<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/callGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  27 #include &quot;ci/ciCallSite.hpp&quot;
  28 #include &quot;ci/ciObjArray.hpp&quot;
  29 #include &quot;ci/ciMemberName.hpp&quot;
  30 #include &quot;ci/ciMethodHandle.hpp&quot;
  31 #include &quot;classfile/javaClasses.hpp&quot;
  32 #include &quot;compiler/compileLog.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/callGenerator.hpp&quot;
  35 #include &quot;opto/callnode.hpp&quot;
  36 #include &quot;opto/castnode.hpp&quot;
  37 #include &quot;opto/cfgnode.hpp&quot;
  38 #include &quot;opto/parse.hpp&quot;
  39 #include &quot;opto/rootnode.hpp&quot;
  40 #include &quot;opto/runtime.hpp&quot;
  41 #include &quot;opto/subnode.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;ci/ciNativeEntryPoint.hpp&quot;
  44 #include &quot;utilities/debug.hpp&quot;
  45 
  46 // Utility function.
  47 const TypeFunc* CallGenerator::tf() const {
  48   return TypeFunc::make(method());
  49 }
  50 
  51 bool CallGenerator::is_inlined_method_handle_intrinsic(JVMState* jvms, ciMethod* m) {
  52   return is_inlined_method_handle_intrinsic(jvms-&gt;method(), jvms-&gt;bci(), m);
  53 }
  54 
  55 bool CallGenerator::is_inlined_method_handle_intrinsic(ciMethod* caller, int bci, ciMethod* m) {
  56   ciMethod* symbolic_info = caller-&gt;get_method_at_bci(bci);
  57   return is_inlined_method_handle_intrinsic(symbolic_info, m);
  58 }
  59 
  60 bool CallGenerator::is_inlined_method_handle_intrinsic(ciMethod* symbolic_info, ciMethod* m) {
  61   return symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !m-&gt;is_method_handle_intrinsic();
  62 }
  63 
  64 //-----------------------------ParseGenerator---------------------------------
  65 // Internal class which handles all direct bytecode traversal.
  66 class ParseGenerator : public InlineCallGenerator {
  67 private:
  68   bool  _is_osr;
  69   float _expected_uses;
  70 
  71 public:
  72   ParseGenerator(ciMethod* method, float expected_uses, bool is_osr = false)
  73     : InlineCallGenerator(method)
  74   {
  75     _is_osr        = is_osr;
  76     _expected_uses = expected_uses;
  77     assert(InlineTree::check_can_parse(method) == NULL, &quot;parse must be possible&quot;);
  78   }
  79 
  80   virtual bool      is_parse() const           { return true; }
  81   virtual JVMState* generate(JVMState* jvms);
  82   int is_osr() { return _is_osr; }
  83 
  84 };
  85 
  86 JVMState* ParseGenerator::generate(JVMState* jvms) {
  87   Compile* C = Compile::current();
  88   C-&gt;print_inlining_update(this);
  89 
  90   if (is_osr()) {
  91     // The JVMS for a OSR has a single argument (see its TypeFunc).
  92     assert(jvms-&gt;depth() == 1, &quot;no inline OSR&quot;);
  93   }
  94 
  95   if (C-&gt;failing()) {
  96     return NULL;  // bailing out of the compile; do not try to parse
  97   }
  98 
  99   Parse parser(jvms, method(), _expected_uses);
 100   // Grab signature for matching/allocation
 101   GraphKit&amp; exits = parser.exits();
 102 
 103   if (C-&gt;failing()) {
 104     while (exits.pop_exception_state() != NULL) ;
 105     return NULL;
 106   }
 107 
 108   assert(exits.jvms()-&gt;same_calls_as(jvms), &quot;sanity&quot;);
 109 
 110   // Simply return the exit state of the parser,
 111   // augmented by any exceptional states.
 112   return exits.transfer_exceptions_into_jvms();
 113 }
 114 
 115 //---------------------------DirectCallGenerator------------------------------
 116 // Internal class which handles all out-of-line calls w/o receiver type checks.
 117 class DirectCallGenerator : public CallGenerator {
 118  private:
 119   CallStaticJavaNode* _call_node;
 120   // Force separate memory and I/O projections for the exceptional
 121   // paths to facilitate late inlinig.
 122   bool                _separate_io_proj;
 123 
 124  public:
 125   DirectCallGenerator(ciMethod* method, bool separate_io_proj)
 126     : CallGenerator(method),
 127       _separate_io_proj(separate_io_proj)
 128   {
 129   }
 130   virtual JVMState* generate(JVMState* jvms);
 131 
 132   CallStaticJavaNode* call_node() const { return _call_node; }
 133 };
 134 
 135 JVMState* DirectCallGenerator::generate(JVMState* jvms) {
 136   GraphKit kit(jvms);
 137   kit.C-&gt;print_inlining_update(this);
 138   bool is_static = method()-&gt;is_static();
 139   address target = is_static ? SharedRuntime::get_resolve_static_call_stub()
 140                              : SharedRuntime::get_resolve_opt_virtual_call_stub();
 141 
 142   if (kit.C-&gt;log() != NULL) {
 143     kit.C-&gt;log()-&gt;elem(&quot;direct_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 144   }
 145 
 146   CallStaticJavaNode *call = new CallStaticJavaNode(kit.C, tf(), target, method(), kit.bci());
 147   if (is_inlined_method_handle_intrinsic(jvms, method())) {
 148     // To be able to issue a direct call and skip a call to MH.linkTo*/invokeBasic adapter,
 149     // additional information about the method being invoked should be attached
 150     // to the call site to make resolution logic work
 151     // (see SharedRuntime::resolve_static_call_C).
 152     call-&gt;set_override_symbolic_info(true);
 153   }
 154   _call_node = call;  // Save the call node in case we need it later
 155   if (!is_static) {
 156     // Make an explicit receiver null_check as part of this call.
 157     // Since we share a map with the caller, his JVMS gets adjusted.
 158     kit.null_check_receiver_before_call(method());
 159     if (kit.stopped()) {
 160       // And dump it back to the caller, decorated with any exceptions:
 161       return kit.transfer_exceptions_into_jvms();
 162     }
 163     // Mark the call node as virtual, sort of:
 164     call-&gt;set_optimized_virtual(true);
 165     if (method()-&gt;is_method_handle_intrinsic() ||
 166         method()-&gt;is_compiled_lambda_form()) {
 167       call-&gt;set_method_handle_invoke(true);
 168     }
 169   }
 170   kit.set_arguments_for_java_call(call);
 171   kit.set_edges_for_java_call(call, false, _separate_io_proj);
 172   Node* ret = kit.set_results_for_java_call(call, _separate_io_proj);
 173   kit.push_node(method()-&gt;return_type()-&gt;basic_type(), ret);
 174   return kit.transfer_exceptions_into_jvms();
 175 }
 176 
 177 //--------------------------VirtualCallGenerator------------------------------
 178 // Internal class which handles all out-of-line calls checking receiver type.
 179 class VirtualCallGenerator : public CallGenerator {
 180 private:
 181   int _vtable_index;
 182 public:
 183   VirtualCallGenerator(ciMethod* method, int vtable_index)
 184     : CallGenerator(method), _vtable_index(vtable_index)
 185   {
 186     assert(vtable_index == Method::invalid_vtable_index ||
 187            vtable_index &gt;= 0, &quot;either invalid or usable&quot;);
 188   }
 189   virtual bool      is_virtual() const          { return true; }
 190   virtual JVMState* generate(JVMState* jvms);
 191 };
 192 
 193 JVMState* VirtualCallGenerator::generate(JVMState* jvms) {
 194   GraphKit kit(jvms);
 195   Node* receiver = kit.argument(0);
 196 
 197   kit.C-&gt;print_inlining_update(this);
 198 
 199   if (kit.C-&gt;log() != NULL) {
 200     kit.C-&gt;log()-&gt;elem(&quot;virtual_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 201   }
 202 
 203   // If the receiver is a constant null, do not torture the system
 204   // by attempting to call through it.  The compile will proceed
 205   // correctly, but may bail out in final_graph_reshaping, because
 206   // the call instruction will have a seemingly deficient out-count.
 207   // (The bailout says something misleading about an &quot;infinite loop&quot;.)
 208   if (kit.gvn().type(receiver)-&gt;higher_equal(TypePtr::NULL_PTR)) {
 209     assert(Bytecodes::is_invoke(kit.java_bc()), &quot;%d: %s&quot;, kit.java_bc(), Bytecodes::name(kit.java_bc()));
 210     ciMethod* declared_method = kit.method()-&gt;get_method_at_bci(kit.bci());
 211     int arg_size = declared_method-&gt;signature()-&gt;arg_size_for_bc(kit.java_bc());
 212     kit.inc_sp(arg_size);  // restore arguments
 213     kit.uncommon_trap(Deoptimization::Reason_null_check,
 214                       Deoptimization::Action_none,
 215                       NULL, &quot;null receiver&quot;);
 216     return kit.transfer_exceptions_into_jvms();
 217   }
 218 
 219   // Ideally we would unconditionally do a null check here and let it
 220   // be converted to an implicit check based on profile information.
 221   // However currently the conversion to implicit null checks in
 222   // Block::implicit_null_check() only looks for loads and stores, not calls.
 223   ciMethod *caller = kit.method();
 224   ciMethodData *caller_md = (caller == NULL) ? NULL : caller-&gt;method_data();
 225   if (!UseInlineCaches || !ImplicitNullChecks || !os::zero_page_read_protected() ||
 226        ((ImplicitNullCheckThreshold &gt; 0) &amp;&amp; caller_md &amp;&amp;
 227        (caller_md-&gt;trap_count(Deoptimization::Reason_null_check)
 228        &gt;= (uint)ImplicitNullCheckThreshold))) {
 229     // Make an explicit receiver null_check as part of this call.
 230     // Since we share a map with the caller, his JVMS gets adjusted.
 231     receiver = kit.null_check_receiver_before_call(method());
 232     if (kit.stopped()) {
 233       // And dump it back to the caller, decorated with any exceptions:
 234       return kit.transfer_exceptions_into_jvms();
 235     }
 236   }
 237 
 238   assert(!method()-&gt;is_static(), &quot;virtual call must not be to static&quot;);
 239   assert(!method()-&gt;is_final(), &quot;virtual call should not be to final&quot;);
 240   assert(!method()-&gt;is_private(), &quot;virtual call should not be to private&quot;);
 241   assert(_vtable_index == Method::invalid_vtable_index || !UseInlineCaches,
 242          &quot;no vtable calls if +UseInlineCaches &quot;);
 243   address target = SharedRuntime::get_resolve_virtual_call_stub();
 244   // Normal inline cache used for call
 245   CallDynamicJavaNode *call = new CallDynamicJavaNode(tf(), target, method(), _vtable_index, kit.bci());
 246   if (is_inlined_method_handle_intrinsic(jvms, method())) {
 247     // To be able to issue a direct call (optimized virtual or virtual)
 248     // and skip a call to MH.linkTo*/invokeBasic adapter, additional information
 249     // about the method being invoked should be attached to the call site to
 250     // make resolution logic work (see SharedRuntime::resolve_{virtual,opt_virtual}_call_C).
 251     call-&gt;set_override_symbolic_info(true);
 252   }
 253   kit.set_arguments_for_java_call(call);
 254   kit.set_edges_for_java_call(call);
 255   Node* ret = kit.set_results_for_java_call(call);
 256   kit.push_node(method()-&gt;return_type()-&gt;basic_type(), ret);
 257 
 258   // Represent the effect of an implicit receiver null_check
 259   // as part of this call.  Since we share a map with the caller,
 260   // his JVMS gets adjusted.
 261   kit.cast_not_null(receiver);
 262   return kit.transfer_exceptions_into_jvms();
 263 }
 264 
 265 CallGenerator* CallGenerator::for_inline(ciMethod* m, float expected_uses) {
 266   if (InlineTree::check_can_parse(m) != NULL)  return NULL;
 267   return new ParseGenerator(m, expected_uses);
 268 }
 269 
 270 // As a special case, the JVMS passed to this CallGenerator is
 271 // for the method execution already in progress, not just the JVMS
 272 // of the caller.  Thus, this CallGenerator cannot be mixed with others!
 273 CallGenerator* CallGenerator::for_osr(ciMethod* m, int osr_bci) {
 274   if (InlineTree::check_can_parse(m) != NULL)  return NULL;
 275   float past_uses = m-&gt;interpreter_invocation_count();
 276   float expected_uses = past_uses;
 277   return new ParseGenerator(m, expected_uses, true);
 278 }
 279 
 280 CallGenerator* CallGenerator::for_direct_call(ciMethod* m, bool separate_io_proj) {
 281   assert(!m-&gt;is_abstract(), &quot;for_direct_call mismatch&quot;);
 282   return new DirectCallGenerator(m, separate_io_proj);
 283 }
 284 
 285 CallGenerator* CallGenerator::for_virtual_call(ciMethod* m, int vtable_index) {
 286   assert(!m-&gt;is_static(), &quot;for_virtual_call mismatch&quot;);
 287   assert(!m-&gt;is_method_handle_intrinsic(), &quot;should be a direct call&quot;);
 288   return new VirtualCallGenerator(m, vtable_index);
 289 }
 290 
 291 // Allow inlining decisions to be delayed
 292 class LateInlineCallGenerator : public DirectCallGenerator {
 293  private:
 294   jlong _unique_id;   // unique id for log compilation
 295   bool _is_pure_call; // a hint that the call doesn&#39;t have important side effects to care about
 296 
 297  protected:
 298   CallGenerator* _inline_cg;
 299   virtual bool do_late_inline_check(JVMState* jvms) { return true; }
 300 
 301  public:
 302   LateInlineCallGenerator(ciMethod* method, CallGenerator* inline_cg, bool is_pure_call = false) :
 303     DirectCallGenerator(method, true), _unique_id(0), _is_pure_call(is_pure_call), _inline_cg(inline_cg) {}
 304 
 305   virtual bool is_late_inline() const { return true; }
 306 
 307   // Convert the CallStaticJava into an inline
 308   virtual void do_late_inline();
 309 
 310   virtual JVMState* generate(JVMState* jvms) {
 311     Compile *C = Compile::current();
 312 
 313     C-&gt;log_inline_id(this);
 314 
 315     // Record that this call site should be revisited once the main
 316     // parse is finished.
 317     if (!is_mh_late_inline()) {
 318       C-&gt;add_late_inline(this);
 319     }
 320 
 321     // Emit the CallStaticJava and request separate projections so
 322     // that the late inlining logic can distinguish between fall
 323     // through and exceptional uses of the memory and io projections
 324     // as is done for allocations and macro expansion.
 325     return DirectCallGenerator::generate(jvms);
 326   }
 327 
 328   virtual void print_inlining_late(const char* msg) {
 329     CallNode* call = call_node();
 330     Compile* C = Compile::current();
 331     C-&gt;print_inlining_assert_ready();
 332     C-&gt;print_inlining(method(), call-&gt;jvms()-&gt;depth()-1, call-&gt;jvms()-&gt;bci(), msg);
 333     C-&gt;print_inlining_move_to(this);
 334     C-&gt;print_inlining_update_delayed(this);
 335   }
 336 
 337   virtual void set_unique_id(jlong id) {
 338     _unique_id = id;
 339   }
 340 
 341   virtual jlong unique_id() const {
 342     return _unique_id;
 343   }
 344 };
 345 
 346 void LateInlineCallGenerator::do_late_inline() {
 347   // Can&#39;t inline it
 348   CallStaticJavaNode* call = call_node();
 349   if (call == NULL || call-&gt;outcnt() == 0 ||
 350       call-&gt;in(0) == NULL || call-&gt;in(0)-&gt;is_top()) {
 351     return;
 352   }
 353 
 354   const TypeTuple *r = call-&gt;tf()-&gt;domain();
 355   for (int i1 = 0; i1 &lt; method()-&gt;arg_size(); i1++) {
 356     if (call-&gt;in(TypeFunc::Parms + i1)-&gt;is_top() &amp;&amp; r-&gt;field_at(TypeFunc::Parms + i1) != Type::HALF) {
 357       assert(Compile::current()-&gt;inlining_incrementally(), &quot;shouldn&#39;t happen during parsing&quot;);
 358       return;
 359     }
 360   }
 361 
 362   if (call-&gt;in(TypeFunc::Memory)-&gt;is_top()) {
 363     assert(Compile::current()-&gt;inlining_incrementally(), &quot;shouldn&#39;t happen during parsing&quot;);
 364     return;
 365   }
 366 
 367   // check for unreachable loop
 368   CallProjections callprojs;
 369   call-&gt;extract_projections(&amp;callprojs, true);
 370   if (callprojs.fallthrough_catchproj == call-&gt;in(0) ||
 371       callprojs.catchall_catchproj == call-&gt;in(0) ||
 372       callprojs.fallthrough_memproj == call-&gt;in(TypeFunc::Memory) ||
 373       callprojs.catchall_memproj == call-&gt;in(TypeFunc::Memory) ||
 374       callprojs.fallthrough_ioproj == call-&gt;in(TypeFunc::I_O) ||
 375       callprojs.catchall_ioproj == call-&gt;in(TypeFunc::I_O) ||
 376       (callprojs.resproj != NULL &amp;&amp; call-&gt;find_edge(callprojs.resproj) != -1) ||
 377       (callprojs.exobj != NULL &amp;&amp; call-&gt;find_edge(callprojs.exobj) != -1)) {
 378     return;
 379   }
 380 
 381   Compile* C = Compile::current();
 382   // Remove inlined methods from Compiler&#39;s lists.
 383   if (call-&gt;is_macro()) {
 384     C-&gt;remove_macro_node(call);
 385   }
 386 
 387   bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj-&gt;outcnt() == 0);
 388   if (_is_pure_call &amp;&amp; result_not_used) {
 389     // The call is marked as pure (no important side effects), but result isn&#39;t used.
 390     // It&#39;s safe to remove the call.
 391     GraphKit kit(call-&gt;jvms());
 392     kit.replace_call(call, C-&gt;top(), true);
 393   } else {
 394     // Make a clone of the JVMState that appropriate to use for driving a parse
 395     JVMState* old_jvms = call-&gt;jvms();
 396     JVMState* jvms = old_jvms-&gt;clone_shallow(C);
 397     uint size = call-&gt;req();
 398     SafePointNode* map = new SafePointNode(size, jvms);
 399     for (uint i1 = 0; i1 &lt; size; i1++) {
 400       map-&gt;init_req(i1, call-&gt;in(i1));
 401     }
 402 
 403     // Make sure the state is a MergeMem for parsing.
 404     if (!map-&gt;in(TypeFunc::Memory)-&gt;is_MergeMem()) {
 405       Node* mem = MergeMemNode::make(map-&gt;in(TypeFunc::Memory));
 406       C-&gt;initial_gvn()-&gt;set_type_bottom(mem);
 407       map-&gt;set_req(TypeFunc::Memory, mem);
 408     }
 409 
 410     uint nargs = method()-&gt;arg_size();
 411     // blow away old call arguments
 412     Node* top = C-&gt;top();
 413     for (uint i1 = 0; i1 &lt; nargs; i1++) {
 414       map-&gt;set_req(TypeFunc::Parms + i1, top);
 415     }
 416     jvms-&gt;set_map(map);
 417 
 418     // Make enough space in the expression stack to transfer
 419     // the incoming arguments and return value.
 420     map-&gt;ensure_stack(jvms, jvms-&gt;method()-&gt;max_stack());
 421     for (uint i1 = 0; i1 &lt; nargs; i1++) {
 422       map-&gt;set_argument(jvms, i1, call-&gt;in(TypeFunc::Parms + i1));
 423     }
 424 
 425     C-&gt;print_inlining_assert_ready();
 426 
 427     C-&gt;print_inlining_move_to(this);
 428 
 429     C-&gt;log_late_inline(this);
 430 
 431     // This check is done here because for_method_handle_inline() method
 432     // needs jvms for inlined state.
 433     if (!do_late_inline_check(jvms)) {
 434       map-&gt;disconnect_inputs(NULL, C);
 435       return;
 436     }
 437 
 438     // Setup default node notes to be picked up by the inlining
 439     Node_Notes* old_nn = C-&gt;node_notes_at(call-&gt;_idx);
 440     if (old_nn != NULL) {
 441       Node_Notes* entry_nn = old_nn-&gt;clone(C);
 442       entry_nn-&gt;set_jvms(jvms);
 443       C-&gt;set_default_node_notes(entry_nn);
 444     }
 445 
 446     // Now perform the inlining using the synthesized JVMState
 447     JVMState* new_jvms = _inline_cg-&gt;generate(jvms);
 448     if (new_jvms == NULL)  return;  // no change
 449     if (C-&gt;failing())      return;
 450 
 451     // Capture any exceptional control flow
 452     GraphKit kit(new_jvms);
 453 
 454     // Find the result object
 455     Node* result = C-&gt;top();
 456     int   result_size = method()-&gt;return_type()-&gt;size();
 457     if (result_size != 0 &amp;&amp; !kit.stopped()) {
 458       result = (result_size == 1) ? kit.pop() : kit.pop_pair();
 459     }
 460 
 461     C-&gt;set_has_loops(C-&gt;has_loops() || _inline_cg-&gt;method()-&gt;has_loops());
 462     C-&gt;env()-&gt;notice_inlined_method(_inline_cg-&gt;method());
 463     C-&gt;set_inlining_progress(true);
 464     C-&gt;set_do_cleanup(kit.stopped()); // path is dead; needs cleanup
 465     kit.replace_call(call, result, true);
 466   }
 467 }
 468 
 469 
 470 CallGenerator* CallGenerator::for_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 471   return new LateInlineCallGenerator(method, inline_cg);
 472 }
 473 
 474 class LateInlineMHCallGenerator : public LateInlineCallGenerator {
 475   ciMethod* _caller;
 476   int _attempt;
 477   bool _input_not_const;
 478 
 479   virtual bool do_late_inline_check(JVMState* jvms);
 480   virtual bool already_attempted() const { return _attempt &gt; 0; }
 481 
 482  public:
 483   LateInlineMHCallGenerator(ciMethod* caller, ciMethod* callee, bool input_not_const) :
 484     LateInlineCallGenerator(callee, NULL), _caller(caller), _attempt(0), _input_not_const(input_not_const) {}
 485 
 486   virtual bool is_mh_late_inline() const { return true; }
 487 
 488   virtual JVMState* generate(JVMState* jvms) {
 489     JVMState* new_jvms = LateInlineCallGenerator::generate(jvms);
 490 
 491     Compile* C = Compile::current();
 492     if (_input_not_const) {
 493       // inlining won&#39;t be possible so no need to enqueue right now.
 494       call_node()-&gt;set_generator(this);
 495     } else {
 496       C-&gt;add_late_inline(this);
 497     }
 498     return new_jvms;
 499   }
 500 };
 501 
 502 bool LateInlineMHCallGenerator::do_late_inline_check(JVMState* jvms) {
 503 
 504   CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), _input_not_const);
 505 
 506   Compile::current()-&gt;print_inlining_update_delayed(this);
 507 
 508   if (!_input_not_const) {
 509     _attempt++;
 510   }
 511 
 512   if (cg != NULL &amp;&amp; cg-&gt;is_inline()) {
 513     assert(!cg-&gt;is_late_inline(), &quot;we&#39;re doing late inlining&quot;);
 514     _inline_cg = cg;
 515     Compile::current()-&gt;dec_number_of_mh_late_inlines();
 516     return true;
 517   }
 518 
 519   call_node()-&gt;set_generator(this);
 520   return false;
 521 }
 522 
 523 CallGenerator* CallGenerator::for_mh_late_inline(ciMethod* caller, ciMethod* callee, bool input_not_const) {
 524   Compile::current()-&gt;inc_number_of_mh_late_inlines();
 525   CallGenerator* cg = new LateInlineMHCallGenerator(caller, callee, input_not_const);
 526   return cg;
 527 }
 528 
 529 class LateInlineStringCallGenerator : public LateInlineCallGenerator {
 530 
 531  public:
 532   LateInlineStringCallGenerator(ciMethod* method, CallGenerator* inline_cg) :
 533     LateInlineCallGenerator(method, inline_cg) {}
 534 
 535   virtual JVMState* generate(JVMState* jvms) {
 536     Compile *C = Compile::current();
 537 
 538     C-&gt;log_inline_id(this);
 539 
 540     C-&gt;add_string_late_inline(this);
 541 
 542     JVMState* new_jvms =  DirectCallGenerator::generate(jvms);
 543     return new_jvms;
 544   }
 545 
 546   virtual bool is_string_late_inline() const { return true; }
 547 };
 548 
 549 CallGenerator* CallGenerator::for_string_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 550   return new LateInlineStringCallGenerator(method, inline_cg);
 551 }
 552 
 553 class LateInlineBoxingCallGenerator : public LateInlineCallGenerator {
 554 
 555  public:
 556   LateInlineBoxingCallGenerator(ciMethod* method, CallGenerator* inline_cg) :
 557     LateInlineCallGenerator(method, inline_cg, /*is_pure=*/true) {}
 558 
 559   virtual JVMState* generate(JVMState* jvms) {
 560     Compile *C = Compile::current();
 561 
 562     C-&gt;log_inline_id(this);
 563 
 564     C-&gt;add_boxing_late_inline(this);
 565 
 566     JVMState* new_jvms =  DirectCallGenerator::generate(jvms);
 567     return new_jvms;
 568   }
 569 };
 570 
 571 CallGenerator* CallGenerator::for_boxing_late_inline(ciMethod* method, CallGenerator* inline_cg) {
 572   return new LateInlineBoxingCallGenerator(method, inline_cg);
 573 }
 574 
 575 //---------------------------WarmCallGenerator--------------------------------
 576 // Internal class which handles initial deferral of inlining decisions.
 577 class WarmCallGenerator : public CallGenerator {
 578   WarmCallInfo*   _call_info;
 579   CallGenerator*  _if_cold;
 580   CallGenerator*  _if_hot;
 581   bool            _is_virtual;   // caches virtuality of if_cold
 582   bool            _is_inline;    // caches inline-ness of if_hot
 583 
 584 public:
 585   WarmCallGenerator(WarmCallInfo* ci,
 586                     CallGenerator* if_cold,
 587                     CallGenerator* if_hot)
 588     : CallGenerator(if_cold-&gt;method())
 589   {
 590     assert(method() == if_hot-&gt;method(), &quot;consistent choices&quot;);
 591     _call_info  = ci;
 592     _if_cold    = if_cold;
 593     _if_hot     = if_hot;
 594     _is_virtual = if_cold-&gt;is_virtual();
 595     _is_inline  = if_hot-&gt;is_inline();
 596   }
 597 
 598   virtual bool      is_inline() const           { return _is_inline; }
 599   virtual bool      is_virtual() const          { return _is_virtual; }
 600   virtual bool      is_deferred() const         { return true; }
 601 
 602   virtual JVMState* generate(JVMState* jvms);
 603 };
 604 
 605 
 606 CallGenerator* CallGenerator::for_warm_call(WarmCallInfo* ci,
 607                                             CallGenerator* if_cold,
 608                                             CallGenerator* if_hot) {
 609   return new WarmCallGenerator(ci, if_cold, if_hot);
 610 }
 611 
 612 JVMState* WarmCallGenerator::generate(JVMState* jvms) {
 613   Compile* C = Compile::current();
 614   C-&gt;print_inlining_update(this);
 615 
 616   if (C-&gt;log() != NULL) {
 617     C-&gt;log()-&gt;elem(&quot;warm_call bci=&#39;%d&#39;&quot;, jvms-&gt;bci());
 618   }
 619   jvms = _if_cold-&gt;generate(jvms);
 620   if (jvms != NULL) {
 621     Node* m = jvms-&gt;map()-&gt;control();
 622     if (m-&gt;is_CatchProj()) m = m-&gt;in(0);  else m = C-&gt;top();
 623     if (m-&gt;is_Catch())     m = m-&gt;in(0);  else m = C-&gt;top();
 624     if (m-&gt;is_Proj())      m = m-&gt;in(0);  else m = C-&gt;top();
 625     if (m-&gt;is_CallJava()) {
 626       _call_info-&gt;set_call(m-&gt;as_Call());
 627       _call_info-&gt;set_hot_cg(_if_hot);
 628 #ifndef PRODUCT
 629       if (PrintOpto || PrintOptoInlining) {
 630         tty-&gt;print_cr(&quot;Queueing for warm inlining at bci %d:&quot;, jvms-&gt;bci());
 631         tty-&gt;print(&quot;WCI: &quot;);
 632         _call_info-&gt;print();
 633       }
 634 #endif
 635       _call_info-&gt;set_heat(_call_info-&gt;compute_heat());
 636       C-&gt;set_warm_calls(_call_info-&gt;insert_into(C-&gt;warm_calls()));
 637     }
 638   }
 639   return jvms;
 640 }
 641 
 642 void WarmCallInfo::make_hot() {
 643   Unimplemented();
 644 }
 645 
 646 void WarmCallInfo::make_cold() {
 647   // No action:  Just dequeue.
 648 }
 649 
 650 
 651 //------------------------PredictedCallGenerator------------------------------
 652 // Internal class which handles all out-of-line calls checking receiver type.
 653 class PredictedCallGenerator : public CallGenerator {
 654   ciKlass*       _predicted_receiver;
 655   CallGenerator* _if_missed;
 656   CallGenerator* _if_hit;
 657   float          _hit_prob;
 658   bool           _exact_check;
 659 
 660 public:
 661   PredictedCallGenerator(ciKlass* predicted_receiver,
 662                          CallGenerator* if_missed,
 663                          CallGenerator* if_hit, bool exact_check,
 664                          float hit_prob)
 665     : CallGenerator(if_missed-&gt;method())
 666   {
 667     // The call profile data may predict the hit_prob as extreme as 0 or 1.
 668     // Remove the extremes values from the range.
 669     if (hit_prob &gt; PROB_MAX)   hit_prob = PROB_MAX;
 670     if (hit_prob &lt; PROB_MIN)   hit_prob = PROB_MIN;
 671 
 672     _predicted_receiver = predicted_receiver;
 673     _if_missed          = if_missed;
 674     _if_hit             = if_hit;
 675     _hit_prob           = hit_prob;
 676     _exact_check        = exact_check;
 677   }
 678 
 679   virtual bool      is_virtual()   const    { return true; }
 680   virtual bool      is_inline()    const    { return _if_hit-&gt;is_inline(); }
 681   virtual bool      is_deferred()  const    { return _if_hit-&gt;is_deferred(); }
 682 
 683   virtual JVMState* generate(JVMState* jvms);
 684 };
 685 
 686 
 687 CallGenerator* CallGenerator::for_predicted_call(ciKlass* predicted_receiver,
 688                                                  CallGenerator* if_missed,
 689                                                  CallGenerator* if_hit,
 690                                                  float hit_prob) {
 691   return new PredictedCallGenerator(predicted_receiver, if_missed, if_hit,
 692                                     /*exact_check=*/true, hit_prob);
 693 }
 694 
 695 CallGenerator* CallGenerator::for_guarded_call(ciKlass* guarded_receiver,
 696                                                CallGenerator* if_missed,
 697                                                CallGenerator* if_hit) {
 698   return new PredictedCallGenerator(guarded_receiver, if_missed, if_hit,
 699                                     /*exact_check=*/false, PROB_ALWAYS);
 700 }
 701 
 702 JVMState* PredictedCallGenerator::generate(JVMState* jvms) {
 703   GraphKit kit(jvms);
 704   kit.C-&gt;print_inlining_update(this);
 705   PhaseGVN&amp; gvn = kit.gvn();
 706   // We need an explicit receiver null_check before checking its type.
 707   // We share a map with the caller, so his JVMS gets adjusted.
 708   Node* receiver = kit.argument(0);
 709   CompileLog* log = kit.C-&gt;log();
 710   if (log != NULL) {
 711     log-&gt;elem(&quot;predicted_call bci=&#39;%d&#39; exact=&#39;%d&#39; klass=&#39;%d&#39;&quot;,
 712               jvms-&gt;bci(), (_exact_check ? 1 : 0), log-&gt;identify(_predicted_receiver));
 713   }
 714 
 715   receiver = kit.null_check_receiver_before_call(method());
 716   if (kit.stopped()) {
 717     return kit.transfer_exceptions_into_jvms();
 718   }
 719 
 720   // Make a copy of the replaced nodes in case we need to restore them
 721   ReplacedNodes replaced_nodes = kit.map()-&gt;replaced_nodes();
 722   replaced_nodes.clone();
 723 
 724   Node* casted_receiver = receiver;  // will get updated in place...
 725   Node* slow_ctl = NULL;
 726   if (_exact_check) {
 727     slow_ctl = kit.type_check_receiver(receiver, _predicted_receiver, _hit_prob,
 728                                        &amp;casted_receiver);
 729   } else {
 730     slow_ctl = kit.subtype_check_receiver(receiver, _predicted_receiver,
 731                                           &amp;casted_receiver);
 732   }
 733 
 734   SafePointNode* slow_map = NULL;
 735   JVMState* slow_jvms = NULL;
 736   { PreserveJVMState pjvms(&amp;kit);
 737     kit.set_control(slow_ctl);
 738     if (!kit.stopped()) {
 739       slow_jvms = _if_missed-&gt;generate(kit.sync_jvms());
 740       if (kit.failing())
 741         return NULL;  // might happen because of NodeCountInliningCutoff
 742       assert(slow_jvms != NULL, &quot;must be&quot;);
 743       kit.add_exception_states_from(slow_jvms);
 744       kit.set_map(slow_jvms-&gt;map());
 745       if (!kit.stopped())
 746         slow_map = kit.stop();
 747     }
 748   }
 749 
 750   if (kit.stopped()) {
 751     // Instance exactly does not matches the desired type.
 752     kit.set_jvms(slow_jvms);
 753     return kit.transfer_exceptions_into_jvms();
 754   }
 755 
 756   // fall through if the instance exactly matches the desired type
 757   kit.replace_in_map(receiver, casted_receiver);
 758 
 759   // Make the hot call:
 760   JVMState* new_jvms = _if_hit-&gt;generate(kit.sync_jvms());
 761   if (new_jvms == NULL) {
 762     // Inline failed, so make a direct call.
 763     assert(_if_hit-&gt;is_inline(), &quot;must have been a failed inline&quot;);
 764     CallGenerator* cg = CallGenerator::for_direct_call(_if_hit-&gt;method());
 765     new_jvms = cg-&gt;generate(kit.sync_jvms());
 766   }
 767   kit.add_exception_states_from(new_jvms);
 768   kit.set_jvms(new_jvms);
 769 
 770   // Need to merge slow and fast?
 771   if (slow_map == NULL) {
 772     // The fast path is the only path remaining.
 773     return kit.transfer_exceptions_into_jvms();
 774   }
 775 
 776   if (kit.stopped()) {
 777     // Inlined method threw an exception, so it&#39;s just the slow path after all.
 778     kit.set_jvms(slow_jvms);
 779     return kit.transfer_exceptions_into_jvms();
 780   }
 781 
 782   // There are 2 branches and the replaced nodes are only valid on
 783   // one: restore the replaced nodes to what they were before the
 784   // branch.
 785   kit.map()-&gt;set_replaced_nodes(replaced_nodes);
 786 
 787   // Finish the diamond.
 788   kit.C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
 789   RegionNode* region = new RegionNode(3);
 790   region-&gt;init_req(1, kit.control());
 791   region-&gt;init_req(2, slow_map-&gt;control());
 792   kit.set_control(gvn.transform(region));
 793   Node* iophi = PhiNode::make(region, kit.i_o(), Type::ABIO);
 794   iophi-&gt;set_req(2, slow_map-&gt;i_o());
 795   kit.set_i_o(gvn.transform(iophi));
 796   // Merge memory
 797   kit.merge_memory(slow_map-&gt;merged_memory(), region, 2);
 798   // Transform new memory Phis.
 799   for (MergeMemStream mms(kit.merged_memory()); mms.next_non_empty();) {
 800     Node* phi = mms.memory();
 801     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == region) {
 802       mms.set_memory(gvn.transform(phi));
 803     }
 804   }
 805   uint tos = kit.jvms()-&gt;stkoff() + kit.sp();
 806   uint limit = slow_map-&gt;req();
 807   for (uint i = TypeFunc::Parms; i &lt; limit; i++) {
 808     // Skip unused stack slots; fast forward to monoff();
 809     if (i == tos) {
 810       i = kit.jvms()-&gt;monoff();
 811       if( i &gt;= limit ) break;
 812     }
 813     Node* m = kit.map()-&gt;in(i);
 814     Node* n = slow_map-&gt;in(i);
 815     if (m != n) {
 816       const Type* t = gvn.type(m)-&gt;meet_speculative(gvn.type(n));
 817       Node* phi = PhiNode::make(region, m, t);
 818       phi-&gt;set_req(2, n);
 819       kit.map()-&gt;set_req(i, gvn.transform(phi));
 820     }
 821   }
 822   return kit.transfer_exceptions_into_jvms();
 823 }
 824 
 825 
 826 CallGenerator* CallGenerator::for_method_handle_call(JVMState* jvms, ciMethod* caller, ciMethod* callee) {
 827   assert(callee-&gt;is_method_handle_intrinsic(), &quot;for_method_handle_call mismatch&quot;);
 828   bool input_not_const;
 829   CallGenerator* cg = CallGenerator::for_method_handle_inline(jvms, caller, callee, input_not_const);
 830   Compile* C = Compile::current();
 831   if (cg != NULL) {
 832     if (AlwaysIncrementalInline) {
 833       return CallGenerator::for_late_inline(callee, cg);
 834     } else {
 835       return cg;
 836     }
 837   }
 838   int bci = jvms-&gt;bci();
 839   ciCallProfile profile = caller-&gt;call_profile_at_bci(bci);
 840   int call_site_count = caller-&gt;scale_count(profile.count());
 841 
 842   if (IncrementalInline &amp;&amp; call_site_count &gt; 0 &amp;&amp;
 843       (input_not_const || !C-&gt;inlining_incrementally() || C-&gt;over_inlining_cutoff())) {
 844     return CallGenerator::for_mh_late_inline(caller, callee, input_not_const);
 845   } else {
 846     // Out-of-line call.
 847     return CallGenerator::for_direct_call(callee);
 848   }
 849 }
 850 
 851 class NativeCallGenerator : public CallGenerator {
 852 private:
 853   ciNativeEntryPoint* _nep;
 854 public:
 855   NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)
 856    : CallGenerator(m), _nep(nep) {}
 857 
 858   virtual JVMState* generate(JVMState* jvms);
 859 };
 860 
 861 JVMState* NativeCallGenerator::generate(JVMState* jvms) {
 862   GraphKit kit(jvms);
 863 
 864   Node* call = kit.make_native_call(tf(), method()-&gt;arg_size(), _nep); // -fallback, - nep
 865 
 866   kit.C-&gt;print_inlining_update(this);
 867   address addr = _nep-&gt;entry_point();
 868   if (kit.C-&gt;log() != NULL) {
 869     kit.C-&gt;log()-&gt;elem(&quot;l2n_intrinsification_success bci=&#39;%d&#39; entry_point=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;, jvms-&gt;bci(), p2i(addr));
 870   }
 871 
 872   return kit.transfer_exceptions_into_jvms();
 873 }
 874 
 875 CallGenerator* CallGenerator::for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool&amp; input_not_const) {
 876   GraphKit kit(jvms);
 877   PhaseGVN&amp; gvn = kit.gvn();
 878   Compile* C = kit.C;
 879   vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 880   input_not_const = true;
 881   switch (iid) {
 882   case vmIntrinsics::_invokeBasic:
 883     {
 884       // Get MethodHandle receiver:
 885       Node* receiver = kit.argument(0);
 886       if (receiver-&gt;Opcode() == Op_ConP) {
 887         input_not_const = false;
 888         const TypeOopPtr* oop_ptr = receiver-&gt;bottom_type()-&gt;is_oopptr();
 889         ciMethod* target = oop_ptr-&gt;const_oop()-&gt;as_method_handle()-&gt;get_vmtarget();
 890         const int vtable_index = Method::invalid_vtable_index;
 891 
 892         if (!ciMethod::is_consistent_info(callee, target)) {
 893           print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
 894                                  &quot;signatures mismatch&quot;);
 895           return NULL;
 896         }
 897 
 898         CallGenerator* cg = C-&gt;call_generator(target, vtable_index,
 899                                               false /* call_does_dispatch */,
 900                                               jvms,
 901                                               true /* allow_inline */,
 902                                               PROB_ALWAYS);
 903         return cg;
 904       } else {
 905         print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
 906                                &quot;receiver not constant&quot;);
 907       }
 908     }
 909     break;
 910 
 911   case vmIntrinsics::_linkToVirtual:
 912   case vmIntrinsics::_linkToStatic:
 913   case vmIntrinsics::_linkToSpecial:
 914   case vmIntrinsics::_linkToInterface:
 915     {
 916       // Get MemberName argument:
 917       Node* member_name = kit.argument(callee-&gt;arg_size() - 1);
 918       if (member_name-&gt;Opcode() == Op_ConP) {
 919         input_not_const = false;
 920         const TypeOopPtr* oop_ptr = member_name-&gt;bottom_type()-&gt;is_oopptr();
 921         ciMethod* target = oop_ptr-&gt;const_oop()-&gt;as_member_name()-&gt;get_vmtarget();
 922 
 923         if (!ciMethod::is_consistent_info(callee, target)) {
 924           print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
 925                                  &quot;signatures mismatch&quot;);
 926           return NULL;
 927         }
 928 
 929         // In lambda forms we erase signature types to avoid resolving issues
 930         // involving class loaders.  When we optimize a method handle invoke
 931         // to a direct call we must cast the receiver and arguments to its
 932         // actual types.
 933         ciSignature* signature = target-&gt;signature();
 934         const int receiver_skip = target-&gt;is_static() ? 0 : 1;
 935         // Cast receiver to its type.
 936         if (!target-&gt;is_static()) {
 937           Node* arg = kit.argument(0);
 938           const TypeOopPtr* arg_type = arg-&gt;bottom_type()-&gt;isa_oopptr();
 939           const Type*       sig_type = TypeOopPtr::make_from_klass(signature-&gt;accessing_klass());
 940           if (arg_type != NULL &amp;&amp; !arg_type-&gt;higher_equal(sig_type)) {
 941             const Type* recv_type = arg_type-&gt;join_speculative(sig_type); // keep speculative part
 942             Node* cast_obj = gvn.transform(new CheckCastPPNode(kit.control(), arg, recv_type));
 943             kit.set_argument(0, cast_obj);
 944           }
 945         }
 946         // Cast reference arguments to its type.
 947         for (int i = 0, j = 0; i &lt; signature-&gt;count(); i++) {
 948           ciType* t = signature-&gt;type_at(i);
 949           if (t-&gt;is_klass()) {
 950             Node* arg = kit.argument(receiver_skip + j);
 951             const TypeOopPtr* arg_type = arg-&gt;bottom_type()-&gt;isa_oopptr();
 952             const Type*       sig_type = TypeOopPtr::make_from_klass(t-&gt;as_klass());
 953             if (arg_type != NULL &amp;&amp; !arg_type-&gt;higher_equal(sig_type)) {
 954               const Type* narrowed_arg_type = arg_type-&gt;join_speculative(sig_type); // keep speculative part
 955               Node* cast_obj = gvn.transform(new CheckCastPPNode(kit.control(), arg, narrowed_arg_type));
 956               kit.set_argument(receiver_skip + j, cast_obj);
 957             }
 958           }
 959           j += t-&gt;size();  // long and double take two slots
 960         }
 961 
 962         // Try to get the most accurate receiver type
 963         const bool is_virtual              = (iid == vmIntrinsics::_linkToVirtual);
 964         const bool is_virtual_or_interface = (is_virtual || iid == vmIntrinsics::_linkToInterface);
 965         int  vtable_index       = Method::invalid_vtable_index;
 966         bool call_does_dispatch = false;
 967 
 968         ciKlass* speculative_receiver_type = NULL;
 969         if (is_virtual_or_interface) {
 970           ciInstanceKlass* klass = target-&gt;holder();
 971           Node*             receiver_node = kit.argument(0);
 972           const TypeOopPtr* receiver_type = gvn.type(receiver_node)-&gt;isa_oopptr();
 973           // call_does_dispatch and vtable_index are out-parameters.  They might be changed.
 974           // optimize_virtual_call() takes 2 different holder
 975           // arguments for a corner case that doesn&#39;t apply here (see
 976           // Parse::do_call())
 977           target = C-&gt;optimize_virtual_call(caller, jvms-&gt;bci(), klass, klass,
 978                                             target, receiver_type, is_virtual,
 979                                             call_does_dispatch, vtable_index, // out-parameters
 980                                             false /* check_access */);
 981           // We lack profiling at this call but type speculation may
 982           // provide us with a type
 983           speculative_receiver_type = (receiver_type != NULL) ? receiver_type-&gt;speculative_type() : NULL;
 984         }
 985         CallGenerator* cg = C-&gt;call_generator(target, vtable_index, call_does_dispatch, jvms,
 986                                               !StressMethodHandleLinkerInlining /* allow_inline */,
 987                                               PROB_ALWAYS,
 988                                               speculative_receiver_type);
 989         return cg;
 990       } else {
 991         print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
 992                                &quot;member_name not constant&quot;);
 993       }
 994     }
 995     break;
 996 
 997     case vmIntrinsics::_linkToNative:
 998     {
 999       Node* nep = kit.argument(callee-&gt;arg_size() - 1);
1000       if (nep-&gt;Opcode() == Op_ConP) {
1001         const TypeOopPtr* oop_ptr = nep-&gt;bottom_type()-&gt;is_oopptr();
1002         ciNativeEntryPoint* nep = oop_ptr-&gt;const_oop()-&gt;as_native_entry_point();
1003         return new NativeCallGenerator(callee, nep);
1004       } else {
<a name="1" id="anc1"></a>
1005         print_inlining_failure(C, callee, jvms-&gt;depth() - 1, jvms-&gt;bci(),
1006                                &quot;NativeEntryPoint not constant&quot;);
1007       }
1008     }
1009     break;
1010 
1011   default:
1012     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
1013     break;
1014   }
1015   return NULL;
1016 }
1017 
1018 
1019 //------------------------PredicatedIntrinsicGenerator------------------------------
1020 // Internal class which handles all predicated Intrinsic calls.
1021 class PredicatedIntrinsicGenerator : public CallGenerator {
1022   CallGenerator* _intrinsic;
1023   CallGenerator* _cg;
1024 
1025 public:
1026   PredicatedIntrinsicGenerator(CallGenerator* intrinsic,
1027                                CallGenerator* cg)
1028     : CallGenerator(cg-&gt;method())
1029   {
1030     _intrinsic = intrinsic;
1031     _cg        = cg;
1032   }
1033 
1034   virtual bool      is_virtual()   const    { return true; }
1035   virtual bool      is_inlined()   const    { return true; }
1036   virtual bool      is_intrinsic() const    { return true; }
1037 
1038   virtual JVMState* generate(JVMState* jvms);
1039 };
1040 
1041 
1042 CallGenerator* CallGenerator::for_predicated_intrinsic(CallGenerator* intrinsic,
1043                                                        CallGenerator* cg) {
1044   return new PredicatedIntrinsicGenerator(intrinsic, cg);
1045 }
1046 
1047 
1048 JVMState* PredicatedIntrinsicGenerator::generate(JVMState* jvms) {
1049   // The code we want to generate here is:
1050   //    if (receiver == NULL)
1051   //        uncommon_Trap
1052   //    if (predicate(0))
1053   //        do_intrinsic(0)
1054   //    else
1055   //    if (predicate(1))
1056   //        do_intrinsic(1)
1057   //    ...
1058   //    else
1059   //        do_java_comp
1060 
1061   GraphKit kit(jvms);
1062   PhaseGVN&amp; gvn = kit.gvn();
1063 
1064   CompileLog* log = kit.C-&gt;log();
1065   if (log != NULL) {
1066     log-&gt;elem(&quot;predicated_intrinsic bci=&#39;%d&#39; method=&#39;%d&#39;&quot;,
1067               jvms-&gt;bci(), log-&gt;identify(method()));
1068   }
1069 
1070   if (!method()-&gt;is_static()) {
1071     // We need an explicit receiver null_check before checking its type in predicate.
1072     // We share a map with the caller, so his JVMS gets adjusted.
1073     Node* receiver = kit.null_check_receiver_before_call(method());
1074     if (kit.stopped()) {
1075       return kit.transfer_exceptions_into_jvms();
1076     }
1077   }
1078 
1079   int n_predicates = _intrinsic-&gt;predicates_count();
1080   assert(n_predicates &gt; 0, &quot;sanity&quot;);
1081 
1082   JVMState** result_jvms = NEW_RESOURCE_ARRAY(JVMState*, (n_predicates+1));
1083 
1084   // Region for normal compilation code if intrinsic failed.
1085   Node* slow_region = new RegionNode(1);
1086 
1087   int results = 0;
1088   for (int predicate = 0; (predicate &lt; n_predicates) &amp;&amp; !kit.stopped(); predicate++) {
1089 #ifdef ASSERT
1090     JVMState* old_jvms = kit.jvms();
1091     SafePointNode* old_map = kit.map();
1092     Node* old_io  = old_map-&gt;i_o();
1093     Node* old_mem = old_map-&gt;memory();
1094     Node* old_exc = old_map-&gt;next_exception();
1095 #endif
1096     Node* else_ctrl = _intrinsic-&gt;generate_predicate(kit.sync_jvms(), predicate);
1097 #ifdef ASSERT
1098     // Assert(no_new_memory &amp;&amp; no_new_io &amp;&amp; no_new_exceptions) after generate_predicate.
1099     assert(old_jvms == kit.jvms(), &quot;generate_predicate should not change jvm state&quot;);
1100     SafePointNode* new_map = kit.map();
1101     assert(old_io  == new_map-&gt;i_o(), &quot;generate_predicate should not change i_o&quot;);
1102     assert(old_mem == new_map-&gt;memory(), &quot;generate_predicate should not change memory&quot;);
1103     assert(old_exc == new_map-&gt;next_exception(), &quot;generate_predicate should not add exceptions&quot;);
1104 #endif
1105     if (!kit.stopped()) {
1106       PreserveJVMState pjvms(&amp;kit);
1107       // Generate intrinsic code:
1108       JVMState* new_jvms = _intrinsic-&gt;generate(kit.sync_jvms());
1109       if (new_jvms == NULL) {
1110         // Intrinsic failed, use normal compilation path for this predicate.
1111         slow_region-&gt;add_req(kit.control());
1112       } else {
1113         kit.add_exception_states_from(new_jvms);
1114         kit.set_jvms(new_jvms);
1115         if (!kit.stopped()) {
1116           result_jvms[results++] = kit.jvms();
1117         }
1118       }
1119     }
1120     if (else_ctrl == NULL) {
1121       else_ctrl = kit.C-&gt;top();
1122     }
1123     kit.set_control(else_ctrl);
1124   }
1125   if (!kit.stopped()) {
1126     // Final &#39;else&#39; after predicates.
1127     slow_region-&gt;add_req(kit.control());
1128   }
1129   if (slow_region-&gt;req() &gt; 1) {
1130     PreserveJVMState pjvms(&amp;kit);
1131     // Generate normal compilation code:
1132     kit.set_control(gvn.transform(slow_region));
1133     JVMState* new_jvms = _cg-&gt;generate(kit.sync_jvms());
1134     if (kit.failing())
1135       return NULL;  // might happen because of NodeCountInliningCutoff
1136     assert(new_jvms != NULL, &quot;must be&quot;);
1137     kit.add_exception_states_from(new_jvms);
1138     kit.set_jvms(new_jvms);
1139     if (!kit.stopped()) {
1140       result_jvms[results++] = kit.jvms();
1141     }
1142   }
1143 
1144   if (results == 0) {
1145     // All paths ended in uncommon traps.
1146     (void) kit.stop();
1147     return kit.transfer_exceptions_into_jvms();
1148   }
1149 
1150   if (results == 1) { // Only one path
1151     kit.set_jvms(result_jvms[0]);
1152     return kit.transfer_exceptions_into_jvms();
1153   }
1154 
1155   // Merge all paths.
1156   kit.C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
1157   RegionNode* region = new RegionNode(results + 1);
1158   Node* iophi = PhiNode::make(region, kit.i_o(), Type::ABIO);
1159   for (int i = 0; i &lt; results; i++) {
1160     JVMState* jvms = result_jvms[i];
1161     int path = i + 1;
1162     SafePointNode* map = jvms-&gt;map();
1163     region-&gt;init_req(path, map-&gt;control());
1164     iophi-&gt;set_req(path, map-&gt;i_o());
1165     if (i == 0) {
1166       kit.set_jvms(jvms);
1167     } else {
1168       kit.merge_memory(map-&gt;merged_memory(), region, path);
1169     }
1170   }
1171   kit.set_control(gvn.transform(region));
1172   kit.set_i_o(gvn.transform(iophi));
1173   // Transform new memory Phis.
1174   for (MergeMemStream mms(kit.merged_memory()); mms.next_non_empty();) {
1175     Node* phi = mms.memory();
1176     if (phi-&gt;is_Phi() &amp;&amp; phi-&gt;in(0) == region) {
1177       mms.set_memory(gvn.transform(phi));
1178     }
1179   }
1180 
1181   // Merge debug info.
1182   Node** ins = NEW_RESOURCE_ARRAY(Node*, results);
1183   uint tos = kit.jvms()-&gt;stkoff() + kit.sp();
1184   Node* map = kit.map();
1185   uint limit = map-&gt;req();
1186   for (uint i = TypeFunc::Parms; i &lt; limit; i++) {
1187     // Skip unused stack slots; fast forward to monoff();
1188     if (i == tos) {
1189       i = kit.jvms()-&gt;monoff();
1190       if( i &gt;= limit ) break;
1191     }
1192     Node* n = map-&gt;in(i);
1193     ins[0] = n;
1194     const Type* t = gvn.type(n);
1195     bool needs_phi = false;
1196     for (int j = 1; j &lt; results; j++) {
1197       JVMState* jvms = result_jvms[j];
1198       Node* jmap = jvms-&gt;map();
1199       Node* m = NULL;
1200       if (jmap-&gt;req() &gt; i) {
1201         m = jmap-&gt;in(i);
1202         if (m != n) {
1203           needs_phi = true;
1204           t = t-&gt;meet_speculative(gvn.type(m));
1205         }
1206       }
1207       ins[j] = m;
1208     }
1209     if (needs_phi) {
1210       Node* phi = PhiNode::make(region, n, t);
1211       for (int j = 1; j &lt; results; j++) {
1212         phi-&gt;set_req(j + 1, ins[j]);
1213       }
1214       map-&gt;set_req(i, gvn.transform(phi));
1215     }
1216   }
1217 
1218   return kit.transfer_exceptions_into_jvms();
1219 }
1220 
1221 //-------------------------UncommonTrapCallGenerator-----------------------------
1222 // Internal class which handles all out-of-line calls checking receiver type.
1223 class UncommonTrapCallGenerator : public CallGenerator {
1224   Deoptimization::DeoptReason _reason;
1225   Deoptimization::DeoptAction _action;
1226 
1227 public:
1228   UncommonTrapCallGenerator(ciMethod* m,
1229                             Deoptimization::DeoptReason reason,
1230                             Deoptimization::DeoptAction action)
1231     : CallGenerator(m)
1232   {
1233     _reason = reason;
1234     _action = action;
1235   }
1236 
1237   virtual bool      is_virtual() const          { ShouldNotReachHere(); return false; }
1238   virtual bool      is_trap() const             { return true; }
1239 
1240   virtual JVMState* generate(JVMState* jvms);
1241 };
1242 
1243 
1244 CallGenerator*
1245 CallGenerator::for_uncommon_trap(ciMethod* m,
1246                                  Deoptimization::DeoptReason reason,
1247                                  Deoptimization::DeoptAction action) {
1248   return new UncommonTrapCallGenerator(m, reason, action);
1249 }
1250 
1251 
1252 JVMState* UncommonTrapCallGenerator::generate(JVMState* jvms) {
1253   GraphKit kit(jvms);
1254   kit.C-&gt;print_inlining_update(this);
1255   // Take the trap with arguments pushed on the stack.  (Cf. null_check_receiver).
1256   // Callsite signature can be different from actual method being called (i.e _linkTo* sites).
1257   // Use callsite signature always.
1258   ciMethod* declared_method = kit.method()-&gt;get_method_at_bci(kit.bci());
1259   int nargs = declared_method-&gt;arg_size();
1260   kit.inc_sp(nargs);
1261   assert(nargs &lt;= kit.sp() &amp;&amp; kit.sp() &lt;= jvms-&gt;stk_size(), &quot;sane sp w/ args pushed&quot;);
1262   if (_reason == Deoptimization::Reason_class_check &amp;&amp;
1263       _action == Deoptimization::Action_maybe_recompile) {
1264     // Temp fix for 6529811
1265     // Don&#39;t allow uncommon_trap to override our decision to recompile in the event
1266     // of a class cast failure for a monomorphic call as it will never let us convert
1267     // the call to either bi-morphic or megamorphic and can lead to unc-trap loops
1268     bool keep_exact_action = true;
1269     kit.uncommon_trap(_reason, _action, NULL, &quot;monomorphic vcall checkcast&quot;, false, keep_exact_action);
1270   } else {
1271     kit.uncommon_trap(_reason, _action);
1272   }
1273   return kit.transfer_exceptions_into_jvms();
1274 }
1275 
1276 // (Note:  Moved hook_up_call to GraphKit::set_edges_for_java_call.)
1277 
1278 // (Node:  Merged hook_up_exits into ParseGenerator::generate.)
1279 
1280 #define NODES_OVERHEAD_PER_METHOD (30.0)
1281 #define NODES_PER_BYTECODE (9.5)
1282 
1283 void WarmCallInfo::init(JVMState* call_site, ciMethod* call_method, ciCallProfile&amp; profile, float prof_factor) {
1284   int call_count = profile.count();
1285   int code_size = call_method-&gt;code_size();
1286 
1287   // Expected execution count is based on the historical count:
1288   _count = call_count &lt; 0 ? 1 : call_site-&gt;method()-&gt;scale_count(call_count, prof_factor);
1289 
1290   // Expected profit from inlining, in units of simple call-overheads.
1291   _profit = 1.0;
1292 
1293   // Expected work performed by the call in units of call-overheads.
1294   // %%% need an empirical curve fit for &quot;work&quot; (time in call)
1295   float bytecodes_per_call = 3;
1296   _work = 1.0 + code_size / bytecodes_per_call;
1297 
1298   // Expected size of compilation graph:
1299   // -XX:+PrintParseStatistics once reported:
1300   //  Methods seen: 9184  Methods parsed: 9184  Nodes created: 1582391
1301   //  Histogram of 144298 parsed bytecodes:
1302   // %%% Need an better predictor for graph size.
1303   _size = NODES_OVERHEAD_PER_METHOD + (NODES_PER_BYTECODE * code_size);
1304 }
1305 
1306 // is_cold:  Return true if the node should never be inlined.
1307 // This is true if any of the key metrics are extreme.
1308 bool WarmCallInfo::is_cold() const {
1309   if (count()  &lt;  WarmCallMinCount)        return true;
1310   if (profit() &lt;  WarmCallMinProfit)       return true;
1311   if (work()   &gt;  WarmCallMaxWork)         return true;
1312   if (size()   &gt;  WarmCallMaxSize)         return true;
1313   return false;
1314 }
1315 
1316 // is_hot:  Return true if the node should be inlined immediately.
1317 // This is true if any of the key metrics are extreme.
1318 bool WarmCallInfo::is_hot() const {
1319   assert(!is_cold(), &quot;eliminate is_cold cases before testing is_hot&quot;);
1320   if (count()  &gt;= HotCallCountThreshold)   return true;
1321   if (profit() &gt;= HotCallProfitThreshold)  return true;
1322   if (work()   &lt;= HotCallTrivialWork)      return true;
1323   if (size()   &lt;= HotCallTrivialSize)      return true;
1324   return false;
1325 }
1326 
1327 // compute_heat:
1328 float WarmCallInfo::compute_heat() const {
1329   assert(!is_cold(), &quot;compute heat only on warm nodes&quot;);
1330   assert(!is_hot(),  &quot;compute heat only on warm nodes&quot;);
1331   int min_size = MAX2(0,   (int)HotCallTrivialSize);
1332   int max_size = MIN2(500, (int)WarmCallMaxSize);
1333   float method_size = (size() - min_size) / MAX2(1, max_size - min_size);
1334   float size_factor;
1335   if      (method_size &lt; 0.05)  size_factor = 4;   // 2 sigmas better than avg.
1336   else if (method_size &lt; 0.15)  size_factor = 2;   // 1 sigma better than avg.
1337   else if (method_size &lt; 0.5)   size_factor = 1;   // better than avg.
1338   else                          size_factor = 0.5; // worse than avg.
1339   return (count() * profit() * size_factor);
1340 }
1341 
1342 bool WarmCallInfo::warmer_than(WarmCallInfo* that) {
1343   assert(this != that, &quot;compare only different WCIs&quot;);
1344   assert(this-&gt;heat() != 0 &amp;&amp; that-&gt;heat() != 0, &quot;call compute_heat 1st&quot;);
1345   if (this-&gt;heat() &gt; that-&gt;heat())   return true;
1346   if (this-&gt;heat() &lt; that-&gt;heat())   return false;
1347   assert(this-&gt;heat() == that-&gt;heat(), &quot;no NaN heat allowed&quot;);
1348   // Equal heat.  Break the tie some other way.
1349   if (!this-&gt;call() || !that-&gt;call())  return (address)this &gt; (address)that;
1350   return this-&gt;call()-&gt;_idx &gt; that-&gt;call()-&gt;_idx;
1351 }
1352 
1353 //#define UNINIT_NEXT ((WarmCallInfo*)badAddress)
1354 #define UNINIT_NEXT ((WarmCallInfo*)NULL)
1355 
1356 WarmCallInfo* WarmCallInfo::insert_into(WarmCallInfo* head) {
1357   assert(next() == UNINIT_NEXT, &quot;not yet on any list&quot;);
1358   WarmCallInfo* prev_p = NULL;
1359   WarmCallInfo* next_p = head;
1360   while (next_p != NULL &amp;&amp; next_p-&gt;warmer_than(this)) {
1361     prev_p = next_p;
1362     next_p = prev_p-&gt;next();
1363   }
1364   // Install this between prev_p and next_p.
1365   this-&gt;set_next(next_p);
1366   if (prev_p == NULL)
1367     head = this;
1368   else
1369     prev_p-&gt;set_next(this);
1370   return head;
1371 }
1372 
1373 WarmCallInfo* WarmCallInfo::remove_from(WarmCallInfo* head) {
1374   WarmCallInfo* prev_p = NULL;
1375   WarmCallInfo* next_p = head;
1376   while (next_p != this) {
1377     assert(next_p != NULL, &quot;this must be in the list somewhere&quot;);
1378     prev_p = next_p;
1379     next_p = prev_p-&gt;next();
1380   }
1381   next_p = this-&gt;next();
1382   debug_only(this-&gt;set_next(UNINIT_NEXT));
1383   // Remove this from between prev_p and next_p.
1384   if (prev_p == NULL)
1385     head = next_p;
1386   else
1387     prev_p-&gt;set_next(next_p);
1388   return head;
1389 }
1390 
1391 WarmCallInfo WarmCallInfo::_always_hot(WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE(),
1392                                        WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE());
1393 WarmCallInfo WarmCallInfo::_always_cold(WarmCallInfo::MIN_VALUE(), WarmCallInfo::MIN_VALUE(),
1394                                         WarmCallInfo::MAX_VALUE(), WarmCallInfo::MAX_VALUE());
1395 
1396 WarmCallInfo* WarmCallInfo::always_hot() {
1397   assert(_always_hot.is_hot(), &quot;must always be hot&quot;);
1398   return &amp;_always_hot;
1399 }
1400 
1401 WarmCallInfo* WarmCallInfo::always_cold() {
1402   assert(_always_cold.is_cold(), &quot;must always be cold&quot;);
1403   return &amp;_always_cold;
1404 }
1405 
1406 
1407 #ifndef PRODUCT
1408 
1409 void WarmCallInfo::print() const {
1410   tty-&gt;print(&quot;%s : C=%6.1f P=%6.1f W=%6.1f S=%6.1f H=%6.1f -&gt; %p&quot;,
1411              is_cold() ? &quot;cold&quot; : is_hot() ? &quot;hot &quot; : &quot;warm&quot;,
1412              count(), profit(), work(), size(), compute_heat(), next());
1413   tty-&gt;cr();
1414   if (call() != NULL)  call()-&gt;dump();
1415 }
1416 
1417 void print_wci(WarmCallInfo* ci) {
1418   ci-&gt;print();
1419 }
1420 
1421 void WarmCallInfo::print_all() const {
1422   for (const WarmCallInfo* p = this; p != NULL; p = p-&gt;next())
1423     p-&gt;print();
1424 }
1425 
1426 int WarmCallInfo::count_all() const {
1427   int cnt = 0;
1428   for (const WarmCallInfo* p = this; p != NULL; p = p-&gt;next())
1429     cnt++;
1430   return cnt;
1431 }
1432 
1433 #endif //PRODUCT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
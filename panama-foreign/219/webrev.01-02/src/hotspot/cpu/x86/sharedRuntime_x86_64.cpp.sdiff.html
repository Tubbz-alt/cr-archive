<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/opto/callGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3677 
3678 class NativeInvokerGenerator : public StubCodeGenerator {
3679   address _call_target;
3680   int _shadow_space_bytes;
3681 
3682   const GrowableArray&lt;VMReg&gt;&amp; _input_registers;
3683   const GrowableArray&lt;VMReg&gt;&amp; _output_registers;
3684 public:
3685   NativeInvokerGenerator(CodeBuffer* buffer,
3686                          address call_target,
3687                          int shadow_space_bytes,
3688                          const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3689                          const GrowableArray&lt;VMReg&gt;&amp; output_registers)
3690    : StubCodeGenerator(buffer, PrintMethodHandleStubs),
3691      _call_target(call_target),
3692      _shadow_space_bytes(shadow_space_bytes),
3693      _input_registers(input_registers),
3694      _output_registers(output_registers) {}
3695   void generate();
3696 










































3697 private:
3698 #ifdef ASSERT
3699 bool target_uses_register(VMReg reg) {
3700   return _input_registers.contains(reg) || _output_registers.contains(reg);
3701 }
3702 #endif
3703 };
3704 
3705 address SharedRuntime::make_native_invoker(address call_target,
3706                                            int shadow_space_bytes,
3707                                            const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3708                                            const GrowableArray&lt;VMReg&gt;&amp; output_registers) {
3709   BufferBlob* _invoke_native_blob = BufferBlob::create(&quot;nep_invoker_blob&quot;, native_invoker_code_size);
3710   if (_invoke_native_blob == NULL)
3711     return NULL; // allocation failure
3712 
3713   CodeBuffer code(_invoke_native_blob);
3714   NativeInvokerGenerator g(&amp;code, call_target, shadow_space_bytes, input_registers, output_registers);
3715   g.generate();
3716   code.log_section_sizes(&quot;nep_invoker_blob&quot;);
</pre>
<hr />
<pre>
3777 
3778   __ block_comment(&quot;reguard stack check&quot;);
3779   Label L_reguard;
3780   Label L_after_reguard;
3781   __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
3782   __ jcc(Assembler::equal, L_reguard);
3783   __ bind(L_after_reguard);
3784 
3785   __ reset_last_Java_frame(r15_thread, true);
3786 
3787   __ leave(); // required for proper stackwalking of RuntimeStub frame
3788   __ ret(0);
3789 
3790   //////////////////////////////////////////////////////////////////////////////
3791 
3792   __ block_comment(&quot;{ L_safepoint_poll_slow_path&quot;);
3793   __ bind(L_safepoint_poll_slow_path);
3794   __ vzeroupper();
3795 
3796   if (need_spills) {
<span class="line-modified">3797     __ spill_register(ret_reg);</span>
3798   }
3799 
3800   __ mov(c_rarg0, r15_thread);
3801   __ mov(r12, rsp); // remember sp
3802   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3803   __ andptr(rsp, -16); // align stack as required by ABI
3804   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
3805   __ mov(rsp, r12); // restore sp
3806   __ reinit_heapbase();
3807 
3808   if (need_spills) {
<span class="line-modified">3809     __ fill_register(ret_reg);</span>
3810   }
3811 
3812   __ jmp(L_after_safepoint_poll);
3813   __ block_comment(&quot;} L_safepoint_poll_slow_path&quot;);
3814 
3815   //////////////////////////////////////////////////////////////////////////////
3816 
3817   __ block_comment(&quot;{ L_reguard&quot;);
3818   __ bind(L_reguard);
3819   __ vzeroupper();
3820 
3821   if (need_spills) {
<span class="line-modified">3822     __ spill_register(ret_reg);</span>
3823   }
3824 
3825   __ mov(r12, rsp); // remember sp
3826   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3827   __ andptr(rsp, -16); // align stack as required by ABI
3828   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
3829   __ mov(rsp, r12); // restore sp
3830   __ reinit_heapbase();
3831 
3832   if (need_spills) {
<span class="line-modified">3833     __ fill_register(ret_reg);</span>
3834   }
3835 
3836   __ jmp(L_after_reguard);
3837 
3838   __ block_comment(&quot;} L_reguard&quot;);
3839 
3840   //////////////////////////////////////////////////////////////////////////////
3841 
3842   __ flush();
3843 }
3844 
3845 //------------------------------Montgomery multiplication------------------------
3846 //
3847 
3848 #ifndef _WINDOWS
3849 
3850 // Subtract 0:b from carry:a.  Return carry.
3851 static julong
3852 sub(julong a[], julong b[], julong carry, long len) {
3853   long long i = 0, cnt = len;
</pre>
</td>
<td>
<hr />
<pre>
3677 
3678 class NativeInvokerGenerator : public StubCodeGenerator {
3679   address _call_target;
3680   int _shadow_space_bytes;
3681 
3682   const GrowableArray&lt;VMReg&gt;&amp; _input_registers;
3683   const GrowableArray&lt;VMReg&gt;&amp; _output_registers;
3684 public:
3685   NativeInvokerGenerator(CodeBuffer* buffer,
3686                          address call_target,
3687                          int shadow_space_bytes,
3688                          const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3689                          const GrowableArray&lt;VMReg&gt;&amp; output_registers)
3690    : StubCodeGenerator(buffer, PrintMethodHandleStubs),
3691      _call_target(call_target),
3692      _shadow_space_bytes(shadow_space_bytes),
3693      _input_registers(input_registers),
3694      _output_registers(output_registers) {}
3695   void generate();
3696 
<span class="line-added">3697   void spill_register(VMReg reg) {</span>
<span class="line-added">3698     assert(reg-&gt;is_reg(), &quot;must be a register&quot;);</span>
<span class="line-added">3699     MacroAssembler* masm = _masm;</span>
<span class="line-added">3700     if (reg-&gt;is_Register()) {</span>
<span class="line-added">3701       __ push(reg-&gt;as_Register());</span>
<span class="line-added">3702     } else if (reg-&gt;is_XMMRegister()) {</span>
<span class="line-added">3703       if (UseAVX &gt;= 3) {</span>
<span class="line-added">3704         __ subptr(rsp, 64); // bytes</span>
<span class="line-added">3705         __ evmovdqul(Address(rsp, 0), reg-&gt;as_XMMRegister(), Assembler::AVX_512bit);</span>
<span class="line-added">3706       } else if (UseAVX &gt;= 1) {</span>
<span class="line-added">3707         __ subptr(rsp, 32);</span>
<span class="line-added">3708         __ vmovdqu(Address(rsp, 0), reg-&gt;as_XMMRegister());</span>
<span class="line-added">3709       } else {</span>
<span class="line-added">3710         __ subptr(rsp, 16);</span>
<span class="line-added">3711         __ movdqu(Address(rsp, 0), reg-&gt;as_XMMRegister());</span>
<span class="line-added">3712       }</span>
<span class="line-added">3713     } else {</span>
<span class="line-added">3714       ShouldNotReachHere();</span>
<span class="line-added">3715     }</span>
<span class="line-added">3716   }</span>
<span class="line-added">3717 </span>
<span class="line-added">3718   void fill_register(VMReg reg) {</span>
<span class="line-added">3719     assert(reg-&gt;is_reg(), &quot;must be a register&quot;);</span>
<span class="line-added">3720     MacroAssembler* masm = _masm;</span>
<span class="line-added">3721     if (reg-&gt;is_Register()) {</span>
<span class="line-added">3722       __ pop(reg-&gt;as_Register());</span>
<span class="line-added">3723     } else if (reg-&gt;is_XMMRegister()) {</span>
<span class="line-added">3724       if (UseAVX &gt;= 3) {</span>
<span class="line-added">3725         __ evmovdqul(reg-&gt;as_XMMRegister(), Address(rsp, 0), Assembler::AVX_512bit);</span>
<span class="line-added">3726         __ addptr(rsp, 64); // bytes</span>
<span class="line-added">3727       } else if (UseAVX &gt;= 1) {</span>
<span class="line-added">3728         __ vmovdqu(reg-&gt;as_XMMRegister(), Address(rsp, 0));</span>
<span class="line-added">3729         __ addptr(rsp, 32);</span>
<span class="line-added">3730       } else {</span>
<span class="line-added">3731         __ movdqu(reg-&gt;as_XMMRegister(), Address(rsp, 0));</span>
<span class="line-added">3732         __ addptr(rsp, 16);</span>
<span class="line-added">3733       }</span>
<span class="line-added">3734     } else {</span>
<span class="line-added">3735       ShouldNotReachHere();</span>
<span class="line-added">3736     }</span>
<span class="line-added">3737   }</span>
<span class="line-added">3738 </span>
3739 private:
3740 #ifdef ASSERT
3741 bool target_uses_register(VMReg reg) {
3742   return _input_registers.contains(reg) || _output_registers.contains(reg);
3743 }
3744 #endif
3745 };
3746 
3747 address SharedRuntime::make_native_invoker(address call_target,
3748                                            int shadow_space_bytes,
3749                                            const GrowableArray&lt;VMReg&gt;&amp; input_registers,
3750                                            const GrowableArray&lt;VMReg&gt;&amp; output_registers) {
3751   BufferBlob* _invoke_native_blob = BufferBlob::create(&quot;nep_invoker_blob&quot;, native_invoker_code_size);
3752   if (_invoke_native_blob == NULL)
3753     return NULL; // allocation failure
3754 
3755   CodeBuffer code(_invoke_native_blob);
3756   NativeInvokerGenerator g(&amp;code, call_target, shadow_space_bytes, input_registers, output_registers);
3757   g.generate();
3758   code.log_section_sizes(&quot;nep_invoker_blob&quot;);
</pre>
<hr />
<pre>
3819 
3820   __ block_comment(&quot;reguard stack check&quot;);
3821   Label L_reguard;
3822   Label L_after_reguard;
3823   __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
3824   __ jcc(Assembler::equal, L_reguard);
3825   __ bind(L_after_reguard);
3826 
3827   __ reset_last_Java_frame(r15_thread, true);
3828 
3829   __ leave(); // required for proper stackwalking of RuntimeStub frame
3830   __ ret(0);
3831 
3832   //////////////////////////////////////////////////////////////////////////////
3833 
3834   __ block_comment(&quot;{ L_safepoint_poll_slow_path&quot;);
3835   __ bind(L_safepoint_poll_slow_path);
3836   __ vzeroupper();
3837 
3838   if (need_spills) {
<span class="line-modified">3839     spill_register(ret_reg);</span>
3840   }
3841 
3842   __ mov(c_rarg0, r15_thread);
3843   __ mov(r12, rsp); // remember sp
3844   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3845   __ andptr(rsp, -16); // align stack as required by ABI
3846   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
3847   __ mov(rsp, r12); // restore sp
3848   __ reinit_heapbase();
3849 
3850   if (need_spills) {
<span class="line-modified">3851     fill_register(ret_reg);</span>
3852   }
3853 
3854   __ jmp(L_after_safepoint_poll);
3855   __ block_comment(&quot;} L_safepoint_poll_slow_path&quot;);
3856 
3857   //////////////////////////////////////////////////////////////////////////////
3858 
3859   __ block_comment(&quot;{ L_reguard&quot;);
3860   __ bind(L_reguard);
3861   __ vzeroupper();
3862 
3863   if (need_spills) {
<span class="line-modified">3864     spill_register(ret_reg);</span>
3865   }
3866 
3867   __ mov(r12, rsp); // remember sp
3868   __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
3869   __ andptr(rsp, -16); // align stack as required by ABI
3870   __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
3871   __ mov(rsp, r12); // restore sp
3872   __ reinit_heapbase();
3873 
3874   if (need_spills) {
<span class="line-modified">3875     fill_register(ret_reg);</span>
3876   }
3877 
3878   __ jmp(L_after_reguard);
3879 
3880   __ block_comment(&quot;} L_reguard&quot;);
3881 
3882   //////////////////////////////////////////////////////////////////////////////
3883 
3884   __ flush();
3885 }
3886 
3887 //------------------------------Montgomery multiplication------------------------
3888 //
3889 
3890 #ifndef _WINDOWS
3891 
3892 // Subtract 0:b from carry:a.  Return carry.
3893 static julong
3894 sub(julong a[], julong b[], julong carry, long len) {
3895   long long i = 0, cnt = len;
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/opto/callGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
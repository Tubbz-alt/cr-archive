<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
7854   } else {
7855     bind(below_threshold);
7856   }
7857 
7858   testl(len, len);
7859   jccb(Assembler::zero, done);
7860   lea(src, Address(src, len, Address::times_1));
7861   lea(dst, Address(dst, len, Address::times_2));
7862   negptr(len);
7863 
7864   // inflate 1 char per iter
7865   bind(copy_chars_loop);
7866   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7867   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7868   increment(len);
7869   jcc(Assembler::notZero, copy_chars_loop);
7870 
7871   bind(done);
7872 }
7873 
<span class="line-removed">7874 void MacroAssembler::spill_register(VMReg reg) {</span>
<span class="line-removed">7875   assert(reg-&gt;is_reg(), &quot;must be a register&quot;);</span>
<span class="line-removed">7876   if (reg-&gt;is_Register()) {</span>
<span class="line-removed">7877     push(reg-&gt;as_Register());</span>
<span class="line-removed">7878   } else if (reg-&gt;is_XMMRegister()) {</span>
<span class="line-removed">7879     subptr(rsp, 16); // 16 bytes</span>
<span class="line-removed">7880     movdqu(Address(rsp, 0), reg-&gt;as_XMMRegister());</span>
<span class="line-removed">7881   } else {</span>
<span class="line-removed">7882     ShouldNotReachHere();</span>
<span class="line-removed">7883   }</span>
<span class="line-removed">7884 }</span>
<span class="line-removed">7885 </span>
<span class="line-removed">7886 void MacroAssembler::fill_register(VMReg reg) {</span>
<span class="line-removed">7887   assert(reg-&gt;is_reg(), &quot;must be a register&quot;);</span>
<span class="line-removed">7888   if (reg-&gt;is_Register()) {</span>
<span class="line-removed">7889     pop(reg-&gt;as_Register());</span>
<span class="line-removed">7890   } else if (reg-&gt;is_XMMRegister()) {</span>
<span class="line-removed">7891     movdqu(reg-&gt;as_XMMRegister(), Address(rsp, 0));</span>
<span class="line-removed">7892     addptr(rsp, 16); // 16 bytes</span>
<span class="line-removed">7893   } else {</span>
<span class="line-removed">7894     ShouldNotReachHere();</span>
<span class="line-removed">7895   }</span>
<span class="line-removed">7896 }</span>
<span class="line-removed">7897 </span>
7898 #ifdef _LP64
7899 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7900   Label done;
7901   cvttss2sil(dst, src);
7902   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7903   cmpl(dst, 0x80000000); // float_sign_flip
7904   jccb(Assembler::notEqual, done);
7905   subptr(rsp, 8);
7906   movflt(Address(rsp, 0), src);
7907   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7908   pop(dst);
7909   bind(done);
7910 }
7911 
7912 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7913   Label done;
7914   cvttsd2sil(dst, src);
7915   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7916   cmpl(dst, 0x80000000); // float_sign_flip
7917   jccb(Assembler::notEqual, done);
</pre>
</td>
<td>
<hr />
<pre>
7854   } else {
7855     bind(below_threshold);
7856   }
7857 
7858   testl(len, len);
7859   jccb(Assembler::zero, done);
7860   lea(src, Address(src, len, Address::times_1));
7861   lea(dst, Address(dst, len, Address::times_2));
7862   negptr(len);
7863 
7864   // inflate 1 char per iter
7865   bind(copy_chars_loop);
7866   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
7867   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
7868   increment(len);
7869   jcc(Assembler::notZero, copy_chars_loop);
7870 
7871   bind(done);
7872 }
7873 
























7874 #ifdef _LP64
7875 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
7876   Label done;
7877   cvttss2sil(dst, src);
7878   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7879   cmpl(dst, 0x80000000); // float_sign_flip
7880   jccb(Assembler::notEqual, done);
7881   subptr(rsp, 8);
7882   movflt(Address(rsp, 0), src);
7883   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
7884   pop(dst);
7885   bind(done);
7886 }
7887 
7888 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
7889   Label done;
7890   cvttsd2sil(dst, src);
7891   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
7892   cmpl(dst, 0x80000000); // float_sign_flip
7893   jccb(Assembler::notEqual, done);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/cpu/x86/macroAssembler_x86.cpp b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
--- a/src/hotspot/cpu/x86/macroAssembler_x86.cpp
+++ b/src/hotspot/cpu/x86/macroAssembler_x86.cpp
@@ -743,24 +743,10 @@
   } else {
     pushq(Address(rscratch1, 0));
   }
 }
 
-void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
-  // we must set sp to zero to clear frame
-  movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
-  // must clear fp, so that compiled frames are not confused; it is
-  // possible that we need it only for debugging
-  if (clear_fp) {
-    movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
-  }
-
-  // Always clear the pc because it could have been set by make_walkable()
-  movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
-  vzeroupper();
-}
-
 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
                                          Register last_java_fp,
                                          address  last_java_pc) {
   vzeroupper();
   // determine last_java_sp register
@@ -2672,24 +2658,28 @@
   // Make sure rsp stays 16-byte aligned
   LP64_ONLY(subq(rsp, 8));
   pusha();
 }
 
+void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
+  reset_last_Java_frame(r15_thread, clear_fp);
+}
+
 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
   if (!java_thread->is_valid()) {
     java_thread = rdi;
     get_thread(java_thread);
   }
   // we must set sp to zero to clear frame
-  movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
+  movslq(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
+  // must clear fp, so that compiled frames are not confused; it is
+  // possible that we need it only for debugging
   if (clear_fp) {
-    movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
+    movslq(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
   }
-
   // Always clear the pc because it could have been set by make_walkable()
-  movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
-
+  movslq(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
   vzeroupper();
 }
 
 void MacroAssembler::restore_rax(Register tmp) {
   if (tmp == noreg) pop(rax);
diff a/src/hotspot/cpu/x86/methodHandles_x86.cpp b/src/hotspot/cpu/x86/methodHandles_x86.cpp
--- a/src/hotspot/cpu/x86/methodHandles_x86.cpp
+++ b/src/hotspot/cpu/x86/methodHandles_x86.cpp
@@ -213,10 +213,17 @@
     // They all allow an appendix argument.
     __ hlt();           // empty stubs make SG sick
     return NULL;
   }
 
+  // No need in interpreter entry for linkToNative for now.
+  // Interpreter calls compiled entry through i2c.
+  if (iid == vmIntrinsics::_linkToNative) {
+    __ hlt();
+    return NULL;
+  }
+
   // rsi/r13: sender SP (must preserve; see prepare_to_jump_from_interpreted)
   // rbx: Method*
   // rdx: argument locator (parameter slot count, added to rsp)
   // rcx: used as temp to hold mh or receiver
   // rax, rdi: garbage temps, blown away
@@ -324,11 +331,14 @@
     assert_different_registers(temp1, temp2, temp3, saved_last_sp_register());  // don't trash lastSP
   }
   assert_different_registers(temp1, temp2, temp3, receiver_reg);
   assert_different_registers(temp1, temp2, temp3, member_reg);
 
-  if (iid == vmIntrinsics::_invokeBasic) {
+  if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {
+    if (iid == vmIntrinsics::_linkToNative) {
+      assert(for_compiler_entry, "only compiler entry is supported");
+    }
     // indirect through MH.form.vmentry.vmtarget
     jump_to_lambda_form(_masm, receiver_reg, rbx_method, temp1, for_compiler_entry);
 
   } else {
     // The method is a member invoker used by direct method handles.
diff a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
--- a/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
+++ b/src/hotspot/cpu/x86/sharedRuntime_x86_64.cpp
@@ -1846,11 +1846,11 @@
   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
   if (ref_kind != 0) {
     member_arg_pos = method->size_of_parameters() - 1;  // trailing MemberName argument
     member_reg = rbx;  // known to be free at this point
     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
-  } else if (iid == vmIntrinsics::_invokeBasic) {
+  } else if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {
     has_receiver = true;
   } else {
     fatal("unexpected intrinsic id %d", iid);
   }
 
@@ -3671,10 +3671,204 @@
   // return the  blob
   // frame_size_words or bytes??
   return RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, true);
 }
 
+static const int native_invoker_code_size = MethodHandles::adapter_code_size;
+
+class NativeInvokerGenerator : public StubCodeGenerator {
+  address _call_target;
+  int _shadow_space_bytes;
+
+  const GrowableArray<VMReg>& _input_registers;
+  const GrowableArray<VMReg>& _output_registers;
+public:
+  NativeInvokerGenerator(CodeBuffer* buffer,
+                         address call_target,
+                         int shadow_space_bytes,
+                         const GrowableArray<VMReg>& input_registers,
+                         const GrowableArray<VMReg>& output_registers)
+   : StubCodeGenerator(buffer, PrintMethodHandleStubs),
+     _call_target(call_target),
+     _shadow_space_bytes(shadow_space_bytes),
+     _input_registers(input_registers),
+     _output_registers(output_registers) {}
+  void generate();
+
+  void spill_register(VMReg reg) {
+    assert(reg->is_reg(), "must be a register");
+    MacroAssembler* masm = _masm;
+    if (reg->is_Register()) {
+      __ push(reg->as_Register());
+    } else if (reg->is_XMMRegister()) {
+      __ subptr(rsp, 16); // 16 bytes
+      __ movdqu(Address(rsp, 0), reg->as_XMMRegister());
+    } else {
+      ShouldNotReachHere();
+    }
+  }
+
+  void fill_register(VMReg reg) {
+    assert(reg->is_reg(), "must be a register");
+    MacroAssembler* masm = _masm;
+    if (reg->is_Register()) {
+      __ pop(reg->as_Register());
+    } else if (reg->is_XMMRegister()) {
+      __ movdqu(reg->as_XMMRegister(), Address(rsp, 0));
+      __ addptr(rsp, 16); // 16 bytes
+    } else {
+      ShouldNotReachHere();
+    }
+  }
+
+private:
+#ifdef ASSERT
+bool target_uses_register(VMReg reg) {
+  return _input_registers.contains(reg) || _output_registers.contains(reg);
+}
+#endif
+};
+
+address SharedRuntime::make_native_invoker(address call_target,
+                                           int shadow_space_bytes,
+                                           const GrowableArray<VMReg>& input_registers,
+                                           const GrowableArray<VMReg>& output_registers) {
+  BufferBlob* _invoke_native_blob = BufferBlob::create("nep_invoker_blob", native_invoker_code_size);
+  if (_invoke_native_blob == NULL)
+    return NULL; // allocation failure
+
+  CodeBuffer code(_invoke_native_blob);
+  NativeInvokerGenerator g(&code, call_target, shadow_space_bytes, input_registers, output_registers);
+  g.generate();
+  code.log_section_sizes("nep_invoker_blob");
+
+  return _invoke_native_blob->code_begin();
+}
+
+void NativeInvokerGenerator::generate() {
+  assert(!(target_uses_register(r15_thread->as_VMReg()) || target_uses_register(rscratch1->as_VMReg())), "Register conflict");
+
+  MacroAssembler* masm = _masm;
+  __ enter();
+
+  Address java_pc(r15_thread,
+                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
+  __ movptr(rscratch1, Address(rsp, 8)); // read return address from stack
+  __ movptr(java_pc, rscratch1);
+
+  __ movptr(rscratch1, rsp);
+  __ addptr(rscratch1, 16);
+  __ movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), rscratch1);
+
+    // State transition
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);
+
+  if (_shadow_space_bytes != 0) {
+    // needed here for correct stack args offset on Windows
+    __ subptr(rsp, _shadow_space_bytes);
+  }
+
+  __ call(RuntimeAddress(_call_target));
+
+  if (_shadow_space_bytes != 0) {
+    // needed here for correct stack args offset on Windows
+    __ addptr(rsp, _shadow_space_bytes);
+  }
+
+  assert(_output_registers.length() <= 1
+    || (_output_registers.length() == 2 && !_output_registers.at(1)->is_valid()), "no multi-reg returns");
+  bool need_spills = _output_registers.length() != 0;
+  VMReg ret_reg = need_spills ? _output_registers.at(0) : VMRegImpl::Bad();
+
+  __ restore_cpu_control_state_after_jni();
+
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);
+
+  if (os::is_MP()) {
+    // Force this write out before the read below
+    __ membar(Assembler::Membar_mask_bits(
+            Assembler::LoadLoad | Assembler::LoadStore |
+            Assembler::StoreLoad | Assembler::StoreStore));
+  }
+
+  Label L_after_safepoint_poll;
+  Label L_safepoint_poll_slow_path;
+
+  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, rscratch1);
+  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);
+  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);
+  // change thread state
+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);
+
+  __ bind(L_after_safepoint_poll);
+
+  __ block_comment("reguard stack check");
+  Label L_reguard;
+  Label L_after_reguard;
+  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), JavaThread::stack_guard_yellow_reserved_disabled);
+  __ jcc(Assembler::equal, L_reguard);
+  __ bind(L_after_reguard);
+
+  __ reset_last_Java_frame(r15_thread, true);
+
+  __ leave(); // required for proper stackwalking of RuntimeStub frame
+  __ ret(0);
+
+  //////////////////////////////////////////////////////////////////////////////
+
+  __ block_comment("{ L_safepoint_poll_slow_path");
+  __ bind(L_safepoint_poll_slow_path);
+  __ vzeroupper();
+
+  if (need_spills) {
+    spill_register(ret_reg);
+  }
+
+  __ mov(c_rarg0, r15_thread);
+  __ mov(r12, rsp); // remember sp
+  __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
+  __ andptr(rsp, -16); // align stack as required by ABI
+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
+  __ mov(rsp, r12); // restore sp
+  __ reinit_heapbase();
+
+  if (need_spills) {
+    fill_register(ret_reg);
+  }
+
+  __ jmp(L_after_safepoint_poll);
+  __ block_comment("} L_safepoint_poll_slow_path");
+
+  //////////////////////////////////////////////////////////////////////////////
+
+  __ block_comment("{ L_reguard");
+  __ bind(L_reguard);
+  __ vzeroupper();
+
+  if (need_spills) {
+    spill_register(ret_reg);
+  }
+
+  __ mov(r12, rsp); // remember sp
+  __ subptr(rsp, frame::arg_reg_save_area_bytes); // windows
+  __ andptr(rsp, -16); // align stack as required by ABI
+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));
+  __ mov(rsp, r12); // restore sp
+  __ reinit_heapbase();
+
+  if (need_spills) {
+    fill_register(ret_reg);
+  }
+
+  __ jmp(L_after_reguard);
+
+  __ block_comment("} L_reguard");
+
+  //////////////////////////////////////////////////////////////////////////////
+
+  __ flush();
+}
 
 //------------------------------Montgomery multiplication------------------------
 //
 
 #ifndef _WINDOWS
diff a/src/hotspot/cpu/x86/vmreg_x86.cpp b/src/hotspot/cpu/x86/vmreg_x86.cpp
--- a/src/hotspot/cpu/x86/vmreg_x86.cpp
+++ b/src/hotspot/cpu/x86/vmreg_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,11 @@
  */
 
 #include "precompiled.hpp"
 #include "asm/assembler.hpp"
 #include "code/vmreg.hpp"
-
+#include "vmreg_x86.inline.hpp"
 
 
 void VMRegImpl::set_regName() {
   Register reg = ::as_Register(0);
   int i;
@@ -64,5 +64,19 @@
 
   for ( ; i < ConcreteRegisterImpl::number_of_registers ; i ++ ) {
     regName[i] = "NON-GPR-FPR-XMM-KREG";
   }
 }
+
+#define INTEGER_TYPE 0
+#define VECTOR_TYPE 1
+#define X87_TYPE 2
+#define STACK_TYPE 3
+
+VMReg VMRegImpl::vmStorageToVMReg(int type, int index) {
+  switch(type) {
+    case INTEGER_TYPE: return ::as_Register(index)->as_VMReg();
+    case VECTOR_TYPE: return ::as_XMMRegister(index)->as_VMReg();
+    case STACK_TYPE: return VMRegImpl::stack2reg(index LP64_ONLY(* 2)); // numbering on x64 goes per 64-bits
+  }
+  return VMRegImpl::Bad();
+}
diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -457,10 +457,14 @@
   int offset = 13; // movq r10,#addr; callq (r10)
   offset += clear_avx_size();
   return offset;
 }
 
+int MachCallNativeNode::ret_addr_offset() {
+  int offset = 13; // movq r10,#addr; callq (r10)
+  return offset;
+}
 //
 // Compute padding required for nodes which need alignment
 //
 
 // The address of the call instruction needs to be 4-byte aligned to
@@ -12558,10 +12562,24 @@
   format %{ "call_leaf,runtime " %}
   ins_encode(clear_avx, Java_To_Runtime(meth));
   ins_pipe(pipe_slow);
 %}
 
+//
+instruct CallNativeDirect(method meth)
+%{
+  match(CallNative);
+  effect(USE meth);
+
+  ins_cost(300);
+  format %{ "call_native " %}
+  ins_encode %{
+    __ call(RuntimeAddress((address) $meth$$method));
+  %}
+  ins_pipe(pipe_slow);
+%}
+
 // Call runtime without safepoint
 instruct CallLeafNoFPDirect(method meth)
 %{
   match(CallLeafNoFP);
   effect(USE meth);
diff a/src/hotspot/share/adlc/formssel.cpp b/src/hotspot/share/adlc/formssel.cpp
--- a/src/hotspot/share/adlc/formssel.cpp
+++ b/src/hotspot/share/adlc/formssel.cpp
@@ -417,10 +417,12 @@
   idx = 0;
   if(_matrule->find_type("CallLeaf",idx))         return Form::JAVA_LEAF;
   idx = 0;
   if(_matrule->find_type("CallLeafNoFP",idx))     return Form::JAVA_LEAF;
   idx = 0;
+  if(_matrule->find_type("CallNative",idx))       return Form::JAVA_NATIVE;
+  idx = 0;
 
   return Form::invalid_type;
 }
 
 // Return 'true' if this instruction matches an ideal 'Load?' node
@@ -1127,10 +1129,13 @@
     return "MachCallRuntimeNode";
   }
   else if( is_ideal_call() == Form::JAVA_LEAF ) {
     return "MachCallLeafNode";
   }
+  else if( is_ideal_call() == Form::JAVA_NATIVE ) {
+    return "MachCallNativeNode";
+  }
   else if (is_ideal_return()) {
     return "MachReturnNode";
   }
   else if (is_ideal_halt()) {
     return "MachHaltNode";
diff a/src/hotspot/share/c1/c1_GraphBuilder.cpp b/src/hotspot/share/c1/c1_GraphBuilder.cpp
--- a/src/hotspot/share/c1/c1_GraphBuilder.cpp
+++ b/src/hotspot/share/c1/c1_GraphBuilder.cpp
@@ -4127,10 +4127,13 @@
         print_inlining(callee, "MemberName not constant", /*success*/ false);
       }
     }
     break;
 
+  case vmIntrinsics::_linkToNative:
+    break; // TODO: NYI
+
   default:
     fatal("unexpected intrinsic %d: %s", iid, vmIntrinsics::name_at(iid));
     break;
   }
   set_state(state_before->copy_for_parsing());
diff a/src/hotspot/share/ci/ciClassList.hpp b/src/hotspot/share/ci/ciClassList.hpp
--- a/src/hotspot/share/ci/ciClassList.hpp
+++ b/src/hotspot/share/ci/ciClassList.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -46,10 +46,11 @@
 class ciObject;
 class   ciNullObject;
 class   ciInstance;
 class     ciCallSite;
 class     ciMemberName;
+class     ciNativeEntryPoint;
 class     ciMethodHandle;
 class     ciMethodType;
 class     ciArray;
 class       ciObjArray;
 class       ciTypeArray;
@@ -95,10 +96,11 @@
 friend class ciExceptionHandlerStream; \
 friend class ciObject;                 \
 friend class ciNullObject;             \
 friend class ciInstance;               \
 friend class ciMemberName;             \
+friend class ciNativeEntryPoint;       \
 friend class ciMethod;                 \
 friend class ciMethodData;             \
 friend class ciMethodHandle;           \
 friend class ciMethodType;             \
 friend class ciReceiverTypeData;       \
diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -966,11 +966,13 @@
                             ExceptionHandlerTable* handler_table,
                             ImplicitExceptionTable* inc_table,
                             AbstractCompiler* compiler,
                             bool has_unsafe_access,
                             bool has_wide_vectors,
-                            RTMState  rtm_state) {
+                            RTMState  rtm_state,
+                            address* native_stubs,
+                            int num_stubs) {
   VM_ENTRY_MARK;
   nmethod* nm = NULL;
   {
     // To prevent compile queue updates.
     MutexLocker locker(THREAD, MethodCompileQueue_lock);
@@ -1046,11 +1048,12 @@
                                offsets,
                                orig_pc_offset,
                                debug_info(), dependencies(), code_buffer,
                                frame_words, oop_map_set,
                                handler_table, inc_table,
-                               compiler, task()->comp_level());
+                               compiler, task()->comp_level(),
+                               native_stubs, num_stubs);
 
     // Free codeBlobs
     code_buffer->free_blob();
 
     if (nm != NULL) {
diff a/src/hotspot/share/ci/ciEnv.hpp b/src/hotspot/share/ci/ciEnv.hpp
--- a/src/hotspot/share/ci/ciEnv.hpp
+++ b/src/hotspot/share/ci/ciEnv.hpp
@@ -376,11 +376,13 @@
                        ExceptionHandlerTable*    handler_table,
                        ImplicitExceptionTable*   inc_table,
                        AbstractCompiler*         compiler,
                        bool                      has_unsafe_access,
                        bool                      has_wide_vectors,
-                       RTMState                  rtm_state = NoRTM);
+                       RTMState                  rtm_state = NoRTM,
+                       address*                  native_stubs = NULL,
+                       int                       num_stubs = 0);
 
 
   // Access to certain well known ciObjects.
 #define WK_KLASS_FUNC(name, ignore_s) \
   ciInstanceKlass* name() { \
diff a/src/hotspot/share/ci/ciNativeEntryPoint.cpp b/src/hotspot/share/ci/ciNativeEntryPoint.cpp
--- /dev/null
+++ b/src/hotspot/share/ci/ciNativeEntryPoint.cpp
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "ci/ciClassList.hpp"
+#include "ci/ciNativeEntryPoint.hpp"
+#include "ci/ciUtilities.inline.hpp"
+#include "ci/ciArray.hpp"
+#include "classfile/javaClasses.hpp"
+#include "oops/oop.inline.hpp"
+#include "memory/allocation.hpp"
+
+VMReg* getVMRegArray(ciArray* array) {
+  assert(array->element_basic_type() == T_LONG, "Unexpected type");
+
+  VMReg* out = NEW_ARENA_ARRAY(CURRENT_ENV->arena(), VMReg, array->length());
+
+  for (int i = 0; i < array->length(); i++) {
+    ciConstant con = array->element_value(i);
+    VMReg reg = VMRegImpl::as_VMReg(con.as_long());
+    out[i] = reg;
+  }
+
+  return out;
+}
+
+ciNativeEntryPoint::ciNativeEntryPoint(instanceHandle h_i) : ciInstance(h_i), _name(NULL) {
+  // Copy name
+  oop name_str = jdk_internal_invoke_NativeEntryPoint::name(get_oop());
+  if (name_str != NULL) {
+    char* temp_name = java_lang_String::as_quoted_ascii(name_str);
+    size_t len = strlen(temp_name) + 1;
+    char* name = (char*)CURRENT_ENV->arena()->Amalloc(len);
+    strncpy(name, temp_name, len);
+    _name = name;
+  }
+
+  _arg_moves = getVMRegArray(CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::argMoves(get_oop()))->as_array());
+  _ret_moves = getVMRegArray(CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::returnMoves(get_oop()))->as_array());
+}
+
+address ciNativeEntryPoint::entry_point() const {
+  VM_ENTRY_MARK;
+  return jdk_internal_invoke_NativeEntryPoint::addr(get_oop());
+}
+
+jint ciNativeEntryPoint::shadow_space() const {
+  VM_ENTRY_MARK;
+  return jdk_internal_invoke_NativeEntryPoint::shadow_space(get_oop());
+}
+
+VMReg* ciNativeEntryPoint::argMoves() const {
+  return _arg_moves;
+}
+
+VMReg* ciNativeEntryPoint::returnMoves() const {
+  return _ret_moves;
+}
+
+jboolean ciNativeEntryPoint::need_transition() const {
+  VM_ENTRY_MARK;
+  return jdk_internal_invoke_NativeEntryPoint::need_transition(get_oop());
+}
+
+ciMethodType* ciNativeEntryPoint::method_type() const {
+  VM_ENTRY_MARK;
+  return CURRENT_ENV->get_object(jdk_internal_invoke_NativeEntryPoint::method_type(get_oop()))->as_method_type();
+}
+
+const char* ciNativeEntryPoint::name() {
+  return _name;
+}
diff a/src/hotspot/share/ci/ciNativeEntryPoint.hpp b/src/hotspot/share/ci/ciNativeEntryPoint.hpp
--- /dev/null
+++ b/src/hotspot/share/ci/ciNativeEntryPoint.hpp
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_CI_CINATIVEENTRYPOINT_HPP
+#define SHARE_VM_CI_CINATIVEENTRYPOINT_HPP
+
+#include "ci/ciInstance.hpp"
+#include "ci/ciMethodType.hpp"
+
+#include "code/vmreg.hpp"
+
+// ciNativeEntryPoint
+//
+// The class represents a java.lang.invoke.NativeEntryPoint object.
+class ciNativeEntryPoint : public ciInstance {
+private:
+  const char* _name;
+  VMReg* _arg_moves;
+  VMReg* _ret_moves;
+public:
+  ciNativeEntryPoint(instanceHandle h_i);
+
+  // What kind of ciObject is this?
+  bool is_native_entry_point() const { return true; }
+
+  address        entry_point() const;
+  jint           shadow_space() const;
+  VMReg*         argMoves() const;
+  VMReg*        returnMoves() const;
+  jboolean       need_transition() const;
+  ciMethodType*  method_type() const;
+  const char*    name();
+};
+
+#endif // SHARE_VM_CI_CINATIVEENTRYPOINT_HPP
diff a/src/hotspot/share/ci/ciObjArray.cpp b/src/hotspot/share/ci/ciObjArray.cpp
--- a/src/hotspot/share/ci/ciObjArray.cpp
+++ b/src/hotspot/share/ci/ciObjArray.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2015, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -34,11 +34,11 @@
 // machine.
 
 ciObject* ciObjArray::obj_at(int index) {
   VM_ENTRY_MARK;
   objArrayOop array = get_objArrayOop();
-  if (index < 0 || index >= array->length()) return NULL;
+  assert(index >= 0 && index < array->length(), "OOB access");
   oop o = array->obj_at(index);
   if (o == NULL) {
     return ciNullObject::make();
   } else {
     return CURRENT_ENV->get_object(o);
diff a/src/hotspot/share/ci/ciObject.hpp b/src/hotspot/share/ci/ciObject.hpp
--- a/src/hotspot/share/ci/ciObject.hpp
+++ b/src/hotspot/share/ci/ciObject.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -105,10 +105,11 @@
   virtual bool is_method_handle()     const { return false; }
   virtual bool is_method_type()       const { return false; }
   virtual bool is_array()                   { return false; }
   virtual bool is_obj_array()               { return false; }
   virtual bool is_type_array()              { return false; }
+  virtual bool is_native_entry_point()const { return false; }
 
   // Is this a type or value which has no associated class?
   // It is true of primitive types and null objects.
   virtual bool is_classless() const         { return false; }
   virtual void dump_replay_data(outputStream* st) { /* do nothing */ }
@@ -158,10 +159,14 @@
   }
   ciTypeArray* as_type_array() {
     assert(is_type_array(), "bad cast");
     return (ciTypeArray*)this;
   }
+  ciNativeEntryPoint* as_native_entry_point() {
+    assert(is_native_entry_point(), "bad cast");
+    return (ciNativeEntryPoint*)this;
+  }
 
   // Print debugging output about this ciObject.
   void print(outputStream* st);
   void print() { print(tty); }  // GDB cannot handle default arguments
 
diff a/src/hotspot/share/ci/ciObjectFactory.cpp b/src/hotspot/share/ci/ciObjectFactory.cpp
--- a/src/hotspot/share/ci/ciObjectFactory.cpp
+++ b/src/hotspot/share/ci/ciObjectFactory.cpp
@@ -25,10 +25,11 @@
 #include "precompiled.hpp"
 #include "ci/ciCallSite.hpp"
 #include "ci/ciInstance.hpp"
 #include "ci/ciInstanceKlass.hpp"
 #include "ci/ciMemberName.hpp"
+#include "ci/ciNativeEntryPoint.hpp"
 #include "ci/ciMethod.hpp"
 #include "ci/ciMethodData.hpp"
 #include "ci/ciMethodHandle.hpp"
 #include "ci/ciMethodType.hpp"
 #include "ci/ciNullObject.hpp"
@@ -349,10 +350,12 @@
     instanceHandle h_i(THREAD, (instanceOop)o);
     if (java_lang_invoke_CallSite::is_instance(o))
       return new (arena()) ciCallSite(h_i);
     else if (java_lang_invoke_MemberName::is_instance(o))
       return new (arena()) ciMemberName(h_i);
+    else if (jdk_internal_invoke_NativeEntryPoint::is_instance(o))
+      return new (arena()) ciNativeEntryPoint(h_i);
     else if (java_lang_invoke_MethodHandle::is_instance(o))
       return new (arena()) ciMethodHandle(h_i);
     else if (java_lang_invoke_MethodType::is_instance(o))
       return new (arena()) ciMethodType(h_i);
     else
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -3828,10 +3828,69 @@
 
 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
   return obj != NULL && is_subclass(obj->klass());
 }
 
+int jdk_internal_invoke_NativeEntryPoint::_addr_offset;
+int jdk_internal_invoke_NativeEntryPoint::_shadow_space_offset;
+int jdk_internal_invoke_NativeEntryPoint::_argMoves_offset;
+int jdk_internal_invoke_NativeEntryPoint::_returnMoves_offset;
+int jdk_internal_invoke_NativeEntryPoint::_need_transition_offset;
+int jdk_internal_invoke_NativeEntryPoint::_method_type_offset;
+int jdk_internal_invoke_NativeEntryPoint::_name_offset;
+
+#define NEP_FIELDS_DO(macro) \
+  macro(_addr_offset,            k, "addr",           long_signature, false); \
+  macro(_shadow_space_offset,    k, "shadowSpace",    int_signature, false); \
+  macro(_argMoves_offset,        k, "argMoves",       long_array_signature, false); \
+  macro(_returnMoves_offset,     k, "returnMoves",    long_array_signature, false); \
+  macro(_need_transition_offset, k, "needTransition", bool_signature, false); \
+  macro(_method_type_offset,     k, "methodType",     java_lang_invoke_MethodType_signature, false); \
+  macro(_name_offset,            k, "name",           string_signature, false);
+
+bool jdk_internal_invoke_NativeEntryPoint::is_instance(oop obj) {
+  return obj != NULL && is_subclass(obj->klass());
+}
+
+void jdk_internal_invoke_NativeEntryPoint::compute_offsets() {
+  InstanceKlass* k = SystemDictionary::NativeEntryPoint_klass();
+  NEP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
+}
+
+#if INCLUDE_CDS
+void jdk_internal_invoke_NativeEntryPoint::serialize_offsets(SerializeClosure* f) {
+  NEP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
+}
+#endif
+
+address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {
+  return (address)entry->long_field(_addr_offset);
+}
+
+jint jdk_internal_invoke_NativeEntryPoint::shadow_space(oop entry) {
+  return entry->int_field(_shadow_space_offset);
+}
+
+oop jdk_internal_invoke_NativeEntryPoint::argMoves(oop entry) {
+  return entry->obj_field(_argMoves_offset);
+}
+
+oop jdk_internal_invoke_NativeEntryPoint::returnMoves(oop entry) {
+  return entry->obj_field(_returnMoves_offset);
+}
+
+jboolean jdk_internal_invoke_NativeEntryPoint::need_transition(oop entry) {
+  return entry->bool_field(_need_transition_offset);
+}
+
+oop jdk_internal_invoke_NativeEntryPoint::method_type(oop entry) {
+  return entry->obj_field(_method_type_offset);
+}
+
+oop jdk_internal_invoke_NativeEntryPoint::name(oop entry) {
+  return entry->obj_field(_name_offset);
+}
 
 oop java_lang_invoke_MethodHandle::type(oop mh) {
   return mh->obj_field(_type_offset);
 }
 
diff a/src/hotspot/share/classfile/javaClasses.hpp b/src/hotspot/share/classfile/javaClasses.hpp
--- a/src/hotspot/share/classfile/javaClasses.hpp
+++ b/src/hotspot/share/classfile/javaClasses.hpp
@@ -70,10 +70,11 @@
   f(java_lang_Module) \
   f(java_lang_StackTraceElement) \
   f(java_lang_StackFrameInfo) \
   f(java_lang_LiveStackFrameInfo) \
   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
+  f(jdk_internal_invoke_NativeEntryPoint) \
   f(jdk_internal_misc_UnsafeConstants) \
   f(java_lang_boxing_object) \
   //end
 
 #define BASIC_JAVA_CLASSES_DO(f) \
@@ -1029,10 +1030,55 @@
 
   // Accessors for code generation:
   static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }
 };
 
+// Interface to java.lang.invoke.NativeEntryPoint objects
+// (These are a private interface for managing adapter code generation.)
+
+class jdk_internal_invoke_NativeEntryPoint: AllStatic {
+  friend class JavaClasses;
+
+ private:
+  static int _addr_offset;  // type is jlong
+  static int _shadow_space_offset;
+  static int _argMoves_offset;
+  static int _returnMoves_offset;
+  static int _need_transition_offset;
+  static int _method_type_offset;
+  static int _name_offset;
+
+  static void compute_offsets();
+
+ public:
+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
+
+  // Accessors
+  static address    addr(oop entry);
+  static jint       shadow_space(oop entry);
+  static oop        argMoves(oop entry);
+  static oop        returnMoves(oop entry);
+  static jboolean   need_transition(oop entry);
+  static oop        method_type(oop entry);
+  static oop        name(oop entry);
+
+  // Testers
+  static bool is_subclass(Klass* klass) {
+    return SystemDictionary::NativeEntryPoint_klass() != NULL &&
+      klass->is_subclass_of(SystemDictionary::NativeEntryPoint_klass());
+  }
+  static bool is_instance(oop obj);
+
+  // Accessors for code generation:
+  static int addr_offset_in_bytes()            { return _addr_offset;            }
+  static int shadow_space_offset_in_bytes()    { return _shadow_space_offset;    }
+  static int argMoves_offset_in_bytes()        { return _argMoves_offset;        }
+  static int returnMoves_offset_in_bytes()     { return _returnMoves_offset;     }
+  static int need_transition_offset_in_bytes() { return _need_transition_offset; }
+  static int method_type_offset_in_bytes()     { return _method_type_offset;     }
+  static int name_offset_in_bytes()            { return _name_offset;            }
+};
 
 // Interface to java.lang.invoke.MemberName objects
 // (These are a private interface for Java code to query the class hierarchy.)
 
 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
diff a/src/hotspot/share/classfile/systemDictionary.hpp b/src/hotspot/share/classfile/systemDictionary.hpp
--- a/src/hotspot/share/classfile/systemDictionary.hpp
+++ b/src/hotspot/share/classfile/systemDictionary.hpp
@@ -216,10 +216,11 @@
   do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives                  ) \
   do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm                           ) \
   do_klass(MethodType_klass,                            java_lang_invoke_MethodType                           ) \
   do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError                        ) \
   do_klass(CallSite_klass,                              java_lang_invoke_CallSite                             ) \
+  do_klass(NativeEntryPoint_klass,                      jdk_internal_invoke_NativeEntryPoint                  ) \
   do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \
   do_klass(ConstantCallSite_klass,                      java_lang_invoke_ConstantCallSite                     ) \
   do_klass(MutableCallSite_klass,                       java_lang_invoke_MutableCallSite                      ) \
   do_klass(VolatileCallSite_klass,                      java_lang_invoke_VolatileCallSite                     ) \
   /* Note: MethodHandle must be first, and VolatileCallSite last in group */                                    \
diff a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -257,10 +257,11 @@
   template(invokeBasic_name,                          "invokeBasic")                              \
   template(linkToVirtual_name,                        "linkToVirtual")                            \
   template(linkToStatic_name,                         "linkToStatic")                             \
   template(linkToSpecial_name,                        "linkToSpecial")                            \
   template(linkToInterface_name,                      "linkToInterface")                          \
+  template(linkToNative_name,                         "linkToNative")                             \
   template(compiledLambdaForm_name,                   "<compiledLambdaForm>")  /*fake name*/      \
   template(star_name,                                 "*") /*not really a name*/                  \
   template(invoke_name,                               "invoke")                                   \
   template(parameterTypes_name,                       "parameterTypes")                           \
   template(returnType_name,                           "returnType")                               \
@@ -327,12 +328,15 @@
   template(setTargetVolatile_name,                    "setTargetVolatile")                        \
   template(setTarget_signature,                       "(Ljava/lang/invoke/MethodHandle;)V")       \
   template(DEFAULT_CONTEXT_name,                      "DEFAULT_CONTEXT")                          \
   NOT_LP64(  do_alias(intptr_signature,               int_signature)  )                           \
   LP64_ONLY( do_alias(intptr_signature,               long_signature) )                           \
-                                                                                                                                      \
-  /* Support for JVMCI */                                                                                                             \
+  /* Panama Support */                                                                                          \
+  template(jdk_internal_invoke_NativeEntryPoint,                 "jdk/internal/invoke/NativeEntryPoint")           \
+  template(jdk_internal_invoke_NativeEntryPoint_signature,       "Ljdk/internal/invoke/NativeEntryPoint;")         \
+                                                                                                  \
+  /* Support for JVMCI */                                                                         \
   JVMCI_VM_SYMBOLS_DO(template, do_alias)                                                         \
                                                                                                   \
   template(java_lang_StackWalker,                     "java/lang/StackWalker")                    \
   template(java_lang_StackFrameInfo,                  "java/lang/StackFrameInfo")                 \
   template(java_lang_LiveStackFrameInfo,              "java/lang/LiveStackFrameInfo")             \
@@ -499,10 +503,11 @@
   template(void_signature,                            "V")                                        \
   template(bool_array_signature,                      "[Z")                                       \
   template(byte_array_signature,                      "[B")                                       \
   template(char_array_signature,                      "[C")                                       \
   template(int_array_signature,                       "[I")                                       \
+  template(long_array_signature,                      "[J")                                       \
   template(object_void_signature,                     "(Ljava/lang/Object;)V")                    \
   template(object_int_signature,                      "(Ljava/lang/Object;)I")                    \
   template(object_boolean_signature,                  "(Ljava/lang/Object;)Z")                    \
   template(object_object_signature,                   "(Ljava/lang/Object;)Ljava/lang/Object;")   \
   template(string_void_signature,                     "(Ljava/lang/String;)V")                    \
@@ -1456,10 +1461,11 @@
   do_intrinsic(_invokeBasic,              java_lang_invoke_MethodHandle, invokeBasic_name,      star_name, F_RN)        \
   do_intrinsic(_linkToVirtual,            java_lang_invoke_MethodHandle, linkToVirtual_name,    star_name, F_SN)        \
   do_intrinsic(_linkToStatic,             java_lang_invoke_MethodHandle, linkToStatic_name,     star_name, F_SN)        \
   do_intrinsic(_linkToSpecial,            java_lang_invoke_MethodHandle, linkToSpecial_name,    star_name, F_SN)        \
   do_intrinsic(_linkToInterface,          java_lang_invoke_MethodHandle, linkToInterface_name,  star_name, F_SN)        \
+  do_intrinsic(_linkToNative,             java_lang_invoke_MethodHandle, linkToNative_name,     star_name, F_SN)        \
   /* special marker for bytecode generated for the JVM from a LambdaForm: */                                            \
   do_intrinsic(_compiledLambdaForm,       java_lang_invoke_MethodHandle, compiledLambdaForm_name, star_name, F_RN)      \
                                                                                                                         \
   /* unboxing methods: */                                                                                               \
   do_intrinsic(_booleanValue,             java_lang_Boolean,      booleanValue_name, void_boolean_signature, F_R)       \
@@ -1597,11 +1603,11 @@
 
     ID_LIMIT,
     LAST_COMPILER_INLINE = _getAndSetReference,
     FIRST_MH_SIG_POLY    = _invokeGeneric,
     FIRST_MH_STATIC      = _linkToVirtual,
-    LAST_MH_SIG_POLY     = _linkToInterface,
+    LAST_MH_SIG_POLY     = _linkToNative,
 
     FIRST_ID = _none + 1
   };
 
   enum Flags {
diff a/src/hotspot/share/code/codeCache.cpp b/src/hotspot/share/code/codeCache.cpp
--- a/src/hotspot/share/code/codeCache.cpp
+++ b/src/hotspot/share/code/codeCache.cpp
@@ -556,14 +556,16 @@
 void CodeCache::free(CodeBlob* cb) {
   assert_locked_or_safepoint(CodeCache_lock);
   CodeHeap* heap = get_code_heap(cb);
   print_trace("free", cb);
   if (cb->is_nmethod()) {
+    nmethod* ptr = (nmethod *)cb;
     heap->set_nmethod_count(heap->nmethod_count() - 1);
-    if (((nmethod *)cb)->has_dependencies()) {
+    if (ptr->has_dependencies()) {
       _number_of_nmethods_with_dependencies--;
     }
+    ptr->free_native_stubs();
   }
   if (cb->is_adapter_blob()) {
     heap->set_adapter_count(heap->adapter_count() - 1);
   }
 
diff a/src/hotspot/share/code/nmethod.cpp b/src/hotspot/share/code/nmethod.cpp
--- a/src/hotspot/share/code/nmethod.cpp
+++ b/src/hotspot/share/code/nmethod.cpp
@@ -493,11 +493,13 @@
   CodeBuffer* code_buffer, int frame_size,
   OopMapSet* oop_maps,
   ExceptionHandlerTable* handler_table,
   ImplicitExceptionTable* nul_chk_table,
   AbstractCompiler* compiler,
-  int comp_level
+  int comp_level,
+  address* native_stubs,
+  int num_stubs
 #if INCLUDE_JVMCI
   , char* speculations,
   int speculations_len,
   int nmethod_mirror_index,
   const char* nmethod_mirror_name,
@@ -530,11 +532,13 @@
             orig_pc_offset, debug_info, dependencies, code_buffer, frame_size,
             oop_maps,
             handler_table,
             nul_chk_table,
             compiler,
-            comp_level
+            comp_level,
+            native_stubs,
+            num_stubs
 #if INCLUDE_JVMCI
             , speculations,
             speculations_len,
             jvmci_data_size
 #endif
@@ -594,11 +598,12 @@
   ByteSize basic_lock_sp_offset,
   OopMapSet* oop_maps )
   : CompiledMethod(method, "native nmethod", type, nmethod_size, sizeof(nmethod), code_buffer, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
   _is_unloading_state(0),
   _native_receiver_sp_offset(basic_lock_owner_sp_offset),
-  _native_basic_lock_sp_offset(basic_lock_sp_offset)
+  _native_basic_lock_sp_offset(basic_lock_sp_offset),
+  _native_stubs(NULL), _num_stubs(0)
 {
   {
     int scopes_data_offset   = 0;
     int deoptimize_offset    = 0;
     int deoptimize_mh_offset = 0;
@@ -714,21 +719,24 @@
   int frame_size,
   OopMapSet* oop_maps,
   ExceptionHandlerTable* handler_table,
   ImplicitExceptionTable* nul_chk_table,
   AbstractCompiler* compiler,
-  int comp_level
+  int comp_level,
+  address* native_stubs,
+  int num_stubs
 #if INCLUDE_JVMCI
   , char* speculations,
   int speculations_len,
   int jvmci_data_size
 #endif
   )
   : CompiledMethod(method, "nmethod", type, nmethod_size, sizeof(nmethod), code_buffer, offsets->value(CodeOffsets::Frame_Complete), frame_size, oop_maps, false),
   _is_unloading_state(0),
   _native_receiver_sp_offset(in_ByteSize(-1)),
-  _native_basic_lock_sp_offset(in_ByteSize(-1))
+  _native_basic_lock_sp_offset(in_ByteSize(-1)),
+  _native_stubs(native_stubs), _num_stubs(num_stubs)
 {
   assert(debug_info->oop_recorder() == code_buffer->oop_recorder(), "shared OR");
   {
     debug_only(NoSafepointVerifier nsv;)
     assert_locked_or_safepoint(CodeCache_lock);
@@ -1037,10 +1045,21 @@
   for (int index = 0 ; index < length; index++) {
     dest[index] = array->at(index);
   }
 }
 
+void nmethod::free_native_stubs() {
+  if (_native_stubs != NULL) {
+    for (int i = 0; i < _num_stubs; i++) {
+      CodeBlob* cb = CodeCache::find_blob((char*)  _native_stubs[i]);
+      assert(cb != NULL, "Expected to find blob");
+      CodeCache::free(cb);
+    }
+    FREE_C_HEAP_ARRAY(address, _native_stubs);
+  }
+}
+
 void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {
   // re-patch all oop-bearing instructions, just in case some oops moved
   RelocIterator iter(this, begin, end);
   while (iter.next()) {
     if (iter.type() == relocInfo::oop_type) {
diff a/src/hotspot/share/code/nmethod.hpp b/src/hotspot/share/code/nmethod.hpp
--- a/src/hotspot/share/code/nmethod.hpp
+++ b/src/hotspot/share/code/nmethod.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -280,10 +280,13 @@
   // JVMTI's GetLocalInstance() also uses these offsets to find the receiver
   // for non-static native wrapper frames.
   ByteSize _native_receiver_sp_offset;
   ByteSize _native_basic_lock_sp_offset;
 
+  address* _native_stubs;
+  int _num_stubs;
+
   friend class nmethodLocker;
 
   // For native wrappers
   nmethod(Method* method,
           CompilerType type,
@@ -310,11 +313,13 @@
           int frame_size,
           OopMapSet* oop_maps,
           ExceptionHandlerTable* handler_table,
           ImplicitExceptionTable* nul_chk_table,
           AbstractCompiler* compiler,
-          int comp_level
+          int comp_level,
+          address* native_stubs,
+          int num_stubs
 #if INCLUDE_JVMCI
           , char* speculations,
           int speculations_len,
           int jvmci_data_size
 #endif
@@ -358,11 +363,13 @@
                               int frame_size,
                               OopMapSet* oop_maps,
                               ExceptionHandlerTable* handler_table,
                               ImplicitExceptionTable* nul_chk_table,
                               AbstractCompiler* compiler,
-                              int comp_level
+                              int comp_level,
+                              address* native_stubs = NULL,
+                              int num_stubs = 0
 #if INCLUDE_JVMCI
                               , char* speculations = NULL,
                               int speculations_len = 0,
                               int nmethod_mirror_index = -1,
                               const char* nmethod_mirror_name = NULL,
@@ -523,10 +530,12 @@
   }
 
   void copy_values(GrowableArray<jobject>* oops);
   void copy_values(GrowableArray<Metadata*>* metadata);
 
+  void free_native_stubs();
+
   // Relocation support
 private:
   void fix_oop_relocations(address begin, address end, bool initialize_immediates);
   inline void initialize_immediate_oop(oop* dest, jobject handle);
 
diff a/src/hotspot/share/code/vmreg.hpp b/src/hotspot/share/code/vmreg.hpp
--- a/src/hotspot/share/code/vmreg.hpp
+++ b/src/hotspot/share/code/vmreg.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -138,10 +138,12 @@
     return value() - stack0->value();
   }
 
   static void set_regName();
 
+  static VMReg vmStorageToVMReg(int type, int index);
+
 #include CPU_HEADER(vmreg)
 
 };
 
 //---------------------------VMRegPair-------------------------------------------
diff a/src/hotspot/share/jvmci/jvmciRuntime.cpp b/src/hotspot/share/jvmci/jvmciRuntime.cpp
--- a/src/hotspot/share/jvmci/jvmciRuntime.cpp
+++ b/src/hotspot/share/jvmci/jvmciRuntime.cpp
@@ -1431,11 +1431,11 @@
                                  offsets,
                                  orig_pc_offset,
                                  debug_info, dependencies, code_buffer,
                                  frame_words, oop_map_set,
                                  handler_table, implicit_exception_table,
-                                 compiler, comp_level,
+                                 compiler, comp_level, NULL, 0,
                                  speculations, speculations_len,
                                  nmethod_mirror_index, nmethod_mirror_name, failed_speculations);
 
 
       // Free codeBlobs
diff a/src/hotspot/share/oops/method.cpp b/src/hotspot/share/oops/method.cpp
--- a/src/hotspot/share/oops/method.cpp
+++ b/src/hotspot/share/oops/method.cpp
@@ -1466,10 +1466,13 @@
   // Finally, set up its entry points.
   assert(m->can_be_statically_bound(), "");
   m->set_vtable_index(Method::nonvirtual_vtable_index);
   m->link_method(m, CHECK_(empty));
 
+  if (iid == vmIntrinsics::_linkToNative) {
+    m->set_interpreter_entry(m->adapter()->get_i2c_entry());
+  }
   if (log_is_enabled(Info, methodhandles) && (Verbose || WizardMode)) {
     LogTarget(Info, methodhandles) lt;
     LogStream ls(lt);
     m->print_on(&ls);
   }
diff a/src/hotspot/share/opto/callGenerator.cpp b/src/hotspot/share/opto/callGenerator.cpp
--- a/src/hotspot/share/opto/callGenerator.cpp
+++ b/src/hotspot/share/opto/callGenerator.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -38,10 +38,12 @@
 #include "opto/parse.hpp"
 #include "opto/rootnode.hpp"
 #include "opto/runtime.hpp"
 #include "opto/subnode.hpp"
 #include "runtime/sharedRuntime.hpp"
+#include "ci/ciNativeEntryPoint.hpp"
+#include "utilities/debug.hpp"
 
 // Utility function.
 const TypeFunc* CallGenerator::tf() const {
   return TypeFunc::make(method());
 }
@@ -844,10 +846,34 @@
     // Out-of-line call.
     return CallGenerator::for_direct_call(callee);
   }
 }
 
+class NativeCallGenerator : public CallGenerator {
+private:
+  ciNativeEntryPoint* _nep;
+public:
+  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)
+   : CallGenerator(m), _nep(nep) {}
+
+  virtual JVMState* generate(JVMState* jvms);
+};
+
+JVMState* NativeCallGenerator::generate(JVMState* jvms) {
+  GraphKit kit(jvms);
+
+  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); // -fallback, - nep
+
+  kit.C->print_inlining_update(this);
+  address addr = _nep->entry_point();
+  if (kit.C->log() != NULL) {
+    kit.C->log()->elem("l2n_intrinsification_success bci='%d' entry_point='" INTPTR_FORMAT "'", jvms->bci(), p2i(addr));
+  }
+
+  return kit.transfer_exceptions_into_jvms();
+}
+
 CallGenerator* CallGenerator::for_method_handle_inline(JVMState* jvms, ciMethod* caller, ciMethod* callee, bool& input_not_const) {
   GraphKit kit(jvms);
   PhaseGVN& gvn = kit.gvn();
   Compile* C = kit.C;
   vmIntrinsics::ID iid = callee->intrinsic_id();
@@ -966,10 +992,25 @@
                                "member_name not constant");
       }
     }
     break;
 
+    case vmIntrinsics::_linkToNative:
+    {
+      Node* nep = kit.argument(callee->arg_size() - 1);
+      if (nep->Opcode() == Op_ConP) {
+        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();
+        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();
+        return new NativeCallGenerator(callee, nep);
+      } else {
+        // can this happen?
+        print_inlining_failure(C, callee, jvms->depth() - 1, jvms->bci(),
+                               "NativeEntryPoint not constant");
+      }
+    }
+    break;
+
   default:
     fatal("unexpected intrinsic %d: %s", iid, vmIntrinsics::name_at(iid));
     break;
   }
   return NULL;
diff a/src/hotspot/share/opto/callnode.cpp b/src/hotspot/share/opto/callnode.cpp
--- a/src/hotspot/share/opto/callnode.cpp
+++ b/src/hotspot/share/opto/callnode.cpp
@@ -41,10 +41,11 @@
 #include "opto/regalloc.hpp"
 #include "opto/regmask.hpp"
 #include "opto/rootnode.hpp"
 #include "opto/runtime.hpp"
 #include "utilities/powerOfTwo.hpp"
+#include "code/vmreg.hpp"
 
 // Portions of code courtesy of Clifford Click
 
 // Optimization - Graph Style
 
@@ -1080,15 +1081,101 @@
   st->print("%s", _name);
   CallNode::dump_spec(st);
 }
 #endif
 
+//=============================================================================
+uint CallNativeNode::size_of() const { return sizeof(*this); }
+bool CallNativeNode::cmp( const Node &n ) const {
+  CallNativeNode &call = (CallNativeNode&)n;
+  return CallNode::cmp(call) && !strcmp(_name,call._name)
+    && _arg_regs == call._arg_regs && _ret_regs == call._ret_regs;
+}
+Node* CallNativeNode::match(const ProjNode *proj, const Matcher *matcher) {
+  switch (proj->_con) {
+    case TypeFunc::Control:
+    case TypeFunc::I_O:
+    case TypeFunc::Memory:
+      return new MachProjNode(this,proj->_con,RegMask::Empty,MachProjNode::unmatched_proj);
+    case TypeFunc::ReturnAdr:
+    case TypeFunc::FramePtr:
+      ShouldNotReachHere();
+    case TypeFunc::Parms:
+    default: {
+      if(tf()->range()->field_at(proj->_con) == Type::HALF) {
+        assert(_ret_regs.at(proj->_con - TypeFunc::Parms) == VMRegImpl::Bad(), "Unexpected register for Type::HALF");
+        // 2nd half of doubles and longs
+        return new MachProjNode(this,proj->_con, RegMask::Empty, (uint)OptoReg::Bad);
+      }
+
+      const BasicType bt = tf()->range()->field_at(proj->_con)->basic_type();
+      OptoReg::Name optoreg = OptoReg::as_OptoReg(_ret_regs.at(proj->_con - TypeFunc::Parms));
+      OptoRegPair regs;
+      if (bt == T_DOUBLE || bt == T_LONG) {
+        regs.set2(optoreg);
+      } else {
+        regs.set1(optoreg);
+      }
+      RegMask rm = RegMask(regs.first());
+      if( OptoReg::is_valid(regs.second()) )
+        rm.Insert( regs.second() );
+      return new MachProjNode(this,proj->_con,rm,tf()->range()->field_at(proj->_con)->ideal_reg());
+    }
+  }
+  return NULL;
+}
+#ifndef PRODUCT
+void CallNativeNode::dump_spec(outputStream *st) const {
+  st->print("# ");
+  st->print("%s ", _name);
+  st->print("_arg_regs: ");
+  _arg_regs.print_on(st);
+  st->print("_ret_regs: ");
+  _ret_regs.print_on(st);
+  CallNode::dump_spec(st);
+}
+#endif
+
 //------------------------------calling_convention-----------------------------
 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
 }
 
+void CallNativeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
+  assert((tf()->domain()->cnt() - TypeFunc::Parms) == argcnt, "arg counts must match!");
+#ifndef PRODUCT
+  for (uint i = 0; i < argcnt; i++) {
+    assert(tf()->domain()->field_at(TypeFunc::Parms + i)->basic_type() == sig_bt[i], "types must match!");
+  }
+#endif
+  for (uint i = 0; i < argcnt; i++) {
+    switch (sig_bt[i]) {
+      case T_BOOLEAN:
+      case T_CHAR:
+      case T_BYTE:
+      case T_SHORT:
+      case T_INT:
+      case T_FLOAT:
+        parm_regs[i].set1(_arg_regs.at(i));
+        break;
+      case T_LONG:
+      case T_DOUBLE:
+        assert((i + 1) < argcnt && sig_bt[i + 1] == T_VOID, "expecting half");
+        parm_regs[i].set2(_arg_regs.at(i));
+        break;
+      case T_VOID: // Halves of longs and doubles
+        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), "expecting half");
+        assert(_arg_regs.at(i) == VMRegImpl::Bad(), "expecting bad reg");
+        parm_regs[i].set_bad();
+        break;
+      default:
+        ShouldNotReachHere();
+        break;
+    }
+  }
+}
+
 //=============================================================================
 //------------------------------calling_convention-----------------------------
 
 
 //=============================================================================
diff a/src/hotspot/share/opto/callnode.hpp b/src/hotspot/share/opto/callnode.hpp
--- a/src/hotspot/share/opto/callnode.hpp
+++ b/src/hotspot/share/opto/callnode.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -30,10 +30,11 @@
 #include "opto/multnode.hpp"
 #include "opto/opcodes.hpp"
 #include "opto/phaseX.hpp"
 #include "opto/replacednodes.hpp"
 #include "opto/type.hpp"
+#include "utilities/growableArray.hpp"
 
 // Portions of code courtesy of Clifford Click
 
 // Optimization - Graph Style
 
@@ -46,10 +47,11 @@
 class       CallStaticJavaNode;
 class       CallDynamicJavaNode;
 class     CallRuntimeNode;
 class       CallLeafNode;
 class         CallLeafNoFPNode;
+class     CallNativeNode;
 class     AllocateNode;
 class       AllocateArrayNode;
 class     BoxLockNode;
 class     LockNode;
 class     UnlockNode;
@@ -802,10 +804,44 @@
 #ifndef PRODUCT
   virtual void  dump_spec(outputStream *st) const;
 #endif
 };
 
+//------------------------------CallNativeNode-----------------------------------
+// Make a direct call into a foreign function with an arbitrary ABI
+// safepoints
+class CallNativeNode : public CallNode {
+  virtual bool cmp( const Node &n ) const;
+  virtual uint size_of() const;
+public:
+  GrowableArray<VMReg> _arg_regs;
+  GrowableArray<VMReg> _ret_regs;
+  const int _shadow_space_bytes;
+  const bool _need_transition;
+
+  CallNativeNode(const TypeFunc* tf, address addr, const char* name,
+                 const TypePtr* adr_type,
+                 const GrowableArray<VMReg>& arg_regs,
+                 const GrowableArray<VMReg>& ret_regs,
+                 int shadow_space_bytes,
+                 bool need_transition)
+    : CallNode(tf, addr, adr_type), _arg_regs(arg_regs),
+      _ret_regs(ret_regs), _shadow_space_bytes(shadow_space_bytes),
+      _need_transition(need_transition)
+  {
+    init_class_id(Class_CallNative);
+    _name = name;
+  }
+  virtual int   Opcode() const;
+  virtual bool  guaranteed_safepoint()  { return _need_transition; }
+  virtual Node* match(const ProjNode *proj, const Matcher *m);
+  virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
+#ifndef PRODUCT
+  virtual void  dump_spec(outputStream *st) const;
+#endif
+};
+
 //------------------------------CallLeafNoFPNode-------------------------------
 // CallLeafNode, not using floating point or using it in the same manner as
 // the generated code
 class CallLeafNoFPNode : public CallLeafNode {
 public:
diff a/src/hotspot/share/opto/classes.hpp b/src/hotspot/share/opto/classes.hpp
--- a/src/hotspot/share/opto/classes.hpp
+++ b/src/hotspot/share/opto/classes.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -57,10 +57,11 @@
 macro(CallDynamicJava)
 macro(CallJava)
 macro(CallLeaf)
 macro(CallLeafNoFP)
 macro(CallRuntime)
+macro(CallNative)
 macro(CallStaticJava)
 macro(CastII)
 macro(CastX2P)
 macro(CastP2X)
 macro(CastPP)
diff a/src/hotspot/share/opto/compile.cpp b/src/hotspot/share/opto/compile.cpp
--- a/src/hotspot/share/opto/compile.cpp
+++ b/src/hotspot/share/opto/compile.cpp
@@ -542,10 +542,11 @@
                   _late_inlines(comp_arena(), 2, 0, NULL),
                   _string_late_inlines(comp_arena(), 2, 0, NULL),
                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
                   _late_inlines_pos(0),
                   _number_of_mh_late_inlines(0),
+                  _native_stubs(NULL),
                   _print_inlining_stream(NULL),
                   _print_inlining_list(NULL),
                   _print_inlining_idx(0),
                   _print_inlining_output(NULL),
                   _replay_inline_data(NULL),
@@ -823,10 +824,11 @@
     _Compile_types(mtCompiler),
     _initial_gvn(NULL),
     _for_igvn(NULL),
     _warm_calls(NULL),
     _number_of_mh_late_inlines(0),
+    _native_stubs(NULL),
     _print_inlining_stream(NULL),
     _print_inlining_list(NULL),
     _print_inlining_idx(0),
     _print_inlining_output(NULL),
     _replay_inline_data(NULL),
@@ -999,10 +1001,11 @@
   _macro_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);
   _predicate_opaqs = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);
   _expensive_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);
   _range_check_casts = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);
   _opaque4_nodes = new(comp_arena()) GrowableArray<Node*>(comp_arena(), 8,  0, NULL);
+  _native_stubs = new(comp_arena()) GrowableArray<address>(comp_arena(), 1,  0, NULL);
   register_library_intrinsics();
 #ifdef ASSERT
   _type_verify_symmetry = true;
 #endif
 }
@@ -2866,10 +2869,11 @@
   case Op_CallJava:
   case Op_CallDynamicJava:
     frc.inc_java_call_count(); // Count java call site;
   case Op_CallRuntime:
   case Op_CallLeaf:
+  case Op_CallNative:
   case Op_CallLeafNoFP: {
     assert (n->is_Call(), "");
     CallNode *call = n->as_Call();
     // Count call sites where the FP mode bit would have to be flipped.
     // Do not count uncommon runtime calls:
@@ -4660,5 +4664,8 @@
   tty->print_cr("Method printed over network stream to IGV");
   _debug_network_printer->print_method(phase_name, 0);
 }
 #endif
 
+void Compile::add_native_stub(address stubAddress) {
+  _native_stubs->append(stubAddress);
+}
diff a/src/hotspot/share/opto/compile.hpp b/src/hotspot/share/opto/compile.hpp
--- a/src/hotspot/share/opto/compile.hpp
+++ b/src/hotspot/share/opto/compile.hpp
@@ -381,10 +381,11 @@
   GrowableArray<CallGenerator*> _boxing_late_inlines; // same but for boxing operations
 
   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 
+  GrowableArray<address>*       _native_stubs;
 
   // Inlining may not happen in parse order which would make
   // PrintInlining output confusing. Keep track of PrintInlining
   // pieces in order.
   class PrintInliningBuffer : public ResourceObj {
@@ -940,10 +941,14 @@
 
   void              add_boxing_late_inline(CallGenerator* cg) {
     _boxing_late_inlines.push(cg);
   }
 
+  void add_native_stub(address stub);
+
+  GrowableArray<address>* native_stubs() const { return _native_stubs; }
+
   void remove_useless_late_inlines(GrowableArray<CallGenerator*>* inlines, Unique_Node_List &useful);
 
   void process_print_inlining();
   void dump_print_inlining();
 
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -22,10 +22,13 @@
  *
  */
 
 #include "precompiled.hpp"
 #include "ci/ciUtilities.hpp"
+#include "ci/ciNativeEntryPoint.hpp"
+#include "ci/ciObjArray.hpp"
+#include "asm/register.hpp"
 #include "compiler/compileLog.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/c2/barrierSetC2.hpp"
 #include "interpreter/interpreter.hpp"
 #include "memory/resourceArea.hpp"
@@ -44,10 +47,11 @@
 #include "opto/subtypenode.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/sharedRuntime.hpp"
 #include "utilities/bitMap.inline.hpp"
 #include "utilities/powerOfTwo.hpp"
+#include "utilities/growableArray.hpp"
 
 //----------------------------GraphKit-----------------------------------------
 // Main utility constructor.
 GraphKit::GraphKit(JVMState* jvms)
   : Phase(Phase::Parser),
@@ -2557,10 +2561,138 @@
   }
   return call;
 
 }
 
+// i2b
+Node* GraphKit::sign_extend_byte(Node* in) {
+  Node* tmp = _gvn.transform(new LShiftINode(in, _gvn.intcon(24)));
+  return _gvn.transform(new RShiftINode(tmp, _gvn.intcon(24)));
+}
+
+// i2s
+Node* GraphKit::sign_extend_short(Node* in) {
+  Node* tmp = _gvn.transform(new LShiftINode(in, _gvn.intcon(16)));
+  return _gvn.transform(new RShiftINode(tmp, _gvn.intcon(16)));
+}
+
+//-----------------------------make_native_call-------------------------------
+Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {
+  uint n_filtered_args = nargs - 2; // -fallback, -nep;
+  ResourceMark rm;
+  Node** argument_nodes = NEW_RESOURCE_ARRAY(Node*, n_filtered_args);
+  const Type** arg_types = NEW_RESOURCE_ARRAY(const Type*, n_filtered_args);
+  GrowableArray<VMReg> arg_regs(C->comp_arena(), n_filtered_args, n_filtered_args, VMRegImpl::Bad());
+
+  VMReg* argRegs = nep->argMoves();
+  {
+    for (uint vm_arg_pos = 0, java_arg_read_pos = 0;
+        vm_arg_pos < n_filtered_args; vm_arg_pos++) {
+      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; // +1 to skip fallback handle argument
+      Node* node = argument(vm_unfiltered_arg_pos);
+      const Type* type = call_type->domain()->field_at(TypeFunc::Parms + vm_unfiltered_arg_pos);
+      VMReg reg = type == Type::HALF
+        ? VMRegImpl::Bad()
+        : argRegs[java_arg_read_pos++];
+
+      argument_nodes[vm_arg_pos] = node;
+      arg_types[vm_arg_pos] = type;
+      arg_regs.at_put(vm_arg_pos, reg);
+    }
+  }
+
+  uint n_returns = call_type->range()->cnt() - TypeFunc::Parms;
+  GrowableArray<VMReg> ret_regs(C->comp_arena(), n_returns, n_returns, VMRegImpl::Bad());
+  const Type** ret_types = NEW_RESOURCE_ARRAY(const Type*, n_returns);
+
+  VMReg* retRegs = nep->returnMoves();
+  {
+    for (uint vm_ret_pos = 0, java_ret_read_pos = 0;
+        vm_ret_pos < n_returns; vm_ret_pos++) { // 0 or 1
+      const Type* type = call_type->range()->field_at(TypeFunc::Parms + vm_ret_pos);
+      VMReg reg = type == Type::HALF
+        ? VMRegImpl::Bad()
+        : retRegs[java_ret_read_pos++];
+
+      ret_regs.at_put(vm_ret_pos, reg);
+      ret_types[vm_ret_pos] = type;
+    }
+  }
+
+  const TypeFunc* new_call_type = TypeFunc::make(
+    TypeTuple::make_func(n_filtered_args, arg_types),
+    TypeTuple::make_func(n_returns, ret_types)
+  );
+
+  address call_addr = nep->entry_point();
+  if (nep->need_transition()) {
+    call_addr = SharedRuntime::make_native_invoker(call_addr,
+                                                   nep->shadow_space(),
+                                                   arg_regs, ret_regs);
+    C->add_native_stub(call_addr);
+  }
+  assert(call_addr != NULL, "sanity");
+
+  CallNativeNode* call = new CallNativeNode(new_call_type, call_addr, nep->name(), TypePtr::BOTTOM,
+                                            arg_regs,
+                                            ret_regs,
+                                            nep->shadow_space(),
+                                            nep->need_transition());
+
+  if (call->_need_transition) {
+    add_safepoint_edges(call);
+  }
+
+  set_predefined_input_for_runtime_call(call);
+
+  for (uint i = 0; i < n_filtered_args; i++) {
+    call->init_req(i + TypeFunc::Parms, argument_nodes[i]);
+  }
+
+  Node* c = gvn().transform(call);
+  assert(c == call, "cannot disappear");
+
+  set_predefined_output_for_runtime_call(call);
+
+  Node* ret;
+  if (method() == NULL || method()->return_type()->basic_type() == T_VOID) {
+    ret = top();
+  } else {
+    Node* current_value = NULL;
+    for (uint vm_ret_pos = 0; vm_ret_pos < n_returns; vm_ret_pos++) {
+      if (new_call_type->range()->field_at(TypeFunc::Parms + vm_ret_pos)  == Type::HALF) {
+        // FIXME is this needed?
+        gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));
+      } else {
+        assert(current_value == NULL, "Must not overwrite");
+        current_value = gvn().transform(new ProjNode(call, TypeFunc::Parms + vm_ret_pos));
+      }
+    }
+    assert(current_value != NULL, "Should not be null");
+    // Unpack native results if needed
+    // Need this method type since it's unerased
+    switch (nep->method_type()->rtype()->basic_type()) {
+      case T_CHAR:
+        current_value = _gvn.transform(new AndINode(current_value, _gvn.intcon(0xFFFF)));
+        break;
+      case T_BYTE:
+        current_value = sign_extend_byte(current_value);
+        break;
+      case T_SHORT:
+        current_value = sign_extend_short(current_value);
+        break;
+      default: // do nothing
+        break;
+    }
+    ret = current_value;
+  }
+
+  push_node(method()->return_type()->basic_type(), ret);
+
+  return call;
+}
+
 //------------------------------merge_memory-----------------------------------
 // Merge memory from one path into the current memory state.
 void GraphKit::merge_memory(Node* new_mem, Node* region, int new_path) {
   for (MergeMemStream mms(merged_memory(), new_mem->as_MergeMem()); mms.next_non_empty2(); ) {
     Node* old_slice = mms.force_memory();
diff a/src/hotspot/share/opto/graphKit.hpp b/src/hotspot/share/opto/graphKit.hpp
--- a/src/hotspot/share/opto/graphKit.hpp
+++ b/src/hotspot/share/opto/graphKit.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -789,10 +789,16 @@
                           const TypePtr* adr_type, // NULL if no memory effects
                           Node* parm0 = NULL, Node* parm1 = NULL,
                           Node* parm2 = NULL, Node* parm3 = NULL,
                           Node* parm4 = NULL, Node* parm5 = NULL,
                           Node* parm6 = NULL, Node* parm7 = NULL);
+
+  Node* sign_extend_byte(Node* in);
+  Node* sign_extend_short(Node* in);
+
+  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);
+
   enum {  // flag values for make_runtime_call
     RC_NO_FP = 1,               // CallLeafNoFPNode
     RC_NO_IO = 2,               // do not hook IO edges
     RC_NO_LEAF = 4,             // CallStaticJavaNode
     RC_MUST_THROW = 8,          // flag passed to add_safepoint_edges
diff a/src/hotspot/share/opto/lcm.cpp b/src/hotspot/share/opto/lcm.cpp
--- a/src/hotspot/share/opto/lcm.cpp
+++ b/src/hotspot/share/opto/lcm.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -860,10 +860,14 @@
     case Op_CallStaticJava:
     case Op_CallDynamicJava:
       // Calling Java code so use Java calling convention
       save_policy = _matcher._register_save_policy;
       break;
+    case Op_CallNative:
+      // FIXME compute actual save policy based on nep->abi
+      save_policy = _matcher._c_reg_save_policy;
+      break;
 
     default:
       ShouldNotReachHere();
   }
 
diff a/src/hotspot/share/opto/machnode.cpp b/src/hotspot/share/opto/machnode.cpp
--- a/src/hotspot/share/opto/machnode.cpp
+++ b/src/hotspot/share/opto/machnode.cpp
@@ -816,10 +816,27 @@
   st->print("%s ",_name);
   MachCallNode::dump_spec(st);
 }
 #endif
 //=============================================================================
+uint MachCallNativeNode::size_of() const { return sizeof(*this); }
+bool MachCallNativeNode::cmp( const Node &n ) const {
+  MachCallNativeNode &call = (MachCallNativeNode&)n;
+  return MachCallNode::cmp(call) && !strcmp(_name,call._name)
+    && _arg_regs == call._arg_regs && _ret_regs == call._ret_regs;
+}
+#ifndef PRODUCT
+void MachCallNativeNode::dump_spec(outputStream *st) const {
+  st->print("%s ",_name);
+  st->print("_arg_regs: ");
+  _arg_regs.print_on(st);
+  st->print("_ret_regs: ");
+  _ret_regs.print_on(st);
+  MachCallNode::dump_spec(st);
+}
+#endif
+//=============================================================================
 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
 // to indicate where the stack-slot-only debug info inputs begin.
 // There is no other JVM state needed here.
 JVMState jvms_for_throw(0);
diff a/src/hotspot/share/opto/machnode.hpp b/src/hotspot/share/opto/machnode.hpp
--- a/src/hotspot/share/opto/machnode.hpp
+++ b/src/hotspot/share/opto/machnode.hpp
@@ -29,18 +29,20 @@
 #include "opto/constantTable.hpp"
 #include "opto/matcher.hpp"
 #include "opto/multnode.hpp"
 #include "opto/node.hpp"
 #include "opto/regmask.hpp"
+#include "utilities/growableArray.hpp"
 
 class BiasedLockingCounters;
 class BufferBlob;
 class CodeBuffer;
 class JVMState;
 class MachCallDynamicJavaNode;
 class MachCallJavaNode;
 class MachCallLeafNode;
+class MachCallNativeNode;
 class MachCallNode;
 class MachCallRuntimeNode;
 class MachCallStaticJavaNode;
 class MachEpilogNode;
 class MachIfNode;
@@ -879,20 +881,22 @@
 public:
   const TypeFunc *_tf;        // Function type
   address      _entry_point;  // Address of the method being called
   float        _cnt;          // Estimate of number of times called
   uint         _argsize;      // Size of argument block on stack
+  bool         _guaranteed_safepoint; // Do we need to observe safepoint?
 
   const TypeFunc* tf()        const { return _tf; }
   const address entry_point() const { return _entry_point; }
   const float   cnt()         const { return _cnt; }
   uint argsize()              const { return _argsize; }
 
-  void set_tf(const TypeFunc* tf) { _tf = tf; }
-  void set_entry_point(address p) { _entry_point = p; }
-  void set_cnt(float c)           { _cnt = c; }
-  void set_argsize(int s)         { _argsize = s; }
+  void set_tf(const TypeFunc* tf)       { _tf = tf; }
+  void set_entry_point(address p)       { _entry_point = p; }
+  void set_cnt(float c)                 { _cnt = c; }
+  void set_argsize(int s)               { _argsize = s; }
+  void set_guaranteed_safepoint(bool b) { _guaranteed_safepoint = b; }
 
   MachCallNode() : MachSafePointNode() {
     init_class_id(Class_MachCall);
   }
 
@@ -906,10 +910,12 @@
   bool return_value_is_used() const;
 
   // Similar to cousin class CallNode::returns_pointer
   bool returns_pointer() const;
 
+  bool guaranteed_safepoint() const { return _guaranteed_safepoint; }
+
 #ifndef PRODUCT
   virtual void dump_spec(outputStream *st) const;
 #endif
 };
 
@@ -1004,10 +1010,28 @@
   MachCallLeafNode() : MachCallRuntimeNode() {
     init_class_id(Class_MachCallLeaf);
   }
 };
 
+class MachCallNativeNode: public MachCallNode {
+  virtual bool cmp( const Node &n ) const;
+  virtual uint size_of() const;
+public:
+  const char *_name;
+  GrowableArray<VMReg> _arg_regs;
+  GrowableArray<VMReg> _ret_regs;
+
+  MachCallNativeNode() : MachCallNode() {
+    init_class_id(Class_MachCallNative);
+  }
+
+  virtual int ret_addr_offset();
+#ifndef PRODUCT
+  virtual void dump_spec(outputStream *st) const;
+#endif
+};
+
 //------------------------------MachHaltNode-----------------------------------
 // Machine-specific versions of halt nodes
 class MachHaltNode : public MachReturnNode {
 public:
   bool _reachable;
diff a/src/hotspot/share/opto/matcher.cpp b/src/hotspot/share/opto/matcher.cpp
--- a/src/hotspot/share/opto/matcher.cpp
+++ b/src/hotspot/share/opto/matcher.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -1143,13 +1143,14 @@
     if( m == NULL ) { Matcher::soft_match_failure(); return NULL; }
 
     // Copy data from the Ideal SafePoint to the machine version
     mcall = m->as_MachCall();
 
-    mcall->set_tf(         call->tf());
-    mcall->set_entry_point(call->entry_point());
-    mcall->set_cnt(        call->cnt());
+    mcall->set_tf(                  call->tf());
+    mcall->set_entry_point(         call->entry_point());
+    mcall->set_cnt(                 call->cnt());
+    mcall->set_guaranteed_safepoint(call->guaranteed_safepoint());
 
     if( mcall->is_MachCallJava() ) {
       MachCallJavaNode *mcall_java  = mcall->as_MachCallJava();
       const CallJavaNode *call_java =  call->as_CallJava();
       assert(call_java->validate_symbolic_info(), "inconsistent info");
@@ -1171,10 +1172,17 @@
          call_java->as_CallDynamicJava()->_vtable_index;
     }
     else if( mcall->is_MachCallRuntime() ) {
       mcall->as_MachCallRuntime()->_name = call->as_CallRuntime()->_name;
     }
+    else if( mcall->is_MachCallNative() ) {
+      MachCallNativeNode* mach_call_native = mcall->as_MachCallNative();
+      CallNativeNode* call_native = call->as_CallNative();
+      mach_call_native->_name = call_native->_name;
+      mach_call_native->_arg_regs = call_native->_arg_regs;
+      mach_call_native->_ret_regs = call_native->_ret_regs;
+    }
     msfpt = mcall;
   }
   // This is a non-call safepoint
   else {
     call = NULL;
@@ -1204,10 +1212,12 @@
   OptoReg::Name out_arg_limit_per_call = begin_out_arg_area;
   // Calls to C may hammer extra stack slots above and beyond any arguments.
   // These are usually backing store for register arguments for varargs.
   if( call != NULL && call->is_CallRuntime() )
     out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call,C->varargs_C_out_slots_killed());
+  if( call != NULL && call->is_CallNative() )
+    out_arg_limit_per_call = OptoReg::add(out_arg_limit_per_call, call->as_CallNative()->_shadow_space_bytes);
 
 
   // Do the normal argument list (parameters) register masks
   int argcnt = cnt - TypeFunc::Parms;
   if( argcnt > 0 ) {          // Skip it all if we have no args
diff a/src/hotspot/share/opto/node.hpp b/src/hotspot/share/opto/node.hpp
--- a/src/hotspot/share/opto/node.hpp
+++ b/src/hotspot/share/opto/node.hpp
@@ -48,10 +48,11 @@
 class CallDynamicJavaNode;
 class CallJavaNode;
 class CallLeafNode;
 class CallNode;
 class CallRuntimeNode;
+class CallNativeNode;
 class CallStaticJavaNode;
 class CastIINode;
 class CatchNode;
 class CatchProjNode;
 class CheckCastPPNode;
@@ -89,10 +90,11 @@
 class MachBranchNode;
 class MachCallDynamicJavaNode;
 class MachCallJavaNode;
 class MachCallLeafNode;
 class MachCallNode;
+class MachCallNativeNode;
 class MachCallRuntimeNode;
 class MachCallStaticJavaNode;
 class MachConstantBaseNode;
 class MachConstantNode;
 class MachGotoNode;
@@ -625,10 +627,11 @@
             DEFINE_CLASS_ID(AllocateArray,    Allocate, 0)
           DEFINE_CLASS_ID(AbstractLock,     Call, 3)
             DEFINE_CLASS_ID(Lock,             AbstractLock, 0)
             DEFINE_CLASS_ID(Unlock,           AbstractLock, 1)
           DEFINE_CLASS_ID(ArrayCopy,        Call, 4)
+          DEFINE_CLASS_ID(CallNative,       Call, 5)
       DEFINE_CLASS_ID(MultiBranch, Multi, 1)
         DEFINE_CLASS_ID(PCTable,     MultiBranch, 0)
           DEFINE_CLASS_ID(Catch,       PCTable, 0)
           DEFINE_CLASS_ID(Jump,        PCTable, 1)
         DEFINE_CLASS_ID(If,          MultiBranch, 1)
@@ -648,10 +651,11 @@
             DEFINE_CLASS_ID(MachCallJava,         MachCall, 0)
               DEFINE_CLASS_ID(MachCallStaticJava,   MachCallJava, 0)
               DEFINE_CLASS_ID(MachCallDynamicJava,  MachCallJava, 1)
             DEFINE_CLASS_ID(MachCallRuntime,      MachCall, 1)
               DEFINE_CLASS_ID(MachCallLeaf,         MachCallRuntime, 0)
+            DEFINE_CLASS_ID(MachCallNative,       MachCall, 2)
       DEFINE_CLASS_ID(MachBranch, Mach, 1)
         DEFINE_CLASS_ID(MachIf,         MachBranch, 0)
         DEFINE_CLASS_ID(MachGoto,       MachBranch, 1)
         DEFINE_CLASS_ID(MachNullCheck,  MachBranch, 2)
       DEFINE_CLASS_ID(MachSpillCopy,    Mach, 2)
@@ -798,10 +802,11 @@
   DEFINE_CLASS_QUERY(AllocateArray)
   DEFINE_CLASS_QUERY(ArrayCopy)
   DEFINE_CLASS_QUERY(Bool)
   DEFINE_CLASS_QUERY(BoxLock)
   DEFINE_CLASS_QUERY(Call)
+  DEFINE_CLASS_QUERY(CallNative)
   DEFINE_CLASS_QUERY(CallDynamicJava)
   DEFINE_CLASS_QUERY(CallJava)
   DEFINE_CLASS_QUERY(CallLeaf)
   DEFINE_CLASS_QUERY(CallRuntime)
   DEFINE_CLASS_QUERY(CallStaticJava)
@@ -838,10 +843,11 @@
   DEFINE_CLASS_QUERY(Lock)
   DEFINE_CLASS_QUERY(Loop)
   DEFINE_CLASS_QUERY(Mach)
   DEFINE_CLASS_QUERY(MachBranch)
   DEFINE_CLASS_QUERY(MachCall)
+  DEFINE_CLASS_QUERY(MachCallNative)
   DEFINE_CLASS_QUERY(MachCallDynamicJava)
   DEFINE_CLASS_QUERY(MachCallJava)
   DEFINE_CLASS_QUERY(MachCallLeaf)
   DEFINE_CLASS_QUERY(MachCallRuntime)
   DEFINE_CLASS_QUERY(MachCallStaticJava)
diff a/src/hotspot/share/opto/output.cpp b/src/hotspot/share/opto/output.cpp
--- a/src/hotspot/share/opto/output.cpp
+++ b/src/hotspot/share/opto/output.cpp
@@ -33,10 +33,11 @@
 #include "compiler/disassembler.hpp"
 #include "compiler/oopMap.hpp"
 #include "gc/shared/barrierSet.hpp"
 #include "gc/shared/c2/barrierSetC2.hpp"
 #include "memory/allocation.inline.hpp"
+#include "memory/allocation.hpp"
 #include "opto/ad.hpp"
 #include "opto/block.hpp"
 #include "opto/c2compiler.hpp"
 #include "opto/callnode.hpp"
 #include "opto/cfgnode.hpp"
@@ -1442,29 +1443,26 @@
           nop->emit(*cb, C->regalloc());
           cb->flush_bundle(true);
           current_offset = cb->insts_size();
         }
 
+        bool observe_safepoint = is_sfn;
         // Remember the start of the last call in a basic block
         if (is_mcall) {
           MachCallNode *mcall = mach->as_MachCall();
 
           // This destination address is NOT PC-relative
           mcall->method_set((intptr_t)mcall->entry_point());
 
           // Save the return address
           call_returns[block->_pre_order] = current_offset + mcall->ret_addr_offset();
 
-          if (mcall->is_MachCallLeaf()) {
-            is_mcall = false;
-            is_sfn = false;
-          }
+          observe_safepoint = mcall->guaranteed_safepoint();
         }
 
         // sfn will be valid whenever mcall is valid now because of inheritance
-        if (is_sfn || is_mcall) {
-
+        if (observe_safepoint) {
           // Handle special safepoint nodes for synchronization
           if (!is_mcall) {
             MachSafePointNode *sfn = mach->as_MachSafePoint();
             // !!!!! Stubs only need an oopmap right now, so bail out
             if (sfn->jvms()->method() == NULL) {
@@ -3295,10 +3293,17 @@
     } else {
       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);
       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);
     }
 
+    address* native_stubs = NULL;
+    int num_stubs = 0;
+    if (!C->native_stubs()->is_empty()) {
+      num_stubs = C->native_stubs()->length();
+      native_stubs = NEW_C_HEAP_ARRAY(address, num_stubs, mtInternal);
+    }
+
     C->env()->register_method(target,
                                      entry_bci,
                                      &_code_offsets,
                                      _orig_pc_slot_offset_in_bytes,
                                      code_buffer(),
@@ -3307,11 +3312,13 @@
                                      &_handler_table,
                                      inc_table(),
                                      compiler,
                                      has_unsafe_access,
                                      SharedRuntime::is_wide_vector(C->max_vector_size()),
-                                     C->rtm_state());
+                                     C->rtm_state(),
+                                     native_stubs,
+                                     num_stubs);
 
     if (C->log() != NULL) { // Print code cache state into compiler log
       C->log()->code_cache_state();
     }
   }
diff a/src/hotspot/share/opto/type.cpp b/src/hotspot/share/opto/type.cpp
--- a/src/hotspot/share/opto/type.cpp
+++ b/src/hotspot/share/opto/type.cpp
@@ -1966,10 +1966,18 @@
 
 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
   return (TypeTuple*)(new TypeTuple(cnt,fields))->hashcons();
 }
 
+const TypeTuple *TypeTuple::make_func( uint arg_cnt, const Type **arg_fields ) {
+  const Type** field_array = fields(arg_cnt);
+  for (uint i = 0; i < arg_cnt; i++) {
+    field_array[i + TypeFunc::Parms] = arg_fields[i];
+  }
+  return make(arg_cnt + TypeFunc::Parms, field_array);
+}
+
 //------------------------------fields-----------------------------------------
 // Subroutine call type with space allocated for argument types
 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 const Type **TypeTuple::fields( uint arg_cnt ) {
   const Type **flds = (const Type **)(Compile::current()->type_arena()->Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
diff a/src/hotspot/share/opto/type.hpp b/src/hotspot/share/opto/type.hpp
--- a/src/hotspot/share/opto/type.hpp
+++ b/src/hotspot/share/opto/type.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -663,10 +663,11 @@
   }
 
   static const TypeTuple *make( uint cnt, const Type **fields );
   static const TypeTuple *make_range(ciSignature *sig);
   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
+  static const TypeTuple *make_func(uint arg_cnt, const Type **arg_fields);
 
   // Subroutine call type with space allocated for argument types
   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
   static const Type **fields( uint arg_cnt );
 
diff a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -421,10 +421,11 @@
   case vmIntrinsics::_invokeBasic:      return vmSymbols::invokeBasic_name();
   case vmIntrinsics::_linkToVirtual:    return vmSymbols::linkToVirtual_name();
   case vmIntrinsics::_linkToStatic:     return vmSymbols::linkToStatic_name();
   case vmIntrinsics::_linkToSpecial:    return vmSymbols::linkToSpecial_name();
   case vmIntrinsics::_linkToInterface:  return vmSymbols::linkToInterface_name();
+  case vmIntrinsics::_linkToNative:     return vmSymbols::linkToNative_name();
   default:
     fatal("unexpected intrinsic id: %d %s", iid, vmIntrinsics::name_at(iid));
     return 0;
   }
 }
@@ -443,10 +444,11 @@
 }
 
 int MethodHandles::signature_polymorphic_intrinsic_ref_kind(vmIntrinsics::ID iid) {
   switch (iid) {
   case vmIntrinsics::_invokeBasic:      return 0;
+  case vmIntrinsics::_linkToNative:     return 0;
   case vmIntrinsics::_linkToVirtual:    return JVM_REF_invokeVirtual;
   case vmIntrinsics::_linkToStatic:     return JVM_REF_invokeStatic;
   case vmIntrinsics::_linkToSpecial:    return JVM_REF_invokeSpecial;
   case vmIntrinsics::_linkToInterface:  return JVM_REF_invokeInterface;
   default:
@@ -466,10 +468,11 @@
   // There is one static signature-polymorphic method for each JVM invocation mode.
   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToVirtual_name):    return vmIntrinsics::_linkToVirtual;
   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToStatic_name):     return vmIntrinsics::_linkToStatic;
   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToSpecial_name):    return vmIntrinsics::_linkToSpecial;
   case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToInterface_name):  return vmIntrinsics::_linkToInterface;
+  case vmSymbols::VM_SYMBOL_ENUM_NAME(linkToNative_name):     return vmIntrinsics::_linkToNative;
   default:                                                    break;
   }
 
   // Cover the case of invokeExact and any future variants of invokeFoo.
   Klass* mh_klass = SystemDictionary::well_known_klass(
diff a/src/hotspot/share/prims/methodHandles.hpp b/src/hotspot/share/prims/methodHandles.hpp
--- a/src/hotspot/share/prims/methodHandles.hpp
+++ b/src/hotspot/share/prims/methodHandles.hpp
@@ -116,11 +116,11 @@
   }
 
   static bool has_member_arg(vmIntrinsics::ID iid) {
     assert(is_signature_polymorphic(iid), "");
     return (iid >= vmIntrinsics::_linkToVirtual &&
-            iid <= vmIntrinsics::_linkToInterface);
+            iid <= vmIntrinsics::_linkToNative);
   }
   static bool has_member_arg(Symbol* klass, Symbol* name) {
     if ((klass == vmSymbols::java_lang_invoke_MethodHandle() ||
          klass == vmSymbols::java_lang_invoke_VarHandle()) &&
         is_signature_polymorphic_name(name)) {
diff a/src/hotspot/share/prims/nativeEntryPoint.cpp b/src/hotspot/share/prims/nativeEntryPoint.cpp
--- /dev/null
+++ b/src/hotspot/share/prims/nativeEntryPoint.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/interfaceSupport.inline.hpp"
+#include "code/vmreg.hpp"
+
+JVM_ENTRY(jlong, NEP_vmStorageToVMReg(JNIEnv* env, jclass _unused, jint type, jint index)) {
+  ThreadToNativeFromVM ttnfvm(thread);
+  return VMRegImpl::vmStorageToVMReg(type, index)->value();
+}
+JVM_END
+
+#define CC (char*)  /*cast a literal from (const char*)*/
+#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)
+
+static JNINativeMethod NEP_methods[] = {
+  {CC "vmStorageToVMReg", CC "(II)J", FN_PTR(NEP_vmStorageToVMReg)},
+};
+
+JVM_ENTRY(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class)) {
+  {
+    ThreadToNativeFromVM ttnfv(thread);
+
+    int status = env->RegisterNatives(NEP_class, NEP_methods, sizeof(NEP_methods)/sizeof(JNINativeMethod));
+    guarantee(status == JNI_OK && !env->ExceptionOccurred(),
+              "register jdk.internal.invoke.NativeEntryPoint natives");
+  }
+}
+JVM_END
diff a/src/hotspot/share/prims/nativeLookup.cpp b/src/hotspot/share/prims/nativeLookup.cpp
--- a/src/hotspot/share/prims/nativeLookup.cpp
+++ b/src/hotspot/share/prims/nativeLookup.cpp
@@ -118,10 +118,11 @@
   void JNICALL JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass unsafecls);
   void JNICALL JVM_RegisterReferencesMethods(JNIEnv *env, jclass unsafecls);
   void JNICALL JVM_RegisterUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);
   void JNICALL JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass unsafecls);
   void JNICALL JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass unsafecls);
+  void JNICALL JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass unsafecls);
   void JNICALL JVM_RegisterPerfMethods(JNIEnv *env, jclass perfclass);
   void JNICALL JVM_RegisterWhiteBoxMethods(JNIEnv *env, jclass wbclass);
 #if INCLUDE_JVMCI
   jobject  JNICALL JVM_GetJVMCIRuntime(JNIEnv *env, jclass c);
   void     JNICALL JVM_RegisterJVMCINatives(JNIEnv *env, jclass compilerToVMClass);
@@ -135,10 +136,11 @@
   { CC"Java_jdk_internal_misc_Unsafe_registerNatives",             NULL, FN_PTR(JVM_RegisterJDKInternalMiscUnsafeMethods) },
   { CC"Java_java_lang_invoke_MethodHandleNatives_registerNatives", NULL, FN_PTR(JVM_RegisterMethodHandleMethods) },
   { CC"Java_jdk_internal_foreign_abi_UpcallStubs_registerNatives",      NULL, FN_PTR(JVM_RegisterUpcallHandlerMethods) },
   { CC"Java_jdk_internal_foreign_abi_ProgrammableUpcallHandler_registerNatives",      NULL, FN_PTR(JVM_RegisterProgrammableUpcallHandlerMethods) },
   { CC"Java_jdk_internal_foreign_abi_ProgrammableInvoker_registerNatives",      NULL, FN_PTR(JVM_RegisterProgrammableInvokerMethods) },
+  { CC"Java_jdk_internal_invoke_NativeEntryPoint_registerNatives",      NULL, FN_PTR(JVM_RegisterNativeEntryPointMethods) },
   { CC"Java_jdk_internal_perf_Perf_registerNatives",               NULL, FN_PTR(JVM_RegisterPerfMethods)         },
   { CC"Java_sun_hotspot_WhiteBox_registerNatives",                 NULL, FN_PTR(JVM_RegisterWhiteBoxMethods)     },
 #if INCLUDE_JVMCI
   { CC"Java_jdk_vm_ci_runtime_JVMCI_initializeRuntime",            NULL, FN_PTR(JVM_GetJVMCIRuntime)             },
   { CC"Java_jdk_vm_ci_hotspot_CompilerToVM_registerNatives",       NULL, FN_PTR(JVM_RegisterJVMCINatives)        },
diff a/src/hotspot/share/runtime/sharedRuntime.hpp b/src/hotspot/share/runtime/sharedRuntime.hpp
--- a/src/hotspot/share/runtime/sharedRuntime.hpp
+++ b/src/hotspot/share/runtime/sharedRuntime.hpp
@@ -523,10 +523,15 @@
   static address handle_wrong_method_abstract(JavaThread* thread);
   static address handle_wrong_method_ic_miss(JavaThread* thread);
 
   static address handle_unsafe_access(JavaThread* thread, address next_pc);
 
+  static address make_native_invoker(address call_target,
+                                     int shadow_space_bytes,
+                                     const GrowableArray<VMReg>& input_registers,
+                                     const GrowableArray<VMReg>& output_registers);
+
 #ifndef PRODUCT
 
   // Collect and print inline cache miss statistics
  private:
   enum { maxICmiss_count = 100 };
diff a/src/hotspot/share/runtime/vmStructs.cpp b/src/hotspot/share/runtime/vmStructs.cpp
--- a/src/hotspot/share/runtime/vmStructs.cpp
+++ b/src/hotspot/share/runtime/vmStructs.cpp
@@ -1533,10 +1533,11 @@
   declare_c2_type(CallJavaNode, CallNode)                                 \
   declare_c2_type(CallStaticJavaNode, CallJavaNode)                       \
   declare_c2_type(CallDynamicJavaNode, CallJavaNode)                      \
   declare_c2_type(CallRuntimeNode, CallNode)                              \
   declare_c2_type(CallLeafNode, CallRuntimeNode)                          \
+  declare_c2_type(CallNativeNode, CallNode)                               \
   declare_c2_type(CallLeafNoFPNode, CallLeafNode)                         \
   declare_c2_type(AllocateNode, CallNode)                                 \
   declare_c2_type(AllocateArrayNode, AllocateNode)                        \
   declare_c2_type(LockNode, AbstractLockNode)                             \
   declare_c2_type(UnlockNode, AbstractLockNode)                           \
@@ -1649,10 +1650,11 @@
   declare_c2_type(MachCallNode, MachSafePointNode)                        \
   declare_c2_type(MachCallJavaNode, MachCallNode)                         \
   declare_c2_type(MachCallStaticJavaNode, MachCallJavaNode)               \
   declare_c2_type(MachCallDynamicJavaNode, MachCallJavaNode)              \
   declare_c2_type(MachCallRuntimeNode, MachCallNode)                      \
+  declare_c2_type(MachCallNativeNode, MachCallNode)                       \
   declare_c2_type(MachHaltNode, MachReturnNode)                           \
   declare_c2_type(MachTempNode, MachNode)                                 \
   declare_c2_type(MemNode, Node)                                          \
   declare_c2_type(MergeMemNode, Node)                                     \
   declare_c2_type(LoadNode, MemNode)                                      \
@@ -2542,10 +2544,11 @@
   declare_constant(vmIntrinsics::_invokeBasic)                            \
   declare_constant(vmIntrinsics::_linkToVirtual)                          \
   declare_constant(vmIntrinsics::_linkToStatic)                           \
   declare_constant(vmIntrinsics::_linkToSpecial)                          \
   declare_constant(vmIntrinsics::_linkToInterface)                        \
+  declare_constant(vmIntrinsics::_linkToNative)                           \
                                                                           \
   /********************************/                                      \
   /* Calling convention constants */                                      \
   /********************************/                                      \
                                                                           \
diff a/src/hotspot/share/utilities/growableArray.hpp b/src/hotspot/share/utilities/growableArray.hpp
--- a/src/hotspot/share/utilities/growableArray.hpp
+++ b/src/hotspot/share/utilities/growableArray.hpp
@@ -29,10 +29,11 @@
 #include "memory/iterator.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/globalDefinitions.hpp"
 #include "utilities/ostream.hpp"
 #include "utilities/powerOfTwo.hpp"
+#include "utilities/ostream.hpp"
 
 // A growable array.
 
 /*************************************************************************/
 /*                                                                       */
@@ -122,10 +123,25 @@
       GrowableArrayBase(initial_max, initial_len), _data(data) {}
 
   ~GrowableArrayView() {}
 
 public:
+  bool operator==(const GrowableArrayView<E>& rhs) const {
+    if (_len != rhs._len)
+      return false;
+    for (int i = 0; i < _len; i++) {
+      if (at(i) != rhs.at(i)) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  bool operator!=(const GrowableArrayView<E>& rhs) const {
+    return !(*this == rhs);
+  }
+
   E& at(int i) {
     assert(0 <= i && i < _len, "illegal index");
     return _data[i];
   }
 
@@ -283,17 +299,21 @@
       }
     }
     return min;
   }
 
-  void print() {
-    tty->print("Growable Array " INTPTR_FORMAT, this);
-    tty->print(": length %ld (_max %ld) { ", _len, _max);
+  void print_on(outputStream *st) const {
+    st->print("Growable Array " INTPTR_FORMAT, (intptr_t) this);
+    st->print(": length %d (_max %d) { ", _len, _max);
     for (int i = 0; i < _len; i++) {
-      tty->print(INTPTR_FORMAT " ", *(intptr_t*)&(_data[i]));
+      st->print(INTPTR_FORMAT " ", *(intptr_t*)&(_data[i]));
     }
-    tty->print("}\n");
+    st->print("}\n");
+  }
+
+  void print() {
+    print_on(tty);
   }
 };
 
 // GrowableArrayWithAllocator extends the "view" with
 // the capability to grow and deallocate the data array.
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandle.java b/src/java.base/share/classes/java/lang/invoke/MethodHandle.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandle.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandle.java
@@ -603,10 +603,14 @@
      */
     @HotSpotIntrinsicCandidate
     /*non-public*/
     static native @PolymorphicSignature Object linkToInterface(Object... args) throws Throwable;
 
+    /** TODO */
+    @HotSpotIntrinsicCandidate
+    /*non-public*/ static native @PolymorphicSignature Object linkToNative(Object... args) throws Throwable;
+
     /**
      * Performs a variable arity invocation, passing the arguments in the given array
      * to the method handle, as if via an inexact {@link #invoke invoke} from a call site
      * which mentions only the type {@code Object}, and whose actual argument count is the length
      * of the argument array.
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleImpl.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -25,10 +25,11 @@
 
 package java.lang.invoke;
 
 import jdk.internal.access.JavaLangInvokeAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.invoke.NativeEntryPoint;
 import jdk.internal.org.objectweb.asm.ClassWriter;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.reflect.CallerSensitive;
 import jdk.internal.reflect.Reflection;
 import jdk.internal.vm.annotation.ForceInline;
@@ -1829,10 +1830,15 @@
             }
 
             @Override
             public long[] memoryAddressStrides(VarHandle handle) {
                 return checkMemoryAccessHandle(handle).strides();
+            }
+
+            @Override
+            public MethodHandle nativeMethodHandle(NativeEntryPoint nep, MethodHandle fallback) {
+                return NativeMethodHandle.make(nep, fallback);
             }
 
             @Override
             public boolean isMemoryAccessVarHandle(VarHandle handle) {
                 return asMemoryAccessVarHandle(handle) != null;
diff a/src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java b/src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodTypeForm.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -84,11 +84,12 @@
             LF_GWC                     = 16,  // guardWithCatch (catchException)
             LF_GWT                     = 17,  // guardWithTest
             LF_TF                      = 18,  // tryFinally
             LF_LOOP                    = 19,  // loop
             LF_INVSPECIAL_IFC          = 20,  // DMH invokeSpecial of (private) interface method
-            LF_LIMIT                   = 21;
+            LF_INVNATIVE               = 21,  // NMH invokeNative
+            LF_LIMIT                   = 22;
 
     /** Return the type corresponding uniquely (1-1) to this MT-form.
      *  It might have any primitive returns or arguments, but will have no references except Object.
      */
     public MethodType erasedType() {
diff a/src/java.base/share/classes/java/lang/invoke/NativeMethodHandle.java b/src/java.base/share/classes/java/lang/invoke/NativeMethodHandle.java
--- /dev/null
+++ b/src/java.base/share/classes/java/lang/invoke/NativeMethodHandle.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.lang.invoke;
+
+import jdk.internal.vm.annotation.ForceInline;
+import jdk.internal.invoke.NativeEntryPoint;
+
+import static java.lang.invoke.LambdaForm.*;
+import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;
+import static java.lang.invoke.MethodHandleStatics.newInternalError;
+
+/** TODO */
+/*non-public*/ class NativeMethodHandle extends MethodHandle {
+    final NativeEntryPoint nep;
+    final MethodHandle fallback;
+
+    /**
+     * TODO
+     */
+    private NativeMethodHandle(MethodType type, LambdaForm form, MethodHandle fallback, NativeEntryPoint nep) {
+        super(type, form);
+        this.fallback = fallback;
+        this.nep = nep;
+    }
+
+    /** TODO */
+    public static MethodHandle make(NativeEntryPoint nep, MethodHandle fallback) {
+        MethodType type = nep.type();
+        if (!allTypesPrimitive(type))
+            throw new IllegalArgumentException("Type must only contain primitives: " + type);
+
+        if (type != fallback.type())
+            throw new IllegalArgumentException("Type of fallback must match");
+
+        LambdaForm lform = preparedLambdaForm(type);
+        return new NativeMethodHandle(type, lform, fallback, nep);
+    }
+
+    private static boolean allTypesPrimitive(MethodType type) {
+        if (!type.returnType().isPrimitive())
+            return false;
+
+        for (Class<?> pType : type.parameterArray()) {
+            if (!pType.isPrimitive())
+                return false;
+        }
+
+        return true;
+    }
+
+    private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
+
+    private static LambdaForm preparedLambdaForm(MethodType mtype) {
+        int id = MethodTypeForm.LF_INVNATIVE;
+        mtype = mtype.basicType();
+        LambdaForm lform = mtype.form().cachedLambdaForm(id);
+        if (lform != null) return lform;
+        lform = makePreparedLambdaForm(mtype);
+        return mtype.form().setCachedLambdaForm(id, lform);
+    }
+
+    private static LambdaForm makePreparedLambdaForm(MethodType mtype) {
+        MethodType linkerType = mtype.insertParameterTypes(0, MethodHandle.class)
+                .appendParameterTypes(Object.class);
+        MemberName linker = new MemberName(MethodHandle.class, "linkToNative", linkerType, REF_invokeStatic);
+        try {
+            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);
+        } catch (ReflectiveOperationException ex) {
+            throw newInternalError(ex);
+        }
+        final int NMH_THIS = 0;
+        final int ARG_BASE = 1;
+        final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();
+        int nameCursor = ARG_LIMIT;
+        final int GET_FALLBACK = nameCursor++;
+        final int GET_NEP = nameCursor++;
+        final int LINKER_CALL = nameCursor++;
+        LambdaForm.Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());
+        assert (names.length == nameCursor);
+        names[GET_FALLBACK] = new LambdaForm.Name(Lazy.NF_internalFallback, names[NMH_THIS]);
+        names[GET_NEP] = new LambdaForm.Name(Lazy.NF_internalNativeEntryPoint, names[NMH_THIS]);
+        Object[] outArgs = new Object[linkerType.parameterCount()];
+        // Need to pass fallback here so we can call it without destroying the receiver register!!
+        outArgs[0] = names[GET_FALLBACK];
+        System.arraycopy(names, ARG_BASE, outArgs, 1, mtype.parameterCount());
+        outArgs[outArgs.length - 1] = names[GET_NEP];
+        names[LINKER_CALL] = new LambdaForm.Name(linker, outArgs);
+        LambdaForm lform = new LambdaForm(ARG_LIMIT, names, LAST_RESULT);
+        // This is a tricky bit of code.  Don't send it through the LF interpreter.
+        lform.compileToBytecode();
+        return lform;
+    }
+
+    final
+    @Override
+    MethodHandle copyWith(MethodType mt, LambdaForm lf) {
+        assert (this.getClass() == NativeMethodHandle.class);  // must override in subclasses
+        return new NativeMethodHandle(mt, lf, fallback, nep);
+    }
+
+    @Override
+    BoundMethodHandle rebind() {
+        return BoundMethodHandle.makeReinvoker(this);
+    }
+
+    @ForceInline
+    static Object internalNativeEntryPoint(Object mh) {
+        return ((NativeMethodHandle)mh).nep;
+    }
+
+    @ForceInline
+    static MethodHandle internalFallback(Object mh) {
+        return ((NativeMethodHandle)mh).fallback;
+    }
+
+    /**
+     * Pre-initialized NamedFunctions for bootstrapping purposes.
+     * Factored in an inner class to delay initialization until first usage.
+     */
+    private static class Lazy {
+        static Class<NativeMethodHandle> THIS_CLASS = NativeMethodHandle.class;
+
+        static final NamedFunction
+                NF_internalNativeEntryPoint;
+        static final NamedFunction
+                NF_internalFallback;
+
+        static {
+            try {
+                NamedFunction[] nfs = new NamedFunction[]{
+                        NF_internalNativeEntryPoint = new NamedFunction(
+                                THIS_CLASS.getDeclaredMethod("internalNativeEntryPoint", Object.class)),
+                        NF_internalFallback = new NamedFunction(
+                                THIS_CLASS.getDeclaredMethod("internalFallback", Object.class))
+                };
+                for (NamedFunction nf : nfs) {
+                    // Each nf must be statically invocable or we get tied up in our bootstraps.
+                    assert (InvokerBytecodeGenerator.isStaticallyInvocable(nf.member)) : nf;
+                    nf.resolve();
+                }
+            } catch (ReflectiveOperationException ex) {
+                throw newInternalError(ex);
+            }
+        }
+    }
+}
diff a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -23,10 +23,12 @@
  * questions.
  */
 
 package jdk.internal.access;
 
+import jdk.internal.invoke.NativeEntryPoint;
+
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
 import java.nio.ByteOrder;
 import java.util.List;
@@ -187,6 +189,17 @@
     /**
      * Var handle insert coordinates combinator.
      * Used by {@code jdk.incubator.foreign.MemoryHandles}.
      */
     VarHandle insertCoordinates(VarHandle target, int pos, Object... values);
+
+    /**
+     * Returns a native method handle with given arguments as fallback and steering info.
+     *
+     * Will allow JIT to intrinsify.
+     *
+     * @param nep the native entry point
+     * @param fallback the fallback handle
+     * @return the native method handle
+     */
+    MethodHandle nativeMethodHandle(NativeEntryPoint nep, MethodHandle fallback);
 }
diff a/src/java.base/share/classes/jdk/internal/invoke/ABIDescriptorProxy.java b/src/java.base/share/classes/jdk/internal/invoke/ABIDescriptorProxy.java
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/invoke/ABIDescriptorProxy.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.invoke;
+
+public interface ABIDescriptorProxy {
+    int shadowSpaceBytes();
+}
diff a/src/java.base/share/classes/jdk/internal/invoke/NativeEntryPoint.java b/src/java.base/share/classes/jdk/internal/invoke/NativeEntryPoint.java
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/invoke/NativeEntryPoint.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.internal.invoke;
+
+import java.lang.invoke.MethodType;
+import java.util.Objects;
+
+/** TODO */
+public class NativeEntryPoint {
+    static {
+        registerNatives();
+    }
+
+    private final long addr;
+
+    private final int shadowSpace;
+
+    // encoded as VMRegImpl*
+    private final long[] argMoves;
+    private final long[] returnMoves;
+
+    private final boolean needTransition;
+    private final MethodType methodType; // C2 sees erased version (byte -> int), so need this explicitly
+    private final String name;
+
+    private NativeEntryPoint(long addr, int shadowSpace, long[] argMoves, long[] returnMoves,
+                     boolean needTransition, MethodType methodType, String name) {
+        this.addr = addr;
+        this.shadowSpace = shadowSpace;
+        this.argMoves = Objects.requireNonNull(argMoves);
+        this.returnMoves = Objects.requireNonNull(returnMoves);
+        this.needTransition = needTransition;
+        this.methodType = methodType;
+        this.name = name;
+    }
+
+    public static NativeEntryPoint make(long addr, String name, ABIDescriptorProxy abi, VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,
+                                        boolean needTransition, MethodType methodType) {
+        if (returnMoves.length > 1) {
+            throw new IllegalArgumentException("Multiple register return not supported");
+        }
+
+        return new NativeEntryPoint(
+            addr, abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves), needTransition, methodType, name);
+    }
+
+    private static long[] encodeVMStorages(VMStorageProxy[] moves) {
+        long[] out = new long[moves.length];
+        for (int i = 0; i < moves.length; i++) {
+            out[i] = vmStorageToVMReg(moves[i].type(), moves[i].index());
+        }
+        return out;
+    }
+
+    private static native long vmStorageToVMReg(int type, int index);
+
+    public MethodType type() {
+        return methodType;
+    }
+
+    private static native void registerNatives();
+}
diff a/src/java.base/share/classes/jdk/internal/invoke/VMStorageProxy.java b/src/java.base/share/classes/jdk/internal/invoke/VMStorageProxy.java
--- /dev/null
+++ b/src/java.base/share/classes/jdk/internal/invoke/VMStorageProxy.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.internal.invoke;
+
+public interface VMStorageProxy {
+    int type();
+    int index();
+}
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -342,10 +342,12 @@
         java.desktop,
         java.logging,
         java.prefs;
     exports sun.util.resources to
         jdk.localedata;
+    exports jdk.internal.invoke to
+        jdk.incubator.foreign;
 
 
     // the service types defined by the APIs in this module
 
     uses java.lang.System.LoggerFinder;
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/FunctionDescriptor.java
@@ -1,7 +1,7 @@
 /*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  *  This code is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 only, as
  *  published by the Free Software Foundation.
@@ -26,30 +26,50 @@
 import java.lang.constant.ConstantDesc;
 import java.lang.constant.ConstantDescs;
 import java.lang.constant.DynamicConstantDesc;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
  * A function descriptor is made up of zero or more argument layouts and one return  A function descriptor
  * is used to model the signature of native functions.
  */
 public final class FunctionDescriptor implements Constable {
+    public static final String IS_TRIVIAL = "abi/is_trivial";
     
     private final MemoryLayout resLayout;
     private final MemoryLayout[] argLayouts;
+    private final Map<String, Constable> attributes;
 
-    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {
+    private FunctionDescriptor(MemoryLayout resLayout, Map<String, Constable> attributes, MemoryLayout... argLayouts) {
         this.resLayout = resLayout;
+        this.attributes = Collections.unmodifiableMap(attributes);
         this.argLayouts = argLayouts;
     }
 
+    public Optional<Constable> attribute(String name) {
+        return Optional.ofNullable(attributes.get(name));
+    }
+
+    public Stream<String> attributes() {
+        return attributes.keySet().stream();
+    }
+
+    public FunctionDescriptor withAttribute(String name, Constable value) {
+        Map<String, Constable> newAttributes = new HashMap<>(attributes);
+        newAttributes.put(name, value);
+        return new FunctionDescriptor(resLayout, newAttributes, argLayouts);
+    }
+
     /**
      * Returns the return foreign.layout associated with this function.
      * @return the return
      */
     public Optional<MemoryLayout> returnLayout() {
@@ -69,20 +89,20 @@
      * @param resLayout the return
      * @param argLayouts the argument layouts.
      * @return the new function descriptor.
      */
     public static FunctionDescriptor of(MemoryLayout resLayout, MemoryLayout... argLayouts) {
-        return new FunctionDescriptor(resLayout, argLayouts);
+        return new FunctionDescriptor(resLayout, Map.of(), argLayouts);
     }
 
     /**
      * Create a void function descriptor with given argument layouts.
      * @param argLayouts the argument layouts.
      * @return the new function descriptor.
      */
     public static FunctionDescriptor ofVoid(MemoryLayout... argLayouts) {
-        return new FunctionDescriptor(null, argLayouts);
+        return new FunctionDescriptor(null, Map.of(), argLayouts);
     }
 
     /**
      * Create a new function descriptor with the given argument layouts appended to the argument layout array
      * of this function descriptor.
@@ -90,20 +110,20 @@
      * @return the new function descriptor
      */
     public FunctionDescriptor appendArgumentLayouts(MemoryLayout... addedLayouts) {
         MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);
         System.arraycopy(addedLayouts, 0, newLayouts, argLayouts.length, addedLayouts.length);
-        return new FunctionDescriptor(resLayout, newLayouts);
+        return new FunctionDescriptor(resLayout, attributes, newLayouts);
     }
 
     /**
      * Create a new function descriptor with the given memory layout as the new return layout.
      * @param newReturn the new return layout
      * @return the new function descriptor
      */
     public FunctionDescriptor changeReturnLayout(MemoryLayout newReturn) {
-        return new FunctionDescriptor(newReturn, argLayouts);
+        return new FunctionDescriptor(newReturn, attributes, argLayouts);
     }
 
     /**
      * Returns a string representation of this function descriptor.
      * @return a string representation of this function descriptor.
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -25,10 +25,11 @@
  */
 
 package jdk.internal.foreign;
 
 import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.ValueLayout;
@@ -141,6 +142,7 @@
 
     public static void checkLayoutType(MemoryLayout layout, Class<? extends MemoryLayout> layoutType) {
         if (!layoutType.isInstance(layout))
             throw new IllegalArgumentException("Expected a " + layoutType.getSimpleName() + ": " + layout);
     }
+
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ABIDescriptor.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ABIDescriptor.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ABIDescriptor.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ABIDescriptor.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,26 +20,33 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi;
 
-public class ABIDescriptor {
+import jdk.internal.invoke.ABIDescriptorProxy;
+
+public class ABIDescriptor implements ABIDescriptorProxy {
     final Architecture arch;
 
     public final VMStorage[][] inputStorage;
     public final VMStorage[][] outputStorage;
 
     final VMStorage[][] volatileStorage;
 
     final int stackAlignment;
     final int shadowSpace;
 
-    public ABIDescriptor(Architecture arch, jdk.internal.foreign.abi.VMStorage[][] inputStorage, jdk.internal.foreign.abi.VMStorage[][] outputStorage,
+    public ABIDescriptor(Architecture arch, VMStorage[][] inputStorage, VMStorage[][] outputStorage,
                          VMStorage[][] volatileStorage, int stackAlignment, int shadowSpace) {
         this.arch = arch;
         this.inputStorage = inputStorage;
         this.outputStorage = outputStorage;
         this.volatileStorage = volatileStorage;
         this.stackAlignment = stackAlignment;
         this.shadowSpace = shadowSpace;
     }
+
+    @Override
+    public int shadowSpaceBytes() {
+        return shadowSpace;
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequence.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequence.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequence.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequence.java
@@ -30,18 +30,20 @@
 import java.util.stream.Stream;
 
 public class CallingSequence {
     private final MethodType mt;
     private final FunctionDescriptor desc;
+    private final boolean isTrivial;
 
     private final List<Binding> returnBindings;
     private final List<List<Binding>> argumentBindings;
 
     public CallingSequence(MethodType mt, FunctionDescriptor desc,
-                           List<List<Binding>> argumentBindings, List<Binding> returnBindings) {
+                           boolean isTrivial, List<List<Binding>> argumentBindings, List<Binding> returnBindings) {
         this.mt = mt;
         this.desc = desc;
+        this.isTrivial = isTrivial;
         this.returnBindings = returnBindings;
         this.argumentBindings = argumentBindings;
     }
 
     public Stream<Binding.Move> argMoveBindings() {
@@ -97,6 +99,10 @@
     }
 
     public FunctionDescriptor functionDesc() {
         return desc;
     }
+
+    public boolean isTrivial() {
+        return isTrivial;
+    }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/CallingSequenceBuilder.java
@@ -1,7 +1,7 @@
 /*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  *  This code is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 only, as
  *  published by the Free Software Foundation.
@@ -34,10 +34,11 @@
 
 public class CallingSequenceBuilder {
     private static final boolean VERIFY_BINDINGS = Boolean.parseBoolean(
             GetPropertyAction.privilegedGetProperty("jdk.incubator.foreign.VERIFY_BINDINGS", "true"));
 
+    private boolean isTrivial;
     private final boolean forUpcall;
     private final List<List<Binding>> inputBindings = new ArrayList<>();
     private List<Binding> outputBindings = List.of();
 
     private MethodType mt = MethodType.methodType(void.class);
@@ -63,12 +64,17 @@
         mt = mt.changeReturnType(carrier);
         desc = desc.changeReturnLayout(layout);
         return this;
     }
 
+    public CallingSequenceBuilder setTrivial(boolean isTrivial) {
+        this.isTrivial = isTrivial;
+        return this;
+    }
+
     public CallingSequence build() {
-        return new CallingSequence(mt, desc, inputBindings, outputBindings);
+        return new CallingSequence(mt, desc, isTrivial, inputBindings, outputBindings);
     }
 
     private void verifyBindings(boolean forArguments, Class<?> carrier, List<Binding> bindings) {
         if (VERIFY_BINDINGS) {
             if (forUpcall == forArguments) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -24,12 +24,16 @@
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryHandles;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.NativeScope;
+import jdk.internal.access.JavaLangInvokeAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.foreign.MemoryAddressImpl;
 import jdk.internal.foreign.Utils;
+import jdk.internal.invoke.NativeEntryPoint;
+import jdk.internal.invoke.VMStorageProxy;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
@@ -61,10 +65,14 @@
 public class ProgrammableInvoker {
     private static final boolean DEBUG =
         privilegedGetProperty("jdk.internal.foreign.ProgrammableInvoker.DEBUG");
     private static final boolean NO_SPEC =
         privilegedGetProperty("jdk.internal.foreign.ProgrammableInvoker.NO_SPEC");
+    private static final boolean NO_INTRINSICS =
+        privilegedGetProperty("jdk.internal.foreign.ProgrammableInvoker.NO_INTRINSICS");
+
+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();
 
     private static final VarHandle VH_LONG = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
 
     private static final MethodHandle MH_INVOKE_MOVES;
     private static final MethodHandle MH_INVOKE_INTERP_BINDINGS;
@@ -150,10 +158,24 @@
 
         MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 1, argMoves, retMoves)
                                             .asCollector(Object[].class, leafType.parameterCount())
                                             .asType(leafType);
 
+        if (!(NO_INTRINSICS || retMoves.length > 1)) {
+            NativeEntryPoint nep = NativeEntryPoint.make(
+                addr.toRawLongValue(),
+                "native_call",
+                abi,
+                toStorageArray(argMoves),
+                toStorageArray(retMoves),
+                !callingSequence.isTrivial(),
+                leafType
+            );
+
+            handle = JLIA.nativeMethodHandle(nep, handle);
+        }
+
         if (NO_SPEC || retMoves.length > 1) {
             Map<VMStorage, Integer> argIndexMap = indexMap(argMoves);
             Map<VMStorage, Integer> retIndexMap = indexMap(retMoves);
 
             handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 1, handle, argIndexMap, retIndexMap);
@@ -164,10 +186,14 @@
          }
 
         return handle;
     }
 
+    private VMStorageProxy[] toStorageArray(Binding.Move[] moves) {
+        return Arrays.stream(moves).map(Binding.Move::storage).toArray(VMStorage[]::new);
+    }
+
     private MethodHandle specialize(MethodHandle leafHandle) {
         MethodType highLevelType = callingSequence.methodType();
         MethodType leafType = leafHandle.type();
 
         MethodHandle specializedHandle = leafHandle; // initial
@@ -213,10 +239,18 @@
             specializedHandle = collectArguments(specializedHandle, 0, insertArguments(MH_MAKE_ALLOCATOR, 0, bufferCopySize));
         }
         return specializedHandle;
     }
 
+    private static long toRawLongValue(MemoryAddress address) {
+        return address.toRawLongValue(); // Workaround for JDK-8239083
+    }
+
+    private static MemoryAddress ofLong(long address) {
+        return MemoryAddress.ofLong(address); // Workaround for JDK-8239083
+    }
+
     private Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {
         return IntStream.range(0, moves.length)
                         .boxed()
                         .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -326,10 +326,16 @@
             throw new IllegalArgumentException(
                     String.format("Invalid operand type: %s. %s expected", actualType, expectedType));
         }
     }
 
+    public static boolean isTrivial(FunctionDescriptor cDesc) {
+        return cDesc.attribute(FunctionDescriptor.IS_TRIVIAL)
+                .map(Boolean.class::cast)
+                .orElse(false);
+    }
+
     public static class SimpleVaArg {
         public final Class<?> carrier;
         public final MemoryLayout layout;
         public final Object value;
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/VMStorage.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/VMStorage.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/VMStorage.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/VMStorage.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -20,13 +20,15 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package jdk.internal.foreign.abi;
 
+import jdk.internal.invoke.VMStorageProxy;
+
 import java.util.Objects;
 
-public class VMStorage {
+public class VMStorage implements VMStorageProxy {
     private final int type;
     private final int index;
 
     private final String debugName;
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/CallArranger.java
@@ -118,10 +118,12 @@
             Class<?> carrier = mt.parameterType(i);
             MemoryLayout layout = cDesc.argumentLayouts().get(i);
             csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));
         }
 
+        csb.setTrivial(SharedUtils.isTrivial(cDesc));
+
         return new Bindings(csb.build(), returnInMemory);
     }
 
     public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/CallArranger.java
@@ -42,11 +42,10 @@
 import jdk.internal.foreign.abi.SharedUtils;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
 import java.lang.invoke.MethodType;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
 
 import static jdk.incubator.foreign.CSupport.*;
 import static jdk.internal.foreign.abi.Binding.*;
@@ -115,10 +114,12 @@
             //add extra binding for number of used vector registers (used for variadic calls)
             csb.addArgumentBindings(long.class, SysV.C_LONG,
                     List.of(move(rax, long.class)));
         }
 
+        csb.setTrivial(SharedUtils.isTrivial(cDesc));
+
         return new Bindings(csb.build(), returnInMemory, argCalc.storageCalculator.nVectorReg);
     }
 
     public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/CallArranger.java
@@ -113,10 +113,12 @@
 
         for (int i = 0; i < mt.parameterCount(); i++) {
             csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i));
         }
 
+        csb.csb.setTrivial(SharedUtils.isTrivial(cDesc));
+
         return new Bindings(csb.csb.build(), returnInMemory);
     }
 
     public static MethodHandle arrangeDowncall(MemoryAddress addr, MethodType mt, FunctionDescriptor cDesc) {
         Bindings bindings = getBindings(mt, cDesc, false);
diff a/test/jdk/java/foreign/TestDowncall.java b/test/jdk/java/foreign/TestDowncall.java
--- a/test/jdk/java/foreign/TestDowncall.java
+++ b/test/jdk/java/foreign/TestDowncall.java
@@ -1,7 +1,7 @@
 /*
- *  Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ *  Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  *  This code is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 only, as
  *  published by the Free Software Foundation.
@@ -33,11 +33,20 @@
  * @run testng/othervm
  *   -Dforeign.restricted=permit
  *   TestDowncall
  * @run testng/othervm
  *   -Dforeign.restricted=permit
+ *   -Djdk.internal.foreign.ProgrammableInvoker.NO_INTRINSICS=true
+ *   TestDowncall
+ * @run testng/othervm
+ *   -Dforeign.restricted=permit
+ *   -Djdk.internal.foreign.ProgrammableInvoker.NO_SPEC=true
+ *   TestDowncall
+ * @run testng/othervm
+ *   -Dforeign.restricted=permit
  *   -Djdk.internal.foreign.ProgrammableInvoker.NO_SPEC=true
+ *   -Djdk.internal.foreign.ProgrammableInvoker.NO_INTRINSICS=true
  *   TestDowncall
  */
 
 import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.FunctionDescriptor;
diff a/test/jdk/java/foreign/TestIntrinsics.java b/test/jdk/java/foreign/TestIntrinsics.java
--- /dev/null
+++ b/test/jdk/java/foreign/TestIntrinsics.java
@@ -0,0 +1,176 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ */
+
+/*
+ * @test
+ * @modules jdk.incubator.foreign/jdk.incubator.foreign.unsafe
+ *          jdk.incubator.foreign/jdk.internal.foreign
+ *          jdk.incubator.foreign/jdk.internal.foreign.abi
+ *          java.base/sun.security.action
+ * @build NativeTestHelper
+ * @run testng/othervm -Dforeign.restricted=permit -Xbatch TestIntrinsics
+ */
+
+import jdk.incubator.foreign.CSupport;
+import jdk.incubator.foreign.ForeignLinker;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+import jdk.incubator.foreign.MemoryLayout;
+import org.testng.annotations.*;
+
+import static java.lang.invoke.MethodType.methodType;
+import static jdk.incubator.foreign.CSupport.*;
+import static org.testng.Assert.assertEquals;
+
+public class TestIntrinsics extends NativeTestHelper {
+
+    static final ForeignLinker abi = CSupport.getSystemLinker();
+    static final LibraryLookup lookup = LibraryLookup.ofLibrary("Intrinsics");
+
+    private static final MethodHandle MH_empty;
+    private static final MethodHandle MH_identity_int;
+    private static final MethodHandle MH_identity_char;
+    private static final MethodHandle MH_identity_short;
+    private static final MethodHandle MH_identity_long;
+    private static final MethodHandle MH_identity_float;
+    private static final MethodHandle MH_identity_double;
+    private static final MethodHandle MH_identity_va;
+    private static final MethodHandle MH_invoke_consumer;
+
+    private static MethodHandle linkIndentity(String name, Class<?> carrier, MemoryLayout layout)
+            throws NoSuchMethodException {
+        MemoryAddress ma = lookup.lookup(name);
+        MethodType mt = methodType(carrier, carrier);
+        FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);
+        return abi.downcallHandle(ma, mt, fd);
+    }
+
+    static {
+        try {
+            {
+                MemoryAddress ma = lookup.lookup("empty");
+                MethodType mt = methodType(void.class);
+                FunctionDescriptor fd = FunctionDescriptor.ofVoid();
+                MH_empty = abi.downcallHandle(ma, mt, fd);
+            }
+            MH_identity_char = linkIndentity("identity_char", byte.class, C_CHAR);
+            MH_identity_short = linkIndentity("identity_short", short.class, C_SHORT);
+            MH_identity_int = linkIndentity("identity_int", int.class, C_INT);
+            MH_identity_long = linkIndentity("identity_long", long.class, C_LONGLONG);
+            MH_identity_float = linkIndentity("identity_float", float.class, C_FLOAT);
+            MH_identity_double = linkIndentity("identity_double", double.class, C_DOUBLE);
+            {
+                MemoryAddress ma = lookup.lookup("identity_va");
+                MethodType mt = methodType(int.class, int.class, double.class, int.class, float.class, long.class);
+                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, asVarArg(C_DOUBLE),
+                        asVarArg(C_INT), asVarArg(C_FLOAT), asVarArg(C_LONGLONG));
+                MH_identity_va = abi.downcallHandle(ma, mt, fd);
+            }
+            {
+                MemoryAddress ma = lookup.lookup("invoke_consumer");
+                MethodType mt = methodType(void.class, int.class, double.class, long.class, float.class, byte.class,
+                        short.class, char.class);
+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_DOUBLE, C_LONGLONG, C_FLOAT, C_CHAR,
+                        C_SHORT, C_SHORT);
+                MH_invoke_consumer = abi.downcallHandle(ma, mt, fd);
+            }
+        } catch (ReflectiveOperationException e) {
+            throw new BootstrapMethodError(e);
+        }
+    }
+
+    @DataProvider
+    public Object[][] handles() throws Throwable {
+        return new Object[][] {
+            { "invoke_empty" },
+            { "invoke_identity_char" },
+            { "invoke_identity_short" },
+            { "invoke_identity_int" },
+            { "invoke_identity_long" },
+            { "invoke_identity_float" },
+            { "invoke_identity_double" },
+            { "invoke_identity_va" },
+            { "invoke_consumer" },
+        };
+    }
+
+    @Test(dataProvider = "handles")
+    public void testIntrinsics(String methodName) throws Throwable {
+        MethodHandle handle = MethodHandles.lookup().findStatic(TestIntrinsics.class, methodName, methodType(void.class));
+
+        for (int i = 0; i < 20_000; i++) {
+            handle.invokeExact();
+        }
+    }
+
+    // where
+
+    public static void invoke_empty() throws Throwable {
+        MH_empty.invokeExact();
+    }
+
+    public static void invoke_identity_char() throws Throwable {
+        byte x = (byte) MH_identity_char.invokeExact((byte) 10);
+        assertEquals(x, (byte) 10);
+    }
+
+    public static void invoke_identity_short() throws Throwable {
+        short x = (short) MH_identity_short.invokeExact((short) 10);
+        assertEquals(x, (short) 10);
+    }
+
+    public static void invoke_identity_int() throws Throwable {
+        int x = (int) MH_identity_int.invokeExact(10);
+        assertEquals(x, 10);
+    }
+
+    public static void invoke_identity_long() throws Throwable {
+        long x = (long) MH_identity_long.invokeExact(10L);
+        assertEquals(x, 10L);
+    }
+
+    public static void invoke_identity_float() throws Throwable {
+        float x = (float) MH_identity_float.invokeExact(10F);
+        assertEquals(x, 10F);
+    }
+
+    public static void invoke_identity_double() throws Throwable {
+        double x = (double) MH_identity_double.invokeExact(10D);
+        assertEquals(x, 10D);
+    }
+
+    public static void invoke_identity_va() throws Throwable {
+        int x = (int) MH_identity_va.invokeExact(1, 10D, 2, 3F, 4L);
+        assertEquals(x, 1);
+    }
+
+    public static void invoke_consumer() throws Throwable {
+        MH_invoke_consumer.invokeExact(1, 10D, 2L, 3F, (byte) 0, (short) 13, (char) 'a');
+    }
+}
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  *  This code is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 only, as
  *  published by the Free Software Foundation.
@@ -22,22 +22,20 @@
  *
  */
 
 /*
  * @test
- * @modules java.base/jdk.internal.misc
- *          jdk.incubator.foreign/jdk.internal.foreign
+ * @modules jdk.incubator.foreign/jdk.internal.foreign
  * @run testng/othervm -Dforeign.restricted=permit TestNative
  */
 
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.SequenceLayout;
-import jdk.internal.misc.Unsafe;
 import org.testng.annotations.DataProvider;
 import org.testng.annotations.Test;
 
 import java.lang.invoke.VarHandle;
 import java.nio.Buffer;
@@ -56,16 +54,10 @@
 import static jdk.incubator.foreign.MemorySegment.*;
 import static org.testng.Assert.*;
 
 public class TestNative {
 
-    static Unsafe UNSAFE;
-
-    static {
-        UNSAFE = Unsafe.getUnsafe();
-    }
-
     static SequenceLayout bytes = MemoryLayout.ofSequence(100,
             MemoryLayouts.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())
     );
 
     static SequenceLayout chars = MemoryLayout.ofSequence(100,
diff a/test/jdk/java/foreign/libIntrinsics.c b/test/jdk/java/foreign/libIntrinsics.c
--- /dev/null
+++ b/test/jdk/java/foreign/libIntrinsics.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT void empty() {
+}
+
+EXPORT char identity_char(char x) {
+    return x;
+}
+
+EXPORT short identity_short(short x) {
+    return x;
+}
+
+EXPORT int identity_int(int x) {
+    return x;
+}
+
+EXPORT long long identity_long(long long x) {
+    return x;
+}
+
+EXPORT float identity_float(float x) {
+    return x;
+}
+
+EXPORT double identity_double(double x) {
+    return x;
+}
+
+EXPORT int identity_va(int x, ...) {
+    return x;
+}
+
+EXPORT void invoke_consumer(int x, double d, long long l, float f, char c, short s1, short s2) {
+}
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/CallOverhead.java
@@ -60,10 +60,12 @@
     static final MethodHandle identity;
     static final MethodHandle identity_struct;
     static final MethodHandle identity_memory_address;
     static final MethodHandle args5;
     static final MethodHandle args10;
+    static final MethodHandle func_trivial;
+    static final MethodHandle identity_trivial;
 
     static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(
         C_LONGLONG, C_LONGLONG
     );
 
@@ -72,23 +74,31 @@
     static {
         System.loadLibrary("CallOverheadJNI");
 
         try {
             LibraryLookup ll = LibraryLookup.ofLibrary("CallOverhead");
-            func = abi.downcallHandle(ll.lookup("func"),
-                    MethodType.methodType(void.class),
-                    FunctionDescriptor.ofVoid());
-            identity = abi.downcallHandle(ll.lookup("identity"),
-                    MethodType.methodType(int.class, int.class),
-                    FunctionDescriptor.of(C_INT, C_INT));
+            {
+                MemoryAddress addr = ll.lookup("func");
+                MethodType mt = MethodType.methodType(void.class);
+                FunctionDescriptor fd = FunctionDescriptor.ofVoid();
+                func = abi.downcallHandle(addr, mt, fd);
+                func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.IS_TRIVIAL, true));
+            }
+            {
+                MemoryAddress addr = ll.lookup("identity");
+                MethodType mt = MethodType.methodType(int.class, int.class);
+                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);
+                identity = abi.downcallHandle(addr, mt, fd);
+                identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.IS_TRIVIAL, true));
+            }
             identity_struct = abi.downcallHandle(ll.lookup("identity_struct"),
                     MethodType.methodType(MemorySegment.class, MemorySegment.class),
                     FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));
             identity_memory_address = abi.downcallHandle(ll.lookup("identity_memory_address"),
                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class),
                     FunctionDescriptor.of(C_POINTER, C_POINTER));
-            args5 = abi.downcallHandle(ll.lookup("args5"), // just reuse identity
+            args5 = abi.downcallHandle(ll.lookup("args5"),
                     MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),
                     FunctionDescriptor.ofVoid(C_LONGLONG, C_DOUBLE, C_LONGLONG, C_DOUBLE, C_LONGLONG));
             args10 = abi.downcallHandle(ll.lookup("args10"),
                     MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,
                                                       double.class, long.class, double.class, long.class, double.class),
@@ -116,10 +126,15 @@
     @Fork(jvmArgsAppend = "-Djdk.internal.foreign.ProgrammableInvoker.NO_SPEC=true")
     public void panama_blank_NO_SPEC() throws Throwable {
         func.invokeExact();
     }
 
+    @Benchmark
+    public void panama_blank_trivial() throws Throwable {
+        func_trivial.invokeExact();
+    }
+
     @Benchmark
     public int jni_identity() throws Throwable {
         return identity(10);
     }
 
@@ -132,10 +147,15 @@
     @Fork(jvmArgsAppend = "-Djdk.internal.foreign.ProgrammableInvoker.NO_SPEC=true")
     public int panama_identity_NO_SPEC() throws Throwable {
         return (int) identity.invokeExact(10);
     }
 
+    @Benchmark
+    public int panama_identity_trivial() throws Throwable {
+        return (int) identity_trivial.invokeExact(10);
+    }
+
     @Benchmark
     public MemorySegment panama_identity_struct() throws Throwable {
         return (MemorySegment) identity_struct.invokeExact(point);
     }
 

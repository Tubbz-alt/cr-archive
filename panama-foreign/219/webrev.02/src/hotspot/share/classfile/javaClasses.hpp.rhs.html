<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 
  37 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  38   f(java_lang_Class) \
  39   f(java_lang_String) \
  40   f(java_lang_ref_Reference) \
  41   //end
  42 
  43 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  44   f(java_lang_System) \
  45   f(java_lang_ClassLoader) \
  46   f(java_lang_Throwable) \
  47   f(java_lang_Thread) \
  48   f(java_lang_ThreadGroup) \
  49   f(java_lang_AssertionStatusDirectives) \
  50   f(java_lang_ref_SoftReference) \
  51   f(java_lang_invoke_MethodHandle) \
  52   f(java_lang_invoke_DirectMethodHandle) \
  53   f(java_lang_invoke_MemberName) \
  54   f(java_lang_invoke_ResolvedMethodName) \
  55   f(java_lang_invoke_LambdaForm) \
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
<a name="1" id="anc1"></a><span class="line-added">  75   f(jdk_internal_invoke_NativeEntryPoint) \</span>
  76   f(jdk_internal_misc_UnsafeConstants) \
  77   f(java_lang_boxing_object) \
  78   //end
  79 
  80 #define BASIC_JAVA_CLASSES_DO(f) \
  81         BASIC_JAVA_CLASSES_DO_PART1(f) \
  82         BASIC_JAVA_CLASSES_DO_PART2(f)
  83 
  84 #define CHECK_INIT(offset)  assert(offset != 0, &quot;should be initialized&quot;); return offset;
  85 
  86 // Interface to java.lang.Object objects
  87 
  88 class java_lang_Object : AllStatic {
  89  public:
  90   static void register_natives(TRAPS);
  91 };
  92 
  93 // Interface to java.lang.String objects
  94 
  95 class java_lang_String : AllStatic {
  96  private:
  97   static int _value_offset;
  98   static int _hash_offset;
  99   static int _hashIsZero_offset;
 100   static int _coder_offset;
 101 
 102   static bool _initialized;
 103 
 104   static Handle basic_create(int length, bool byte_arr, TRAPS);
 105 
 106   static inline void set_coder(oop string, jbyte coder);
 107 
 108  public:
 109 
 110   // Coders
 111   enum Coder {
 112     CODER_LATIN1 =  0,
 113     CODER_UTF16  =  1
 114   };
 115 
 116   static void compute_offsets();
 117   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 118 
 119   // Instance creation
 120   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 121   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 122   static Handle create_from_str(const char* utf8_str, TRAPS);
 123   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 124   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 125   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 126   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 127 
 128   static void set_compact_strings(bool value);
 129 
 130   static int value_offset() { CHECK_INIT(_value_offset); }
 131   static int coder_offset() { CHECK_INIT(_coder_offset); }
 132 
 133   static inline void set_value_raw(oop string, typeArrayOop buffer);
 134   static inline void set_value(oop string, typeArrayOop buffer);
 135 
 136   // Accessors
 137   static inline typeArrayOop value(oop java_string);
 138   static inline typeArrayOop value_no_keepalive(oop java_string);
 139   static inline bool hash_is_set(oop string);
 140   static inline bool is_latin1(oop java_string);
 141   static inline int length(oop java_string);
 142   static inline int length(oop java_string, typeArrayOop string_value);
 143   static int utf8_length(oop java_string);
 144   static int utf8_length(oop java_string, typeArrayOop string_value);
 145 
 146   // String converters
 147   static char*  as_utf8_string(oop java_string);
 148   static char*  as_utf8_string(oop java_string, int&amp; length);
 149   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 150   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 151   static char*  as_utf8_string(oop java_string, int start, int len);
 152   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 153   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 154   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 155   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 156   // produce an ascii string with all other values quoted using \u####
 157   static char*  as_quoted_ascii(oop java_string);
 158 
 159   // Compute the hash value for a java.lang.String object which would
 160   // contain the characters passed in.
 161   //
 162   // As the hash value used by the String object itself, in
 163   // String.hashCode().  This value is normally calculated in Java code
 164   // in the String.hashCode method(), but is precomputed for String
 165   // objects in the shared archive file.
 166   // hash P(31) from Kernighan &amp; Ritchie
 167   //
 168   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 169   static unsigned int hash_code(const jchar* s, int len) {
 170     unsigned int h = 0;
 171     while (len-- &gt; 0) {
 172       h = 31*h + (unsigned int) *s;
 173       s++;
 174     }
 175     return h;
 176   }
 177 
 178   static unsigned int hash_code(const jbyte* s, int len) {
 179     unsigned int h = 0;
 180     while (len-- &gt; 0) {
 181       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 182       s++;
 183     }
 184     return h;
 185   }
 186 
 187   static unsigned int hash_code(oop java_string);
 188 
 189   static bool equals(oop java_string, const jchar* chars, int len);
 190   static bool equals(oop str1, oop str2);
 191   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 192 
 193   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 194   static Handle externalize_classname(Handle java_string, TRAPS) {
 195     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 196   }
 197 
 198   // Conversion
 199   static Symbol* as_symbol(oop java_string);
 200   static Symbol* as_symbol_or_null(oop java_string);
 201 
 202   // Testers
 203   static bool is_instance(oop obj);
 204   static inline bool is_instance_inlined(oop obj);
 205 
 206   // Debugging
 207   static void print(oop java_string, outputStream* st);
 208   friend class JavaClasses;
 209   friend class StringTable;
 210 };
 211 
 212 
 213 // Interface to java.lang.Class objects
 214 
 215 #define CLASS_INJECTED_FIELDS(macro)                                       \
 216   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 217   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 218   macro(java_lang_Class, oop_size,               int_signature,     false) \
 219   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 220   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 221   macro(java_lang_Class, signers,                object_signature,  false) \
 222   macro(java_lang_Class, source_file,            object_signature,  false) \
 223 
 224 class java_lang_Class : AllStatic {
 225   friend class VMStructs;
 226   friend class JVMCIVMStructs;
 227 
 228  private:
 229 
 230   // The fake offsets are added by the class loader when java.lang.Class is loaded
 231 
 232   static int _klass_offset;
 233   static int _array_klass_offset;
 234 
 235   static int _oop_size_offset;
 236   static int _static_oop_field_count_offset;
 237 
 238   static int _protection_domain_offset;
 239   static int _init_lock_offset;
 240   static int _signers_offset;
 241   static int _class_loader_offset;
 242   static int _module_offset;
 243   static int _component_mirror_offset;
 244   static int _name_offset;
 245   static int _source_file_offset;
 246   static int _classData_offset;
 247   static int _classRedefinedCount_offset;
 248 
 249   static bool _offsets_computed;
 250 
 251   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 252   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 253 
 254   static void set_init_lock(oop java_class, oop init_lock);
 255   static void set_protection_domain(oop java_class, oop protection_domain);
 256   static void set_class_loader(oop java_class, oop class_loader);
 257   static void set_component_mirror(oop java_class, oop comp_mirror);
 258   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 259                                        Handle classData, TRAPS);
 260   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 261  public:
 262   static void allocate_fixup_lists();
 263   static void compute_offsets();
 264 
 265   // Instance creation
 266   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 267                             Handle protection_domain, Handle classData, TRAPS);
 268   static void fixup_mirror(Klass* k, TRAPS);
 269   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 270   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 271   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 272 
 273   // Archiving
 274   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 275   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 276   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 277   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 278                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 279   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 280                                       Handle protection_domain,
 281                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 282 
 283   static void fixup_module_field(Klass* k, Handle module);
 284 
 285   // Conversion
 286   static Klass* as_Klass(oop java_class);
 287   static Klass* as_Klass_raw(oop java_class);
 288   static void set_klass(oop java_class, Klass* klass);
 289   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 290   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 291   static void print_signature(oop java_class, outputStream *st);
 292   static const char* as_external_name(oop java_class);
 293   // Testing
 294   static bool is_instance(oop obj);
 295 
 296   static bool is_primitive(oop java_class);
 297   static BasicType primitive_type(oop java_class);
 298   static oop primitive_mirror(BasicType t);
 299   // JVM_NewArray support
 300   static Klass* array_klass_acquire(oop java_class);
 301   static void release_set_array_klass(oop java_class, Klass* klass);
 302   // compiler support for class operations
 303   static int klass_offset()                { CHECK_INIT(_klass_offset); }
 304   static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }
 305   // Support for classRedefinedCount field
 306   static int classRedefinedCount(oop the_class_mirror);
 307   static void set_classRedefinedCount(oop the_class_mirror, int value);
 308 
 309   // Support for embedded per-class oops
 310   static oop  protection_domain(oop java_class);
 311   static oop  init_lock(oop java_class);
 312   static void clear_init_lock(oop java_class) {
 313     set_init_lock(java_class, NULL);
 314   }
 315   static oop  component_mirror(oop java_class);
 316   static objArrayOop  signers(oop java_class);
 317   static void set_signers(oop java_class, objArrayOop signers);
 318   static oop  class_data(oop java_class);
 319   static void set_class_data(oop java_class, oop classData);
 320 
 321   static oop class_loader(oop java_class);
 322   static void set_module(oop java_class, oop module);
 323   static oop module(oop java_class);
 324 
 325   static oop name(Handle java_class, TRAPS);
 326 
 327   static oop source_file(oop java_class);
 328   static void set_source_file(oop java_class, oop source_file);
 329 
 330   static int oop_size(oop java_class);
 331   static int oop_size_raw(oop java_class);
 332   static void set_oop_size(HeapWord* java_class, int size);
 333   static int static_oop_field_count(oop java_class);
 334   static int static_oop_field_count_raw(oop java_class);
 335   static void set_static_oop_field_count(oop java_class, int size);
 336 
 337   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 338     return _fixup_mirror_list;
 339   }
 340   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 341     _fixup_mirror_list = v;
 342   }
 343 
 344   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 345     return _fixup_module_field_list;
 346   }
 347   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 348     _fixup_module_field_list = v;
 349   }
 350 
 351   // Debugging
 352   friend class JavaClasses;
 353 };
 354 
 355 // Interface to java.lang.Thread objects
 356 
 357 class java_lang_Thread : AllStatic {
 358  private:
 359   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 360   // so we compute the offsets at startup rather than hard-wiring them.
 361   static int _name_offset;
 362   static int _group_offset;
 363   static int _contextClassLoader_offset;
 364   static int _inheritedAccessControlContext_offset;
 365   static int _priority_offset;
 366   static int _eetop_offset;
 367   static int _interrupted_offset;
 368   static int _daemon_offset;
 369   static int _stillborn_offset;
 370   static int _stackSize_offset;
 371   static int _tid_offset;
 372   static int _thread_status_offset;
 373   static int _park_blocker_offset;
 374 
 375   static void compute_offsets();
 376 
 377  public:
 378   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 379 
 380   // Instance creation
 381   static oop create();
 382   // Returns the JavaThread associated with the thread obj
 383   static JavaThread* thread(oop java_thread);
 384   // Set JavaThread for instance
 385   static void set_thread(oop java_thread, JavaThread* thread);
 386   // Interrupted status
 387   static bool interrupted(oop java_thread);
 388   static void set_interrupted(oop java_thread, bool val);
 389   // Name
 390   static oop name(oop java_thread);
 391   static void set_name(oop java_thread, oop name);
 392   // Priority
 393   static ThreadPriority priority(oop java_thread);
 394   static void set_priority(oop java_thread, ThreadPriority priority);
 395   // Thread group
 396   static oop  threadGroup(oop java_thread);
 397   // Stillborn
 398   static bool is_stillborn(oop java_thread);
 399   static void set_stillborn(oop java_thread);
 400   // Alive (NOTE: this is not really a field, but provides the correct
 401   // definition without doing a Java call)
 402   static bool is_alive(oop java_thread);
 403   // Daemon
 404   static bool is_daemon(oop java_thread);
 405   static void set_daemon(oop java_thread);
 406   // Context ClassLoader
 407   static oop context_class_loader(oop java_thread);
 408   // Control context
 409   static oop inherited_access_control_context(oop java_thread);
 410   // Stack size hint
 411   static jlong stackSize(oop java_thread);
 412   // Thread ID
 413   static jlong thread_id(oop java_thread);
 414 
 415   // Blocker object responsible for thread parking
 416   static oop park_blocker(oop java_thread);
 417 
 418   // Java Thread Status for JVMTI and M&amp;M use.
 419   // This thread status info is saved in threadStatus field of
 420   // java.lang.Thread java class.
 421   enum ThreadStatus {
 422     NEW                      = 0,
 423     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 424                                JVMTI_THREAD_STATE_RUNNABLE,
 425     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 426                                JVMTI_THREAD_STATE_WAITING +
 427                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 428                                JVMTI_THREAD_STATE_SLEEPING,
 429     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 430                                JVMTI_THREAD_STATE_WAITING +
 431                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 432                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 433     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 434                                JVMTI_THREAD_STATE_WAITING +
 435                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 436                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 437     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 438                                JVMTI_THREAD_STATE_WAITING +
 439                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 440                                JVMTI_THREAD_STATE_PARKED,
 441     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 442                                JVMTI_THREAD_STATE_WAITING +
 443                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 444                                JVMTI_THREAD_STATE_PARKED,
 445     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 446                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 447     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 448   };
 449   // Write thread status info to threadStatus field of java.lang.Thread.
 450   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 451   // Read thread status info from threadStatus field of java.lang.Thread.
 452   static ThreadStatus get_thread_status(oop java_thread_oop);
 453 
 454   static const char*  thread_status_name(oop java_thread_oop);
 455 
 456   // Debugging
 457   friend class JavaClasses;
 458 };
 459 
 460 // Interface to java.lang.ThreadGroup objects
 461 
 462 class java_lang_ThreadGroup : AllStatic {
 463  private:
 464   static int _parent_offset;
 465   static int _name_offset;
 466   static int _threads_offset;
 467   static int _groups_offset;
 468   static int _maxPriority_offset;
 469   static int _destroyed_offset;
 470   static int _daemon_offset;
 471   static int _nthreads_offset;
 472   static int _ngroups_offset;
 473 
 474   static void compute_offsets();
 475 
 476  public:
 477   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 478 
 479   // parent ThreadGroup
 480   static oop  parent(oop java_thread_group);
 481   // name
 482   static const char* name(oop java_thread_group);
 483   // (&quot;name as oop&quot; accessor is not necessary)
 484   // Number of threads in group
 485   static int nthreads(oop java_thread_group);
 486   // threads
 487   static objArrayOop threads(oop java_thread_group);
 488   // Number of threads in group
 489   static int ngroups(oop java_thread_group);
 490   // groups
 491   static objArrayOop groups(oop java_thread_group);
 492   // maxPriority in group
 493   static ThreadPriority maxPriority(oop java_thread_group);
 494   // Destroyed
 495   static bool is_destroyed(oop java_thread_group);
 496   // Daemon
 497   static bool is_daemon(oop java_thread_group);
 498   // Debugging
 499   friend class JavaClasses;
 500 };
 501 
 502 
 503 
 504 // Interface to java.lang.Throwable objects
 505 
 506 class java_lang_Throwable: AllStatic {
 507   friend class BacktraceBuilder;
 508   friend class BacktraceIterator;
 509 
 510  private:
 511   // Trace constants
 512   enum {
 513     trace_methods_offset = 0,
 514     trace_bcis_offset    = 1,
 515     trace_mirrors_offset = 2,
 516     trace_names_offset   = 3,
 517     trace_next_offset    = 4,
 518     trace_hidden_offset  = 5,
 519     trace_size           = 6,
 520     trace_chunk_size     = 32
 521   };
 522 
 523   static int _backtrace_offset;
 524   static int _detailMessage_offset;
 525   static int _stackTrace_offset;
 526   static int _depth_offset;
 527   static int _static_unassigned_stacktrace_offset;
 528 
 529   // StackTrace (programmatic access, new since 1.4)
 530   static void clear_stacktrace(oop throwable);
 531   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 532   static void set_stacktrace(oop throwable, oop st_element_array);
 533   static oop unassigned_stacktrace();
 534 
 535  public:
 536   // Backtrace
 537   static oop backtrace(oop throwable);
 538   static void set_backtrace(oop throwable, oop value);
 539   static int depth(oop throwable);
 540   static void set_depth(oop throwable, int value);
 541   static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }
 542   // Message
 543   static oop message(oop throwable);
 544   static void set_message(oop throwable, oop value);
 545   static Symbol* detail_message(oop throwable);
 546   static void print_stack_element(outputStream *st, Method* method, int bci);
 547   static void print_stack_usage(Handle stream);
 548 
 549   static void compute_offsets();
 550   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 551 
 552   // Allocate space for backtrace (created but stack trace not filled in)
 553   static void allocate_backtrace(Handle throwable, TRAPS);
 554   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 555   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 556   // Fill in current stack trace, can cause GC
 557   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 558   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 559   // Programmatic access to stack trace
 560   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 561   // Printing
 562   static void print(oop throwable, outputStream* st);
 563   static void print_stack_trace(Handle throwable, outputStream* st);
 564   static void java_printStackTrace(Handle throwable, TRAPS);
 565   // Debugging
 566   friend class JavaClasses;
 567   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 568   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 569 };
 570 
 571 
 572 // Interface to java.lang.reflect.AccessibleObject objects
 573 
 574 class java_lang_reflect_AccessibleObject: AllStatic {
 575  private:
 576   // Note that to reduce dependencies on the JDK we compute these
 577   // offsets at run-time.
 578   static int _override_offset;
 579 
 580   static void compute_offsets();
 581 
 582  public:
 583   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 584 
 585   // Accessors
 586   static jboolean override(oop reflect);
 587   static void set_override(oop reflect, jboolean value);
 588 
 589   // Debugging
 590   friend class JavaClasses;
 591 };
 592 
 593 
 594 // Interface to java.lang.reflect.Method objects
 595 
 596 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 597  private:
 598   // Note that to reduce dependencies on the JDK we compute these
 599   // offsets at run-time.
 600   static int _clazz_offset;
 601   static int _name_offset;
 602   static int _returnType_offset;
 603   static int _parameterTypes_offset;
 604   static int _exceptionTypes_offset;
 605   static int _slot_offset;
 606   static int _modifiers_offset;
 607   static int _signature_offset;
 608   static int _annotations_offset;
 609   static int _parameter_annotations_offset;
 610   static int _annotation_default_offset;
 611 
 612   static void compute_offsets();
 613  public:
 614   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 615 
 616   // Allocation
 617   static Handle create(TRAPS);
 618 
 619   // Accessors
 620   static oop clazz(oop reflect);
 621   static void set_clazz(oop reflect, oop value);
 622 
 623   static void set_name(oop method, oop value);
 624 
 625   static oop return_type(oop method);
 626   static void set_return_type(oop method, oop value);
 627 
 628   static oop parameter_types(oop method);
 629   static void set_parameter_types(oop method, oop value);
 630 
 631   static int slot(oop reflect);
 632   static void set_slot(oop reflect, int value);
 633 
 634   static void set_exception_types(oop method, oop value);
 635   static void set_modifiers(oop method, int value);
 636   static void set_signature(oop method, oop value);
 637   static void set_annotations(oop method, oop value);
 638   static void set_parameter_annotations(oop method, oop value);
 639   static void set_annotation_default(oop method, oop value);
 640 
 641   // Debugging
 642   friend class JavaClasses;
 643 };
 644 
 645 
 646 // Interface to java.lang.reflect.Constructor objects
 647 
 648 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 649  private:
 650   // Note that to reduce dependencies on the JDK we compute these
 651   // offsets at run-time.
 652   static int _clazz_offset;
 653   static int _parameterTypes_offset;
 654   static int _exceptionTypes_offset;
 655   static int _slot_offset;
 656   static int _modifiers_offset;
 657   static int _signature_offset;
 658   static int _annotations_offset;
 659   static int _parameter_annotations_offset;
 660 
 661   static void compute_offsets();
 662  public:
 663   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 664 
 665   // Allocation
 666   static Handle create(TRAPS);
 667 
 668   // Accessors
 669   static oop clazz(oop reflect);
 670   static void set_clazz(oop reflect, oop value);
 671 
 672   static oop parameter_types(oop constructor);
 673   static void set_parameter_types(oop constructor, oop value);
 674 
 675   static int slot(oop reflect);
 676   static void set_slot(oop reflect, int value);
 677 
 678   static void set_exception_types(oop constructor, oop value);
 679   static void set_modifiers(oop constructor, int value);
 680   static void set_signature(oop constructor, oop value);
 681   static void set_annotations(oop constructor, oop value);
 682   static void set_parameter_annotations(oop method, oop value);
 683 
 684   // Debugging
 685   friend class JavaClasses;
 686 };
 687 
 688 
 689 // Interface to java.lang.reflect.Field objects
 690 
 691 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 692  private:
 693   // Note that to reduce dependencies on the JDK we compute these
 694   // offsets at run-time.
 695   static int _clazz_offset;
 696   static int _name_offset;
 697   static int _type_offset;
 698   static int _slot_offset;
 699   static int _modifiers_offset;
 700   static int _trusted_final_offset;
 701   static int _signature_offset;
 702   static int _annotations_offset;
 703 
 704   static void compute_offsets();
 705 
 706  public:
 707   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 708 
 709   // Allocation
 710   static Handle create(TRAPS);
 711 
 712   // Accessors
 713   static oop clazz(oop reflect);
 714   static void set_clazz(oop reflect, oop value);
 715 
 716   static oop name(oop field);
 717   static void set_name(oop field, oop value);
 718 
 719   static oop type(oop field);
 720   static void set_type(oop field, oop value);
 721 
 722   static int slot(oop reflect);
 723   static void set_slot(oop reflect, int value);
 724 
 725   static int modifiers(oop field);
 726   static void set_modifiers(oop field, int value);
 727 
 728   static void set_trusted_final(oop field);
 729 
 730   static void set_signature(oop constructor, oop value);
 731   static void set_annotations(oop constructor, oop value);
 732   static void set_parameter_annotations(oop method, oop value);
 733   static void set_annotation_default(oop method, oop value);
 734 
 735   // Debugging
 736   friend class JavaClasses;
 737 };
 738 
 739 class java_lang_reflect_Parameter {
 740  private:
 741   // Note that to reduce dependencies on the JDK we compute these
 742   // offsets at run-time.
 743   static int _name_offset;
 744   static int _modifiers_offset;
 745   static int _index_offset;
 746   static int _executable_offset;
 747 
 748   static void compute_offsets();
 749 
 750  public:
 751   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 752 
 753   // Allocation
 754   static Handle create(TRAPS);
 755 
 756   // Accessors
 757   static oop name(oop field);
 758   static void set_name(oop field, oop value);
 759 
 760   static int index(oop reflect);
 761   static void set_index(oop reflect, int value);
 762 
 763   static int modifiers(oop reflect);
 764   static void set_modifiers(oop reflect, int value);
 765 
 766   static oop executable(oop constructor);
 767   static void set_executable(oop constructor, oop value);
 768 
 769   friend class JavaClasses;
 770 };
 771 
 772 #define MODULE_INJECTED_FIELDS(macro)                            \
 773   macro(java_lang_Module, module_entry, intptr_signature, false)
 774 
 775 class java_lang_Module {
 776   private:
 777     static int _loader_offset;
 778     static int _name_offset;
 779     static int _module_entry_offset;
 780 
 781     static void compute_offsets();
 782 
 783   public:
 784     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 785 
 786     // Allocation
 787     static Handle create(Handle loader, Handle module_name, TRAPS);
 788 
 789     // Testers
 790     static bool is_instance(oop obj);
 791 
 792     // Accessors
 793     static oop loader(oop module);
 794     static void set_loader(oop module, oop value);
 795 
 796     static oop name(oop module);
 797     static void set_name(oop module, oop value);
 798 
 799     static ModuleEntry* module_entry(oop module);
 800     static void set_module_entry(oop module, ModuleEntry* module_entry);
 801 
 802   friend class JavaClasses;
 803 };
 804 
 805 // Interface to jdk.internal.reflect.ConstantPool objects
 806 class reflect_ConstantPool {
 807  private:
 808   // Note that to reduce dependencies on the JDK we compute these
 809   // offsets at run-time.
 810   static int _oop_offset;
 811 
 812   static void compute_offsets();
 813 
 814  public:
 815   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 816 
 817   // Allocation
 818   static Handle create(TRAPS);
 819 
 820   // Accessors
 821   static void set_cp(oop reflect, ConstantPool* value);
 822   static int oop_offset() { CHECK_INIT(_oop_offset); }
 823 
 824   static ConstantPool* get_cp(oop reflect);
 825 
 826   // Debugging
 827   friend class JavaClasses;
 828 };
 829 
 830 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 831 class reflect_UnsafeStaticFieldAccessorImpl {
 832  private:
 833   static int _base_offset;
 834   static void compute_offsets();
 835 
 836  public:
 837   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 838 
 839   static int base_offset() { CHECK_INIT(_base_offset); }
 840 
 841   // Debugging
 842   friend class JavaClasses;
 843 };
 844 
 845 // Interface to java.lang primitive type boxing objects:
 846 //  - java.lang.Boolean
 847 //  - java.lang.Character
 848 //  - java.lang.Float
 849 //  - java.lang.Double
 850 //  - java.lang.Byte
 851 //  - java.lang.Short
 852 //  - java.lang.Integer
 853 //  - java.lang.Long
 854 
 855 // This could be separated out into 8 individual classes.
 856 
 857 class java_lang_boxing_object: AllStatic {
 858  private:
 859   static int _value_offset;
 860   static int _long_value_offset;
 861 
 862   static void compute_offsets();
 863   static oop initialize_and_allocate(BasicType type, TRAPS);
 864  public:
 865   // Allocation. Returns a boxed value, or NULL for invalid type.
 866   static oop create(BasicType type, jvalue* value, TRAPS);
 867   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 868   static BasicType get_value(oop box, jvalue* value);
 869   static BasicType set_value(oop box, jvalue* value);
 870   static BasicType basic_type(oop box);
 871   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 872   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 873   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 874   static void print(BasicType type, jvalue* value, outputStream* st);
 875 
 876   static int value_offset(BasicType type) {
 877     return is_double_word_type(type) ? _long_value_offset : _value_offset;
 878   }
 879 
 880   static void serialize_offsets(SerializeClosure* f);
 881 
 882   // Debugging
 883   friend class JavaClasses;
 884 };
 885 
 886 
 887 
 888 // Interface to java.lang.ref.Reference objects
 889 
 890 class java_lang_ref_Reference: AllStatic {
 891   static int _referent_offset;
 892   static int _queue_offset;
 893   static int _next_offset;
 894   static int _discovered_offset;
 895 
 896   static bool _offsets_initialized;
 897 
 898  public:
 899   // Accessors
 900   static inline oop referent(oop ref);
 901   static inline void set_referent(oop ref, oop value);
 902   static inline void set_referent_raw(oop ref, oop value);
 903   static inline HeapWord* referent_addr_raw(oop ref);
 904   static inline oop next(oop ref);
 905   static inline void set_next(oop ref, oop value);
 906   static inline void set_next_raw(oop ref, oop value);
 907   static inline HeapWord* next_addr_raw(oop ref);
 908   static inline oop discovered(oop ref);
 909   static inline void set_discovered(oop ref, oop value);
 910   static inline void set_discovered_raw(oop ref, oop value);
 911   static inline HeapWord* discovered_addr_raw(oop ref);
 912   static inline oop queue(oop ref);
 913   static inline void set_queue(oop ref, oop value);
 914   static bool is_referent_field(oop obj, ptrdiff_t offset);
 915   static inline bool is_final(oop ref);
 916   static inline bool is_phantom(oop ref);
 917 
 918   static int referent_offset()    { CHECK_INIT(_referent_offset); }
 919   static int queue_offset()       { CHECK_INIT(_queue_offset); }
 920   static int next_offset()        { CHECK_INIT(_next_offset); }
 921   static int discovered_offset()  { CHECK_INIT(_discovered_offset); }
 922 
 923   static void compute_offsets();
 924   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 925 };
 926 
 927 
 928 // Interface to java.lang.ref.SoftReference objects
 929 
 930 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 931   static int _timestamp_offset;
 932   static int _static_clock_offset;
 933 
 934  public:
 935   // Accessors
 936   static jlong timestamp(oop ref);
 937 
 938   // Accessors for statics
 939   static jlong clock();
 940   static void set_clock(jlong value);
 941 
 942   static void compute_offsets();
 943   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 944 };
 945 
 946 // Interface to java.lang.invoke.MethodHandle objects
 947 
 948 class MethodHandleEntry;
 949 
 950 class java_lang_invoke_MethodHandle: AllStatic {
 951   friend class JavaClasses;
 952 
 953  private:
 954   static int _type_offset;               // the MethodType of this MH
 955   static int _form_offset;               // the LambdaForm of this MH
 956 
 957   static void compute_offsets();
 958 
 959  public:
 960   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 961 
 962   // Accessors
 963   static oop            type(oop mh);
 964   static void       set_type(oop mh, oop mtype);
 965 
 966   static oop            form(oop mh);
 967   static void       set_form(oop mh, oop lform);
 968 
 969   // Testers
 970   static bool is_subclass(Klass* klass) {
 971     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 972   }
 973   static bool is_instance(oop obj);
 974 
 975   // Accessors for code generation:
 976   static int type_offset()             { CHECK_INIT(_type_offset); }
 977   static int form_offset()             { CHECK_INIT(_form_offset); }
 978 };
 979 
 980 // Interface to java.lang.invoke.DirectMethodHandle objects
 981 
 982 class java_lang_invoke_DirectMethodHandle: AllStatic {
 983   friend class JavaClasses;
 984 
 985  private:
 986   static int _member_offset;               // the MemberName of this DMH
 987 
 988   static void compute_offsets();
 989 
 990  public:
 991   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 992 
 993   // Accessors
 994   static oop  member(oop mh);
 995 
 996   // Testers
 997   static bool is_subclass(Klass* klass) {
 998     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
 999   }
1000   static bool is_instance(oop obj);
1001 
1002   // Accessors for code generation:
1003   static int member_offset()           { CHECK_INIT(_member_offset); }
1004 };
1005 
1006 // Interface to java.lang.invoke.LambdaForm objects
1007 // (These are a private interface for managing adapter code generation.)
1008 
1009 class java_lang_invoke_LambdaForm: AllStatic {
1010   friend class JavaClasses;
1011 
1012  private:
1013   static int _vmentry_offset;  // type is MemberName
1014 
1015   static void compute_offsets();
1016 
1017  public:
1018   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1019 
1020   // Accessors
1021   static oop            vmentry(oop lform);
1022   static void       set_vmentry(oop lform, oop invoker);
1023 
1024   // Testers
1025   static bool is_subclass(Klass* klass) {
1026     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1027       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1028   }
1029   static bool is_instance(oop obj);
1030 
1031   // Accessors for code generation:
1032   static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }
1033 };
1034 
<a name="2" id="anc2"></a><span class="line-added">1035 // Interface to java.lang.invoke.NativeEntryPoint objects</span>
<span class="line-added">1036 // (These are a private interface for managing adapter code generation.)</span>
<span class="line-added">1037 </span>
<span class="line-added">1038 class jdk_internal_invoke_NativeEntryPoint: AllStatic {</span>
<span class="line-added">1039   friend class JavaClasses;</span>
<span class="line-added">1040 </span>
<span class="line-added">1041  private:</span>
<span class="line-added">1042   static int _addr_offset;  // type is jlong</span>
<span class="line-added">1043   static int _shadow_space_offset;</span>
<span class="line-added">1044   static int _argMoves_offset;</span>
<span class="line-added">1045   static int _returnMoves_offset;</span>
<span class="line-added">1046   static int _need_transition_offset;</span>
<span class="line-added">1047   static int _method_type_offset;</span>
<span class="line-added">1048   static int _name_offset;</span>
<span class="line-added">1049 </span>
<span class="line-added">1050   static void compute_offsets();</span>
<span class="line-added">1051 </span>
<span class="line-added">1052  public:</span>
<span class="line-added">1053   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;</span>
<span class="line-added">1054 </span>
<span class="line-added">1055   // Accessors</span>
<span class="line-added">1056   static address    addr(oop entry);</span>
<span class="line-added">1057   static jint       shadow_space(oop entry);</span>
<span class="line-added">1058   static oop        argMoves(oop entry);</span>
<span class="line-added">1059   static oop        returnMoves(oop entry);</span>
<span class="line-added">1060   static jboolean   need_transition(oop entry);</span>
<span class="line-added">1061   static oop        method_type(oop entry);</span>
<span class="line-added">1062   static oop        name(oop entry);</span>
<span class="line-added">1063 </span>
<span class="line-added">1064   // Testers</span>
<span class="line-added">1065   static bool is_subclass(Klass* klass) {</span>
<span class="line-added">1066     return SystemDictionary::NativeEntryPoint_klass() != NULL &amp;&amp;</span>
<span class="line-added">1067       klass-&gt;is_subclass_of(SystemDictionary::NativeEntryPoint_klass());</span>
<span class="line-added">1068   }</span>
<span class="line-added">1069   static bool is_instance(oop obj);</span>
<span class="line-added">1070 </span>
<span class="line-added">1071   // Accessors for code generation:</span>
<span class="line-added">1072   static int addr_offset_in_bytes()            { return _addr_offset;            }</span>
<span class="line-added">1073   static int shadow_space_offset_in_bytes()    { return _shadow_space_offset;    }</span>
<span class="line-added">1074   static int argMoves_offset_in_bytes()        { return _argMoves_offset;        }</span>
<span class="line-added">1075   static int returnMoves_offset_in_bytes()     { return _returnMoves_offset;     }</span>
<span class="line-added">1076   static int need_transition_offset_in_bytes() { return _need_transition_offset; }</span>
<span class="line-added">1077   static int method_type_offset_in_bytes()     { return _method_type_offset;     }</span>
<span class="line-added">1078   static int name_offset_in_bytes()            { return _name_offset;            }</span>
<span class="line-added">1079 };</span>
1080 
1081 // Interface to java.lang.invoke.MemberName objects
1082 // (These are a private interface for Java code to query the class hierarchy.)
1083 
1084 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1085   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1086   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1087 
1088 class java_lang_invoke_ResolvedMethodName : AllStatic {
1089   friend class JavaClasses;
1090 
1091   static int _vmtarget_offset;
1092   static int _vmholder_offset;
1093 
1094   static void compute_offsets();
1095  public:
1096   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1097 
1098   static int vmtarget_offset() { CHECK_INIT(_vmtarget_offset); }
1099 
1100   static Method* vmtarget(oop resolved_method);
1101   static void set_vmtarget(oop resolved_method, Method* method);
1102 
1103   static void set_vmholder(oop resolved_method, oop holder);
1104 
1105   // find or create resolved member name
1106   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1107 
1108   static bool is_instance(oop resolved_method);
1109 };
1110 
1111 
1112 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1113   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1114 
1115 
1116 class java_lang_invoke_MemberName: AllStatic {
1117   friend class JavaClasses;
1118 
1119  private:
1120   // From java.lang.invoke.MemberName:
1121   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1122   //    private String     name;        // may be null if not yet materialized
1123   //    private Object     type;        // may be null if not yet materialized
1124   //    private int        flags;       // modifier bits; see reflect.Modifier
1125   //    private ResolvedMethodName method;    // holds VM-specific target value
1126   //    private intptr_t   vmindex;     // member index within class or interface
1127   static int _clazz_offset;
1128   static int _name_offset;
1129   static int _type_offset;
1130   static int _flags_offset;
1131   static int _method_offset;
1132   static int _vmindex_offset;
1133 
1134   static void compute_offsets();
1135 
1136  public:
1137   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1138   // Accessors
1139   static oop            clazz(oop mname);
1140   static void       set_clazz(oop mname, oop clazz);
1141 
1142   static oop            type(oop mname);
1143   static void       set_type(oop mname, oop type);
1144 
1145   static oop            name(oop mname);
1146   static void       set_name(oop mname, oop name);
1147 
1148   static int            flags(oop mname);
1149   static void       set_flags(oop mname, int flags);
1150 
1151   // Link through ResolvedMethodName field to get Method*
1152   static Method*        vmtarget(oop mname);
1153   static void       set_method(oop mname, oop method);
1154 
1155   static intptr_t       vmindex(oop mname);
1156   static void       set_vmindex(oop mname, intptr_t index);
1157 
1158   // Testers
1159   static bool is_subclass(Klass* klass) {
1160     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1161   }
1162   static bool is_instance(oop obj);
1163 
1164   static bool is_method(oop obj);
1165 
1166   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1167   enum {
1168     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1169     MN_IS_CONSTRUCTOR        = 0x00020000, // constructor
1170     MN_IS_FIELD              = 0x00040000, // field
1171     MN_IS_TYPE               = 0x00080000, // nested type
1172     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1173     MN_TRUSTED_FINAL         = 0x00200000, // trusted final field
1174     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1175     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1176     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1177     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1178     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1179     MN_NESTMATE_CLASS        = 0x00000001,
1180     MN_HIDDEN_CLASS          = 0x00000002,
1181     MN_STRONG_LOADER_LINK    = 0x00000004,
1182     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1183   };
1184 
1185   // Accessors for code generation:
1186   static int clazz_offset()   { CHECK_INIT(_clazz_offset); }
1187   static int type_offset()    { CHECK_INIT(_type_offset); }
1188   static int flags_offset()   { CHECK_INIT(_flags_offset); }
1189   static int method_offset()  { CHECK_INIT(_method_offset); }
1190   static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }
1191 };
1192 
1193 
1194 // Interface to java.lang.invoke.MethodType objects
1195 
1196 class java_lang_invoke_MethodType: AllStatic {
1197   friend class JavaClasses;
1198 
1199  private:
1200   static int _rtype_offset;
1201   static int _ptypes_offset;
1202 
1203   static void compute_offsets();
1204 
1205  public:
1206   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1207   // Accessors
1208   static oop            rtype(oop mt);
1209   static objArrayOop    ptypes(oop mt);
1210 
1211   static oop            ptype(oop mt, int index);
1212   static int            ptype_count(oop mt);
1213 
1214   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1215   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1216 
1217   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1218   static void           print_signature(oop mt, outputStream* st);
1219 
1220   static bool is_instance(oop obj);
1221 
1222   static bool equals(oop mt1, oop mt2);
1223 
1224   // Accessors for code generation:
1225   static int rtype_offset()  { CHECK_INIT(_rtype_offset); }
1226   static int ptypes_offset() { CHECK_INIT(_ptypes_offset); }
1227 };
1228 
1229 
1230 // Interface to java.lang.invoke.CallSite objects
1231 
1232 class java_lang_invoke_CallSite: AllStatic {
1233   friend class JavaClasses;
1234 
1235 private:
1236   static int _target_offset;
1237   static int _context_offset;
1238 
1239   static void compute_offsets();
1240 
1241 public:
1242   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1243   // Accessors
1244   static oop              target(          oop site);
1245   static void         set_target(          oop site, oop target);
1246   static void         set_target_volatile( oop site, oop target);
1247 
1248   static oop context_no_keepalive(oop site);
1249 
1250   // Testers
1251   static bool is_subclass(Klass* klass) {
1252     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1253   }
1254   static bool is_instance(oop obj);
1255 
1256   // Accessors for code generation:
1257   static int target_offset()  { CHECK_INIT(_target_offset); }
1258   static int context_offset() { CHECK_INIT(_context_offset); }
1259 };
1260 
1261 // Interface to java.lang.invoke.ConstantCallSite objects
1262 
1263 class java_lang_invoke_ConstantCallSite: AllStatic {
1264   friend class JavaClasses;
1265 
1266 private:
1267   static int _is_frozen_offset;
1268 
1269   static void compute_offsets();
1270 
1271 public:
1272   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1273   // Accessors
1274   static jboolean is_frozen(oop site);
1275 
1276   // Testers
1277   static bool is_subclass(Klass* klass) {
1278     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1279   }
1280   static bool is_instance(oop obj);
1281 };
1282 
1283 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1284 
1285 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1286   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1287   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1288 
1289 class DependencyContext;
1290 
1291 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1292   friend class JavaClasses;
1293 
1294 private:
1295   static int _vmdependencies_offset;
1296   static int _last_cleanup_offset;
1297 
1298   static void compute_offsets();
1299 
1300 public:
1301   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1302   // Accessors
1303   static DependencyContext vmdependencies(oop context);
1304 
1305   // Testers
1306   static bool is_subclass(Klass* klass) {
1307     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1308   }
1309   static bool is_instance(oop obj);
1310 };
1311 
1312 // Interface to java.security.AccessControlContext objects
1313 
1314 class java_security_AccessControlContext: AllStatic {
1315  private:
1316   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1317   // so we compute the offsets at startup rather than hard-wiring them.
1318   static int _context_offset;
1319   static int _privilegedContext_offset;
1320   static int _isPrivileged_offset;
1321   static int _isAuthorized_offset;
1322 
1323   static void compute_offsets();
1324  public:
1325   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1326   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1327 
1328   // Debugging/initialization
1329   friend class JavaClasses;
1330 };
1331 
1332 
1333 // Interface to java.lang.ClassLoader objects
1334 
1335 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1336   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1337 
1338 class java_lang_ClassLoader : AllStatic {
1339  private:
1340   static int _loader_data_offset;
1341   static int _parent_offset;
1342   static int _parallelCapable_offset;
1343   static int _name_offset;
1344   static int _nameAndId_offset;
1345   static int _unnamedModule_offset;
1346 
1347   static void compute_offsets();
1348 
1349  public:
1350   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1351 
1352   static ClassLoaderData* loader_data_acquire(oop loader);
1353   static ClassLoaderData* loader_data_raw(oop loader);
1354   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1355 
1356   static oop parent(oop loader);
1357   static oop name(oop loader);
1358   static oop nameAndId(oop loader);
1359   static bool isAncestor(oop loader, oop cl);
1360 
1361   // Support for parallelCapable field
1362   static bool parallelCapable(oop the_class_mirror);
1363 
1364   static bool is_trusted_loader(oop loader);
1365 
1366   // Return true if this is one of the class loaders associated with
1367   // the generated bytecodes for reflection.
1368   static bool is_reflection_class_loader(oop loader);
1369 
1370   // Fix for 4474172
1371   static oop  non_reflection_class_loader(oop loader);
1372 
1373   // Testers
1374   static bool is_subclass(Klass* klass) {
1375     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1376   }
1377   static bool is_instance(oop obj);
1378 
1379   static oop unnamedModule(oop loader);
1380 
1381   // Debugging
1382   friend class JavaClasses;
1383 };
1384 
1385 
1386 // Interface to java.lang.System objects
1387 
1388 class java_lang_System : AllStatic {
1389  private:
1390   static int _static_in_offset;
1391   static int _static_out_offset;
1392   static int _static_err_offset;
1393   static int _static_security_offset;
1394 
1395  public:
1396   static int  in_offset() { CHECK_INIT(_static_in_offset); }
1397   static int out_offset() { CHECK_INIT(_static_out_offset); }
1398   static int err_offset() { CHECK_INIT(_static_err_offset); }
1399 
1400   static void compute_offsets();
1401   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1402 
1403   // Debugging
1404   friend class JavaClasses;
1405 };
1406 
1407 
1408 // Interface to java.lang.StackTraceElement objects
1409 
1410 class java_lang_StackTraceElement: AllStatic {
1411  private:
1412   static int _declaringClassObject_offset;
1413   static int _classLoaderName_offset;
1414   static int _moduleName_offset;
1415   static int _moduleVersion_offset;
1416   static int _declaringClass_offset;
1417   static int _methodName_offset;
1418   static int _fileName_offset;
1419   static int _lineNumber_offset;
1420 
1421   // Setters
1422   static void set_classLoaderName(oop element, oop value);
1423   static void set_moduleName(oop element, oop value);
1424   static void set_moduleVersion(oop element, oop value);
1425   static void set_declaringClass(oop element, oop value);
1426   static void set_methodName(oop element, oop value);
1427   static void set_fileName(oop element, oop value);
1428   static void set_lineNumber(oop element, int value);
1429   static void set_declaringClassObject(oop element, oop value);
1430 
1431   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1432                                    const methodHandle&amp; method, int bci,
1433                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1434 
1435  public:
1436   // Create an instance of StackTraceElement
1437   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1438 
1439   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1440                       int version, int bci, Symbol* name, TRAPS);
1441 
1442   static void compute_offsets();
1443   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1444 
1445 #if INCLUDE_JVMCI
1446   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1447 #endif
1448 
1449   // Debugging
1450   friend class JavaClasses;
1451 };
1452 
1453 
1454 class Backtrace: AllStatic {
1455  public:
1456   // Helper backtrace functions to store bci|version together.
1457   static int merge_bci_and_version(int bci, int version);
1458   static int merge_mid_and_cpref(int mid, int cpref);
1459   static int bci_at(unsigned int merged);
1460   static int version_at(unsigned int merged);
1461   static int mid_at(unsigned int merged);
1462   static int cpref_at(unsigned int merged);
1463   static int get_line_number(Method* method, int bci);
1464   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1465 
1466   // Debugging
1467   friend class JavaClasses;
1468 };
1469 
1470 // Interface to java.lang.StackFrameInfo objects
1471 
1472 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1473   macro(java_lang_StackFrameInfo, version, short_signature, false)
1474 
1475 class java_lang_StackFrameInfo: AllStatic {
1476 private:
1477   static int _memberName_offset;
1478   static int _bci_offset;
1479   static int _version_offset;
1480 
1481   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1482 
1483 public:
1484   // Setters
1485   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1486   static void set_bci(oop info, int value);
1487 
1488   static void set_version(oop info, short value);
1489 
1490   static void compute_offsets();
1491   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1492 
1493   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1494 
1495   // Debugging
1496   friend class JavaClasses;
1497 };
1498 
1499 class java_lang_LiveStackFrameInfo: AllStatic {
1500  private:
1501   static int _monitors_offset;
1502   static int _locals_offset;
1503   static int _operands_offset;
1504   static int _mode_offset;
1505 
1506  public:
1507   static void set_monitors(oop info, oop value);
1508   static void set_locals(oop info, oop value);
1509   static void set_operands(oop info, oop value);
1510   static void set_mode(oop info, int value);
1511 
1512   static void compute_offsets();
1513   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1514 
1515   // Debugging
1516   friend class JavaClasses;
1517 };
1518 
1519 // Interface to java.lang.reflect.RecordComponent objects
1520 
1521 class java_lang_reflect_RecordComponent: AllStatic {
1522  private:
1523   static int _clazz_offset;
1524   static int _name_offset;
1525   static int _type_offset;
1526   static int _accessor_offset;
1527   static int _signature_offset;
1528   static int _annotations_offset;
1529   static int _typeAnnotations_offset;
1530 
1531   // Setters
1532   static void set_clazz(oop element, oop value);
1533   static void set_name(oop element, oop value);
1534   static void set_type(oop element, oop value);
1535   static void set_accessor(oop element, oop value);
1536   static void set_signature(oop element, oop value);
1537   static void set_annotations(oop element, oop value);
1538   static void set_typeAnnotations(oop element, oop value);
1539 
1540  public:
1541   // Create an instance of RecordComponent
1542   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1543 
1544   static void compute_offsets();
1545   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1546 
1547   // Debugging
1548   friend class JavaClasses;
1549 };
1550 
1551 
1552 // Interface to java.lang.AssertionStatusDirectives objects
1553 
1554 class java_lang_AssertionStatusDirectives: AllStatic {
1555  private:
1556   static int _classes_offset;
1557   static int _classEnabled_offset;
1558   static int _packages_offset;
1559   static int _packageEnabled_offset;
1560   static int _deflt_offset;
1561 
1562  public:
1563   // Setters
1564   static void set_classes(oop obj, oop val);
1565   static void set_classEnabled(oop obj, oop val);
1566   static void set_packages(oop obj, oop val);
1567   static void set_packageEnabled(oop obj, oop val);
1568   static void set_deflt(oop obj, bool val);
1569 
1570   static void compute_offsets();
1571   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1572 
1573   // Debugging
1574   friend class JavaClasses;
1575 };
1576 
1577 
1578 class java_nio_Buffer: AllStatic {
1579  private:
1580   static int _limit_offset;
1581 
1582  public:
1583   static int  limit_offset() { CHECK_INIT(_limit_offset); }
1584   static void compute_offsets();
1585   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1586 };
1587 
1588 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1589  private:
1590   static int  _owner_offset;
1591  public:
1592   static void compute_offsets();
1593   static oop  get_owner_threadObj(oop obj);
1594   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1595 };
1596 
1597  // Interface to jdk.internal.misc.UnsafeConsants
1598 
1599 class jdk_internal_misc_UnsafeConstants : AllStatic {
1600  public:
1601   static void set_unsafe_constants();
1602   static void compute_offsets() { }
1603   static void serialize_offsets(SerializeClosure* f) { }
1604 };
1605 
1606 class java_lang_Integer : AllStatic {
1607 public:
1608   static jint value(oop obj);
1609 };
1610 
1611 class java_lang_Long : AllStatic {
1612 public:
1613   static jlong value(oop obj);
1614 };
1615 
1616 class java_lang_Character : AllStatic {
1617 public:
1618   static jchar value(oop obj);
1619 };
1620 
1621 class java_lang_Short : AllStatic {
1622 public:
1623   static jshort value(oop obj);
1624 };
1625 
1626 class java_lang_Byte : AllStatic {
1627 public:
1628   static jbyte value(oop obj);
1629 };
1630 
1631 class java_lang_Boolean : AllStatic {
1632  private:
1633   static int _static_TRUE_offset;
1634   static int _static_FALSE_offset;
1635  public:
1636   static Symbol* symbol();
1637   static void compute_offsets(InstanceKlass* k);
1638   static oop  get_TRUE(InstanceKlass *k);
1639   static oop  get_FALSE(InstanceKlass *k);
1640   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1641   static jboolean value(oop obj);
1642 };
1643 
1644 class java_lang_Integer_IntegerCache : AllStatic {
1645  private:
1646   static int _static_cache_offset;
1647  public:
1648   static Symbol* symbol();
1649   static void compute_offsets(InstanceKlass* k);
1650   static objArrayOop  cache(InstanceKlass *k);
1651   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1652 };
1653 
1654 class java_lang_Long_LongCache : AllStatic {
1655  private:
1656   static int _static_cache_offset;
1657  public:
1658   static Symbol* symbol();
1659   static void compute_offsets(InstanceKlass* k);
1660   static objArrayOop  cache(InstanceKlass *k);
1661   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1662 };
1663 
1664 class java_lang_Character_CharacterCache : AllStatic {
1665  private:
1666   static int _static_cache_offset;
1667  public:
1668   static Symbol* symbol();
1669   static void compute_offsets(InstanceKlass* k);
1670   static objArrayOop  cache(InstanceKlass *k);
1671   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1672 };
1673 
1674 class java_lang_Short_ShortCache : AllStatic {
1675  private:
1676   static int _static_cache_offset;
1677  public:
1678   static Symbol* symbol();
1679   static void compute_offsets(InstanceKlass* k);
1680   static objArrayOop  cache(InstanceKlass *k);
1681   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1682 };
1683 
1684 class java_lang_Byte_ByteCache : AllStatic {
1685  private:
1686   static int _static_cache_offset;
1687  public:
1688   static Symbol* symbol();
1689   static void compute_offsets(InstanceKlass* k);
1690   static objArrayOop  cache(InstanceKlass *k);
1691   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1692 };
1693 
1694 // Use to declare fields that need to be injected into Java classes
1695 // for the JVM to use.  The name_index and signature_index are
1696 // declared in vmSymbols.  The may_be_java flag is used to declare
1697 // fields that might already exist in Java but should be injected if
1698 // they don&#39;t.  Otherwise the field is unconditionally injected and
1699 // the JVM uses the injected one.  This is to ensure that name
1700 // collisions don&#39;t occur.  In general may_be_java should be false
1701 // unless there&#39;s a good reason.
1702 
1703 class InjectedField {
1704  public:
1705   const SystemDictionary::WKID klass_id;
1706   const vmSymbols::SID name_index;
1707   const vmSymbols::SID signature_index;
1708   const bool           may_be_java;
1709 
1710 
1711   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1712   Symbol* name() const      { return lookup_symbol(name_index); }
1713   Symbol* signature() const { return lookup_symbol(signature_index); }
1714 
1715   int compute_offset();
1716 
1717   // Find the Symbol for this index
1718   static Symbol* lookup_symbol(int symbol_index) {
1719     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1720   }
1721 };
1722 
1723 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1724   klass##_##name##_enum,
1725 
1726 #define ALL_INJECTED_FIELDS(macro)          \
1727   CLASS_INJECTED_FIELDS(macro)              \
1728   CLASSLOADER_INJECTED_FIELDS(macro)        \
1729   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1730   MEMBERNAME_INJECTED_FIELDS(macro)         \
1731   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1732   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1733   MODULE_INJECTED_FIELDS(macro)
1734 
1735 // Interface to hard-coded offset checking
1736 
1737 class JavaClasses : AllStatic {
1738  private:
1739 
1740   static InjectedField _injected_fields[];
1741 
1742   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1743  public:
1744   enum InjectedFieldID {
1745     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1746     MAX_enum
1747   };
1748 
1749   static int compute_injected_offset(InjectedFieldID id);
1750 
1751   static void compute_offsets();
1752   static void check_offsets() PRODUCT_RETURN;
1753   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1754   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1755   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1756 };
1757 
1758 #undef DECLARE_INJECTED_FIELD_ENUM
1759 
1760 #undef CHECK_INIT
1761 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
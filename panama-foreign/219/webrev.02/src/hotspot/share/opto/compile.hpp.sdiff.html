<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 366   const TypeFunc*       _last_tf;               //  TypeFunc::make
 367   AliasType**           _alias_types;           // List of alias types seen so far.
 368   int                   _num_alias_types;       // Logical length of _alias_types
 369   int                   _max_alias_types;       // Physical length of _alias_types
 370   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 371 
 372   // Parsing, optimization
 373   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 374   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 375   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 376 
 377   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 378                                                       // main parsing has finished.
 379   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 380 
 381   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 382 
 383   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 384   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 385 

 386 
 387   // Inlining may not happen in parse order which would make
 388   // PrintInlining output confusing. Keep track of PrintInlining
 389   // pieces in order.
 390   class PrintInliningBuffer : public ResourceObj {
 391    private:
 392     CallGenerator* _cg;
 393     stringStream* _ss;
 394 
 395    public:
 396     PrintInliningBuffer()
 397       : _cg(NULL) { _ss = new stringStream(); }
 398 
 399     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }
 400 
 401     stringStream* ss() const { return _ss; }
 402     CallGenerator* cg() const { return _cg; }
 403     void set_cg(CallGenerator* cg) { _cg = cg; }
 404   };
 405 
</pre>
<hr />
<pre>
 925   WarmCallInfo* pop_warm_call();
 926 
 927   // Record this CallGenerator for inlining at the end of parsing.
 928   void              add_late_inline(CallGenerator* cg)        {
 929     _late_inlines.insert_before(_late_inlines_pos, cg);
 930     _late_inlines_pos++;
 931   }
 932 
 933   void              prepend_late_inline(CallGenerator* cg)    {
 934     _late_inlines.insert_before(0, cg);
 935   }
 936 
 937   void              add_string_late_inline(CallGenerator* cg) {
 938     _string_late_inlines.push(cg);
 939   }
 940 
 941   void              add_boxing_late_inline(CallGenerator* cg) {
 942     _boxing_late_inlines.push(cg);
 943   }
 944 




 945   void remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful);
 946 
 947   void process_print_inlining();
 948   void dump_print_inlining();
 949 
 950   bool over_inlining_cutoff() const {
 951     if (!inlining_incrementally()) {
 952       return unique() &gt; (uint)NodeCountInliningCutoff;
 953     } else {
 954       // Give some room for incremental inlining algorithm to &quot;breathe&quot;
 955       // and avoid thrashing when live node count is close to the limit.
 956       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
 957       // dead node elimination step happens (see Compile::inline_incrementally).
 958       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
 959     }
 960   }
 961 
 962   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
 963   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
 964   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
</pre>
</td>
<td>
<hr />
<pre>
 366   const TypeFunc*       _last_tf;               //  TypeFunc::make
 367   AliasType**           _alias_types;           // List of alias types seen so far.
 368   int                   _num_alias_types;       // Logical length of _alias_types
 369   int                   _max_alias_types;       // Physical length of _alias_types
 370   AliasCacheEntry       _alias_cache[AliasCacheSize]; // Gets aliases w/o data structure walking
 371 
 372   // Parsing, optimization
 373   PhaseGVN*             _initial_gvn;           // Results of parse-time PhaseGVN
 374   Unique_Node_List*     _for_igvn;              // Initial work-list for next round of Iterative GVN
 375   WarmCallInfo*         _warm_calls;            // Sorted work-list for heat-based inlining.
 376 
 377   GrowableArray&lt;CallGenerator*&gt; _late_inlines;        // List of CallGenerators to be revisited after
 378                                                       // main parsing has finished.
 379   GrowableArray&lt;CallGenerator*&gt; _string_late_inlines; // same but for string operations
 380 
 381   GrowableArray&lt;CallGenerator*&gt; _boxing_late_inlines; // same but for boxing operations
 382 
 383   int                           _late_inlines_pos;    // Where in the queue should the next late inlining candidate go (emulate depth first inlining)
 384   uint                          _number_of_mh_late_inlines; // number of method handle late inlining still pending
 385 
<span class="line-added"> 386   GrowableArray&lt;address&gt;*       _native_stubs;</span>
 387 
 388   // Inlining may not happen in parse order which would make
 389   // PrintInlining output confusing. Keep track of PrintInlining
 390   // pieces in order.
 391   class PrintInliningBuffer : public ResourceObj {
 392    private:
 393     CallGenerator* _cg;
 394     stringStream* _ss;
 395 
 396    public:
 397     PrintInliningBuffer()
 398       : _cg(NULL) { _ss = new stringStream(); }
 399 
 400     void freeStream() { _ss-&gt;~stringStream(); _ss = NULL; }
 401 
 402     stringStream* ss() const { return _ss; }
 403     CallGenerator* cg() const { return _cg; }
 404     void set_cg(CallGenerator* cg) { _cg = cg; }
 405   };
 406 
</pre>
<hr />
<pre>
 926   WarmCallInfo* pop_warm_call();
 927 
 928   // Record this CallGenerator for inlining at the end of parsing.
 929   void              add_late_inline(CallGenerator* cg)        {
 930     _late_inlines.insert_before(_late_inlines_pos, cg);
 931     _late_inlines_pos++;
 932   }
 933 
 934   void              prepend_late_inline(CallGenerator* cg)    {
 935     _late_inlines.insert_before(0, cg);
 936   }
 937 
 938   void              add_string_late_inline(CallGenerator* cg) {
 939     _string_late_inlines.push(cg);
 940   }
 941 
 942   void              add_boxing_late_inline(CallGenerator* cg) {
 943     _boxing_late_inlines.push(cg);
 944   }
 945 
<span class="line-added"> 946   void add_native_stub(address stub);</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948   GrowableArray&lt;address&gt;* native_stubs() const { return _native_stubs; }</span>
<span class="line-added"> 949 </span>
 950   void remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful);
 951 
 952   void process_print_inlining();
 953   void dump_print_inlining();
 954 
 955   bool over_inlining_cutoff() const {
 956     if (!inlining_incrementally()) {
 957       return unique() &gt; (uint)NodeCountInliningCutoff;
 958     } else {
 959       // Give some room for incremental inlining algorithm to &quot;breathe&quot;
 960       // and avoid thrashing when live node count is close to the limit.
 961       // Keep in mind that live_nodes() isn&#39;t accurate during inlining until
 962       // dead node elimination step happens (see Compile::inline_incrementally).
 963       return live_nodes() &gt; (uint)LiveNodeCountInliningCutoff * 11 / 10;
 964     }
 965   }
 966 
 967   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
 968   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
 969   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
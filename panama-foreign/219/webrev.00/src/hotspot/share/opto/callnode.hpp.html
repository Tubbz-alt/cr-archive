<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/callnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_CALLNODE_HPP
  26 #define SHARE_OPTO_CALLNODE_HPP
  27 
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/mulnode.hpp&quot;
  30 #include &quot;opto/multnode.hpp&quot;
  31 #include &quot;opto/opcodes.hpp&quot;
  32 #include &quot;opto/phaseX.hpp&quot;
  33 #include &quot;opto/replacednodes.hpp&quot;
  34 #include &quot;opto/type.hpp&quot;
  35 #include &quot;utilities/growableArray.hpp&quot;
  36 
  37 // Portions of code courtesy of Clifford Click
  38 
  39 // Optimization - Graph Style
  40 
  41 class Chaitin;
  42 class NamedCounter;
  43 class MultiNode;
  44 class  SafePointNode;
  45 class   CallNode;
  46 class     CallJavaNode;
  47 class       CallStaticJavaNode;
  48 class       CallDynamicJavaNode;
  49 class     CallRuntimeNode;
  50 class       CallLeafNode;
  51 class         CallLeafNoFPNode;
  52 class     CallNativeNode;
  53 class     AllocateNode;
  54 class       AllocateArrayNode;
  55 class     BoxLockNode;
  56 class     LockNode;
  57 class     UnlockNode;
  58 class JVMState;
  59 class OopMap;
  60 class State;
  61 class StartNode;
  62 class MachCallNode;
  63 class FastLockNode;
  64 
  65 //------------------------------StartNode--------------------------------------
  66 // The method start node
  67 class StartNode : public MultiNode {
  68   virtual bool cmp( const Node &amp;n ) const;
  69   virtual uint size_of() const; // Size is bigger
  70 public:
  71   const TypeTuple *_domain;
  72   StartNode( Node *root, const TypeTuple *domain ) : MultiNode(2), _domain(domain) {
  73     init_class_id(Class_Start);
  74     init_req(0,this);
  75     init_req(1,root);
  76   }
  77   virtual int Opcode() const;
  78   virtual bool pinned() const { return true; };
  79   virtual const Type *bottom_type() const;
  80   virtual const TypePtr *adr_type() const { return TypePtr::BOTTOM; }
  81   virtual const Type* Value(PhaseGVN* phase) const;
  82   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
  83   virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_reg, uint length ) const;
  84   virtual const RegMask &amp;in_RegMask(uint) const;
  85   virtual Node *match( const ProjNode *proj, const Matcher *m );
  86   virtual uint ideal_reg() const { return 0; }
  87 #ifndef PRODUCT
  88   virtual void  dump_spec(outputStream *st) const;
  89   virtual void  dump_compact_spec(outputStream *st) const;
  90 #endif
  91 };
  92 
  93 //------------------------------StartOSRNode-----------------------------------
  94 // The method start node for on stack replacement code
  95 class StartOSRNode : public StartNode {
  96 public:
  97   StartOSRNode( Node *root, const TypeTuple *domain ) : StartNode(root, domain) {}
  98   virtual int   Opcode() const;
  99   static  const TypeTuple *osr_domain();
 100 };
 101 
 102 
 103 //------------------------------ParmNode---------------------------------------
 104 // Incoming parameters
 105 class ParmNode : public ProjNode {
 106   static const char * const names[TypeFunc::Parms+1];
 107 public:
 108   ParmNode( StartNode *src, uint con ) : ProjNode(src,con) {
 109     init_class_id(Class_Parm);
 110   }
 111   virtual int Opcode() const;
 112   virtual bool  is_CFG() const { return (_con == TypeFunc::Control); }
 113   virtual uint ideal_reg() const;
 114 #ifndef PRODUCT
 115   virtual void dump_spec(outputStream *st) const;
 116   virtual void dump_compact_spec(outputStream *st) const;
 117   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
 118 #endif
 119 };
 120 
 121 
 122 //------------------------------ReturnNode-------------------------------------
 123 // Return from subroutine node
 124 class ReturnNode : public Node {
 125 public:
 126   ReturnNode( uint edges, Node *cntrl, Node *i_o, Node *memory, Node *retadr, Node *frameptr );
 127   virtual int Opcode() const;
 128   virtual bool  is_CFG() const { return true; }
 129   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 130   virtual bool depends_only_on_test() const { return false; }
 131   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 132   virtual const Type* Value(PhaseGVN* phase) const;
 133   virtual uint ideal_reg() const { return NotAMachineReg; }
 134   virtual uint match_edge(uint idx) const;
 135 #ifndef PRODUCT
 136   virtual void dump_req(outputStream *st = tty) const;
 137 #endif
 138 };
 139 
 140 
 141 //------------------------------RethrowNode------------------------------------
 142 // Rethrow of exception at call site.  Ends a procedure before rethrowing;
 143 // ends the current basic block like a ReturnNode.  Restores registers and
 144 // unwinds stack.  Rethrow happens in the caller&#39;s method.
 145 class RethrowNode : public Node {
 146  public:
 147   RethrowNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *ret_adr, Node *exception );
 148   virtual int Opcode() const;
 149   virtual bool  is_CFG() const { return true; }
 150   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 151   virtual bool depends_only_on_test() const { return false; }
 152   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 153   virtual const Type* Value(PhaseGVN* phase) const;
 154   virtual uint match_edge(uint idx) const;
 155   virtual uint ideal_reg() const { return NotAMachineReg; }
 156 #ifndef PRODUCT
 157   virtual void dump_req(outputStream *st = tty) const;
 158 #endif
 159 };
 160 
 161 
 162 //------------------------------TailCallNode-----------------------------------
 163 // Pop stack frame and jump indirect
 164 class TailCallNode : public ReturnNode {
 165 public:
 166   TailCallNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr, Node *target, Node *moop )
 167     : ReturnNode( TypeFunc::Parms+2, cntrl, i_o, memory, frameptr, retadr ) {
 168     init_req(TypeFunc::Parms, target);
 169     init_req(TypeFunc::Parms+1, moop);
 170   }
 171 
 172   virtual int Opcode() const;
 173   virtual uint match_edge(uint idx) const;
 174 };
 175 
 176 //------------------------------TailJumpNode-----------------------------------
 177 // Pop stack frame and jump indirect
 178 class TailJumpNode : public ReturnNode {
 179 public:
 180   TailJumpNode( Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *target, Node *ex_oop)
 181     : ReturnNode(TypeFunc::Parms+2, cntrl, i_o, memory, frameptr, Compile::current()-&gt;top()) {
 182     init_req(TypeFunc::Parms, target);
 183     init_req(TypeFunc::Parms+1, ex_oop);
 184   }
 185 
 186   virtual int Opcode() const;
 187   virtual uint match_edge(uint idx) const;
 188 };
 189 
 190 //-------------------------------JVMState-------------------------------------
 191 // A linked list of JVMState nodes captures the whole interpreter state,
 192 // plus GC roots, for all active calls at some call site in this compilation
 193 // unit.  (If there is no inlining, then the list has exactly one link.)
 194 // This provides a way to map the optimized program back into the interpreter,
 195 // or to let the GC mark the stack.
 196 class JVMState : public ResourceObj {
 197   friend class VMStructs;
 198 public:
 199   typedef enum {
 200     Reexecute_Undefined = -1, // not defined -- will be translated into false later
 201     Reexecute_False     =  0, // false       -- do not reexecute
 202     Reexecute_True      =  1  // true        -- reexecute the bytecode
 203   } ReexecuteState; //Reexecute State
 204 
 205 private:
 206   JVMState*         _caller;    // List pointer for forming scope chains
 207   uint              _depth;     // One more than caller depth, or one.
 208   uint              _locoff;    // Offset to locals in input edge mapping
 209   uint              _stkoff;    // Offset to stack in input edge mapping
 210   uint              _monoff;    // Offset to monitors in input edge mapping
 211   uint              _scloff;    // Offset to fields of scalar objs in input edge mapping
 212   uint              _endoff;    // Offset to end of input edge mapping
 213   uint              _sp;        // Jave Expression Stack Pointer for this state
 214   int               _bci;       // Byte Code Index of this JVM point
 215   ReexecuteState    _reexecute; // Whether this bytecode need to be re-executed
 216   ciMethod*         _method;    // Method Pointer
 217   SafePointNode*    _map;       // Map node associated with this scope
 218 public:
 219   friend class Compile;
 220   friend class PreserveReexecuteState;
 221 
 222   // Because JVMState objects live over the entire lifetime of the
 223   // Compile object, they are allocated into the comp_arena, which
 224   // does not get resource marked or reset during the compile process
 225   void *operator new( size_t x, Compile* C ) throw() { return C-&gt;comp_arena()-&gt;Amalloc(x); }
 226   void operator delete( void * ) { } // fast deallocation
 227 
 228   // Create a new JVMState, ready for abstract interpretation.
 229   JVMState(ciMethod* method, JVMState* caller);
 230   JVMState(int stack_size);  // root state; has a null method
 231 
 232   // Access functions for the JVM
 233   // ... --|--- loc ---|--- stk ---|--- arg ---|--- mon ---|--- scl ---|
 234   //       \ locoff    \ stkoff    \ argoff    \ monoff    \ scloff    \ endoff
 235   uint              locoff() const { return _locoff; }
 236   uint              stkoff() const { return _stkoff; }
 237   uint              argoff() const { return _stkoff + _sp; }
 238   uint              monoff() const { return _monoff; }
 239   uint              scloff() const { return _scloff; }
 240   uint              endoff() const { return _endoff; }
 241   uint              oopoff() const { return debug_end(); }
 242 
 243   int            loc_size() const { return stkoff() - locoff(); }
 244   int            stk_size() const { return monoff() - stkoff(); }
 245   int            mon_size() const { return scloff() - monoff(); }
 246   int            scl_size() const { return endoff() - scloff(); }
 247 
 248   bool        is_loc(uint i) const { return locoff() &lt;= i &amp;&amp; i &lt; stkoff(); }
 249   bool        is_stk(uint i) const { return stkoff() &lt;= i &amp;&amp; i &lt; monoff(); }
 250   bool        is_mon(uint i) const { return monoff() &lt;= i &amp;&amp; i &lt; scloff(); }
 251   bool        is_scl(uint i) const { return scloff() &lt;= i &amp;&amp; i &lt; endoff(); }
 252 
 253   uint                      sp() const { return _sp; }
 254   int                      bci() const { return _bci; }
 255   bool        should_reexecute() const { return _reexecute==Reexecute_True; }
 256   bool  is_reexecute_undefined() const { return _reexecute==Reexecute_Undefined; }
 257   bool              has_method() const { return _method != NULL; }
 258   ciMethod*             method() const { assert(has_method(), &quot;&quot;); return _method; }
 259   JVMState*             caller() const { return _caller; }
 260   SafePointNode*           map() const { return _map; }
 261   uint                   depth() const { return _depth; }
 262   uint             debug_start() const; // returns locoff of root caller
 263   uint               debug_end() const; // returns endoff of self
 264   uint              debug_size() const {
 265     return loc_size() + sp() + mon_size() + scl_size();
 266   }
 267   uint        debug_depth()  const; // returns sum of debug_size values at all depths
 268 
 269   // Returns the JVM state at the desired depth (1 == root).
 270   JVMState* of_depth(int d) const;
 271 
 272   // Tells if two JVM states have the same call chain (depth, methods, &amp; bcis).
 273   bool same_calls_as(const JVMState* that) const;
 274 
 275   // Monitors (monitors are stored as (boxNode, objNode) pairs
 276   enum { logMonitorEdges = 1 };
 277   int  nof_monitors()              const { return mon_size() &gt;&gt; logMonitorEdges; }
 278   int  monitor_depth()             const { return nof_monitors() + (caller() ? caller()-&gt;monitor_depth() : 0); }
 279   int  monitor_box_offset(int idx) const { return monoff() + (idx &lt;&lt; logMonitorEdges) + 0; }
 280   int  monitor_obj_offset(int idx) const { return monoff() + (idx &lt;&lt; logMonitorEdges) + 1; }
 281   bool is_monitor_box(uint off)    const {
 282     assert(is_mon(off), &quot;should be called only for monitor edge&quot;);
 283     return (0 == bitfield(off - monoff(), 0, logMonitorEdges));
 284   }
 285   bool is_monitor_use(uint off)    const { return (is_mon(off)
 286                                                    &amp;&amp; is_monitor_box(off))
 287                                              || (caller() &amp;&amp; caller()-&gt;is_monitor_use(off)); }
 288 
 289   // Initialization functions for the JVM
 290   void              set_locoff(uint off) { _locoff = off; }
 291   void              set_stkoff(uint off) { _stkoff = off; }
 292   void              set_monoff(uint off) { _monoff = off; }
 293   void              set_scloff(uint off) { _scloff = off; }
 294   void              set_endoff(uint off) { _endoff = off; }
 295   void              set_offsets(uint off) {
 296     _locoff = _stkoff = _monoff = _scloff = _endoff = off;
 297   }
 298   void              set_map(SafePointNode *map) { _map = map; }
 299   void              set_sp(uint sp) { _sp = sp; }
 300                     // _reexecute is initialized to &quot;undefined&quot; for a new bci
 301   void              set_bci(int bci) {if(_bci != bci)_reexecute=Reexecute_Undefined; _bci = bci; }
 302   void              set_should_reexecute(bool reexec) {_reexecute = reexec ? Reexecute_True : Reexecute_False;}
 303 
 304   // Miscellaneous utility functions
 305   JVMState* clone_deep(Compile* C) const;    // recursively clones caller chain
 306   JVMState* clone_shallow(Compile* C) const; // retains uncloned caller
 307   void      set_map_deep(SafePointNode *map);// reset map for all callers
 308   void      adapt_position(int delta);       // Adapt offsets in in-array after adding an edge.
 309   int       interpreter_frame_size() const;
 310 
 311 #ifndef PRODUCT
 312   void      format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const;
 313   void      dump_spec(outputStream *st) const;
 314   void      dump_on(outputStream* st) const;
 315   void      dump() const {
 316     dump_on(tty);
 317   }
 318 #endif
 319 };
 320 
 321 //------------------------------SafePointNode----------------------------------
 322 // A SafePointNode is a subclass of a MultiNode for convenience (and
 323 // potential code sharing) only - conceptually it is independent of
 324 // the Node semantics.
 325 class SafePointNode : public MultiNode {
 326   virtual bool           cmp( const Node &amp;n ) const;
 327   virtual uint           size_of() const;       // Size is bigger
 328 
 329 public:
 330   SafePointNode(uint edges, JVMState* jvms,
 331                 // A plain safepoint advertises no memory effects (NULL):
 332                 const TypePtr* adr_type = NULL)
 333     : MultiNode( edges ),
 334       _oop_map(NULL),
 335       _jvms(jvms),
 336       _adr_type(adr_type)
 337   {
 338     init_class_id(Class_SafePoint);
 339   }
 340 
 341   OopMap*         _oop_map;   // Array of OopMap info (8-bit char) for GC
 342   JVMState* const _jvms;      // Pointer to list of JVM State objects
 343   const TypePtr*  _adr_type;  // What type of memory does this node produce?
 344   ReplacedNodes   _replaced_nodes; // During parsing: list of pair of nodes from calls to GraphKit::replace_in_map()
 345 
 346   // Many calls take *all* of memory as input,
 347   // but some produce a limited subset of that memory as output.
 348   // The adr_type reports the call&#39;s behavior as a store, not a load.
 349 
 350   virtual JVMState* jvms() const { return _jvms; }
 351   void set_jvms(JVMState* s) {
 352     *(JVMState**)&amp;_jvms = s;  // override const attribute in the accessor
 353   }
 354   OopMap *oop_map() const { return _oop_map; }
 355   void set_oop_map(OopMap *om) { _oop_map = om; }
 356 
 357  private:
 358   void verify_input(JVMState* jvms, uint idx) const {
 359     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 360     Node* n = in(idx);
 361     assert((!n-&gt;bottom_type()-&gt;isa_long() &amp;&amp; !n-&gt;bottom_type()-&gt;isa_double()) ||
 362            in(idx + 1)-&gt;is_top(), &quot;2nd half of long/double&quot;);
 363   }
 364 
 365  public:
 366   // Functionality from old debug nodes which has changed
 367   Node *local(JVMState* jvms, uint idx) const {
 368     verify_input(jvms, jvms-&gt;locoff() + idx);
 369     return in(jvms-&gt;locoff() + idx);
 370   }
 371   Node *stack(JVMState* jvms, uint idx) const {
 372     verify_input(jvms, jvms-&gt;stkoff() + idx);
 373     return in(jvms-&gt;stkoff() + idx);
 374   }
 375   Node *argument(JVMState* jvms, uint idx) const {
 376     verify_input(jvms, jvms-&gt;argoff() + idx);
 377     return in(jvms-&gt;argoff() + idx);
 378   }
 379   Node *monitor_box(JVMState* jvms, uint idx) const {
 380     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 381     return in(jvms-&gt;monitor_box_offset(idx));
 382   }
 383   Node *monitor_obj(JVMState* jvms, uint idx) const {
 384     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 385     return in(jvms-&gt;monitor_obj_offset(idx));
 386   }
 387 
 388   void  set_local(JVMState* jvms, uint idx, Node *c);
 389 
 390   void  set_stack(JVMState* jvms, uint idx, Node *c) {
 391     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 392     set_req(jvms-&gt;stkoff() + idx, c);
 393   }
 394   void  set_argument(JVMState* jvms, uint idx, Node *c) {
 395     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 396     set_req(jvms-&gt;argoff() + idx, c);
 397   }
 398   void ensure_stack(JVMState* jvms, uint stk_size) {
 399     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 400     int grow_by = (int)stk_size - (int)jvms-&gt;stk_size();
 401     if (grow_by &gt; 0)  grow_stack(jvms, grow_by);
 402   }
 403   void grow_stack(JVMState* jvms, uint grow_by);
 404   // Handle monitor stack
 405   void push_monitor( const FastLockNode *lock );
 406   void pop_monitor ();
 407   Node *peek_monitor_box() const;
 408   Node *peek_monitor_obj() const;
 409 
 410   // Access functions for the JVM
 411   Node *control  () const { return in(TypeFunc::Control  ); }
 412   Node *i_o      () const { return in(TypeFunc::I_O      ); }
 413   Node *memory   () const { return in(TypeFunc::Memory   ); }
 414   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 415   Node *frameptr () const { return in(TypeFunc::FramePtr ); }
 416 
 417   void set_control  ( Node *c ) { set_req(TypeFunc::Control,c); }
 418   void set_i_o      ( Node *c ) { set_req(TypeFunc::I_O    ,c); }
 419   void set_memory   ( Node *c ) { set_req(TypeFunc::Memory ,c); }
 420 
 421   MergeMemNode* merged_memory() const {
 422     return in(TypeFunc::Memory)-&gt;as_MergeMem();
 423   }
 424 
 425   // The parser marks useless maps as dead when it&#39;s done with them:
 426   bool is_killed() { return in(TypeFunc::Control) == NULL; }
 427 
 428   // Exception states bubbling out of subgraphs such as inlined calls
 429   // are recorded here.  (There might be more than one, hence the &quot;next&quot;.)
 430   // This feature is used only for safepoints which serve as &quot;maps&quot;
 431   // for JVM states during parsing, intrinsic expansion, etc.
 432   SafePointNode*         next_exception() const;
 433   void               set_next_exception(SafePointNode* n);
 434   bool                   has_exceptions() const { return next_exception() != NULL; }
 435 
 436   // Helper methods to operate on replaced nodes
 437   ReplacedNodes replaced_nodes() const {
 438     return _replaced_nodes;
 439   }
 440 
 441   void set_replaced_nodes(ReplacedNodes replaced_nodes) {
 442     _replaced_nodes = replaced_nodes;
 443   }
 444 
 445   void clone_replaced_nodes() {
 446     _replaced_nodes.clone();
 447   }
 448   void record_replaced_node(Node* initial, Node* improved) {
 449     _replaced_nodes.record(initial, improved);
 450   }
 451   void transfer_replaced_nodes_from(SafePointNode* sfpt, uint idx = 0) {
 452     _replaced_nodes.transfer_from(sfpt-&gt;_replaced_nodes, idx);
 453   }
 454   void delete_replaced_nodes() {
 455     _replaced_nodes.reset();
 456   }
 457   void apply_replaced_nodes(uint idx) {
 458     _replaced_nodes.apply(this, idx);
 459   }
 460   void merge_replaced_nodes_with(SafePointNode* sfpt) {
 461     _replaced_nodes.merge_with(sfpt-&gt;_replaced_nodes);
 462   }
 463   bool has_replaced_nodes() const {
 464     return !_replaced_nodes.is_empty();
 465   }
 466 
 467   void disconnect_from_root(PhaseIterGVN *igvn);
 468 
 469   // Standard Node stuff
 470   virtual int            Opcode() const;
 471   virtual bool           pinned() const { return true; }
 472   virtual const Type*    Value(PhaseGVN* phase) const;
 473   virtual const Type    *bottom_type() const { return Type::CONTROL; }
 474   virtual const TypePtr *adr_type() const { return _adr_type; }
 475   virtual Node          *Ideal(PhaseGVN *phase, bool can_reshape);
 476   virtual Node*          Identity(PhaseGVN* phase);
 477   virtual uint           ideal_reg() const { return 0; }
 478   virtual const RegMask &amp;in_RegMask(uint) const;
 479   virtual const RegMask &amp;out_RegMask() const;
 480   virtual uint           match_edge(uint idx) const;
 481 
 482   static  bool           needs_polling_address_input();
 483 
 484 #ifndef PRODUCT
 485   virtual void           dump_spec(outputStream *st) const;
 486   virtual void           related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
 487 #endif
 488 };
 489 
 490 //------------------------------SafePointScalarObjectNode----------------------
 491 // A SafePointScalarObjectNode represents the state of a scalarized object
 492 // at a safepoint.
 493 
 494 class SafePointScalarObjectNode: public TypeNode {
 495   uint _first_index; // First input edge relative index of a SafePoint node where
 496                      // states of the scalarized object fields are collected.
 497                      // It is relative to the last (youngest) jvms-&gt;_scloff.
 498   uint _n_fields;    // Number of non-static fields of the scalarized object.
 499   DEBUG_ONLY(AllocateNode* _alloc;)
 500 
 501   virtual uint hash() const ; // { return NO_HASH; }
 502   virtual bool cmp( const Node &amp;n ) const;
 503 
 504   uint first_index() const { return _first_index; }
 505 
 506 public:
 507   SafePointScalarObjectNode(const TypeOopPtr* tp,
 508 #ifdef ASSERT
 509                             AllocateNode* alloc,
 510 #endif
 511                             uint first_index, uint n_fields);
 512   virtual int Opcode() const;
 513   virtual uint           ideal_reg() const;
 514   virtual const RegMask &amp;in_RegMask(uint) const;
 515   virtual const RegMask &amp;out_RegMask() const;
 516   virtual uint           match_edge(uint idx) const;
 517 
 518   uint first_index(JVMState* jvms) const {
 519     assert(jvms != NULL, &quot;missed JVMS&quot;);
 520     return jvms-&gt;scloff() + _first_index;
 521   }
 522   uint n_fields()    const { return _n_fields; }
 523 
 524 #ifdef ASSERT
 525   AllocateNode* alloc() const { return _alloc; }
 526 #endif
 527 
 528   virtual uint size_of() const { return sizeof(*this); }
 529 
 530   // Assumes that &quot;this&quot; is an argument to a safepoint node &quot;s&quot;, and that
 531   // &quot;new_call&quot; is being created to correspond to &quot;s&quot;.  But the difference
 532   // between the start index of the jvmstates of &quot;new_call&quot; and &quot;s&quot; is
 533   // &quot;jvms_adj&quot;.  Produce and return a SafePointScalarObjectNode that
 534   // corresponds appropriately to &quot;this&quot; in &quot;new_call&quot;.  Assumes that
 535   // &quot;sosn_map&quot; is a map, specific to the translation of &quot;s&quot; to &quot;new_call&quot;,
 536   // mapping old SafePointScalarObjectNodes to new, to avoid multiple copies.
 537   SafePointScalarObjectNode* clone(Dict* sosn_map) const;
 538 
 539 #ifndef PRODUCT
 540   virtual void              dump_spec(outputStream *st) const;
 541 #endif
 542 };
 543 
 544 
 545 // Simple container for the outgoing projections of a call.  Useful
 546 // for serious surgery on calls.
 547 class CallProjections : public StackObj {
 548 public:
 549   Node* fallthrough_proj;
 550   Node* fallthrough_catchproj;
 551   Node* fallthrough_memproj;
 552   Node* fallthrough_ioproj;
 553   Node* catchall_catchproj;
 554   Node* catchall_memproj;
 555   Node* catchall_ioproj;
 556   Node* resproj;
 557   Node* exobj;
 558 };
 559 
 560 class CallGenerator;
 561 
 562 //------------------------------CallNode---------------------------------------
 563 // Call nodes now subsume the function of debug nodes at callsites, so they
 564 // contain the functionality of a full scope chain of debug nodes.
 565 class CallNode : public SafePointNode {
 566   friend class VMStructs;
 567 
 568 protected:
 569   bool may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase);
 570 
 571 public:
 572   const TypeFunc *_tf;        // Function type
 573   address      _entry_point;  // Address of method being called
 574   float        _cnt;          // Estimate of number of times called
 575   CallGenerator* _generator;  // corresponding CallGenerator for some late inline calls
 576   const char *_name;           // Printable name, if _method is NULL
 577 
 578   CallNode(const TypeFunc* tf, address addr, const TypePtr* adr_type)
 579     : SafePointNode(tf-&gt;domain()-&gt;cnt(), NULL, adr_type),
 580       _tf(tf),
 581       _entry_point(addr),
 582       _cnt(COUNT_UNKNOWN),
 583       _generator(NULL),
 584       _name(NULL)
 585   {
 586     init_class_id(Class_Call);
 587   }
 588 
 589   const TypeFunc* tf()         const { return _tf; }
 590   const address  entry_point() const { return _entry_point; }
 591   const float    cnt()         const { return _cnt; }
 592   CallGenerator* generator()   const { return _generator; }
 593 
 594   void set_tf(const TypeFunc* tf)       { _tf = tf; }
 595   void set_entry_point(address p)       { _entry_point = p; }
 596   void set_cnt(float c)                 { _cnt = c; }
 597   void set_generator(CallGenerator* cg) { _generator = cg; }
 598 
 599   virtual const Type *bottom_type() const;
 600   virtual const Type* Value(PhaseGVN* phase) const;
 601   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 602   virtual Node* Identity(PhaseGVN* phase) { return this; }
 603   virtual bool        cmp( const Node &amp;n ) const;
 604   virtual uint        size_of() const = 0;
 605   virtual void        calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
 606   virtual Node       *match( const ProjNode *proj, const Matcher *m );
 607   virtual uint        ideal_reg() const { return NotAMachineReg; }
 608   // Are we guaranteed that this node is a safepoint?  Not true for leaf calls and
 609   // for some macro nodes whose expansion does not have a safepoint on the fast path.
 610   virtual bool        guaranteed_safepoint()  { return true; }
 611   // For macro nodes, the JVMState gets modified during expansion. If calls
 612   // use MachConstantBase, it gets modified during matching. So when cloning
 613   // the node the JVMState must be cloned. Default is not to clone.
 614   virtual void clone_jvms(Compile* C) {
 615     if (C-&gt;needs_clone_jvms() &amp;&amp; jvms() != NULL) {
 616       set_jvms(jvms()-&gt;clone_deep(C));
 617       jvms()-&gt;set_map_deep(this);
 618     }
 619   }
 620 
 621   // Returns true if the call may modify n
 622   virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase);
 623   // Does this node have a use of n other than in debug information?
 624   bool                has_non_debug_use(Node *n);
 625   // Returns the unique CheckCastPP of a call
 626   // or result projection is there are several CheckCastPP
 627   // or returns NULL if there is no one.
 628   Node *result_cast();
 629   // Does this node returns pointer?
 630   bool returns_pointer() const {
 631     const TypeTuple *r = tf()-&gt;range();
 632     return (r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
 633             r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
 634   }
 635 
 636   // Collect all the interesting edges from a call for use in
 637   // replacing the call by something else.  Used by macro expansion
 638   // and the late inlining support.
 639   void extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts = true);
 640 
 641   virtual uint match_edge(uint idx) const;
 642 
 643   bool is_call_to_arraycopystub() const;
 644 
 645 #ifndef PRODUCT
 646   virtual void        dump_req(outputStream *st = tty) const;
 647   virtual void        dump_spec(outputStream *st) const;
 648 #endif
 649 };
 650 
 651 
 652 //------------------------------CallJavaNode-----------------------------------
 653 // Make a static or dynamic subroutine call node using Java calling
 654 // convention.  (The &quot;Java&quot; calling convention is the compiler&#39;s calling
 655 // convention, as opposed to the interpreter&#39;s or that of native C.)
 656 class CallJavaNode : public CallNode {
 657   friend class VMStructs;
 658 protected:
 659   virtual bool cmp( const Node &amp;n ) const;
 660   virtual uint size_of() const; // Size is bigger
 661 
 662   bool    _optimized_virtual;
 663   bool    _method_handle_invoke;
 664   bool    _override_symbolic_info; // Override symbolic call site info from bytecode
 665   ciMethod* _method;               // Method being direct called
 666 public:
 667   const int       _bci;         // Byte Code Index of call byte code
 668   CallJavaNode(const TypeFunc* tf , address addr, ciMethod* method, int bci)
 669     : CallNode(tf, addr, TypePtr::BOTTOM),
 670       _optimized_virtual(false),
 671       _method_handle_invoke(false),
 672       _override_symbolic_info(false),
 673       _method(method), _bci(bci)
 674   {
 675     init_class_id(Class_CallJava);
 676   }
 677 
 678   virtual int   Opcode() const;
 679   ciMethod* method() const                 { return _method; }
 680   void  set_method(ciMethod *m)            { _method = m; }
 681   void  set_optimized_virtual(bool f)      { _optimized_virtual = f; }
 682   bool  is_optimized_virtual() const       { return _optimized_virtual; }
 683   void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }
 684   bool  is_method_handle_invoke() const    { return _method_handle_invoke; }
 685   void  set_override_symbolic_info(bool f) { _override_symbolic_info = f; }
 686   bool  override_symbolic_info() const     { return _override_symbolic_info; }
 687 
 688   DEBUG_ONLY( bool validate_symbolic_info() const; )
 689 
 690 #ifndef PRODUCT
 691   virtual void  dump_spec(outputStream *st) const;
 692   virtual void  dump_compact_spec(outputStream *st) const;
 693 #endif
 694 };
 695 
 696 //------------------------------CallStaticJavaNode-----------------------------
 697 // Make a direct subroutine call using Java calling convention (for static
 698 // calls and optimized virtual calls, plus calls to wrappers for run-time
 699 // routines); generates static stub.
 700 class CallStaticJavaNode : public CallJavaNode {
 701   virtual bool cmp( const Node &amp;n ) const;
 702   virtual uint size_of() const; // Size is bigger
 703 public:
 704   CallStaticJavaNode(Compile* C, const TypeFunc* tf, address addr, ciMethod* method, int bci)
 705     : CallJavaNode(tf, addr, method, bci) {
 706     init_class_id(Class_CallStaticJava);
 707     if (C-&gt;eliminate_boxing() &amp;&amp; (method != NULL) &amp;&amp; method-&gt;is_boxing_method()) {
 708       init_flags(Flag_is_macro);
 709       C-&gt;add_macro_node(this);
 710     }
 711     _is_scalar_replaceable = false;
 712     _is_non_escaping = false;
 713   }
 714   CallStaticJavaNode(const TypeFunc* tf, address addr, const char* name, int bci,
 715                      const TypePtr* adr_type)
 716     : CallJavaNode(tf, addr, NULL, bci) {
 717     init_class_id(Class_CallStaticJava);
 718     // This node calls a runtime stub, which often has narrow memory effects.
 719     _adr_type = adr_type;
 720     _is_scalar_replaceable = false;
 721     _is_non_escaping = false;
 722     _name = name;
 723   }
 724 
 725   // Result of Escape Analysis
 726   bool _is_scalar_replaceable;
 727   bool _is_non_escaping;
 728 
 729   // If this is an uncommon trap, return the request code, else zero.
 730   int uncommon_trap_request() const;
 731   static int extract_uncommon_trap_request(const Node* call);
 732 
 733   bool is_boxing_method() const {
 734     return is_macro() &amp;&amp; (method() != NULL) &amp;&amp; method()-&gt;is_boxing_method();
 735   }
 736   // Later inlining modifies the JVMState, so we need to clone it
 737   // when the call node is cloned (because it is macro node).
 738   virtual void  clone_jvms(Compile* C) {
 739     if ((jvms() != NULL) &amp;&amp; is_boxing_method()) {
 740       set_jvms(jvms()-&gt;clone_deep(C));
 741       jvms()-&gt;set_map_deep(this);
 742     }
 743   }
 744 
 745   virtual int         Opcode() const;
 746 #ifndef PRODUCT
 747   virtual void        dump_spec(outputStream *st) const;
 748   virtual void        dump_compact_spec(outputStream *st) const;
 749 #endif
 750 };
 751 
 752 //------------------------------CallDynamicJavaNode----------------------------
 753 // Make a dispatched call using Java calling convention.
 754 class CallDynamicJavaNode : public CallJavaNode {
 755   virtual bool cmp( const Node &amp;n ) const;
 756   virtual uint size_of() const; // Size is bigger
 757 public:
 758   CallDynamicJavaNode( const TypeFunc *tf , address addr, ciMethod* method, int vtable_index, int bci ) : CallJavaNode(tf,addr,method,bci), _vtable_index(vtable_index) {
 759     init_class_id(Class_CallDynamicJava);
 760   }
 761 
 762   int _vtable_index;
 763   virtual int   Opcode() const;
 764 #ifndef PRODUCT
 765   virtual void  dump_spec(outputStream *st) const;
 766 #endif
 767 };
 768 
 769 //------------------------------CallRuntimeNode--------------------------------
 770 // Make a direct subroutine call node into compiled C++ code.
 771 class CallRuntimeNode : public CallNode {
 772   virtual bool cmp( const Node &amp;n ) const;
 773   virtual uint size_of() const; // Size is bigger
 774 public:
 775   CallRuntimeNode(const TypeFunc* tf, address addr, const char* name,
 776                   const TypePtr* adr_type)
 777     : CallNode(tf, addr, adr_type)
 778   {
 779     init_class_id(Class_CallRuntime);
 780     _name = name;
 781   }
 782 
 783   virtual int   Opcode() const;
 784   virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
 785 
 786 #ifndef PRODUCT
 787   virtual void  dump_spec(outputStream *st) const;
 788 #endif
 789 };
 790 
 791 //------------------------------CallLeafNode-----------------------------------
 792 // Make a direct subroutine call node into compiled C++ code, without
 793 // safepoints
 794 class CallLeafNode : public CallRuntimeNode {
 795 public:
 796   CallLeafNode(const TypeFunc* tf, address addr, const char* name,
 797                const TypePtr* adr_type)
 798     : CallRuntimeNode(tf, addr, name, adr_type)
 799   {
 800     init_class_id(Class_CallLeaf);
 801   }
 802   virtual int   Opcode() const;
 803   virtual bool        guaranteed_safepoint()  { return false; }
 804 #ifndef PRODUCT
 805   virtual void  dump_spec(outputStream *st) const;
 806 #endif
 807 };
 808 
 809 //------------------------------CallNativeNode-----------------------------------
 810 // Make a direct call into a foreign function with an arbitrary ABI
 811 // safepoints
 812 class CallNativeNode : public CallNode {
 813   virtual bool cmp( const Node &amp;n ) const;
 814   virtual uint size_of() const;
 815 public:
 816   GrowableArray&lt;VMReg&gt; _arg_regs;
 817   GrowableArray&lt;VMReg&gt; _ret_regs;
 818   const int _shadow_space_bytes;
 819   const bool _need_transition;
 820 
 821   CallNativeNode(const TypeFunc* tf, address addr, const char* name,
 822                  const TypePtr* adr_type,
 823                  const GrowableArray&lt;VMReg&gt;&amp; arg_regs,
 824                  const GrowableArray&lt;VMReg&gt;&amp; ret_regs,
 825                  int shadow_space_bytes,
 826                  bool need_transition)
 827     : CallNode(tf, addr, adr_type), _arg_regs(arg_regs),
 828       _ret_regs(ret_regs), _shadow_space_bytes(shadow_space_bytes),
 829       _need_transition(need_transition)
 830   {
 831     init_class_id(Class_CallNative);
 832     _name = name;
 833   }
 834   virtual int   Opcode() const;
 835   virtual bool  guaranteed_safepoint()  { return _need_transition; }
 836   virtual Node* match(const ProjNode *proj, const Matcher *m);
 837   virtual void  calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const;
 838 #ifndef PRODUCT
 839   virtual void  dump_spec(outputStream *st) const;
 840 #endif
 841 };
 842 
 843 //------------------------------CallLeafNoFPNode-------------------------------
 844 // CallLeafNode, not using floating point or using it in the same manner as
 845 // the generated code
 846 class CallLeafNoFPNode : public CallLeafNode {
 847 public:
 848   CallLeafNoFPNode(const TypeFunc* tf, address addr, const char* name,
 849                    const TypePtr* adr_type)
 850     : CallLeafNode(tf, addr, name, adr_type)
 851   {
 852   }
 853   virtual int   Opcode() const;
 854 };
 855 
 856 
 857 //------------------------------Allocate---------------------------------------
 858 // High-level memory allocation
 859 //
 860 //  AllocateNode and AllocateArrayNode are subclasses of CallNode because they will
 861 //  get expanded into a code sequence containing a call.  Unlike other CallNodes,
 862 //  they have 2 memory projections and 2 i_o projections (which are distinguished by
 863 //  the _is_io_use flag in the projection.)  This is needed when expanding the node in
 864 //  order to differentiate the uses of the projection on the normal control path from
 865 //  those on the exception return path.
 866 //
 867 class AllocateNode : public CallNode {
 868 public:
 869   enum {
 870     // Output:
 871     RawAddress  = TypeFunc::Parms,    // the newly-allocated raw address
 872     // Inputs:
 873     AllocSize   = TypeFunc::Parms,    // size (in bytes) of the new object
 874     KlassNode,                        // type (maybe dynamic) of the obj.
 875     InitialTest,                      // slow-path test (may be constant)
 876     ALength,                          // array length (or TOP if none)
 877     ParmLimit
 878   };
 879 
 880   static const TypeFunc* alloc_type(const Type* t) {
 881     const Type** fields = TypeTuple::fields(ParmLimit - TypeFunc::Parms);
 882     fields[AllocSize]   = TypeInt::POS;
 883     fields[KlassNode]   = TypeInstPtr::NOTNULL;
 884     fields[InitialTest] = TypeInt::BOOL;
 885     fields[ALength]     = t;  // length (can be a bad length)
 886 
 887     const TypeTuple *domain = TypeTuple::make(ParmLimit, fields);
 888 
 889     // create result type (range)
 890     fields = TypeTuple::fields(1);
 891     fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 892 
 893     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 894 
 895     return TypeFunc::make(domain, range);
 896   }
 897 
 898   // Result of Escape Analysis
 899   bool _is_scalar_replaceable;
 900   bool _is_non_escaping;
 901   // True when MemBar for new is redundant with MemBar at initialzer exit
 902   bool _is_allocation_MemBar_redundant;
 903 
 904   virtual uint size_of() const; // Size is bigger
 905   AllocateNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,
 906                Node *size, Node *klass_node, Node *initial_test);
 907   // Expansion modifies the JVMState, so we need to clone it
 908   virtual void  clone_jvms(Compile* C) {
 909     if (jvms() != NULL) {
 910       set_jvms(jvms()-&gt;clone_deep(C));
 911       jvms()-&gt;set_map_deep(this);
 912     }
 913   }
 914   virtual int Opcode() const;
 915   virtual uint ideal_reg() const { return Op_RegP; }
 916   virtual bool        guaranteed_safepoint()  { return false; }
 917 
 918   // allocations do not modify their arguments
 919   virtual bool        may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) { return false;}
 920 
 921   // Pattern-match a possible usage of AllocateNode.
 922   // Return null if no allocation is recognized.
 923   // The operand is the pointer produced by the (possible) allocation.
 924   // It must be a projection of the Allocate or its subsequent CastPP.
 925   // (Note:  This function is defined in file graphKit.cpp, near
 926   // GraphKit::new_instance/new_array, whose output it recognizes.)
 927   // The &#39;ptr&#39; may not have an offset unless the &#39;offset&#39; argument is given.
 928   static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase);
 929 
 930   // Fancy version which uses AddPNode::Ideal_base_and_offset to strip
 931   // an offset, which is reported back to the caller.
 932   // (Note:  AllocateNode::Ideal_allocation is defined in graphKit.cpp.)
 933   static AllocateNode* Ideal_allocation(Node* ptr, PhaseTransform* phase,
 934                                         intptr_t&amp; offset);
 935 
 936   // Dig the klass operand out of a (possible) allocation site.
 937   static Node* Ideal_klass(Node* ptr, PhaseTransform* phase) {
 938     AllocateNode* allo = Ideal_allocation(ptr, phase);
 939     return (allo == NULL) ? NULL : allo-&gt;in(KlassNode);
 940   }
 941 
 942   // Conservatively small estimate of offset of first non-header byte.
 943   int minimum_header_size() {
 944     return is_AllocateArray() ? arrayOopDesc::base_offset_in_bytes(T_BYTE) :
 945                                 instanceOopDesc::base_offset_in_bytes();
 946   }
 947 
 948   // Return the corresponding initialization barrier (or null if none).
 949   // Walks out edges to find it...
 950   // (Note: Both InitializeNode::allocation and AllocateNode::initialization
 951   // are defined in graphKit.cpp, which sets up the bidirectional relation.)
 952   InitializeNode* initialization();
 953 
 954   // Convenience for initialization-&gt;maybe_set_complete(phase)
 955   bool maybe_set_complete(PhaseGVN* phase);
 956 
 957   // Return true if allocation doesn&#39;t escape thread, its escape state
 958   // needs be noEscape or ArgEscape. InitializeNode._does_not_escape
 959   // is true when its allocation&#39;s escape state is noEscape or
 960   // ArgEscape. In case allocation&#39;s InitializeNode is NULL, check
 961   // AlllocateNode._is_non_escaping flag.
 962   // AlllocateNode._is_non_escaping is true when its escape state is
 963   // noEscape.
 964   bool does_not_escape_thread() {
 965     InitializeNode* init = NULL;
 966     return _is_non_escaping || (((init = initialization()) != NULL) &amp;&amp; init-&gt;does_not_escape());
 967   }
 968 
 969   // If object doesn&#39;t escape in &lt;.init&gt; method and there is memory barrier
 970   // inserted at exit of its &lt;.init&gt;, memory barrier for new is not necessary.
 971   // Inovke this method when MemBar at exit of initializer and post-dominate
 972   // allocation node.
 973   void compute_MemBar_redundancy(ciMethod* initializer);
 974   bool is_allocation_MemBar_redundant() { return _is_allocation_MemBar_redundant; }
 975 
 976   Node* make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem);
 977 };
 978 
 979 //------------------------------AllocateArray---------------------------------
 980 //
 981 // High-level array allocation
 982 //
 983 class AllocateArrayNode : public AllocateNode {
 984 public:
 985   AllocateArrayNode(Compile* C, const TypeFunc *atype, Node *ctrl, Node *mem, Node *abio,
 986                     Node* size, Node* klass_node, Node* initial_test,
 987                     Node* count_val
 988                     )
 989     : AllocateNode(C, atype, ctrl, mem, abio, size, klass_node,
 990                    initial_test)
 991   {
 992     init_class_id(Class_AllocateArray);
 993     set_req(AllocateNode::ALength,        count_val);
 994   }
 995   virtual int Opcode() const;
 996   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 997 
 998   // Dig the length operand out of a array allocation site.
 999   Node* Ideal_length() {
1000     return in(AllocateNode::ALength);
1001   }
1002 
1003   // Dig the length operand out of a array allocation site and narrow the
1004   // type with a CastII, if necesssary
1005   Node* make_ideal_length(const TypeOopPtr* ary_type, PhaseTransform *phase, bool can_create = true);
1006 
1007   // Pattern-match a possible usage of AllocateArrayNode.
1008   // Return null if no allocation is recognized.
1009   static AllocateArrayNode* Ideal_array_allocation(Node* ptr, PhaseTransform* phase) {
1010     AllocateNode* allo = Ideal_allocation(ptr, phase);
1011     return (allo == NULL || !allo-&gt;is_AllocateArray())
1012            ? NULL : allo-&gt;as_AllocateArray();
1013   }
1014 };
1015 
1016 //------------------------------AbstractLockNode-----------------------------------
1017 class AbstractLockNode: public CallNode {
1018 private:
1019   enum {
1020     Regular = 0,  // Normal lock
1021     NonEscObj,    // Lock is used for non escaping object
1022     Coarsened,    // Lock was coarsened
1023     Nested        // Nested lock
1024   } _kind;
1025 #ifndef PRODUCT
1026   NamedCounter* _counter;
1027   static const char* _kind_names[Nested+1];
1028 #endif
1029 
1030 protected:
1031   // helper functions for lock elimination
1032   //
1033 
1034   bool find_matching_unlock(const Node* ctrl, LockNode* lock,
1035                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1036   bool find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1037                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1038   bool find_unlocks_for_region(const RegionNode* region, LockNode* lock,
1039                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops);
1040   LockNode *find_matching_lock(UnlockNode* unlock);
1041 
1042   // Update the counter to indicate that this lock was eliminated.
1043   void set_eliminated_lock_counter() PRODUCT_RETURN;
1044 
1045 public:
1046   AbstractLockNode(const TypeFunc *tf)
1047     : CallNode(tf, NULL, TypeRawPtr::BOTTOM),
1048       _kind(Regular)
1049   {
1050 #ifndef PRODUCT
1051     _counter = NULL;
1052 #endif
1053   }
1054   virtual int Opcode() const = 0;
1055   Node *   obj_node() const       {return in(TypeFunc::Parms + 0); }
1056   Node *   box_node() const       {return in(TypeFunc::Parms + 1); }
1057   Node *   fastlock_node() const  {return in(TypeFunc::Parms + 2); }
1058   void     set_box_node(Node* box) { set_req(TypeFunc::Parms + 1, box); }
1059 
1060   const Type *sub(const Type *t1, const Type *t2) const { return TypeInt::CC;}
1061 
1062   virtual uint size_of() const { return sizeof(*this); }
1063 
1064   bool is_eliminated()  const { return (_kind != Regular); }
1065   bool is_non_esc_obj() const { return (_kind == NonEscObj); }
1066   bool is_coarsened()   const { return (_kind == Coarsened); }
1067   bool is_nested()      const { return (_kind == Nested); }
1068 
1069   const char * kind_as_string() const;
1070   void log_lock_optimization(Compile* c, const char * tag) const;
1071 
1072   void set_non_esc_obj() { _kind = NonEscObj; set_eliminated_lock_counter(); }
1073   void set_coarsened()   { _kind = Coarsened; set_eliminated_lock_counter(); }
1074   void set_nested()      { _kind = Nested; set_eliminated_lock_counter(); }
1075 
1076   // locking does not modify its arguments
1077   virtual bool may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase){ return false;}
1078 
1079 #ifndef PRODUCT
1080   void create_lock_counter(JVMState* s);
1081   NamedCounter* counter() const { return _counter; }
1082   virtual void dump_spec(outputStream* st) const;
1083   virtual void dump_compact_spec(outputStream* st) const;
1084   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
1085 #endif
1086 };
1087 
1088 //------------------------------Lock---------------------------------------
1089 // High-level lock operation
1090 //
1091 // This is a subclass of CallNode because it is a macro node which gets expanded
1092 // into a code sequence containing a call.  This node takes 3 &quot;parameters&quot;:
1093 //    0  -  object to lock
1094 //    1 -   a BoxLockNode
1095 //    2 -   a FastLockNode
1096 //
1097 class LockNode : public AbstractLockNode {
1098 public:
1099 
1100   static const TypeFunc *lock_type() {
1101     // create input type (domain)
1102     const Type **fields = TypeTuple::fields(3);
1103     fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
1104     fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;    // Address of stack location for lock
1105     fields[TypeFunc::Parms+2] = TypeInt::BOOL;         // FastLock
1106     const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3,fields);
1107 
1108     // create result type (range)
1109     fields = TypeTuple::fields(0);
1110 
1111     const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1112 
1113     return TypeFunc::make(domain,range);
1114   }
1115 
1116   virtual int Opcode() const;
1117   virtual uint size_of() const; // Size is bigger
1118   LockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf ) {
1119     init_class_id(Class_Lock);
1120     init_flags(Flag_is_macro);
1121     C-&gt;add_macro_node(this);
1122   }
1123   virtual bool        guaranteed_safepoint()  { return false; }
1124 
1125   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1126   // Expansion modifies the JVMState, so we need to clone it
1127   virtual void  clone_jvms(Compile* C) {
1128     if (jvms() != NULL) {
1129       set_jvms(jvms()-&gt;clone_deep(C));
1130       jvms()-&gt;set_map_deep(this);
1131     }
1132   }
1133 
1134   bool is_nested_lock_region(); // Is this Lock nested?
1135   bool is_nested_lock_region(Compile * c); // Why isn&#39;t this Lock nested?
1136 };
1137 
1138 //------------------------------Unlock---------------------------------------
1139 // High-level unlock operation
1140 class UnlockNode : public AbstractLockNode {
1141 private:
1142 #ifdef ASSERT
1143   JVMState* const _dbg_jvms;      // Pointer to list of JVM State objects
1144 #endif
1145 public:
1146   virtual int Opcode() const;
1147   virtual uint size_of() const; // Size is bigger
1148   UnlockNode(Compile* C, const TypeFunc *tf) : AbstractLockNode( tf )
1149 #ifdef ASSERT
1150     , _dbg_jvms(NULL)
1151 #endif
1152   {
1153     init_class_id(Class_Unlock);
1154     init_flags(Flag_is_macro);
1155     C-&gt;add_macro_node(this);
1156   }
1157   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
1158   // unlock is never a safepoint
1159   virtual bool        guaranteed_safepoint()  { return false; }
1160 #ifdef ASSERT
1161   void set_dbg_jvms(JVMState* s) {
1162     *(JVMState**)&amp;_dbg_jvms = s;  // override const attribute in the accessor
1163   }
1164   JVMState* dbg_jvms() const { return _dbg_jvms; }
1165 #else
1166   JVMState* dbg_jvms() const { return NULL; }
1167 #endif
1168 };
1169 #endif // SHARE_OPTO_CALLNODE_HPP
    </pre>
  </body>
</html>
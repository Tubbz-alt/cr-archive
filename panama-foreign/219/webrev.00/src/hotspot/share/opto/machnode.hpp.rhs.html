<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/machnode.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_MACHNODE_HPP
  26 #define SHARE_OPTO_MACHNODE_HPP
  27 
  28 #include &quot;opto/callnode.hpp&quot;
  29 #include &quot;opto/constantTable.hpp&quot;
  30 #include &quot;opto/matcher.hpp&quot;
  31 #include &quot;opto/multnode.hpp&quot;
  32 #include &quot;opto/node.hpp&quot;
  33 #include &quot;opto/regmask.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  34 #include &quot;utilities/growableArray.hpp&quot;</span>
  35 
  36 class BiasedLockingCounters;
  37 class BufferBlob;
  38 class CodeBuffer;
  39 class JVMState;
  40 class MachCallDynamicJavaNode;
  41 class MachCallJavaNode;
  42 class MachCallLeafNode;
<a name="2" id="anc2"></a><span class="line-added">  43 class MachCallNativeNode;</span>
  44 class MachCallNode;
  45 class MachCallRuntimeNode;
  46 class MachCallStaticJavaNode;
  47 class MachEpilogNode;
  48 class MachIfNode;
  49 class MachNullCheckNode;
  50 class MachOper;
  51 class MachProjNode;
  52 class MachPrologNode;
  53 class MachReturnNode;
  54 class MachSafePointNode;
  55 class MachSpillCopyNode;
  56 class Matcher;
  57 class PhaseRegAlloc;
  58 class RegMask;
  59 class RTMLockingCounters;
  60 class State;
  61 
  62 //---------------------------MachOper------------------------------------------
  63 class MachOper : public ResourceObj {
  64 public:
  65   // Allocate right next to the MachNodes in the same arena
  66   void *operator new(size_t x) throw() {
  67     Compile* C = Compile::current();
  68     return C-&gt;node_arena()-&gt;Amalloc_D(x);
  69   }
  70 
  71   // Opcode
  72   virtual uint opcode() const = 0;
  73 
  74   // Number of input edges.
  75   // Generally at least 1
  76   virtual uint num_edges() const { return 1; }
  77   // Array of Register masks
  78   virtual const RegMask *in_RegMask(int index) const;
  79 
  80   // Methods to output the encoding of the operand
  81 
  82   // Negate conditional branches.  Error for non-branch Nodes
  83   virtual void negate();
  84 
  85   // Return the value requested
  86   // result register lookup, corresponding to int_format
  87   virtual int  reg(PhaseRegAlloc *ra_, const Node *node)   const;
  88   // input register lookup, corresponding to ext_format
  89   virtual int  reg(PhaseRegAlloc *ra_, const Node *node, int idx)   const;
  90 
  91   // helpers for MacroAssembler generation from ADLC
  92   Register  as_Register(PhaseRegAlloc *ra_, const Node *node)   const {
  93     return ::as_Register(reg(ra_, node));
  94   }
  95   Register  as_Register(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
  96     return ::as_Register(reg(ra_, node, idx));
  97   }
  98   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node)   const {
  99     return ::as_FloatRegister(reg(ra_, node));
 100   }
 101   FloatRegister  as_FloatRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 102     return ::as_FloatRegister(reg(ra_, node, idx));
 103   }
 104 
 105 #if defined(IA32) || defined(AMD64)
 106   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node)   const {
 107     return ::as_XMMRegister(reg(ra_, node));
 108   }
 109   XMMRegister  as_XMMRegister(PhaseRegAlloc *ra_, const Node *node, int idx)   const {
 110     return ::as_XMMRegister(reg(ra_, node, idx));
 111   }
 112 #endif
 113   // CondRegister reg converter
 114 #if defined(PPC64)
 115   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node) const {
 116     return ::as_ConditionRegister(reg(ra_, node));
 117   }
 118   ConditionRegister as_ConditionRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 119     return ::as_ConditionRegister(reg(ra_, node, idx));
 120   }
 121   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node) const {
 122     return ::as_VectorRegister(reg(ra_, node));
 123   }
 124   VectorRegister as_VectorRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 125     return ::as_VectorRegister(reg(ra_, node, idx));
 126   }
 127   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node) const {
 128     return ::as_VectorSRegister(reg(ra_, node));
 129   }
 130   VectorSRegister as_VectorSRegister(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 131     return ::as_VectorSRegister(reg(ra_, node, idx));
 132   }
 133 #endif
 134 
 135   virtual intptr_t  constant() const;
 136   virtual relocInfo::relocType constant_reloc() const;
 137   virtual jdouble constantD() const;
 138   virtual jfloat  constantF() const;
 139   virtual jlong   constantL() const;
 140   virtual TypeOopPtr *oop() const;
 141   virtual int  ccode() const;
 142   // A zero, default, indicates this value is not needed.
 143   // May need to lookup the base register, as done in int_ and ext_format
 144   virtual int  base (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 145   virtual int  index(PhaseRegAlloc *ra_, const Node *node, int idx) const;
 146   virtual int  scale() const;
 147   // Parameters needed to support MEMORY_INTERFACE access to stackSlot
 148   virtual int  disp (PhaseRegAlloc *ra_, const Node *node, int idx) const;
 149   // Check for PC-Relative displacement
 150   virtual relocInfo::relocType disp_reloc() const;
 151   virtual int  constant_disp() const;   // usu. 0, may return Type::OffsetBot
 152   virtual int  base_position()  const;  // base edge position, or -1
 153   virtual int  index_position() const;  // index edge position, or -1
 154 
 155   // Access the TypeKlassPtr of operands with a base==RegI and disp==RegP
 156   // Only returns non-null value for i486.ad&#39;s indOffset32X
 157   virtual const TypePtr *disp_as_type() const { return NULL; }
 158 
 159   // Return the label
 160   virtual Label *label() const;
 161 
 162   // Return the method&#39;s address
 163   virtual intptr_t  method() const;
 164 
 165   // Hash and compare over operands are currently identical
 166   virtual uint  hash() const;
 167   virtual bool  cmp( const MachOper &amp;oper ) const;
 168 
 169   // Virtual clone, since I do not know how big the MachOper is.
 170   virtual MachOper *clone() const = 0;
 171 
 172   // Return ideal Type from simple operands.  Fail for complex operands.
 173   virtual const Type *type() const;
 174 
 175   // Set an integer offset if we have one, or error otherwise
 176   virtual void set_con( jint c0 ) { ShouldNotReachHere();  }
 177 
 178 #ifndef PRODUCT
 179   // Return name of operand
 180   virtual const char    *Name() const { return &quot;???&quot;;}
 181 
 182   // Methods to output the text version of the operand
 183   virtual void int_format(PhaseRegAlloc *,const MachNode *node, outputStream *st) const = 0;
 184   virtual void ext_format(PhaseRegAlloc *,const MachNode *node,int idx, outputStream *st) const=0;
 185 
 186   virtual void dump_spec(outputStream *st) const; // Print per-operand info
 187 
 188   // Check whether o is a valid oper.
 189   static bool notAnOper(const MachOper *o) {
 190     if (o == NULL)                   return true;
 191     if (((intptr_t)o &amp; 1) != 0)      return true;
 192     if (*(address*)o == badAddress)  return true;  // kill by Node::destruct
 193     return false;
 194   }
 195 #endif // !PRODUCT
 196 };
 197 
 198 //------------------------------MachNode---------------------------------------
 199 // Base type for all machine specific nodes.  All node classes generated by the
 200 // ADLC inherit from this class.
 201 class MachNode : public Node {
 202 public:
 203   MachNode() : Node((uint)0), _barrier(0), _num_opnds(0), _opnds(NULL) {
 204     init_class_id(Class_Mach);
 205   }
 206   // Required boilerplate
 207   virtual uint size_of() const { return sizeof(MachNode); }
 208   virtual int  Opcode() const;          // Always equal to MachNode
 209   virtual uint rule() const = 0;        // Machine-specific opcode
 210   // Number of inputs which come before the first operand.
 211   // Generally at least 1, to skip the Control input
 212   virtual uint oper_input_base() const { return 1; }
 213   // Position of constant base node in node&#39;s inputs. -1 if
 214   // no constant base node input.
 215   virtual uint mach_constant_base_node_input() const { return (uint)-1; }
 216 
 217   uint8_t barrier_data() const { return _barrier; }
 218   void set_barrier_data(uint data) { _barrier = data; }
 219 
 220   // Copy inputs and operands to new node of instruction.
 221   // Called from cisc_version() and short_branch_version().
 222   // !!!! The method&#39;s body is defined in ad_&lt;arch&gt;.cpp file.
 223   void fill_new_machnode(MachNode *n) const;
 224 
 225   // Return an equivalent instruction using memory for cisc_operand position
 226   virtual MachNode *cisc_version(int offset);
 227   // Modify this instruction&#39;s register mask to use stack version for cisc_operand
 228   virtual void use_cisc_RegMask();
 229 
 230   // Support for short branches
 231   bool may_be_short_branch() const { return (flags() &amp; Flag_may_be_short_branch) != 0; }
 232 
 233   // Avoid back to back some instructions on some CPUs.
 234   enum AvoidBackToBackFlag { AVOID_NONE = 0,
 235                              AVOID_BEFORE = Flag_avoid_back_to_back_before,
 236                              AVOID_AFTER = Flag_avoid_back_to_back_after,
 237                              AVOID_BEFORE_AND_AFTER = AVOID_BEFORE | AVOID_AFTER };
 238 
 239   bool avoid_back_to_back(AvoidBackToBackFlag flag_value) const {
 240     return (flags() &amp; flag_value) == flag_value;
 241   }
 242 
 243   // instruction implemented with a call
 244   bool has_call() const { return (flags() &amp; Flag_has_call) != 0; }
 245 
 246   // First index in _in[] corresponding to operand, or -1 if there is none
 247   int  operand_index(uint operand) const;
 248   int  operand_index(const MachOper *oper) const;
 249   int  operand_index(Node* m) const;
 250 
 251   // Register class input is expected in
 252   virtual const RegMask &amp;in_RegMask(uint) const;
 253 
 254   // cisc-spillable instructions redefine for use by in_RegMask
 255   virtual const RegMask *cisc_RegMask() const { return NULL; }
 256 
 257   // If this instruction is a 2-address instruction, then return the
 258   // index of the input which must match the output.  Not nessecary
 259   // for instructions which bind the input and output register to the
 260   // same singleton regiser (e.g., Intel IDIV which binds AX to be
 261   // both an input and an output).  It is nessecary when the input and
 262   // output have choices - but they must use the same choice.
 263   virtual uint two_adr( ) const { return 0; }
 264 
 265   // The GC might require some barrier metadata for machine code emission.
 266   uint8_t _barrier;
 267 
 268   // Array of complex operand pointers.  Each corresponds to zero or
 269   // more leafs.  Must be set by MachNode constructor to point to an
 270   // internal array of MachOpers.  The MachOper array is sized by
 271   // specific MachNodes described in the ADL.
 272   uint _num_opnds;
 273   MachOper **_opnds;
 274   uint  num_opnds() const { return _num_opnds; }
 275 
 276   // Emit bytes into cbuf
 277   virtual void  emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 278   // Expand node after register allocation.
 279   // Node is replaced by several nodes in the postalloc expand phase.
 280   // Corresponding methods are generated for nodes if they specify
 281   // postalloc_expand. See block.cpp for more documentation.
 282   virtual bool requires_postalloc_expand() const { return false; }
 283   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 284   // Size of instruction in bytes
 285   virtual uint  size(PhaseRegAlloc *ra_) const;
 286   // Helper function that computes size by emitting code
 287   virtual uint  emit_size(PhaseRegAlloc *ra_) const;
 288 
 289   // Return the alignment required (in units of relocInfo::addr_unit())
 290   // for this instruction (must be a power of 2)
 291   int           pd_alignment_required() const;
 292   virtual int   alignment_required() const { return pd_alignment_required(); }
 293 
 294   // Return the padding (in bytes) to be emitted before this
 295   // instruction to properly align it.
 296   virtual int   compute_padding(int current_offset) const;
 297 
 298   // Return number of relocatable values contained in this instruction
 299   virtual int   reloc() const { return 0; }
 300 
 301   // Return number of words used for double constants in this instruction
 302   virtual int   ins_num_consts() const { return 0; }
 303 
 304   // Hash and compare over operands.  Used to do GVN on machine Nodes.
 305   virtual uint  hash() const;
 306   virtual bool  cmp( const Node &amp;n ) const;
 307 
 308   // Expand method for MachNode, replaces nodes representing pseudo
 309   // instructions with a set of nodes which represent real machine
 310   // instructions and compute the same value.
 311   virtual MachNode *Expand( State *, Node_List &amp;proj_list, Node* mem ) { return this; }
 312 
 313   // Bottom_type call; value comes from operand0
 314   virtual const class Type *bottom_type() const { return _opnds[0]-&gt;type(); }
 315   virtual uint ideal_reg() const {
 316     const Type *t = _opnds[0]-&gt;type();
 317     if (t == TypeInt::CC) {
 318       return Op_RegFlags;
 319     } else {
 320       return t-&gt;ideal_reg();
 321     }
 322   }
 323 
 324   // If this is a memory op, return the base pointer and fixed offset.
 325   // If there are no such, return NULL.  If there are multiple addresses
 326   // or the address is indeterminate (rare cases) then return (Node*)-1,
 327   // which serves as node bottom.
 328   // If the offset is not statically determined, set it to Type::OffsetBot.
 329   // This method is free to ignore stack slots if that helps.
 330   #define TYPE_PTR_SENTINAL  ((const TypePtr*)-1)
 331   // Passing TYPE_PTR_SENTINAL as adr_type asks for computation of the adr_type if possible
 332   const Node* get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const;
 333 
 334   // Helper for get_base_and_disp: find the base and index input nodes.
 335   // Returns the MachOper as determined by memory_operand(), for use, if
 336   // needed by the caller. If (MachOper *)-1 is returned, base and index
 337   // are set to NodeSentinel. If (MachOper *) NULL is returned, base and
 338   // index are set to NULL.
 339   const MachOper* memory_inputs(Node* &amp;base, Node* &amp;index) const;
 340 
 341   // Helper for memory_inputs:  Which operand carries the necessary info?
 342   // By default, returns NULL, which means there is no such operand.
 343   // If it returns (MachOper*)-1, this means there are multiple memories.
 344   virtual const MachOper* memory_operand() const { return NULL; }
 345 
 346   // Call &quot;get_base_and_disp&quot; to decide which category of memory is used here.
 347   virtual const class TypePtr *adr_type() const;
 348 
 349   // Apply peephole rule(s) to this instruction
 350   virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted);
 351 
 352   // Top-level ideal Opcode matched
 353   virtual int ideal_Opcode()     const { return Op_Node; }
 354 
 355   // Adds the label for the case
 356   virtual void add_case_label( int switch_val, Label* blockLabel);
 357 
 358   // Set the absolute address for methods
 359   virtual void method_set( intptr_t addr );
 360 
 361   // Should we clone rather than spill this instruction?
 362   bool rematerialize() const;
 363 
 364   // Get the pipeline info
 365   static const Pipeline *pipeline_class();
 366   virtual const Pipeline *pipeline() const;
 367 
 368   // Returns true if this node is a check that can be implemented with a trap.
 369   virtual bool is_TrapBasedCheckNode() const { return false; }
 370 
 371 #ifndef PRODUCT
 372   virtual const char *Name() const = 0; // Machine-specific name
 373   virtual void dump_spec(outputStream *st) const; // Print per-node info
 374   void         dump_format(PhaseRegAlloc *ra, outputStream *st) const; // access to virtual
 375 #endif
 376 };
 377 
 378 //------------------------------MachIdealNode----------------------------
 379 // Machine specific versions of nodes that must be defined by user.
 380 // These are not converted by matcher from ideal nodes to machine nodes
 381 // but are inserted into the code by the compiler.
 382 class MachIdealNode : public MachNode {
 383 public:
 384   MachIdealNode( ) {}
 385 
 386   // Define the following defaults for non-matched machine nodes
 387   virtual uint oper_input_base() const { return 0; }
 388   virtual uint rule()            const { return 9999999; }
 389   virtual const class Type *bottom_type() const { return _opnds == NULL ? Type::CONTROL : MachNode::bottom_type(); }
 390 };
 391 
 392 //------------------------------MachTypeNode----------------------------
 393 // Machine Nodes that need to retain a known Type.
 394 class MachTypeNode : public MachNode {
 395   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 396 public:
 397   MachTypeNode( ) {}
 398   const Type *_bottom_type;
 399 
 400   virtual const class Type *bottom_type() const { return _bottom_type; }
 401 #ifndef PRODUCT
 402   virtual void dump_spec(outputStream *st) const;
 403 #endif
 404 };
 405 
 406 //------------------------------MachBreakpointNode----------------------------
 407 // Machine breakpoint or interrupt Node
 408 class MachBreakpointNode : public MachIdealNode {
 409 public:
 410   MachBreakpointNode( ) {}
 411   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 412   virtual uint size(PhaseRegAlloc *ra_) const;
 413 
 414 #ifndef PRODUCT
 415   virtual const char *Name() const { return &quot;Breakpoint&quot;; }
 416   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 417 #endif
 418 };
 419 
 420 //------------------------------MachConstantBaseNode--------------------------
 421 // Machine node that represents the base address of the constant table.
 422 class MachConstantBaseNode : public MachIdealNode {
 423 public:
 424   static const RegMask&amp; _out_RegMask;  // We need the out_RegMask statically in MachConstantNode::in_RegMask().
 425 
 426 public:
 427   MachConstantBaseNode() : MachIdealNode() {
 428     init_class_id(Class_MachConstantBase);
 429   }
 430   virtual const class Type* bottom_type() const { return TypeRawPtr::NOTNULL; }
 431   virtual uint ideal_reg() const { return Op_RegP; }
 432   virtual uint oper_input_base() const { return 1; }
 433 
 434   virtual bool requires_postalloc_expand() const;
 435   virtual void postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_);
 436 
 437   virtual void emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const;
 438   virtual uint size(PhaseRegAlloc* ra_) const;
 439   virtual bool pinned() const { return UseRDPCForConstantTableBase; }
 440 
 441   static const RegMask&amp; static_out_RegMask() { return _out_RegMask; }
 442   virtual const RegMask&amp; out_RegMask() const { return static_out_RegMask(); }
 443 
 444 #ifndef PRODUCT
 445   virtual const char* Name() const { return &quot;MachConstantBaseNode&quot;; }
 446   virtual void format(PhaseRegAlloc*, outputStream* st) const;
 447 #endif
 448 };
 449 
 450 //------------------------------MachConstantNode-------------------------------
 451 // Machine node that holds a constant which is stored in the constant table.
 452 class MachConstantNode : public MachTypeNode {
 453 protected:
 454   ConstantTable::Constant _constant;  // This node&#39;s constant.
 455 
 456 public:
 457   MachConstantNode() : MachTypeNode() {
 458     init_class_id(Class_MachConstant);
 459   }
 460 
 461   virtual void eval_constant(Compile* C) {
 462 #ifdef ASSERT
 463     tty-&gt;print(&quot;missing MachConstantNode eval_constant function: &quot;);
 464     dump();
 465 #endif
 466     ShouldNotCallThis();
 467   }
 468 
 469   virtual const RegMask &amp;in_RegMask(uint idx) const {
 470     if (idx == mach_constant_base_node_input())
 471       return MachConstantBaseNode::static_out_RegMask();
 472     return MachNode::in_RegMask(idx);
 473   }
 474 
 475   // Input edge of MachConstantBaseNode.
 476   virtual uint mach_constant_base_node_input() const { return req() - 1; }
 477 
 478   int  constant_offset();
 479   int  constant_offset() const { return ((MachConstantNode*) this)-&gt;constant_offset(); }
 480   // Unchecked version to avoid assertions in debug output.
 481   int  constant_offset_unchecked() const;
 482 };
 483 
 484 //------------------------------MachUEPNode-----------------------------------
 485 // Machine Unvalidated Entry Point Node
 486 class MachUEPNode : public MachIdealNode {
 487 public:
 488   MachUEPNode( ) {}
 489   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 490   virtual uint size(PhaseRegAlloc *ra_) const;
 491 
 492 #ifndef PRODUCT
 493   virtual const char *Name() const { return &quot;Unvalidated-Entry-Point&quot;; }
 494   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 495 #endif
 496 };
 497 
 498 //------------------------------MachPrologNode--------------------------------
 499 // Machine function Prolog Node
 500 class MachPrologNode : public MachIdealNode {
 501 public:
 502   MachPrologNode( ) {}
 503   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 504   virtual uint size(PhaseRegAlloc *ra_) const;
 505   virtual int reloc() const;
 506 
 507 #ifndef PRODUCT
 508   virtual const char *Name() const { return &quot;Prolog&quot;; }
 509   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 510 #endif
 511 };
 512 
 513 //------------------------------MachEpilogNode--------------------------------
 514 // Machine function Epilog Node
 515 class MachEpilogNode : public MachIdealNode {
 516 public:
 517   MachEpilogNode(bool do_poll = false) : _do_polling(do_poll) {}
 518   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 519   virtual uint size(PhaseRegAlloc *ra_) const;
 520   virtual int reloc() const;
 521   virtual const Pipeline *pipeline() const;
 522 
 523 private:
 524   bool _do_polling;
 525 
 526 public:
 527   bool do_polling() const { return _do_polling; }
 528 
 529 #ifndef PRODUCT
 530   virtual const char *Name() const { return &quot;Epilog&quot;; }
 531   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 532 #endif
 533 };
 534 
 535 //------------------------------MachNopNode-----------------------------------
 536 // Machine function Nop Node
 537 class MachNopNode : public MachIdealNode {
 538 private:
 539   int _count;
 540 public:
 541   MachNopNode( ) : _count(1) {}
 542   MachNopNode( int count ) : _count(count) {}
 543   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 544   virtual uint size(PhaseRegAlloc *ra_) const;
 545 
 546   virtual const class Type *bottom_type() const { return Type::CONTROL; }
 547 
 548   virtual int ideal_Opcode() const { return Op_Con; } // bogus; see output.cpp
 549   virtual const Pipeline *pipeline() const;
 550 #ifndef PRODUCT
 551   virtual const char *Name() const { return &quot;Nop&quot;; }
 552   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 553   virtual void dump_spec(outputStream *st) const { } // No per-operand info
 554 #endif
 555 };
 556 
 557 //------------------------------MachSpillCopyNode------------------------------
 558 // Machine SpillCopy Node.  Copies 1 or 2 words from any location to any
 559 // location (stack or register).
 560 class MachSpillCopyNode : public MachIdealNode {
 561 public:
 562   enum SpillType {
 563     TwoAddress,                        // Inserted when coalescing of a two-address-instruction node and its input fails
 564     PhiInput,                          // Inserted when coalescing of a phi node and its input fails
 565     DebugUse,                          // Inserted as debug info spills to safepoints in non-frequent blocks
 566     LoopPhiInput,                      // Pre-split compares of loop-phis
 567     Definition,                        // An lrg marked as spilled will be spilled to memory right after its definition,
 568                                        // if in high pressure region or the lrg is bound
 569     RegToReg,                          // A register to register move
 570     RegToMem,                          // A register to memory move
 571     MemToReg,                          // A memory to register move
 572     PhiLocationDifferToInputLocation,  // When coalescing phi nodes in PhaseChaitin::Split(), a move spill is inserted if
 573                                        // the phi and its input resides at different locations (i.e. reg or mem)
 574     BasePointerToMem,                  // Spill base pointer to memory at safepoint
 575     InputToRematerialization,          // When rematerializing a node we stretch the inputs live ranges, and they might be
 576                                        // stretched beyond a new definition point, therefore we split out new copies instead
 577     CallUse,                           // Spill use at a call
 578     Bound                              // An lrg marked as spill that is bound and needs to be spilled at a use
 579   };
 580 private:
 581   const RegMask *_in;           // RegMask for input
 582   const RegMask *_out;          // RegMask for output
 583   const Type *_type;
 584   const SpillType _spill_type;
 585 public:
 586   MachSpillCopyNode(SpillType spill_type, Node *n, const RegMask &amp;in, const RegMask &amp;out ) :
 587     MachIdealNode(), _in(&amp;in), _out(&amp;out), _type(n-&gt;bottom_type()), _spill_type(spill_type) {
 588     init_class_id(Class_MachSpillCopy);
 589     init_flags(Flag_is_Copy);
 590     add_req(NULL);
 591     add_req(n);
 592   }
 593   virtual uint size_of() const { return sizeof(*this); }
 594   void set_out_RegMask(const RegMask &amp;out) { _out = &amp;out; }
 595   void set_in_RegMask(const RegMask &amp;in) { _in = &amp;in; }
 596   virtual const RegMask &amp;out_RegMask() const { return *_out; }
 597   virtual const RegMask &amp;in_RegMask(uint) const { return *_in; }
 598   virtual const class Type *bottom_type() const { return _type; }
 599   virtual uint ideal_reg() const { return _type-&gt;ideal_reg(); }
 600   virtual uint oper_input_base() const { return 1; }
 601   uint implementation( CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream* st ) const;
 602 
 603   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 604   virtual uint size(PhaseRegAlloc *ra_) const;
 605 
 606 
 607 #ifndef PRODUCT
 608   static const char *spill_type(SpillType st) {
 609     switch (st) {
 610       case TwoAddress:
 611         return &quot;TwoAddressSpillCopy&quot;;
 612       case PhiInput:
 613         return &quot;PhiInputSpillCopy&quot;;
 614       case DebugUse:
 615         return &quot;DebugUseSpillCopy&quot;;
 616       case LoopPhiInput:
 617         return &quot;LoopPhiInputSpillCopy&quot;;
 618       case Definition:
 619         return &quot;DefinitionSpillCopy&quot;;
 620       case RegToReg:
 621         return &quot;RegToRegSpillCopy&quot;;
 622       case RegToMem:
 623         return &quot;RegToMemSpillCopy&quot;;
 624       case MemToReg:
 625         return &quot;MemToRegSpillCopy&quot;;
 626       case PhiLocationDifferToInputLocation:
 627         return &quot;PhiLocationDifferToInputLocationSpillCopy&quot;;
 628       case BasePointerToMem:
 629         return &quot;BasePointerToMemSpillCopy&quot;;
 630       case InputToRematerialization:
 631         return &quot;InputToRematerializationSpillCopy&quot;;
 632       case CallUse:
 633         return &quot;CallUseSpillCopy&quot;;
 634       case Bound:
 635         return &quot;BoundSpillCopy&quot;;
 636       default:
 637         assert(false, &quot;Must have valid spill type&quot;);
 638         return &quot;MachSpillCopy&quot;;
 639     }
 640   }
 641 
 642   virtual const char *Name() const {
 643     return spill_type(_spill_type);
 644   }
 645 
 646   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 647 #endif
 648 };
 649 
 650 // MachMergeNode is similar to a PhiNode in a sense it merges multiple values,
 651 // however it doesn&#39;t have a control input and is more like a MergeMem.
 652 // It is inserted after the register allocation is done to ensure that nodes use single
 653 // definition of a multidef lrg in a block.
 654 class MachMergeNode : public MachIdealNode {
 655 public:
 656   MachMergeNode(Node *n1) {
 657     init_class_id(Class_MachMerge);
 658     add_req(NULL);
 659     add_req(n1);
 660   }
 661   virtual const RegMask &amp;out_RegMask() const { return in(1)-&gt;out_RegMask(); }
 662   virtual const RegMask &amp;in_RegMask(uint idx) const { return in(1)-&gt;in_RegMask(idx); }
 663   virtual const class Type *bottom_type() const { return in(1)-&gt;bottom_type(); }
 664   virtual uint ideal_reg() const { return bottom_type()-&gt;ideal_reg(); }
 665   virtual uint oper_input_base() const { return 1; }
 666   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const { }
 667   virtual uint size(PhaseRegAlloc *ra_) const { return 0; }
 668 #ifndef PRODUCT
 669   virtual const char *Name() const { return &quot;MachMerge&quot;; }
 670 #endif
 671 };
 672 
 673 //------------------------------MachBranchNode--------------------------------
 674 // Abstract machine branch Node
 675 class MachBranchNode : public MachIdealNode {
 676 public:
 677   MachBranchNode() : MachIdealNode() {
 678     init_class_id(Class_MachBranch);
 679   }
 680   virtual void label_set(Label* label, uint block_num) = 0;
 681   virtual void save_label(Label** label, uint* block_num) = 0;
 682 
 683   // Support for short branches
 684   virtual MachNode *short_branch_version() { return NULL; }
 685 
 686   virtual bool pinned() const { return true; };
 687 };
 688 
 689 //------------------------------MachNullChkNode--------------------------------
 690 // Machine-dependent null-pointer-check Node.  Points a real MachNode that is
 691 // also some kind of memory op.  Turns the indicated MachNode into a
 692 // conditional branch with good latency on the ptr-not-null path and awful
 693 // latency on the pointer-is-null path.
 694 
 695 class MachNullCheckNode : public MachBranchNode {
 696 public:
 697   const uint _vidx;             // Index of memop being tested
 698   MachNullCheckNode( Node *ctrl, Node *memop, uint vidx ) : MachBranchNode(), _vidx(vidx) {
 699     init_class_id(Class_MachNullCheck);
 700     add_req(ctrl);
 701     add_req(memop);
 702   }
 703   virtual uint size_of() const { return sizeof(*this); }
 704 
 705   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
 706   virtual void label_set(Label* label, uint block_num);
 707   virtual void save_label(Label** label, uint* block_num);
 708   virtual void negate() { }
 709   virtual const class Type *bottom_type() const { return TypeTuple::IFBOTH; }
 710   virtual uint ideal_reg() const { return NotAMachineReg; }
 711   virtual const RegMask &amp;in_RegMask(uint) const;
 712   virtual const RegMask &amp;out_RegMask() const { return RegMask::Empty; }
 713 #ifndef PRODUCT
 714   virtual const char *Name() const { return &quot;NullCheck&quot;; }
 715   virtual void format( PhaseRegAlloc *, outputStream *st ) const;
 716 #endif
 717 };
 718 
 719 //------------------------------MachProjNode----------------------------------
 720 // Machine-dependent Ideal projections (how is that for an oxymoron).  Really
 721 // just MachNodes made by the Ideal world that replicate simple projections
 722 // but with machine-dependent input &amp; output register masks.  Generally
 723 // produced as part of calling conventions.  Normally I make MachNodes as part
 724 // of the Matcher process, but the Matcher is ill suited to issues involving
 725 // frame handling, so frame handling is all done in the Ideal world with
 726 // occasional callbacks to the machine model for important info.
 727 class MachProjNode : public ProjNode {
 728 public:
 729   MachProjNode( Node *multi, uint con, const RegMask &amp;out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {
 730     init_class_id(Class_MachProj);
 731   }
 732   RegMask _rout;
 733   const uint  _ideal_reg;
 734   enum projType {
 735     unmatched_proj = 0,         // Projs for Control, I/O, memory not matched
 736     fat_proj       = 999        // Projs killing many regs, defined by _rout
 737   };
 738   virtual int   Opcode() const;
 739   virtual const Type *bottom_type() const;
 740   virtual const TypePtr *adr_type() const;
 741   virtual const RegMask &amp;in_RegMask(uint) const { return RegMask::Empty; }
 742   virtual const RegMask &amp;out_RegMask() const { return _rout; }
 743   virtual uint  ideal_reg() const { return _ideal_reg; }
 744   // Need size_of() for virtual ProjNode::clone()
 745   virtual uint  size_of() const { return sizeof(MachProjNode); }
 746 #ifndef PRODUCT
 747   virtual void dump_spec(outputStream *st) const;
 748 #endif
 749 };
 750 
 751 //------------------------------MachIfNode-------------------------------------
 752 // Machine-specific versions of IfNodes
 753 class MachIfNode : public MachBranchNode {
 754   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 755 public:
 756   float _prob;                  // Probability branch goes either way
 757   float _fcnt;                  // Frequency counter
 758   MachIfNode() : MachBranchNode() {
 759     init_class_id(Class_MachIf);
 760   }
 761   // Negate conditional branches.
 762   virtual void negate() = 0;
 763 #ifndef PRODUCT
 764   virtual void dump_spec(outputStream *st) const;
 765 #endif
 766 };
 767 
 768 //------------------------------MachJumpNode-----------------------------------
 769 // Machine-specific versions of JumpNodes
 770 class MachJumpNode : public MachConstantNode {
 771 public:
 772   float* _probs;
 773   MachJumpNode() : MachConstantNode() {
 774     init_class_id(Class_MachJump);
 775   }
 776 };
 777 
 778 //------------------------------MachGotoNode-----------------------------------
 779 // Machine-specific versions of GotoNodes
 780 class MachGotoNode : public MachBranchNode {
 781 public:
 782   MachGotoNode() : MachBranchNode() {
 783     init_class_id(Class_MachGoto);
 784   }
 785 };
 786 
 787 //------------------------------MachFastLockNode-------------------------------------
 788 // Machine-specific versions of FastLockNodes
 789 class MachFastLockNode : public MachNode {
 790   virtual uint size_of() const { return sizeof(*this); } // Size is bigger
 791 public:
 792   BiasedLockingCounters*        _counters;
 793   RTMLockingCounters*       _rtm_counters; // RTM lock counters for inflated locks
 794   RTMLockingCounters* _stack_rtm_counters; // RTM lock counters for stack locks
 795   MachFastLockNode() : MachNode() {}
 796 };
 797 
 798 //------------------------------MachReturnNode--------------------------------
 799 // Machine-specific versions of subroutine returns
 800 class MachReturnNode : public MachNode {
 801   virtual uint size_of() const; // Size is bigger
 802 public:
 803   RegMask *_in_rms;             // Input register masks, set during allocation
 804   ReallocMark _nesting;         // assertion check for reallocations
 805   const TypePtr* _adr_type;     // memory effects of call or return
 806   MachReturnNode() : MachNode() {
 807     init_class_id(Class_MachReturn);
 808     _adr_type = TypePtr::BOTTOM; // the default: all of memory
 809   }
 810 
 811   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
 812 
 813   virtual const RegMask &amp;in_RegMask(uint) const;
 814   virtual bool pinned() const { return true; };
 815   virtual const TypePtr *adr_type() const;
 816 };
 817 
 818 //------------------------------MachSafePointNode-----------------------------
 819 // Machine-specific versions of safepoints
 820 class MachSafePointNode : public MachReturnNode {
 821 public:
 822   OopMap*         _oop_map;     // Array of OopMap info (8-bit char) for GC
 823   JVMState*       _jvms;        // Pointer to list of JVM State Objects
 824   uint            _jvmadj;      // Extra delta to jvms indexes (mach. args)
 825   OopMap*         oop_map() const { return _oop_map; }
 826   void            set_oop_map(OopMap* om) { _oop_map = om; }
 827 
 828   MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0) {
 829     init_class_id(Class_MachSafePoint);
 830   }
 831 
 832   virtual JVMState* jvms() const { return _jvms; }
 833   void set_jvms(JVMState* s) {
 834     _jvms = s;
 835   }
 836   virtual const Type    *bottom_type() const;
 837 
 838   virtual const RegMask &amp;in_RegMask(uint) const;
 839 
 840   // Functionality from old debug nodes
 841   Node *returnadr() const { return in(TypeFunc::ReturnAdr); }
 842   Node *frameptr () const { return in(TypeFunc::FramePtr); }
 843 
 844   Node *local(const JVMState* jvms, uint idx) const {
 845     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 846     return in(_jvmadj + jvms-&gt;locoff() + idx);
 847   }
 848   Node *stack(const JVMState* jvms, uint idx) const {
 849     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 850     return in(_jvmadj + jvms-&gt;stkoff() + idx);
 851  }
 852   Node *monitor_obj(const JVMState* jvms, uint idx) const {
 853     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 854     return in(_jvmadj + jvms-&gt;monitor_obj_offset(idx));
 855   }
 856   Node *monitor_box(const JVMState* jvms, uint idx) const {
 857     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 858     return in(_jvmadj + jvms-&gt;monitor_box_offset(idx));
 859   }
 860   void  set_local(const JVMState* jvms, uint idx, Node *c) {
 861     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 862     set_req(_jvmadj + jvms-&gt;locoff() + idx, c);
 863   }
 864   void  set_stack(const JVMState* jvms, uint idx, Node *c) {
 865     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 866     set_req(_jvmadj + jvms-&gt;stkoff() + idx, c);
 867   }
 868   void  set_monitor(const JVMState* jvms, uint idx, Node *c) {
 869     assert(verify_jvms(jvms), &quot;jvms must match&quot;);
 870     set_req(_jvmadj + jvms-&gt;monoff() + idx, c);
 871   }
 872 };
 873 
 874 //------------------------------MachCallNode----------------------------------
 875 // Machine-specific versions of subroutine calls
 876 class MachCallNode : public MachSafePointNode {
 877 protected:
 878   virtual uint hash() const { return NO_HASH; }  // CFG nodes do not hash
 879   virtual bool cmp( const Node &amp;n ) const;
 880   virtual uint size_of() const = 0; // Size is bigger
 881 public:
 882   const TypeFunc *_tf;        // Function type
 883   address      _entry_point;  // Address of the method being called
 884   float        _cnt;          // Estimate of number of times called
 885   uint         _argsize;      // Size of argument block on stack
<a name="3" id="anc3"></a><span class="line-added"> 886   bool         _guaranteed_safepoint; // Do we need to observe safepoint?</span>
 887 
 888   const TypeFunc* tf()        const { return _tf; }
 889   const address entry_point() const { return _entry_point; }
 890   const float   cnt()         const { return _cnt; }
 891   uint argsize()              const { return _argsize; }
 892 
<a name="4" id="anc4"></a><span class="line-modified"> 893   void set_tf(const TypeFunc* tf)       { _tf = tf; }</span>
<span class="line-modified"> 894   void set_entry_point(address p)       { _entry_point = p; }</span>
<span class="line-modified"> 895   void set_cnt(float c)                 { _cnt = c; }</span>
<span class="line-modified"> 896   void set_argsize(int s)               { _argsize = s; }</span>
<span class="line-added"> 897   void set_guaranteed_safepoint(bool b) { _guaranteed_safepoint = b; }</span>
 898 
 899   MachCallNode() : MachSafePointNode() {
 900     init_class_id(Class_MachCall);
 901   }
 902 
 903   virtual const Type *bottom_type() const;
 904   virtual bool  pinned() const { return false; }
 905   virtual const Type* Value(PhaseGVN* phase) const;
 906   virtual const RegMask &amp;in_RegMask(uint) const;
 907   virtual int ret_addr_offset() { return 0; }
 908 
 909   bool returns_long() const { return tf()-&gt;return_type() == T_LONG; }
 910   bool return_value_is_used() const;
 911 
 912   // Similar to cousin class CallNode::returns_pointer
 913   bool returns_pointer() const;
 914 
<a name="5" id="anc5"></a><span class="line-added"> 915   bool guaranteed_safepoint() const { return _guaranteed_safepoint; }</span>
<span class="line-added"> 916 </span>
 917 #ifndef PRODUCT
 918   virtual void dump_spec(outputStream *st) const;
 919 #endif
 920 };
 921 
 922 //------------------------------MachCallJavaNode------------------------------
 923 // &quot;Base&quot; class for machine-specific versions of subroutine calls
 924 class MachCallJavaNode : public MachCallNode {
 925 protected:
 926   virtual bool cmp( const Node &amp;n ) const;
 927   virtual uint size_of() const; // Size is bigger
 928 public:
 929   ciMethod* _method;                 // Method being direct called
 930   bool      _override_symbolic_info; // Override symbolic call site info from bytecode
 931   int       _bci;                    // Byte Code index of call byte code
 932   bool      _optimized_virtual;      // Tells if node is a static call or an optimized virtual
 933   bool      _method_handle_invoke;   // Tells if the call has to preserve SP
 934   MachCallJavaNode() : MachCallNode(), _override_symbolic_info(false) {
 935     init_class_id(Class_MachCallJava);
 936   }
 937 
 938   virtual const RegMask &amp;in_RegMask(uint) const;
 939 
 940   int resolved_method_index(CodeBuffer &amp;cbuf) const {
 941     if (_override_symbolic_info) {
 942       // Attach corresponding Method* to the call site, so VM can use it during resolution
 943       // instead of querying symbolic info from bytecode.
 944       assert(_method != NULL, &quot;method should be set&quot;);
 945       assert(_method-&gt;constant_encoding()-&gt;is_method(), &quot;should point to a Method&quot;);
 946       return cbuf.oop_recorder()-&gt;find_index(_method-&gt;constant_encoding());
 947     }
 948     return 0; // Use symbolic info from bytecode (resolved_method == NULL).
 949   }
 950 
 951 #ifndef PRODUCT
 952   virtual void dump_spec(outputStream *st) const;
 953 #endif
 954 };
 955 
 956 //------------------------------MachCallStaticJavaNode------------------------
 957 // Machine-specific versions of monomorphic subroutine calls
 958 class MachCallStaticJavaNode : public MachCallJavaNode {
 959   virtual bool cmp( const Node &amp;n ) const;
 960   virtual uint size_of() const; // Size is bigger
 961 public:
 962   const char *_name;            // Runtime wrapper name
 963   MachCallStaticJavaNode() : MachCallJavaNode() {
 964     init_class_id(Class_MachCallStaticJava);
 965   }
 966 
 967   // If this is an uncommon trap, return the request code, else zero.
 968   int uncommon_trap_request() const;
 969 
 970   virtual int ret_addr_offset();
 971 #ifndef PRODUCT
 972   virtual void dump_spec(outputStream *st) const;
 973   void dump_trap_args(outputStream *st) const;
 974 #endif
 975 };
 976 
 977 //------------------------------MachCallDynamicJavaNode------------------------
 978 // Machine-specific versions of possibly megamorphic subroutine calls
 979 class MachCallDynamicJavaNode : public MachCallJavaNode {
 980 public:
 981   int _vtable_index;
 982   MachCallDynamicJavaNode() : MachCallJavaNode() {
 983     init_class_id(Class_MachCallDynamicJava);
 984     DEBUG_ONLY(_vtable_index = -99);  // throw an assert if uninitialized
 985   }
 986   virtual int ret_addr_offset();
 987 #ifndef PRODUCT
 988   virtual void dump_spec(outputStream *st) const;
 989 #endif
 990 };
 991 
 992 //------------------------------MachCallRuntimeNode----------------------------
 993 // Machine-specific versions of subroutine calls
 994 class MachCallRuntimeNode : public MachCallNode {
 995   virtual bool cmp( const Node &amp;n ) const;
 996   virtual uint size_of() const; // Size is bigger
 997 public:
 998   const char *_name;            // Printable name, if _method is NULL
 999   MachCallRuntimeNode() : MachCallNode() {
1000     init_class_id(Class_MachCallRuntime);
1001   }
1002   virtual int ret_addr_offset();
1003 #ifndef PRODUCT
1004   virtual void dump_spec(outputStream *st) const;
1005 #endif
1006 };
1007 
1008 class MachCallLeafNode: public MachCallRuntimeNode {
1009 public:
1010   MachCallLeafNode() : MachCallRuntimeNode() {
1011     init_class_id(Class_MachCallLeaf);
1012   }
1013 };
1014 
<a name="6" id="anc6"></a><span class="line-added">1015 class MachCallNativeNode: public MachCallNode {</span>
<span class="line-added">1016   virtual bool cmp( const Node &amp;n ) const;</span>
<span class="line-added">1017   virtual uint size_of() const;</span>
<span class="line-added">1018 public:</span>
<span class="line-added">1019   const char *_name;</span>
<span class="line-added">1020   GrowableArray&lt;VMReg&gt; _arg_regs;</span>
<span class="line-added">1021   GrowableArray&lt;VMReg&gt; _ret_regs;</span>
<span class="line-added">1022 </span>
<span class="line-added">1023   MachCallNativeNode() : MachCallNode() {</span>
<span class="line-added">1024     init_class_id(Class_MachCallNative);</span>
<span class="line-added">1025   }</span>
<span class="line-added">1026 </span>
<span class="line-added">1027   virtual int ret_addr_offset();</span>
<span class="line-added">1028 #ifndef PRODUCT</span>
<span class="line-added">1029   virtual void dump_spec(outputStream *st) const;</span>
<span class="line-added">1030 #endif</span>
<span class="line-added">1031 };</span>
<span class="line-added">1032 </span>
1033 //------------------------------MachHaltNode-----------------------------------
1034 // Machine-specific versions of halt nodes
1035 class MachHaltNode : public MachReturnNode {
1036 public:
1037   bool _reachable;
1038   const char* _halt_reason;
1039   virtual JVMState* jvms() const;
1040   bool is_reachable() const {
1041     return _reachable;
1042   }
1043 };
1044 
1045 class MachMemBarNode : public MachNode {
1046   virtual uint size_of() const; // Size is bigger
1047 public:
1048   const TypePtr* _adr_type;     // memory effects
1049   MachMemBarNode() : MachNode() {
1050     init_class_id(Class_MachMemBar);
1051     _adr_type = TypePtr::BOTTOM; // the default: all of memory
1052   }
1053 
1054   void set_adr_type(const TypePtr* atp) { _adr_type = atp; }
1055   virtual const TypePtr *adr_type() const;
1056 };
1057 
1058 
1059 //------------------------------MachTempNode-----------------------------------
1060 // Node used by the adlc to construct inputs to represent temporary registers
1061 class MachTempNode : public MachNode {
1062 private:
1063   MachOper *_opnd_array[1];
1064 
1065 public:
1066   virtual const RegMask &amp;out_RegMask() const { return *_opnds[0]-&gt;in_RegMask(0); }
1067   virtual uint rule() const { return 9999999; }
1068   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1069 
1070   MachTempNode(MachOper* oper) {
1071     init_class_id(Class_MachTemp);
1072     _num_opnds = 1;
1073     _opnds = _opnd_array;
1074     add_req(NULL);
1075     _opnds[0] = oper;
1076   }
1077   virtual uint size_of() const { return sizeof(MachTempNode); }
1078 
1079 #ifndef PRODUCT
1080   virtual void format(PhaseRegAlloc *, outputStream *st ) const {}
1081   virtual const char *Name() const { return &quot;MachTemp&quot;;}
1082 #endif
1083 };
1084 
1085 
1086 
1087 //------------------------------labelOper--------------------------------------
1088 // Machine-independent version of label operand
1089 class labelOper : public MachOper {
1090 private:
1091   virtual uint           num_edges() const { return 0; }
1092 public:
1093   // Supported for fixed size branches
1094   Label* _label;                // Label for branch(es)
1095 
1096   uint _block_num;
1097 
1098   labelOper() : _label(0), _block_num(0) {}
1099 
1100   labelOper(Label* label, uint block_num) : _label(label), _block_num(block_num) {}
1101 
1102   labelOper(labelOper* l) : _label(l-&gt;_label) , _block_num(l-&gt;_block_num) {}
1103 
1104   virtual MachOper *clone() const;
1105 
1106   virtual Label *label() const { assert(_label != NULL, &quot;need Label&quot;); return _label; }
1107 
1108   virtual uint           opcode() const;
1109 
1110   virtual uint           hash()   const;
1111   virtual bool           cmp( const MachOper &amp;oper ) const;
1112 #ifndef PRODUCT
1113   virtual const char    *Name()   const { return &quot;Label&quot;;}
1114 
1115   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1116   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1117 #endif
1118 };
1119 
1120 
1121 //------------------------------methodOper--------------------------------------
1122 // Machine-independent version of method operand
1123 class methodOper : public MachOper {
1124 private:
1125   virtual uint           num_edges() const { return 0; }
1126 public:
1127   intptr_t _method;             // Address of method
1128   methodOper() :   _method(0) {}
1129   methodOper(intptr_t method) : _method(method)  {}
1130 
1131   virtual MachOper *clone() const;
1132 
1133   virtual intptr_t method() const { return _method; }
1134 
1135   virtual uint           opcode() const;
1136 
1137   virtual uint           hash()   const;
1138   virtual bool           cmp( const MachOper &amp;oper ) const;
1139 #ifndef PRODUCT
1140   virtual const char    *Name()   const { return &quot;Method&quot;;}
1141 
1142   virtual void int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const;
1143   virtual void ext_format(PhaseRegAlloc *ra, const MachNode *node, int idx, outputStream *st) const { int_format( ra, node, st ); }
1144 #endif
1145 };
1146 
1147 #endif // SHARE_OPTO_MACHNODE_HPP
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="lcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
801 //=============================================================================
802 #ifndef PRODUCT
803 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
804   st-&gt;print(&quot;Dynamic &quot;);
805   MachCallJavaNode::dump_spec(st);
806 }
807 #endif
808 //=============================================================================
809 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
810 bool MachCallRuntimeNode::cmp( const Node &amp;n ) const {
811   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
812   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
813 }
814 #ifndef PRODUCT
815 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
816   st-&gt;print(&quot;%s &quot;,_name);
817   MachCallNode::dump_spec(st);
818 }
819 #endif
820 //=============================================================================

















821 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
822 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
823 // to indicate where the stack-slot-only debug info inputs begin.
824 // There is no other JVM state needed here.
825 JVMState jvms_for_throw(0);
826 JVMState *MachHaltNode::jvms() const {
827   return &amp;jvms_for_throw;
828 }
829 
830 uint MachMemBarNode::size_of() const { return sizeof(*this); }
831 
832 const TypePtr *MachMemBarNode::adr_type() const {
833   return _adr_type;
834 }
835 
836 
837 //=============================================================================
838 #ifndef PRODUCT
839 void labelOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
840   st-&gt;print(&quot;B%d&quot;, _block_num);
</pre>
</td>
<td>
<hr />
<pre>
801 //=============================================================================
802 #ifndef PRODUCT
803 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
804   st-&gt;print(&quot;Dynamic &quot;);
805   MachCallJavaNode::dump_spec(st);
806 }
807 #endif
808 //=============================================================================
809 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
810 bool MachCallRuntimeNode::cmp( const Node &amp;n ) const {
811   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
812   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
813 }
814 #ifndef PRODUCT
815 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
816   st-&gt;print(&quot;%s &quot;,_name);
817   MachCallNode::dump_spec(st);
818 }
819 #endif
820 //=============================================================================
<span class="line-added">821 uint MachCallNativeNode::size_of() const { return sizeof(*this); }</span>
<span class="line-added">822 bool MachCallNativeNode::cmp( const Node &amp;n ) const {</span>
<span class="line-added">823   MachCallNativeNode &amp;call = (MachCallNativeNode&amp;)n;</span>
<span class="line-added">824   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name)</span>
<span class="line-added">825     &amp;&amp; _arg_regs == call._arg_regs &amp;&amp; _ret_regs == call._ret_regs;</span>
<span class="line-added">826 }</span>
<span class="line-added">827 #ifndef PRODUCT</span>
<span class="line-added">828 void MachCallNativeNode::dump_spec(outputStream *st) const {</span>
<span class="line-added">829   st-&gt;print(&quot;%s &quot;,_name);</span>
<span class="line-added">830   st-&gt;print(&quot;_arg_regs: &quot;);</span>
<span class="line-added">831   _arg_regs.print_on(st);</span>
<span class="line-added">832   st-&gt;print(&quot;_ret_regs: &quot;);</span>
<span class="line-added">833   _ret_regs.print_on(st);</span>
<span class="line-added">834   MachCallNode::dump_spec(st);</span>
<span class="line-added">835 }</span>
<span class="line-added">836 #endif</span>
<span class="line-added">837 //=============================================================================</span>
838 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
839 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
840 // to indicate where the stack-slot-only debug info inputs begin.
841 // There is no other JVM state needed here.
842 JVMState jvms_for_throw(0);
843 JVMState *MachHaltNode::jvms() const {
844   return &amp;jvms_for_throw;
845 }
846 
847 uint MachMemBarNode::size_of() const { return sizeof(*this); }
848 
849 const TypePtr *MachMemBarNode::adr_type() const {
850   return _adr_type;
851 }
852 
853 
854 //=============================================================================
855 #ifndef PRODUCT
856 void labelOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
857   st-&gt;print(&quot;B%d&quot;, _block_num);
</pre>
</td>
</tr>
</table>
<center><a href="lcm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/callnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;ci/bcEscapeAnalyzer.hpp&quot;
  28 #include &quot;compiler/oopMap.hpp&quot;
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;opto/callGenerator.hpp&quot;
  33 #include &quot;opto/callnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/locknode.hpp&quot;
  38 #include &quot;opto/machnode.hpp&quot;
  39 #include &quot;opto/matcher.hpp&quot;
  40 #include &quot;opto/parse.hpp&quot;
  41 #include &quot;opto/regalloc.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;opto/rootnode.hpp&quot;
  44 #include &quot;opto/runtime.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 #include &quot;code/vmreg.hpp&quot;
  47 
  48 // Portions of code courtesy of Clifford Click
  49 
  50 // Optimization - Graph Style
  51 
  52 //=============================================================================
  53 uint StartNode::size_of() const { return sizeof(*this); }
  54 bool StartNode::cmp( const Node &amp;n ) const
  55 { return _domain == ((StartNode&amp;)n)._domain; }
  56 const Type *StartNode::bottom_type() const { return _domain; }
  57 const Type* StartNode::Value(PhaseGVN* phase) const { return _domain; }
  58 #ifndef PRODUCT
  59 void StartNode::dump_spec(outputStream *st) const { st-&gt;print(&quot; #&quot;); _domain-&gt;dump_on(st);}
  60 void StartNode::dump_compact_spec(outputStream *st) const { /* empty */ }
  61 #endif
  62 
  63 //------------------------------Ideal------------------------------------------
  64 Node *StartNode::Ideal(PhaseGVN *phase, bool can_reshape){
  65   return remove_dead_region(phase, can_reshape) ? this : NULL;
  66 }
  67 
  68 //------------------------------calling_convention-----------------------------
  69 void StartNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
  70   Matcher::calling_convention( sig_bt, parm_regs, argcnt, false );
  71 }
  72 
  73 //------------------------------Registers--------------------------------------
  74 const RegMask &amp;StartNode::in_RegMask(uint) const {
  75   return RegMask::Empty;
  76 }
  77 
  78 //------------------------------match------------------------------------------
  79 // Construct projections for incoming parameters, and their RegMask info
  80 Node *StartNode::match( const ProjNode *proj, const Matcher *match ) {
  81   switch (proj-&gt;_con) {
  82   case TypeFunc::Control:
  83   case TypeFunc::I_O:
  84   case TypeFunc::Memory:
  85     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
  86   case TypeFunc::FramePtr:
  87     return new MachProjNode(this,proj-&gt;_con,Matcher::c_frame_ptr_mask, Op_RegP);
  88   case TypeFunc::ReturnAdr:
  89     return new MachProjNode(this,proj-&gt;_con,match-&gt;_return_addr_mask,Op_RegP);
  90   case TypeFunc::Parms:
  91   default: {
  92       uint parm_num = proj-&gt;_con - TypeFunc::Parms;
  93       const Type *t = _domain-&gt;field_at(proj-&gt;_con);
  94       if (t-&gt;base() == Type::Half)  // 2nd half of Longs and Doubles
  95         return new ConNode(Type::TOP);
  96       uint ideal_reg = t-&gt;ideal_reg();
  97       RegMask &amp;rm = match-&gt;_calling_convention_mask[parm_num];
  98       return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
  99     }
 100   }
 101   return NULL;
 102 }
 103 
 104 //------------------------------StartOSRNode----------------------------------
 105 // The method start node for an on stack replacement adapter
 106 
 107 //------------------------------osr_domain-----------------------------
 108 const TypeTuple *StartOSRNode::osr_domain() {
 109   const Type **fields = TypeTuple::fields(2);
 110   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM;  // address of osr buffer
 111 
 112   return TypeTuple::make(TypeFunc::Parms+1, fields);
 113 }
 114 
 115 //=============================================================================
 116 const char * const ParmNode::names[TypeFunc::Parms+1] = {
 117   &quot;Control&quot;, &quot;I_O&quot;, &quot;Memory&quot;, &quot;FramePtr&quot;, &quot;ReturnAdr&quot;, &quot;Parms&quot;
 118 };
 119 
 120 #ifndef PRODUCT
 121 void ParmNode::dump_spec(outputStream *st) const {
 122   if( _con &lt; TypeFunc::Parms ) {
 123     st-&gt;print(&quot;%s&quot;, names[_con]);
 124   } else {
 125     st-&gt;print(&quot;Parm%d: &quot;,_con-TypeFunc::Parms);
 126     // Verbose and WizardMode dump bottom_type for all nodes
 127     if( !Verbose &amp;&amp; !WizardMode )   bottom_type()-&gt;dump_on(st);
 128   }
 129 }
 130 
 131 void ParmNode::dump_compact_spec(outputStream *st) const {
 132   if (_con &lt; TypeFunc::Parms) {
 133     st-&gt;print(&quot;%s&quot;, names[_con]);
 134   } else {
 135     st-&gt;print(&quot;%d:&quot;, _con-TypeFunc::Parms);
 136     // unconditionally dump bottom_type
 137     bottom_type()-&gt;dump_on(st);
 138   }
 139 }
 140 
 141 // For a ParmNode, all immediate inputs and outputs are considered relevant
 142 // both in compact and standard representation.
 143 void ParmNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
 144   this-&gt;collect_nodes(in_rel, 1, false, false);
 145   this-&gt;collect_nodes(out_rel, -1, false, false);
 146 }
 147 #endif
 148 
 149 uint ParmNode::ideal_reg() const {
 150   switch( _con ) {
 151   case TypeFunc::Control  : // fall through
 152   case TypeFunc::I_O      : // fall through
 153   case TypeFunc::Memory   : return 0;
 154   case TypeFunc::FramePtr : // fall through
 155   case TypeFunc::ReturnAdr: return Op_RegP;
 156   default                 : assert( _con &gt; TypeFunc::Parms, &quot;&quot; );
 157     // fall through
 158   case TypeFunc::Parms    : {
 159     // Type of argument being passed
 160     const Type *t = in(0)-&gt;as_Start()-&gt;_domain-&gt;field_at(_con);
 161     return t-&gt;ideal_reg();
 162   }
 163   }
 164   ShouldNotReachHere();
 165   return 0;
 166 }
 167 
 168 //=============================================================================
 169 ReturnNode::ReturnNode(uint edges, Node *cntrl, Node *i_o, Node *memory, Node *frameptr, Node *retadr ) : Node(edges) {
 170   init_req(TypeFunc::Control,cntrl);
 171   init_req(TypeFunc::I_O,i_o);
 172   init_req(TypeFunc::Memory,memory);
 173   init_req(TypeFunc::FramePtr,frameptr);
 174   init_req(TypeFunc::ReturnAdr,retadr);
 175 }
 176 
 177 Node *ReturnNode::Ideal(PhaseGVN *phase, bool can_reshape){
 178   return remove_dead_region(phase, can_reshape) ? this : NULL;
 179 }
 180 
 181 const Type* ReturnNode::Value(PhaseGVN* phase) const {
 182   return ( phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 183     ? Type::TOP
 184     : Type::BOTTOM;
 185 }
 186 
 187 // Do we Match on this edge index or not?  No edges on return nodes
 188 uint ReturnNode::match_edge(uint idx) const {
 189   return 0;
 190 }
 191 
 192 
 193 #ifndef PRODUCT
 194 void ReturnNode::dump_req(outputStream *st) const {
 195   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 196   uint i;                       // Exit value of loop
 197   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 198     if (i == TypeFunc::Parms) st-&gt;print(&quot;returns&quot;);
 199     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 200     else st-&gt;print(&quot;_ &quot;);
 201   }
 202 }
 203 #endif
 204 
 205 //=============================================================================
 206 RethrowNode::RethrowNode(
 207   Node* cntrl,
 208   Node* i_o,
 209   Node* memory,
 210   Node* frameptr,
 211   Node* ret_adr,
 212   Node* exception
 213 ) : Node(TypeFunc::Parms + 1) {
 214   init_req(TypeFunc::Control  , cntrl    );
 215   init_req(TypeFunc::I_O      , i_o      );
 216   init_req(TypeFunc::Memory   , memory   );
 217   init_req(TypeFunc::FramePtr , frameptr );
 218   init_req(TypeFunc::ReturnAdr, ret_adr);
 219   init_req(TypeFunc::Parms    , exception);
 220 }
 221 
 222 Node *RethrowNode::Ideal(PhaseGVN *phase, bool can_reshape){
 223   return remove_dead_region(phase, can_reshape) ? this : NULL;
 224 }
 225 
 226 const Type* RethrowNode::Value(PhaseGVN* phase) const {
 227   return (phase-&gt;type(in(TypeFunc::Control)) == Type::TOP)
 228     ? Type::TOP
 229     : Type::BOTTOM;
 230 }
 231 
 232 uint RethrowNode::match_edge(uint idx) const {
 233   return 0;
 234 }
 235 
 236 #ifndef PRODUCT
 237 void RethrowNode::dump_req(outputStream *st) const {
 238   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 239   uint i;                       // Exit value of loop
 240   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 241     if (i == TypeFunc::Parms) st-&gt;print(&quot;exception&quot;);
 242     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 243     else st-&gt;print(&quot;_ &quot;);
 244   }
 245 }
 246 #endif
 247 
 248 //=============================================================================
 249 // Do we Match on this edge index or not?  Match only target address &amp; method
 250 uint TailCallNode::match_edge(uint idx) const {
 251   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 252 }
 253 
 254 //=============================================================================
 255 // Do we Match on this edge index or not?  Match only target address &amp; oop
 256 uint TailJumpNode::match_edge(uint idx) const {
 257   return TypeFunc::Parms &lt;= idx  &amp;&amp;  idx &lt;= TypeFunc::Parms+1;
 258 }
 259 
 260 //=============================================================================
 261 JVMState::JVMState(ciMethod* method, JVMState* caller) :
 262   _method(method) {
 263   assert(method != NULL, &quot;must be valid call site&quot;);
 264   _bci = InvocationEntryBci;
 265   _reexecute = Reexecute_Undefined;
 266   debug_only(_bci = -99);  // random garbage value
 267   debug_only(_map = (SafePointNode*)-1);
 268   _caller = caller;
 269   _depth  = 1 + (caller == NULL ? 0 : caller-&gt;depth());
 270   _locoff = TypeFunc::Parms;
 271   _stkoff = _locoff + _method-&gt;max_locals();
 272   _monoff = _stkoff + _method-&gt;max_stack();
 273   _scloff = _monoff;
 274   _endoff = _monoff;
 275   _sp = 0;
 276 }
 277 JVMState::JVMState(int stack_size) :
 278   _method(NULL) {
 279   _bci = InvocationEntryBci;
 280   _reexecute = Reexecute_Undefined;
 281   debug_only(_map = (SafePointNode*)-1);
 282   _caller = NULL;
 283   _depth  = 1;
 284   _locoff = TypeFunc::Parms;
 285   _stkoff = _locoff;
 286   _monoff = _stkoff + stack_size;
 287   _scloff = _monoff;
 288   _endoff = _monoff;
 289   _sp = 0;
 290 }
 291 
 292 //--------------------------------of_depth-------------------------------------
 293 JVMState* JVMState::of_depth(int d) const {
 294   const JVMState* jvmp = this;
 295   assert(0 &lt; d &amp;&amp; (uint)d &lt;= depth(), &quot;oob&quot;);
 296   for (int skip = depth() - d; skip &gt; 0; skip--) {
 297     jvmp = jvmp-&gt;caller();
 298   }
 299   assert(jvmp-&gt;depth() == (uint)d, &quot;found the right one&quot;);
 300   return (JVMState*)jvmp;
 301 }
 302 
 303 //-----------------------------same_calls_as-----------------------------------
 304 bool JVMState::same_calls_as(const JVMState* that) const {
 305   if (this == that)                    return true;
 306   if (this-&gt;depth() != that-&gt;depth())  return false;
 307   const JVMState* p = this;
 308   const JVMState* q = that;
 309   for (;;) {
 310     if (p-&gt;_method != q-&gt;_method)    return false;
 311     if (p-&gt;_method == NULL)          return true;   // bci is irrelevant
 312     if (p-&gt;_bci    != q-&gt;_bci)       return false;
 313     if (p-&gt;_reexecute != q-&gt;_reexecute)  return false;
 314     p = p-&gt;caller();
 315     q = q-&gt;caller();
 316     if (p == q)                      return true;
 317     assert(p != NULL &amp;&amp; q != NULL, &quot;depth check ensures we don&#39;t run off end&quot;);
 318   }
 319 }
 320 
 321 //------------------------------debug_start------------------------------------
 322 uint JVMState::debug_start()  const {
 323   debug_only(JVMState* jvmroot = of_depth(1));
 324   assert(jvmroot-&gt;locoff() &lt;= this-&gt;locoff(), &quot;youngest JVMState must be last&quot;);
 325   return of_depth(1)-&gt;locoff();
 326 }
 327 
 328 //-------------------------------debug_end-------------------------------------
 329 uint JVMState::debug_end() const {
 330   debug_only(JVMState* jvmroot = of_depth(1));
 331   assert(jvmroot-&gt;endoff() &lt;= this-&gt;endoff(), &quot;youngest JVMState must be last&quot;);
 332   return endoff();
 333 }
 334 
 335 //------------------------------debug_depth------------------------------------
 336 uint JVMState::debug_depth() const {
 337   uint total = 0;
 338   for (const JVMState* jvmp = this; jvmp != NULL; jvmp = jvmp-&gt;caller()) {
 339     total += jvmp-&gt;debug_size();
 340   }
 341   return total;
 342 }
 343 
 344 #ifndef PRODUCT
 345 
 346 //------------------------------format_helper----------------------------------
 347 // Given an allocation (a Chaitin object) and a Node decide if the Node carries
 348 // any defined value or not.  If it does, print out the register or constant.
 349 static void format_helper( PhaseRegAlloc *regalloc, outputStream* st, Node *n, const char *msg, uint i, GrowableArray&lt;SafePointScalarObjectNode*&gt; *scobjs ) {
 350   if (n == NULL) { st-&gt;print(&quot; NULL&quot;); return; }
 351   if (n-&gt;is_SafePointScalarObject()) {
 352     // Scalar replacement.
 353     SafePointScalarObjectNode* spobj = n-&gt;as_SafePointScalarObject();
 354     scobjs-&gt;append_if_missing(spobj);
 355     int sco_n = scobjs-&gt;find(spobj);
 356     assert(sco_n &gt;= 0, &quot;&quot;);
 357     st-&gt;print(&quot; %s%d]=#ScObj&quot; INT32_FORMAT, msg, i, sco_n);
 358     return;
 359   }
 360   if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 361       OptoReg::is_valid(regalloc-&gt;get_reg_first(n))) { // Check for undefined
 362     char buf[50];
 363     regalloc-&gt;dump_register(n,buf);
 364     st-&gt;print(&quot; %s%d]=%s&quot;,msg,i,buf);
 365   } else {                      // No register, but might be constant
 366     const Type *t = n-&gt;bottom_type();
 367     switch (t-&gt;base()) {
 368     case Type::Int:
 369       st-&gt;print(&quot; %s%d]=#&quot; INT32_FORMAT,msg,i,t-&gt;is_int()-&gt;get_con());
 370       break;
 371     case Type::AnyPtr:
 372       assert( t == TypePtr::NULL_PTR || n-&gt;in_dump(), &quot;&quot; );
 373       st-&gt;print(&quot; %s%d]=#NULL&quot;,msg,i);
 374       break;
 375     case Type::AryPtr:
 376     case Type::InstPtr:
 377       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;isa_oopptr()-&gt;const_oop()));
 378       break;
 379     case Type::KlassPtr:
 380       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_klassptr()-&gt;klass()));
 381       break;
 382     case Type::MetadataPtr:
 383       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_metadataptr()-&gt;metadata()));
 384       break;
 385     case Type::NarrowOop:
 386       st-&gt;print(&quot; %s%d]=#Ptr&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()));
 387       break;
 388     case Type::RawPtr:
 389       st-&gt;print(&quot; %s%d]=#Raw&quot; INTPTR_FORMAT,msg,i,p2i(t-&gt;is_rawptr()));
 390       break;
 391     case Type::DoubleCon:
 392       st-&gt;print(&quot; %s%d]=#%fD&quot;,msg,i,t-&gt;is_double_constant()-&gt;_d);
 393       break;
 394     case Type::FloatCon:
 395       st-&gt;print(&quot; %s%d]=#%fF&quot;,msg,i,t-&gt;is_float_constant()-&gt;_f);
 396       break;
 397     case Type::Long:
 398       st-&gt;print(&quot; %s%d]=#&quot; INT64_FORMAT,msg,i,(int64_t)(t-&gt;is_long()-&gt;get_con()));
 399       break;
 400     case Type::Half:
 401     case Type::Top:
 402       st-&gt;print(&quot; %s%d]=_&quot;,msg,i);
 403       break;
 404     default: ShouldNotReachHere();
 405     }
 406   }
 407 }
 408 
 409 //------------------------------format-----------------------------------------
 410 void JVMState::format(PhaseRegAlloc *regalloc, const Node *n, outputStream* st) const {
 411   st-&gt;print(&quot;        #&quot;);
 412   if (_method) {
 413     _method-&gt;print_short_name(st);
 414     st-&gt;print(&quot; @ bci:%d &quot;,_bci);
 415   } else {
 416     st-&gt;print_cr(&quot; runtime stub &quot;);
 417     return;
 418   }
 419   if (n-&gt;is_MachSafePoint()) {
 420     GrowableArray&lt;SafePointScalarObjectNode*&gt; scobjs;
 421     MachSafePointNode *mcall = n-&gt;as_MachSafePoint();
 422     uint i;
 423     // Print locals
 424     for (i = 0; i &lt; (uint)loc_size(); i++)
 425       format_helper(regalloc, st, mcall-&gt;local(this, i), &quot;L[&quot;, i, &amp;scobjs);
 426     // Print stack
 427     for (i = 0; i &lt; (uint)stk_size(); i++) {
 428       if ((uint)(_stkoff + i) &gt;= mcall-&gt;len())
 429         st-&gt;print(&quot; oob &quot;);
 430       else
 431        format_helper(regalloc, st, mcall-&gt;stack(this, i), &quot;STK[&quot;, i, &amp;scobjs);
 432     }
 433     for (i = 0; (int)i &lt; nof_monitors(); i++) {
 434       Node *box = mcall-&gt;monitor_box(this, i);
 435       Node *obj = mcall-&gt;monitor_obj(this, i);
 436       if (regalloc-&gt;node_regs_max_index() &gt; 0 &amp;&amp;
 437           OptoReg::is_valid(regalloc-&gt;get_reg_first(box))) {
 438         box = BoxLockNode::box_node(box);
 439         format_helper(regalloc, st, box, &quot;MON-BOX[&quot;, i, &amp;scobjs);
 440       } else {
 441         OptoReg::Name box_reg = BoxLockNode::reg(box);
 442         st-&gt;print(&quot; MON-BOX%d=%s+%d&quot;,
 443                    i,
 444                    OptoReg::regname(OptoReg::c_frame_pointer),
 445                    regalloc-&gt;reg2offset(box_reg));
 446       }
 447       const char* obj_msg = &quot;MON-OBJ[&quot;;
 448       if (EliminateLocks) {
 449         if (BoxLockNode::box_node(box)-&gt;is_eliminated())
 450           obj_msg = &quot;MON-OBJ(LOCK ELIMINATED)[&quot;;
 451       }
 452       format_helper(regalloc, st, obj, obj_msg, i, &amp;scobjs);
 453     }
 454 
 455     for (i = 0; i &lt; (uint)scobjs.length(); i++) {
 456       // Scalar replaced objects.
 457       st-&gt;cr();
 458       st-&gt;print(&quot;        # ScObj&quot; INT32_FORMAT &quot; &quot;, i);
 459       SafePointScalarObjectNode* spobj = scobjs.at(i);
 460       ciKlass* cik = spobj-&gt;bottom_type()-&gt;is_oopptr()-&gt;klass();
 461       assert(cik-&gt;is_instance_klass() ||
 462              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 463       ciInstanceKlass *iklass = NULL;
 464       if (cik-&gt;is_instance_klass()) {
 465         cik-&gt;print_name_on(st);
 466         iklass = cik-&gt;as_instance_klass();
 467       } else if (cik-&gt;is_type_array_klass()) {
 468         cik-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 469         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 470       } else if (cik-&gt;is_obj_array_klass()) {
 471         ciKlass* cie = cik-&gt;as_obj_array_klass()-&gt;base_element_klass();
 472         if (cie-&gt;is_instance_klass()) {
 473           cie-&gt;print_name_on(st);
 474         } else if (cie-&gt;is_type_array_klass()) {
 475           cie-&gt;as_array_klass()-&gt;base_element_type()-&gt;print_name_on(st);
 476         } else {
 477           ShouldNotReachHere();
 478         }
 479         st-&gt;print(&quot;[%d]&quot;, spobj-&gt;n_fields());
 480         int ndim = cik-&gt;as_array_klass()-&gt;dimension() - 1;
 481         while (ndim-- &gt; 0) {
 482           st-&gt;print(&quot;[]&quot;);
 483         }
 484       }
 485       st-&gt;print(&quot;={&quot;);
 486       uint nf = spobj-&gt;n_fields();
 487       if (nf &gt; 0) {
 488         uint first_ind = spobj-&gt;first_index(mcall-&gt;jvms());
 489         Node* fld_node = mcall-&gt;in(first_ind);
 490         ciField* cifield;
 491         if (iklass != NULL) {
 492           st-&gt;print(&quot; [&quot;);
 493           cifield = iklass-&gt;nonstatic_field_at(0);
 494           cifield-&gt;print_name_on(st);
 495           format_helper(regalloc, st, fld_node, &quot;:&quot;, 0, &amp;scobjs);
 496         } else {
 497           format_helper(regalloc, st, fld_node, &quot;[&quot;, 0, &amp;scobjs);
 498         }
 499         for (uint j = 1; j &lt; nf; j++) {
 500           fld_node = mcall-&gt;in(first_ind+j);
 501           if (iklass != NULL) {
 502             st-&gt;print(&quot;, [&quot;);
 503             cifield = iklass-&gt;nonstatic_field_at(j);
 504             cifield-&gt;print_name_on(st);
 505             format_helper(regalloc, st, fld_node, &quot;:&quot;, j, &amp;scobjs);
 506           } else {
 507             format_helper(regalloc, st, fld_node, &quot;, [&quot;, j, &amp;scobjs);
 508           }
 509         }
 510       }
 511       st-&gt;print(&quot; }&quot;);
 512     }
 513   }
 514   st-&gt;cr();
 515   if (caller() != NULL) caller()-&gt;format(regalloc, n, st);
 516 }
 517 
 518 
 519 void JVMState::dump_spec(outputStream *st) const {
 520   if (_method != NULL) {
 521     bool printed = false;
 522     if (!Verbose) {
 523       // The JVMS dumps make really, really long lines.
 524       // Take out the most boring parts, which are the package prefixes.
 525       char buf[500];
 526       stringStream namest(buf, sizeof(buf));
 527       _method-&gt;print_short_name(&amp;namest);
 528       if (namest.count() &lt; sizeof(buf)) {
 529         const char* name = namest.base();
 530         if (name[0] == &#39; &#39;)  ++name;
 531         const char* endcn = strchr(name, &#39;:&#39;);  // end of class name
 532         if (endcn == NULL)  endcn = strchr(name, &#39;(&#39;);
 533         if (endcn == NULL)  endcn = name + strlen(name);
 534         while (endcn &gt; name &amp;&amp; endcn[-1] != &#39;.&#39; &amp;&amp; endcn[-1] != &#39;/&#39;)
 535           --endcn;
 536         st-&gt;print(&quot; %s&quot;, endcn);
 537         printed = true;
 538       }
 539     }
 540     if (!printed)
 541       _method-&gt;print_short_name(st);
 542     st-&gt;print(&quot; @ bci:%d&quot;,_bci);
 543     if(_reexecute == Reexecute_True)
 544       st-&gt;print(&quot; reexecute&quot;);
 545   } else {
 546     st-&gt;print(&quot; runtime stub&quot;);
 547   }
 548   if (caller() != NULL)  caller()-&gt;dump_spec(st);
 549 }
 550 
 551 
 552 void JVMState::dump_on(outputStream* st) const {
 553   bool print_map = _map &amp;&amp; !((uintptr_t)_map &amp; 1) &amp;&amp;
 554                   ((caller() == NULL) || (caller()-&gt;map() != _map));
 555   if (print_map) {
 556     if (_map-&gt;len() &gt; _map-&gt;req()) {  // _map-&gt;has_exceptions()
 557       Node* ex = _map-&gt;in(_map-&gt;req());  // _map-&gt;next_exception()
 558       // skip the first one; it&#39;s already being printed
 559       while (ex != NULL &amp;&amp; ex-&gt;len() &gt; ex-&gt;req()) {
 560         ex = ex-&gt;in(ex-&gt;req());  // ex-&gt;next_exception()
 561         ex-&gt;dump(1);
 562       }
 563     }
 564     _map-&gt;dump(Verbose ? 2 : 1);
 565   }
 566   if (caller() != NULL) {
 567     caller()-&gt;dump_on(st);
 568   }
 569   st-&gt;print(&quot;JVMS depth=%d loc=%d stk=%d arg=%d mon=%d scalar=%d end=%d mondepth=%d sp=%d bci=%d reexecute=%s method=&quot;,
 570              depth(), locoff(), stkoff(), argoff(), monoff(), scloff(), endoff(), monitor_depth(), sp(), bci(), should_reexecute()?&quot;true&quot;:&quot;false&quot;);
 571   if (_method == NULL) {
 572     st-&gt;print_cr(&quot;(none)&quot;);
 573   } else {
 574     _method-&gt;print_name(st);
 575     st-&gt;cr();
 576     if (bci() &gt;= 0 &amp;&amp; bci() &lt; _method-&gt;code_size()) {
 577       st-&gt;print(&quot;    bc: &quot;);
 578       _method-&gt;print_codes_on(bci(), bci()+1, st);
 579     }
 580   }
 581 }
 582 
 583 // Extra way to dump a jvms from the debugger,
 584 // to avoid a bug with C++ member function calls.
 585 void dump_jvms(JVMState* jvms) {
 586   jvms-&gt;dump();
 587 }
 588 #endif
 589 
 590 //--------------------------clone_shallow--------------------------------------
 591 JVMState* JVMState::clone_shallow(Compile* C) const {
 592   JVMState* n = has_method() ? new (C) JVMState(_method, _caller) : new (C) JVMState(0);
 593   n-&gt;set_bci(_bci);
 594   n-&gt;_reexecute = _reexecute;
 595   n-&gt;set_locoff(_locoff);
 596   n-&gt;set_stkoff(_stkoff);
 597   n-&gt;set_monoff(_monoff);
 598   n-&gt;set_scloff(_scloff);
 599   n-&gt;set_endoff(_endoff);
 600   n-&gt;set_sp(_sp);
 601   n-&gt;set_map(_map);
 602   return n;
 603 }
 604 
 605 //---------------------------clone_deep----------------------------------------
 606 JVMState* JVMState::clone_deep(Compile* C) const {
 607   JVMState* n = clone_shallow(C);
 608   for (JVMState* p = n; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 609     p-&gt;_caller = p-&gt;_caller-&gt;clone_shallow(C);
 610   }
 611   assert(n-&gt;depth() == depth(), &quot;sanity&quot;);
 612   assert(n-&gt;debug_depth() == debug_depth(), &quot;sanity&quot;);
 613   return n;
 614 }
 615 
 616 /**
 617  * Reset map for all callers
 618  */
 619 void JVMState::set_map_deep(SafePointNode* map) {
 620   for (JVMState* p = this; p-&gt;_caller != NULL; p = p-&gt;_caller) {
 621     p-&gt;set_map(map);
 622   }
 623 }
 624 
 625 // Adapt offsets in in-array after adding or removing an edge.
 626 // Prerequisite is that the JVMState is used by only one node.
 627 void JVMState::adapt_position(int delta) {
 628   for (JVMState* jvms = this; jvms != NULL; jvms = jvms-&gt;caller()) {
 629     jvms-&gt;set_locoff(jvms-&gt;locoff() + delta);
 630     jvms-&gt;set_stkoff(jvms-&gt;stkoff() + delta);
 631     jvms-&gt;set_monoff(jvms-&gt;monoff() + delta);
 632     jvms-&gt;set_scloff(jvms-&gt;scloff() + delta);
 633     jvms-&gt;set_endoff(jvms-&gt;endoff() + delta);
 634   }
 635 }
 636 
 637 // Mirror the stack size calculation in the deopt code
 638 // How much stack space would we need at this point in the program in
 639 // case of deoptimization?
 640 int JVMState::interpreter_frame_size() const {
 641   const JVMState* jvms = this;
 642   int size = 0;
 643   int callee_parameters = 0;
 644   int callee_locals = 0;
 645   int extra_args = method()-&gt;max_stack() - stk_size();
 646 
 647   while (jvms != NULL) {
 648     int locks = jvms-&gt;nof_monitors();
 649     int temps = jvms-&gt;stk_size();
 650     bool is_top_frame = (jvms == this);
 651     ciMethod* method = jvms-&gt;method();
 652 
 653     int frame_size = BytesPerWord * Interpreter::size_activation(method-&gt;max_stack(),
 654                                                                  temps + callee_parameters,
 655                                                                  extra_args,
 656                                                                  locks,
 657                                                                  callee_parameters,
 658                                                                  callee_locals,
 659                                                                  is_top_frame);
 660     size += frame_size;
 661 
 662     callee_parameters = method-&gt;size_of_parameters();
 663     callee_locals = method-&gt;max_locals();
 664     extra_args = 0;
 665     jvms = jvms-&gt;caller();
 666   }
 667   return size + Deoptimization::last_frame_adjust(0, callee_locals) * BytesPerWord;
 668 }
 669 
 670 //=============================================================================
 671 bool CallNode::cmp( const Node &amp;n ) const
 672 { return _tf == ((CallNode&amp;)n)._tf &amp;&amp; _jvms == ((CallNode&amp;)n)._jvms; }
 673 #ifndef PRODUCT
 674 void CallNode::dump_req(outputStream *st) const {
 675   // Dump the required inputs, enclosed in &#39;(&#39; and &#39;)&#39;
 676   uint i;                       // Exit value of loop
 677   for (i = 0; i &lt; req(); i++) {    // For all required inputs
 678     if (i == TypeFunc::Parms) st-&gt;print(&quot;(&quot;);
 679     if (in(i)) st-&gt;print(&quot;%c%d &quot;, Compile::current()-&gt;node_arena()-&gt;contains(in(i)) ? &#39; &#39; : &#39;o&#39;, in(i)-&gt;_idx);
 680     else st-&gt;print(&quot;_ &quot;);
 681   }
 682   st-&gt;print(&quot;)&quot;);
 683 }
 684 
 685 void CallNode::dump_spec(outputStream *st) const {
 686   st-&gt;print(&quot; &quot;);
 687   if (tf() != NULL)  tf()-&gt;dump_on(st);
 688   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
 689   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
 690 }
 691 #endif
 692 
 693 const Type *CallNode::bottom_type() const { return tf()-&gt;range(); }
 694 const Type* CallNode::Value(PhaseGVN* phase) const {
 695   if (phase-&gt;type(in(0)) == Type::TOP)  return Type::TOP;
 696   return tf()-&gt;range();
 697 }
 698 
 699 //------------------------------calling_convention-----------------------------
 700 void CallNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
 701   // Use the standard compiler calling convention
 702   Matcher::calling_convention( sig_bt, parm_regs, argcnt, true );
 703 }
 704 
 705 
 706 //------------------------------match------------------------------------------
 707 // Construct projections for control, I/O, memory-fields, ..., and
 708 // return result(s) along with their RegMask info
 709 Node *CallNode::match( const ProjNode *proj, const Matcher *match ) {
 710   switch (proj-&gt;_con) {
 711   case TypeFunc::Control:
 712   case TypeFunc::I_O:
 713   case TypeFunc::Memory:
 714     return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
 715 
 716   case TypeFunc::Parms+1:       // For LONG &amp; DOUBLE returns
 717     assert(tf()-&gt;range()-&gt;field_at(TypeFunc::Parms+1) == Type::HALF, &quot;&quot;);
 718     // 2nd half of doubles and longs
 719     return new MachProjNode(this,proj-&gt;_con, RegMask::Empty, (uint)OptoReg::Bad);
 720 
 721   case TypeFunc::Parms: {       // Normal returns
 722     uint ideal_reg = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms)-&gt;ideal_reg();
 723     OptoRegPair regs = is_CallRuntime()
 724       ? match-&gt;c_return_value(ideal_reg,true)  // Calls into C runtime
 725       : match-&gt;  return_value(ideal_reg,true); // Calls into compiled Java code
 726     RegMask rm = RegMask(regs.first());
 727     if( OptoReg::is_valid(regs.second()) )
 728       rm.Insert( regs.second() );
 729     return new MachProjNode(this,proj-&gt;_con,rm,ideal_reg);
 730   }
 731 
 732   case TypeFunc::ReturnAdr:
 733   case TypeFunc::FramePtr:
 734   default:
 735     ShouldNotReachHere();
 736   }
 737   return NULL;
 738 }
 739 
 740 // Do we Match on this edge index or not?  Match no edges
 741 uint CallNode::match_edge(uint idx) const {
 742   return 0;
 743 }
 744 
 745 //
 746 // Determine whether the call could modify the field of the specified
 747 // instance at the specified offset.
 748 //
 749 bool CallNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
 750   assert((t_oop != NULL), &quot;sanity&quot;);
 751   if (is_call_to_arraycopystub() &amp;&amp; strcmp(_name, &quot;unsafe_arraycopy&quot;) != 0) {
 752     const TypeTuple* args = _tf-&gt;domain();
 753     Node* dest = NULL;
 754     // Stubs that can be called once an ArrayCopyNode is expanded have
 755     // different signatures. Look for the second pointer argument,
 756     // that is the destination of the copy.
 757     for (uint i = TypeFunc::Parms, j = 0; i &lt; args-&gt;cnt(); i++) {
 758       if (args-&gt;field_at(i)-&gt;isa_ptr()) {
 759         j++;
 760         if (j == 2) {
 761           dest = in(i);
 762           break;
 763         }
 764       }
 765     }
 766     guarantee(dest != NULL, &quot;Call had only one ptr in, broken IR!&quot;);
 767     if (!dest-&gt;is_top() &amp;&amp; may_modify_arraycopy_helper(phase-&gt;type(dest)-&gt;is_oopptr(), t_oop, phase)) {
 768       return true;
 769     }
 770     return false;
 771   }
 772   if (t_oop-&gt;is_known_instance()) {
 773     // The instance_id is set only for scalar-replaceable allocations which
 774     // are not passed as arguments according to Escape Analysis.
 775     return false;
 776   }
 777   if (t_oop-&gt;is_ptr_to_boxed_value()) {
 778     ciKlass* boxing_klass = t_oop-&gt;klass();
 779     if (is_CallStaticJava() &amp;&amp; as_CallStaticJava()-&gt;is_boxing_method()) {
 780       // Skip unrelated boxing methods.
 781       Node* proj = proj_out_or_null(TypeFunc::Parms);
 782       if ((proj == NULL) || (phase-&gt;type(proj)-&gt;is_instptr()-&gt;klass() != boxing_klass)) {
 783         return false;
 784       }
 785     }
 786     if (is_CallJava() &amp;&amp; as_CallJava()-&gt;method() != NULL) {
 787       ciMethod* meth = as_CallJava()-&gt;method();
 788       if (meth-&gt;is_getter()) {
 789         return false;
 790       }
 791       // May modify (by reflection) if an boxing object is passed
 792       // as argument or returned.
 793       Node* proj = returns_pointer() ? proj_out_or_null(TypeFunc::Parms) : NULL;
 794       if (proj != NULL) {
 795         const TypeInstPtr* inst_t = phase-&gt;type(proj)-&gt;isa_instptr();
 796         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 797                                  (inst_t-&gt;klass() == boxing_klass))) {
 798           return true;
 799         }
 800       }
 801       const TypeTuple* d = tf()-&gt;domain();
 802       for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 803         const TypeInstPtr* inst_t = d-&gt;field_at(i)-&gt;isa_instptr();
 804         if ((inst_t != NULL) &amp;&amp; (!inst_t-&gt;klass_is_exact() ||
 805                                  (inst_t-&gt;klass() == boxing_klass))) {
 806           return true;
 807         }
 808       }
 809       return false;
 810     }
 811   }
 812   return true;
 813 }
 814 
 815 // Does this call have a direct reference to n other than debug information?
 816 bool CallNode::has_non_debug_use(Node *n) {
 817   const TypeTuple * d = tf()-&gt;domain();
 818   for (uint i = TypeFunc::Parms; i &lt; d-&gt;cnt(); i++) {
 819     Node *arg = in(i);
 820     if (arg == n) {
 821       return true;
 822     }
 823   }
 824   return false;
 825 }
 826 
 827 // Returns the unique CheckCastPP of a call
 828 // or &#39;this&#39; if there are several CheckCastPP or unexpected uses
 829 // or returns NULL if there is no one.
 830 Node *CallNode::result_cast() {
 831   Node *cast = NULL;
 832 
 833   Node *p = proj_out_or_null(TypeFunc::Parms);
 834   if (p == NULL)
 835     return NULL;
 836 
 837   for (DUIterator_Fast imax, i = p-&gt;fast_outs(imax); i &lt; imax; i++) {
 838     Node *use = p-&gt;fast_out(i);
 839     if (use-&gt;is_CheckCastPP()) {
 840       if (cast != NULL) {
 841         return this;  // more than 1 CheckCastPP
 842       }
 843       cast = use;
 844     } else if (!use-&gt;is_Initialize() &amp;&amp;
 845                !use-&gt;is_AddP() &amp;&amp;
 846                use-&gt;Opcode() != Op_MemBarStoreStore) {
 847       // Expected uses are restricted to a CheckCastPP, an Initialize
 848       // node, a MemBarStoreStore (clone) and AddP nodes. If we
 849       // encounter any other use (a Phi node can be seen in rare
 850       // cases) return this to prevent incorrect optimizations.
 851       return this;
 852     }
 853   }
 854   return cast;
 855 }
 856 
 857 
 858 void CallNode::extract_projections(CallProjections* projs, bool separate_io_proj, bool do_asserts) {
 859   projs-&gt;fallthrough_proj      = NULL;
 860   projs-&gt;fallthrough_catchproj = NULL;
 861   projs-&gt;fallthrough_ioproj    = NULL;
 862   projs-&gt;catchall_ioproj       = NULL;
 863   projs-&gt;catchall_catchproj    = NULL;
 864   projs-&gt;fallthrough_memproj   = NULL;
 865   projs-&gt;catchall_memproj      = NULL;
 866   projs-&gt;resproj               = NULL;
 867   projs-&gt;exobj                 = NULL;
 868 
 869   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
 870     ProjNode *pn = fast_out(i)-&gt;as_Proj();
 871     if (pn-&gt;outcnt() == 0) continue;
 872     switch (pn-&gt;_con) {
 873     case TypeFunc::Control:
 874       {
 875         // For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -&gt; Catch -&gt; Proj
 876         projs-&gt;fallthrough_proj = pn;
 877         DUIterator_Fast jmax, j = pn-&gt;fast_outs(jmax);
 878         const Node *cn = pn-&gt;fast_out(j);
 879         if (cn-&gt;is_Catch()) {
 880           ProjNode *cpn = NULL;
 881           for (DUIterator_Fast kmax, k = cn-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 882             cpn = cn-&gt;fast_out(k)-&gt;as_Proj();
 883             assert(cpn-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
 884             if (cpn-&gt;_con == CatchProjNode::fall_through_index)
 885               projs-&gt;fallthrough_catchproj = cpn;
 886             else {
 887               assert(cpn-&gt;_con == CatchProjNode::catch_all_index, &quot;must be correct index.&quot;);
 888               projs-&gt;catchall_catchproj = cpn;
 889             }
 890           }
 891         }
 892         break;
 893       }
 894     case TypeFunc::I_O:
 895       if (pn-&gt;_is_io_use)
 896         projs-&gt;catchall_ioproj = pn;
 897       else
 898         projs-&gt;fallthrough_ioproj = pn;
 899       for (DUIterator j = pn-&gt;outs(); pn-&gt;has_out(j); j++) {
 900         Node* e = pn-&gt;out(j);
 901         if (e-&gt;Opcode() == Op_CreateEx &amp;&amp; e-&gt;in(0)-&gt;is_CatchProj() &amp;&amp; e-&gt;outcnt() &gt; 0) {
 902           assert(projs-&gt;exobj == NULL, &quot;only one&quot;);
 903           projs-&gt;exobj = e;
 904         }
 905       }
 906       break;
 907     case TypeFunc::Memory:
 908       if (pn-&gt;_is_io_use)
 909         projs-&gt;catchall_memproj = pn;
 910       else
 911         projs-&gt;fallthrough_memproj = pn;
 912       break;
 913     case TypeFunc::Parms:
 914       projs-&gt;resproj = pn;
 915       break;
 916     default:
 917       assert(false, &quot;unexpected projection from allocation node.&quot;);
 918     }
 919   }
 920 
 921   // The resproj may not exist because the result could be ignored
 922   // and the exception object may not exist if an exception handler
 923   // swallows the exception but all the other must exist and be found.
 924   assert(projs-&gt;fallthrough_proj      != NULL, &quot;must be found&quot;);
 925   do_asserts = do_asserts &amp;&amp; !Compile::current()-&gt;inlining_incrementally();
 926   assert(!do_asserts || projs-&gt;fallthrough_catchproj != NULL, &quot;must be found&quot;);
 927   assert(!do_asserts || projs-&gt;fallthrough_memproj   != NULL, &quot;must be found&quot;);
 928   assert(!do_asserts || projs-&gt;fallthrough_ioproj    != NULL, &quot;must be found&quot;);
 929   assert(!do_asserts || projs-&gt;catchall_catchproj    != NULL, &quot;must be found&quot;);
 930   if (separate_io_proj) {
 931     assert(!do_asserts || projs-&gt;catchall_memproj    != NULL, &quot;must be found&quot;);
 932     assert(!do_asserts || projs-&gt;catchall_ioproj     != NULL, &quot;must be found&quot;);
 933   }
 934 }
 935 
 936 Node *CallNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 937   CallGenerator* cg = generator();
 938   if (can_reshape &amp;&amp; cg != NULL &amp;&amp; cg-&gt;is_mh_late_inline() &amp;&amp; !cg-&gt;already_attempted()) {
 939     // Check whether this MH handle call becomes a candidate for inlining
 940     ciMethod* callee = cg-&gt;method();
 941     vmIntrinsics::ID iid = callee-&gt;intrinsic_id();
 942     if (iid == vmIntrinsics::_invokeBasic) {
 943       if (in(TypeFunc::Parms)-&gt;Opcode() == Op_ConP) {
 944         phase-&gt;C-&gt;prepend_late_inline(cg);
 945         set_generator(NULL);
 946       }
 947     } else {
 948       assert(callee-&gt;has_member_arg(), &quot;wrong type of call?&quot;);
 949       if (in(TypeFunc::Parms + callee-&gt;arg_size() - 1)-&gt;Opcode() == Op_ConP) {
 950         phase-&gt;C-&gt;prepend_late_inline(cg);
 951         set_generator(NULL);
 952       }
 953     }
 954   }
 955   return SafePointNode::Ideal(phase, can_reshape);
 956 }
 957 
 958 bool CallNode::is_call_to_arraycopystub() const {
 959   if (_name != NULL &amp;&amp; strstr(_name, &quot;arraycopy&quot;) != 0) {
 960     return true;
 961   }
 962   return false;
 963 }
 964 
 965 //=============================================================================
 966 uint CallJavaNode::size_of() const { return sizeof(*this); }
 967 bool CallJavaNode::cmp( const Node &amp;n ) const {
 968   CallJavaNode &amp;call = (CallJavaNode&amp;)n;
 969   return CallNode::cmp(call) &amp;&amp; _method == call._method &amp;&amp;
 970          _override_symbolic_info == call._override_symbolic_info;
 971 }
 972 #ifdef ASSERT
 973 bool CallJavaNode::validate_symbolic_info() const {
 974   if (method() == NULL) {
 975     return true; // call into runtime or uncommon trap
 976   }
 977   ciMethod* symbolic_info = jvms()-&gt;method()-&gt;get_method_at_bci(_bci);
 978   ciMethod* callee = method();
 979   if (symbolic_info-&gt;is_method_handle_intrinsic() &amp;&amp; !callee-&gt;is_method_handle_intrinsic()) {
 980     assert(override_symbolic_info(), &quot;should be set&quot;);
 981   }
 982   assert(ciMethod::is_consistent_info(symbolic_info, callee), &quot;inconsistent info&quot;);
 983   return true;
 984 }
 985 #endif
 986 
 987 #ifndef PRODUCT
 988 void CallJavaNode::dump_spec(outputStream *st) const {
 989   if( _method ) _method-&gt;print_short_name(st);
 990   CallNode::dump_spec(st);
 991 }
 992 
 993 void CallJavaNode::dump_compact_spec(outputStream* st) const {
 994   if (_method) {
 995     _method-&gt;print_short_name(st);
 996   } else {
 997     st-&gt;print(&quot;&lt;?&gt;&quot;);
 998   }
 999 }
1000 #endif
1001 
1002 //=============================================================================
1003 uint CallStaticJavaNode::size_of() const { return sizeof(*this); }
1004 bool CallStaticJavaNode::cmp( const Node &amp;n ) const {
1005   CallStaticJavaNode &amp;call = (CallStaticJavaNode&amp;)n;
1006   return CallJavaNode::cmp(call);
1007 }
1008 
1009 //----------------------------uncommon_trap_request----------------------------
1010 // If this is an uncommon trap, return the request code, else zero.
1011 int CallStaticJavaNode::uncommon_trap_request() const {
1012   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
1013     return extract_uncommon_trap_request(this);
1014   }
1015   return 0;
1016 }
1017 int CallStaticJavaNode::extract_uncommon_trap_request(const Node* call) {
1018 #ifndef PRODUCT
1019   if (!(call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
1020         call-&gt;in(TypeFunc::Parms) != NULL &amp;&amp;
1021         call-&gt;in(TypeFunc::Parms)-&gt;is_Con() &amp;&amp;
1022         call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;isa_int())) {
1023     assert(in_dump() != 0, &quot;OK if dumping&quot;);
1024     tty-&gt;print(&quot;[bad uncommon trap]&quot;);
1025     return 0;
1026   }
1027 #endif
1028   return call-&gt;in(TypeFunc::Parms)-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
1029 }
1030 
1031 #ifndef PRODUCT
1032 void CallStaticJavaNode::dump_spec(outputStream *st) const {
1033   st-&gt;print(&quot;# Static &quot;);
1034   if (_name != NULL) {
1035     st-&gt;print(&quot;%s&quot;, _name);
1036     int trap_req = uncommon_trap_request();
1037     if (trap_req != 0) {
1038       char buf[100];
1039       st-&gt;print(&quot;(%s)&quot;,
1040                  Deoptimization::format_trap_request(buf, sizeof(buf),
1041                                                      trap_req));
1042     }
1043     st-&gt;print(&quot; &quot;);
1044   }
1045   CallJavaNode::dump_spec(st);
1046 }
1047 
1048 void CallStaticJavaNode::dump_compact_spec(outputStream* st) const {
1049   if (_method) {
1050     _method-&gt;print_short_name(st);
1051   } else if (_name) {
1052     st-&gt;print(&quot;%s&quot;, _name);
1053   } else {
1054     st-&gt;print(&quot;&lt;?&gt;&quot;);
1055   }
1056 }
1057 #endif
1058 
1059 //=============================================================================
1060 uint CallDynamicJavaNode::size_of() const { return sizeof(*this); }
1061 bool CallDynamicJavaNode::cmp( const Node &amp;n ) const {
1062   CallDynamicJavaNode &amp;call = (CallDynamicJavaNode&amp;)n;
1063   return CallJavaNode::cmp(call);
1064 }
1065 #ifndef PRODUCT
1066 void CallDynamicJavaNode::dump_spec(outputStream *st) const {
1067   st-&gt;print(&quot;# Dynamic &quot;);
1068   CallJavaNode::dump_spec(st);
1069 }
1070 #endif
1071 
1072 //=============================================================================
1073 uint CallRuntimeNode::size_of() const { return sizeof(*this); }
1074 bool CallRuntimeNode::cmp( const Node &amp;n ) const {
1075   CallRuntimeNode &amp;call = (CallRuntimeNode&amp;)n;
1076   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
1077 }
1078 #ifndef PRODUCT
1079 void CallRuntimeNode::dump_spec(outputStream *st) const {
1080   st-&gt;print(&quot;# &quot;);
1081   st-&gt;print(&quot;%s&quot;, _name);
1082   CallNode::dump_spec(st);
1083 }
1084 #endif
1085 
1086 //=============================================================================
1087 uint CallNativeNode::size_of() const { return sizeof(*this); }
1088 bool CallNativeNode::cmp( const Node &amp;n ) const {
1089   CallNativeNode &amp;call = (CallNativeNode&amp;)n;
1090   return CallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name)
1091     &amp;&amp; _arg_regs == call._arg_regs &amp;&amp; _ret_regs == call._ret_regs;
1092 }
1093 Node* CallNativeNode::match(const ProjNode *proj, const Matcher *matcher) {
1094   switch (proj-&gt;_con) {
1095     case TypeFunc::Control:
1096     case TypeFunc::I_O:
1097     case TypeFunc::Memory:
1098       return new MachProjNode(this,proj-&gt;_con,RegMask::Empty,MachProjNode::unmatched_proj);
1099     case TypeFunc::ReturnAdr:
1100     case TypeFunc::FramePtr:
1101       ShouldNotReachHere();
1102     case TypeFunc::Parms:
1103     default: {
1104       if(tf()-&gt;range()-&gt;field_at(proj-&gt;_con) == Type::HALF) {
1105         assert(_ret_regs.at(proj-&gt;_con - TypeFunc::Parms) == VMRegImpl::Bad(), &quot;Unexpected register for Type::HALF&quot;);
1106         // 2nd half of doubles and longs
1107         return new MachProjNode(this,proj-&gt;_con, RegMask::Empty, (uint)OptoReg::Bad);
1108       }
1109 
1110       const BasicType bt = tf()-&gt;range()-&gt;field_at(proj-&gt;_con)-&gt;basic_type();
1111       OptoReg::Name optoreg = OptoReg::as_OptoReg(_ret_regs.at(proj-&gt;_con - TypeFunc::Parms));
1112       OptoRegPair regs;
1113       if (bt == T_DOUBLE || bt == T_LONG) {
1114         regs.set2(optoreg);
1115       } else {
1116         regs.set1(optoreg);
1117       }
1118       RegMask rm = RegMask(regs.first());
1119       if( OptoReg::is_valid(regs.second()) )
1120         rm.Insert( regs.second() );
1121       return new MachProjNode(this,proj-&gt;_con,rm,tf()-&gt;range()-&gt;field_at(proj-&gt;_con)-&gt;ideal_reg());
1122     }
1123   }
1124   return NULL;
1125 }
1126 #ifndef PRODUCT
1127 void CallNativeNode::dump_spec(outputStream *st) const {
1128   st-&gt;print(&quot;# &quot;);
1129   st-&gt;print(&quot;%s &quot;, _name);
1130   st-&gt;print(&quot;_arg_regs: &quot;);
1131   _arg_regs.print_on(st);
1132   st-&gt;print(&quot;_ret_regs: &quot;);
1133   _ret_regs.print_on(st);
1134   CallNode::dump_spec(st);
1135 }
1136 #endif
1137 
1138 //------------------------------calling_convention-----------------------------
1139 void CallRuntimeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1140   Matcher::c_calling_convention( sig_bt, parm_regs, argcnt );
1141 }
1142 
1143 void CallNativeNode::calling_convention( BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt ) const {
1144   assert((tf()-&gt;domain()-&gt;cnt() - TypeFunc::Parms) == argcnt, &quot;arg counts must match!&quot;);
1145 #ifndef PRODUCT
1146   for (uint i = 0; i &lt; argcnt; i++) {
1147     assert(tf()-&gt;domain()-&gt;field_at(TypeFunc::Parms + i)-&gt;basic_type() == sig_bt[i], &quot;types must match!&quot;);
1148   }
1149 #endif
1150   for (uint i = 0; i &lt; argcnt; i++) {
1151     switch (sig_bt[i]) {
1152       case T_BOOLEAN:
1153       case T_CHAR:
1154       case T_BYTE:
1155       case T_SHORT:
1156       case T_INT:
1157       case T_FLOAT:
1158         parm_regs[i].set1(_arg_regs.at(i));
1159         break;
1160       case T_LONG:
1161       case T_DOUBLE:
1162         assert((i + 1) &lt; argcnt &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1163         parm_regs[i].set2(_arg_regs.at(i));
1164         break;
1165       case T_VOID: // Halves of longs and doubles
1166         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
1167         assert(_arg_regs.at(i) == VMRegImpl::Bad(), &quot;expecting bad reg&quot;);
1168         parm_regs[i].set_bad();
1169         break;
1170       default:
1171         ShouldNotReachHere();
1172         break;
1173     }
1174   }
1175 }
1176 
1177 //=============================================================================
1178 //------------------------------calling_convention-----------------------------
1179 
1180 
1181 //=============================================================================
1182 #ifndef PRODUCT
1183 void CallLeafNode::dump_spec(outputStream *st) const {
1184   st-&gt;print(&quot;# &quot;);
1185   st-&gt;print(&quot;%s&quot;, _name);
1186   CallNode::dump_spec(st);
1187 }
1188 #endif
1189 
1190 //=============================================================================
1191 
1192 void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {
1193   assert(verify_jvms(jvms), &quot;jvms must match&quot;);
1194   int loc = jvms-&gt;locoff() + idx;
1195   if (in(loc)-&gt;is_top() &amp;&amp; idx &gt; 0 &amp;&amp; !c-&gt;is_top() ) {
1196     // If current local idx is top then local idx - 1 could
1197     // be a long/double that needs to be killed since top could
1198     // represent the 2nd half ofthe long/double.
1199     uint ideal = in(loc -1)-&gt;ideal_reg();
1200     if (ideal == Op_RegD || ideal == Op_RegL) {
1201       // set other (low index) half to top
1202       set_req(loc - 1, in(loc));
1203     }
1204   }
1205   set_req(loc, c);
1206 }
1207 
1208 uint SafePointNode::size_of() const { return sizeof(*this); }
1209 bool SafePointNode::cmp( const Node &amp;n ) const {
1210   return (&amp;n == this);          // Always fail except on self
1211 }
1212 
1213 //-------------------------set_next_exception----------------------------------
1214 void SafePointNode::set_next_exception(SafePointNode* n) {
1215   assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;correct value for next_exception&quot;);
1216   if (len() == req()) {
1217     if (n != NULL)  add_prec(n);
1218   } else {
1219     set_prec(req(), n);
1220   }
1221 }
1222 
1223 
1224 //----------------------------next_exception-----------------------------------
1225 SafePointNode* SafePointNode::next_exception() const {
1226   if (len() == req()) {
1227     return NULL;
1228   } else {
1229     Node* n = in(req());
1230     assert(n == NULL || n-&gt;Opcode() == Op_SafePoint, &quot;no other uses of prec edges&quot;);
1231     return (SafePointNode*) n;
1232   }
1233 }
1234 
1235 
1236 //------------------------------Ideal------------------------------------------
1237 // Skip over any collapsed Regions
1238 Node *SafePointNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1239   return remove_dead_region(phase, can_reshape) ? this : NULL;
1240 }
1241 
1242 //------------------------------Identity---------------------------------------
1243 // Remove obviously duplicate safepoints
1244 Node* SafePointNode::Identity(PhaseGVN* phase) {
1245 
1246   // If you have back to back safepoints, remove one
1247   if( in(TypeFunc::Control)-&gt;is_SafePoint() )
1248     return in(TypeFunc::Control);
1249 
1250   if( in(0)-&gt;is_Proj() ) {
1251     Node *n0 = in(0)-&gt;in(0);
1252     // Check if he is a call projection (except Leaf Call)
1253     if( n0-&gt;is_Catch() ) {
1254       n0 = n0-&gt;in(0)-&gt;in(0);
1255       assert( n0-&gt;is_Call(), &quot;expect a call here&quot; );
1256     }
1257     if( n0-&gt;is_Call() &amp;&amp; n0-&gt;as_Call()-&gt;guaranteed_safepoint() ) {
1258       // Don&#39;t remove a safepoint belonging to an OuterStripMinedLoopEndNode.
1259       // If the loop dies, they will be removed together.
1260       if (has_out_with(Op_OuterStripMinedLoopEnd)) {
1261         return this;
1262       }
1263       // Useless Safepoint, so remove it
1264       return in(TypeFunc::Control);
1265     }
1266   }
1267 
1268   return this;
1269 }
1270 
1271 //------------------------------Value------------------------------------------
1272 const Type* SafePointNode::Value(PhaseGVN* phase) const {
1273   if( phase-&gt;type(in(0)) == Type::TOP ) return Type::TOP;
1274   if( phase-&gt;eqv( in(0), this ) ) return Type::TOP; // Dead infinite loop
1275   return Type::CONTROL;
1276 }
1277 
1278 #ifndef PRODUCT
1279 void SafePointNode::dump_spec(outputStream *st) const {
1280   st-&gt;print(&quot; SafePoint &quot;);
1281   _replaced_nodes.dump(st);
1282 }
1283 
1284 // The related nodes of a SafepointNode are all data inputs, excluding the
1285 // control boundary, as well as all outputs till level 2 (to include projection
1286 // nodes and targets). In compact mode, just include inputs till level 1 and
1287 // outputs as before.
1288 void SafePointNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1289   if (compact) {
1290     this-&gt;collect_nodes(in_rel, 1, false, false);
1291   } else {
1292     this-&gt;collect_nodes_in_all_data(in_rel, false);
1293   }
1294   this-&gt;collect_nodes(out_rel, -2, false, false);
1295 }
1296 #endif
1297 
1298 const RegMask &amp;SafePointNode::in_RegMask(uint idx) const {
1299   if( idx &lt; TypeFunc::Parms ) return RegMask::Empty;
1300   // Values outside the domain represent debug info
1301   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1302 }
1303 const RegMask &amp;SafePointNode::out_RegMask() const {
1304   return RegMask::Empty;
1305 }
1306 
1307 
1308 void SafePointNode::grow_stack(JVMState* jvms, uint grow_by) {
1309   assert((int)grow_by &gt; 0, &quot;sanity&quot;);
1310   int monoff = jvms-&gt;monoff();
1311   int scloff = jvms-&gt;scloff();
1312   int endoff = jvms-&gt;endoff();
1313   assert(endoff == (int)req(), &quot;no other states or debug info after me&quot;);
1314   Node* top = Compile::current()-&gt;top();
1315   for (uint i = 0; i &lt; grow_by; i++) {
1316     ins_req(monoff, top);
1317   }
1318   jvms-&gt;set_monoff(monoff + grow_by);
1319   jvms-&gt;set_scloff(scloff + grow_by);
1320   jvms-&gt;set_endoff(endoff + grow_by);
1321 }
1322 
1323 void SafePointNode::push_monitor(const FastLockNode *lock) {
1324   // Add a LockNode, which points to both the original BoxLockNode (the
1325   // stack space for the monitor) and the Object being locked.
1326   const int MonitorEdges = 2;
1327   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1328   assert(req() == jvms()-&gt;endoff(), &quot;correct sizing&quot;);
1329   int nextmon = jvms()-&gt;scloff();
1330   if (GenerateSynchronizationCode) {
1331     ins_req(nextmon,   lock-&gt;box_node());
1332     ins_req(nextmon+1, lock-&gt;obj_node());
1333   } else {
1334     Node* top = Compile::current()-&gt;top();
1335     ins_req(nextmon, top);
1336     ins_req(nextmon, top);
1337   }
1338   jvms()-&gt;set_scloff(nextmon + MonitorEdges);
1339   jvms()-&gt;set_endoff(req());
1340 }
1341 
1342 void SafePointNode::pop_monitor() {
1343   // Delete last monitor from debug info
1344   debug_only(int num_before_pop = jvms()-&gt;nof_monitors());
1345   const int MonitorEdges = 2;
1346   assert(JVMState::logMonitorEdges == exact_log2(MonitorEdges), &quot;correct MonitorEdges&quot;);
1347   int scloff = jvms()-&gt;scloff();
1348   int endoff = jvms()-&gt;endoff();
1349   int new_scloff = scloff - MonitorEdges;
1350   int new_endoff = endoff - MonitorEdges;
1351   jvms()-&gt;set_scloff(new_scloff);
1352   jvms()-&gt;set_endoff(new_endoff);
1353   while (scloff &gt; new_scloff)  del_req_ordered(--scloff);
1354   assert(jvms()-&gt;nof_monitors() == num_before_pop-1, &quot;&quot;);
1355 }
1356 
1357 Node *SafePointNode::peek_monitor_box() const {
1358   int mon = jvms()-&gt;nof_monitors() - 1;
1359   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1360   return monitor_box(jvms(), mon);
1361 }
1362 
1363 Node *SafePointNode::peek_monitor_obj() const {
1364   int mon = jvms()-&gt;nof_monitors() - 1;
1365   assert(mon &gt;= 0, &quot;must have a monitor&quot;);
1366   return monitor_obj(jvms(), mon);
1367 }
1368 
1369 // Do we Match on this edge index or not?  Match no edges
1370 uint SafePointNode::match_edge(uint idx) const {
1371   return (TypeFunc::Parms == idx);
1372 }
1373 
1374 void SafePointNode::disconnect_from_root(PhaseIterGVN *igvn) {
1375   assert(Opcode() == Op_SafePoint, &quot;only value for safepoint in loops&quot;);
1376   int nb = igvn-&gt;C-&gt;root()-&gt;find_prec_edge(this);
1377   if (nb != -1) {
1378     igvn-&gt;C-&gt;root()-&gt;rm_prec(nb);
1379   }
1380 }
1381 
1382 //==============  SafePointScalarObjectNode  ==============
1383 
1384 SafePointScalarObjectNode::SafePointScalarObjectNode(const TypeOopPtr* tp,
1385 #ifdef ASSERT
1386                                                      AllocateNode* alloc,
1387 #endif
1388                                                      uint first_index,
1389                                                      uint n_fields) :
1390   TypeNode(tp, 1), // 1 control input -- seems required.  Get from root.
1391   _first_index(first_index),
1392   _n_fields(n_fields)
1393 #ifdef ASSERT
1394   , _alloc(alloc)
1395 #endif
1396 {
1397   init_class_id(Class_SafePointScalarObject);
1398 }
1399 
1400 // Do not allow value-numbering for SafePointScalarObject node.
1401 uint SafePointScalarObjectNode::hash() const { return NO_HASH; }
1402 bool SafePointScalarObjectNode::cmp( const Node &amp;n ) const {
1403   return (&amp;n == this); // Always fail except on self
1404 }
1405 
1406 uint SafePointScalarObjectNode::ideal_reg() const {
1407   return 0; // No matching to machine instruction
1408 }
1409 
1410 const RegMask &amp;SafePointScalarObjectNode::in_RegMask(uint idx) const {
1411   return *(Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()]);
1412 }
1413 
1414 const RegMask &amp;SafePointScalarObjectNode::out_RegMask() const {
1415   return RegMask::Empty;
1416 }
1417 
1418 uint SafePointScalarObjectNode::match_edge(uint idx) const {
1419   return 0;
1420 }
1421 
1422 SafePointScalarObjectNode*
1423 SafePointScalarObjectNode::clone(Dict* sosn_map) const {
1424   void* cached = (*sosn_map)[(void*)this];
1425   if (cached != NULL) {
1426     return (SafePointScalarObjectNode*)cached;
1427   }
1428   SafePointScalarObjectNode* res = (SafePointScalarObjectNode*)Node::clone();
1429   sosn_map-&gt;Insert((void*)this, (void*)res);
1430   return res;
1431 }
1432 
1433 
1434 #ifndef PRODUCT
1435 void SafePointScalarObjectNode::dump_spec(outputStream *st) const {
1436   st-&gt;print(&quot; # fields@[%d..%d]&quot;, first_index(),
1437              first_index() + n_fields() - 1);
1438 }
1439 
1440 #endif
1441 
1442 //=============================================================================
1443 uint AllocateNode::size_of() const { return sizeof(*this); }
1444 
1445 AllocateNode::AllocateNode(Compile* C, const TypeFunc *atype,
1446                            Node *ctrl, Node *mem, Node *abio,
1447                            Node *size, Node *klass_node, Node *initial_test)
1448   : CallNode(atype, NULL, TypeRawPtr::BOTTOM)
1449 {
1450   init_class_id(Class_Allocate);
1451   init_flags(Flag_is_macro);
1452   _is_scalar_replaceable = false;
1453   _is_non_escaping = false;
1454   _is_allocation_MemBar_redundant = false;
1455   Node *topnode = C-&gt;top();
1456 
1457   init_req( TypeFunc::Control  , ctrl );
1458   init_req( TypeFunc::I_O      , abio );
1459   init_req( TypeFunc::Memory   , mem );
1460   init_req( TypeFunc::ReturnAdr, topnode );
1461   init_req( TypeFunc::FramePtr , topnode );
1462   init_req( AllocSize          , size);
1463   init_req( KlassNode          , klass_node);
1464   init_req( InitialTest        , initial_test);
1465   init_req( ALength            , topnode);
1466   C-&gt;add_macro_node(this);
1467 }
1468 
1469 void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)
1470 {
1471   assert(initializer != NULL &amp;&amp;
1472          initializer-&gt;is_initializer() &amp;&amp;
1473          !initializer-&gt;is_static(),
1474              &quot;unexpected initializer method&quot;);
1475   BCEscapeAnalyzer* analyzer = initializer-&gt;get_bcea();
1476   if (analyzer == NULL) {
1477     return;
1478   }
1479 
1480   // Allocation node is first parameter in its initializer
1481   if (analyzer-&gt;is_arg_stack(0) || analyzer-&gt;is_arg_local(0)) {
1482     _is_allocation_MemBar_redundant = true;
1483   }
1484 }
1485 Node *AllocateNode::make_ideal_mark(PhaseGVN *phase, Node* obj, Node* control, Node* mem) {
1486   Node* mark_node = NULL;
1487   // For now only enable fast locking for non-array types
1488   if (UseBiasedLocking &amp;&amp; Opcode() == Op_Allocate) {
1489     Node* klass_node = in(AllocateNode::KlassNode);
1490     Node* proto_adr = phase-&gt;transform(new AddPNode(klass_node, klass_node, phase-&gt;MakeConX(in_bytes(Klass::prototype_header_offset()))));
1491     mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);
1492   } else {
1493     mark_node = phase-&gt;MakeConX(markWord::prototype().value());
1494   }
1495   return mark_node;
1496 }
1497 
1498 //=============================================================================
1499 Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1500   if (remove_dead_region(phase, can_reshape))  return this;
1501   // Don&#39;t bother trying to transform a dead node
1502   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1503 
1504   const Type* type = phase-&gt;type(Ideal_length());
1505   if (type-&gt;isa_int() &amp;&amp; type-&gt;is_int()-&gt;_hi &lt; 0) {
1506     if (can_reshape) {
1507       PhaseIterGVN *igvn = phase-&gt;is_IterGVN();
1508       // Unreachable fall through path (negative array length),
1509       // the allocation can only throw so disconnect it.
1510       Node* proj = proj_out_or_null(TypeFunc::Control);
1511       Node* catchproj = NULL;
1512       if (proj != NULL) {
1513         for (DUIterator_Fast imax, i = proj-&gt;fast_outs(imax); i &lt; imax; i++) {
1514           Node *cn = proj-&gt;fast_out(i);
1515           if (cn-&gt;is_Catch()) {
1516             catchproj = cn-&gt;as_Multi()-&gt;proj_out_or_null(CatchProjNode::fall_through_index);
1517             break;
1518           }
1519         }
1520       }
1521       if (catchproj != NULL &amp;&amp; catchproj-&gt;outcnt() &gt; 0 &amp;&amp;
1522           (catchproj-&gt;outcnt() &gt; 1 ||
1523            catchproj-&gt;unique_out()-&gt;Opcode() != Op_Halt)) {
1524         assert(catchproj-&gt;is_CatchProj(), &quot;must be a CatchProjNode&quot;);
1525         Node* nproj = catchproj-&gt;clone();
1526         igvn-&gt;register_new_node_with_optimizer(nproj);
1527 
1528         Node *frame = new ParmNode( phase-&gt;C-&gt;start(), TypeFunc::FramePtr );
1529         frame = phase-&gt;transform(frame);
1530         // Halt &amp; Catch Fire
1531         Node* halt = new HaltNode(nproj, frame, &quot;unexpected negative array length&quot;);
1532         phase-&gt;C-&gt;root()-&gt;add_req(halt);
1533         phase-&gt;transform(halt);
1534 
1535         igvn-&gt;replace_node(catchproj, phase-&gt;C-&gt;top());
1536         return this;
1537       }
1538     } else {
1539       // Can&#39;t correct it during regular GVN so register for IGVN
1540       phase-&gt;C-&gt;record_for_igvn(this);
1541     }
1542   }
1543   return NULL;
1544 }
1545 
1546 // Retrieve the length from the AllocateArrayNode. Narrow the type with a
1547 // CastII, if appropriate.  If we are not allowed to create new nodes, and
1548 // a CastII is appropriate, return NULL.
1549 Node *AllocateArrayNode::make_ideal_length(const TypeOopPtr* oop_type, PhaseTransform *phase, bool allow_new_nodes) {
1550   Node *length = in(AllocateNode::ALength);
1551   assert(length != NULL, &quot;length is not null&quot;);
1552 
1553   const TypeInt* length_type = phase-&gt;find_int_type(length);
1554   const TypeAryPtr* ary_type = oop_type-&gt;isa_aryptr();
1555 
1556   if (ary_type != NULL &amp;&amp; length_type != NULL) {
1557     const TypeInt* narrow_length_type = ary_type-&gt;narrow_size_type(length_type);
1558     if (narrow_length_type != length_type) {
1559       // Assert one of:
1560       //   - the narrow_length is 0
1561       //   - the narrow_length is not wider than length
1562       assert(narrow_length_type == TypeInt::ZERO ||
1563              length_type-&gt;is_con() &amp;&amp; narrow_length_type-&gt;is_con() &amp;&amp;
1564                 (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_lo) ||
1565              (narrow_length_type-&gt;_hi &lt;= length_type-&gt;_hi &amp;&amp;
1566               narrow_length_type-&gt;_lo &gt;= length_type-&gt;_lo),
1567              &quot;narrow type must be narrower than length type&quot;);
1568 
1569       // Return NULL if new nodes are not allowed
1570       if (!allow_new_nodes) return NULL;
1571       // Create a cast which is control dependent on the initialization to
1572       // propagate the fact that the array length must be positive.
1573       InitializeNode* init = initialization();
1574       assert(init != NULL, &quot;initialization not found&quot;);
1575       length = new CastIINode(length, narrow_length_type);
1576       length-&gt;set_req(0, init-&gt;proj_out_or_null(0));
1577     }
1578   }
1579 
1580   return length;
1581 }
1582 
1583 //=============================================================================
1584 uint LockNode::size_of() const { return sizeof(*this); }
1585 
1586 // Redundant lock elimination
1587 //
1588 // There are various patterns of locking where we release and
1589 // immediately reacquire a lock in a piece of code where no operations
1590 // occur in between that would be observable.  In those cases we can
1591 // skip releasing and reacquiring the lock without violating any
1592 // fairness requirements.  Doing this around a loop could cause a lock
1593 // to be held for a very long time so we concentrate on non-looping
1594 // control flow.  We also require that the operations are fully
1595 // redundant meaning that we don&#39;t introduce new lock operations on
1596 // some paths so to be able to eliminate it on others ala PRE.  This
1597 // would probably require some more extensive graph manipulation to
1598 // guarantee that the memory edges were all handled correctly.
1599 //
1600 // Assuming p is a simple predicate which can&#39;t trap in any way and s
1601 // is a synchronized method consider this code:
1602 //
1603 //   s();
1604 //   if (p)
1605 //     s();
1606 //   else
1607 //     s();
1608 //   s();
1609 //
1610 // 1. The unlocks of the first call to s can be eliminated if the
1611 // locks inside the then and else branches are eliminated.
1612 //
1613 // 2. The unlocks of the then and else branches can be eliminated if
1614 // the lock of the final call to s is eliminated.
1615 //
1616 // Either of these cases subsumes the simple case of sequential control flow
1617 //
1618 // Addtionally we can eliminate versions without the else case:
1619 //
1620 //   s();
1621 //   if (p)
1622 //     s();
1623 //   s();
1624 //
1625 // 3. In this case we eliminate the unlock of the first s, the lock
1626 // and unlock in the then case and the lock in the final s.
1627 //
1628 // Note also that in all these cases the then/else pieces don&#39;t have
1629 // to be trivial as long as they begin and end with synchronization
1630 // operations.
1631 //
1632 //   s();
1633 //   if (p)
1634 //     s();
1635 //     f();
1636 //     s();
1637 //   s();
1638 //
1639 // The code will work properly for this case, leaving in the unlock
1640 // before the call to f and the relock after it.
1641 //
1642 // A potentially interesting case which isn&#39;t handled here is when the
1643 // locking is partially redundant.
1644 //
1645 //   s();
1646 //   if (p)
1647 //     s();
1648 //
1649 // This could be eliminated putting unlocking on the else case and
1650 // eliminating the first unlock and the lock in the then side.
1651 // Alternatively the unlock could be moved out of the then side so it
1652 // was after the merge and the first unlock and second lock
1653 // eliminated.  This might require less manipulation of the memory
1654 // state to get correct.
1655 //
1656 // Additionally we might allow work between a unlock and lock before
1657 // giving up eliminating the locks.  The current code disallows any
1658 // conditional control flow between these operations.  A formulation
1659 // similar to partial redundancy elimination computing the
1660 // availability of unlocking and the anticipatability of locking at a
1661 // program point would allow detection of fully redundant locking with
1662 // some amount of work in between.  I&#39;m not sure how often I really
1663 // think that would occur though.  Most of the cases I&#39;ve seen
1664 // indicate it&#39;s likely non-trivial work would occur in between.
1665 // There may be other more complicated constructs where we could
1666 // eliminate locking but I haven&#39;t seen any others appear as hot or
1667 // interesting.
1668 //
1669 // Locking and unlocking have a canonical form in ideal that looks
1670 // roughly like this:
1671 //
1672 //              &lt;obj&gt;
1673 //                | \\------+
1674 //                |  \       \
1675 //                | BoxLock   \
1676 //                |  |   |     \
1677 //                |  |    \     \
1678 //                |  |   FastLock
1679 //                |  |   /
1680 //                |  |  /
1681 //                |  |  |
1682 //
1683 //               Lock
1684 //                |
1685 //            Proj #0
1686 //                |
1687 //            MembarAcquire
1688 //                |
1689 //            Proj #0
1690 //
1691 //            MembarRelease
1692 //                |
1693 //            Proj #0
1694 //                |
1695 //              Unlock
1696 //                |
1697 //            Proj #0
1698 //
1699 //
1700 // This code proceeds by processing Lock nodes during PhaseIterGVN
1701 // and searching back through its control for the proper code
1702 // patterns.  Once it finds a set of lock and unlock operations to
1703 // eliminate they are marked as eliminatable which causes the
1704 // expansion of the Lock and Unlock macro nodes to make the operation a NOP
1705 //
1706 //=============================================================================
1707 
1708 //
1709 // Utility function to skip over uninteresting control nodes.  Nodes skipped are:
1710 //   - copy regions.  (These may not have been optimized away yet.)
1711 //   - eliminated locking nodes
1712 //
1713 static Node *next_control(Node *ctrl) {
1714   if (ctrl == NULL)
1715     return NULL;
1716   while (1) {
1717     if (ctrl-&gt;is_Region()) {
1718       RegionNode *r = ctrl-&gt;as_Region();
1719       Node *n = r-&gt;is_copy();
1720       if (n == NULL)
1721         break;  // hit a region, return it
1722       else
1723         ctrl = n;
1724     } else if (ctrl-&gt;is_Proj()) {
1725       Node *in0 = ctrl-&gt;in(0);
1726       if (in0-&gt;is_AbstractLock() &amp;&amp; in0-&gt;as_AbstractLock()-&gt;is_eliminated()) {
1727         ctrl = in0-&gt;in(0);
1728       } else {
1729         break;
1730       }
1731     } else {
1732       break; // found an interesting control
1733     }
1734   }
1735   return ctrl;
1736 }
1737 //
1738 // Given a control, see if it&#39;s the control projection of an Unlock which
1739 // operating on the same object as lock.
1740 //
1741 bool AbstractLockNode::find_matching_unlock(const Node* ctrl, LockNode* lock,
1742                                             GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1743   ProjNode *ctrl_proj = (ctrl-&gt;is_Proj()) ? ctrl-&gt;as_Proj() : NULL;
1744   if (ctrl_proj != NULL &amp;&amp; ctrl_proj-&gt;_con == TypeFunc::Control) {
1745     Node *n = ctrl_proj-&gt;in(0);
1746     if (n != NULL &amp;&amp; n-&gt;is_Unlock()) {
1747       UnlockNode *unlock = n-&gt;as_Unlock();
1748       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1749       Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1750       Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1751       if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1752           BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node()) &amp;&amp;
1753           !unlock-&gt;is_eliminated()) {
1754         lock_ops.append(unlock);
1755         return true;
1756       }
1757     }
1758   }
1759   return false;
1760 }
1761 
1762 //
1763 // Find the lock matching an unlock.  Returns null if a safepoint
1764 // or complicated control is encountered first.
1765 LockNode *AbstractLockNode::find_matching_lock(UnlockNode* unlock) {
1766   LockNode *lock_result = NULL;
1767   // find the matching lock, or an intervening safepoint
1768   Node *ctrl = next_control(unlock-&gt;in(0));
1769   while (1) {
1770     assert(ctrl != NULL, &quot;invalid control graph&quot;);
1771     assert(!ctrl-&gt;is_Start(), &quot;missing lock for unlock&quot;);
1772     if (ctrl-&gt;is_top()) break;  // dead control path
1773     if (ctrl-&gt;is_Proj()) ctrl = ctrl-&gt;in(0);
1774     if (ctrl-&gt;is_SafePoint()) {
1775         break;  // found a safepoint (may be the lock we are searching for)
1776     } else if (ctrl-&gt;is_Region()) {
1777       // Check for a simple diamond pattern.  Punt on anything more complicated
1778       if (ctrl-&gt;req() == 3 &amp;&amp; ctrl-&gt;in(1) != NULL &amp;&amp; ctrl-&gt;in(2) != NULL) {
1779         Node *in1 = next_control(ctrl-&gt;in(1));
1780         Node *in2 = next_control(ctrl-&gt;in(2));
1781         if (((in1-&gt;is_IfTrue() &amp;&amp; in2-&gt;is_IfFalse()) ||
1782              (in2-&gt;is_IfTrue() &amp;&amp; in1-&gt;is_IfFalse())) &amp;&amp; (in1-&gt;in(0) == in2-&gt;in(0))) {
1783           ctrl = next_control(in1-&gt;in(0)-&gt;in(0));
1784         } else {
1785           break;
1786         }
1787       } else {
1788         break;
1789       }
1790     } else {
1791       ctrl = next_control(ctrl-&gt;in(0));  // keep searching
1792     }
1793   }
1794   if (ctrl-&gt;is_Lock()) {
1795     LockNode *lock = ctrl-&gt;as_Lock();
1796     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1797     Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1798     Node* unlock_obj = bs-&gt;step_over_gc_barrier(unlock-&gt;obj_node());
1799     if (lock_obj-&gt;eqv_uncast(unlock_obj) &amp;&amp;
1800         BoxLockNode::same_slot(lock-&gt;box_node(), unlock-&gt;box_node())) {
1801       lock_result = lock;
1802     }
1803   }
1804   return lock_result;
1805 }
1806 
1807 // This code corresponds to case 3 above.
1808 
1809 bool AbstractLockNode::find_lock_and_unlock_through_if(Node* node, LockNode* lock,
1810                                                        GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1811   Node* if_node = node-&gt;in(0);
1812   bool  if_true = node-&gt;is_IfTrue();
1813 
1814   if (if_node-&gt;is_If() &amp;&amp; if_node-&gt;outcnt() == 2 &amp;&amp; (if_true || node-&gt;is_IfFalse())) {
1815     Node *lock_ctrl = next_control(if_node-&gt;in(0));
1816     if (find_matching_unlock(lock_ctrl, lock, lock_ops)) {
1817       Node* lock1_node = NULL;
1818       ProjNode* proj = if_node-&gt;as_If()-&gt;proj_out(!if_true);
1819       if (if_true) {
1820         if (proj-&gt;is_IfFalse() &amp;&amp; proj-&gt;outcnt() == 1) {
1821           lock1_node = proj-&gt;unique_out();
1822         }
1823       } else {
1824         if (proj-&gt;is_IfTrue() &amp;&amp; proj-&gt;outcnt() == 1) {
1825           lock1_node = proj-&gt;unique_out();
1826         }
1827       }
1828       if (lock1_node != NULL &amp;&amp; lock1_node-&gt;is_Lock()) {
1829         LockNode *lock1 = lock1_node-&gt;as_Lock();
1830         BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1831         Node* lock_obj = bs-&gt;step_over_gc_barrier(lock-&gt;obj_node());
1832         Node* lock1_obj = bs-&gt;step_over_gc_barrier(lock1-&gt;obj_node());
1833         if (lock_obj-&gt;eqv_uncast(lock1_obj) &amp;&amp;
1834             BoxLockNode::same_slot(lock-&gt;box_node(), lock1-&gt;box_node()) &amp;&amp;
1835             !lock1-&gt;is_eliminated()) {
1836           lock_ops.append(lock1);
1837           return true;
1838         }
1839       }
1840     }
1841   }
1842 
1843   lock_ops.trunc_to(0);
1844   return false;
1845 }
1846 
1847 bool AbstractLockNode::find_unlocks_for_region(const RegionNode* region, LockNode* lock,
1848                                GrowableArray&lt;AbstractLockNode*&gt; &amp;lock_ops) {
1849   // check each control merging at this point for a matching unlock.
1850   // in(0) should be self edge so skip it.
1851   for (int i = 1; i &lt; (int)region-&gt;req(); i++) {
1852     Node *in_node = next_control(region-&gt;in(i));
1853     if (in_node != NULL) {
1854       if (find_matching_unlock(in_node, lock, lock_ops)) {
1855         // found a match so keep on checking.
1856         continue;
1857       } else if (find_lock_and_unlock_through_if(in_node, lock, lock_ops)) {
1858         continue;
1859       }
1860 
1861       // If we fall through to here then it was some kind of node we
1862       // don&#39;t understand or there wasn&#39;t a matching unlock, so give
1863       // up trying to merge locks.
1864       lock_ops.trunc_to(0);
1865       return false;
1866     }
1867   }
1868   return true;
1869 
1870 }
1871 
1872 #ifndef PRODUCT
1873 //
1874 // Create a counter which counts the number of times this lock is acquired
1875 //
1876 void AbstractLockNode::create_lock_counter(JVMState* state) {
1877   _counter = OptoRuntime::new_named_counter(state, NamedCounter::LockCounter);
1878 }
1879 
1880 void AbstractLockNode::set_eliminated_lock_counter() {
1881   if (_counter) {
1882     // Update the counter to indicate that this lock was eliminated.
1883     // The counter update code will stay around even though the
1884     // optimizer will eliminate the lock operation itself.
1885     _counter-&gt;set_tag(NamedCounter::EliminatedLockCounter);
1886   }
1887 }
1888 
1889 const char* AbstractLockNode::_kind_names[] = {&quot;Regular&quot;, &quot;NonEscObj&quot;, &quot;Coarsened&quot;, &quot;Nested&quot;};
1890 
1891 void AbstractLockNode::dump_spec(outputStream* st) const {
1892   st-&gt;print(&quot;%s &quot;, _kind_names[_kind]);
1893   CallNode::dump_spec(st);
1894 }
1895 
1896 void AbstractLockNode::dump_compact_spec(outputStream* st) const {
1897   st-&gt;print(&quot;%s&quot;, _kind_names[_kind]);
1898 }
1899 
1900 // The related set of lock nodes includes the control boundary.
1901 void AbstractLockNode::related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const {
1902   if (compact) {
1903       this-&gt;collect_nodes(in_rel, 1, false, false);
1904     } else {
1905       this-&gt;collect_nodes_in_all_data(in_rel, true);
1906     }
1907     this-&gt;collect_nodes(out_rel, -2, false, false);
1908 }
1909 #endif
1910 
1911 //=============================================================================
1912 Node *LockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1913 
1914   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
1915   Node *result = SafePointNode::Ideal(phase, can_reshape);
1916   if (result != NULL)  return result;
1917   // Don&#39;t bother trying to transform a dead node
1918   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
1919 
1920   // Now see if we can optimize away this lock.  We don&#39;t actually
1921   // remove the locking here, we simply set the _eliminate flag which
1922   // prevents macro expansion from expanding the lock.  Since we don&#39;t
1923   // modify the graph, the value returned from this function is the
1924   // one computed above.
1925   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
1926     //
1927     // If we are locking an unescaped object, the lock/unlock is unnecessary
1928     //
1929     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
1930     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
1931       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
1932       // The lock could be marked eliminated by lock coarsening
1933       // code during first IGVN before EA. Replace coarsened flag
1934       // to eliminate all associated locks/unlocks.
1935 #ifdef ASSERT
1936       this-&gt;log_lock_optimization(phase-&gt;C,&quot;eliminate_lock_set_non_esc1&quot;);
1937 #endif
1938       this-&gt;set_non_esc_obj();
1939       return result;
1940     }
1941 
1942     //
1943     // Try lock coarsening
1944     //
1945     PhaseIterGVN* iter = phase-&gt;is_IterGVN();
1946     if (iter != NULL &amp;&amp; !is_eliminated()) {
1947 
1948       GrowableArray&lt;AbstractLockNode*&gt;   lock_ops;
1949 
1950       Node *ctrl = next_control(in(0));
1951 
1952       // now search back for a matching Unlock
1953       if (find_matching_unlock(ctrl, this, lock_ops)) {
1954         // found an unlock directly preceding this lock.  This is the
1955         // case of single unlock directly control dependent on a
1956         // single lock which is the trivial version of case 1 or 2.
1957       } else if (ctrl-&gt;is_Region() ) {
1958         if (find_unlocks_for_region(ctrl-&gt;as_Region(), this, lock_ops)) {
1959         // found lock preceded by multiple unlocks along all paths
1960         // joining at this point which is case 3 in description above.
1961         }
1962       } else {
1963         // see if this lock comes from either half of an if and the
1964         // predecessors merges unlocks and the other half of the if
1965         // performs a lock.
1966         if (find_lock_and_unlock_through_if(ctrl, this, lock_ops)) {
1967           // found unlock splitting to an if with locks on both branches.
1968         }
1969       }
1970 
1971       if (lock_ops.length() &gt; 0) {
1972         // add ourselves to the list of locks to be eliminated.
1973         lock_ops.append(this);
1974 
1975   #ifndef PRODUCT
1976         if (PrintEliminateLocks) {
1977           int locks = 0;
1978           int unlocks = 0;
1979           for (int i = 0; i &lt; lock_ops.length(); i++) {
1980             AbstractLockNode* lock = lock_ops.at(i);
1981             if (lock-&gt;Opcode() == Op_Lock)
1982               locks++;
1983             else
1984               unlocks++;
1985             if (Verbose) {
1986               lock-&gt;dump(1);
1987             }
1988           }
1989           tty-&gt;print_cr(&quot;***Eliminated %d unlocks and %d locks&quot;, unlocks, locks);
1990         }
1991   #endif
1992 
1993         // for each of the identified locks, mark them
1994         // as eliminatable
1995         for (int i = 0; i &lt; lock_ops.length(); i++) {
1996           AbstractLockNode* lock = lock_ops.at(i);
1997 
1998           // Mark it eliminated by coarsening and update any counters
1999 #ifdef ASSERT
2000           lock-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_coarsened&quot;);
2001 #endif
2002           lock-&gt;set_coarsened();
2003         }
2004       } else if (ctrl-&gt;is_Region() &amp;&amp;
2005                  iter-&gt;_worklist.member(ctrl)) {
2006         // We weren&#39;t able to find any opportunities but the region this
2007         // lock is control dependent on hasn&#39;t been processed yet so put
2008         // this lock back on the worklist so we can check again once any
2009         // region simplification has occurred.
2010         iter-&gt;_worklist.push(this);
2011       }
2012     }
2013   }
2014 
2015   return result;
2016 }
2017 
2018 //=============================================================================
2019 bool LockNode::is_nested_lock_region() {
2020   return is_nested_lock_region(NULL);
2021 }
2022 
2023 // p is used for access to compilation log; no logging if NULL
2024 bool LockNode::is_nested_lock_region(Compile * c) {
2025   BoxLockNode* box = box_node()-&gt;as_BoxLock();
2026   int stk_slot = box-&gt;stack_slot();
2027   if (stk_slot &lt;= 0) {
2028 #ifdef ASSERT
2029     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_1&quot;);
2030 #endif
2031     return false; // External lock or it is not Box (Phi node).
2032   }
2033 
2034   // Ignore complex cases: merged locks or multiple locks.
2035   Node* obj = obj_node();
2036   LockNode* unique_lock = NULL;
2037   if (!box-&gt;is_simple_lock_region(&amp;unique_lock, obj)) {
2038 #ifdef ASSERT
2039     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2a&quot;);
2040 #endif
2041     return false;
2042   }
2043   if (unique_lock != this) {
2044 #ifdef ASSERT
2045     this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_2b&quot;);
2046 #endif
2047     return false;
2048   }
2049 
2050   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2051   obj = bs-&gt;step_over_gc_barrier(obj);
2052   // Look for external lock for the same object.
2053   SafePointNode* sfn = this-&gt;as_SafePoint();
2054   JVMState* youngest_jvms = sfn-&gt;jvms();
2055   int max_depth = youngest_jvms-&gt;depth();
2056   for (int depth = 1; depth &lt;= max_depth; depth++) {
2057     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
2058     int num_mon  = jvms-&gt;nof_monitors();
2059     // Loop over monitors
2060     for (int idx = 0; idx &lt; num_mon; idx++) {
2061       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
2062       obj_node = bs-&gt;step_over_gc_barrier(obj_node);
2063       BoxLockNode* box_node = sfn-&gt;monitor_box(jvms, idx)-&gt;as_BoxLock();
2064       if ((box_node-&gt;stack_slot() &lt; stk_slot) &amp;&amp; obj_node-&gt;eqv_uncast(obj)) {
2065         return true;
2066       }
2067     }
2068   }
2069 #ifdef ASSERT
2070   this-&gt;log_lock_optimization(c, &quot;eliminate_lock_INLR_3&quot;);
2071 #endif
2072   return false;
2073 }
2074 
2075 //=============================================================================
2076 uint UnlockNode::size_of() const { return sizeof(*this); }
2077 
2078 //=============================================================================
2079 Node *UnlockNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2080 
2081   // perform any generic optimizations first (returns &#39;this&#39; or NULL)
2082   Node *result = SafePointNode::Ideal(phase, can_reshape);
2083   if (result != NULL)  return result;
2084   // Don&#39;t bother trying to transform a dead node
2085   if (in(0) &amp;&amp; in(0)-&gt;is_top())  return NULL;
2086 
2087   // Now see if we can optimize away this unlock.  We don&#39;t actually
2088   // remove the unlocking here, we simply set the _eliminate flag which
2089   // prevents macro expansion from expanding the unlock.  Since we don&#39;t
2090   // modify the graph, the value returned from this function is the
2091   // one computed above.
2092   // Escape state is defined after Parse phase.
2093   if (can_reshape &amp;&amp; EliminateLocks &amp;&amp; !is_non_esc_obj()) {
2094     //
2095     // If we are unlocking an unescaped object, the lock/unlock is unnecessary.
2096     //
2097     ConnectionGraph *cgr = phase-&gt;C-&gt;congraph();
2098     if (cgr != NULL &amp;&amp; cgr-&gt;not_global_escape(obj_node())) {
2099       assert(!is_eliminated() || is_coarsened(), &quot;sanity&quot;);
2100       // The lock could be marked eliminated by lock coarsening
2101       // code during first IGVN before EA. Replace coarsened flag
2102       // to eliminate all associated locks/unlocks.
2103 #ifdef ASSERT
2104       this-&gt;log_lock_optimization(phase-&gt;C, &quot;eliminate_lock_set_non_esc2&quot;);
2105 #endif
2106       this-&gt;set_non_esc_obj();
2107     }
2108   }
2109   return result;
2110 }
2111 
2112 const char * AbstractLockNode::kind_as_string() const {
2113   return is_coarsened()   ? &quot;coarsened&quot; :
2114          is_nested()      ? &quot;nested&quot; :
2115          is_non_esc_obj() ? &quot;non_escaping&quot; :
2116          &quot;?&quot;;
2117 }
2118 
2119 void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {
2120   if (C == NULL) {
2121     return;
2122   }
2123   CompileLog* log = C-&gt;log();
2124   if (log != NULL) {
2125     log-&gt;begin_head(&quot;%s lock=&#39;%d&#39; compile_id=&#39;%d&#39; class_id=&#39;%s&#39; kind=&#39;%s&#39;&quot;,
2126           tag, is_Lock(), C-&gt;compile_id(),
2127           is_Unlock() ? &quot;unlock&quot; : is_Lock() ? &quot;lock&quot; : &quot;?&quot;,
2128           kind_as_string());
2129     log-&gt;stamp();
2130     log-&gt;end_head();
2131     JVMState* p = is_Unlock() ? (as_Unlock()-&gt;dbg_jvms()) : jvms();
2132     while (p != NULL) {
2133       log-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log-&gt;identify(p-&gt;method()));
2134       p = p-&gt;caller();
2135     }
2136     log-&gt;tail(tag);
2137   }
2138 }
2139 
2140 bool CallNode::may_modify_arraycopy_helper(const TypeOopPtr* dest_t, const TypeOopPtr *t_oop, PhaseTransform *phase) {
2141   if (dest_t-&gt;is_known_instance() &amp;&amp; t_oop-&gt;is_known_instance()) {
2142     return dest_t-&gt;instance_id() == t_oop-&gt;instance_id();
2143   }
2144 
2145   if (dest_t-&gt;isa_instptr() &amp;&amp; !dest_t-&gt;klass()-&gt;equals(phase-&gt;C-&gt;env()-&gt;Object_klass())) {
2146     // clone
2147     if (t_oop-&gt;isa_aryptr()) {
2148       return false;
2149     }
2150     if (!t_oop-&gt;isa_instptr()) {
2151       return true;
2152     }
2153     if (dest_t-&gt;klass()-&gt;is_subtype_of(t_oop-&gt;klass()) || t_oop-&gt;klass()-&gt;is_subtype_of(dest_t-&gt;klass())) {
2154       return true;
2155     }
2156     // unrelated
2157     return false;
2158   }
2159 
2160   if (dest_t-&gt;isa_aryptr()) {
2161     // arraycopy or array clone
2162     if (t_oop-&gt;isa_instptr()) {
2163       return false;
2164     }
2165     if (!t_oop-&gt;isa_aryptr()) {
2166       return true;
2167     }
2168 
2169     const Type* elem = dest_t-&gt;is_aryptr()-&gt;elem();
2170     if (elem == Type::BOTTOM) {
2171       // An array but we don&#39;t know what elements are
2172       return true;
2173     }
2174 
2175     dest_t = dest_t-&gt;add_offset(Type::OffsetBot)-&gt;is_oopptr();
2176     uint dest_alias = phase-&gt;C-&gt;get_alias_index(dest_t);
2177     uint t_oop_alias = phase-&gt;C-&gt;get_alias_index(t_oop);
2178 
2179     return dest_alias == t_oop_alias;
2180   }
2181 
2182   return true;
2183 }
    </pre>
  </body>
</html>
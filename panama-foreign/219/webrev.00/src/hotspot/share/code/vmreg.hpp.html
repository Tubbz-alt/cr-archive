<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/vmreg.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CODE_VMREG_HPP
 26 #define SHARE_CODE_VMREG_HPP
 27 
 28 #include &quot;asm/register.hpp&quot;
 29 #include &quot;runtime/globals.hpp&quot;
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 #include &quot;utilities/macros.hpp&quot;
 32 #include &quot;utilities/ostream.hpp&quot;
 33 #ifdef COMPILER2
 34 #include &quot;opto/adlcVMDeps.hpp&quot;
 35 #endif
 36 
 37 //------------------------------VMReg------------------------------------------
 38 // The VM uses &#39;unwarped&#39; stack slots; the compiler uses &#39;warped&#39; stack slots.
 39 // Register numbers below VMRegImpl::stack0 are the same for both.  Register
 40 // numbers above stack0 are either warped (in the compiler) or unwarped
 41 // (in the VM).  Unwarped numbers represent stack indices, offsets from
 42 // the current stack pointer.  Warped numbers are required during compilation
 43 // when we do not yet know how big the frame will be.
 44 
 45 class VMRegImpl;
 46 typedef VMRegImpl* VMReg;
 47 
 48 class VMRegImpl {
 49 // friend class OopMap;
 50 friend class VMStructs;
 51 friend class OptoReg;
 52 // friend class Location;
 53 private:
 54   enum {
 55     BAD_REG = -1
 56   };
 57 
 58 
 59 
 60   static VMReg stack0;
 61   // Names for registers
 62   static const char *regName[];
 63   static const int register_count;
 64 
 65 
 66 public:
 67 
 68   static VMReg  as_VMReg(int val, bool bad_ok = false) { assert(val &gt; BAD_REG || bad_ok, &quot;invalid&quot;); return (VMReg) (intptr_t) val; }
 69 
 70   const char*  name() {
 71     if (is_reg()) {
 72       return regName[value()];
 73     } else if (!is_valid()) {
 74       return &quot;BAD&quot;;
 75     } else {
 76       // shouldn&#39;t really be called with stack
 77       return &quot;STACKED REG&quot;;
 78     }
 79   }
 80   static VMReg Bad() { return (VMReg) (intptr_t) BAD_REG; }
 81   bool is_valid() const { return ((intptr_t) this) != BAD_REG; }
 82   bool is_stack() const { return (intptr_t) this &gt;= (intptr_t) stack0; }
 83   bool is_reg()   const { return is_valid() &amp;&amp; !is_stack(); }
 84 
 85   // A concrete register is a value that returns true for is_reg() and is
 86   // also a register you could use in the assembler. On machines with
 87   // 64bit registers only one half of the VMReg (and OptoReg) is considered
 88   // concrete.
 89   //  bool is_concrete();
 90 
 91   // VMRegs are 4 bytes wide on all platforms
 92   static const int stack_slot_size;
 93   static const int slots_per_word;
 94 
 95 
 96   // This really ought to check that the register is &quot;real&quot; in the sense that
 97   // we don&#39;t try and get the VMReg number of a physical register that doesn&#39;t
 98   // have an expressible part. That would be pd specific code
 99   VMReg next() {
100     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - 1) || is_stack(), &quot;must be&quot;);
101     return (VMReg)(intptr_t)(value() + 1);
102   }
103   VMReg next(int i) {
104     assert((is_reg() &amp;&amp; value() &lt; stack0-&gt;value() - i) || is_stack(), &quot;must be&quot;);
105     return (VMReg)(intptr_t)(value() + i);
106   }
107   VMReg prev() {
108     assert((is_stack() &amp;&amp; value() &gt; stack0-&gt;value()) || (is_reg() &amp;&amp; value() != 0), &quot;must be&quot;);
109     return (VMReg)(intptr_t)(value() - 1);
110   }
111 
112 
113   intptr_t value() const         {return (intptr_t) this; }
114 
115   void print_on(outputStream* st) const;
116   void print() const;
117 
118   // bias a stack slot.
119   // Typically used to adjust a virtual frame slots by amounts that are offset by
120   // amounts that are part of the native abi. The VMReg must be a stack slot
121   // and the result must be also.
122 
123   VMReg bias(int offset) {
124     assert(is_stack(), &quot;must be&quot;);
125     // VMReg res = VMRegImpl::as_VMReg(value() + offset);
126     VMReg res = stack2reg(reg2stack() + offset);
127     assert(res-&gt;is_stack(), &quot;must be&quot;);
128     return res;
129   }
130 
131   // Convert register numbers to stack slots and vice versa
132   static VMReg stack2reg( int idx ) {
133     return (VMReg) (intptr_t) (stack0-&gt;value() + idx);
134   }
135 
136   uintptr_t reg2stack() {
137     assert( is_stack(), &quot;Not a stack-based register&quot; );
138     return value() - stack0-&gt;value();
139   }
140 
141   static void set_regName();
142 
143   static VMReg vmStorageToVMReg(int type, int index);
144 
145 #include CPU_HEADER(vmreg)
146 
147 };
148 
149 //---------------------------VMRegPair-------------------------------------------
150 // Pairs of 32-bit registers for arguments.
151 // SharedRuntime::java_calling_convention will overwrite the structs with
152 // the calling convention&#39;s registers.  VMRegImpl::Bad is returned for any
153 // unused 32-bit register.  This happens for the unused high half of Int
154 // arguments, or for 32-bit pointers or for longs in the 32-bit sparc build
155 // (which are passed to natives in low 32-bits of e.g. O0/O1 and the high
156 // 32-bits of O0/O1 are set to VMRegImpl::Bad).  Longs in one register &amp; doubles
157 // always return a high and a low register, as do 64-bit pointers.
158 //
159 class VMRegPair {
160 private:
161   VMReg _second;
162   VMReg _first;
163 public:
164   void set_bad (                   ) { _second=VMRegImpl::Bad(); _first=VMRegImpl::Bad(); }
165   void set1    (         VMReg v  ) { _second=VMRegImpl::Bad(); _first=v; }
166   void set2    (         VMReg v  ) { _second=v-&gt;next();  _first=v; }
167   void set_pair( VMReg second, VMReg first    ) { _second= second;    _first= first; }
168   void set_ptr ( VMReg ptr ) {
169 #ifdef _LP64
170     _second = ptr-&gt;next();
171 #else
172     _second = VMRegImpl::Bad();
173 #endif
174     _first = ptr;
175   }
176   // Return true if single register, even if the pair is really just adjacent stack slots
177   bool is_single_reg() const {
178     return (_first-&gt;is_valid()) &amp;&amp; (_first-&gt;value() + 1 == _second-&gt;value());
179   }
180 
181   // Return true if single stack based &quot;register&quot; where the slot alignment matches input alignment
182   bool is_adjacent_on_stack(int alignment) const {
183     return (_first-&gt;is_stack() &amp;&amp; (_first-&gt;value() + 1 == _second-&gt;value()) &amp;&amp; ((_first-&gt;value() &amp; (alignment-1)) == 0));
184   }
185 
186   // Return true if single stack based &quot;register&quot; where the slot alignment matches input alignment
187   bool is_adjacent_aligned_on_stack(int alignment) const {
188     return (_first-&gt;is_stack() &amp;&amp; (_first-&gt;value() + 1 == _second-&gt;value()) &amp;&amp; ((_first-&gt;value() &amp; (alignment-1)) == 0));
189   }
190 
191   // Return true if single register but adjacent stack slots do not count
192   bool is_single_phys_reg() const {
193     return (_first-&gt;is_reg() &amp;&amp; (_first-&gt;value() + 1 == _second-&gt;value()));
194   }
195 
196   VMReg second() const { return _second; }
197   VMReg first()  const { return _first; }
198   VMRegPair(VMReg s, VMReg f) {  _second = s; _first = f; }
199   VMRegPair(VMReg f) { _second = VMRegImpl::Bad(); _first = f; }
200   VMRegPair() { _second = VMRegImpl::Bad(); _first = VMRegImpl::Bad(); }
201 };
202 
203 #endif // SHARE_CODE_VMREG_HPP
    </pre>
  </body>
</html>
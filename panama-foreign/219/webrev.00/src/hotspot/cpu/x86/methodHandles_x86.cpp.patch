diff a/src/hotspot/cpu/x86/methodHandles_x86.cpp b/src/hotspot/cpu/x86/methodHandles_x86.cpp
--- a/src/hotspot/cpu/x86/methodHandles_x86.cpp
+++ b/src/hotspot/cpu/x86/methodHandles_x86.cpp
@@ -213,10 +213,17 @@
     // They all allow an appendix argument.
     __ hlt();           // empty stubs make SG sick
     return NULL;
   }
 
+  // No need in interpreter entry for linkToNative for now.
+  // Interpreter calls compiled entry through i2c.
+  if (iid == vmIntrinsics::_linkToNative) {
+    __ hlt();
+    return NULL;
+  }
+
   // rsi/r13: sender SP (must preserve; see prepare_to_jump_from_interpreted)
   // rbx: Method*
   // rdx: argument locator (parameter slot count, added to rsp)
   // rcx: used as temp to hold mh or receiver
   // rax, rdi: garbage temps, blown away
@@ -324,11 +331,14 @@
     assert_different_registers(temp1, temp2, temp3, saved_last_sp_register());  // don't trash lastSP
   }
   assert_different_registers(temp1, temp2, temp3, receiver_reg);
   assert_different_registers(temp1, temp2, temp3, member_reg);
 
-  if (iid == vmIntrinsics::_invokeBasic) {
+  if (iid == vmIntrinsics::_invokeBasic || iid == vmIntrinsics::_linkToNative) {
+    if (iid == vmIntrinsics::_linkToNative) {
+      assert(for_compiler_entry, "only compiler entry is supported");
+    }
     // indirect through MH.form.vmentry.vmtarget
     jump_to_lambda_form(_masm, receiver_reg, rbx_method, temp1, for_compiler_entry);
 
   } else {
     // The method is a member invoker used by direct method handles.

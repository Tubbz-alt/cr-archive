<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../adlc/formssel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciClassList.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4112               }
4113             }
4114             j += t-&gt;size();  // long and double take two slots
4115           }
4116           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4117           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4118             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4119             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {
4120               return true;
4121             }
4122           } else {
4123             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4124           }
4125         }
4126       } else {
4127         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4128       }
4129     }
4130     break;
4131 



4132   default:
4133     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4134     break;
4135   }
4136   set_state(state_before-&gt;copy_for_parsing());
4137   return false;
4138 }
4139 
4140 
4141 void GraphBuilder::inline_bailout(const char* msg) {
4142   assert(msg != NULL, &quot;inline bailout msg must exist&quot;);
4143   _inline_bailout_msg = msg;
4144 }
4145 
4146 
4147 void GraphBuilder::clear_inline_bailout() {
4148   _inline_bailout_msg = NULL;
4149 }
4150 
4151 
</pre>
</td>
<td>
<hr />
<pre>
4112               }
4113             }
4114             j += t-&gt;size();  // long and double take two slots
4115           }
4116           // We don&#39;t do CHA here so only inline static and statically bindable methods.
4117           if (target-&gt;is_static() || target-&gt;can_be_statically_bound()) {
4118             Bytecodes::Code bc = target-&gt;is_static() ? Bytecodes::_invokestatic : Bytecodes::_invokevirtual;
4119             if (try_inline(target, /*holder_known*/ !callee-&gt;is_static(), ignore_return, bc)) {
4120               return true;
4121             }
4122           } else {
4123             print_inlining(target, &quot;not static or statically bindable&quot;, /*success*/ false);
4124           }
4125         }
4126       } else {
4127         print_inlining(callee, &quot;MemberName not constant&quot;, /*success*/ false);
4128       }
4129     }
4130     break;
4131 
<span class="line-added">4132   case vmIntrinsics::_linkToNative:</span>
<span class="line-added">4133     break; // TODO: NYI</span>
<span class="line-added">4134 </span>
4135   default:
4136     fatal(&quot;unexpected intrinsic %d: %s&quot;, iid, vmIntrinsics::name_at(iid));
4137     break;
4138   }
4139   set_state(state_before-&gt;copy_for_parsing());
4140   return false;
4141 }
4142 
4143 
4144 void GraphBuilder::inline_bailout(const char* msg) {
4145   assert(msg != NULL, &quot;inline bailout msg must exist&quot;);
4146   _inline_bailout_msg = msg;
4147 }
4148 
4149 
4150 void GraphBuilder::clear_inline_bailout() {
4151   _inline_bailout_msg = NULL;
4152 }
4153 
4154 
</pre>
</td>
</tr>
</table>
<center><a href="../adlc/formssel.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/ciClassList.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/code/codeCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;code/codeBlob.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/codeHeapState.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/dependencies.hpp&quot;
  32 #include &quot;code/dependencyContext.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/nmethod.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;compiler/compileBroker.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/log.hpp&quot;
  40 #include &quot;logging/logStream.hpp&quot;
  41 #include &quot;memory/allocation.inline.hpp&quot;
  42 #include &quot;memory/iterator.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/method.inline.hpp&quot;
  46 #include &quot;oops/objArrayOop.hpp&quot;
  47 #include &quot;oops/oop.inline.hpp&quot;
  48 #include &quot;oops/verifyOopClosure.hpp&quot;
  49 #include &quot;runtime/arguments.hpp&quot;
  50 #include &quot;runtime/atomic.hpp&quot;
  51 #include &quot;runtime/deoptimization.hpp&quot;
  52 #include &quot;runtime/handles.inline.hpp&quot;
  53 #include &quot;runtime/icache.hpp&quot;
  54 #include &quot;runtime/java.hpp&quot;
  55 #include &quot;runtime/mutexLocker.hpp&quot;
  56 #include &quot;runtime/safepointVerifiers.hpp&quot;
  57 #include &quot;runtime/sweeper.hpp&quot;
  58 #include &quot;runtime/vmThread.hpp&quot;
  59 #include &quot;services/memoryService.hpp&quot;
  60 #include &quot;utilities/align.hpp&quot;
  61 #include &quot;utilities/vmError.hpp&quot;
  62 #include &quot;utilities/xmlstream.hpp&quot;
  63 #ifdef COMPILER1
  64 #include &quot;c1/c1_Compilation.hpp&quot;
  65 #include &quot;c1/c1_Compiler.hpp&quot;
  66 #endif
  67 #ifdef COMPILER2
  68 #include &quot;opto/c2compiler.hpp&quot;
  69 #include &quot;opto/compile.hpp&quot;
  70 #include &quot;opto/node.hpp&quot;
  71 #endif
  72 
  73 // Helper class for printing in CodeCache
  74 class CodeBlob_sizes {
  75  private:
  76   int count;
  77   int total_size;
  78   int header_size;
  79   int code_size;
  80   int stub_size;
  81   int relocation_size;
  82   int scopes_oop_size;
  83   int scopes_metadata_size;
  84   int scopes_data_size;
  85   int scopes_pcs_size;
  86 
  87  public:
  88   CodeBlob_sizes() {
  89     count            = 0;
  90     total_size       = 0;
  91     header_size      = 0;
  92     code_size        = 0;
  93     stub_size        = 0;
  94     relocation_size  = 0;
  95     scopes_oop_size  = 0;
  96     scopes_metadata_size  = 0;
  97     scopes_data_size = 0;
  98     scopes_pcs_size  = 0;
  99   }
 100 
 101   int total()                                    { return total_size; }
 102   bool is_empty()                                { return count == 0; }
 103 
 104   void print(const char* title) {
 105     tty-&gt;print_cr(&quot; #%d %s = %dK (hdr %d%%,  loc %d%%, code %d%%, stub %d%%, [oops %d%%, metadata %d%%, data %d%%, pcs %d%%])&quot;,
 106                   count,
 107                   title,
 108                   (int)(total() / K),
 109                   header_size             * 100 / total_size,
 110                   relocation_size         * 100 / total_size,
 111                   code_size               * 100 / total_size,
 112                   stub_size               * 100 / total_size,
 113                   scopes_oop_size         * 100 / total_size,
 114                   scopes_metadata_size    * 100 / total_size,
 115                   scopes_data_size        * 100 / total_size,
 116                   scopes_pcs_size         * 100 / total_size);
 117   }
 118 
 119   void add(CodeBlob* cb) {
 120     count++;
 121     total_size       += cb-&gt;size();
 122     header_size      += cb-&gt;header_size();
 123     relocation_size  += cb-&gt;relocation_size();
 124     if (cb-&gt;is_nmethod()) {
 125       nmethod* nm = cb-&gt;as_nmethod_or_null();
 126       code_size        += nm-&gt;insts_size();
 127       stub_size        += nm-&gt;stub_size();
 128 
 129       scopes_oop_size  += nm-&gt;oops_size();
 130       scopes_metadata_size  += nm-&gt;metadata_size();
 131       scopes_data_size += nm-&gt;scopes_data_size();
 132       scopes_pcs_size  += nm-&gt;scopes_pcs_size();
 133     } else {
 134       code_size        += cb-&gt;code_size();
 135     }
 136   }
 137 };
 138 
 139 // Iterate over all CodeHeaps
 140 #define FOR_ALL_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _heaps-&gt;begin(); heap != _heaps-&gt;end(); ++heap)
 141 #define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _nmethod_heaps-&gt;begin(); heap != _nmethod_heaps-&gt;end(); ++heap)
 142 #define FOR_ALL_ALLOCABLE_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _allocable_heaps-&gt;begin(); heap != _allocable_heaps-&gt;end(); ++heap)
 143 
 144 // Iterate over all CodeBlobs (cb) on the given CodeHeap
 145 #define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))
 146 
 147 address CodeCache::_low_bound = 0;
 148 address CodeCache::_high_bound = 0;
 149 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 150 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 151 
 152 // Initialize arrays of CodeHeap subsets
 153 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);
 154 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);
 155 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);
 156 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);
 157 
 158 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
 159   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
 160   // Prepare error message
 161   const char* error = &quot;Invalid code heap sizes&quot;;
 162   err_msg message(&quot;NonNMethodCodeHeapSize (&quot; SIZE_FORMAT &quot;K) + ProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K)&quot;
 163                   &quot; + NonProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K) = &quot; SIZE_FORMAT &quot;K&quot;,
 164           non_nmethod_size/K, profiled_size/K, non_profiled_size/K, total_size/K);
 165 
 166   if (total_size &gt; cache_size) {
 167     // Some code heap sizes were explicitly set: total_size must be &lt;= cache_size
 168     message.append(&quot; is greater than ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 169     vm_exit_during_initialization(error, message);
 170   } else if (all_set &amp;&amp; total_size != cache_size) {
 171     // All code heap sizes were explicitly set: total_size must equal cache_size
 172     message.append(&quot; is not equal to ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 173     vm_exit_during_initialization(error, message);
 174   }
 175 }
 176 
 177 void CodeCache::initialize_heaps() {
 178   bool non_nmethod_set      = FLAG_IS_CMDLINE(NonNMethodCodeHeapSize);
 179   bool profiled_set         = FLAG_IS_CMDLINE(ProfiledCodeHeapSize);
 180   bool non_profiled_set     = FLAG_IS_CMDLINE(NonProfiledCodeHeapSize);
 181   size_t min_size           = os::vm_page_size();
 182   size_t cache_size         = ReservedCodeCacheSize;
 183   size_t non_nmethod_size   = NonNMethodCodeHeapSize;
 184   size_t profiled_size      = ProfiledCodeHeapSize;
 185   size_t non_profiled_size  = NonProfiledCodeHeapSize;
 186   // Check if total size set via command line flags exceeds the reserved size
 187   check_heap_sizes((non_nmethod_set  ? non_nmethod_size  : min_size),
 188                    (profiled_set     ? profiled_size     : min_size),
 189                    (non_profiled_set ? non_profiled_size : min_size),
 190                    cache_size,
 191                    non_nmethod_set &amp;&amp; profiled_set &amp;&amp; non_profiled_set);
 192 
 193   // Determine size of compiler buffers
 194   size_t code_buffers_size = 0;
 195 #ifdef COMPILER1
 196   // C1 temporary code buffers (see Compiler::init_buffer_blob())
 197   const int c1_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_simple);
 198   code_buffers_size += c1_count * Compiler::code_buffer_size();
 199 #endif
 200 #ifdef COMPILER2
 201   // C2 scratch buffers (see Compile::init_scratch_buffer_blob())
 202   const int c2_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_full_optimization);
 203   // Initial size of constant table (this may be increased if a compiled method needs more space)
 204   code_buffers_size += c2_count * C2Compiler::initial_code_buffer_size();
 205 #endif
 206 
 207   // Increase default non_nmethod_size to account for compiler buffers
 208   if (!non_nmethod_set) {
 209     non_nmethod_size += code_buffers_size;
 210   }
 211   // Calculate default CodeHeap sizes if not set by user
 212   if (!non_nmethod_set &amp;&amp; !profiled_set &amp;&amp; !non_profiled_set) {
 213     // Check if we have enough space for the non-nmethod code heap
 214     if (cache_size &gt; non_nmethod_size) {
 215       // Use the default value for non_nmethod_size and one half of the
 216       // remaining size for non-profiled and one half for profiled methods
 217       size_t remaining_size = cache_size - non_nmethod_size;
 218       profiled_size = remaining_size / 2;
 219       non_profiled_size = remaining_size - profiled_size;
 220     } else {
 221       // Use all space for the non-nmethod heap and set other heaps to minimal size
 222       non_nmethod_size = cache_size - 2 * min_size;
 223       profiled_size = min_size;
 224       non_profiled_size = min_size;
 225     }
 226   } else if (!non_nmethod_set || !profiled_set || !non_profiled_set) {
 227     // The user explicitly set some code heap sizes. Increase or decrease the (default)
 228     // sizes of the other code heaps accordingly. First adapt non-profiled and profiled
 229     // code heap sizes and then only change non-nmethod code heap size if still necessary.
 230     intx diff_size = cache_size - (non_nmethod_size + profiled_size + non_profiled_size);
 231     if (non_profiled_set) {
 232       if (!profiled_set) {
 233         // Adapt size of profiled code heap
 234         if (diff_size &lt; 0 &amp;&amp; ((intx)profiled_size + diff_size) &lt;= 0) {
 235           // Not enough space available, set to minimum size
 236           diff_size += profiled_size - min_size;
 237           profiled_size = min_size;
 238         } else {
 239           profiled_size += diff_size;
 240           diff_size = 0;
 241         }
 242       }
 243     } else if (profiled_set) {
 244       // Adapt size of non-profiled code heap
 245       if (diff_size &lt; 0 &amp;&amp; ((intx)non_profiled_size + diff_size) &lt;= 0) {
 246         // Not enough space available, set to minimum size
 247         diff_size += non_profiled_size - min_size;
 248         non_profiled_size = min_size;
 249       } else {
 250         non_profiled_size += diff_size;
 251         diff_size = 0;
 252       }
 253     } else if (non_nmethod_set) {
 254       // Distribute remaining size between profiled and non-profiled code heaps
 255       diff_size = cache_size - non_nmethod_size;
 256       profiled_size = diff_size / 2;
 257       non_profiled_size = diff_size - profiled_size;
 258       diff_size = 0;
 259     }
 260     if (diff_size != 0) {
 261       // Use non-nmethod code heap for remaining space requirements
 262       assert(!non_nmethod_set &amp;&amp; ((intx)non_nmethod_size + diff_size) &gt; 0, &quot;sanity&quot;);
 263       non_nmethod_size += diff_size;
 264     }
 265   }
 266 
 267   // We do not need the profiled CodeHeap, use all space for the non-profiled CodeHeap
 268   if (!heap_available(CodeBlobType::MethodProfiled)) {
 269     non_profiled_size += profiled_size;
 270     profiled_size = 0;
 271   }
 272   // We do not need the non-profiled CodeHeap, use all space for the non-nmethod CodeHeap
 273   if (!heap_available(CodeBlobType::MethodNonProfiled)) {
 274     non_nmethod_size += non_profiled_size;
 275     non_profiled_size = 0;
 276   }
 277   // Make sure we have enough space for VM internal code
 278   uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);
 279   if (non_nmethod_size &lt; min_code_cache_size) {
 280     vm_exit_during_initialization(err_msg(
 281         &quot;Not enough space in non-nmethod code heap to run VM: &quot; SIZE_FORMAT &quot;K &lt; &quot; SIZE_FORMAT &quot;K&quot;,
 282         non_nmethod_size/K, min_code_cache_size/K));
 283   }
 284 
 285   // Verify sizes and update flag values
 286   assert(non_profiled_size + profiled_size + non_nmethod_size == cache_size, &quot;Invalid code heap sizes&quot;);
 287   FLAG_SET_ERGO(NonNMethodCodeHeapSize, non_nmethod_size);
 288   FLAG_SET_ERGO(ProfiledCodeHeapSize, profiled_size);
 289   FLAG_SET_ERGO(NonProfiledCodeHeapSize, non_profiled_size);
 290 
 291   // If large page support is enabled, align code heaps according to large
 292   // page size to make sure that code cache is covered by large pages.
 293   const size_t alignment = MAX2(page_size(false, 8), (size_t) os::vm_allocation_granularity());
 294   non_nmethod_size = align_up(non_nmethod_size, alignment);
 295   profiled_size    = align_down(profiled_size, alignment);
 296 
 297   // Reserve one continuous chunk of memory for CodeHeaps and split it into
 298   // parts for the individual heaps. The memory layout looks like this:
 299   // ---------- high -----------
 300   //    Non-profiled nmethods
 301   //      Profiled nmethods
 302   //         Non-nmethods
 303   // ---------- low ------------
 304   ReservedCodeSpace rs = reserve_heap_memory(cache_size);
 305   ReservedSpace non_method_space    = rs.first_part(non_nmethod_size);
 306   ReservedSpace rest                = rs.last_part(non_nmethod_size);
 307   ReservedSpace profiled_space      = rest.first_part(profiled_size);
 308   ReservedSpace non_profiled_space  = rest.last_part(profiled_size);
 309 
 310   // Non-nmethods (stubs, adapters, ...)
 311   add_heap(non_method_space, &quot;CodeHeap &#39;non-nmethods&#39;&quot;, CodeBlobType::NonNMethod);
 312   // Tier 2 and tier 3 (profiled) methods
 313   add_heap(profiled_space, &quot;CodeHeap &#39;profiled nmethods&#39;&quot;, CodeBlobType::MethodProfiled);
 314   // Tier 1 and tier 4 (non-profiled) methods and native methods
 315   add_heap(non_profiled_space, &quot;CodeHeap &#39;non-profiled nmethods&#39;&quot;, CodeBlobType::MethodNonProfiled);
 316 }
 317 
 318 size_t CodeCache::page_size(bool aligned, size_t min_pages) {
 319   if (os::can_execute_large_page_memory()) {
 320     if (InitialCodeCacheSize &lt; ReservedCodeCacheSize) {
 321       // Make sure that the page size allows for an incremental commit of the reserved space
 322       min_pages = MAX2(min_pages, (size_t)8);
 323     }
 324     return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :
 325                      os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);
 326   } else {
 327     return os::vm_page_size();
 328   }
 329 }
 330 
 331 ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {
 332   // Align and reserve space for code cache
 333   const size_t rs_ps = page_size();
 334   const size_t rs_align = MAX2(rs_ps, (size_t) os::vm_allocation_granularity());
 335   const size_t rs_size = align_up(size, rs_align);
 336   ReservedCodeSpace rs(rs_size, rs_align, rs_ps &gt; (size_t) os::vm_page_size());
 337   if (!rs.is_reserved()) {
 338     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space for code cache (&quot; SIZE_FORMAT &quot;K)&quot;,
 339                                           rs_size/K));
 340   }
 341 
 342   // Initialize bounds
 343   _low_bound = (address)rs.base();
 344   _high_bound = _low_bound + rs.size();
 345   return rs;
 346 }
 347 
 348 // Heaps available for allocation
 349 bool CodeCache::heap_available(int code_blob_type) {
 350   if (!SegmentedCodeCache) {
 351     // No segmentation: use a single code heap
 352     return (code_blob_type == CodeBlobType::All);
 353   } else if (Arguments::is_interpreter_only()) {
 354     // Interpreter only: we don&#39;t need any method code heaps
 355     return (code_blob_type == CodeBlobType::NonNMethod);
 356   } else if (TieredCompilation &amp;&amp; (TieredStopAtLevel &gt; CompLevel_simple)) {
 357     // Tiered compilation: use all code heaps
 358     return (code_blob_type &lt; CodeBlobType::All);
 359   } else {
 360     // No TieredCompilation: we only need the non-nmethod and non-profiled code heap
 361     return (code_blob_type == CodeBlobType::NonNMethod) ||
 362            (code_blob_type == CodeBlobType::MethodNonProfiled);
 363   }
 364 }
 365 
 366 const char* CodeCache::get_code_heap_flag_name(int code_blob_type) {
 367   switch(code_blob_type) {
 368   case CodeBlobType::NonNMethod:
 369     return &quot;NonNMethodCodeHeapSize&quot;;
 370     break;
 371   case CodeBlobType::MethodNonProfiled:
 372     return &quot;NonProfiledCodeHeapSize&quot;;
 373     break;
 374   case CodeBlobType::MethodProfiled:
 375     return &quot;ProfiledCodeHeapSize&quot;;
 376     break;
 377   }
 378   ShouldNotReachHere();
 379   return NULL;
 380 }
 381 
 382 int CodeCache::code_heap_compare(CodeHeap* const &amp;lhs, CodeHeap* const &amp;rhs) {
 383   if (lhs-&gt;code_blob_type() == rhs-&gt;code_blob_type()) {
 384     return (lhs &gt; rhs) ? 1 : ((lhs &lt; rhs) ? -1 : 0);
 385   } else {
 386     return lhs-&gt;code_blob_type() - rhs-&gt;code_blob_type();
 387   }
 388 }
 389 
 390 void CodeCache::add_heap(CodeHeap* heap) {
 391   assert(!Universe::is_fully_initialized(), &quot;late heap addition?&quot;);
 392 
 393   _heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 394 
 395   int type = heap-&gt;code_blob_type();
 396   if (code_blob_type_accepts_compiled(type)) {
 397     _compiled_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 398   }
 399   if (code_blob_type_accepts_nmethod(type)) {
 400     _nmethod_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 401   }
 402   if (code_blob_type_accepts_allocable(type)) {
 403     _allocable_heaps-&gt;insert_sorted&lt;code_heap_compare&gt;(heap);
 404   }
 405 }
 406 
 407 void CodeCache::add_heap(ReservedSpace rs, const char* name, int code_blob_type) {
 408   // Check if heap is needed
 409   if (!heap_available(code_blob_type)) {
 410     return;
 411   }
 412 
 413   // Create CodeHeap
 414   CodeHeap* heap = new CodeHeap(name, code_blob_type);
 415   add_heap(heap);
 416 
 417   // Reserve Space
 418   size_t size_initial = MIN2((size_t)InitialCodeCacheSize, rs.size());
 419   size_initial = align_up(size_initial, os::vm_page_size());
 420   if (!heap-&gt;reserve(rs, size_initial, CodeCacheSegmentSize)) {
 421     vm_exit_during_initialization(err_msg(&quot;Could not reserve enough space in %s (&quot; SIZE_FORMAT &quot;K)&quot;,
 422                                           heap-&gt;name(), size_initial/K));
 423   }
 424 
 425   // Register the CodeHeap
 426   MemoryService::add_code_heap_memory_pool(heap, name);
 427 }
 428 
 429 CodeHeap* CodeCache::get_code_heap_containing(void* start) {
 430   FOR_ALL_HEAPS(heap) {
 431     if ((*heap)-&gt;contains(start)) {
 432       return *heap;
 433     }
 434   }
 435   return NULL;
 436 }
 437 
 438 CodeHeap* CodeCache::get_code_heap(const CodeBlob* cb) {
 439   assert(cb != NULL, &quot;CodeBlob is null&quot;);
 440   FOR_ALL_HEAPS(heap) {
 441     if ((*heap)-&gt;contains_blob(cb)) {
 442       return *heap;
 443     }
 444   }
 445   ShouldNotReachHere();
 446   return NULL;
 447 }
 448 
 449 CodeHeap* CodeCache::get_code_heap(int code_blob_type) {
 450   FOR_ALL_HEAPS(heap) {
 451     if ((*heap)-&gt;accepts(code_blob_type)) {
 452       return *heap;
 453     }
 454   }
 455   return NULL;
 456 }
 457 
 458 CodeBlob* CodeCache::first_blob(CodeHeap* heap) {
 459   assert_locked_or_safepoint(CodeCache_lock);
 460   assert(heap != NULL, &quot;heap is null&quot;);
 461   return (CodeBlob*)heap-&gt;first();
 462 }
 463 
 464 CodeBlob* CodeCache::first_blob(int code_blob_type) {
 465   if (heap_available(code_blob_type)) {
 466     return first_blob(get_code_heap(code_blob_type));
 467   } else {
 468     return NULL;
 469   }
 470 }
 471 
 472 CodeBlob* CodeCache::next_blob(CodeHeap* heap, CodeBlob* cb) {
 473   assert_locked_or_safepoint(CodeCache_lock);
 474   assert(heap != NULL, &quot;heap is null&quot;);
 475   return (CodeBlob*)heap-&gt;next(cb);
 476 }
 477 
 478 /**
 479  * Do not seize the CodeCache lock here--if the caller has not
 480  * already done so, we are going to lose bigtime, since the code
 481  * cache will contain a garbage CodeBlob until the caller can
 482  * run the constructor for the CodeBlob subclass he is busy
 483  * instantiating.
 484  */
 485 CodeBlob* CodeCache::allocate(int size, int code_blob_type, int orig_code_blob_type) {
 486   // Possibly wakes up the sweeper thread.
 487   NMethodSweeper::report_allocation(code_blob_type);
 488   assert_locked_or_safepoint(CodeCache_lock);
 489   assert(size &gt; 0, &quot;Code cache allocation request must be &gt; 0 but is %d&quot;, size);
 490   if (size &lt;= 0) {
 491     return NULL;
 492   }
 493   CodeBlob* cb = NULL;
 494 
 495   // Get CodeHeap for the given CodeBlobType
 496   CodeHeap* heap = get_code_heap(code_blob_type);
 497   assert(heap != NULL, &quot;heap is null&quot;);
 498 
 499   while (true) {
 500     cb = (CodeBlob*)heap-&gt;allocate(size);
 501     if (cb != NULL) break;
 502     if (!heap-&gt;expand_by(CodeCacheExpansionSize)) {
 503       // Save original type for error reporting
 504       if (orig_code_blob_type == CodeBlobType::All) {
 505         orig_code_blob_type = code_blob_type;
 506       }
 507       // Expansion failed
 508       if (SegmentedCodeCache) {
 509         // Fallback solution: Try to store code in another code heap.
 510         // NonNMethod -&gt; MethodNonProfiled -&gt; MethodProfiled (-&gt; MethodNonProfiled)
 511         // Note that in the sweeper, we check the reverse_free_ratio of the code heap
 512         // and force stack scanning if less than 10% of the code heap are free.
 513         int type = code_blob_type;
 514         switch (type) {
 515         case CodeBlobType::NonNMethod:
 516           type = CodeBlobType::MethodNonProfiled;
 517           break;
 518         case CodeBlobType::MethodNonProfiled:
 519           type = CodeBlobType::MethodProfiled;
 520           break;
 521         case CodeBlobType::MethodProfiled:
 522           // Avoid loop if we already tried that code heap
 523           if (type == orig_code_blob_type) {
 524             type = CodeBlobType::MethodNonProfiled;
 525           }
 526           break;
 527         }
 528         if (type != code_blob_type &amp;&amp; type != orig_code_blob_type &amp;&amp; heap_available(type)) {
 529           if (PrintCodeCacheExtension) {
 530             tty-&gt;print_cr(&quot;Extension of %s failed. Trying to allocate in %s.&quot;,
 531                           heap-&gt;name(), get_code_heap(type)-&gt;name());
 532           }
 533           return allocate(size, type, orig_code_blob_type);
 534         }
 535       }
 536       MutexUnlocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 537       CompileBroker::handle_full_code_cache(orig_code_blob_type);
 538       return NULL;
 539     }
 540     if (PrintCodeCacheExtension) {
 541       ResourceMark rm;
 542       if (_nmethod_heaps-&gt;length() &gt;= 1) {
 543         tty-&gt;print(&quot;%s&quot;, heap-&gt;name());
 544       } else {
 545         tty-&gt;print(&quot;CodeCache&quot;);
 546       }
 547       tty-&gt;print_cr(&quot; extended to [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;] (&quot; SSIZE_FORMAT &quot; bytes)&quot;,
 548                     (intptr_t)heap-&gt;low_boundary(), (intptr_t)heap-&gt;high(),
 549                     (address)heap-&gt;high() - (address)heap-&gt;low_boundary());
 550     }
 551   }
 552   print_trace(&quot;allocation&quot;, cb, size);
 553   return cb;
 554 }
 555 
 556 void CodeCache::free(CodeBlob* cb) {
 557   assert_locked_or_safepoint(CodeCache_lock);
 558   CodeHeap* heap = get_code_heap(cb);
 559   print_trace(&quot;free&quot;, cb);
 560   if (cb-&gt;is_nmethod()) {
 561     nmethod* ptr = (nmethod *)cb;
 562     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() - 1);
 563     if (ptr-&gt;has_dependencies()) {
 564       _number_of_nmethods_with_dependencies--;
 565     }
 566     ptr-&gt;free_native_stubs();
 567   }
 568   if (cb-&gt;is_adapter_blob()) {
 569     heap-&gt;set_adapter_count(heap-&gt;adapter_count() - 1);
 570   }
 571 
 572   // Get heap for given CodeBlob and deallocate
 573   get_code_heap(cb)-&gt;deallocate(cb);
 574 
 575   assert(heap-&gt;blob_count() &gt;= 0, &quot;sanity check&quot;);
 576 }
 577 
 578 void CodeCache::free_unused_tail(CodeBlob* cb, size_t used) {
 579   assert_locked_or_safepoint(CodeCache_lock);
 580   guarantee(cb-&gt;is_buffer_blob() &amp;&amp; strncmp(&quot;Interpreter&quot;, cb-&gt;name(), 11) == 0, &quot;Only possible for interpreter!&quot;);
 581   print_trace(&quot;free_unused_tail&quot;, cb);
 582 
 583   // We also have to account for the extra space (i.e. header) used by the CodeBlob
 584   // which provides the memory (see BufferBlob::create() in codeBlob.cpp).
 585   used += CodeBlob::align_code_offset(cb-&gt;header_size());
 586 
 587   // Get heap for given CodeBlob and deallocate its unused tail
 588   get_code_heap(cb)-&gt;deallocate_tail(cb, used);
 589   // Adjust the sizes of the CodeBlob
 590   cb-&gt;adjust_size(used);
 591 }
 592 
 593 void CodeCache::commit(CodeBlob* cb) {
 594   // this is called by nmethod::nmethod, which must already own CodeCache_lock
 595   assert_locked_or_safepoint(CodeCache_lock);
 596   CodeHeap* heap = get_code_heap(cb);
 597   if (cb-&gt;is_nmethod()) {
 598     heap-&gt;set_nmethod_count(heap-&gt;nmethod_count() + 1);
 599     if (((nmethod *)cb)-&gt;has_dependencies()) {
 600       _number_of_nmethods_with_dependencies++;
 601     }
 602   }
 603   if (cb-&gt;is_adapter_blob()) {
 604     heap-&gt;set_adapter_count(heap-&gt;adapter_count() + 1);
 605   }
 606 
 607   // flush the hardware I-cache
 608   ICache::invalidate_range(cb-&gt;content_begin(), cb-&gt;content_size());
 609 }
 610 
 611 bool CodeCache::contains(void *p) {
 612   // S390 uses contains() in current_frame(), which is used before
 613   // code cache initialization if NativeMemoryTracking=detail is set.
 614   S390_ONLY(if (_heaps == NULL) return false;)
 615   // It should be ok to call contains without holding a lock.
 616   FOR_ALL_HEAPS(heap) {
 617     if ((*heap)-&gt;contains(p)) {
 618       return true;
 619     }
 620   }
 621   return false;
 622 }
 623 
 624 bool CodeCache::contains(nmethod *nm) {
 625   return contains((void *)nm);
 626 }
 627 
 628 // This method is safe to call without holding the CodeCache_lock, as long as a dead CodeBlob is not
 629 // looked up (i.e., one that has been marked for deletion). It only depends on the _segmap to contain
 630 // valid indices, which it will always do, as long as the CodeBlob is not in the process of being recycled.
 631 CodeBlob* CodeCache::find_blob(void* start) {
 632   CodeBlob* result = find_blob_unsafe(start);
 633   // We could potentially look up non_entrant methods
 634   guarantee(result == NULL || !result-&gt;is_zombie() || result-&gt;is_locked_by_vm() || VMError::is_error_reported(), &quot;unsafe access to zombie method&quot;);
 635   return result;
 636 }
 637 
 638 // Lookup that does not fail if you lookup a zombie method (if you call this, be sure to know
 639 // what you are doing)
 640 CodeBlob* CodeCache::find_blob_unsafe(void* start) {
 641   // NMT can walk the stack before code cache is created
 642   if (_heaps != NULL) {
 643     CodeHeap* heap = get_code_heap_containing(start);
 644     if (heap != NULL) {
 645       return heap-&gt;find_blob_unsafe(start);
 646     }
 647   }
 648   return NULL;
 649 }
 650 
 651 nmethod* CodeCache::find_nmethod(void* start) {
 652   CodeBlob* cb = find_blob(start);
 653   assert(cb-&gt;is_nmethod(), &quot;did not find an nmethod&quot;);
 654   return (nmethod*)cb;
 655 }
 656 
 657 void CodeCache::blobs_do(void f(CodeBlob* nm)) {
 658   assert_locked_or_safepoint(CodeCache_lock);
 659   FOR_ALL_HEAPS(heap) {
 660     FOR_ALL_BLOBS(cb, *heap) {
 661       f(cb);
 662     }
 663   }
 664 }
 665 
 666 void CodeCache::nmethods_do(void f(nmethod* nm)) {
 667   assert_locked_or_safepoint(CodeCache_lock);
 668   NMethodIterator iter(NMethodIterator::all_blobs);
 669   while(iter.next()) {
 670     f(iter.method());
 671   }
 672 }
 673 
 674 void CodeCache::metadata_do(MetadataClosure* f) {
 675   assert_locked_or_safepoint(CodeCache_lock);
 676   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 677   while(iter.next()) {
 678     iter.method()-&gt;metadata_do(f);
 679   }
 680   AOTLoader::metadata_do(f);
 681 }
 682 
 683 int CodeCache::alignment_unit() {
 684   return (int)_heaps-&gt;first()-&gt;alignment_unit();
 685 }
 686 
 687 int CodeCache::alignment_offset() {
 688   return (int)_heaps-&gt;first()-&gt;alignment_offset();
 689 }
 690 
 691 // Mark nmethods for unloading if they contain otherwise unreachable oops.
 692 void CodeCache::do_unloading(BoolObjectClosure* is_alive, bool unloading_occurred) {
 693   assert_locked_or_safepoint(CodeCache_lock);
 694   UnloadingScope scope(is_alive);
 695   CompiledMethodIterator iter(CompiledMethodIterator::only_alive);
 696   while(iter.next()) {
 697     iter.method()-&gt;do_unloading(unloading_occurred);
 698   }
 699 }
 700 
 701 void CodeCache::blobs_do(CodeBlobClosure* f) {
 702   assert_locked_or_safepoint(CodeCache_lock);
 703   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 704     FOR_ALL_BLOBS(cb, *heap) {
 705       if (cb-&gt;is_alive()) {
 706         f-&gt;do_code_blob(cb);
 707 #ifdef ASSERT
 708         if (cb-&gt;is_nmethod()) {
 709           Universe::heap()-&gt;verify_nmethod((nmethod*)cb);
 710         }
 711 #endif //ASSERT
 712       }
 713     }
 714   }
 715 }
 716 
 717 void CodeCache::verify_clean_inline_caches() {
 718 #ifdef ASSERT
 719   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 720   while(iter.next()) {
 721     nmethod* nm = iter.method();
 722     assert(!nm-&gt;is_unloaded(), &quot;Tautology&quot;);
 723     nm-&gt;verify_clean_inline_caches();
 724     nm-&gt;verify();
 725   }
 726 #endif
 727 }
 728 
 729 void CodeCache::verify_icholder_relocations() {
 730 #ifdef ASSERT
 731   // make sure that we aren&#39;t leaking icholders
 732   int count = 0;
 733   FOR_ALL_HEAPS(heap) {
 734     FOR_ALL_BLOBS(cb, *heap) {
 735       CompiledMethod *nm = cb-&gt;as_compiled_method_or_null();
 736       if (nm != NULL) {
 737         count += nm-&gt;verify_icholder_relocations();
 738       }
 739     }
 740   }
 741   assert(count + InlineCacheBuffer::pending_icholder_count() + CompiledICHolder::live_not_claimed_count() ==
 742          CompiledICHolder::live_count(), &quot;must agree&quot;);
 743 #endif
 744 }
 745 
 746 // Defer freeing of concurrently cleaned ExceptionCache entries until
 747 // after a global handshake operation.
 748 void CodeCache::release_exception_cache(ExceptionCache* entry) {
 749   if (SafepointSynchronize::is_at_safepoint()) {
 750     delete entry;
 751   } else {
 752     for (;;) {
 753       ExceptionCache* purge_list_head = Atomic::load(&amp;_exception_cache_purge_list);
 754       entry-&gt;set_purge_list_next(purge_list_head);
 755       if (Atomic::cmpxchg(&amp;_exception_cache_purge_list, purge_list_head, entry) == purge_list_head) {
 756         break;
 757       }
 758     }
 759   }
 760 }
 761 
 762 // Delete exception caches that have been concurrently unlinked,
 763 // followed by a global handshake operation.
 764 void CodeCache::purge_exception_caches() {
 765   ExceptionCache* curr = _exception_cache_purge_list;
 766   while (curr != NULL) {
 767     ExceptionCache* next = curr-&gt;purge_list_next();
 768     delete curr;
 769     curr = next;
 770   }
 771   _exception_cache_purge_list = NULL;
 772 }
 773 
 774 uint8_t CodeCache::_unloading_cycle = 1;
 775 
 776 void CodeCache::increment_unloading_cycle() {
 777   // 2-bit value (see IsUnloadingState in nmethod.cpp for details)
 778   // 0 is reserved for new methods.
 779   _unloading_cycle = (_unloading_cycle + 1) % 4;
 780   if (_unloading_cycle == 0) {
 781     _unloading_cycle = 1;
 782   }
 783 }
 784 
 785 CodeCache::UnloadingScope::UnloadingScope(BoolObjectClosure* is_alive)
 786   : _is_unloading_behaviour(is_alive)
 787 {
 788   _saved_behaviour = IsUnloadingBehaviour::current();
 789   IsUnloadingBehaviour::set_current(&amp;_is_unloading_behaviour);
 790   increment_unloading_cycle();
 791   DependencyContext::cleaning_start();
 792 }
 793 
 794 CodeCache::UnloadingScope::~UnloadingScope() {
 795   IsUnloadingBehaviour::set_current(_saved_behaviour);
 796   DependencyContext::cleaning_end();
 797 }
 798 
 799 void CodeCache::verify_oops() {
 800   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 801   VerifyOopClosure voc;
 802   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 803   while(iter.next()) {
 804     nmethod* nm = iter.method();
 805     nm-&gt;oops_do(&amp;voc);
 806     nm-&gt;verify_oop_relocations();
 807   }
 808 }
 809 
 810 int CodeCache::blob_count(int code_blob_type) {
 811   CodeHeap* heap = get_code_heap(code_blob_type);
 812   return (heap != NULL) ? heap-&gt;blob_count() : 0;
 813 }
 814 
 815 int CodeCache::blob_count() {
 816   int count = 0;
 817   FOR_ALL_HEAPS(heap) {
 818     count += (*heap)-&gt;blob_count();
 819   }
 820   return count;
 821 }
 822 
 823 int CodeCache::nmethod_count(int code_blob_type) {
 824   CodeHeap* heap = get_code_heap(code_blob_type);
 825   return (heap != NULL) ? heap-&gt;nmethod_count() : 0;
 826 }
 827 
 828 int CodeCache::nmethod_count() {
 829   int count = 0;
 830   FOR_ALL_NMETHOD_HEAPS(heap) {
 831     count += (*heap)-&gt;nmethod_count();
 832   }
 833   return count;
 834 }
 835 
 836 int CodeCache::adapter_count(int code_blob_type) {
 837   CodeHeap* heap = get_code_heap(code_blob_type);
 838   return (heap != NULL) ? heap-&gt;adapter_count() : 0;
 839 }
 840 
 841 int CodeCache::adapter_count() {
 842   int count = 0;
 843   FOR_ALL_HEAPS(heap) {
 844     count += (*heap)-&gt;adapter_count();
 845   }
 846   return count;
 847 }
 848 
 849 address CodeCache::low_bound(int code_blob_type) {
 850   CodeHeap* heap = get_code_heap(code_blob_type);
 851   return (heap != NULL) ? (address)heap-&gt;low_boundary() : NULL;
 852 }
 853 
 854 address CodeCache::high_bound(int code_blob_type) {
 855   CodeHeap* heap = get_code_heap(code_blob_type);
 856   return (heap != NULL) ? (address)heap-&gt;high_boundary() : NULL;
 857 }
 858 
 859 size_t CodeCache::capacity() {
 860   size_t cap = 0;
 861   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 862     cap += (*heap)-&gt;capacity();
 863   }
 864   return cap;
 865 }
 866 
 867 size_t CodeCache::unallocated_capacity(int code_blob_type) {
 868   CodeHeap* heap = get_code_heap(code_blob_type);
 869   return (heap != NULL) ? heap-&gt;unallocated_capacity() : 0;
 870 }
 871 
 872 size_t CodeCache::unallocated_capacity() {
 873   size_t unallocated_cap = 0;
 874   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 875     unallocated_cap += (*heap)-&gt;unallocated_capacity();
 876   }
 877   return unallocated_cap;
 878 }
 879 
 880 size_t CodeCache::max_capacity() {
 881   size_t max_cap = 0;
 882   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 883     max_cap += (*heap)-&gt;max_capacity();
 884   }
 885   return max_cap;
 886 }
 887 
 888 /**
 889  * Returns the reverse free ratio. E.g., if 25% (1/4) of the code heap
 890  * is free, reverse_free_ratio() returns 4.
 891  */
 892 double CodeCache::reverse_free_ratio(int code_blob_type) {
 893   CodeHeap* heap = get_code_heap(code_blob_type);
 894   if (heap == NULL) {
 895     return 0;
 896   }
 897 
 898   double unallocated_capacity = MAX2((double)heap-&gt;unallocated_capacity(), 1.0); // Avoid division by 0;
 899   double max_capacity = (double)heap-&gt;max_capacity();
 900   double result = max_capacity / unallocated_capacity;
 901   assert (max_capacity &gt;= unallocated_capacity, &quot;Must be&quot;);
 902   assert (result &gt;= 1.0, &quot;reverse_free_ratio must be at least 1. It is %f&quot;, result);
 903   return result;
 904 }
 905 
 906 size_t CodeCache::bytes_allocated_in_freelists() {
 907   size_t allocated_bytes = 0;
 908   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 909     allocated_bytes += (*heap)-&gt;allocated_in_freelist();
 910   }
 911   return allocated_bytes;
 912 }
 913 
 914 int CodeCache::allocated_segments() {
 915   int number_of_segments = 0;
 916   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 917     number_of_segments += (*heap)-&gt;allocated_segments();
 918   }
 919   return number_of_segments;
 920 }
 921 
 922 size_t CodeCache::freelists_length() {
 923   size_t length = 0;
 924   FOR_ALL_ALLOCABLE_HEAPS(heap) {
 925     length += (*heap)-&gt;freelist_length();
 926   }
 927   return length;
 928 }
 929 
 930 void icache_init();
 931 
 932 void CodeCache::initialize() {
 933   assert(CodeCacheSegmentSize &gt;= (uintx)CodeEntryAlignment, &quot;CodeCacheSegmentSize must be large enough to align entry points&quot;);
 934 #ifdef COMPILER2
 935   assert(CodeCacheSegmentSize &gt;= (uintx)OptoLoopAlignment,  &quot;CodeCacheSegmentSize must be large enough to align inner loops&quot;);
 936 #endif
 937   assert(CodeCacheSegmentSize &gt;= sizeof(jdouble),    &quot;CodeCacheSegmentSize must be large enough to align constants&quot;);
 938   // This was originally just a check of the alignment, causing failure, instead, round
 939   // the code cache to the page size.  In particular, Solaris is moving to a larger
 940   // default page size.
 941   CodeCacheExpansionSize = align_up(CodeCacheExpansionSize, os::vm_page_size());
 942 
 943   if (SegmentedCodeCache) {
 944     // Use multiple code heaps
 945     initialize_heaps();
 946   } else {
 947     // Use a single code heap
 948     FLAG_SET_ERGO(NonNMethodCodeHeapSize, 0);
 949     FLAG_SET_ERGO(ProfiledCodeHeapSize, 0);
 950     FLAG_SET_ERGO(NonProfiledCodeHeapSize, 0);
 951     ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);
 952     add_heap(rs, &quot;CodeCache&quot;, CodeBlobType::All);
 953   }
 954 
 955   // Initialize ICache flush mechanism
 956   // This service is needed for os::register_code_area
 957   icache_init();
 958 
 959   // Give OS a chance to register generated code area.
 960   // This is used on Windows 64 bit platforms to register
 961   // Structured Exception Handlers for our generated code.
 962   os::register_code_area((char*)low_bound(), (char*)high_bound());
 963 }
 964 
 965 void codeCache_init() {
 966   CodeCache::initialize();
 967   // Load AOT libraries and add AOT code heaps.
 968   AOTLoader::initialize();
 969 }
 970 
 971 //------------------------------------------------------------------------------------------------
 972 
 973 int CodeCache::number_of_nmethods_with_dependencies() {
 974   return _number_of_nmethods_with_dependencies;
 975 }
 976 
 977 void CodeCache::clear_inline_caches() {
 978   assert_locked_or_safepoint(CodeCache_lock);
 979   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
 980   while(iter.next()) {
 981     iter.method()-&gt;clear_inline_caches();
 982   }
 983 }
 984 
 985 void CodeCache::cleanup_inline_caches() {
 986   assert_locked_or_safepoint(CodeCache_lock);
 987   NMethodIterator iter(NMethodIterator::only_alive_and_not_unloading);
 988   while(iter.next()) {
 989     iter.method()-&gt;cleanup_inline_caches(/*clean_all=*/true);
 990   }
 991 }
 992 
 993 // Keeps track of time spent for checking dependencies
 994 NOT_PRODUCT(static elapsedTimer dependentCheckTime;)
 995 
 996 int CodeCache::mark_for_deoptimization(KlassDepChange&amp; changes) {
 997   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
 998   int number_of_marked_CodeBlobs = 0;
 999 
1000   // search the hierarchy looking for nmethods which are affected by the loading of this class
1001 
1002   // then search the interfaces this class implements looking for nmethods
1003   // which might be dependent of the fact that an interface only had one
1004   // implementor.
1005   // nmethod::check_all_dependencies works only correctly, if no safepoint
1006   // can happen
1007   NoSafepointVerifier nsv;
1008   for (DepChange::ContextStream str(changes, nsv); str.next(); ) {
1009     Klass* d = str.klass();
1010     number_of_marked_CodeBlobs += InstanceKlass::cast(d)-&gt;mark_dependent_nmethods(changes);
1011   }
1012 
1013 #ifndef PRODUCT
1014   if (VerifyDependencies) {
1015     // Object pointers are used as unique identifiers for dependency arguments. This
1016     // is only possible if no safepoint, i.e., GC occurs during the verification code.
1017     dependentCheckTime.start();
1018     nmethod::check_all_dependencies(changes);
1019     dependentCheckTime.stop();
1020   }
1021 #endif
1022 
1023   return number_of_marked_CodeBlobs;
1024 }
1025 
1026 CompiledMethod* CodeCache::find_compiled(void* start) {
1027   CodeBlob *cb = find_blob(start);
1028   assert(cb == NULL || cb-&gt;is_compiled(), &quot;did not find an compiled_method&quot;);
1029   return (CompiledMethod*)cb;
1030 }
1031 
1032 bool CodeCache::is_far_target(address target) {
1033 #if INCLUDE_AOT
1034   return NativeCall::is_far_call(_low_bound,  target) ||
1035          NativeCall::is_far_call(_high_bound, target);
1036 #else
1037   return false;
1038 #endif
1039 }
1040 
1041 #if INCLUDE_JVMTI
1042 // RedefineClasses support for unloading nmethods that are dependent on &quot;old&quot; methods.
1043 // We don&#39;t really expect this table to grow very large.  If it does, it can become a hashtable.
1044 static GrowableArray&lt;CompiledMethod*&gt;* old_compiled_method_table = NULL;
1045 
1046 static void add_to_old_table(CompiledMethod* c) {
1047   if (old_compiled_method_table == NULL) {
1048     old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CompiledMethod*&gt;(100, mtCode);
1049   }
1050   old_compiled_method_table-&gt;push(c);
1051 }
1052 
1053 static void reset_old_method_table() {
1054   if (old_compiled_method_table != NULL) {
1055     delete old_compiled_method_table;
1056     old_compiled_method_table = NULL;
1057   }
1058 }
1059 
1060 // Remove this method when zombied or unloaded.
1061 void CodeCache::unregister_old_nmethod(CompiledMethod* c) {
1062   assert_lock_strong(CodeCache_lock);
1063   if (old_compiled_method_table != NULL) {
1064     int index = old_compiled_method_table-&gt;find(c);
1065     if (index != -1) {
1066       old_compiled_method_table-&gt;delete_at(index);
1067     }
1068   }
1069 }
1070 
1071 void CodeCache::old_nmethods_do(MetadataClosure* f) {
1072   // Walk old method table and mark those on stack.
1073   int length = 0;
1074   if (old_compiled_method_table != NULL) {
1075     length = old_compiled_method_table-&gt;length();
1076     for (int i = 0; i &lt; length; i++) {
1077       CompiledMethod* cm = old_compiled_method_table-&gt;at(i);
1078       // Only walk alive nmethods, the dead ones will get removed by the sweeper or GC.
1079       if (cm-&gt;is_alive() &amp;&amp; !cm-&gt;is_unloading()) {
1080         old_compiled_method_table-&gt;at(i)-&gt;metadata_do(f);
1081       }
1082     }
1083   }
1084   log_debug(redefine, class, nmethod)(&quot;Walked %d nmethods for mark_on_stack&quot;, length);
1085 }
1086 
1087 // Just marks the methods in this class as needing deoptimization
1088 void CodeCache::mark_for_evol_deoptimization(InstanceKlass* dependee) {
1089   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1090 
1091   // Mark dependent AOT nmethods, which are only found via the class redefined.
1092   // TODO: add dependencies to aotCompiledMethod&#39;s metadata section so this isn&#39;t
1093   // needed.
1094   AOTLoader::mark_evol_dependent_methods(dependee);
1095 }
1096 
1097 
1098 // Walk compiled methods and mark dependent methods for deoptimization.
1099 int CodeCache::mark_dependents_for_evol_deoptimization() {
1100   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1101   // Each redefinition creates a new set of nmethods that have references to &quot;old&quot; Methods
1102   // So delete old method table and create a new one.
1103   reset_old_method_table();
1104 
1105   int number_of_marked_CodeBlobs = 0;
1106   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1107   while(iter.next()) {
1108     CompiledMethod* nm = iter.method();
1109     // Walk all alive nmethods to check for old Methods.
1110     // This includes methods whose inline caches point to old methods, so
1111     // inline cache clearing is unnecessary.
1112     if (nm-&gt;has_evol_metadata()) {
1113       nm-&gt;mark_for_deoptimization();
1114       add_to_old_table(nm);
1115       number_of_marked_CodeBlobs++;
1116     }
1117   }
1118 
1119   // return total count of nmethods marked for deoptimization, if zero the caller
1120   // can skip deoptimization
1121   return number_of_marked_CodeBlobs;
1122 }
1123 
1124 void CodeCache::mark_all_nmethods_for_evol_deoptimization() {
1125   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1126   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1127   while(iter.next()) {
1128     CompiledMethod* nm = iter.method();
1129     if (!nm-&gt;method()-&gt;is_method_handle_intrinsic()) {
1130       nm-&gt;mark_for_deoptimization();
1131       if (nm-&gt;has_evol_metadata()) {
1132         add_to_old_table(nm);
1133       }
1134     }
1135   }
1136 }
1137 
1138 // Flushes compiled methods dependent on redefined classes, that have already been
1139 // marked for deoptimization.
1140 void CodeCache::flush_evol_dependents() {
1141   assert(SafepointSynchronize::is_at_safepoint(), &quot;Can only do this at a safepoint!&quot;);
1142 
1143   // CodeCache can only be updated by a thread_in_VM and they will all be
1144   // stopped during the safepoint so CodeCache will be safe to update without
1145   // holding the CodeCache_lock.
1146 
1147   // At least one nmethod has been marked for deoptimization
1148 
1149   Deoptimization::deoptimize_all_marked();
1150 }
1151 #endif // INCLUDE_JVMTI
1152 
1153 // Mark methods for deopt (if safe or possible).
1154 void CodeCache::mark_all_nmethods_for_deoptimization() {
1155   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1156   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1157   while(iter.next()) {
1158     CompiledMethod* nm = iter.method();
1159     if (!nm-&gt;is_native_method()) {
1160       nm-&gt;mark_for_deoptimization();
1161     }
1162   }
1163 }
1164 
1165 int CodeCache::mark_for_deoptimization(Method* dependee) {
1166   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1167   int number_of_marked_CodeBlobs = 0;
1168 
1169   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1170   while(iter.next()) {
1171     CompiledMethod* nm = iter.method();
1172     if (nm-&gt;is_dependent_on_method(dependee)) {
1173       ResourceMark rm;
1174       nm-&gt;mark_for_deoptimization();
1175       number_of_marked_CodeBlobs++;
1176     }
1177   }
1178 
1179   return number_of_marked_CodeBlobs;
1180 }
1181 
1182 void CodeCache::make_marked_nmethods_not_entrant() {
1183   assert_locked_or_safepoint(CodeCache_lock);
1184   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1185   while(iter.next()) {
1186     CompiledMethod* nm = iter.method();
1187     if (nm-&gt;is_marked_for_deoptimization()) {
1188       nm-&gt;make_not_entrant();
1189     }
1190   }
1191 }
1192 
1193 // Flushes compiled methods dependent on dependee.
1194 void CodeCache::flush_dependents_on(InstanceKlass* dependee) {
1195   assert_lock_strong(Compile_lock);
1196 
1197   if (number_of_nmethods_with_dependencies() == 0) return;
1198 
1199   KlassDepChange changes(dependee);
1200 
1201   // Compute the dependent nmethods
1202   if (mark_for_deoptimization(changes) &gt; 0) {
1203     // At least one nmethod has been marked for deoptimization
1204     Deoptimization::deoptimize_all_marked();
1205   }
1206 }
1207 
1208 // Flushes compiled methods dependent on dependee
1209 void CodeCache::flush_dependents_on_method(const methodHandle&amp; m_h) {
1210   // --- Compile_lock is not held. However we are at a safepoint.
1211   assert_locked_or_safepoint(Compile_lock);
1212 
1213   // Compute the dependent nmethods
1214   if (mark_for_deoptimization(m_h()) &gt; 0) {
1215     Deoptimization::deoptimize_all_marked();
1216   }
1217 }
1218 
1219 void CodeCache::verify() {
1220   assert_locked_or_safepoint(CodeCache_lock);
1221   FOR_ALL_HEAPS(heap) {
1222     (*heap)-&gt;verify();
1223     FOR_ALL_BLOBS(cb, *heap) {
1224       if (cb-&gt;is_alive()) {
1225         cb-&gt;verify();
1226       }
1227     }
1228   }
1229 }
1230 
1231 // A CodeHeap is full. Print out warning and report event.
1232 PRAGMA_DIAG_PUSH
1233 PRAGMA_FORMAT_NONLITERAL_IGNORED
1234 void CodeCache::report_codemem_full(int code_blob_type, bool print) {
1235   // Get nmethod heap for the given CodeBlobType and build CodeCacheFull event
1236   CodeHeap* heap = get_code_heap(code_blob_type);
1237   assert(heap != NULL, &quot;heap is null&quot;);
1238 
1239   if ((heap-&gt;full_count() == 0) || print) {
1240     // Not yet reported for this heap, report
1241     if (SegmentedCodeCache) {
1242       ResourceMark rm;
1243       stringStream msg1_stream, msg2_stream;
1244       msg1_stream.print(&quot;%s is full. Compiler has been disabled.&quot;,
1245                         get_code_heap_name(code_blob_type));
1246       msg2_stream.print(&quot;Try increasing the code heap size using -XX:%s=&quot;,
1247                  get_code_heap_flag_name(code_blob_type));
1248       const char *msg1 = msg1_stream.as_string();
1249       const char *msg2 = msg2_stream.as_string();
1250 
1251       log_warning(codecache)(&quot;%s&quot;, msg1);
1252       log_warning(codecache)(&quot;%s&quot;, msg2);
1253       warning(&quot;%s&quot;, msg1);
1254       warning(&quot;%s&quot;, msg2);
1255     } else {
1256       const char *msg1 = &quot;CodeCache is full. Compiler has been disabled.&quot;;
1257       const char *msg2 = &quot;Try increasing the code cache size using -XX:ReservedCodeCacheSize=&quot;;
1258 
1259       log_warning(codecache)(&quot;%s&quot;, msg1);
1260       log_warning(codecache)(&quot;%s&quot;, msg2);
1261       warning(&quot;%s&quot;, msg1);
1262       warning(&quot;%s&quot;, msg2);
1263     }
1264     ResourceMark rm;
1265     stringStream s;
1266     // Dump code cache into a buffer before locking the tty.
1267     {
1268       MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1269       print_summary(&amp;s);
1270     }
1271     {
1272       ttyLocker ttyl;
1273       tty-&gt;print(&quot;%s&quot;, s.as_string());
1274     }
1275 
1276     if (heap-&gt;full_count() == 0) {
1277       if (PrintCodeHeapAnalytics) {
1278         CompileBroker::print_heapinfo(tty, &quot;all&quot;, 4096); // details, may be a lot!
1279       }
1280     }
1281   }
1282 
1283   heap-&gt;report_full();
1284 
1285   EventCodeCacheFull event;
1286   if (event.should_commit()) {
1287     event.set_codeBlobType((u1)code_blob_type);
1288     event.set_startAddress((u8)heap-&gt;low_boundary());
1289     event.set_commitedTopAddress((u8)heap-&gt;high());
1290     event.set_reservedTopAddress((u8)heap-&gt;high_boundary());
1291     event.set_entryCount(heap-&gt;blob_count());
1292     event.set_methodCount(heap-&gt;nmethod_count());
1293     event.set_adaptorCount(heap-&gt;adapter_count());
1294     event.set_unallocatedCapacity(heap-&gt;unallocated_capacity());
1295     event.set_fullCount(heap-&gt;full_count());
1296     event.commit();
1297   }
1298 }
1299 PRAGMA_DIAG_POP
1300 
1301 void CodeCache::print_memory_overhead() {
1302   size_t wasted_bytes = 0;
1303   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1304       CodeHeap* curr_heap = *heap;
1305       for (CodeBlob* cb = (CodeBlob*)curr_heap-&gt;first(); cb != NULL; cb = (CodeBlob*)curr_heap-&gt;next(cb)) {
1306         HeapBlock* heap_block = ((HeapBlock*)cb) - 1;
1307         wasted_bytes += heap_block-&gt;length() * CodeCacheSegmentSize - cb-&gt;size();
1308       }
1309   }
1310   // Print bytes that are allocated in the freelist
1311   ttyLocker ttl;
1312   tty-&gt;print_cr(&quot;Number of elements in freelist: &quot; SSIZE_FORMAT,       freelists_length());
1313   tty-&gt;print_cr(&quot;Allocated in freelist:          &quot; SSIZE_FORMAT &quot;kB&quot;,  bytes_allocated_in_freelists()/K);
1314   tty-&gt;print_cr(&quot;Unused bytes in CodeBlobs:      &quot; SSIZE_FORMAT &quot;kB&quot;,  (wasted_bytes/K));
1315   tty-&gt;print_cr(&quot;Segment map size:               &quot; SSIZE_FORMAT &quot;kB&quot;,  allocated_segments()/K); // 1 byte per segment
1316 }
1317 
1318 //------------------------------------------------------------------------------------------------
1319 // Non-product version
1320 
1321 #ifndef PRODUCT
1322 
1323 void CodeCache::print_trace(const char* event, CodeBlob* cb, int size) {
1324   if (PrintCodeCache2) {  // Need to add a new flag
1325     ResourceMark rm;
1326     if (size == 0)  size = cb-&gt;size();
1327     tty-&gt;print_cr(&quot;CodeCache %s:  addr: &quot; INTPTR_FORMAT &quot;, size: 0x%x&quot;, event, p2i(cb), size);
1328   }
1329 }
1330 
1331 void CodeCache::print_internals() {
1332   int nmethodCount = 0;
1333   int runtimeStubCount = 0;
1334   int adapterCount = 0;
1335   int deoptimizationStubCount = 0;
1336   int uncommonTrapStubCount = 0;
1337   int bufferBlobCount = 0;
1338   int total = 0;
1339   int nmethodAlive = 0;
1340   int nmethodNotEntrant = 0;
1341   int nmethodZombie = 0;
1342   int nmethodUnloaded = 0;
1343   int nmethodJava = 0;
1344   int nmethodNative = 0;
1345   int max_nm_size = 0;
1346   ResourceMark rm;
1347 
1348   int i = 0;
1349   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1350     if ((_nmethod_heaps-&gt;length() &gt;= 1) &amp;&amp; Verbose) {
1351       tty-&gt;print_cr(&quot;-- %s --&quot;, (*heap)-&gt;name());
1352     }
1353     FOR_ALL_BLOBS(cb, *heap) {
1354       total++;
1355       if (cb-&gt;is_nmethod()) {
1356         nmethod* nm = (nmethod*)cb;
1357 
1358         if (Verbose &amp;&amp; nm-&gt;method() != NULL) {
1359           ResourceMark rm;
1360           char *method_name = nm-&gt;method()-&gt;name_and_sig_as_C_string();
1361           tty-&gt;print(&quot;%s&quot;, method_name);
1362           if(nm-&gt;is_alive()) { tty-&gt;print_cr(&quot; alive&quot;); }
1363           if(nm-&gt;is_not_entrant()) { tty-&gt;print_cr(&quot; not-entrant&quot;); }
1364           if(nm-&gt;is_zombie()) { tty-&gt;print_cr(&quot; zombie&quot;); }
1365         }
1366 
1367         nmethodCount++;
1368 
1369         if(nm-&gt;is_alive()) { nmethodAlive++; }
1370         if(nm-&gt;is_not_entrant()) { nmethodNotEntrant++; }
1371         if(nm-&gt;is_zombie()) { nmethodZombie++; }
1372         if(nm-&gt;is_unloaded()) { nmethodUnloaded++; }
1373         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_native_method()) { nmethodNative++; }
1374 
1375         if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1376           nmethodJava++;
1377           max_nm_size = MAX2(max_nm_size, nm-&gt;size());
1378         }
1379       } else if (cb-&gt;is_runtime_stub()) {
1380         runtimeStubCount++;
1381       } else if (cb-&gt;is_deoptimization_stub()) {
1382         deoptimizationStubCount++;
1383       } else if (cb-&gt;is_uncommon_trap_stub()) {
1384         uncommonTrapStubCount++;
1385       } else if (cb-&gt;is_adapter_blob()) {
1386         adapterCount++;
1387       } else if (cb-&gt;is_buffer_blob()) {
1388         bufferBlobCount++;
1389       }
1390     }
1391   }
1392 
1393   int bucketSize = 512;
1394   int bucketLimit = max_nm_size / bucketSize + 1;
1395   int *buckets = NEW_C_HEAP_ARRAY(int, bucketLimit, mtCode);
1396   memset(buckets, 0, sizeof(int) * bucketLimit);
1397 
1398   NMethodIterator iter(NMethodIterator::all_blobs);
1399   while(iter.next()) {
1400     nmethod* nm = iter.method();
1401     if(nm-&gt;method() != NULL &amp;&amp; nm-&gt;is_java_method()) {
1402       buckets[nm-&gt;size() / bucketSize]++;
1403     }
1404   }
1405 
1406   tty-&gt;print_cr(&quot;Code Cache Entries (total of %d)&quot;,total);
1407   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1408   tty-&gt;print_cr(&quot;nmethods: %d&quot;,nmethodCount);
1409   tty-&gt;print_cr(&quot;\talive: %d&quot;,nmethodAlive);
1410   tty-&gt;print_cr(&quot;\tnot_entrant: %d&quot;,nmethodNotEntrant);
1411   tty-&gt;print_cr(&quot;\tzombie: %d&quot;,nmethodZombie);
1412   tty-&gt;print_cr(&quot;\tunloaded: %d&quot;,nmethodUnloaded);
1413   tty-&gt;print_cr(&quot;\tjava: %d&quot;,nmethodJava);
1414   tty-&gt;print_cr(&quot;\tnative: %d&quot;,nmethodNative);
1415   tty-&gt;print_cr(&quot;runtime_stubs: %d&quot;,runtimeStubCount);
1416   tty-&gt;print_cr(&quot;adapters: %d&quot;,adapterCount);
1417   tty-&gt;print_cr(&quot;buffer blobs: %d&quot;,bufferBlobCount);
1418   tty-&gt;print_cr(&quot;deoptimization_stubs: %d&quot;,deoptimizationStubCount);
1419   tty-&gt;print_cr(&quot;uncommon_traps: %d&quot;,uncommonTrapStubCount);
1420   tty-&gt;print_cr(&quot;\nnmethod size distribution (non-zombie java)&quot;);
1421   tty-&gt;print_cr(&quot;-------------------------------------------------&quot;);
1422 
1423   for(int i=0; i&lt;bucketLimit; i++) {
1424     if(buckets[i] != 0) {
1425       tty-&gt;print(&quot;%d - %d bytes&quot;,i*bucketSize,(i+1)*bucketSize);
1426       tty-&gt;fill_to(40);
1427       tty-&gt;print_cr(&quot;%d&quot;,buckets[i]);
1428     }
1429   }
1430 
1431   FREE_C_HEAP_ARRAY(int, buckets);
1432   print_memory_overhead();
1433 }
1434 
1435 #endif // !PRODUCT
1436 
1437 void CodeCache::print() {
1438   print_summary(tty);
1439 
1440 #ifndef PRODUCT
1441   if (!Verbose) return;
1442 
1443   CodeBlob_sizes live;
1444   CodeBlob_sizes dead;
1445 
1446   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1447     FOR_ALL_BLOBS(cb, *heap) {
1448       if (!cb-&gt;is_alive()) {
1449         dead.add(cb);
1450       } else {
1451         live.add(cb);
1452       }
1453     }
1454   }
1455 
1456   tty-&gt;print_cr(&quot;CodeCache:&quot;);
1457   tty-&gt;print_cr(&quot;nmethod dependency checking time %fs&quot;, dependentCheckTime.seconds());
1458 
1459   if (!live.is_empty()) {
1460     live.print(&quot;live&quot;);
1461   }
1462   if (!dead.is_empty()) {
1463     dead.print(&quot;dead&quot;);
1464   }
1465 
1466   if (WizardMode) {
1467      // print the oop_map usage
1468     int code_size = 0;
1469     int number_of_blobs = 0;
1470     int number_of_oop_maps = 0;
1471     int map_size = 0;
1472     FOR_ALL_ALLOCABLE_HEAPS(heap) {
1473       FOR_ALL_BLOBS(cb, *heap) {
1474         if (cb-&gt;is_alive()) {
1475           number_of_blobs++;
1476           code_size += cb-&gt;code_size();
1477           ImmutableOopMapSet* set = cb-&gt;oop_maps();
1478           if (set != NULL) {
1479             number_of_oop_maps += set-&gt;count();
1480             map_size           += set-&gt;nr_of_bytes();
1481           }
1482         }
1483       }
1484     }
1485     tty-&gt;print_cr(&quot;OopMaps&quot;);
1486     tty-&gt;print_cr(&quot;  #blobs    = %d&quot;, number_of_blobs);
1487     tty-&gt;print_cr(&quot;  code size = %d&quot;, code_size);
1488     tty-&gt;print_cr(&quot;  #oop_maps = %d&quot;, number_of_oop_maps);
1489     tty-&gt;print_cr(&quot;  map size  = %d&quot;, map_size);
1490   }
1491 
1492 #endif // !PRODUCT
1493 }
1494 
1495 void CodeCache::print_summary(outputStream* st, bool detailed) {
1496   int full_count = 0;
1497   FOR_ALL_HEAPS(heap_iterator) {
1498     CodeHeap* heap = (*heap_iterator);
1499     size_t total = (heap-&gt;high_boundary() - heap-&gt;low_boundary());
1500     if (_heaps-&gt;length() &gt;= 1) {
1501       st-&gt;print(&quot;%s:&quot;, heap-&gt;name());
1502     } else {
1503       st-&gt;print(&quot;CodeCache:&quot;);
1504     }
1505     st-&gt;print_cr(&quot; size=&quot; SIZE_FORMAT &quot;Kb used=&quot; SIZE_FORMAT
1506                  &quot;Kb max_used=&quot; SIZE_FORMAT &quot;Kb free=&quot; SIZE_FORMAT &quot;Kb&quot;,
1507                  total/K, (total - heap-&gt;unallocated_capacity())/K,
1508                  heap-&gt;max_allocated_capacity()/K, heap-&gt;unallocated_capacity()/K);
1509 
1510     if (detailed) {
1511       st-&gt;print_cr(&quot; bounds [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot;]&quot;,
1512                    p2i(heap-&gt;low_boundary()),
1513                    p2i(heap-&gt;high()),
1514                    p2i(heap-&gt;high_boundary()));
1515 
1516       full_count += get_codemem_full_count(heap-&gt;code_blob_type());
1517     }
1518   }
1519 
1520   if (detailed) {
1521     st-&gt;print_cr(&quot; total_blobs=&quot; UINT32_FORMAT &quot; nmethods=&quot; UINT32_FORMAT
1522                        &quot; adapters=&quot; UINT32_FORMAT,
1523                        blob_count(), nmethod_count(), adapter_count());
1524     st-&gt;print_cr(&quot; compilation: %s&quot;, CompileBroker::should_compile_new_jobs() ?
1525                  &quot;enabled&quot; : Arguments::mode() == Arguments::_int ?
1526                  &quot;disabled (interpreter mode)&quot; :
1527                  &quot;disabled (not enough contiguous free space left)&quot;);
1528     st-&gt;print_cr(&quot;              stopped_count=%d, restarted_count=%d&quot;,
1529                  CompileBroker::get_total_compiler_stopped_count(),
1530                  CompileBroker::get_total_compiler_restarted_count());
1531     st-&gt;print_cr(&quot; full_count=%d&quot;, full_count);
1532   }
1533 }
1534 
1535 void CodeCache::print_codelist(outputStream* st) {
1536   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1537 
1538   CompiledMethodIterator iter(CompiledMethodIterator::only_alive_and_not_unloading);
1539   while (iter.next()) {
1540     CompiledMethod* cm = iter.method();
1541     ResourceMark rm;
1542     char* method_name = cm-&gt;method()-&gt;name_and_sig_as_C_string();
1543     st-&gt;print_cr(&quot;%d %d %d %s [&quot; INTPTR_FORMAT &quot;, &quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;]&quot;,
1544                  cm-&gt;compile_id(), cm-&gt;comp_level(), cm-&gt;get_state(),
1545                  method_name,
1546                  (intptr_t)cm-&gt;header_begin(), (intptr_t)cm-&gt;code_begin(), (intptr_t)cm-&gt;code_end());
1547   }
1548 }
1549 
1550 void CodeCache::print_layout(outputStream* st) {
1551   MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1552   ResourceMark rm;
1553   print_summary(st, true);
1554 }
1555 
1556 void CodeCache::log_state(outputStream* st) {
1557   st-&gt;print(&quot; total_blobs=&#39;&quot; UINT32_FORMAT &quot;&#39; nmethods=&#39;&quot; UINT32_FORMAT &quot;&#39;&quot;
1558             &quot; adapters=&#39;&quot; UINT32_FORMAT &quot;&#39; free_code_cache=&#39;&quot; SIZE_FORMAT &quot;&#39;&quot;,
1559             blob_count(), nmethod_count(), adapter_count(),
1560             unallocated_capacity());
1561 }
1562 
1563 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
1564 
1565 void CodeCache::aggregate(outputStream *out, size_t granularity) {
1566   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1567     CodeHeapState::aggregate(out, (*heap), granularity);
1568   }
1569 }
1570 
1571 void CodeCache::discard(outputStream *out) {
1572   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1573     CodeHeapState::discard(out, (*heap));
1574   }
1575 }
1576 
1577 void CodeCache::print_usedSpace(outputStream *out) {
1578   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1579     CodeHeapState::print_usedSpace(out, (*heap));
1580   }
1581 }
1582 
1583 void CodeCache::print_freeSpace(outputStream *out) {
1584   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1585     CodeHeapState::print_freeSpace(out, (*heap));
1586   }
1587 }
1588 
1589 void CodeCache::print_count(outputStream *out) {
1590   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1591     CodeHeapState::print_count(out, (*heap));
1592   }
1593 }
1594 
1595 void CodeCache::print_space(outputStream *out) {
1596   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1597     CodeHeapState::print_space(out, (*heap));
1598   }
1599 }
1600 
1601 void CodeCache::print_age(outputStream *out) {
1602   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1603     CodeHeapState::print_age(out, (*heap));
1604   }
1605 }
1606 
1607 void CodeCache::print_names(outputStream *out) {
1608   FOR_ALL_ALLOCABLE_HEAPS(heap) {
1609     CodeHeapState::print_names(out, (*heap));
1610   }
1611 }
1612 //---&lt;  END  &gt;--- CodeHeap State Analytics.
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;opto/adlcVMDeps.hpp&quot;
  29 #include &quot;runtime/handles.hpp&quot;
  30 
  31 // Portions of code courtesy of Clifford Click
  32 
  33 // Optimization - Graph Style
  34 
  35 
  36 // This class defines a Type lattice.  The lattice is used in the constant
  37 // propagation algorithms, and for some type-checking of the iloc code.
  38 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  39 // float &amp; double precision constants, sets of data-labels and code-labels.
  40 // The complete lattice is described below.  Subtypes have no relationship to
  41 // up or down in the lattice; that is entirely determined by the behavior of
  42 // the MEET/JOIN functions.
  43 
  44 class Dict;
  45 class Type;
  46 class   TypeD;
  47 class   TypeF;
  48 class   TypeInt;
  49 class   TypeLong;
  50 class   TypeNarrowPtr;
  51 class     TypeNarrowOop;
  52 class     TypeNarrowKlass;
  53 class   TypeAry;
  54 class   TypeTuple;
  55 class   TypeVect;
  56 class     TypeVectS;
  57 class     TypeVectD;
  58 class     TypeVectX;
  59 class     TypeVectY;
  60 class     TypeVectZ;
  61 class   TypePtr;
  62 class     TypeRawPtr;
  63 class     TypeOopPtr;
  64 class       TypeInstPtr;
  65 class       TypeAryPtr;
  66 class     TypeKlassPtr;
  67 class     TypeMetadataPtr;
  68 
  69 //------------------------------Type-------------------------------------------
  70 // Basic Type object, represents a set of primitive Values.
  71 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  72 // different kind of Type exists.  Types are never modified after creation, so
  73 // all their interesting fields are constant.
  74 class Type {
  75   friend class VMStructs;
  76 
  77 public:
  78   enum TYPES {
  79     Bad=0,                      // Type check
  80     Control,                    // Control of code (not in lattice)
  81     Top,                        // Top of the lattice
  82     Int,                        // Integer range (lo-hi)
  83     Long,                       // Long integer range (lo-hi)
  84     Half,                       // Placeholder half of doubleword
  85     NarrowOop,                  // Compressed oop pointer
  86     NarrowKlass,                // Compressed klass pointer
  87 
  88     Tuple,                      // Method signature or object layout
  89     Array,                      // Array types
  90     VectorS,                    //  32bit Vector types
  91     VectorD,                    //  64bit Vector types
  92     VectorX,                    // 128bit Vector types
  93     VectorY,                    // 256bit Vector types
  94     VectorZ,                    // 512bit Vector types
  95 
  96     AnyPtr,                     // Any old raw, klass, inst, or array pointer
  97     RawPtr,                     // Raw (non-oop) pointers
  98     OopPtr,                     // Any and all Java heap entities
  99     InstPtr,                    // Instance pointers (non-array objects)
 100     AryPtr,                     // Array pointers
 101     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 102 
 103     MetadataPtr,                // Generic metadata
 104     KlassPtr,                   // Klass pointers
 105 
 106     Function,                   // Function signature
 107     Abio,                       // Abstract I/O
 108     Return_Address,             // Subroutine return address
 109     Memory,                     // Abstract store
 110     FloatTop,                   // No float value
 111     FloatCon,                   // Floating point constant
 112     FloatBot,                   // Any float value
 113     DoubleTop,                  // No double value
 114     DoubleCon,                  // Double precision constant
 115     DoubleBot,                  // Any double value
 116     Bottom,                     // Bottom of lattice
 117     lastype                     // Bogus ending type (not in lattice)
 118   };
 119 
 120   // Signal values for offsets from a base pointer
 121   enum OFFSET_SIGNALS {
 122     OffsetTop = -2000000000,    // undefined offset
 123     OffsetBot = -2000000001     // any possible offset
 124   };
 125 
 126   // Min and max WIDEN values.
 127   enum WIDEN {
 128     WidenMin = 0,
 129     WidenMax = 3
 130   };
 131 
 132 private:
 133   typedef struct {
 134     TYPES                dual_type;
 135     BasicType            basic_type;
 136     const char*          msg;
 137     bool                 isa_oop;
 138     uint                 ideal_reg;
 139     relocInfo::relocType reloc;
 140   } TypeInfo;
 141 
 142   // Dictionary of types shared among compilations.
 143   static Dict* _shared_type_dict;
 144   static const TypeInfo _type_info[];
 145 
 146   static int uhash( const Type *const t );
 147   // Structural equality check.  Assumes that cmp() has already compared
 148   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 149   virtual bool eq( const Type *t ) const;
 150 
 151   // Top-level hash-table of types
 152   static Dict *type_dict() {
 153     return Compile::current()-&gt;type_dict();
 154   }
 155 
 156   // DUAL operation: reflect around lattice centerline.  Used instead of
 157   // join to ensure my lattice is symmetric up and down.  Dual is computed
 158   // lazily, on demand, and cached in _dual.
 159   const Type *_dual;            // Cached dual value
 160   // Table for efficient dualing of base types
 161   static const TYPES dual_type[lastype];
 162 
 163 #ifdef ASSERT
 164   // One type is interface, the other is oop
 165   virtual bool interface_vs_oop_helper(const Type *t) const;
 166 #endif
 167 
 168   const Type *meet_helper(const Type *t, bool include_speculative) const;
 169   void check_symmetrical(const Type *t, const Type *mt) const;
 170 
 171 protected:
 172   // Each class of type is also identified by its base.
 173   const TYPES _base;            // Enum of Types type
 174 
 175   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 176   // ~Type();                   // Use fast deallocation
 177   const Type *hashcons();       // Hash-cons the type
 178   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 179   const Type *join_helper(const Type *t, bool include_speculative) const {
 180     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 181   }
 182 
 183 public:
 184 
 185   inline void* operator new( size_t x ) throw() {
 186     Compile* compile = Compile::current();
 187     compile-&gt;set_type_last_size(x);
 188     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 189   }
 190   inline void operator delete( void* ptr ) {
 191     Compile* compile = Compile::current();
 192     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 193   }
 194 
 195   // Initialize the type system for a particular compilation.
 196   static void Initialize(Compile* compile);
 197 
 198   // Initialize the types shared by all compilations.
 199   static void Initialize_shared(Compile* compile);
 200 
 201   TYPES base() const {
 202     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 203     return _base;
 204   }
 205 
 206   // Create a new hash-consd type
 207   static const Type *make(enum TYPES);
 208   // Test for equivalence of types
 209   static int cmp( const Type *const t1, const Type *const t2 );
 210   // Test for higher or equal in lattice
 211   // Variant that drops the speculative part of the types
 212   bool higher_equal(const Type *t) const {
 213     return !cmp(meet(t),t-&gt;remove_speculative());
 214   }
 215   // Variant that keeps the speculative part of the types
 216   bool higher_equal_speculative(const Type *t) const {
 217     return !cmp(meet_speculative(t),t);
 218   }
 219 
 220   // MEET operation; lower in lattice.
 221   // Variant that drops the speculative part of the types
 222   const Type *meet(const Type *t) const {
 223     return meet_helper(t, false);
 224   }
 225   // Variant that keeps the speculative part of the types
 226   const Type *meet_speculative(const Type *t) const {
 227     return meet_helper(t, true)-&gt;cleanup_speculative();
 228   }
 229   // WIDEN: &#39;widens&#39; for Ints and other range types
 230   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 231   // NARROW: complement for widen, used by pessimistic phases
 232   virtual const Type *narrow( const Type *old ) const { return this; }
 233 
 234   // DUAL operation: reflect around lattice centerline.  Used instead of
 235   // join to ensure my lattice is symmetric up and down.
 236   const Type *dual() const { return _dual; }
 237 
 238   // Compute meet dependent on base type
 239   virtual const Type *xmeet( const Type *t ) const;
 240   virtual const Type *xdual() const;    // Compute dual right now.
 241 
 242   // JOIN operation; higher in lattice.  Done by finding the dual of the
 243   // meet of the dual of the 2 inputs.
 244   // Variant that drops the speculative part of the types
 245   const Type *join(const Type *t) const {
 246     return join_helper(t, false);
 247   }
 248   // Variant that keeps the speculative part of the types
 249   const Type *join_speculative(const Type *t) const {
 250     return join_helper(t, true)-&gt;cleanup_speculative();
 251   }
 252 
 253   // Modified version of JOIN adapted to the needs Node::Value.
 254   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 255   // Currently, it also works around limitations involving interface types.
 256   // Variant that drops the speculative part of the types
 257   const Type *filter(const Type *kills) const {
 258     return filter_helper(kills, false);
 259   }
 260   // Variant that keeps the speculative part of the types
 261   const Type *filter_speculative(const Type *kills) const {
 262     return filter_helper(kills, true)-&gt;cleanup_speculative();
 263   }
 264 
 265 #ifdef ASSERT
 266   // One type is interface, the other is oop
 267   virtual bool interface_vs_oop(const Type *t) const;
 268 #endif
 269 
 270   // Returns true if this pointer points at memory which contains a
 271   // compressed oop references.
 272   bool is_ptr_to_narrowoop() const;
 273   bool is_ptr_to_narrowklass() const;
 274 
 275   bool is_ptr_to_boxing_obj() const;
 276 
 277 
 278   // Convenience access
 279   float getf() const;
 280   double getd() const;
 281 
 282   const TypeInt    *is_int() const;
 283   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 284   const TypeLong   *is_long() const;
 285   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 286   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 287   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 288   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 289   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 290   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 291   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 292   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 293   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 294   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 295   const TypeVect   *is_vect() const;             // Vector
 296   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 297   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 298   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 299   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 300   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 301   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 302   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 303   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 304   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 305   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 306   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 307   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 308   const TypeInstPtr  *is_instptr() const;        // Instance
 309   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 310   const TypeAryPtr   *is_aryptr() const;         // Array oop
 311 
 312   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 313   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 314   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 315   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 316 
 317   virtual bool      is_finite() const;           // Has a finite value
 318   virtual bool      is_nan()    const;           // Is not a number (NaN)
 319 
 320   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 321   const TypePtr* make_ptr() const;
 322 
 323   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 324   // Asserts if the underlying type is not an oopptr or narrowoop.
 325   const TypeOopPtr* make_oopptr() const;
 326 
 327   // Returns this compressed pointer or the equivalent compressed version
 328   // of this pointer type.
 329   const TypeNarrowOop* make_narrowoop() const;
 330 
 331   // Returns this compressed klass pointer or the equivalent
 332   // compressed version of this pointer type.
 333   const TypeNarrowKlass* make_narrowklass() const;
 334 
 335   // Special test for register pressure heuristic
 336   bool is_floatingpoint() const;        // True if Float or Double base type
 337 
 338   // Do you have memory, directly or through a tuple?
 339   bool has_memory( ) const;
 340 
 341   // TRUE if type is a singleton
 342   virtual bool singleton(void) const;
 343 
 344   // TRUE if type is above the lattice centerline, and is therefore vacuous
 345   virtual bool empty(void) const;
 346 
 347   // Return a hash for this type.  The hash function is public so ConNode
 348   // (constants) can hash on their constant, which is represented by a Type.
 349   virtual int hash() const;
 350 
 351   // Map ideal registers (machine types) to ideal types
 352   static const Type *mreg2type[];
 353 
 354   // Printing, statistics
 355 #ifndef PRODUCT
 356   void         dump_on(outputStream *st) const;
 357   void         dump() const {
 358     dump_on(tty);
 359   }
 360   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 361   static  void dump_stats();
 362 
 363   static const char* str(const Type* t);
 364 #endif
 365   void typerr(const Type *t) const; // Mixing types error
 366 
 367   // Create basic type
 368   static const Type* get_const_basic_type(BasicType type) {
 369     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 370     return _const_basic_type[type];
 371   }
 372 
 373   // For two instance arrays of same dimension, return the base element types.
 374   // Otherwise or if the arrays have different dimensions, return NULL.
 375   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 376                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 377 
 378   // Mapping to the array element&#39;s basic type.
 379   BasicType array_element_basic_type() const;
 380 
 381   // Create standard type for a ciType:
 382   static const Type* get_const_type(ciType* type);
 383 
 384   // Create standard zero value:
 385   static const Type* get_zero_type(BasicType type) {
 386     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 387     return _zero_type[type];
 388   }
 389 
 390   // Report if this is a zero value (not top).
 391   bool is_zero_type() const {
 392     BasicType type = basic_type();
 393     if (type == T_VOID || type &gt;= T_CONFLICT)
 394       return false;
 395     else
 396       return (this == _zero_type[type]);
 397   }
 398 
 399   // Convenience common pre-built types.
 400   static const Type *ABIO;
 401   static const Type *BOTTOM;
 402   static const Type *CONTROL;
 403   static const Type *DOUBLE;
 404   static const Type *FLOAT;
 405   static const Type *HALF;
 406   static const Type *MEMORY;
 407   static const Type *MULTI;
 408   static const Type *RETURN_ADDRESS;
 409   static const Type *TOP;
 410 
 411   // Mapping from compiler type to VM BasicType
 412   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 413   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 414   const char* msg() const            { return _type_info[_base].msg; }
 415   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 416   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 417 
 418   // Mapping from CI type system to compiler type:
 419   static const Type* get_typeflow_type(ciType* type);
 420 
 421   static const Type* make_from_constant(ciConstant constant,
 422                                         bool require_constant = false,
 423                                         int stable_dimension = 0,
 424                                         bool is_narrow = false,
 425                                         bool is_autobox_cache = false);
 426 
 427   static const Type* make_constant_from_field(ciInstance* holder,
 428                                               int off,
 429                                               bool is_unsigned_load,
 430                                               BasicType loadbt);
 431 
 432   static const Type* make_constant_from_field(ciField* field,
 433                                               ciInstance* holder,
 434                                               BasicType loadbt,
 435                                               bool is_unsigned_load);
 436 
 437   static const Type* make_constant_from_array_element(ciArray* array,
 438                                                       int off,
 439                                                       int stable_dimension,
 440                                                       BasicType loadbt,
 441                                                       bool is_unsigned_load);
 442 
 443   // Speculative type helper methods. See TypePtr.
 444   virtual const TypePtr* speculative() const                                  { return NULL; }
 445   virtual ciKlass* speculative_type() const                                   { return NULL; }
 446   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 447   virtual bool speculative_maybe_null() const                                 { return true; }
 448   virtual bool speculative_always_null() const                                { return true; }
 449   virtual const Type* remove_speculative() const                              { return this; }
 450   virtual const Type* cleanup_speculative() const                             { return this; }
 451   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 452   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 453   const Type* maybe_remove_speculative(bool include_speculative) const;
 454 
 455   virtual bool maybe_null() const { return true; }
 456   virtual bool is_known_instance() const { return false; }
 457 
 458 private:
 459   // support arrays
 460   static const Type*        _zero_type[T_CONFLICT+1];
 461   static const Type* _const_basic_type[T_CONFLICT+1];
 462 };
 463 
 464 //------------------------------TypeF------------------------------------------
 465 // Class of Float-Constant Types.
 466 class TypeF : public Type {
 467   TypeF( float f ) : Type(FloatCon), _f(f) {};
 468 public:
 469   virtual bool eq( const Type *t ) const;
 470   virtual int  hash() const;             // Type specific hashing
 471   virtual bool singleton(void) const;    // TRUE if type is a singleton
 472   virtual bool empty(void) const;        // TRUE if type is vacuous
 473 public:
 474   const float _f;               // Float constant
 475 
 476   static const TypeF *make(float f);
 477 
 478   virtual bool        is_finite() const;  // Has a finite value
 479   virtual bool        is_nan()    const;  // Is not a number (NaN)
 480 
 481   virtual const Type *xmeet( const Type *t ) const;
 482   virtual const Type *xdual() const;    // Compute dual right now.
 483   // Convenience common pre-built types.
 484   static const TypeF *ZERO; // positive zero only
 485   static const TypeF *ONE;
 486   static const TypeF *POS_INF;
 487   static const TypeF *NEG_INF;
 488 #ifndef PRODUCT
 489   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 490 #endif
 491 };
 492 
 493 //------------------------------TypeD------------------------------------------
 494 // Class of Double-Constant Types.
 495 class TypeD : public Type {
 496   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 497 public:
 498   virtual bool eq( const Type *t ) const;
 499   virtual int  hash() const;             // Type specific hashing
 500   virtual bool singleton(void) const;    // TRUE if type is a singleton
 501   virtual bool empty(void) const;        // TRUE if type is vacuous
 502 public:
 503   const double _d;              // Double constant
 504 
 505   static const TypeD *make(double d);
 506 
 507   virtual bool        is_finite() const;  // Has a finite value
 508   virtual bool        is_nan()    const;  // Is not a number (NaN)
 509 
 510   virtual const Type *xmeet( const Type *t ) const;
 511   virtual const Type *xdual() const;    // Compute dual right now.
 512   // Convenience common pre-built types.
 513   static const TypeD *ZERO; // positive zero only
 514   static const TypeD *ONE;
 515   static const TypeD *POS_INF;
 516   static const TypeD *NEG_INF;
 517 #ifndef PRODUCT
 518   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 519 #endif
 520 };
 521 
 522 //------------------------------TypeInt----------------------------------------
 523 // Class of integer ranges, the set of integers between a lower bound and an
 524 // upper bound, inclusive.
 525 class TypeInt : public Type {
 526   TypeInt( jint lo, jint hi, int w );
 527 protected:
 528   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 529 
 530 public:
 531   typedef jint NativeType;
 532   virtual bool eq( const Type *t ) const;
 533   virtual int  hash() const;             // Type specific hashing
 534   virtual bool singleton(void) const;    // TRUE if type is a singleton
 535   virtual bool empty(void) const;        // TRUE if type is vacuous
 536   const jint _lo, _hi;          // Lower bound, upper bound
 537   const short _widen;           // Limit on times we widen this sucker
 538 
 539   static const TypeInt *make(jint lo);
 540   // must always specify w
 541   static const TypeInt *make(jint lo, jint hi, int w);
 542 
 543   // Check for single integer
 544   int is_con() const { return _lo==_hi; }
 545   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 546   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 547 
 548   virtual bool        is_finite() const;  // Has a finite value
 549 
 550   virtual const Type *xmeet( const Type *t ) const;
 551   virtual const Type *xdual() const;    // Compute dual right now.
 552   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 553   virtual const Type *narrow( const Type *t ) const;
 554   // Do not kill _widen bits.
 555   // Convenience common pre-built types.
 556   static const TypeInt *MINUS_1;
 557   static const TypeInt *ZERO;
 558   static const TypeInt *ONE;
 559   static const TypeInt *BOOL;
 560   static const TypeInt *CC;
 561   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 562   static const TypeInt *CC_GT;  // [1]   == ONE
 563   static const TypeInt *CC_EQ;  // [0]   == ZERO
 564   static const TypeInt *CC_LE;  // [-1,0]
 565   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 566   static const TypeInt *BYTE;
 567   static const TypeInt *UBYTE;
 568   static const TypeInt *CHAR;
 569   static const TypeInt *SHORT;
 570   static const TypeInt *POS;
 571   static const TypeInt *POS1;
 572   static const TypeInt *INT;
 573   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 574   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 575 
 576   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 577 #ifndef PRODUCT
 578   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 579 #endif
 580 };
 581 
 582 
 583 //------------------------------TypeLong---------------------------------------
 584 // Class of long integer ranges, the set of integers between a lower bound and
 585 // an upper bound, inclusive.
 586 class TypeLong : public Type {
 587   TypeLong( jlong lo, jlong hi, int w );
 588 protected:
 589   // Do not kill _widen bits.
 590   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 591 public:
 592   typedef jlong NativeType;
 593   virtual bool eq( const Type *t ) const;
 594   virtual int  hash() const;             // Type specific hashing
 595   virtual bool singleton(void) const;    // TRUE if type is a singleton
 596   virtual bool empty(void) const;        // TRUE if type is vacuous
 597 public:
 598   const jlong _lo, _hi;         // Lower bound, upper bound
 599   const short _widen;           // Limit on times we widen this sucker
 600 
 601   static const TypeLong *make(jlong lo);
 602   // must always specify w
 603   static const TypeLong *make(jlong lo, jlong hi, int w);
 604 
 605   // Check for single integer
 606   int is_con() const { return _lo==_hi; }
 607   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 608   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 609 
 610   // Check for positive 32-bit value.
 611   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 612 
 613   virtual bool        is_finite() const;  // Has a finite value
 614 
 615 
 616   virtual const Type *xmeet( const Type *t ) const;
 617   virtual const Type *xdual() const;    // Compute dual right now.
 618   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 619   virtual const Type *narrow( const Type *t ) const;
 620   // Convenience common pre-built types.
 621   static const TypeLong *MINUS_1;
 622   static const TypeLong *ZERO;
 623   static const TypeLong *ONE;
 624   static const TypeLong *POS;
 625   static const TypeLong *LONG;
 626   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 627   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 628   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 629 
 630   // static convenience methods.
 631   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 632 
 633 #ifndef PRODUCT
 634   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 635 #endif
 636 };
 637 
 638 //------------------------------TypeTuple--------------------------------------
 639 // Class of Tuple Types, essentially type collections for function signatures
 640 // and class layouts.  It happens to also be a fast cache for the HotSpot
 641 // signature types.
 642 class TypeTuple : public Type {
 643   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 644 
 645   const uint          _cnt;              // Count of fields
 646   const Type ** const _fields;           // Array of field types
 647 
 648 public:
 649   virtual bool eq( const Type *t ) const;
 650   virtual int  hash() const;             // Type specific hashing
 651   virtual bool singleton(void) const;    // TRUE if type is a singleton
 652   virtual bool empty(void) const;        // TRUE if type is vacuous
 653 
 654   // Accessors:
 655   uint cnt() const { return _cnt; }
 656   const Type* field_at(uint i) const {
 657     assert(i &lt; _cnt, &quot;oob&quot;);
 658     return _fields[i];
 659   }
 660   void set_field_at(uint i, const Type* t) {
 661     assert(i &lt; _cnt, &quot;oob&quot;);
 662     _fields[i] = t;
 663   }
 664 
 665   static const TypeTuple *make( uint cnt, const Type **fields );
 666   static const TypeTuple *make_range(ciSignature *sig);
 667   static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);
<a name="2" id="anc2"></a><span class="line-added"> 668   static const TypeTuple *make_func(uint arg_cnt, const Type **arg_fields);</span>
 669 
 670   // Subroutine call type with space allocated for argument types
 671   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 672   static const Type **fields( uint arg_cnt );
 673 
 674   virtual const Type *xmeet( const Type *t ) const;
 675   virtual const Type *xdual() const;    // Compute dual right now.
 676   // Convenience common pre-built types.
 677   static const TypeTuple *IFBOTH;
 678   static const TypeTuple *IFFALSE;
 679   static const TypeTuple *IFTRUE;
 680   static const TypeTuple *IFNEITHER;
 681   static const TypeTuple *LOOPBODY;
 682   static const TypeTuple *MEMBAR;
 683   static const TypeTuple *STORECONDITIONAL;
 684   static const TypeTuple *START_I2C;
 685   static const TypeTuple *INT_PAIR;
 686   static const TypeTuple *LONG_PAIR;
 687   static const TypeTuple *INT_CC_PAIR;
 688   static const TypeTuple *LONG_CC_PAIR;
 689 #ifndef PRODUCT
 690   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 691 #endif
 692 };
 693 
 694 //------------------------------TypeAry----------------------------------------
 695 // Class of Array Types
 696 class TypeAry : public Type {
 697   TypeAry(const Type* elem, const TypeInt* size, bool stable) : Type(Array),
 698       _elem(elem), _size(size), _stable(stable) {}
 699 public:
 700   virtual bool eq( const Type *t ) const;
 701   virtual int  hash() const;             // Type specific hashing
 702   virtual bool singleton(void) const;    // TRUE if type is a singleton
 703   virtual bool empty(void) const;        // TRUE if type is vacuous
 704 
 705 private:
 706   const Type *_elem;            // Element type of array
 707   const TypeInt *_size;         // Elements in array
 708   const bool _stable;           // Are elements @Stable?
 709   friend class TypeAryPtr;
 710 
 711 public:
 712   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false);
 713 
 714   virtual const Type *xmeet( const Type *t ) const;
 715   virtual const Type *xdual() const;    // Compute dual right now.
 716   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 717   virtual const Type* remove_speculative() const;
 718   virtual const Type* cleanup_speculative() const;
 719 #ifdef ASSERT
 720   // One type is interface, the other is oop
 721   virtual bool interface_vs_oop(const Type *t) const;
 722 #endif
 723 #ifndef PRODUCT
 724   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 725 #endif
 726 };
 727 
 728 //------------------------------TypeVect---------------------------------------
 729 // Class of Vector Types
 730 class TypeVect : public Type {
 731   const Type*   _elem;  // Vector&#39;s element type
 732   const uint  _length;  // Elements in vector (power of 2)
 733 
 734 protected:
 735   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 736     _elem(elem), _length(length) {}
 737 
 738 public:
 739   const Type* element_type() const { return _elem; }
 740   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 741   uint length() const { return _length; }
 742   uint length_in_bytes() const {
 743    return _length * type2aelembytes(element_basic_type());
 744   }
 745 
 746   virtual bool eq(const Type *t) const;
 747   virtual int  hash() const;             // Type specific hashing
 748   virtual bool singleton(void) const;    // TRUE if type is a singleton
 749   virtual bool empty(void) const;        // TRUE if type is vacuous
 750 
 751   static const TypeVect *make(const BasicType elem_bt, uint length) {
 752     // Use bottom primitive type.
 753     return make(get_const_basic_type(elem_bt), length);
 754   }
 755   // Used directly by Replicate nodes to construct singleton vector.
 756   static const TypeVect *make(const Type* elem, uint length);
 757 
 758   virtual const Type *xmeet( const Type *t) const;
 759   virtual const Type *xdual() const;     // Compute dual right now.
 760 
 761   static const TypeVect *VECTS;
 762   static const TypeVect *VECTD;
 763   static const TypeVect *VECTX;
 764   static const TypeVect *VECTY;
 765   static const TypeVect *VECTZ;
 766 
 767 #ifndef PRODUCT
 768   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 769 #endif
 770 };
 771 
 772 class TypeVectS : public TypeVect {
 773   friend class TypeVect;
 774   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 775 };
 776 
 777 class TypeVectD : public TypeVect {
 778   friend class TypeVect;
 779   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 780 };
 781 
 782 class TypeVectX : public TypeVect {
 783   friend class TypeVect;
 784   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 785 };
 786 
 787 class TypeVectY : public TypeVect {
 788   friend class TypeVect;
 789   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 790 };
 791 
 792 class TypeVectZ : public TypeVect {
 793   friend class TypeVect;
 794   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 795 };
 796 
 797 //------------------------------TypePtr----------------------------------------
 798 // Class of machine Pointer Types: raw data, instances or arrays.
 799 // If the _base enum is AnyPtr, then this refers to all of the above.
 800 // Otherwise the _base will indicate which subset of pointers is affected,
 801 // and the class will be inherited from.
 802 class TypePtr : public Type {
 803   friend class TypeNarrowPtr;
 804 public:
 805   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 806 protected:
 807   TypePtr(TYPES t, PTR ptr, int offset,
 808           const TypePtr* speculative = NULL,
 809           int inline_depth = InlineDepthBottom) :
 810     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 811     _ptr(ptr) {}
 812   static const PTR ptr_meet[lastPTR][lastPTR];
 813   static const PTR ptr_dual[lastPTR];
 814   static const char * const ptr_msg[lastPTR];
 815 
 816   enum {
 817     InlineDepthBottom = INT_MAX,
 818     InlineDepthTop = -InlineDepthBottom
 819   };
 820 
 821   // Extra type information profiling gave us. We propagate it the
 822   // same way the rest of the type info is propagated. If we want to
 823   // use it, then we have to emit a guard: this part of the type is
 824   // not something we know but something we speculate about the type.
 825   const TypePtr*   _speculative;
 826   // For speculative types, we record at what inlining depth the
 827   // profiling point that provided the data is. We want to favor
 828   // profile data coming from outer scopes which are likely better for
 829   // the current compilation.
 830   int _inline_depth;
 831 
 832   // utility methods to work on the speculative part of the type
 833   const TypePtr* dual_speculative() const;
 834   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 835   bool eq_speculative(const TypePtr* other) const;
 836   int hash_speculative() const;
 837   const TypePtr* add_offset_speculative(intptr_t offset) const;
 838 #ifndef PRODUCT
 839   void dump_speculative(outputStream *st) const;
 840 #endif
 841 
 842   // utility methods to work on the inline depth of the type
 843   int dual_inline_depth() const;
 844   int meet_inline_depth(int depth) const;
 845 #ifndef PRODUCT
 846   void dump_inline_depth(outputStream *st) const;
 847 #endif
 848 
 849 public:
 850   const int _offset;            // Offset into oop, with TOP &amp; BOT
 851   const PTR _ptr;               // Pointer equivalence class
 852 
 853   const int offset() const { return _offset; }
 854   const PTR ptr()    const { return _ptr; }
 855 
 856   static const TypePtr *make(TYPES t, PTR ptr, int offset,
 857                              const TypePtr* speculative = NULL,
 858                              int inline_depth = InlineDepthBottom);
 859 
 860   // Return a &#39;ptr&#39; version of this type
 861   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 862 
 863   virtual intptr_t get_con() const;
 864 
 865   int xadd_offset( intptr_t offset ) const;
 866   virtual const TypePtr *add_offset( intptr_t offset ) const;
 867   virtual bool eq(const Type *t) const;
 868   virtual int  hash() const;             // Type specific hashing
 869 
 870   virtual bool singleton(void) const;    // TRUE if type is a singleton
 871   virtual bool empty(void) const;        // TRUE if type is vacuous
 872   virtual const Type *xmeet( const Type *t ) const;
 873   virtual const Type *xmeet_helper( const Type *t ) const;
 874   int meet_offset( int offset ) const;
 875   int dual_offset( ) const;
 876   virtual const Type *xdual() const;    // Compute dual right now.
 877 
 878   // meet, dual and join over pointer equivalence sets
 879   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 880   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 881 
 882   // This is textually confusing unless one recalls that
 883   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 884   PTR join_ptr( const PTR in_ptr ) const {
 885     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 886   }
 887 
 888   // Speculative type helper methods.
 889   virtual const TypePtr* speculative() const { return _speculative; }
 890   int inline_depth() const                   { return _inline_depth; }
 891   virtual ciKlass* speculative_type() const;
 892   virtual ciKlass* speculative_type_not_null() const;
 893   virtual bool speculative_maybe_null() const;
 894   virtual bool speculative_always_null() const;
 895   virtual const Type* remove_speculative() const;
 896   virtual const Type* cleanup_speculative() const;
 897   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 898   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 899   virtual const TypePtr* with_inline_depth(int depth) const;
 900 
 901   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 902 
 903   // Tests for relation to centerline of type lattice:
 904   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 905   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 906   // Convenience common pre-built types.
 907   static const TypePtr *NULL_PTR;
 908   static const TypePtr *NOTNULL;
 909   static const TypePtr *BOTTOM;
 910 #ifndef PRODUCT
 911   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 912 #endif
 913 };
 914 
 915 //------------------------------TypeRawPtr-------------------------------------
 916 // Class of raw pointers, pointers to things other than Oops.  Examples
 917 // include the stack pointer, top of heap, card-marking area, handles, etc.
 918 class TypeRawPtr : public TypePtr {
 919 protected:
 920   TypeRawPtr( PTR ptr, address bits ) : TypePtr(RawPtr,ptr,0), _bits(bits){}
 921 public:
 922   virtual bool eq( const Type *t ) const;
 923   virtual int  hash() const;     // Type specific hashing
 924 
 925   const address _bits;          // Constant value, if applicable
 926 
 927   static const TypeRawPtr *make( PTR ptr );
 928   static const TypeRawPtr *make( address bits );
 929 
 930   // Return a &#39;ptr&#39; version of this type
 931   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 932 
 933   virtual intptr_t get_con() const;
 934 
 935   virtual const TypePtr *add_offset( intptr_t offset ) const;
 936 
 937   virtual const Type *xmeet( const Type *t ) const;
 938   virtual const Type *xdual() const;    // Compute dual right now.
 939   // Convenience common pre-built types.
 940   static const TypeRawPtr *BOTTOM;
 941   static const TypeRawPtr *NOTNULL;
 942 #ifndef PRODUCT
 943   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 944 #endif
 945 };
 946 
 947 //------------------------------TypeOopPtr-------------------------------------
 948 // Some kind of oop (Java pointer), either instance or array.
 949 class TypeOopPtr : public TypePtr {
 950 protected:
 951   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
 952              const TypePtr* speculative, int inline_depth);
 953 public:
 954   virtual bool eq( const Type *t ) const;
 955   virtual int  hash() const;             // Type specific hashing
 956   virtual bool singleton(void) const;    // TRUE if type is a singleton
 957   enum {
 958    InstanceTop = -1,   // undefined instance
 959    InstanceBot = 0     // any possible instance
 960   };
 961 protected:
 962 
 963   // Oop is NULL, unless this is a constant oop.
 964   ciObject*     _const_oop;   // Constant oop
 965   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
 966   ciKlass*      _klass;       // Klass object
 967   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
 968   bool          _klass_is_exact;
 969   bool          _is_ptr_to_narrowoop;
 970   bool          _is_ptr_to_narrowklass;
 971   bool          _is_ptr_to_boxed_value;
 972 
 973   // If not InstanceTop or InstanceBot, indicates that this is
 974   // a particular instance of this type which is distinct.
 975   // This is the node index of the allocation node creating this instance.
 976   int           _instance_id;
 977 
 978   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
 979 
 980   int dual_instance_id() const;
 981   int meet_instance_id(int uid) const;
 982 
 983   // Do not allow interface-vs.-noninterface joins to collapse to top.
 984   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 985 
 986 public:
 987   // Creates a type given a klass. Correctly handles multi-dimensional arrays
 988   // Respects UseUniqueSubclasses.
 989   // If the klass is final, the resulting type will be exact.
 990   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
 991     return make_from_klass_common(klass, true, false);
 992   }
 993   // Same as before, but will produce an exact type, even if
 994   // the klass is not final, as long as it has exactly one implementation.
 995   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
 996     return make_from_klass_common(klass, true, true);
 997   }
 998   // Same as before, but does not respects UseUniqueSubclasses.
 999   // Use this only for creating array element types.
1000   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1001     return make_from_klass_common(klass, false, false);
1002   }
1003   // Creates a singleton type given an object.
1004   // If the object cannot be rendered as a constant,
1005   // may return a non-singleton type.
1006   // If require_constant, produce a NULL if a singleton is not possible.
1007   static const TypeOopPtr* make_from_constant(ciObject* o,
1008                                               bool require_constant = false);
1009 
1010   // Make a generic (unclassed) pointer to an oop.
1011   static const TypeOopPtr* make(PTR ptr, int offset, int instance_id,
1012                                 const TypePtr* speculative = NULL,
1013                                 int inline_depth = InlineDepthBottom);
1014 
1015   ciObject* const_oop()    const { return _const_oop; }
1016   virtual ciKlass* klass() const { return _klass;     }
1017   bool klass_is_exact()    const { return _klass_is_exact; }
1018 
1019   // Returns true if this pointer points at memory which contains a
1020   // compressed oop references.
1021   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1022   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1023   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1024   bool is_known_instance()       const { return _instance_id &gt; 0; }
1025   int  instance_id()             const { return _instance_id; }
1026   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset &gt;= 0; }
1027 
1028   virtual intptr_t get_con() const;
1029 
1030   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1031 
1032   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1033 
1034   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1035 
1036   // corresponding pointer to klass, for a given instance
1037   const TypeKlassPtr* as_klass_type() const;
1038 
1039   virtual const TypePtr *add_offset( intptr_t offset ) const;
1040 
1041   // Speculative type helper methods.
1042   virtual const Type* remove_speculative() const;
1043   virtual const Type* cleanup_speculative() const;
1044   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1045   virtual const TypePtr* with_inline_depth(int depth) const;
1046 
1047   virtual const TypePtr* with_instance_id(int instance_id) const;
1048 
1049   virtual const Type *xdual() const;    // Compute dual right now.
1050   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1051   virtual const Type *xmeet_helper(const Type *t) const;
1052 
1053   // Convenience common pre-built type.
1054   static const TypeOopPtr *BOTTOM;
1055 #ifndef PRODUCT
1056   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1057 #endif
1058 };
1059 
1060 //------------------------------TypeInstPtr------------------------------------
1061 // Class of Java object pointers, pointing either to non-array Java instances
1062 // or to a Klass* (including array klasses).
1063 class TypeInstPtr : public TypeOopPtr {
1064   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,
1065               const TypePtr* speculative, int inline_depth);
1066   virtual bool eq( const Type *t ) const;
1067   virtual int  hash() const;             // Type specific hashing
1068 
1069   ciSymbol*  _name;        // class name
1070 
1071  public:
1072   ciSymbol* name()         const { return _name; }
1073 
1074   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1075 
1076   // Make a pointer to a constant oop.
1077   static const TypeInstPtr *make(ciObject* o) {
1078     return make(TypePtr::Constant, o-&gt;klass(), true, o, 0, InstanceBot);
1079   }
1080   // Make a pointer to a constant oop with offset.
1081   static const TypeInstPtr *make(ciObject* o, int offset) {
1082     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, InstanceBot);
1083   }
1084 
1085   // Make a pointer to some value of type klass.
1086   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1087     return make(ptr, klass, false, NULL, 0, InstanceBot);
1088   }
1089 
1090   // Make a pointer to some non-polymorphic value of exactly type klass.
1091   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1092     return make(ptr, klass, true, NULL, 0, InstanceBot);
1093   }
1094 
1095   // Make a pointer to some value of type klass with offset.
1096   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, int offset) {
1097     return make(ptr, klass, false, NULL, offset, InstanceBot);
1098   }
1099 
1100   // Make a pointer to an oop.
1101   static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
1102                                  int instance_id = InstanceBot,
1103                                  const TypePtr* speculative = NULL,
1104                                  int inline_depth = InlineDepthBottom);
1105 
1106   /** Create constant type for a constant boxed value */
1107   const Type* get_const_boxed_value() const;
1108 
1109   // If this is a java.lang.Class constant, return the type for it or NULL.
1110   // Pass to Type::get_const_type to turn it to a type, which will usually
1111   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1112   ciType* java_mirror_type() const;
1113 
1114   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1115 
1116   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1117 
1118   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1119 
1120   virtual const TypePtr *add_offset( intptr_t offset ) const;
1121 
1122   // Speculative type helper methods.
1123   virtual const Type* remove_speculative() const;
1124   virtual const TypePtr* with_inline_depth(int depth) const;
1125   virtual const TypePtr* with_instance_id(int instance_id) const;
1126 
1127   // the core of the computation of the meet of 2 types
1128   virtual const Type *xmeet_helper(const Type *t) const;
1129   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1130   virtual const Type *xdual() const;    // Compute dual right now.
1131 
1132   // Convenience common pre-built types.
1133   static const TypeInstPtr *NOTNULL;
1134   static const TypeInstPtr *BOTTOM;
1135   static const TypeInstPtr *MIRROR;
1136   static const TypeInstPtr *MARK;
1137   static const TypeInstPtr *KLASS;
1138 #ifndef PRODUCT
1139   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1140 #endif
1141 };
1142 
1143 //------------------------------TypeAryPtr-------------------------------------
1144 // Class of Java array pointers
1145 class TypeAryPtr : public TypeOopPtr {
1146   TypeAryPtr( PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1147               int offset, int instance_id, bool is_autobox_cache,
1148               const TypePtr* speculative, int inline_depth)
1149     : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),
1150     _ary(ary),
1151     _is_autobox_cache(is_autobox_cache)
1152  {
1153 #ifdef ASSERT
1154     if (k != NULL) {
1155       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1156       ciKlass* ck = compute_klass(true);
1157       if (k != ck) {
1158         this-&gt;dump(); tty-&gt;cr();
1159         tty-&gt;print(&quot; k: &quot;);
1160         k-&gt;print(); tty-&gt;cr();
1161         tty-&gt;print(&quot;ck: &quot;);
1162         if (ck != NULL) ck-&gt;print();
1163         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1164         tty-&gt;cr();
1165         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1166       }
1167     }
1168 #endif
1169   }
1170   virtual bool eq( const Type *t ) const;
1171   virtual int hash() const;     // Type specific hashing
1172   const TypeAry *_ary;          // Array we point into
1173   const bool     _is_autobox_cache;
1174 
1175   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1176 
1177 public:
1178   // Accessors
1179   ciKlass* klass() const;
1180   const TypeAry* ary() const  { return _ary; }
1181   const Type*    elem() const { return _ary-&gt;_elem; }
1182   const TypeInt* size() const { return _ary-&gt;_size; }
1183   bool      is_stable() const { return _ary-&gt;_stable; }
1184 
1185   bool is_autobox_cache() const { return _is_autobox_cache; }
1186 
1187   static const TypeAryPtr *make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1188                                 int instance_id = InstanceBot,
1189                                 const TypePtr* speculative = NULL,
1190                                 int inline_depth = InlineDepthBottom);
1191   // Constant pointer to array
1192   static const TypeAryPtr *make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
1193                                 int instance_id = InstanceBot,
1194                                 const TypePtr* speculative = NULL,
1195                                 int inline_depth = InlineDepthBottom, bool is_autobox_cache = false);
1196 
1197   // Return a &#39;ptr&#39; version of this type
1198   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1199 
1200   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1201 
1202   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1203 
1204   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1205   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1206 
1207   virtual bool empty(void) const;        // TRUE if type is vacuous
1208   virtual const TypePtr *add_offset( intptr_t offset ) const;
1209 
1210   // Speculative type helper methods.
1211   virtual const Type* remove_speculative() const;
1212   virtual const TypePtr* with_inline_depth(int depth) const;
1213   virtual const TypePtr* with_instance_id(int instance_id) const;
1214 
1215   // the core of the computation of the meet of 2 types
1216   virtual const Type *xmeet_helper(const Type *t) const;
1217   virtual const Type *xdual() const;    // Compute dual right now.
1218 
1219   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1220   int stable_dimension() const;
1221 
1222   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1223 
1224   static jint max_array_length(BasicType etype) ;
1225 
1226   // Convenience common pre-built types.
1227   static const TypeAryPtr *RANGE;
1228   static const TypeAryPtr *OOPS;
1229   static const TypeAryPtr *NARROWOOPS;
1230   static const TypeAryPtr *BYTES;
1231   static const TypeAryPtr *SHORTS;
1232   static const TypeAryPtr *CHARS;
1233   static const TypeAryPtr *INTS;
1234   static const TypeAryPtr *LONGS;
1235   static const TypeAryPtr *FLOATS;
1236   static const TypeAryPtr *DOUBLES;
1237   // selects one of the above:
1238   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1239     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1240     return _array_body_type[elem];
1241   }
1242   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1243   // sharpen the type of an int which is used as an array size
1244 #ifdef ASSERT
1245   // One type is interface, the other is oop
1246   virtual bool interface_vs_oop(const Type *t) const;
1247 #endif
1248 #ifndef PRODUCT
1249   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1250 #endif
1251 };
1252 
1253 //------------------------------TypeMetadataPtr-------------------------------------
1254 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1255 class TypeMetadataPtr : public TypePtr {
1256 protected:
1257   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset);
1258   // Do not allow interface-vs.-noninterface joins to collapse to top.
1259   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1260 public:
1261   virtual bool eq( const Type *t ) const;
1262   virtual int  hash() const;             // Type specific hashing
1263   virtual bool singleton(void) const;    // TRUE if type is a singleton
1264 
1265 private:
1266   ciMetadata*   _metadata;
1267 
1268 public:
1269   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, int offset);
1270 
1271   static const TypeMetadataPtr* make(ciMethod* m);
1272   static const TypeMetadataPtr* make(ciMethodData* m);
1273 
1274   ciMetadata* metadata() const { return _metadata; }
1275 
1276   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1277 
1278   virtual const TypePtr *add_offset( intptr_t offset ) const;
1279 
1280   virtual const Type *xmeet( const Type *t ) const;
1281   virtual const Type *xdual() const;    // Compute dual right now.
1282 
1283   virtual intptr_t get_con() const;
1284 
1285   // Convenience common pre-built types.
1286   static const TypeMetadataPtr *BOTTOM;
1287 
1288 #ifndef PRODUCT
1289   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1290 #endif
1291 };
1292 
1293 //------------------------------TypeKlassPtr-----------------------------------
1294 // Class of Java Klass pointers
1295 class TypeKlassPtr : public TypePtr {
1296   TypeKlassPtr( PTR ptr, ciKlass* klass, int offset );
1297 
1298 protected:
1299   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1300  public:
1301   virtual bool eq( const Type *t ) const;
1302   virtual int hash() const;             // Type specific hashing
1303   virtual bool singleton(void) const;    // TRUE if type is a singleton
1304  private:
1305 
1306   static const TypeKlassPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1307 
1308   ciKlass* _klass;
1309 
1310   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1311   bool          _klass_is_exact;
1312 
1313 public:
1314   ciSymbol* name()  const { return klass()-&gt;name(); }
1315 
1316   ciKlass* klass() const { return  _klass; }
1317   bool klass_is_exact()    const { return _klass_is_exact; }
1318 
1319   bool  is_loaded() const { return klass()-&gt;is_loaded(); }
1320 
1321   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1322   // Respects UseUniqueSubclasses.
1323   // If the klass is final, the resulting type will be exact.
1324   static const TypeKlassPtr* make_from_klass(ciKlass* klass) {
1325     return make_from_klass_common(klass, true, false);
1326   }
1327   // Same as before, but will produce an exact type, even if
1328   // the klass is not final, as long as it has exactly one implementation.
1329   static const TypeKlassPtr* make_from_klass_unique(ciKlass* klass) {
1330     return make_from_klass_common(klass, true, true);
1331   }
1332   // Same as before, but does not respects UseUniqueSubclasses.
1333   // Use this only for creating array element types.
1334   static const TypeKlassPtr* make_from_klass_raw(ciKlass* klass) {
1335     return make_from_klass_common(klass, false, false);
1336   }
1337 
1338   // Make a generic (unclassed) pointer to metadata.
1339   static const TypeKlassPtr* make(PTR ptr, int offset);
1340 
1341   // ptr to klass &#39;k&#39;
1342   static const TypeKlassPtr *make( ciKlass* k ) { return make( TypePtr::Constant, k, 0); }
1343   // ptr to klass &#39;k&#39; with offset
1344   static const TypeKlassPtr *make( ciKlass* k, int offset ) { return make( TypePtr::Constant, k, offset); }
1345   // ptr to klass &#39;k&#39; or sub-klass
1346   static const TypeKlassPtr *make( PTR ptr, ciKlass* k, int offset);
1347 
1348   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1349 
1350   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1351 
1352   // corresponding pointer to instance, for a given class
1353   const TypeOopPtr* as_instance_type() const;
1354 
1355   virtual const TypePtr *add_offset( intptr_t offset ) const;
1356   virtual const Type    *xmeet( const Type *t ) const;
1357   virtual const Type    *xdual() const;      // Compute dual right now.
1358 
1359   virtual intptr_t get_con() const;
1360 
1361   // Convenience common pre-built types.
1362   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1363   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1364 #ifndef PRODUCT
1365   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1366 #endif
1367 };
1368 
1369 class TypeNarrowPtr : public Type {
1370 protected:
1371   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1372 
1373   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1374                                                   _ptrtype(ptrtype) {
1375     assert(ptrtype-&gt;offset() == 0 ||
1376            ptrtype-&gt;offset() == OffsetBot ||
1377            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1378   }
1379 
1380   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1381   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1382   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1383   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1384   // Do not allow interface-vs.-noninterface joins to collapse to top.
1385   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1386 public:
1387   virtual bool eq( const Type *t ) const;
1388   virtual int  hash() const;             // Type specific hashing
1389   virtual bool singleton(void) const;    // TRUE if type is a singleton
1390 
1391   virtual const Type *xmeet( const Type *t ) const;
1392   virtual const Type *xdual() const;    // Compute dual right now.
1393 
1394   virtual intptr_t get_con() const;
1395 
1396   virtual bool empty(void) const;        // TRUE if type is vacuous
1397 
1398   // returns the equivalent ptr type for this compressed pointer
1399   const TypePtr *get_ptrtype() const {
1400     return _ptrtype;
1401   }
1402 
1403   bool is_known_instance() const {
1404     return _ptrtype-&gt;is_known_instance();
1405   }
1406 
1407 #ifndef PRODUCT
1408   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1409 #endif
1410 };
1411 
1412 //------------------------------TypeNarrowOop----------------------------------
1413 // A compressed reference to some kind of Oop.  This type wraps around
1414 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1415 // the underlying type.  It&#39;s only real purpose is to track the
1416 // oopness of the compressed oop value when we expose the conversion
1417 // between the normal and the compressed form.
1418 class TypeNarrowOop : public TypeNarrowPtr {
1419 protected:
1420   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1421   }
1422 
1423   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1424     return t-&gt;isa_narrowoop();
1425   }
1426 
1427   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1428     return t-&gt;is_narrowoop();
1429   }
1430 
1431   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1432     return new TypeNarrowOop(t);
1433   }
1434 
1435   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1436     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1437   }
1438 
1439 public:
1440 
1441   static const TypeNarrowOop *make( const TypePtr* type);
1442 
1443   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1444     return make(TypeOopPtr::make_from_constant(con, require_constant));
1445   }
1446 
1447   static const TypeNarrowOop *BOTTOM;
1448   static const TypeNarrowOop *NULL_PTR;
1449 
1450   virtual const Type* remove_speculative() const;
1451   virtual const Type* cleanup_speculative() const;
1452 
1453 #ifndef PRODUCT
1454   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1455 #endif
1456 };
1457 
1458 //------------------------------TypeNarrowKlass----------------------------------
1459 // A compressed reference to klass pointer.  This type wraps around a
1460 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1461 // the underlying type.
1462 class TypeNarrowKlass : public TypeNarrowPtr {
1463 protected:
1464   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1465   }
1466 
1467   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1468     return t-&gt;isa_narrowklass();
1469   }
1470 
1471   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1472     return t-&gt;is_narrowklass();
1473   }
1474 
1475   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1476     return new TypeNarrowKlass(t);
1477   }
1478 
1479   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1480     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1481   }
1482 
1483 public:
1484   static const TypeNarrowKlass *make( const TypePtr* type);
1485 
1486   // static const TypeNarrowKlass *BOTTOM;
1487   static const TypeNarrowKlass *NULL_PTR;
1488 
1489 #ifndef PRODUCT
1490   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1491 #endif
1492 };
1493 
1494 //------------------------------TypeFunc---------------------------------------
1495 // Class of Array Types
1496 class TypeFunc : public Type {
1497   TypeFunc( const TypeTuple *domain, const TypeTuple *range ) : Type(Function),  _domain(domain), _range(range) {}
1498   virtual bool eq( const Type *t ) const;
1499   virtual int  hash() const;             // Type specific hashing
1500   virtual bool singleton(void) const;    // TRUE if type is a singleton
1501   virtual bool empty(void) const;        // TRUE if type is vacuous
1502 
1503   const TypeTuple* const _domain;     // Domain of inputs
1504   const TypeTuple* const _range;      // Range of results
1505 
1506 public:
1507   // Constants are shared among ADLC and VM
1508   enum { Control    = AdlcVMDeps::Control,
1509          I_O        = AdlcVMDeps::I_O,
1510          Memory     = AdlcVMDeps::Memory,
1511          FramePtr   = AdlcVMDeps::FramePtr,
1512          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1513          Parms      = AdlcVMDeps::Parms
1514   };
1515 
1516 
1517   // Accessors:
1518   const TypeTuple* domain() const { return _domain; }
1519   const TypeTuple* range()  const { return _range; }
1520 
1521   static const TypeFunc *make(ciMethod* method);
1522   static const TypeFunc *make(ciSignature signature, const Type* extra);
1523   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1524 
1525   virtual const Type *xmeet( const Type *t ) const;
1526   virtual const Type *xdual() const;    // Compute dual right now.
1527 
1528   BasicType return_type() const;
1529 
1530 #ifndef PRODUCT
1531   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1532 #endif
1533   // Convenience common pre-built types.
1534 };
1535 
1536 //------------------------------accessors--------------------------------------
1537 inline bool Type::is_ptr_to_narrowoop() const {
1538 #ifdef _LP64
1539   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1540 #else
1541   return false;
1542 #endif
1543 }
1544 
1545 inline bool Type::is_ptr_to_narrowklass() const {
1546 #ifdef _LP64
1547   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1548 #else
1549   return false;
1550 #endif
1551 }
1552 
1553 inline float Type::getf() const {
1554   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1555   return ((TypeF*)this)-&gt;_f;
1556 }
1557 
1558 inline double Type::getd() const {
1559   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1560   return ((TypeD*)this)-&gt;_d;
1561 }
1562 
1563 inline const TypeInt *Type::is_int() const {
1564   assert( _base == Int, &quot;Not an Int&quot; );
1565   return (TypeInt*)this;
1566 }
1567 
1568 inline const TypeInt *Type::isa_int() const {
1569   return ( _base == Int ? (TypeInt*)this : NULL);
1570 }
1571 
1572 inline const TypeLong *Type::is_long() const {
1573   assert( _base == Long, &quot;Not a Long&quot; );
1574   return (TypeLong*)this;
1575 }
1576 
1577 inline const TypeLong *Type::isa_long() const {
1578   return ( _base == Long ? (TypeLong*)this : NULL);
1579 }
1580 
1581 inline const TypeF *Type::isa_float() const {
1582   return ((_base == FloatTop ||
1583            _base == FloatCon ||
1584            _base == FloatBot) ? (TypeF*)this : NULL);
1585 }
1586 
1587 inline const TypeF *Type::is_float_constant() const {
1588   assert( _base == FloatCon, &quot;Not a Float&quot; );
1589   return (TypeF*)this;
1590 }
1591 
1592 inline const TypeF *Type::isa_float_constant() const {
1593   return ( _base == FloatCon ? (TypeF*)this : NULL);
1594 }
1595 
1596 inline const TypeD *Type::isa_double() const {
1597   return ((_base == DoubleTop ||
1598            _base == DoubleCon ||
1599            _base == DoubleBot) ? (TypeD*)this : NULL);
1600 }
1601 
1602 inline const TypeD *Type::is_double_constant() const {
1603   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1604   return (TypeD*)this;
1605 }
1606 
1607 inline const TypeD *Type::isa_double_constant() const {
1608   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1609 }
1610 
1611 inline const TypeTuple *Type::is_tuple() const {
1612   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1613   return (TypeTuple*)this;
1614 }
1615 
1616 inline const TypeAry *Type::is_ary() const {
1617   assert( _base == Array , &quot;Not an Array&quot; );
1618   return (TypeAry*)this;
1619 }
1620 
1621 inline const TypeAry *Type::isa_ary() const {
1622   return ((_base == Array) ? (TypeAry*)this : NULL);
1623 }
1624 
1625 inline const TypeVect *Type::is_vect() const {
1626   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1627   return (TypeVect*)this;
1628 }
1629 
1630 inline const TypeVect *Type::isa_vect() const {
1631   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1632 }
1633 
1634 inline const TypePtr *Type::is_ptr() const {
1635   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1636   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1637   return (TypePtr*)this;
1638 }
1639 
1640 inline const TypePtr *Type::isa_ptr() const {
1641   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1642   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1643 }
1644 
1645 inline const TypeOopPtr *Type::is_oopptr() const {
1646   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1647   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1648   return (TypeOopPtr*)this;
1649 }
1650 
1651 inline const TypeOopPtr *Type::isa_oopptr() const {
1652   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1653   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1654 }
1655 
1656 inline const TypeRawPtr *Type::isa_rawptr() const {
1657   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1658 }
1659 
1660 inline const TypeRawPtr *Type::is_rawptr() const {
1661   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1662   return (TypeRawPtr*)this;
1663 }
1664 
1665 inline const TypeInstPtr *Type::isa_instptr() const {
1666   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1667 }
1668 
1669 inline const TypeInstPtr *Type::is_instptr() const {
1670   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1671   return (TypeInstPtr*)this;
1672 }
1673 
1674 inline const TypeAryPtr *Type::isa_aryptr() const {
1675   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1676 }
1677 
1678 inline const TypeAryPtr *Type::is_aryptr() const {
1679   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1680   return (TypeAryPtr*)this;
1681 }
1682 
1683 inline const TypeNarrowOop *Type::is_narrowoop() const {
1684   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1685   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1686   return (TypeNarrowOop*)this;
1687 }
1688 
1689 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1690   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1691   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1692 }
1693 
1694 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1695   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1696   return (TypeNarrowKlass*)this;
1697 }
1698 
1699 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1700   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1701 }
1702 
1703 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1704   // MetadataPtr is the first and CPCachePtr the last
1705   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1706   return (TypeMetadataPtr*)this;
1707 }
1708 
1709 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1710   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1711 }
1712 
1713 inline const TypeKlassPtr *Type::isa_klassptr() const {
1714   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1715 }
1716 
1717 inline const TypeKlassPtr *Type::is_klassptr() const {
1718   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1719   return (TypeKlassPtr*)this;
1720 }
1721 
1722 inline const TypePtr* Type::make_ptr() const {
1723   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1724                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1725                                                        isa_ptr());
1726 }
1727 
1728 inline const TypeOopPtr* Type::make_oopptr() const {
1729   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1730 }
1731 
1732 inline const TypeNarrowOop* Type::make_narrowoop() const {
1733   return (_base == NarrowOop) ? is_narrowoop() :
1734                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1735 }
1736 
1737 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1738   return (_base == NarrowKlass) ? is_narrowklass() :
1739                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1740 }
1741 
1742 inline bool Type::is_floatingpoint() const {
1743   if( (_base == FloatCon)  || (_base == FloatBot) ||
1744       (_base == DoubleCon) || (_base == DoubleBot) )
1745     return true;
1746   return false;
1747 }
1748 
1749 inline bool Type::is_ptr_to_boxing_obj() const {
1750   const TypeInstPtr* tp = isa_instptr();
1751   return (tp != NULL) &amp;&amp; (tp-&gt;offset() == 0) &amp;&amp;
1752          tp-&gt;klass()-&gt;is_instance_klass()  &amp;&amp;
1753          tp-&gt;klass()-&gt;as_instance_klass()-&gt;is_box_klass();
1754 }
1755 
1756 
1757 // ===============================================================
1758 // Things that need to be 64-bits in the 64-bit build but
1759 // 32-bits in the 32-bit build.  Done this way to get full
1760 // optimization AND strong typing.
1761 #ifdef _LP64
1762 
1763 // For type queries and asserts
1764 #define is_intptr_t  is_long
1765 #define isa_intptr_t isa_long
1766 #define find_intptr_t_type find_long_type
1767 #define find_intptr_t_con  find_long_con
1768 #define TypeX        TypeLong
1769 #define Type_X       Type::Long
1770 #define TypeX_X      TypeLong::LONG
1771 #define TypeX_ZERO   TypeLong::ZERO
1772 // For &#39;ideal_reg&#39; machine registers
1773 #define Op_RegX      Op_RegL
1774 // For phase-&gt;intcon variants
1775 #define MakeConX     longcon
1776 #define ConXNode     ConLNode
1777 // For array index arithmetic
1778 #define MulXNode     MulLNode
1779 #define AndXNode     AndLNode
1780 #define OrXNode      OrLNode
1781 #define CmpXNode     CmpLNode
1782 #define SubXNode     SubLNode
1783 #define LShiftXNode  LShiftLNode
1784 // For object size computation:
1785 #define AddXNode     AddLNode
1786 #define RShiftXNode  RShiftLNode
1787 // For card marks and hashcodes
1788 #define URShiftXNode URShiftLNode
1789 // UseOptoBiasInlining
1790 #define XorXNode     XorLNode
1791 #define StoreXConditionalNode StoreLConditionalNode
1792 #define LoadXNode    LoadLNode
1793 #define StoreXNode   StoreLNode
1794 // Opcodes
1795 #define Op_LShiftX   Op_LShiftL
1796 #define Op_AndX      Op_AndL
1797 #define Op_AddX      Op_AddL
1798 #define Op_SubX      Op_SubL
1799 #define Op_XorX      Op_XorL
1800 #define Op_URShiftX  Op_URShiftL
1801 #define Op_LoadX     Op_LoadL
1802 // conversions
1803 #define ConvI2X(x)   ConvI2L(x)
1804 #define ConvL2X(x)   (x)
1805 #define ConvX2I(x)   ConvL2I(x)
1806 #define ConvX2L(x)   (x)
1807 #define ConvX2UL(x)  (x)
1808 
1809 #else
1810 
1811 // For type queries and asserts
1812 #define is_intptr_t  is_int
1813 #define isa_intptr_t isa_int
1814 #define find_intptr_t_type find_int_type
1815 #define find_intptr_t_con  find_int_con
1816 #define TypeX        TypeInt
1817 #define Type_X       Type::Int
1818 #define TypeX_X      TypeInt::INT
1819 #define TypeX_ZERO   TypeInt::ZERO
1820 // For &#39;ideal_reg&#39; machine registers
1821 #define Op_RegX      Op_RegI
1822 // For phase-&gt;intcon variants
1823 #define MakeConX     intcon
1824 #define ConXNode     ConINode
1825 // For array index arithmetic
1826 #define MulXNode     MulINode
1827 #define AndXNode     AndINode
1828 #define OrXNode      OrINode
1829 #define CmpXNode     CmpINode
1830 #define SubXNode     SubINode
1831 #define LShiftXNode  LShiftINode
1832 // For object size computation:
1833 #define AddXNode     AddINode
1834 #define RShiftXNode  RShiftINode
1835 // For card marks and hashcodes
1836 #define URShiftXNode URShiftINode
1837 // UseOptoBiasInlining
1838 #define XorXNode     XorINode
1839 #define StoreXConditionalNode StoreIConditionalNode
1840 #define LoadXNode    LoadINode
1841 #define StoreXNode   StoreINode
1842 // Opcodes
1843 #define Op_LShiftX   Op_LShiftI
1844 #define Op_AndX      Op_AndI
1845 #define Op_AddX      Op_AddI
1846 #define Op_SubX      Op_SubI
1847 #define Op_XorX      Op_XorI
1848 #define Op_URShiftX  Op_URShiftI
1849 #define Op_LoadX     Op_LoadI
1850 // conversions
1851 #define ConvI2X(x)   (x)
1852 #define ConvL2X(x)   ConvL2I(x)
1853 #define ConvX2I(x)   (x)
1854 #define ConvX2L(x)   ConvI2L(x)
1855 #define ConvX2UL(x)  ConvI2UL(x)
1856 
1857 #endif
1858 
1859 #endif // SHARE_OPTO_TYPE_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
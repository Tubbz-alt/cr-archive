<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;
  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  63 
  64 #if defined(PPC64)
  65   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  66   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  67   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  68   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  69   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  70 #elif defined(S390)
  71   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  72   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  73   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  74   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  75   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  76 #else // all other
  77   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  78   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  79   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  80   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  81   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  82 #endif
  83   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  84   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  85   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  86   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  87   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  88   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  89   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  90   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  91   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  92   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  93   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
  94   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
  95   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
  96   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
  97   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
  98   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
  99   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 100   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 101 };
 102 
 103 // Map ideal registers (machine types) to ideal types
 104 const Type *Type::mreg2type[_last_machine_leaf];
 105 
 106 // Map basic types to canonical Type* pointers.
 107 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 108 
 109 // Map basic types to constant-zero Types.
 110 const Type* Type::            _zero_type[T_CONFLICT+1];
 111 
 112 // Map basic types to array-body alias types.
 113 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 114 
 115 //=============================================================================
 116 // Convenience common pre-built types.
 117 const Type *Type::ABIO;         // State-of-machine only
 118 const Type *Type::BOTTOM;       // All values
 119 const Type *Type::CONTROL;      // Control only
 120 const Type *Type::DOUBLE;       // All doubles
 121 const Type *Type::FLOAT;        // All floats
 122 const Type *Type::HALF;         // Placeholder half of doublewide type
 123 const Type *Type::MEMORY;       // Abstract store only
 124 const Type *Type::RETURN_ADDRESS;
 125 const Type *Type::TOP;          // No values in set
 126 
 127 //------------------------------get_const_type---------------------------
 128 const Type* Type::get_const_type(ciType* type) {
 129   if (type == NULL) {
 130     return NULL;
 131   } else if (type-&gt;is_primitive_type()) {
 132     return get_const_basic_type(type-&gt;basic_type());
 133   } else {
 134     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 135   }
 136 }
 137 
 138 //---------------------------array_element_basic_type---------------------------------
 139 // Mapping to the array element&#39;s basic type.
 140 BasicType Type::array_element_basic_type() const {
 141   BasicType bt = basic_type();
 142   if (bt == T_INT) {
 143     if (this == TypeInt::INT)   return T_INT;
 144     if (this == TypeInt::CHAR)  return T_CHAR;
 145     if (this == TypeInt::BYTE)  return T_BYTE;
 146     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 147     if (this == TypeInt::SHORT) return T_SHORT;
 148     return T_VOID;
 149   }
 150   return bt;
 151 }
 152 
 153 // For two instance arrays of same dimension, return the base element types.
 154 // Otherwise or if the arrays have different dimensions, return NULL.
 155 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 156                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 157 
 158   if (e1) *e1 = NULL;
 159   if (e2) *e2 = NULL;
 160   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 161   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 162 
 163   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 164     // Handle multidimensional arrays
 165     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 166     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 167     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 168       a1tap = a1tp-&gt;is_aryptr();
 169       a2tap = a2tp-&gt;is_aryptr();
 170       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 171       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 172     }
 173     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 174       if (e1) *e1 = a1tp-&gt;is_instptr();
 175       if (e2) *e2 = a2tp-&gt;is_instptr();
 176     }
 177   }
 178 }
 179 
 180 //---------------------------get_typeflow_type---------------------------------
 181 // Import a type produced by ciTypeFlow.
 182 const Type* Type::get_typeflow_type(ciType* type) {
 183   switch (type-&gt;basic_type()) {
 184 
 185   case ciTypeFlow::StateVector::T_BOTTOM:
 186     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 187     return Type::BOTTOM;
 188 
 189   case ciTypeFlow::StateVector::T_TOP:
 190     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 191     return Type::TOP;
 192 
 193   case ciTypeFlow::StateVector::T_NULL:
 194     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 195     return TypePtr::NULL_PTR;
 196 
 197   case ciTypeFlow::StateVector::T_LONG2:
 198     // The ciTypeFlow pass pushes a long, then the half.
 199     // We do the same.
 200     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 201     return TypeInt::TOP;
 202 
 203   case ciTypeFlow::StateVector::T_DOUBLE2:
 204     // The ciTypeFlow pass pushes double, then the half.
 205     // Our convention is the same.
 206     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 207     return Type::TOP;
 208 
 209   case T_ADDRESS:
 210     assert(type-&gt;is_return_address(), &quot;&quot;);
 211     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 212 
 213   default:
 214     // make sure we did not mix up the cases:
 215     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 216     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 217     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 218     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 219     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 220     assert(!type-&gt;is_return_address(), &quot;&quot;);
 221 
 222     return Type::get_const_type(type);
 223   }
 224 }
 225 
 226 
 227 //-----------------------make_from_constant------------------------------------
 228 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 229                                      int stable_dimension, bool is_narrow_oop,
 230                                      bool is_autobox_cache) {
 231   switch (constant.basic_type()) {
 232     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 233     case T_CHAR:     return TypeInt::make(constant.as_char());
 234     case T_BYTE:     return TypeInt::make(constant.as_byte());
 235     case T_SHORT:    return TypeInt::make(constant.as_short());
 236     case T_INT:      return TypeInt::make(constant.as_int());
 237     case T_LONG:     return TypeLong::make(constant.as_long());
 238     case T_FLOAT:    return TypeF::make(constant.as_float());
 239     case T_DOUBLE:   return TypeD::make(constant.as_double());
 240     case T_ARRAY:
 241     case T_OBJECT: {
 242         const Type* con_type = NULL;
 243         ciObject* oop_constant = constant.as_object();
 244         if (oop_constant-&gt;is_null_object()) {
 245           con_type = Type::get_zero_type(T_OBJECT);
 246         } else {
 247           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 248           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 249           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 250             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 251           }
 252           if (stable_dimension &gt; 0) {
 253             assert(FoldStableValues, &quot;sanity&quot;);
 254             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 255             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 256           }
 257         }
 258         if (is_narrow_oop) {
 259           con_type = con_type-&gt;make_narrowoop();
 260         }
 261         return con_type;
 262       }
 263     case T_ILLEGAL:
 264       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 265       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 266       return NULL;
 267     default:
 268       // Fall through to failure
 269       return NULL;
 270   }
 271 }
 272 
 273 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 274   BasicType conbt = con.basic_type();
 275   switch (conbt) {
 276     case T_BOOLEAN: conbt = T_BYTE;   break;
 277     case T_ARRAY:   conbt = T_OBJECT; break;
 278     default:                          break;
 279   }
 280   switch (loadbt) {
 281     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 282     case T_NARROWOOP: loadbt = T_OBJECT; break;
 283     case T_ARRAY:     loadbt = T_OBJECT; break;
 284     case T_ADDRESS:   loadbt = T_OBJECT; break;
 285     default:                             break;
 286   }
 287   if (conbt == loadbt) {
 288     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 289       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 290       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 291     } else {
 292       return con;
 293     }
 294   }
 295   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 296     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 297     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 298   }
 299   return ciConstant(); // T_ILLEGAL
 300 }
 301 
 302 // Try to constant-fold a stable array element.
 303 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 304                                                    BasicType loadbt, bool is_unsigned_load) {
 305   // Decode the results of GraphKit::array_element_address.
 306   ciConstant element_value = array-&gt;element_value_by_offset(off);
 307   if (element_value.basic_type() == T_ILLEGAL) {
 308     return NULL; // wrong offset
 309   }
 310   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 311 
 312   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 313          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 314 
 315   if (con.is_valid() &amp;&amp;          // not a mismatched access
 316       !con.is_null_or_zero()) {  // not a default value
 317     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 318     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 319   }
 320   return NULL;
 321 }
 322 
 323 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 324   ciField* field;
 325   ciType* type = holder-&gt;java_mirror_type();
 326   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 327     // Static field
 328     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 329   } else {
 330     // Instance field
 331     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 332   }
 333   if (field == NULL) {
 334     return NULL; // Wrong offset
 335   }
 336   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 337 }
 338 
 339 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 340                                            BasicType loadbt, bool is_unsigned_load) {
 341   if (!field-&gt;is_constant()) {
 342     return NULL; // Non-constant field
 343   }
 344   ciConstant field_value;
 345   if (field-&gt;is_static()) {
 346     // final static field
 347     field_value = field-&gt;constant_value();
 348   } else if (holder != NULL) {
 349     // final or stable non-static field
 350     // Treat final non-static fields of trusted classes (classes in
 351     // java.lang.invoke and sun.invoke packages and subpackages) as
 352     // compile time constants.
 353     field_value = field-&gt;constant_value_of(holder);
 354   }
 355   if (!field_value.is_valid()) {
 356     return NULL; // Not a constant
 357   }
 358 
 359   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 360 
 361   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 362          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 363 
 364   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 365   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 366   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 367 
 368   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 369                                             stable_dimension, is_narrow_oop,
 370                                             field-&gt;is_autobox_cache());
 371   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 372     ciCallSite* call_site = holder-&gt;as_call_site();
 373     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 374       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 375       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 376     }
 377   }
 378   return con_type;
 379 }
 380 
 381 //------------------------------make-------------------------------------------
 382 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 383 // and look for an existing copy in the type dictionary.
 384 const Type *Type::make( enum TYPES t ) {
 385   return (new Type(t))-&gt;hashcons();
 386 }
 387 
 388 //------------------------------cmp--------------------------------------------
 389 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 390   if( t1-&gt;_base != t2-&gt;_base )
 391     return 1;                   // Missed badly
 392   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 393   return !t1-&gt;eq(t2);           // Return ZERO if equal
 394 }
 395 
 396 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 397   if (!include_speculative) {
 398     return remove_speculative();
 399   }
 400   return this;
 401 }
 402 
 403 //------------------------------hash-------------------------------------------
 404 int Type::uhash( const Type *const t ) {
 405   return t-&gt;hash();
 406 }
 407 
 408 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 409 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 410 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 411 
 412 //--------------------------Initialize_shared----------------------------------
 413 void Type::Initialize_shared(Compile* current) {
 414   // This method does not need to be locked because the first system
 415   // compilations (stub compilations) occur serially.  If they are
 416   // changed to proceed in parallel, then this section will need
 417   // locking.
 418 
 419   Arena* save = current-&gt;type_arena();
 420   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 421 
 422   current-&gt;set_type_arena(shared_type_arena);
 423   _shared_type_dict =
 424     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 425                                   shared_type_arena, 128 );
 426   current-&gt;set_type_dict(_shared_type_dict);
 427 
 428   // Make shared pre-built types.
 429   CONTROL = make(Control);      // Control only
 430   TOP     = make(Top);          // No values in set
 431   MEMORY  = make(Memory);       // Abstract store only
 432   ABIO    = make(Abio);         // State-of-machine only
 433   RETURN_ADDRESS=make(Return_Address);
 434   FLOAT   = make(FloatBot);     // All floats
 435   DOUBLE  = make(DoubleBot);    // All doubles
 436   BOTTOM  = make(Bottom);       // Everything
 437   HALF    = make(Half);         // Placeholder half of doublewide type
 438 
 439   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 440   TypeF::ONE  = TypeF::make(1.0); // Float 1
 441   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 442   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 443 
 444   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 445   TypeD::ONE  = TypeD::make(1.0); // Double 1
 446   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 447   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 448 
 449   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 450   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 451   TypeInt::ONE     = TypeInt::make( 1);  //  1
 452   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 453   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 454   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 455   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 456   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 457   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 458   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 459   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 460   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 461   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 462   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 463   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 464   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 465   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 466   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 467   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 468   // CmpL is overloaded both as the bytecode computation returning
 469   // a trinary (-1,0,+1) integer result AND as an efficient long
 470   // compare returning optimizer ideal-type flags.
 471   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 472   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 473   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 474   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 475   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 476 
 477   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 478   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 479   TypeLong::ONE     = TypeLong::make( 1);        //  1
 480   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 481   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 482   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 483   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 484   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 485 
 486   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 487   fboth[0] = Type::CONTROL;
 488   fboth[1] = Type::CONTROL;
 489   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 490 
 491   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 492   ffalse[0] = Type::CONTROL;
 493   ffalse[1] = Type::TOP;
 494   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 495 
 496   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 497   fneither[0] = Type::TOP;
 498   fneither[1] = Type::TOP;
 499   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 500 
 501   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 502   ftrue[0] = Type::TOP;
 503   ftrue[1] = Type::CONTROL;
 504   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 505 
 506   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 507   floop[0] = Type::CONTROL;
 508   floop[1] = TypeInt::INT;
 509   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 510 
 511   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);
 512   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);
 513   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);
 514 
 515   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 516   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 517 
 518   const Type **fmembar = TypeTuple::fields(0);
 519   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 520 
 521   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 522   fsc[0] = TypeInt::CC;
 523   fsc[1] = Type::MEMORY;
 524   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 525 
 526   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 527   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 528   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 529   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 530                                            false, 0, oopDesc::mark_offset_in_bytes());
 531   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 532                                            false, 0, oopDesc::klass_offset_in_bytes());
 533   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);
 534 
 535   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);
 536 
 537   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 538   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 539 
 540   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 541 
 542   mreg2type[Op_Node] = Type::BOTTOM;
 543   mreg2type[Op_Set ] = 0;
 544   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 545   mreg2type[Op_RegI] = TypeInt::INT;
 546   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 547   mreg2type[Op_RegF] = Type::FLOAT;
 548   mreg2type[Op_RegD] = Type::DOUBLE;
 549   mreg2type[Op_RegL] = TypeLong::LONG;
 550   mreg2type[Op_RegFlags] = TypeInt::CC;
 551 
 552   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());
 553 
 554   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 555 
 556 #ifdef _LP64
 557   if (UseCompressedOops) {
 558     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 559     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 560   } else
 561 #endif
 562   {
 563     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 564     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 565   }
 566   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);
 567   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);
 568   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);
 569   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);
 570   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);
 571   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);
 572   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);
 573 
 574   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 575   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 576   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 577   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 578   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 579   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 580   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 581   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 582   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 583   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 584   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 585   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 586 
 587   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );
 588   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );
 589 
 590   const Type **fi2c = TypeTuple::fields(2);
 591   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 592   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 593   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 594 
 595   const Type **intpair = TypeTuple::fields(2);
 596   intpair[0] = TypeInt::INT;
 597   intpair[1] = TypeInt::INT;
 598   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 599 
 600   const Type **longpair = TypeTuple::fields(2);
 601   longpair[0] = TypeLong::LONG;
 602   longpair[1] = TypeLong::LONG;
 603   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 604 
 605   const Type **intccpair = TypeTuple::fields(2);
 606   intccpair[0] = TypeInt::INT;
 607   intccpair[1] = TypeInt::CC;
 608   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 609 
 610   const Type **longccpair = TypeTuple::fields(2);
 611   longccpair[0] = TypeLong::LONG;
 612   longccpair[1] = TypeInt::CC;
 613   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 614 
 615   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 616   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 617   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 618   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 619   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 620   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 621   _const_basic_type[T_INT]         = TypeInt::INT;
 622   _const_basic_type[T_LONG]        = TypeLong::LONG;
 623   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 624   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 625   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 626   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 627   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 628   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 629   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 630 
 631   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 632   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 633   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 634   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 635   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 636   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 637   _zero_type[T_INT]         = TypeInt::ZERO;
 638   _zero_type[T_LONG]        = TypeLong::ZERO;
 639   _zero_type[T_FLOAT]       = TypeF::ZERO;
 640   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 641   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 642   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 643   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 644   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 645 
 646   // get_zero_type() should not happen for T_CONFLICT
 647   _zero_type[T_CONFLICT]= NULL;
 648 
 649   // Vector predefined types, it needs initialized _const_basic_type[].
 650   if (Matcher::vector_size_supported(T_BYTE,4)) {
 651     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 652   }
 653   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 654     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 655   }
 656   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 657     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 658   }
 659   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 660     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 661   }
 662   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 663     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 664   }
 665   mreg2type[Op_VecS] = TypeVect::VECTS;
 666   mreg2type[Op_VecD] = TypeVect::VECTD;
 667   mreg2type[Op_VecX] = TypeVect::VECTX;
 668   mreg2type[Op_VecY] = TypeVect::VECTY;
 669   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 670 
 671   // Restore working type arena.
 672   current-&gt;set_type_arena(save);
 673   current-&gt;set_type_dict(NULL);
 674 }
 675 
 676 //------------------------------Initialize-------------------------------------
 677 void Type::Initialize(Compile* current) {
 678   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 679 
 680   if (_shared_type_dict == NULL) {
 681     Initialize_shared(current);
 682   }
 683 
 684   Arena* type_arena = current-&gt;type_arena();
 685 
 686   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 687   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 688   current-&gt;set_type_dict(tdic);
 689 
 690   // Transfer the shared types.
 691   DictI i(_shared_type_dict);
 692   for( ; i.test(); ++i ) {
 693     Type* t = (Type*)i._value;
 694     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 695   }
 696 }
 697 
 698 //------------------------------hashcons---------------------------------------
 699 // Do the hash-cons trick.  If the Type already exists in the type table,
 700 // delete the current Type and return the existing Type.  Otherwise stick the
 701 // current Type in the Type table.
 702 const Type *Type::hashcons(void) {
 703   debug_only(base());           // Check the assertion in Type::base().
 704   // Look up the Type in the Type dictionary
 705   Dict *tdic = type_dict();
 706   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 707   if( old ) {                   // Pre-existing Type?
 708     if( old != this )           // Yes, this guy is not the pre-existing?
 709       delete this;              // Yes, Nuke this guy
 710     assert( old-&gt;_dual, &quot;&quot; );
 711     return old;                 // Return pre-existing
 712   }
 713 
 714   // Every type has a dual (to make my lattice symmetric).
 715   // Since we just discovered a new Type, compute its dual right now.
 716   assert( !_dual, &quot;&quot; );         // No dual yet
 717   _dual = xdual();              // Compute the dual
 718   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 719     if (_dual != this) {
 720       delete _dual;
 721       _dual = this;
 722     }
 723     return this;
 724   }
 725   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 726   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 727   // New Type, insert into Type table
 728   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 729   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 730 #ifdef ASSERT
 731   Type *dual_dual = (Type*)_dual-&gt;xdual();
 732   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 733   delete dual_dual;
 734 #endif
 735   return this;                  // Return new Type
 736 }
 737 
 738 //------------------------------eq---------------------------------------------
 739 // Structural equality check for Type representations
 740 bool Type::eq( const Type * ) const {
 741   return true;                  // Nothing else can go wrong
 742 }
 743 
 744 //------------------------------hash-------------------------------------------
 745 // Type-specific hashing function.
 746 int Type::hash(void) const {
 747   return _base;
 748 }
 749 
 750 //------------------------------is_finite--------------------------------------
 751 // Has a finite value
 752 bool Type::is_finite() const {
 753   return false;
 754 }
 755 
 756 //------------------------------is_nan-----------------------------------------
 757 // Is not a number (NaN)
 758 bool Type::is_nan()    const {
 759   return false;
 760 }
 761 
 762 //----------------------interface_vs_oop---------------------------------------
 763 #ifdef ASSERT
 764 bool Type::interface_vs_oop_helper(const Type *t) const {
 765   bool result = false;
 766 
 767   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 768   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 769   if( this_ptr == NULL || t_ptr == NULL )
 770     return result;
 771 
 772   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 773   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 774   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 775     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 776     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 777     result = this_interface ^ t_interface;
 778   }
 779 
 780   return result;
 781 }
 782 
 783 bool Type::interface_vs_oop(const Type *t) const {
 784   if (interface_vs_oop_helper(t)) {
 785     return true;
 786   }
 787   // Now check the speculative parts as well
 788   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 789   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 790   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 791     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 792       return true;
 793     }
 794     return false;
 795   }
 796   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 797     return true;
 798   }
 799   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 800     return true;
 801   }
 802   return false;
 803 }
 804 
 805 #endif
 806 
 807 void Type::check_symmetrical(const Type *t, const Type *mt) const {
 808 #ifdef ASSERT
 809   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);
 810   const Type* dual_join = mt-&gt;_dual;
 811   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 812   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);
 813 
 814   // Interface meet Oop is Not Symmetric:
 815   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 816   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 817 
 818   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) ) {
 819     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 820     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 821     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();
 822     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 823 
 824     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 825     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();
 826     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 827 
 828     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 829     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 830 
 831     fatal(&quot;meet not symmetric&quot; );
 832   }
 833 #endif
 834 }
 835 
 836 //------------------------------meet-------------------------------------------
 837 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 838 // commutative and the lattice is symmetric.
 839 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 840   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 841     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 842     return result-&gt;make_narrowoop();
 843   }
 844   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 845     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 846     return result-&gt;make_narrowklass();
 847   }
 848 
 849   const Type *this_t = maybe_remove_speculative(include_speculative);
 850   t = t-&gt;maybe_remove_speculative(include_speculative);
 851 
 852   const Type *mt = this_t-&gt;xmeet(t);
 853 #ifdef ASSERT
 854   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 855   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 856   Compile* C = Compile::current();
 857   if (!C-&gt;_type_verify_symmetry) {
 858     return mt;
 859   }
 860   this_t-&gt;check_symmetrical(t, mt);
 861   // In the case of an array, computing the meet above, caused the
 862   // computation of the meet of the elements which at verification
 863   // time caused the computation of the meet of the dual of the
 864   // elements. Computing the meet of the dual of the arrays here
 865   // causes the meet of the dual of the elements to be computed which
 866   // would cause the meet of the dual of the dual of the elements,
 867   // that is the meet of the elements already computed above to be
 868   // computed. Avoid redundant computations by requesting no
 869   // verification.
 870   C-&gt;_type_verify_symmetry = false;
 871   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);
 872   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);
 873   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);
 874   C-&gt;_type_verify_symmetry = true;
 875 #endif
 876   return mt;
 877 }
 878 
 879 //------------------------------xmeet------------------------------------------
 880 // Compute the MEET of two types.  It returns a new Type object.
 881 const Type *Type::xmeet( const Type *t ) const {
 882   // Perform a fast test for common case; meeting the same types together.
 883   if( this == t ) return this;  // Meeting same type-rep?
 884 
 885   // Meeting TOP with anything?
 886   if( _base == Top ) return t;
 887 
 888   // Meeting BOTTOM with anything?
 889   if( _base == Bottom ) return BOTTOM;
 890 
 891   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 892   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 893   switch (t-&gt;base()) {  // Switch on original type
 894 
 895   // Cut in half the number of cases I must handle.  Only need cases for when
 896   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 897   case FloatCon:
 898   case DoubleCon:
 899   case Int:
 900   case Long:
 901     return t-&gt;xmeet(this);
 902 
 903   case OopPtr:
 904     return t-&gt;xmeet(this);
 905 
 906   case InstPtr:
 907     return t-&gt;xmeet(this);
 908 
 909   case MetadataPtr:
 910   case KlassPtr:
 911     return t-&gt;xmeet(this);
 912 
 913   case AryPtr:
 914     return t-&gt;xmeet(this);
 915 
 916   case NarrowOop:
 917     return t-&gt;xmeet(this);
 918 
 919   case NarrowKlass:
 920     return t-&gt;xmeet(this);
 921 
 922   case Bad:                     // Type check
 923   default:                      // Bogus type not in lattice
 924     typerr(t);
 925     return Type::BOTTOM;
 926 
 927   case Bottom:                  // Ye Olde Default
 928     return t;
 929 
 930   case FloatTop:
 931     if( _base == FloatTop ) return this;
 932   case FloatBot:                // Float
 933     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 934     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 935     typerr(t);
 936     return Type::BOTTOM;
 937 
 938   case DoubleTop:
 939     if( _base == DoubleTop ) return this;
 940   case DoubleBot:               // Double
 941     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 942     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 943     typerr(t);
 944     return Type::BOTTOM;
 945 
 946   // These next few cases must match exactly or it is a compile-time error.
 947   case Control:                 // Control of code
 948   case Abio:                    // State of world outside of program
 949   case Memory:
 950     if( _base == t-&gt;_base )  return this;
 951     typerr(t);
 952     return Type::BOTTOM;
 953 
 954   case Top:                     // Top of the lattice
 955     return this;
 956   }
 957 
 958   // The type is unchanged
 959   return this;
 960 }
 961 
 962 //-----------------------------filter------------------------------------------
 963 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
 964   const Type* ft = join_helper(kills, include_speculative);
 965   if (ft-&gt;empty())
 966     return Type::TOP;           // Canonical empty value
 967   return ft;
 968 }
 969 
 970 //------------------------------xdual------------------------------------------
 971 // Compute dual right now.
 972 const Type::TYPES Type::dual_type[Type::lastype] = {
 973   Bad,          // Bad
 974   Control,      // Control
 975   Bottom,       // Top
 976   Bad,          // Int - handled in v-call
 977   Bad,          // Long - handled in v-call
 978   Half,         // Half
 979   Bad,          // NarrowOop - handled in v-call
 980   Bad,          // NarrowKlass - handled in v-call
 981 
 982   Bad,          // Tuple - handled in v-call
 983   Bad,          // Array - handled in v-call
 984   Bad,          // VectorS - handled in v-call
 985   Bad,          // VectorD - handled in v-call
 986   Bad,          // VectorX - handled in v-call
 987   Bad,          // VectorY - handled in v-call
 988   Bad,          // VectorZ - handled in v-call
 989 
 990   Bad,          // AnyPtr - handled in v-call
 991   Bad,          // RawPtr - handled in v-call
 992   Bad,          // OopPtr - handled in v-call
 993   Bad,          // InstPtr - handled in v-call
 994   Bad,          // AryPtr - handled in v-call
 995 
 996   Bad,          //  MetadataPtr - handled in v-call
 997   Bad,          // KlassPtr - handled in v-call
 998 
 999   Bad,          // Function - handled in v-call
1000   Abio,         // Abio
1001   Return_Address,// Return_Address
1002   Memory,       // Memory
1003   FloatBot,     // FloatTop
1004   FloatCon,     // FloatCon
1005   FloatTop,     // FloatBot
1006   DoubleBot,    // DoubleTop
1007   DoubleCon,    // DoubleCon
1008   DoubleTop,    // DoubleBot
1009   Top           // Bottom
1010 };
1011 
1012 const Type *Type::xdual() const {
1013   // Note: the base() accessor asserts the sanity of _base.
1014   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
1015   return new Type(_type_info[_base].dual_type);
1016 }
1017 
1018 //------------------------------has_memory-------------------------------------
1019 bool Type::has_memory() const {
1020   Type::TYPES tx = base();
1021   if (tx == Memory) return true;
1022   if (tx == Tuple) {
1023     const TypeTuple *t = is_tuple();
1024     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1025       tx = t-&gt;field_at(i)-&gt;base();
1026       if (tx == Memory)  return true;
1027     }
1028   }
1029   return false;
1030 }
1031 
1032 #ifndef PRODUCT
1033 //------------------------------dump2------------------------------------------
1034 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1035   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1036 }
1037 
1038 //------------------------------dump-------------------------------------------
1039 void Type::dump_on(outputStream *st) const {
1040   ResourceMark rm;
1041   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1042   dump2(d,1, st);
1043   if (is_ptr_to_narrowoop()) {
1044     st-&gt;print(&quot; [narrow]&quot;);
1045   } else if (is_ptr_to_narrowklass()) {
1046     st-&gt;print(&quot; [narrowklass]&quot;);
1047   }
1048 }
1049 
1050 //-----------------------------------------------------------------------------
1051 const char* Type::str(const Type* t) {
1052   stringStream ss;
1053   t-&gt;dump_on(&amp;ss);
1054   return ss.as_string();
1055 }
1056 #endif
1057 
1058 //------------------------------singleton--------------------------------------
1059 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1060 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1061 bool Type::singleton(void) const {
1062   return _base == Top || _base == Half;
1063 }
1064 
1065 //------------------------------empty------------------------------------------
1066 // TRUE if Type is a type with no values, FALSE otherwise.
1067 bool Type::empty(void) const {
1068   switch (_base) {
1069   case DoubleTop:
1070   case FloatTop:
1071   case Top:
1072     return true;
1073 
1074   case Half:
1075   case Abio:
1076   case Return_Address:
1077   case Memory:
1078   case Bottom:
1079   case FloatBot:
1080   case DoubleBot:
1081     return false;  // never a singleton, therefore never empty
1082 
1083   default:
1084     ShouldNotReachHere();
1085     return false;
1086   }
1087 }
1088 
1089 //------------------------------dump_stats-------------------------------------
1090 // Dump collected statistics to stderr
1091 #ifndef PRODUCT
1092 void Type::dump_stats() {
1093   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1094 }
1095 #endif
1096 
1097 //------------------------------typerr-----------------------------------------
1098 void Type::typerr( const Type *t ) const {
1099 #ifndef PRODUCT
1100   tty-&gt;print(&quot;\nError mixing types: &quot;);
1101   dump();
1102   tty-&gt;print(&quot; and &quot;);
1103   t-&gt;dump();
1104   tty-&gt;print(&quot;\n&quot;);
1105 #endif
1106   ShouldNotReachHere();
1107 }
1108 
1109 
1110 //=============================================================================
1111 // Convenience common pre-built types.
1112 const TypeF *TypeF::ZERO;       // Floating point zero
1113 const TypeF *TypeF::ONE;        // Floating point one
1114 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1115 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1116 
1117 //------------------------------make-------------------------------------------
1118 // Create a float constant
1119 const TypeF *TypeF::make(float f) {
1120   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1121 }
1122 
1123 //------------------------------meet-------------------------------------------
1124 // Compute the MEET of two types.  It returns a new Type object.
1125 const Type *TypeF::xmeet( const Type *t ) const {
1126   // Perform a fast test for common case; meeting the same types together.
1127   if( this == t ) return this;  // Meeting same type-rep?
1128 
1129   // Current &quot;this-&gt;_base&quot; is FloatCon
1130   switch (t-&gt;base()) {          // Switch on original type
1131   case AnyPtr:                  // Mixing with oops happens when javac
1132   case RawPtr:                  // reuses local variables
1133   case OopPtr:
1134   case InstPtr:
1135   case AryPtr:
1136   case MetadataPtr:
1137   case KlassPtr:
1138   case NarrowOop:
1139   case NarrowKlass:
1140   case Int:
1141   case Long:
1142   case DoubleTop:
1143   case DoubleCon:
1144   case DoubleBot:
1145   case Bottom:                  // Ye Olde Default
1146     return Type::BOTTOM;
1147 
1148   case FloatBot:
1149     return t;
1150 
1151   default:                      // All else is a mistake
1152     typerr(t);
1153 
1154   case FloatCon:                // Float-constant vs Float-constant?
1155     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1156                                 // must compare bitwise as positive zero, negative zero and NaN have
1157                                 // all the same representation in C++
1158       return FLOAT;             // Return generic float
1159                                 // Equal constants
1160   case Top:
1161   case FloatTop:
1162     break;                      // Return the float constant
1163   }
1164   return this;                  // Return the float constant
1165 }
1166 
1167 //------------------------------xdual------------------------------------------
1168 // Dual: symmetric
1169 const Type *TypeF::xdual() const {
1170   return this;
1171 }
1172 
1173 //------------------------------eq---------------------------------------------
1174 // Structural equality check for Type representations
1175 bool TypeF::eq(const Type *t) const {
1176   // Bitwise comparison to distinguish between +/-0. These values must be treated
1177   // as different to be consistent with C1 and the interpreter.
1178   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1179 }
1180 
1181 //------------------------------hash-------------------------------------------
1182 // Type-specific hashing function.
1183 int TypeF::hash(void) const {
1184   return *(int*)(&amp;_f);
1185 }
1186 
1187 //------------------------------is_finite--------------------------------------
1188 // Has a finite value
1189 bool TypeF::is_finite() const {
1190   return g_isfinite(getf()) != 0;
1191 }
1192 
1193 //------------------------------is_nan-----------------------------------------
1194 // Is not a number (NaN)
1195 bool TypeF::is_nan()    const {
1196   return g_isnan(getf()) != 0;
1197 }
1198 
1199 //------------------------------dump2------------------------------------------
1200 // Dump float constant Type
1201 #ifndef PRODUCT
1202 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1203   Type::dump2(d,depth, st);
1204   st-&gt;print(&quot;%f&quot;, _f);
1205 }
1206 #endif
1207 
1208 //------------------------------singleton--------------------------------------
1209 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1210 // constants (Ldi nodes).  Singletons are integer, float or double constants
1211 // or a single symbol.
1212 bool TypeF::singleton(void) const {
1213   return true;                  // Always a singleton
1214 }
1215 
1216 bool TypeF::empty(void) const {
1217   return false;                 // always exactly a singleton
1218 }
1219 
1220 //=============================================================================
1221 // Convenience common pre-built types.
1222 const TypeD *TypeD::ZERO;       // Floating point zero
1223 const TypeD *TypeD::ONE;        // Floating point one
1224 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1225 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1226 
1227 //------------------------------make-------------------------------------------
1228 const TypeD *TypeD::make(double d) {
1229   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1230 }
1231 
1232 //------------------------------meet-------------------------------------------
1233 // Compute the MEET of two types.  It returns a new Type object.
1234 const Type *TypeD::xmeet( const Type *t ) const {
1235   // Perform a fast test for common case; meeting the same types together.
1236   if( this == t ) return this;  // Meeting same type-rep?
1237 
1238   // Current &quot;this-&gt;_base&quot; is DoubleCon
1239   switch (t-&gt;base()) {          // Switch on original type
1240   case AnyPtr:                  // Mixing with oops happens when javac
1241   case RawPtr:                  // reuses local variables
1242   case OopPtr:
1243   case InstPtr:
1244   case AryPtr:
1245   case MetadataPtr:
1246   case KlassPtr:
1247   case NarrowOop:
1248   case NarrowKlass:
1249   case Int:
1250   case Long:
1251   case FloatTop:
1252   case FloatCon:
1253   case FloatBot:
1254   case Bottom:                  // Ye Olde Default
1255     return Type::BOTTOM;
1256 
1257   case DoubleBot:
1258     return t;
1259 
1260   default:                      // All else is a mistake
1261     typerr(t);
1262 
1263   case DoubleCon:               // Double-constant vs Double-constant?
1264     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1265       return DOUBLE;            // Return generic double
1266   case Top:
1267   case DoubleTop:
1268     break;
1269   }
1270   return this;                  // Return the double constant
1271 }
1272 
1273 //------------------------------xdual------------------------------------------
1274 // Dual: symmetric
1275 const Type *TypeD::xdual() const {
1276   return this;
1277 }
1278 
1279 //------------------------------eq---------------------------------------------
1280 // Structural equality check for Type representations
1281 bool TypeD::eq(const Type *t) const {
1282   // Bitwise comparison to distinguish between +/-0. These values must be treated
1283   // as different to be consistent with C1 and the interpreter.
1284   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1285 }
1286 
1287 //------------------------------hash-------------------------------------------
1288 // Type-specific hashing function.
1289 int TypeD::hash(void) const {
1290   return *(int*)(&amp;_d);
1291 }
1292 
1293 //------------------------------is_finite--------------------------------------
1294 // Has a finite value
1295 bool TypeD::is_finite() const {
1296   return g_isfinite(getd()) != 0;
1297 }
1298 
1299 //------------------------------is_nan-----------------------------------------
1300 // Is not a number (NaN)
1301 bool TypeD::is_nan()    const {
1302   return g_isnan(getd()) != 0;
1303 }
1304 
1305 //------------------------------dump2------------------------------------------
1306 // Dump double constant Type
1307 #ifndef PRODUCT
1308 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1309   Type::dump2(d,depth,st);
1310   st-&gt;print(&quot;%f&quot;, _d);
1311 }
1312 #endif
1313 
1314 //------------------------------singleton--------------------------------------
1315 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1316 // constants (Ldi nodes).  Singletons are integer, float or double constants
1317 // or a single symbol.
1318 bool TypeD::singleton(void) const {
1319   return true;                  // Always a singleton
1320 }
1321 
1322 bool TypeD::empty(void) const {
1323   return false;                 // always exactly a singleton
1324 }
1325 
1326 //=============================================================================
1327 // Convience common pre-built types.
1328 const TypeInt *TypeInt::MINUS_1;// -1
1329 const TypeInt *TypeInt::ZERO;   // 0
1330 const TypeInt *TypeInt::ONE;    // 1
1331 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1332 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1333 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1334 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1335 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1336 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1337 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1338 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1339 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1340 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1341 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1342 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1343 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1344 const TypeInt *TypeInt::INT;    // 32-bit integers
1345 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1346 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1347 
1348 //------------------------------TypeInt----------------------------------------
1349 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1350 }
1351 
1352 //------------------------------make-------------------------------------------
1353 const TypeInt *TypeInt::make( jint lo ) {
1354   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1355 }
1356 
1357 static int normalize_int_widen( jint lo, jint hi, int w ) {
1358   // Certain normalizations keep us sane when comparing types.
1359   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1360   if (lo &lt;= hi) {
1361     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1362     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1363   } else {
1364     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1365     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1366   }
1367   return w;
1368 }
1369 
1370 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1371   w = normalize_int_widen(lo, hi, w);
1372   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1373 }
1374 
1375 //------------------------------meet-------------------------------------------
1376 // Compute the MEET of two types.  It returns a new Type representation object
1377 // with reference count equal to the number of Types pointing at it.
1378 // Caller should wrap a Types around it.
1379 const Type *TypeInt::xmeet( const Type *t ) const {
1380   // Perform a fast test for common case; meeting the same types together.
1381   if( this == t ) return this;  // Meeting same type?
1382 
1383   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1384   switch (t-&gt;base()) {          // Switch on original type
1385   case AnyPtr:                  // Mixing with oops happens when javac
1386   case RawPtr:                  // reuses local variables
1387   case OopPtr:
1388   case InstPtr:
1389   case AryPtr:
1390   case MetadataPtr:
1391   case KlassPtr:
1392   case NarrowOop:
1393   case NarrowKlass:
1394   case Long:
1395   case FloatTop:
1396   case FloatCon:
1397   case FloatBot:
1398   case DoubleTop:
1399   case DoubleCon:
1400   case DoubleBot:
1401   case Bottom:                  // Ye Olde Default
1402     return Type::BOTTOM;
1403   default:                      // All else is a mistake
1404     typerr(t);
1405   case Top:                     // No change
1406     return this;
1407   case Int:                     // Int vs Int?
1408     break;
1409   }
1410 
1411   // Expand covered set
1412   const TypeInt *r = t-&gt;is_int();
1413   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1414 }
1415 
1416 //------------------------------xdual------------------------------------------
1417 // Dual: reverse hi &amp; lo; flip widen
1418 const Type *TypeInt::xdual() const {
1419   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1420   return new TypeInt(_hi,_lo,w);
1421 }
1422 
1423 //------------------------------widen------------------------------------------
1424 // Only happens for optimistic top-down optimizations.
1425 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1426   // Coming from TOP or such; no widening
1427   if( old-&gt;base() != Int ) return this;
1428   const TypeInt *ot = old-&gt;is_int();
1429 
1430   // If new guy is equal to old guy, no widening
1431   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1432     return old;
1433 
1434   // If new guy contains old, then we widened
1435   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1436     // New contains old
1437     // If new guy is already wider than old, no widening
1438     if( _widen &gt; ot-&gt;_widen ) return this;
1439     // If old guy was a constant, do not bother
1440     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1441     // Now widen new guy.
1442     // Check for widening too far
1443     if (_widen == WidenMax) {
1444       int max = max_jint;
1445       int min = min_jint;
1446       if (limit-&gt;isa_int()) {
1447         max = limit-&gt;is_int()-&gt;_hi;
1448         min = limit-&gt;is_int()-&gt;_lo;
1449       }
1450       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1451         // If neither endpoint is extremal yet, push out the endpoint
1452         // which is closer to its respective limit.
1453         if (_lo &gt;= 0 ||                 // easy common case
1454             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1455           // Try to widen to an unsigned range type of 31 bits:
1456           return make(_lo, max, WidenMax);
1457         } else {
1458           return make(min, _hi, WidenMax);
1459         }
1460       }
1461       return TypeInt::INT;
1462     }
1463     // Returned widened new guy
1464     return make(_lo,_hi,_widen+1);
1465   }
1466 
1467   // If old guy contains new, then we probably widened too far &amp; dropped to
1468   // bottom.  Return the wider fellow.
1469   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1470     return old;
1471 
1472   //fatal(&quot;Integer value range is not subset&quot;);
1473   //return this;
1474   return TypeInt::INT;
1475 }
1476 
1477 //------------------------------narrow---------------------------------------
1478 // Only happens for pessimistic optimizations.
1479 const Type *TypeInt::narrow( const Type *old ) const {
1480   if (_lo &gt;= _hi)  return this;   // already narrow enough
1481   if (old == NULL)  return this;
1482   const TypeInt* ot = old-&gt;isa_int();
1483   if (ot == NULL)  return this;
1484   jint olo = ot-&gt;_lo;
1485   jint ohi = ot-&gt;_hi;
1486 
1487   // If new guy is equal to old guy, no narrowing
1488   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1489 
1490   // If old guy was maximum range, allow the narrowing
1491   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1492 
1493   if (_lo &lt; olo || _hi &gt; ohi)
1494     return this;                // doesn&#39;t narrow; pretty wierd
1495 
1496   // The new type narrows the old type, so look for a &quot;death march&quot;.
1497   // See comments on PhaseTransform::saturate.
1498   juint nrange = (juint)_hi - _lo;
1499   juint orange = (juint)ohi - olo;
1500   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1501     // Use the new type only if the range shrinks a lot.
1502     // We do not want the optimizer computing 2^31 point by point.
1503     return old;
1504   }
1505 
1506   return this;
1507 }
1508 
1509 //-----------------------------filter------------------------------------------
1510 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1511   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1512   if (ft == NULL || ft-&gt;empty())
1513     return Type::TOP;           // Canonical empty value
1514   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1515     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1516     // The widen bits must be allowed to run freely through the graph.
1517     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1518   }
1519   return ft;
1520 }
1521 
1522 //------------------------------eq---------------------------------------------
1523 // Structural equality check for Type representations
1524 bool TypeInt::eq( const Type *t ) const {
1525   const TypeInt *r = t-&gt;is_int(); // Handy access
1526   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1527 }
1528 
1529 //------------------------------hash-------------------------------------------
1530 // Type-specific hashing function.
1531 int TypeInt::hash(void) const {
1532   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1533 }
1534 
1535 //------------------------------is_finite--------------------------------------
1536 // Has a finite value
1537 bool TypeInt::is_finite() const {
1538   return true;
1539 }
1540 
1541 //------------------------------dump2------------------------------------------
1542 // Dump TypeInt
1543 #ifndef PRODUCT
1544 static const char* intname(char* buf, jint n) {
1545   if (n == min_jint)
1546     return &quot;min&quot;;
1547   else if (n &lt; min_jint + 10000)
1548     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1549   else if (n == max_jint)
1550     return &quot;max&quot;;
1551   else if (n &gt; max_jint - 10000)
1552     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1553   else
1554     sprintf(buf, INT32_FORMAT, n);
1555   return buf;
1556 }
1557 
1558 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1559   char buf[40], buf2[40];
1560   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1561     st-&gt;print(&quot;int&quot;);
1562   else if (is_con())
1563     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1564   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1565     st-&gt;print(&quot;bool&quot;);
1566   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1567     st-&gt;print(&quot;byte&quot;);
1568   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1569     st-&gt;print(&quot;char&quot;);
1570   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1571     st-&gt;print(&quot;short&quot;);
1572   else if (_hi == max_jint)
1573     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1574   else if (_lo == min_jint)
1575     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1576   else
1577     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1578 
1579   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1580     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1581 }
1582 #endif
1583 
1584 //------------------------------singleton--------------------------------------
1585 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1586 // constants.
1587 bool TypeInt::singleton(void) const {
1588   return _lo &gt;= _hi;
1589 }
1590 
1591 bool TypeInt::empty(void) const {
1592   return _lo &gt; _hi;
1593 }
1594 
1595 //=============================================================================
1596 // Convenience common pre-built types.
1597 const TypeLong *TypeLong::MINUS_1;// -1
1598 const TypeLong *TypeLong::ZERO; // 0
1599 const TypeLong *TypeLong::ONE;  // 1
1600 const TypeLong *TypeLong::POS;  // &gt;=0
1601 const TypeLong *TypeLong::LONG; // 64-bit integers
1602 const TypeLong *TypeLong::INT;  // 32-bit subrange
1603 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1604 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1605 
1606 //------------------------------TypeLong---------------------------------------
1607 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1608 }
1609 
1610 //------------------------------make-------------------------------------------
1611 const TypeLong *TypeLong::make( jlong lo ) {
1612   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1613 }
1614 
1615 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1616   // Certain normalizations keep us sane when comparing types.
1617   // The &#39;SMALLINT&#39; covers constants.
1618   if (lo &lt;= hi) {
1619     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1620     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1621   } else {
1622     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1623     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1624   }
1625   return w;
1626 }
1627 
1628 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1629   w = normalize_long_widen(lo, hi, w);
1630   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1631 }
1632 
1633 
1634 //------------------------------meet-------------------------------------------
1635 // Compute the MEET of two types.  It returns a new Type representation object
1636 // with reference count equal to the number of Types pointing at it.
1637 // Caller should wrap a Types around it.
1638 const Type *TypeLong::xmeet( const Type *t ) const {
1639   // Perform a fast test for common case; meeting the same types together.
1640   if( this == t ) return this;  // Meeting same type?
1641 
1642   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1643   switch (t-&gt;base()) {          // Switch on original type
1644   case AnyPtr:                  // Mixing with oops happens when javac
1645   case RawPtr:                  // reuses local variables
1646   case OopPtr:
1647   case InstPtr:
1648   case AryPtr:
1649   case MetadataPtr:
1650   case KlassPtr:
1651   case NarrowOop:
1652   case NarrowKlass:
1653   case Int:
1654   case FloatTop:
1655   case FloatCon:
1656   case FloatBot:
1657   case DoubleTop:
1658   case DoubleCon:
1659   case DoubleBot:
1660   case Bottom:                  // Ye Olde Default
1661     return Type::BOTTOM;
1662   default:                      // All else is a mistake
1663     typerr(t);
1664   case Top:                     // No change
1665     return this;
1666   case Long:                    // Long vs Long?
1667     break;
1668   }
1669 
1670   // Expand covered set
1671   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1672   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1673 }
1674 
1675 //------------------------------xdual------------------------------------------
1676 // Dual: reverse hi &amp; lo; flip widen
1677 const Type *TypeLong::xdual() const {
1678   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1679   return new TypeLong(_hi,_lo,w);
1680 }
1681 
1682 //------------------------------widen------------------------------------------
1683 // Only happens for optimistic top-down optimizations.
1684 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1685   // Coming from TOP or such; no widening
1686   if( old-&gt;base() != Long ) return this;
1687   const TypeLong *ot = old-&gt;is_long();
1688 
1689   // If new guy is equal to old guy, no widening
1690   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1691     return old;
1692 
1693   // If new guy contains old, then we widened
1694   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1695     // New contains old
1696     // If new guy is already wider than old, no widening
1697     if( _widen &gt; ot-&gt;_widen ) return this;
1698     // If old guy was a constant, do not bother
1699     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1700     // Now widen new guy.
1701     // Check for widening too far
1702     if (_widen == WidenMax) {
1703       jlong max = max_jlong;
1704       jlong min = min_jlong;
1705       if (limit-&gt;isa_long()) {
1706         max = limit-&gt;is_long()-&gt;_hi;
1707         min = limit-&gt;is_long()-&gt;_lo;
1708       }
1709       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1710         // If neither endpoint is extremal yet, push out the endpoint
1711         // which is closer to its respective limit.
1712         if (_lo &gt;= 0 ||                 // easy common case
1713             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1714           // Try to widen to an unsigned range type of 32/63 bits:
1715           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1716             return make(_lo, max_juint, WidenMax);
1717           else
1718             return make(_lo, max, WidenMax);
1719         } else {
1720           return make(min, _hi, WidenMax);
1721         }
1722       }
1723       return TypeLong::LONG;
1724     }
1725     // Returned widened new guy
1726     return make(_lo,_hi,_widen+1);
1727   }
1728 
1729   // If old guy contains new, then we probably widened too far &amp; dropped to
1730   // bottom.  Return the wider fellow.
1731   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1732     return old;
1733 
1734   //  fatal(&quot;Long value range is not subset&quot;);
1735   // return this;
1736   return TypeLong::LONG;
1737 }
1738 
1739 //------------------------------narrow----------------------------------------
1740 // Only happens for pessimistic optimizations.
1741 const Type *TypeLong::narrow( const Type *old ) const {
1742   if (_lo &gt;= _hi)  return this;   // already narrow enough
1743   if (old == NULL)  return this;
1744   const TypeLong* ot = old-&gt;isa_long();
1745   if (ot == NULL)  return this;
1746   jlong olo = ot-&gt;_lo;
1747   jlong ohi = ot-&gt;_hi;
1748 
1749   // If new guy is equal to old guy, no narrowing
1750   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1751 
1752   // If old guy was maximum range, allow the narrowing
1753   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1754 
1755   if (_lo &lt; olo || _hi &gt; ohi)
1756     return this;                // doesn&#39;t narrow; pretty wierd
1757 
1758   // The new type narrows the old type, so look for a &quot;death march&quot;.
1759   // See comments on PhaseTransform::saturate.
1760   julong nrange = _hi - _lo;
1761   julong orange = ohi - olo;
1762   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1763     // Use the new type only if the range shrinks a lot.
1764     // We do not want the optimizer computing 2^31 point by point.
1765     return old;
1766   }
1767 
1768   return this;
1769 }
1770 
1771 //-----------------------------filter------------------------------------------
1772 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1773   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1774   if (ft == NULL || ft-&gt;empty())
1775     return Type::TOP;           // Canonical empty value
1776   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1777     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1778     // The widen bits must be allowed to run freely through the graph.
1779     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1780   }
1781   return ft;
1782 }
1783 
1784 //------------------------------eq---------------------------------------------
1785 // Structural equality check for Type representations
1786 bool TypeLong::eq( const Type *t ) const {
1787   const TypeLong *r = t-&gt;is_long(); // Handy access
1788   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1789 }
1790 
1791 //------------------------------hash-------------------------------------------
1792 // Type-specific hashing function.
1793 int TypeLong::hash(void) const {
1794   return (int)(_lo+_hi+_widen+(int)Type::Long);
1795 }
1796 
1797 //------------------------------is_finite--------------------------------------
1798 // Has a finite value
1799 bool TypeLong::is_finite() const {
1800   return true;
1801 }
1802 
1803 //------------------------------dump2------------------------------------------
1804 // Dump TypeLong
1805 #ifndef PRODUCT
1806 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1807   if (n &gt; x) {
1808     if (n &gt;= x + 10000)  return NULL;
1809     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1810   } else if (n &lt; x) {
1811     if (n &lt;= x - 10000)  return NULL;
1812     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1813   } else {
1814     return xname;
1815   }
1816   return buf;
1817 }
1818 
1819 static const char* longname(char* buf, jlong n) {
1820   const char* str;
1821   if (n == min_jlong)
1822     return &quot;min&quot;;
1823   else if (n &lt; min_jlong + 10000)
1824     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1825   else if (n == max_jlong)
1826     return &quot;max&quot;;
1827   else if (n &gt; max_jlong - 10000)
1828     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1829   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1830     return str;
1831   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1832     return str;
1833   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1834     return str;
1835   else
1836     sprintf(buf, JLONG_FORMAT, n);
1837   return buf;
1838 }
1839 
1840 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1841   char buf[80], buf2[80];
1842   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1843     st-&gt;print(&quot;long&quot;);
1844   else if (is_con())
1845     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1846   else if (_hi == max_jlong)
1847     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1848   else if (_lo == min_jlong)
1849     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1850   else
1851     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1852 
1853   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1854     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1855 }
1856 #endif
1857 
1858 //------------------------------singleton--------------------------------------
1859 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1860 // constants
1861 bool TypeLong::singleton(void) const {
1862   return _lo &gt;= _hi;
1863 }
1864 
1865 bool TypeLong::empty(void) const {
1866   return _lo &gt; _hi;
1867 }
1868 
1869 //=============================================================================
1870 // Convenience common pre-built types.
1871 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1872 const TypeTuple *TypeTuple::IFFALSE;
1873 const TypeTuple *TypeTuple::IFTRUE;
1874 const TypeTuple *TypeTuple::IFNEITHER;
1875 const TypeTuple *TypeTuple::LOOPBODY;
1876 const TypeTuple *TypeTuple::MEMBAR;
1877 const TypeTuple *TypeTuple::STORECONDITIONAL;
1878 const TypeTuple *TypeTuple::START_I2C;
1879 const TypeTuple *TypeTuple::INT_PAIR;
1880 const TypeTuple *TypeTuple::LONG_PAIR;
1881 const TypeTuple *TypeTuple::INT_CC_PAIR;
1882 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1883 
1884 
1885 //------------------------------make-------------------------------------------
1886 // Make a TypeTuple from the range of a method signature
1887 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {
1888   ciType* return_type = sig-&gt;return_type();
1889   uint arg_cnt = return_type-&gt;size();
1890   const Type **field_array = fields(arg_cnt);
1891   switch (return_type-&gt;basic_type()) {
1892   case T_LONG:
1893     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1894     field_array[TypeFunc::Parms+1] = Type::HALF;
1895     break;
1896   case T_DOUBLE:
1897     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1898     field_array[TypeFunc::Parms+1] = Type::HALF;
1899     break;
1900   case T_OBJECT:
1901   case T_ARRAY:
1902   case T_BOOLEAN:
1903   case T_CHAR:
1904   case T_FLOAT:
1905   case T_BYTE:
1906   case T_SHORT:
1907   case T_INT:
1908     field_array[TypeFunc::Parms] = get_const_type(return_type);
1909     break;
1910   case T_VOID:
1911     break;
1912   default:
1913     ShouldNotReachHere();
1914   }
1915   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1916 }
1917 
1918 // Make a TypeTuple from the domain of a method signature
1919 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {
1920   uint arg_cnt = sig-&gt;size();
1921 
1922   uint pos = TypeFunc::Parms;
1923   const Type **field_array;
1924   if (recv != NULL) {
1925     arg_cnt++;
1926     field_array = fields(arg_cnt);
1927     // Use get_const_type here because it respects UseUniqueSubclasses:
1928     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
1929   } else {
1930     field_array = fields(arg_cnt);
1931   }
1932 
1933   int i = 0;
1934   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1935     ciType* type = sig-&gt;type_at(i);
1936 
1937     switch (type-&gt;basic_type()) {
1938     case T_LONG:
1939       field_array[pos++] = TypeLong::LONG;
1940       field_array[pos++] = Type::HALF;
1941       break;
1942     case T_DOUBLE:
1943       field_array[pos++] = Type::DOUBLE;
1944       field_array[pos++] = Type::HALF;
1945       break;
1946     case T_OBJECT:
1947     case T_ARRAY:
1948     case T_FLOAT:
1949     case T_INT:
1950       field_array[pos++] = get_const_type(type);
1951       break;
1952     case T_BOOLEAN:
1953     case T_CHAR:
1954     case T_BYTE:
1955     case T_SHORT:
1956       field_array[pos++] = TypeInt::INT;
1957       break;
1958     default:
1959       ShouldNotReachHere();
1960     }
1961     i++;
1962   }
1963 
1964   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1965 }
1966 
1967 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1968   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1969 }
1970 
1971 const TypeTuple *TypeTuple::make_func( uint arg_cnt, const Type **arg_fields ) {
1972   const Type** field_array = fields(arg_cnt);
1973   for (uint i = 0; i &lt; arg_cnt; i++) {
1974     field_array[i + TypeFunc::Parms] = arg_fields[i];
1975   }
1976   return make(arg_cnt + TypeFunc::Parms, field_array);
1977 }
1978 
1979 //------------------------------fields-----------------------------------------
1980 // Subroutine call type with space allocated for argument types
1981 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1982 const Type **TypeTuple::fields( uint arg_cnt ) {
1983   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1984   flds[TypeFunc::Control  ] = Type::CONTROL;
1985   flds[TypeFunc::I_O      ] = Type::ABIO;
1986   flds[TypeFunc::Memory   ] = Type::MEMORY;
1987   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1988   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1989 
1990   return flds;
1991 }
1992 
1993 //------------------------------meet-------------------------------------------
1994 // Compute the MEET of two types.  It returns a new Type object.
1995 const Type *TypeTuple::xmeet( const Type *t ) const {
1996   // Perform a fast test for common case; meeting the same types together.
1997   if( this == t ) return this;  // Meeting same type-rep?
1998 
1999   // Current &quot;this-&gt;_base&quot; is Tuple
2000   switch (t-&gt;base()) {          // switch on original type
2001 
2002   case Bottom:                  // Ye Olde Default
2003     return t;
2004 
2005   default:                      // All else is a mistake
2006     typerr(t);
2007 
2008   case Tuple: {                 // Meeting 2 signatures?
2009     const TypeTuple *x = t-&gt;is_tuple();
2010     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
2011     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2012     for( uint i=0; i&lt;_cnt; i++ )
2013       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
2014     return TypeTuple::make(_cnt,fields);
2015   }
2016   case Top:
2017     break;
2018   }
2019   return this;                  // Return the double constant
2020 }
2021 
2022 //------------------------------xdual------------------------------------------
2023 // Dual: compute field-by-field dual
2024 const Type *TypeTuple::xdual() const {
2025   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2026   for( uint i=0; i&lt;_cnt; i++ )
2027     fields[i] = _fields[i]-&gt;dual();
2028   return new TypeTuple(_cnt,fields);
2029 }
2030 
2031 //------------------------------eq---------------------------------------------
2032 // Structural equality check for Type representations
2033 bool TypeTuple::eq( const Type *t ) const {
2034   const TypeTuple *s = (const TypeTuple *)t;
2035   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2036   for (uint i = 0; i &lt; _cnt; i++)
2037     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2038       return false;             // Missed
2039   return true;
2040 }
2041 
2042 //------------------------------hash-------------------------------------------
2043 // Type-specific hashing function.
2044 int TypeTuple::hash(void) const {
2045   intptr_t sum = _cnt;
2046   for( uint i=0; i&lt;_cnt; i++ )
2047     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2048   return sum;
2049 }
2050 
2051 //------------------------------dump2------------------------------------------
2052 // Dump signature Type
2053 #ifndef PRODUCT
2054 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2055   st-&gt;print(&quot;{&quot;);
2056   if( !depth || d[this] ) {     // Check for recursive print
2057     st-&gt;print(&quot;...}&quot;);
2058     return;
2059   }
2060   d.Insert((void*)this, (void*)this);   // Stop recursion
2061   if( _cnt ) {
2062     uint i;
2063     for( i=0; i&lt;_cnt-1; i++ ) {
2064       st-&gt;print(&quot;%d:&quot;, i);
2065       _fields[i]-&gt;dump2(d, depth-1, st);
2066       st-&gt;print(&quot;, &quot;);
2067     }
2068     st-&gt;print(&quot;%d:&quot;, i);
2069     _fields[i]-&gt;dump2(d, depth-1, st);
2070   }
2071   st-&gt;print(&quot;}&quot;);
2072 }
2073 #endif
2074 
2075 //------------------------------singleton--------------------------------------
2076 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2077 // constants (Ldi nodes).  Singletons are integer, float or double constants
2078 // or a single symbol.
2079 bool TypeTuple::singleton(void) const {
2080   return false;                 // Never a singleton
2081 }
2082 
2083 bool TypeTuple::empty(void) const {
2084   for( uint i=0; i&lt;_cnt; i++ ) {
2085     if (_fields[i]-&gt;empty())  return true;
2086   }
2087   return false;
2088 }
2089 
2090 //=============================================================================
2091 // Convenience common pre-built types.
2092 
2093 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2094   // Certain normalizations keep us sane when comparing types.
2095   // We do not want arrayOop variables to differ only by the wideness
2096   // of their index types.  Pick minimum wideness, since that is the
2097   // forced wideness of small ranges anyway.
2098   if (size-&gt;_widen != Type::WidenMin)
2099     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2100   else
2101     return size;
2102 }
2103 
2104 //------------------------------make-------------------------------------------
2105 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {
2106   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2107     elem = elem-&gt;make_narrowoop();
2108   }
2109   size = normalize_array_size(size);
2110   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();
2111 }
2112 
2113 //------------------------------meet-------------------------------------------
2114 // Compute the MEET of two types.  It returns a new Type object.
2115 const Type *TypeAry::xmeet( const Type *t ) const {
2116   // Perform a fast test for common case; meeting the same types together.
2117   if( this == t ) return this;  // Meeting same type-rep?
2118 
2119   // Current &quot;this-&gt;_base&quot; is Ary
2120   switch (t-&gt;base()) {          // switch on original type
2121 
2122   case Bottom:                  // Ye Olde Default
2123     return t;
2124 
2125   default:                      // All else is a mistake
2126     typerr(t);
2127 
2128   case Array: {                 // Meeting 2 arrays?
2129     const TypeAry *a = t-&gt;is_ary();
2130     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2131                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2132                          _stable &amp;&amp; a-&gt;_stable);
2133   }
2134   case Top:
2135     break;
2136   }
2137   return this;                  // Return the double constant
2138 }
2139 
2140 //------------------------------xdual------------------------------------------
2141 // Dual: compute field-by-field dual
2142 const Type *TypeAry::xdual() const {
2143   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2144   size_dual = normalize_array_size(size_dual);
2145   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2146 }
2147 
2148 //------------------------------eq---------------------------------------------
2149 // Structural equality check for Type representations
2150 bool TypeAry::eq( const Type *t ) const {
2151   const TypeAry *a = (const TypeAry*)t;
2152   return _elem == a-&gt;_elem &amp;&amp;
2153     _stable == a-&gt;_stable &amp;&amp;
2154     _size == a-&gt;_size;
2155 }
2156 
2157 //------------------------------hash-------------------------------------------
2158 // Type-specific hashing function.
2159 int TypeAry::hash(void) const {
2160   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2161 }
2162 
2163 /**
2164  * Return same type without a speculative part in the element
2165  */
2166 const Type* TypeAry::remove_speculative() const {
2167   return make(_elem-&gt;remove_speculative(), _size, _stable);
2168 }
2169 
2170 /**
2171  * Return same type with cleaned up speculative part of element
2172  */
2173 const Type* TypeAry::cleanup_speculative() const {
2174   return make(_elem-&gt;cleanup_speculative(), _size, _stable);
2175 }
2176 
2177 /**
2178  * Return same type but with a different inline depth (used for speculation)
2179  *
2180  * @param depth  depth to meet with
2181  */
2182 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2183   if (!UseInlineDepthForSpeculativeTypes) {
2184     return this;
2185   }
2186   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2187 }
2188 
2189 //----------------------interface_vs_oop---------------------------------------
2190 #ifdef ASSERT
2191 bool TypeAry::interface_vs_oop(const Type *t) const {
2192   const TypeAry* t_ary = t-&gt;is_ary();
2193   if (t_ary) {
2194     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2195     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2196     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2197       return this_ptr-&gt;interface_vs_oop(t_ptr);
2198     }
2199   }
2200   return false;
2201 }
2202 #endif
2203 
2204 //------------------------------dump2------------------------------------------
2205 #ifndef PRODUCT
2206 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2207   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2208   _elem-&gt;dump2(d, depth, st);
2209   st-&gt;print(&quot;[&quot;);
2210   _size-&gt;dump2(d, depth, st);
2211   st-&gt;print(&quot;]&quot;);
2212 }
2213 #endif
2214 
2215 //------------------------------singleton--------------------------------------
2216 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2217 // constants (Ldi nodes).  Singletons are integer, float or double constants
2218 // or a single symbol.
2219 bool TypeAry::singleton(void) const {
2220   return false;                 // Never a singleton
2221 }
2222 
2223 bool TypeAry::empty(void) const {
2224   return _elem-&gt;empty() || _size-&gt;empty();
2225 }
2226 
2227 //--------------------------ary_must_be_exact----------------------------------
2228 bool TypeAry::ary_must_be_exact() const {
2229   if (!UseExactTypes)       return false;
2230   // This logic looks at the element type of an array, and returns true
2231   // if the element type is either a primitive or a final instance class.
2232   // In such cases, an array built on this ary must have no subclasses.
2233   if (_elem == BOTTOM)      return false;  // general array not exact
2234   if (_elem == TOP   )      return false;  // inverted general array not exact
2235   const TypeOopPtr*  toop = NULL;
2236   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2237     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2238   } else {
2239     toop = _elem-&gt;isa_oopptr();
2240   }
2241   if (!toop)                return true;   // a primitive type, like int
2242   ciKlass* tklass = toop-&gt;klass();
2243   if (tklass == NULL)       return false;  // unloaded class
2244   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2245   const TypeInstPtr* tinst;
2246   if (_elem-&gt;isa_narrowoop())
2247     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2248   else
2249     tinst = _elem-&gt;isa_instptr();
2250   if (tinst)
2251     return tklass-&gt;as_instance_klass()-&gt;is_final();
2252   const TypeAryPtr*  tap;
2253   if (_elem-&gt;isa_narrowoop())
2254     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2255   else
2256     tap = _elem-&gt;isa_aryptr();
2257   if (tap)
2258     return tap-&gt;ary()-&gt;ary_must_be_exact();
2259   return false;
2260 }
2261 
2262 //==============================TypeVect=======================================
2263 // Convenience common pre-built types.
2264 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2265 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2266 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2267 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2268 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2269 
2270 //------------------------------make-------------------------------------------
2271 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2272   BasicType elem_bt = elem-&gt;array_element_basic_type();
2273   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2274   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2275   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2276   int size = length * type2aelembytes(elem_bt);
2277   switch (Matcher::vector_ideal_reg(size)) {
2278   case Op_VecS:
2279     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2280   case Op_RegL:
2281   case Op_VecD:
2282   case Op_RegD:
2283     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2284   case Op_VecX:
2285     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2286   case Op_VecY:
2287     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2288   case Op_VecZ:
2289     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2290   }
2291  ShouldNotReachHere();
2292   return NULL;
2293 }
2294 
2295 //------------------------------meet-------------------------------------------
2296 // Compute the MEET of two types.  It returns a new Type object.
2297 const Type *TypeVect::xmeet( const Type *t ) const {
2298   // Perform a fast test for common case; meeting the same types together.
2299   if( this == t ) return this;  // Meeting same type-rep?
2300 
2301   // Current &quot;this-&gt;_base&quot; is Vector
2302   switch (t-&gt;base()) {          // switch on original type
2303 
2304   case Bottom:                  // Ye Olde Default
2305     return t;
2306 
2307   default:                      // All else is a mistake
2308     typerr(t);
2309 
2310   case VectorS:
2311   case VectorD:
2312   case VectorX:
2313   case VectorY:
2314   case VectorZ: {                // Meeting 2 vectors?
2315     const TypeVect* v = t-&gt;is_vect();
2316     assert(  base() == v-&gt;base(), &quot;&quot;);
2317     assert(length() == v-&gt;length(), &quot;&quot;);
2318     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2319     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2320   }
2321   case Top:
2322     break;
2323   }
2324   return this;
2325 }
2326 
2327 //------------------------------xdual------------------------------------------
2328 // Dual: compute field-by-field dual
2329 const Type *TypeVect::xdual() const {
2330   return new TypeVect(base(), _elem-&gt;dual(), _length);
2331 }
2332 
2333 //------------------------------eq---------------------------------------------
2334 // Structural equality check for Type representations
2335 bool TypeVect::eq(const Type *t) const {
2336   const TypeVect *v = t-&gt;is_vect();
2337   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2338 }
2339 
2340 //------------------------------hash-------------------------------------------
2341 // Type-specific hashing function.
2342 int TypeVect::hash(void) const {
2343   return (intptr_t)_elem + (intptr_t)_length;
2344 }
2345 
2346 //------------------------------singleton--------------------------------------
2347 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2348 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2349 // constant value (when vector is created with Replicate code).
2350 bool TypeVect::singleton(void) const {
2351 // There is no Con node for vectors yet.
2352 //  return _elem-&gt;singleton();
2353   return false;
2354 }
2355 
2356 bool TypeVect::empty(void) const {
2357   return _elem-&gt;empty();
2358 }
2359 
2360 //------------------------------dump2------------------------------------------
2361 #ifndef PRODUCT
2362 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2363   switch (base()) {
2364   case VectorS:
2365     st-&gt;print(&quot;vectors[&quot;); break;
2366   case VectorD:
2367     st-&gt;print(&quot;vectord[&quot;); break;
2368   case VectorX:
2369     st-&gt;print(&quot;vectorx[&quot;); break;
2370   case VectorY:
2371     st-&gt;print(&quot;vectory[&quot;); break;
2372   case VectorZ:
2373     st-&gt;print(&quot;vectorz[&quot;); break;
2374   default:
2375     ShouldNotReachHere();
2376   }
2377   st-&gt;print(&quot;%d]:{&quot;, _length);
2378   _elem-&gt;dump2(d, depth, st);
2379   st-&gt;print(&quot;}&quot;);
2380 }
2381 #endif
2382 
2383 
2384 //=============================================================================
2385 // Convenience common pre-built types.
2386 const TypePtr *TypePtr::NULL_PTR;
2387 const TypePtr *TypePtr::NOTNULL;
2388 const TypePtr *TypePtr::BOTTOM;
2389 
2390 //------------------------------meet-------------------------------------------
2391 // Meet over the PTR enum
2392 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2393   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2394   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2395   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2396   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2397   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2398   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2399   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2400 };
2401 
2402 //------------------------------make-------------------------------------------
2403 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {
2404   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2405 }
2406 
2407 //------------------------------cast_to_ptr_type-------------------------------
2408 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2409   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2410   if( ptr == _ptr ) return this;
2411   return make(_base, ptr, _offset, _speculative, _inline_depth);
2412 }
2413 
2414 //------------------------------get_con----------------------------------------
2415 intptr_t TypePtr::get_con() const {
2416   assert( _ptr == Null, &quot;&quot; );
2417   return _offset;
2418 }
2419 
2420 //------------------------------meet-------------------------------------------
2421 // Compute the MEET of two types.  It returns a new Type object.
2422 const Type *TypePtr::xmeet(const Type *t) const {
2423   const Type* res = xmeet_helper(t);
2424   if (res-&gt;isa_ptr() == NULL) {
2425     return res;
2426   }
2427 
2428   const TypePtr* res_ptr = res-&gt;is_ptr();
2429   if (res_ptr-&gt;speculative() != NULL) {
2430     // type-&gt;speculative() == NULL means that speculation is no better
2431     // than type, i.e. type-&gt;speculative() == type. So there are 2
2432     // ways to represent the fact that we have no useful speculative
2433     // data and we should use a single one to be able to test for
2434     // equality between types. Check whether type-&gt;speculative() ==
2435     // type and set speculative to NULL if it is the case.
2436     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2437       return res_ptr-&gt;remove_speculative();
2438     }
2439   }
2440 
2441   return res;
2442 }
2443 
2444 const Type *TypePtr::xmeet_helper(const Type *t) const {
2445   // Perform a fast test for common case; meeting the same types together.
2446   if( this == t ) return this;  // Meeting same type-rep?
2447 
2448   // Current &quot;this-&gt;_base&quot; is AnyPtr
2449   switch (t-&gt;base()) {          // switch on original type
2450   case Int:                     // Mixing ints &amp; oops happens when javac
2451   case Long:                    // reuses local variables
2452   case FloatTop:
2453   case FloatCon:
2454   case FloatBot:
2455   case DoubleTop:
2456   case DoubleCon:
2457   case DoubleBot:
2458   case NarrowOop:
2459   case NarrowKlass:
2460   case Bottom:                  // Ye Olde Default
2461     return Type::BOTTOM;
2462   case Top:
2463     return this;
2464 
2465   case AnyPtr: {                // Meeting to AnyPtrs
2466     const TypePtr *tp = t-&gt;is_ptr();
2467     const TypePtr* speculative = xmeet_speculative(tp);
2468     int depth = meet_inline_depth(tp-&gt;inline_depth());
2469     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2470   }
2471   case RawPtr:                  // For these, flip the call around to cut down
2472   case OopPtr:
2473   case InstPtr:                 // on the cases I have to handle.
2474   case AryPtr:
2475   case MetadataPtr:
2476   case KlassPtr:
2477     return t-&gt;xmeet(this);      // Call in reverse direction
2478   default:                      // All else is a mistake
2479     typerr(t);
2480 
2481   }
2482   return this;
2483 }
2484 
2485 //------------------------------meet_offset------------------------------------
2486 int TypePtr::meet_offset( int offset ) const {
2487   // Either is &#39;TOP&#39; offset?  Return the other offset!
2488   if( _offset == OffsetTop ) return offset;
2489   if( offset == OffsetTop ) return _offset;
2490   // If either is different, return &#39;BOTTOM&#39; offset
2491   if( _offset != offset ) return OffsetBot;
2492   return _offset;
2493 }
2494 
2495 //------------------------------dual_offset------------------------------------
2496 int TypePtr::dual_offset( ) const {
2497   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
2498   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
2499   return _offset;               // Map everything else into self
2500 }
2501 
2502 //------------------------------xdual------------------------------------------
2503 // Dual: compute field-by-field dual
2504 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2505   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2506 };
2507 const Type *TypePtr::xdual() const {
2508   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2509 }
2510 
2511 //------------------------------xadd_offset------------------------------------
2512 int TypePtr::xadd_offset( intptr_t offset ) const {
2513   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
2514   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;
2515   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
2516   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;
2517   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
2518   offset += (intptr_t)_offset;
2519   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;
2520 
2521   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
2522   // It is possible to construct a negative offset during PhaseCCP
2523 
2524   return (int)offset;        // Sum valid offsets
2525 }
2526 
2527 //------------------------------add_offset-------------------------------------
2528 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2529   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2530 }
2531 
2532 //------------------------------eq---------------------------------------------
2533 // Structural equality check for Type representations
2534 bool TypePtr::eq( const Type *t ) const {
2535   const TypePtr *a = (const TypePtr*)t;
2536   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2537 }
2538 
2539 //------------------------------hash-------------------------------------------
2540 // Type-specific hashing function.
2541 int TypePtr::hash(void) const {
2542   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));
2543 ;
2544 }
2545 
2546 /**
2547  * Return same type without a speculative part
2548  */
2549 const Type* TypePtr::remove_speculative() const {
2550   if (_speculative == NULL) {
2551     return this;
2552   }
2553   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2554   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2555 }
2556 
2557 /**
2558  * Return same type but drop speculative part if we know we won&#39;t use
2559  * it
2560  */
2561 const Type* TypePtr::cleanup_speculative() const {
2562   if (speculative() == NULL) {
2563     return this;
2564   }
2565   const Type* no_spec = remove_speculative();
2566   // If this is NULL_PTR then we don&#39;t need the speculative type
2567   // (with_inline_depth in case the current type inline depth is
2568   // InlineDepthTop)
2569   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2570     return no_spec;
2571   }
2572   if (above_centerline(speculative()-&gt;ptr())) {
2573     return no_spec;
2574   }
2575   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2576   // If the speculative may be null and is an inexact klass then it
2577   // doesn&#39;t help
2578   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2579       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2580     return no_spec;
2581   }
2582   return this;
2583 }
2584 
2585 /**
2586  * dual of the speculative part of the type
2587  */
2588 const TypePtr* TypePtr::dual_speculative() const {
2589   if (_speculative == NULL) {
2590     return NULL;
2591   }
2592   return _speculative-&gt;dual()-&gt;is_ptr();
2593 }
2594 
2595 /**
2596  * meet of the speculative parts of 2 types
2597  *
2598  * @param other  type to meet with
2599  */
2600 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2601   bool this_has_spec = (_speculative != NULL);
2602   bool other_has_spec = (other-&gt;speculative() != NULL);
2603 
2604   if (!this_has_spec &amp;&amp; !other_has_spec) {
2605     return NULL;
2606   }
2607 
2608   // If we are at a point where control flow meets and one branch has
2609   // a speculative type and the other has not, we meet the speculative
2610   // type of one branch with the actual type of the other. If the
2611   // actual type is exact and the speculative is as well, then the
2612   // result is a speculative type which is exact and we can continue
2613   // speculation further.
2614   const TypePtr* this_spec = _speculative;
2615   const TypePtr* other_spec = other-&gt;speculative();
2616 
2617   if (!this_has_spec) {
2618     this_spec = this;
2619   }
2620 
2621   if (!other_has_spec) {
2622     other_spec = other;
2623   }
2624 
2625   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2626 }
2627 
2628 /**
2629  * dual of the inline depth for this type (used for speculation)
2630  */
2631 int TypePtr::dual_inline_depth() const {
2632   return -inline_depth();
2633 }
2634 
2635 /**
2636  * meet of 2 inline depths (used for speculation)
2637  *
2638  * @param depth  depth to meet with
2639  */
2640 int TypePtr::meet_inline_depth(int depth) const {
2641   return MAX2(inline_depth(), depth);
2642 }
2643 
2644 /**
2645  * Are the speculative parts of 2 types equal?
2646  *
2647  * @param other  type to compare this one to
2648  */
2649 bool TypePtr::eq_speculative(const TypePtr* other) const {
2650   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2651     return _speculative == other-&gt;speculative();
2652   }
2653 
2654   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2655     return false;
2656   }
2657 
2658   return _speculative-&gt;eq(other-&gt;speculative());
2659 }
2660 
2661 /**
2662  * Hash of the speculative part of the type
2663  */
2664 int TypePtr::hash_speculative() const {
2665   if (_speculative == NULL) {
2666     return 0;
2667   }
2668 
2669   return _speculative-&gt;hash();
2670 }
2671 
2672 /**
2673  * add offset to the speculative part of the type
2674  *
2675  * @param offset  offset to add
2676  */
2677 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2678   if (_speculative == NULL) {
2679     return NULL;
2680   }
2681   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2682 }
2683 
2684 /**
2685  * return exact klass from the speculative type if there&#39;s one
2686  */
2687 ciKlass* TypePtr::speculative_type() const {
2688   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2689     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2690     if (speculative-&gt;klass_is_exact()) {
2691       return speculative-&gt;klass();
2692     }
2693   }
2694   return NULL;
2695 }
2696 
2697 /**
2698  * return true if speculative type may be null
2699  */
2700 bool TypePtr::speculative_maybe_null() const {
2701   if (_speculative != NULL) {
2702     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2703     return speculative-&gt;maybe_null();
2704   }
2705   return true;
2706 }
2707 
2708 bool TypePtr::speculative_always_null() const {
2709   if (_speculative != NULL) {
2710     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2711     return speculative == TypePtr::NULL_PTR;
2712   }
2713   return false;
2714 }
2715 
2716 /**
2717  * Same as TypePtr::speculative_type() but return the klass only if
2718  * the speculative tells us is not null
2719  */
2720 ciKlass* TypePtr::speculative_type_not_null() const {
2721   if (speculative_maybe_null()) {
2722     return NULL;
2723   }
2724   return speculative_type();
2725 }
2726 
2727 /**
2728  * Check whether new profiling would improve speculative type
2729  *
2730  * @param   exact_kls    class from profiling
2731  * @param   inline_depth inlining depth of profile point
2732  *
2733  * @return  true if type profile is valuable
2734  */
2735 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2736   // no profiling?
2737   if (exact_kls == NULL) {
2738     return false;
2739   }
2740   if (speculative() == TypePtr::NULL_PTR) {
2741     return false;
2742   }
2743   // no speculative type or non exact speculative type?
2744   if (speculative_type() == NULL) {
2745     return true;
2746   }
2747   // If the node already has an exact speculative type keep it,
2748   // unless it was provided by profiling that is at a deeper
2749   // inlining level. Profiling at a higher inlining depth is
2750   // expected to be less accurate.
2751   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2752     return false;
2753   }
2754   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2755   return inline_depth &lt; _speculative-&gt;inline_depth();
2756 }
2757 
2758 /**
2759  * Check whether new profiling would improve ptr (= tells us it is non
2760  * null)
2761  *
2762  * @param   ptr_kind always null or not null?
2763  *
2764  * @return  true if ptr profile is valuable
2765  */
2766 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
2767   // profiling doesn&#39;t tell us anything useful
2768   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
2769     return false;
2770   }
2771   // We already know this is not null
2772   if (!this-&gt;maybe_null()) {
2773     return false;
2774   }
2775   // We already know the speculative type cannot be null
2776   if (!speculative_maybe_null()) {
2777     return false;
2778   }
2779   // We already know this is always null
2780   if (this == TypePtr::NULL_PTR) {
2781     return false;
2782   }
2783   // We already know the speculative type is always null
2784   if (speculative_always_null()) {
2785     return false;
2786   }
2787   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2788     return false;
2789   }
2790   return true;
2791 }
2792 
2793 //------------------------------dump2------------------------------------------
2794 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2795   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2796 };
2797 
2798 #ifndef PRODUCT
2799 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2800   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2801   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
2802   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);
2803   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);
2804   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);
2805   dump_inline_depth(st);
2806   dump_speculative(st);
2807 }
2808 
2809 /**
2810  *dump the speculative part of the type
2811  */
2812 void TypePtr::dump_speculative(outputStream *st) const {
2813   if (_speculative != NULL) {
2814     st-&gt;print(&quot; (speculative=&quot;);
2815     _speculative-&gt;dump_on(st);
2816     st-&gt;print(&quot;)&quot;);
2817   }
2818 }
2819 
2820 /**
2821  *dump the inline depth of the type
2822  */
2823 void TypePtr::dump_inline_depth(outputStream *st) const {
2824   if (_inline_depth != InlineDepthBottom) {
2825     if (_inline_depth == InlineDepthTop) {
2826       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2827     } else {
2828       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2829     }
2830   }
2831 }
2832 #endif
2833 
2834 //------------------------------singleton--------------------------------------
2835 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2836 // constants
2837 bool TypePtr::singleton(void) const {
2838   // TopPTR, Null, AnyNull, Constant are all singletons
2839   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);
2840 }
2841 
2842 bool TypePtr::empty(void) const {
2843   return (_offset == OffsetTop) || above_centerline(_ptr);
2844 }
2845 
2846 //=============================================================================
2847 // Convenience common pre-built types.
2848 const TypeRawPtr *TypeRawPtr::BOTTOM;
2849 const TypeRawPtr *TypeRawPtr::NOTNULL;
2850 
2851 //------------------------------make-------------------------------------------
2852 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2853   assert( ptr != Constant, &quot;what is the constant?&quot; );
2854   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2855   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2856 }
2857 
2858 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2859   assert( bits, &quot;Use TypePtr for NULL&quot; );
2860   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2861 }
2862 
2863 //------------------------------cast_to_ptr_type-------------------------------
2864 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
2865   assert( ptr != Constant, &quot;what is the constant?&quot; );
2866   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2867   assert( _bits==0, &quot;Why cast a constant address?&quot;);
2868   if( ptr == _ptr ) return this;
2869   return make(ptr);
2870 }
2871 
2872 //------------------------------get_con----------------------------------------
2873 intptr_t TypeRawPtr::get_con() const {
2874   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
2875   return (intptr_t)_bits;
2876 }
2877 
2878 //------------------------------meet-------------------------------------------
2879 // Compute the MEET of two types.  It returns a new Type object.
2880 const Type *TypeRawPtr::xmeet( const Type *t ) const {
2881   // Perform a fast test for common case; meeting the same types together.
2882   if( this == t ) return this;  // Meeting same type-rep?
2883 
2884   // Current &quot;this-&gt;_base&quot; is RawPtr
2885   switch( t-&gt;base() ) {         // switch on original type
2886   case Bottom:                  // Ye Olde Default
2887     return t;
2888   case Top:
2889     return this;
2890   case AnyPtr:                  // Meeting to AnyPtrs
2891     break;
2892   case RawPtr: {                // might be top, bot, any/not or constant
2893     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
2894     enum PTR ptr = meet_ptr( tptr );
2895     if( ptr == Constant ) {     // Cannot be equal constants, so...
2896       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
2897       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
2898       ptr = NotNull;            // Fall down in lattice
2899     }
2900     return make( ptr );
2901   }
2902 
2903   case OopPtr:
2904   case InstPtr:
2905   case AryPtr:
2906   case MetadataPtr:
2907   case KlassPtr:
2908     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
2909   default:                      // All else is a mistake
2910     typerr(t);
2911   }
2912 
2913   // Found an AnyPtr type vs self-RawPtr type
2914   const TypePtr *tp = t-&gt;is_ptr();
2915   switch (tp-&gt;ptr()) {
2916   case TypePtr::TopPTR:  return this;
2917   case TypePtr::BotPTR:  return t;
2918   case TypePtr::Null:
2919     if( _ptr == TypePtr::TopPTR ) return t;
2920     return TypeRawPtr::BOTTOM;
2921   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
2922   case TypePtr::AnyNull:
2923     if( _ptr == TypePtr::Constant) return this;
2924     return make( meet_ptr(TypePtr::AnyNull) );
2925   default: ShouldNotReachHere();
2926   }
2927   return this;
2928 }
2929 
2930 //------------------------------xdual------------------------------------------
2931 // Dual: compute field-by-field dual
2932 const Type *TypeRawPtr::xdual() const {
2933   return new TypeRawPtr( dual_ptr(), _bits );
2934 }
2935 
2936 //------------------------------add_offset-------------------------------------
2937 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
2938   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
2939   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
2940   if( offset == 0 ) return this; // No change
2941   switch (_ptr) {
2942   case TypePtr::TopPTR:
2943   case TypePtr::BotPTR:
2944   case TypePtr::NotNull:
2945     return this;
2946   case TypePtr::Null:
2947   case TypePtr::Constant: {
2948     address bits = _bits+offset;
2949     if ( bits == 0 ) return TypePtr::NULL_PTR;
2950     return make( bits );
2951   }
2952   default:  ShouldNotReachHere();
2953   }
2954   return NULL;                  // Lint noise
2955 }
2956 
2957 //------------------------------eq---------------------------------------------
2958 // Structural equality check for Type representations
2959 bool TypeRawPtr::eq( const Type *t ) const {
2960   const TypeRawPtr *a = (const TypeRawPtr*)t;
2961   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
2962 }
2963 
2964 //------------------------------hash-------------------------------------------
2965 // Type-specific hashing function.
2966 int TypeRawPtr::hash(void) const {
2967   return (intptr_t)_bits + TypePtr::hash();
2968 }
2969 
2970 //------------------------------dump2------------------------------------------
2971 #ifndef PRODUCT
2972 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2973   if( _ptr == Constant )
2974     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2975   else
2976     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2977 }
2978 #endif
2979 
2980 //=============================================================================
2981 // Convenience common pre-built type.
2982 const TypeOopPtr *TypeOopPtr::BOTTOM;
2983 
2984 //------------------------------TypeOopPtr-------------------------------------
2985 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
2986                        int instance_id, const TypePtr* speculative, int inline_depth)
2987   : TypePtr(t, ptr, offset, speculative, inline_depth),
2988     _const_oop(o), _klass(k),
2989     _klass_is_exact(xk),
2990     _is_ptr_to_narrowoop(false),
2991     _is_ptr_to_narrowklass(false),
2992     _is_ptr_to_boxed_value(false),
2993     _instance_id(instance_id) {
2994   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
2995       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
2996     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);
2997   }
2998 #ifdef _LP64
2999   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {
3000     if (_offset == oopDesc::klass_offset_in_bytes()) {
3001       _is_ptr_to_narrowklass = UseCompressedClassPointers;
3002     } else if (klass() == NULL) {
3003       // Array with unknown body type
3004       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
3005       _is_ptr_to_narrowoop = UseCompressedOops;
3006     } else if (this-&gt;isa_aryptr()) {
3007       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;
3008                              _offset != arrayOopDesc::length_offset_in_bytes());
3009     } else if (klass()-&gt;is_instance_klass()) {
3010       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
3011       ciField* field = NULL;
3012       if (this-&gt;isa_klassptr()) {
3013         // Perm objects don&#39;t use compressed references
3014       } else if (_offset == OffsetBot || _offset == OffsetTop) {
3015         // unsafe access
3016         _is_ptr_to_narrowoop = UseCompressedOops;
3017       } else { // exclude unsafe ops
3018         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3019 
3020         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3021             (_offset == java_lang_Class::klass_offset() ||
3022              _offset == java_lang_Class::array_klass_offset())) {
3023           // Special hidden fields from the Class.
3024           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
3025           _is_ptr_to_narrowoop = false;
3026         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3027                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3028           // Static fields
3029           assert(o != NULL, &quot;must be constant&quot;);
3030           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3031           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3032           assert(field != NULL, &quot;missing field&quot;);
3033           BasicType basic_elem_type = field-&gt;layout_type();
3034           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3035         } else {
3036           // Instance fields which contains a compressed oop references.
3037           field = ik-&gt;get_field_by_offset(_offset, false);
3038           if (field != NULL) {
3039             BasicType basic_elem_type = field-&gt;layout_type();
3040             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3041           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3042             // Compile::find_alias_type() cast exactness on all types to verify
3043             // that it does not affect alias type.
3044             _is_ptr_to_narrowoop = UseCompressedOops;
3045           } else {
3046             // Type for the copy start in LibraryCallKit::inline_native_clone().
3047             _is_ptr_to_narrowoop = UseCompressedOops;
3048           }
3049         }
3050       }
3051     }
3052   }
3053 #endif
3054 }
3055 
3056 //------------------------------make-------------------------------------------
3057 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3058                                      const TypePtr* speculative, int inline_depth) {
3059   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3060   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3061   bool      xk = false;
3062   ciObject* o = NULL;
3063   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3064 }
3065 
3066 
3067 //------------------------------cast_to_ptr_type-------------------------------
3068 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3069   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3070   if( ptr == _ptr ) return this;
3071   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3072 }
3073 
3074 //-----------------------------cast_to_instance_id----------------------------
3075 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3076   // There are no instances of a general oop.
3077   // Return self unchanged.
3078   return this;
3079 }
3080 
3081 //-----------------------------cast_to_exactness-------------------------------
3082 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3083   // There is no such thing as an exact general oop.
3084   // Return self unchanged.
3085   return this;
3086 }
3087 
3088 
3089 //------------------------------as_klass_type----------------------------------
3090 // Return the klass type corresponding to this instance or array type.
3091 // It is the type that is loaded from an object of this type.
3092 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3093   ciKlass* k = klass();
3094   bool    xk = klass_is_exact();
3095   if (k == NULL)
3096     return TypeKlassPtr::OBJECT;
3097   else
3098     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3099 }
3100 
3101 //------------------------------meet-------------------------------------------
3102 // Compute the MEET of two types.  It returns a new Type object.
3103 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3104   // Perform a fast test for common case; meeting the same types together.
3105   if( this == t ) return this;  // Meeting same type-rep?
3106 
3107   // Current &quot;this-&gt;_base&quot; is OopPtr
3108   switch (t-&gt;base()) {          // switch on original type
3109 
3110   case Int:                     // Mixing ints &amp; oops happens when javac
3111   case Long:                    // reuses local variables
3112   case FloatTop:
3113   case FloatCon:
3114   case FloatBot:
3115   case DoubleTop:
3116   case DoubleCon:
3117   case DoubleBot:
3118   case NarrowOop:
3119   case NarrowKlass:
3120   case Bottom:                  // Ye Olde Default
3121     return Type::BOTTOM;
3122   case Top:
3123     return this;
3124 
3125   default:                      // All else is a mistake
3126     typerr(t);
3127 
3128   case RawPtr:
3129   case MetadataPtr:
3130   case KlassPtr:
3131     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3132 
3133   case AnyPtr: {
3134     // Found an AnyPtr type vs self-OopPtr type
3135     const TypePtr *tp = t-&gt;is_ptr();
3136     int offset = meet_offset(tp-&gt;offset());
3137     PTR ptr = meet_ptr(tp-&gt;ptr());
3138     const TypePtr* speculative = xmeet_speculative(tp);
3139     int depth = meet_inline_depth(tp-&gt;inline_depth());
3140     switch (tp-&gt;ptr()) {
3141     case Null:
3142       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3143       // else fall through:
3144     case TopPTR:
3145     case AnyNull: {
3146       int instance_id = meet_instance_id(InstanceTop);
3147       return make(ptr, offset, instance_id, speculative, depth);
3148     }
3149     case BotPTR:
3150     case NotNull:
3151       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3152     default: typerr(t);
3153     }
3154   }
3155 
3156   case OopPtr: {                 // Meeting to other OopPtrs
3157     const TypeOopPtr *tp = t-&gt;is_oopptr();
3158     int instance_id = meet_instance_id(tp-&gt;instance_id());
3159     const TypePtr* speculative = xmeet_speculative(tp);
3160     int depth = meet_inline_depth(tp-&gt;inline_depth());
3161     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3162   }
3163 
3164   case InstPtr:                  // For these, flip the call around to cut down
3165   case AryPtr:
3166     return t-&gt;xmeet(this);      // Call in reverse direction
3167 
3168   } // End of switch
3169   return this;                  // Return the double constant
3170 }
3171 
3172 
3173 //------------------------------xdual------------------------------------------
3174 // Dual of a pure heap pointer.  No relevant klass or oop information.
3175 const Type *TypeOopPtr::xdual() const {
3176   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3177   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3178   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3179 }
3180 
3181 //--------------------------make_from_klass_common-----------------------------
3182 // Computes the element-type given a klass.
3183 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3184   if (klass-&gt;is_instance_klass()) {
3185     Compile* C = Compile::current();
3186     Dependencies* deps = C-&gt;dependencies();
3187     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3188     // Element is an instance
3189     bool klass_is_exact = false;
3190     if (klass-&gt;is_loaded()) {
3191       // Try to set klass_is_exact.
3192       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3193       klass_is_exact = ik-&gt;is_final();
3194       if (!klass_is_exact &amp;&amp; klass_change
3195           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3196         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3197         if (sub != NULL) {
3198           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3199           klass = ik = sub;
3200           klass_is_exact = sub-&gt;is_final();
3201         }
3202       }
3203       if (!klass_is_exact &amp;&amp; try_for_exact
3204           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3205         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3206           // Add a dependence; if concrete subclass added we need to recompile
3207           deps-&gt;assert_leaf_type(ik);
3208           klass_is_exact = true;
3209         }
3210       }
3211     }
3212     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);
3213   } else if (klass-&gt;is_obj_array_klass()) {
3214     // Element is an object array. Recursively call ourself.
3215     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);
3216     bool xk = etype-&gt;klass_is_exact();
3217     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3218     // We used to pass NotNull in here, asserting that the sub-arrays
3219     // are all not-null.  This is not true in generally, as code can
3220     // slam NULLs down in the subarrays.
3221     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);
3222     return arr;
3223   } else if (klass-&gt;is_type_array_klass()) {
3224     // Element is an typeArray
3225     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3226     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3227     // We used to pass NotNull in here, asserting that the array pointer
3228     // is not-null. That was not true in general.
3229     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);
3230     return arr;
3231   } else {
3232     ShouldNotReachHere();
3233     return NULL;
3234   }
3235 }
3236 
3237 //------------------------------make_from_constant-----------------------------
3238 // Make a java pointer from an oop constant
3239 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3240   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3241 
3242   const bool make_constant = require_constant || o-&gt;should_be_constant();
3243 
3244   ciKlass* klass = o-&gt;klass();
3245   if (klass-&gt;is_instance_klass()) {
3246     // Element is an instance
3247     if (make_constant) {
3248       return TypeInstPtr::make(o);
3249     } else {
3250       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);
3251     }
3252   } else if (klass-&gt;is_obj_array_klass()) {
3253     // Element is an object array. Recursively call ourself.
3254     const TypeOopPtr *etype =
3255       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());
3256     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3257     // We used to pass NotNull in here, asserting that the sub-arrays
3258     // are all not-null.  This is not true in generally, as code can
3259     // slam NULLs down in the subarrays.
3260     if (make_constant) {
3261       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3262     } else {
3263       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3264     }
3265   } else if (klass-&gt;is_type_array_klass()) {
3266     // Element is an typeArray
3267     const Type* etype =
3268       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3269     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3270     // We used to pass NotNull in here, asserting that the array pointer
3271     // is not-null. That was not true in general.
3272     if (make_constant) {
3273       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3274     } else {
3275       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3276     }
3277   }
3278 
3279   fatal(&quot;unhandled object type&quot;);
3280   return NULL;
3281 }
3282 
3283 //------------------------------get_con----------------------------------------
3284 intptr_t TypeOopPtr::get_con() const {
3285   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3286   assert( _offset &gt;= 0, &quot;&quot; );
3287 
3288   if (_offset != 0) {
3289     // After being ported to the compiler interface, the compiler no longer
3290     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3291     // to a handle at compile time.  This handle is embedded in the generated
3292     // code and dereferenced at the time the nmethod is made.  Until that time,
3293     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3294     // have access to the addresses!).  This does not seem to currently happen,
3295     // but this assertion here is to help prevent its occurence.
3296     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3297     ShouldNotReachHere();
3298   }
3299 
3300   return (intptr_t)const_oop()-&gt;constant_encoding();
3301 }
3302 
3303 
3304 //-----------------------------filter------------------------------------------
3305 // Do not allow interface-vs.-noninterface joins to collapse to top.
3306 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3307 
3308   const Type* ft = join_helper(kills, include_speculative);
3309   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3310   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3311 
3312   if (ft-&gt;empty()) {
3313     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3314     // interface.  This can happen because the bytecodes do not contain
3315     // enough type info to distinguish a Java-level interface variable
3316     // from a Java-level object variable.  If we meet 2 classes which
3317     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3318     // doesn&#39;t implement I, we have no way to tell if the result should
3319     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3320     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3321     // uplift the type.
3322     if (!empty()) {
3323       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3324         return kills;           // Uplift to interface
3325       }
3326       // Also check for evil cases of &#39;this&#39; being a class array
3327       // and &#39;kills&#39; expecting an array of interfaces.
3328       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3329       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3330         return kills;           // Uplift to array of interface
3331       }
3332     }
3333 
3334     return Type::TOP;           // Canonical empty value
3335   }
3336 
3337   // If we have an interface-typed Phi or cast and we narrow to a class type,
3338   // the join should report back the class.  However, if we have a J/L/Object
3339   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3340   // join report an interface back out.  This isn&#39;t possible but happens
3341   // because the type system doesn&#39;t interact well with interfaces.
3342   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3343       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3344       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3345     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3346     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3347   }
3348 
3349   return ft;
3350 }
3351 
3352 //------------------------------eq---------------------------------------------
3353 // Structural equality check for Type representations
3354 bool TypeOopPtr::eq( const Type *t ) const {
3355   const TypeOopPtr *a = (const TypeOopPtr*)t;
3356   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3357       _instance_id != a-&gt;_instance_id)  return false;
3358   ciObject* one = const_oop();
3359   ciObject* two = a-&gt;const_oop();
3360   if (one == NULL || two == NULL) {
3361     return (one == two) &amp;&amp; TypePtr::eq(t);
3362   } else {
3363     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3364   }
3365 }
3366 
3367 //------------------------------hash-------------------------------------------
3368 // Type-specific hashing function.
3369 int TypeOopPtr::hash(void) const {
3370   return
3371     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3372              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3373 }
3374 
3375 //------------------------------dump2------------------------------------------
3376 #ifndef PRODUCT
3377 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3378   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3379   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3380   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3381   switch( _offset ) {
3382   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
3383   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
3384   case         0: break;
3385   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
3386   }
3387   if (_instance_id == InstanceTop)
3388     st-&gt;print(&quot;,iid=top&quot;);
3389   else if (_instance_id != InstanceBot)
3390     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3391 
3392   dump_inline_depth(st);
3393   dump_speculative(st);
3394 }
3395 #endif
3396 
3397 //------------------------------singleton--------------------------------------
3398 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3399 // constants
3400 bool TypeOopPtr::singleton(void) const {
3401   // detune optimizer to not generate constant oop + constant offset as a constant!
3402   // TopPTR, Null, AnyNull, Constant are all singletons
3403   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
3404 }
3405 
3406 //------------------------------add_offset-------------------------------------
3407 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3408   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3409 }
3410 
3411 /**
3412  * Return same type without a speculative part
3413  */
3414 const Type* TypeOopPtr::remove_speculative() const {
3415   if (_speculative == NULL) {
3416     return this;
3417   }
3418   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3419   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3420 }
3421 
3422 /**
3423  * Return same type but drop speculative part if we know we won&#39;t use
3424  * it
3425  */
3426 const Type* TypeOopPtr::cleanup_speculative() const {
3427   // If the klass is exact and the ptr is not null then there&#39;s
3428   // nothing that the speculative type can help us with
3429   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3430     return remove_speculative();
3431   }
3432   return TypePtr::cleanup_speculative();
3433 }
3434 
3435 /**
3436  * Return same type but with a different inline depth (used for speculation)
3437  *
3438  * @param depth  depth to meet with
3439  */
3440 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3441   if (!UseInlineDepthForSpeculativeTypes) {
3442     return this;
3443   }
3444   return make(_ptr, _offset, _instance_id, _speculative, depth);
3445 }
3446 
3447 //------------------------------with_instance_id--------------------------------
3448 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3449   assert(_instance_id != -1, &quot;should be known&quot;);
3450   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3451 }
3452 
3453 //------------------------------meet_instance_id--------------------------------
3454 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3455   // Either is &#39;TOP&#39; instance?  Return the other instance!
3456   if( _instance_id == InstanceTop ) return  instance_id;
3457   if(  instance_id == InstanceTop ) return _instance_id;
3458   // If either is different, return &#39;BOTTOM&#39; instance
3459   if( _instance_id != instance_id ) return InstanceBot;
3460   return _instance_id;
3461 }
3462 
3463 //------------------------------dual_instance_id--------------------------------
3464 int TypeOopPtr::dual_instance_id( ) const {
3465   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3466   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3467   return _instance_id;              // Map everything else into self
3468 }
3469 
3470 /**
3471  * Check whether new profiling would improve speculative type
3472  *
3473  * @param   exact_kls    class from profiling
3474  * @param   inline_depth inlining depth of profile point
3475  *
3476  * @return  true if type profile is valuable
3477  */
3478 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3479   // no way to improve an already exact type
3480   if (klass_is_exact()) {
3481     return false;
3482   }
3483   return TypePtr::would_improve_type(exact_kls, inline_depth);
3484 }
3485 
3486 //=============================================================================
3487 // Convenience common pre-built types.
3488 const TypeInstPtr *TypeInstPtr::NOTNULL;
3489 const TypeInstPtr *TypeInstPtr::BOTTOM;
3490 const TypeInstPtr *TypeInstPtr::MIRROR;
3491 const TypeInstPtr *TypeInstPtr::MARK;
3492 const TypeInstPtr *TypeInstPtr::KLASS;
3493 
3494 //------------------------------TypeInstPtr-------------------------------------
3495 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,
3496                          int instance_id, const TypePtr* speculative, int inline_depth)
3497   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),
3498     _name(k-&gt;name()) {
3499    assert(k != NULL &amp;&amp;
3500           (k-&gt;is_loaded() || o == NULL),
3501           &quot;cannot have constants with non-loaded klass&quot;);
3502 };
3503 
3504 //------------------------------make-------------------------------------------
3505 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3506                                      ciKlass* k,
3507                                      bool xk,
3508                                      ciObject* o,
3509                                      int offset,
3510                                      int instance_id,
3511                                      const TypePtr* speculative,
3512                                      int inline_depth) {
3513   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3514   // Either const_oop() is NULL or else ptr is Constant
3515   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3516           &quot;constant pointers must have a value supplied&quot; );
3517   // Ptr is never Null
3518   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3519 
3520   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3521   if (!UseExactTypes)  xk = false;
3522   if (ptr == Constant) {
3523     // Note:  This case includes meta-object constants, such as methods.
3524     xk = true;
3525   } else if (k-&gt;is_loaded()) {
3526     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3527     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3528     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3529   }
3530 
3531   // Now hash this baby
3532   TypeInstPtr *result =
3533     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3534 
3535   return result;
3536 }
3537 
3538 /**
3539  *  Create constant type for a constant boxed value
3540  */
3541 const Type* TypeInstPtr::get_const_boxed_value() const {
3542   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3543   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3544   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3545   BasicType bt = constant.basic_type();
3546   switch (bt) {
3547     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3548     case T_INT:      return TypeInt::make(constant.as_int());
3549     case T_CHAR:     return TypeInt::make(constant.as_char());
3550     case T_BYTE:     return TypeInt::make(constant.as_byte());
3551     case T_SHORT:    return TypeInt::make(constant.as_short());
3552     case T_FLOAT:    return TypeF::make(constant.as_float());
3553     case T_DOUBLE:   return TypeD::make(constant.as_double());
3554     case T_LONG:     return TypeLong::make(constant.as_long());
3555     default:         break;
3556   }
3557   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3558   return NULL;
3559 }
3560 
3561 //------------------------------cast_to_ptr_type-------------------------------
3562 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3563   if( ptr == _ptr ) return this;
3564   // Reconstruct _sig info here since not a problem with later lazy
3565   // construction, _sig will show up on demand.
3566   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3567 }
3568 
3569 
3570 //-----------------------------cast_to_exactness-------------------------------
3571 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3572   if( klass_is_exact == _klass_is_exact ) return this;
3573   if (!UseExactTypes)  return this;
3574   if (!_klass-&gt;is_loaded())  return this;
3575   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3576   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3577   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3578   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3579 }
3580 
3581 //-----------------------------cast_to_instance_id----------------------------
3582 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3583   if( instance_id == _instance_id ) return this;
3584   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3585 }
3586 
3587 //------------------------------xmeet_unloaded---------------------------------
3588 // Compute the MEET of two InstPtrs when at least one is unloaded.
3589 // Assume classes are different since called after check for same name/class-loader
3590 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3591     int off = meet_offset(tinst-&gt;offset());
3592     PTR ptr = meet_ptr(tinst-&gt;ptr());
3593     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3594     const TypePtr* speculative = xmeet_speculative(tinst);
3595     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3596 
3597     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3598     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3599     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3600       //
3601       // Meet unloaded class with java/lang/Object
3602       //
3603       // Meet
3604       //          |                     Unloaded Class
3605       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3606       //  ===================================================================
3607       //   TOP    | ..........................Unloaded......................|
3608       //  AnyNull |  U-AN    |................Unloaded......................|
3609       // Constant | ... O-NN .................................. |   O-BOT   |
3610       //  NotNull | ... O-NN .................................. |   O-BOT   |
3611       //  BOTTOM  | ........................Object-BOTTOM ..................|
3612       //
3613       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3614       //
3615       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3616       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }
3617       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3618       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3619         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3620         else                                      { return TypeInstPtr::NOTNULL; }
3621       }
3622       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3623 
3624       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3625     }
3626 
3627     // Both are unloaded, not the same class, not Object
3628     // Or meet unloaded with a different loaded class, not java/lang/Object
3629     if( ptr != TypePtr::BotPTR ) {
3630       return TypeInstPtr::NOTNULL;
3631     }
3632     return TypeInstPtr::BOTTOM;
3633 }
3634 
3635 
3636 //------------------------------meet-------------------------------------------
3637 // Compute the MEET of two types.  It returns a new Type object.
3638 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3639   // Perform a fast test for common case; meeting the same types together.
3640   if( this == t ) return this;  // Meeting same type-rep?
3641 
3642   // Current &quot;this-&gt;_base&quot; is Pointer
3643   switch (t-&gt;base()) {          // switch on original type
3644 
3645   case Int:                     // Mixing ints &amp; oops happens when javac
3646   case Long:                    // reuses local variables
3647   case FloatTop:
3648   case FloatCon:
3649   case FloatBot:
3650   case DoubleTop:
3651   case DoubleCon:
3652   case DoubleBot:
3653   case NarrowOop:
3654   case NarrowKlass:
3655   case Bottom:                  // Ye Olde Default
3656     return Type::BOTTOM;
3657   case Top:
3658     return this;
3659 
3660   default:                      // All else is a mistake
3661     typerr(t);
3662 
3663   case MetadataPtr:
3664   case KlassPtr:
3665   case RawPtr: return TypePtr::BOTTOM;
3666 
3667   case AryPtr: {                // All arrays inherit from Object class
3668     const TypeAryPtr *tp = t-&gt;is_aryptr();
3669     int offset = meet_offset(tp-&gt;offset());
3670     PTR ptr = meet_ptr(tp-&gt;ptr());
3671     int instance_id = meet_instance_id(tp-&gt;instance_id());
3672     const TypePtr* speculative = xmeet_speculative(tp);
3673     int depth = meet_inline_depth(tp-&gt;inline_depth());
3674     switch (ptr) {
3675     case TopPTR:
3676     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3677       // For instances when a subclass meets a superclass we fall
3678       // below the centerline when the superclass is exact. We need to
3679       // do the same here.
3680       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3681         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3682       } else {
3683         // cannot subclass, so the meet has to fall badly below the centerline
3684         ptr = NotNull;
3685         instance_id = InstanceBot;
3686         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3687       }
3688     case Constant:
3689     case NotNull:
3690     case BotPTR:                // Fall down to object klass
3691       // LCA is object_klass, but if we subclass from the top we can do better
3692       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3693         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3694         // then we can subclass in the Java class hierarchy.
3695         // For instances when a subclass meets a superclass we fall
3696         // below the centerline when the superclass is exact. We need
3697         // to do the same here.
3698         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3699           // that is, tp&#39;s array type is a subtype of my klass
3700           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3701                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3702         }
3703       }
3704       // The other case cannot happen, since I cannot be a subtype of an array.
3705       // The meet falls down to Object class below centerline.
3706       if( ptr == Constant )
3707          ptr = NotNull;
3708       instance_id = InstanceBot;
3709       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3710     default: typerr(t);
3711     }
3712   }
3713 
3714   case OopPtr: {                // Meeting to OopPtrs
3715     // Found a OopPtr type vs self-InstPtr type
3716     const TypeOopPtr *tp = t-&gt;is_oopptr();
3717     int offset = meet_offset(tp-&gt;offset());
3718     PTR ptr = meet_ptr(tp-&gt;ptr());
3719     switch (tp-&gt;ptr()) {
3720     case TopPTR:
3721     case AnyNull: {
3722       int instance_id = meet_instance_id(InstanceTop);
3723       const TypePtr* speculative = xmeet_speculative(tp);
3724       int depth = meet_inline_depth(tp-&gt;inline_depth());
3725       return make(ptr, klass(), klass_is_exact(),
3726                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3727     }
3728     case NotNull:
3729     case BotPTR: {
3730       int instance_id = meet_instance_id(tp-&gt;instance_id());
3731       const TypePtr* speculative = xmeet_speculative(tp);
3732       int depth = meet_inline_depth(tp-&gt;inline_depth());
3733       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3734     }
3735     default: typerr(t);
3736     }
3737   }
3738 
3739   case AnyPtr: {                // Meeting to AnyPtrs
3740     // Found an AnyPtr type vs self-InstPtr type
3741     const TypePtr *tp = t-&gt;is_ptr();
3742     int offset = meet_offset(tp-&gt;offset());
3743     PTR ptr = meet_ptr(tp-&gt;ptr());
3744     int instance_id = meet_instance_id(InstanceTop);
3745     const TypePtr* speculative = xmeet_speculative(tp);
3746     int depth = meet_inline_depth(tp-&gt;inline_depth());
3747     switch (tp-&gt;ptr()) {
3748     case Null:
3749       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3750       // else fall through to AnyNull
3751     case TopPTR:
3752     case AnyNull: {
3753       return make(ptr, klass(), klass_is_exact(),
3754                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3755     }
3756     case NotNull:
3757     case BotPTR:
3758       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3759     default: typerr(t);
3760     }
3761   }
3762 
3763   /*
3764                  A-top         }
3765                /   |   \       }  Tops
3766            B-top A-any C-top   }
3767               | /  |  \ |      }  Any-nulls
3768            B-any   |   C-any   }
3769               |    |    |
3770            B-con A-con C-con   } constants; not comparable across classes
3771               |    |    |
3772            B-not   |   C-not   }
3773               | \  |  / |      }  not-nulls
3774            B-bot A-not C-bot   }
3775                \   |   /       }  Bottoms
3776                  A-bot         }
3777   */
3778 
3779   case InstPtr: {                // Meeting 2 Oops?
3780     // Found an InstPtr sub-type vs self-InstPtr type
3781     const TypeInstPtr *tinst = t-&gt;is_instptr();
3782     int off = meet_offset( tinst-&gt;offset() );
3783     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3784     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3785     const TypePtr* speculative = xmeet_speculative(tinst);
3786     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3787 
3788     // Check for easy case; klasses are equal (and perhaps not loaded!)
3789     // If we have constants, then we created oops so classes are loaded
3790     // and we can handle the constants further down.  This case handles
3791     // both-not-loaded or both-loaded classes
3792     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {
3793       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);
3794     }
3795 
3796     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3797     ciKlass* tinst_klass = tinst-&gt;klass();
3798     ciKlass* this_klass  = this-&gt;klass();
3799     bool tinst_xk = tinst-&gt;klass_is_exact();
3800     bool this_xk  = this-&gt;klass_is_exact();
3801     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3802       // One of these classes has not been loaded
3803       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3804 #ifndef PRODUCT
3805       if( PrintOpto &amp;&amp; Verbose ) {
3806         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3807         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3808         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3809       }
3810 #endif
3811       return unloaded_meet;
3812     }
3813 
3814     // Handle mixing oops and interfaces first.
3815     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3816                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3817       ciKlass *tmp = tinst_klass; // Swap interface around
3818       tinst_klass = this_klass;
3819       this_klass = tmp;
3820       bool tmp2 = tinst_xk;
3821       tinst_xk = this_xk;
3822       this_xk = tmp2;
3823     }
3824     if (tinst_klass-&gt;is_interface() &amp;&amp;
3825         !(this_klass-&gt;is_interface() ||
3826           // Treat java/lang/Object as an honorary interface,
3827           // because we need a bottom for the interface hierarchy.
3828           this_klass == ciEnv::current()-&gt;Object_klass())) {
3829       // Oop meets interface!
3830 
3831       // See if the oop subtypes (implements) interface.
3832       ciKlass *k;
3833       bool xk;
3834       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3835         // Oop indeed subtypes.  Now keep oop or interface depending
3836         // on whether we are both above the centerline or either is
3837         // below the centerline.  If we are on the centerline
3838         // (e.g., Constant vs. AnyNull interface), use the constant.
3839         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3840         // If we are keeping this_klass, keep its exactness too.
3841         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
3842       } else {                  // Does not implement, fall to Object
3843         // Oop does not implement interface, so mixing falls to Object
3844         // just like the verifier does (if both are above the
3845         // centerline fall to interface)
3846         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3847         xk = above_centerline(ptr) ? tinst_xk : false;
3848         // Watch out for Constant vs. AnyNull interface.
3849         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3850         instance_id = InstanceBot;
3851       }
3852       ciObject* o = NULL;  // the Constant value, if any
3853       if (ptr == Constant) {
3854         // Find out which constant.
3855         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3856       }
3857       return make(ptr, k, xk, o, off, instance_id, speculative, depth);
3858     }
3859 
3860     // Either oop vs oop or interface vs interface or interface vs Object
3861 
3862     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3863     // If we split one up &amp; one down AND they subtype, take the down man.
3864     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3865     // If both are up and they subtype, take the subtype class.
3866     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3867     // If both are down and they subtype, take the supertype class.
3868     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3869     // Constants treated as down.
3870 
3871     // Now, reorder the above list; observe that both-down+subtype is also
3872     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3873     // If we split one up &amp; one down AND they subtype, take the down man.
3874     // If both are up and they subtype, take the subtype class.
3875 
3876     // If both are down and they subtype, &quot;fall hard&quot;.
3877     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3878     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3879     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3880 
3881     // If a proper subtype is exact, and we return it, we return it exactly.
3882     // If a proper supertype is exact, there can be no subtyping relationship!
3883     // If both types are equal to the subtype, exactness is and-ed below the
3884     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3885 
3886     // Check for subtyping:
3887     ciKlass *subtype = NULL;
3888     bool subtype_exact = false;
3889     if( tinst_klass-&gt;equals(this_klass) ) {
3890       subtype = this_klass;
3891       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
3892     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3893       subtype = this_klass;     // Pick subtyping class
3894       subtype_exact = this_xk;
3895     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3896       subtype = tinst_klass;    // Pick subtyping class
3897       subtype_exact = tinst_xk;
3898     }
3899 
3900     if( subtype ) {
3901       if( above_centerline(ptr) ) { // both are up?
3902         this_klass = tinst_klass = subtype;
3903         this_xk = tinst_xk = subtype_exact;
3904       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3905         this_klass = tinst_klass; // tinst is down; keep down man
3906         this_xk = tinst_xk;
3907       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3908         tinst_klass = this_klass; // this is down; keep down man
3909         tinst_xk = this_xk;
3910       } else {
3911         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
3912       }
3913     }
3914 
3915     // Check for classes now being equal
3916     if (tinst_klass-&gt;equals(this_klass)) {
3917       // If the klasses are equal, the constants may still differ.  Fall to
3918       // NotNull if they do (neither constant is NULL; that is a special case
3919       // handled elsewhere).
3920       ciObject* o = NULL;             // Assume not constant when done
3921       ciObject* this_oop  = const_oop();
3922       ciObject* tinst_oop = tinst-&gt;const_oop();
3923       if( ptr == Constant ) {
3924         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3925             this_oop-&gt;equals(tinst_oop) )
3926           o = this_oop;
3927         else if (above_centerline(this -&gt;_ptr))
3928           o = tinst_oop;
3929         else if (above_centerline(tinst -&gt;_ptr))
3930           o = this_oop;
3931         else
3932           ptr = NotNull;
3933       }
3934       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);
3935     } // Else classes are not equal
3936 
3937     // Since klasses are different, we require a LCA in the Java
3938     // class hierarchy - which means we have to fall to at least NotNull.
3939     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3940       ptr = NotNull;
3941 
3942     instance_id = InstanceBot;
3943 
3944     // Now we find the LCA of Java classes
3945     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
3946     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);
3947   } // End of case InstPtr
3948 
3949   } // End of switch
3950   return this;                  // Return the double constant
3951 }
3952 
3953 
3954 //------------------------java_mirror_type--------------------------------------
3955 ciType* TypeInstPtr::java_mirror_type() const {
3956   // must be a singleton type
3957   if( const_oop() == NULL )  return NULL;
3958 
3959   // must be of type java.lang.Class
3960   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
3961 
3962   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3963 }
3964 
3965 
3966 //------------------------------xdual------------------------------------------
3967 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3968 // inheritance mechanism.
3969 const Type *TypeInstPtr::xdual() const {
3970   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3971 }
3972 
3973 //------------------------------eq---------------------------------------------
3974 // Structural equality check for Type representations
3975 bool TypeInstPtr::eq( const Type *t ) const {
3976   const TypeInstPtr *p = t-&gt;is_instptr();
3977   return
3978     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
3979     TypeOopPtr::eq(p);          // Check sub-type stuff
3980 }
3981 
3982 //------------------------------hash-------------------------------------------
3983 // Type-specific hashing function.
3984 int TypeInstPtr::hash(void) const {
3985   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());
3986   return hash;
3987 }
3988 
3989 //------------------------------dump2------------------------------------------
3990 // Dump oop Type
3991 #ifndef PRODUCT
3992 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3993   // Print the name of the klass.
3994   klass()-&gt;print_name_on(st);
3995 
3996   switch( _ptr ) {
3997   case Constant:
3998     // TO DO: Make CI print the hex address of the underlying oop.
3999     if (WizardMode || Verbose) {
4000       const_oop()-&gt;print_oop(st);
4001     }
4002   case BotPTR:
4003     if (!WizardMode &amp;&amp; !Verbose) {
4004       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4005       break;
4006     }
4007   case TopPTR:
4008   case AnyNull:
4009   case NotNull:
4010     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4011     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4012     break;
4013   default:
4014     break;
4015   }
4016 
4017   if( _offset ) {               // Dump offset, if any
4018     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);
4019     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);
4020     else st-&gt;print(&quot;+%d&quot;, _offset);
4021   }
4022 
4023   st-&gt;print(&quot; *&quot;);
4024   if (_instance_id == InstanceTop)
4025     st-&gt;print(&quot;,iid=top&quot;);
4026   else if (_instance_id != InstanceBot)
4027     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4028 
4029   dump_inline_depth(st);
4030   dump_speculative(st);
4031 }
4032 #endif
4033 
4034 //------------------------------add_offset-------------------------------------
4035 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4036   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),
4037               _instance_id, add_offset_speculative(offset), _inline_depth);
4038 }
4039 
4040 const Type *TypeInstPtr::remove_speculative() const {
4041   if (_speculative == NULL) {
4042     return this;
4043   }
4044   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4045   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,
4046               _instance_id, NULL, _inline_depth);
4047 }
4048 
4049 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4050   if (!UseInlineDepthForSpeculativeTypes) {
4051     return this;
4052   }
4053   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);
4054 }
4055 
4056 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4057   assert(is_known_instance(), &quot;should be known&quot;);
4058   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);
4059 }
4060 
4061 //=============================================================================
4062 // Convenience common pre-built types.
4063 const TypeAryPtr *TypeAryPtr::RANGE;
4064 const TypeAryPtr *TypeAryPtr::OOPS;
4065 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4066 const TypeAryPtr *TypeAryPtr::BYTES;
4067 const TypeAryPtr *TypeAryPtr::SHORTS;
4068 const TypeAryPtr *TypeAryPtr::CHARS;
4069 const TypeAryPtr *TypeAryPtr::INTS;
4070 const TypeAryPtr *TypeAryPtr::LONGS;
4071 const TypeAryPtr *TypeAryPtr::FLOATS;
4072 const TypeAryPtr *TypeAryPtr::DOUBLES;
4073 
4074 //------------------------------make-------------------------------------------
4075 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4076                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4077   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4078          &quot;integral arrays must be pre-equipped with a class&quot;);
4079   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4080   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4081   if (!UseExactTypes)  xk = (ptr == Constant);
4082   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4083 }
4084 
4085 //------------------------------make-------------------------------------------
4086 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4087                                    int instance_id, const TypePtr* speculative, int inline_depth,
4088                                    bool is_autobox_cache) {
4089   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4090          &quot;integral arrays must be pre-equipped with a class&quot;);
4091   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4092   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4093   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4094   if (!UseExactTypes)  xk = (ptr == Constant);
4095   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4096 }
4097 
4098 //------------------------------cast_to_ptr_type-------------------------------
4099 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4100   if( ptr == _ptr ) return this;
4101   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4102 }
4103 
4104 
4105 //-----------------------------cast_to_exactness-------------------------------
4106 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4107   if( klass_is_exact == _klass_is_exact ) return this;
4108   if (!UseExactTypes)  return this;
4109   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4110   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4111 }
4112 
4113 //-----------------------------cast_to_instance_id----------------------------
4114 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4115   if( instance_id == _instance_id ) return this;
4116   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4117 }
4118 
4119 
4120 //-----------------------------max_array_length-------------------------------
4121 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4122 jint TypeAryPtr::max_array_length(BasicType etype) {
4123   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4124     if (etype == T_NARROWOOP) {
4125       etype = T_OBJECT;
4126     } else if (etype == T_ILLEGAL) { // bottom[]
4127       etype = T_BYTE; // will produce conservatively high value
4128     } else {
4129       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4130     }
4131   }
4132   return arrayOopDesc::max_array_length(etype);
4133 }
4134 
4135 //-----------------------------narrow_size_type-------------------------------
4136 // Narrow the given size type to the index range for the given array base type.
4137 // Return NULL if the resulting int type becomes empty.
4138 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4139   jint hi = size-&gt;_hi;
4140   jint lo = size-&gt;_lo;
4141   jint min_lo = 0;
4142   jint max_hi = max_array_length(elem()-&gt;basic_type());
4143   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4144   bool chg = false;
4145   if (lo &lt; min_lo) {
4146     lo = min_lo;
4147     if (size-&gt;is_con()) {
4148       hi = lo;
4149     }
4150     chg = true;
4151   }
4152   if (hi &gt; max_hi) {
4153     hi = max_hi;
4154     if (size-&gt;is_con()) {
4155       lo = hi;
4156     }
4157     chg = true;
4158   }
4159   // Negative length arrays will produce weird intermediate dead fast-path code
4160   if (lo &gt; hi)
4161     return TypeInt::ZERO;
4162   if (!chg)
4163     return size;
4164   return TypeInt::make(lo, hi, Type::WidenMin);
4165 }
4166 
4167 //-------------------------------cast_to_size----------------------------------
4168 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4169   assert(new_size != NULL, &quot;&quot;);
4170   new_size = narrow_size_type(new_size);
4171   if (new_size == size())  return this;
4172   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());
4173   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4174 }
4175 
4176 //------------------------------cast_to_stable---------------------------------
4177 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4178   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4179     return this;
4180 
4181   const Type* elem = this-&gt;elem();
4182   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4183 
4184   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4185     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4186     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4187   }
4188 
4189   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);
4190 
4191   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4192 }
4193 
4194 //-----------------------------stable_dimension--------------------------------
4195 int TypeAryPtr::stable_dimension() const {
4196   if (!is_stable())  return 0;
4197   int dim = 1;
4198   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4199   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4200     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4201   return dim;
4202 }
4203 
4204 //----------------------cast_to_autobox_cache-----------------------------------
4205 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4206   if (is_autobox_cache() == cache)  return this;
4207   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4208   if (etype == NULL)  return this;
4209   // The pointers in the autobox arrays are always non-null.
4210   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4211   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4212   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());
4213   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);
4214 }
4215 
4216 //------------------------------eq---------------------------------------------
4217 // Structural equality check for Type representations
4218 bool TypeAryPtr::eq( const Type *t ) const {
4219   const TypeAryPtr *p = t-&gt;is_aryptr();
4220   return
4221     _ary == p-&gt;_ary &amp;&amp;  // Check array
4222     TypeOopPtr::eq(p);  // Check sub-parts
4223 }
4224 
4225 //------------------------------hash-------------------------------------------
4226 // Type-specific hashing function.
4227 int TypeAryPtr::hash(void) const {
4228   return (intptr_t)_ary + TypeOopPtr::hash();
4229 }
4230 
4231 //------------------------------meet-------------------------------------------
4232 // Compute the MEET of two types.  It returns a new Type object.
4233 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4234   // Perform a fast test for common case; meeting the same types together.
4235   if( this == t ) return this;  // Meeting same type-rep?
4236   // Current &quot;this-&gt;_base&quot; is Pointer
4237   switch (t-&gt;base()) {          // switch on original type
4238 
4239   // Mixing ints &amp; oops happens when javac reuses local variables
4240   case Int:
4241   case Long:
4242   case FloatTop:
4243   case FloatCon:
4244   case FloatBot:
4245   case DoubleTop:
4246   case DoubleCon:
4247   case DoubleBot:
4248   case NarrowOop:
4249   case NarrowKlass:
4250   case Bottom:                  // Ye Olde Default
4251     return Type::BOTTOM;
4252   case Top:
4253     return this;
4254 
4255   default:                      // All else is a mistake
4256     typerr(t);
4257 
4258   case OopPtr: {                // Meeting to OopPtrs
4259     // Found a OopPtr type vs self-AryPtr type
4260     const TypeOopPtr *tp = t-&gt;is_oopptr();
4261     int offset = meet_offset(tp-&gt;offset());
4262     PTR ptr = meet_ptr(tp-&gt;ptr());
4263     int depth = meet_inline_depth(tp-&gt;inline_depth());
4264     const TypePtr* speculative = xmeet_speculative(tp);
4265     switch (tp-&gt;ptr()) {
4266     case TopPTR:
4267     case AnyNull: {
4268       int instance_id = meet_instance_id(InstanceTop);
4269       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4270                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4271     }
4272     case BotPTR:
4273     case NotNull: {
4274       int instance_id = meet_instance_id(tp-&gt;instance_id());
4275       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4276     }
4277     default: ShouldNotReachHere();
4278     }
4279   }
4280 
4281   case AnyPtr: {                // Meeting two AnyPtrs
4282     // Found an AnyPtr type vs self-AryPtr type
4283     const TypePtr *tp = t-&gt;is_ptr();
4284     int offset = meet_offset(tp-&gt;offset());
4285     PTR ptr = meet_ptr(tp-&gt;ptr());
4286     const TypePtr* speculative = xmeet_speculative(tp);
4287     int depth = meet_inline_depth(tp-&gt;inline_depth());
4288     switch (tp-&gt;ptr()) {
4289     case TopPTR:
4290       return this;
4291     case BotPTR:
4292     case NotNull:
4293       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4294     case Null:
4295       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4296       // else fall through to AnyNull
4297     case AnyNull: {
4298       int instance_id = meet_instance_id(InstanceTop);
4299       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4300                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4301     }
4302     default: ShouldNotReachHere();
4303     }
4304   }
4305 
4306   case MetadataPtr:
4307   case KlassPtr:
4308   case RawPtr: return TypePtr::BOTTOM;
4309 
4310   case AryPtr: {                // Meeting 2 references?
4311     const TypeAryPtr *tap = t-&gt;is_aryptr();
4312     int off = meet_offset(tap-&gt;offset());
4313     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4314     PTR ptr = meet_ptr(tap-&gt;ptr());
4315     int instance_id = meet_instance_id(tap-&gt;instance_id());
4316     const TypePtr* speculative = xmeet_speculative(tap);
4317     int depth = meet_inline_depth(tap-&gt;inline_depth());
4318     ciKlass* lazy_klass = NULL;
4319     if (tary-&gt;_elem-&gt;isa_int()) {
4320       // Integral array element types have irrelevant lattice relations.
4321       // It is the klass that determines array layout, not the element type.
4322       if (_klass == NULL)
4323         lazy_klass = tap-&gt;_klass;
4324       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4325         lazy_klass = _klass;
4326       } else {
4327         // Something like byte[int+] meets char[int+].
4328         // This must fall to bottom, not (int[-128..65535])[int+].
4329         instance_id = InstanceBot;
4330         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4331       }
4332     } else // Non integral arrays.
4333       // Must fall to bottom if exact klasses in upper lattice
4334       // are not equal or super klass is exact.
4335       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4336           // meet with top[] and bottom[] are processed further down:
4337           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;
4338           // both are exact and not equal:
4339           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4340            // &#39;tap&#39;  is exact and super or unrelated:
4341            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4342            // &#39;this&#39; is exact and super or unrelated:
4343            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4344       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {
4345         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4346       }
4347       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4348     }
4349 
4350     bool xk = false;
4351     switch (tap-&gt;ptr()) {
4352     case AnyNull:
4353     case TopPTR:
4354       // Compute new klass on demand, do not use tap-&gt;_klass
4355       if (below_centerline(this-&gt;_ptr)) {
4356         xk = this-&gt;_klass_is_exact;
4357       } else {
4358         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4359       }
4360       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4361     case Constant: {
4362       ciObject* o = const_oop();
4363       if( _ptr == Constant ) {
4364         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4365           xk = (klass() == tap-&gt;klass());
4366           ptr = NotNull;
4367           o = NULL;
4368           instance_id = InstanceBot;
4369         } else {
4370           xk = true;
4371         }
4372       } else if(above_centerline(_ptr)) {
4373         o = tap-&gt;const_oop();
4374         xk = true;
4375       } else {
4376         // Only precise for identical arrays
4377         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4378       }
4379       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4380     }
4381     case NotNull:
4382     case BotPTR:
4383       // Compute new klass on demand, do not use tap-&gt;_klass
4384       if (above_centerline(this-&gt;_ptr))
4385             xk = tap-&gt;_klass_is_exact;
4386       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4387               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4388       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4389     default: ShouldNotReachHere();
4390     }
4391   }
4392 
4393   // All arrays inherit from Object class
4394   case InstPtr: {
4395     const TypeInstPtr *tp = t-&gt;is_instptr();
4396     int offset = meet_offset(tp-&gt;offset());
4397     PTR ptr = meet_ptr(tp-&gt;ptr());
4398     int instance_id = meet_instance_id(tp-&gt;instance_id());
4399     const TypePtr* speculative = xmeet_speculative(tp);
4400     int depth = meet_inline_depth(tp-&gt;inline_depth());
4401     switch (ptr) {
4402     case TopPTR:
4403     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4404       // For instances when a subclass meets a superclass we fall
4405       // below the centerline when the superclass is exact. We need to
4406       // do the same here.
4407       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4408         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4409       } else {
4410         // cannot subclass, so the meet has to fall badly below the centerline
4411         ptr = NotNull;
4412         instance_id = InstanceBot;
4413         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4414       }
4415     case Constant:
4416     case NotNull:
4417     case BotPTR:                // Fall down to object klass
4418       // LCA is object_klass, but if we subclass from the top we can do better
4419       if (above_centerline(tp-&gt;ptr())) {
4420         // If &#39;tp&#39;  is above the centerline and it is Object class
4421         // then we can subclass in the Java class hierarchy.
4422         // For instances when a subclass meets a superclass we fall
4423         // below the centerline when the superclass is exact. We need
4424         // to do the same here.
4425         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4426           // that is, my array type is a subtype of &#39;tp&#39; klass
4427           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4428                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4429         }
4430       }
4431       // The other case cannot happen, since t cannot be a subtype of an array.
4432       // The meet falls down to Object class below centerline.
4433       if( ptr == Constant )
4434          ptr = NotNull;
4435       instance_id = InstanceBot;
4436       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4437     default: typerr(t);
4438     }
4439   }
4440   }
4441   return this;                  // Lint noise
4442 }
4443 
4444 //------------------------------xdual------------------------------------------
4445 // Dual: compute field-by-field dual
4446 const Type *TypeAryPtr::xdual() const {
4447   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4448 }
4449 
4450 //----------------------interface_vs_oop---------------------------------------
4451 #ifdef ASSERT
4452 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4453   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4454   if (t_aryptr) {
4455     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4456   }
4457   return false;
4458 }
4459 #endif
4460 
4461 //------------------------------dump2------------------------------------------
4462 #ifndef PRODUCT
4463 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4464   _ary-&gt;dump2(d,depth,st);
4465   switch( _ptr ) {
4466   case Constant:
4467     const_oop()-&gt;print(st);
4468     break;
4469   case BotPTR:
4470     if (!WizardMode &amp;&amp; !Verbose) {
4471       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4472       break;
4473     }
4474   case TopPTR:
4475   case AnyNull:
4476   case NotNull:
4477     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4478     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4479     break;
4480   default:
4481     break;
4482   }
4483 
4484   if( _offset != 0 ) {
4485     int header_size = objArrayOopDesc::header_size() * wordSize;
4486     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);
4487     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);
4488     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);
4489     else {
4490       BasicType basic_elem_type = elem()-&gt;basic_type();
4491       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4492       int elem_size = type2aelembytes(basic_elem_type);
4493       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);
4494     }
4495   }
4496   st-&gt;print(&quot; *&quot;);
4497   if (_instance_id == InstanceTop)
4498     st-&gt;print(&quot;,iid=top&quot;);
4499   else if (_instance_id != InstanceBot)
4500     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4501 
4502   dump_inline_depth(st);
4503   dump_speculative(st);
4504 }
4505 #endif
4506 
4507 bool TypeAryPtr::empty(void) const {
4508   if (_ary-&gt;empty())       return true;
4509   return TypeOopPtr::empty();
4510 }
4511 
4512 //------------------------------add_offset-------------------------------------
4513 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4514   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
4515 }
4516 
4517 const Type *TypeAryPtr::remove_speculative() const {
4518   if (_speculative == NULL) {
4519     return this;
4520   }
4521   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4522   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);
4523 }
4524 
4525 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4526   if (!UseInlineDepthForSpeculativeTypes) {
4527     return this;
4528   }
4529   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);
4530 }
4531 
4532 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4533   assert(is_known_instance(), &quot;should be known&quot;);
4534   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4535 }
4536 
4537 //=============================================================================
4538 
4539 //------------------------------hash-------------------------------------------
4540 // Type-specific hashing function.
4541 int TypeNarrowPtr::hash(void) const {
4542   return _ptrtype-&gt;hash() + 7;
4543 }
4544 
4545 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4546   return _ptrtype-&gt;singleton();
4547 }
4548 
4549 bool TypeNarrowPtr::empty(void) const {
4550   return _ptrtype-&gt;empty();
4551 }
4552 
4553 intptr_t TypeNarrowPtr::get_con() const {
4554   return _ptrtype-&gt;get_con();
4555 }
4556 
4557 bool TypeNarrowPtr::eq( const Type *t ) const {
4558   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
4559   if (tc != NULL) {
4560     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
4561       return false;
4562     }
4563     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
4564   }
4565   return false;
4566 }
4567 
4568 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
4569   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
4570   return make_same_narrowptr(odual);
4571 }
4572 
4573 
4574 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
4575   if (isa_same_narrowptr(kills)) {
4576     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
4577     if (ft-&gt;empty())
4578       return Type::TOP;           // Canonical empty value
4579     if (ft-&gt;isa_ptr()) {
4580       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
4581     }
4582     return ft;
4583   } else if (kills-&gt;isa_ptr()) {
4584     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
4585     if (ft-&gt;empty())
4586       return Type::TOP;           // Canonical empty value
4587     return ft;
4588   } else {
4589     return Type::TOP;
4590   }
4591 }
4592 
4593 //------------------------------xmeet------------------------------------------
4594 // Compute the MEET of two types.  It returns a new Type object.
4595 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
4596   // Perform a fast test for common case; meeting the same types together.
4597   if( this == t ) return this;  // Meeting same type-rep?
4598 
4599   if (t-&gt;base() == base()) {
4600     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
4601     if (result-&gt;isa_ptr()) {
4602       return make_hash_same_narrowptr(result-&gt;is_ptr());
4603     }
4604     return result;
4605   }
4606 
4607   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4608   switch (t-&gt;base()) {          // switch on original type
4609 
4610   case Int:                     // Mixing ints &amp; oops happens when javac
4611   case Long:                    // reuses local variables
4612   case FloatTop:
4613   case FloatCon:
4614   case FloatBot:
4615   case DoubleTop:
4616   case DoubleCon:
4617   case DoubleBot:
4618   case AnyPtr:
4619   case RawPtr:
4620   case OopPtr:
4621   case InstPtr:
4622   case AryPtr:
4623   case MetadataPtr:
4624   case KlassPtr:
4625   case NarrowOop:
4626   case NarrowKlass:
4627 
4628   case Bottom:                  // Ye Olde Default
4629     return Type::BOTTOM;
4630   case Top:
4631     return this;
4632 
4633   default:                      // All else is a mistake
4634     typerr(t);
4635 
4636   } // End of switch
4637 
4638   return this;
4639 }
4640 
4641 #ifndef PRODUCT
4642 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4643   _ptrtype-&gt;dump2(d, depth, st);
4644 }
4645 #endif
4646 
4647 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4648 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4649 
4650 
4651 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4652   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
4653 }
4654 
4655 const Type* TypeNarrowOop::remove_speculative() const {
4656   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
4657 }
4658 
4659 const Type* TypeNarrowOop::cleanup_speculative() const {
4660   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
4661 }
4662 
4663 #ifndef PRODUCT
4664 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4665   st-&gt;print(&quot;narrowoop: &quot;);
4666   TypeNarrowPtr::dump2(d, depth, st);
4667 }
4668 #endif
4669 
4670 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
4671 
4672 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
4673   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
4674 }
4675 
4676 #ifndef PRODUCT
4677 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4678   st-&gt;print(&quot;narrowklass: &quot;);
4679   TypeNarrowPtr::dump2(d, depth, st);
4680 }
4681 #endif
4682 
4683 
4684 //------------------------------eq---------------------------------------------
4685 // Structural equality check for Type representations
4686 bool TypeMetadataPtr::eq( const Type *t ) const {
4687   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
4688   ciMetadata* one = metadata();
4689   ciMetadata* two = a-&gt;metadata();
4690   if (one == NULL || two == NULL) {
4691     return (one == two) &amp;&amp; TypePtr::eq(t);
4692   } else {
4693     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4694   }
4695 }
4696 
4697 //------------------------------hash-------------------------------------------
4698 // Type-specific hashing function.
4699 int TypeMetadataPtr::hash(void) const {
4700   return
4701     (metadata() ? metadata()-&gt;hash() : 0) +
4702     TypePtr::hash();
4703 }
4704 
4705 //------------------------------singleton--------------------------------------
4706 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4707 // constants
4708 bool TypeMetadataPtr::singleton(void) const {
4709   // detune optimizer to not generate constant metadata + constant offset as a constant!
4710   // TopPTR, Null, AnyNull, Constant are all singletons
4711   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4712 }
4713 
4714 //------------------------------add_offset-------------------------------------
4715 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4716   return make( _ptr, _metadata, xadd_offset(offset));
4717 }
4718 
4719 //-----------------------------filter------------------------------------------
4720 // Do not allow interface-vs.-noninterface joins to collapse to top.
4721 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4722   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4723   if (ft == NULL || ft-&gt;empty())
4724     return Type::TOP;           // Canonical empty value
4725   return ft;
4726 }
4727 
4728  //------------------------------get_con----------------------------------------
4729 intptr_t TypeMetadataPtr::get_con() const {
4730   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
4731   assert( _offset &gt;= 0, &quot;&quot; );
4732 
4733   if (_offset != 0) {
4734     // After being ported to the compiler interface, the compiler no longer
4735     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4736     // to a handle at compile time.  This handle is embedded in the generated
4737     // code and dereferenced at the time the nmethod is made.  Until that time,
4738     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4739     // have access to the addresses!).  This does not seem to currently happen,
4740     // but this assertion here is to help prevent its occurence.
4741     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4742     ShouldNotReachHere();
4743   }
4744 
4745   return (intptr_t)metadata()-&gt;constant_encoding();
4746 }
4747 
4748 //------------------------------cast_to_ptr_type-------------------------------
4749 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4750   if( ptr == _ptr ) return this;
4751   return make(ptr, metadata(), _offset);
4752 }
4753 
4754 //------------------------------meet-------------------------------------------
4755 // Compute the MEET of two types.  It returns a new Type object.
4756 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
4757   // Perform a fast test for common case; meeting the same types together.
4758   if( this == t ) return this;  // Meeting same type-rep?
4759 
4760   // Current &quot;this-&gt;_base&quot; is OopPtr
4761   switch (t-&gt;base()) {          // switch on original type
4762 
4763   case Int:                     // Mixing ints &amp; oops happens when javac
4764   case Long:                    // reuses local variables
4765   case FloatTop:
4766   case FloatCon:
4767   case FloatBot:
4768   case DoubleTop:
4769   case DoubleCon:
4770   case DoubleBot:
4771   case NarrowOop:
4772   case NarrowKlass:
4773   case Bottom:                  // Ye Olde Default
4774     return Type::BOTTOM;
4775   case Top:
4776     return this;
4777 
4778   default:                      // All else is a mistake
4779     typerr(t);
4780 
4781   case AnyPtr: {
4782     // Found an AnyPtr type vs self-OopPtr type
4783     const TypePtr *tp = t-&gt;is_ptr();
4784     int offset = meet_offset(tp-&gt;offset());
4785     PTR ptr = meet_ptr(tp-&gt;ptr());
4786     switch (tp-&gt;ptr()) {
4787     case Null:
4788       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4789       // else fall through:
4790     case TopPTR:
4791     case AnyNull: {
4792       return make(ptr, _metadata, offset);
4793     }
4794     case BotPTR:
4795     case NotNull:
4796       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4797     default: typerr(t);
4798     }
4799   }
4800 
4801   case RawPtr:
4802   case KlassPtr:
4803   case OopPtr:
4804   case InstPtr:
4805   case AryPtr:
4806     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4807 
4808   case MetadataPtr: {
4809     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
4810     int offset = meet_offset(tp-&gt;offset());
4811     PTR tptr = tp-&gt;ptr();
4812     PTR ptr = meet_ptr(tptr);
4813     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4814     if (tptr == TopPTR || _ptr == TopPTR ||
4815         metadata()-&gt;equals(tp-&gt;metadata())) {
4816       return make(ptr, md, offset);
4817     }
4818     // metadata is different
4819     if( ptr == Constant ) {  // Cannot be equal constants, so...
4820       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4821       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4822       ptr = NotNull;            // Fall down in lattice
4823     }
4824     return make(ptr, NULL, offset);
4825     break;
4826   }
4827   } // End of switch
4828   return this;                  // Return the double constant
4829 }
4830 
4831 
4832 //------------------------------xdual------------------------------------------
4833 // Dual of a pure metadata pointer.
4834 const Type *TypeMetadataPtr::xdual() const {
4835   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4836 }
4837 
4838 //------------------------------dump2------------------------------------------
4839 #ifndef PRODUCT
4840 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4841   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4842   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
4843   switch( _offset ) {
4844   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4845   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4846   case         0: break;
4847   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
4848   }
4849 }
4850 #endif
4851 
4852 
4853 //=============================================================================
4854 // Convenience common pre-built type.
4855 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4856 
4857 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):
4858   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4859 }
4860 
4861 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
4862   return make(Constant, m, 0);
4863 }
4864 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
4865   return make(Constant, m, 0);
4866 }
4867 
4868 //------------------------------make-------------------------------------------
4869 // Create a meta data constant
4870 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {
4871   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4872   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4873 }
4874 
4875 
4876 //=============================================================================
4877 // Convenience common pre-built types.
4878 
4879 // Not-null object klass or below
4880 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4881 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4882 
4883 //------------------------------TypeKlassPtr-----------------------------------
4884 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )
4885   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {
4886 }
4887 
4888 //------------------------------make-------------------------------------------
4889 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
4890 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {
4891   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);
4892   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
4893   TypeKlassPtr *r =
4894     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();
4895 
4896   return r;
4897 }
4898 
4899 //------------------------------eq---------------------------------------------
4900 // Structural equality check for Type representations
4901 bool TypeKlassPtr::eq( const Type *t ) const {
4902   const TypeKlassPtr *p = t-&gt;is_klassptr();
4903   return
4904     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4905     TypePtr::eq(p);
4906 }
4907 
4908 //------------------------------hash-------------------------------------------
4909 // Type-specific hashing function.
4910 int TypeKlassPtr::hash(void) const {
4911   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());
4912 }
4913 
4914 //------------------------------singleton--------------------------------------
4915 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4916 // constants
4917 bool TypeKlassPtr::singleton(void) const {
4918   // detune optimizer to not generate constant klass + constant offset as a constant!
4919   // TopPTR, Null, AnyNull, Constant are all singletons
4920   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4921 }
4922 
4923 // Do not allow interface-vs.-noninterface joins to collapse to top.
4924 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4925   // logic here mirrors the one from TypeOopPtr::filter. See comments
4926   // there.
4927   const Type* ft = join_helper(kills, include_speculative);
4928   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4929   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4930 
4931   if (ft-&gt;empty()) {
4932     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
4933       return kills;             // Uplift to interface
4934 
4935     return Type::TOP;           // Canonical empty value
4936   }
4937 
4938   // Interface klass type could be exact in opposite to interface type,
4939   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4940   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4941       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4942       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4943       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4944     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4945   }
4946 
4947   return ft;
4948 }
4949 
4950 //----------------------compute_klass------------------------------------------
4951 // Compute the defining klass for this class
4952 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4953   // Compute _klass based on element type.
4954   ciKlass* k_ary = NULL;
4955   const TypeInstPtr *tinst;
4956   const TypeAryPtr *tary;
4957   const Type* el = elem();
4958   if (el-&gt;isa_narrowoop()) {
4959     el = el-&gt;make_ptr();
4960   }
4961 
4962   // Get element klass
4963   if ((tinst = el-&gt;isa_instptr()) != NULL) {
4964     // Compute array klass from element klass
4965     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());
4966   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4967     // Compute array klass from element klass
4968     ciKlass* k_elem = tary-&gt;klass();
4969     // If element type is something like bottom[], k_elem will be null.
4970     if (k_elem != NULL)
4971       k_ary = ciObjArrayKlass::make(k_elem);
4972   } else if ((el-&gt;base() == Type::Top) ||
4973              (el-&gt;base() == Type::Bottom)) {
4974     // element type of Bottom occurs from meet of basic type
4975     // and object; Top occurs when doing join on Bottom.
4976     // Leave k_ary at NULL.
4977   } else {
4978     // Cannot compute array klass directly from basic type,
4979     // since subtypes of TypeInt all have basic type T_INT.
4980 #ifdef ASSERT
4981     if (verify &amp;&amp; el-&gt;isa_int()) {
4982       // Check simple cases when verifying klass.
4983       BasicType bt = T_ILLEGAL;
4984       if (el == TypeInt::BYTE) {
4985         bt = T_BYTE;
4986       } else if (el == TypeInt::SHORT) {
4987         bt = T_SHORT;
4988       } else if (el == TypeInt::CHAR) {
4989         bt = T_CHAR;
4990       } else if (el == TypeInt::INT) {
4991         bt = T_INT;
4992       } else {
4993         return _klass; // just return specified klass
4994       }
4995       return ciTypeArrayKlass::make(bt);
4996     }
4997 #endif
4998     assert(!el-&gt;isa_int(),
4999            &quot;integral arrays must be pre-equipped with a class&quot;);
5000     // Compute array klass directly from basic type
5001     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
5002   }
5003   return k_ary;
5004 }
5005 
5006 //------------------------------klass------------------------------------------
5007 // Return the defining klass for this class
5008 ciKlass* TypeAryPtr::klass() const {
5009   if( _klass ) return _klass;   // Return cached value, if possible
5010 
5011   // Oops, need to compute _klass and cache it
5012   ciKlass* k_ary = compute_klass();
5013 
5014   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
5015     // The _klass field acts as a cache of the underlying
5016     // ciKlass for this array type.  In order to set the field,
5017     // we need to cast away const-ness.
5018     //
5019     // IMPORTANT NOTE: we *never* set the _klass field for the
5020     // type TypeAryPtr::OOPS.  This Type is shared between all
5021     // active compilations.  However, the ciKlass which represents
5022     // this Type is *not* shared between compilations, so caching
5023     // this value would result in fetching a dangling pointer.
5024     //
5025     // Recomputing the underlying ciKlass for each request is
5026     // a bit less efficient than caching, but calls to
5027     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5028     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5029     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5030         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {
5031       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5032     }
5033   }
5034   return k_ary;
5035 }
5036 
5037 
5038 //------------------------------add_offset-------------------------------------
5039 // Access internals of klass object
5040 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5041   return make( _ptr, klass(), xadd_offset(offset) );
5042 }
5043 
5044 //------------------------------cast_to_ptr_type-------------------------------
5045 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5046   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5047   if( ptr == _ptr ) return this;
5048   return make(ptr, _klass, _offset);
5049 }
5050 
5051 
5052 //-----------------------------cast_to_exactness-------------------------------
5053 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5054   if( klass_is_exact == _klass_is_exact ) return this;
5055   if (!UseExactTypes)  return this;
5056   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);
5057 }
5058 
5059 
5060 //-----------------------------as_instance_type--------------------------------
5061 // Corresponding type for an instance of the given class.
5062 // It will be NotNull, and exact if and only if the klass type is exact.
5063 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5064   ciKlass* k = klass();
5065   bool    xk = klass_is_exact();
5066   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5067   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5068   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5069   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5070   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5071 }
5072 
5073 
5074 //------------------------------xmeet------------------------------------------
5075 // Compute the MEET of two types, return a new Type object.
5076 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5077   // Perform a fast test for common case; meeting the same types together.
5078   if( this == t ) return this;  // Meeting same type-rep?
5079 
5080   // Current &quot;this-&gt;_base&quot; is Pointer
5081   switch (t-&gt;base()) {          // switch on original type
5082 
5083   case Int:                     // Mixing ints &amp; oops happens when javac
5084   case Long:                    // reuses local variables
5085   case FloatTop:
5086   case FloatCon:
5087   case FloatBot:
5088   case DoubleTop:
5089   case DoubleCon:
5090   case DoubleBot:
5091   case NarrowOop:
5092   case NarrowKlass:
5093   case Bottom:                  // Ye Olde Default
5094     return Type::BOTTOM;
5095   case Top:
5096     return this;
5097 
5098   default:                      // All else is a mistake
5099     typerr(t);
5100 
5101   case AnyPtr: {                // Meeting to AnyPtrs
5102     // Found an AnyPtr type vs self-KlassPtr type
5103     const TypePtr *tp = t-&gt;is_ptr();
5104     int offset = meet_offset(tp-&gt;offset());
5105     PTR ptr = meet_ptr(tp-&gt;ptr());
5106     switch (tp-&gt;ptr()) {
5107     case TopPTR:
5108       return this;
5109     case Null:
5110       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5111     case AnyNull:
5112       return make( ptr, klass(), offset );
5113     case BotPTR:
5114     case NotNull:
5115       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5116     default: typerr(t);
5117     }
5118   }
5119 
5120   case RawPtr:
5121   case MetadataPtr:
5122   case OopPtr:
5123   case AryPtr:                  // Meet with AryPtr
5124   case InstPtr:                 // Meet with InstPtr
5125     return TypePtr::BOTTOM;
5126 
5127   //
5128   //             A-top         }
5129   //           /   |   \       }  Tops
5130   //       B-top A-any C-top   }
5131   //          | /  |  \ |      }  Any-nulls
5132   //       B-any   |   C-any   }
5133   //          |    |    |
5134   //       B-con A-con C-con   } constants; not comparable across classes
5135   //          |    |    |
5136   //       B-not   |   C-not   }
5137   //          | \  |  / |      }  not-nulls
5138   //       B-bot A-not C-bot   }
5139   //           \   |   /       }  Bottoms
5140   //             A-bot         }
5141   //
5142 
5143   case KlassPtr: {  // Meet two KlassPtr types
5144     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5145     int  off     = meet_offset(tkls-&gt;offset());
5146     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5147 
5148     // Check for easy case; klasses are equal (and perhaps not loaded!)
5149     // If we have constants, then we created oops so classes are loaded
5150     // and we can handle the constants further down.  This case handles
5151     // not-loaded classes
5152     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {
5153       return make( ptr, klass(), off );
5154     }
5155 
5156     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5157     ciKlass* tkls_klass = tkls-&gt;klass();
5158     ciKlass* this_klass = this-&gt;klass();
5159     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5160     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5161 
5162     // If &#39;this&#39; type is above the centerline and is a superclass of the
5163     // other, we can treat &#39;this&#39; as having the same type as the other.
5164     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5165         tkls_klass-&gt;is_subtype_of(this_klass)) {
5166       this_klass = tkls_klass;
5167     }
5168     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5169     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5170     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5171         this_klass-&gt;is_subtype_of(tkls_klass)) {
5172       tkls_klass = this_klass;
5173     }
5174 
5175     // Check for classes now being equal
5176     if (tkls_klass-&gt;equals(this_klass)) {
5177       // If the klasses are equal, the constants may still differ.  Fall to
5178       // NotNull if they do (neither constant is NULL; that is a special case
5179       // handled elsewhere).
5180       if( ptr == Constant ) {
5181         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5182             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5183         else if (above_centerline(this-&gt;ptr()));
5184         else if (above_centerline(tkls-&gt;ptr()));
5185         else
5186           ptr = NotNull;
5187       }
5188       return make( ptr, this_klass, off );
5189     } // Else classes are not equal
5190 
5191     // Since klasses are different, we require the LCA in the Java
5192     // class hierarchy - which means we have to fall to at least NotNull.
5193     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5194       ptr = NotNull;
5195     // Now we find the LCA of Java classes
5196     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5197     return   make( ptr, k, off );
5198   } // End of case KlassPtr
5199 
5200   } // End of switch
5201   return this;                  // Return the double constant
5202 }
5203 
5204 //------------------------------xdual------------------------------------------
5205 // Dual: compute field-by-field dual
5206 const Type    *TypeKlassPtr::xdual() const {
5207   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );
5208 }
5209 
5210 //------------------------------get_con----------------------------------------
5211 intptr_t TypeKlassPtr::get_con() const {
5212   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5213   assert( _offset &gt;= 0, &quot;&quot; );
5214 
5215   if (_offset != 0) {
5216     // After being ported to the compiler interface, the compiler no longer
5217     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5218     // to a handle at compile time.  This handle is embedded in the generated
5219     // code and dereferenced at the time the nmethod is made.  Until that time,
5220     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5221     // have access to the addresses!).  This does not seem to currently happen,
5222     // but this assertion here is to help prevent its occurence.
5223     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5224     ShouldNotReachHere();
5225   }
5226 
5227   return (intptr_t)klass()-&gt;constant_encoding();
5228 }
5229 //------------------------------dump2------------------------------------------
5230 // Dump Klass Type
5231 #ifndef PRODUCT
5232 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5233   switch( _ptr ) {
5234   case Constant:
5235     st-&gt;print(&quot;precise &quot;);
5236   case NotNull:
5237     {
5238       const char *name = klass()-&gt;name()-&gt;as_utf8();
5239       if( name ) {
5240         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5241       } else {
5242         ShouldNotReachHere();
5243       }
5244     }
5245   case BotPTR:
5246     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5247   case TopPTR:
5248   case AnyNull:
5249     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5250     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5251     break;
5252   default:
5253     break;
5254   }
5255 
5256   if( _offset ) {               // Dump offset, if any
5257     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }
5258     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }
5259     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }
5260   }
5261 
5262   st-&gt;print(&quot; *&quot;);
5263 }
5264 #endif
5265 
5266 
5267 
5268 //=============================================================================
5269 // Convenience common pre-built types.
5270 
5271 //------------------------------make-------------------------------------------
5272 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {
5273   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();
5274 }
5275 
5276 //------------------------------make-------------------------------------------
5277 const TypeFunc *TypeFunc::make(ciMethod* method) {
5278   Compile* C = Compile::current();
5279   const TypeFunc* tf = C-&gt;last_tf(method); // check cache
5280   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5281   const TypeTuple *domain;
5282   if (method-&gt;is_static()) {
5283     domain = TypeTuple::make_domain(NULL, method-&gt;signature());
5284   } else {
5285     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());
5286   }
5287   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());
5288   tf = TypeFunc::make(domain, range);
5289   C-&gt;set_last_tf(method, tf);  // fill cache
5290   return tf;
5291 }
5292 
5293 //------------------------------meet-------------------------------------------
5294 // Compute the MEET of two types.  It returns a new Type object.
5295 const Type *TypeFunc::xmeet( const Type *t ) const {
5296   // Perform a fast test for common case; meeting the same types together.
5297   if( this == t ) return this;  // Meeting same type-rep?
5298 
5299   // Current &quot;this-&gt;_base&quot; is Func
5300   switch (t-&gt;base()) {          // switch on original type
5301 
5302   case Bottom:                  // Ye Olde Default
5303     return t;
5304 
5305   default:                      // All else is a mistake
5306     typerr(t);
5307 
5308   case Top:
5309     break;
5310   }
5311   return this;                  // Return the double constant
5312 }
5313 
5314 //------------------------------xdual------------------------------------------
5315 // Dual: compute field-by-field dual
5316 const Type *TypeFunc::xdual() const {
5317   return this;
5318 }
5319 
5320 //------------------------------eq---------------------------------------------
5321 // Structural equality check for Type representations
5322 bool TypeFunc::eq( const Type *t ) const {
5323   const TypeFunc *a = (const TypeFunc*)t;
5324   return _domain == a-&gt;_domain &amp;&amp;
5325     _range == a-&gt;_range;
5326 }
5327 
5328 //------------------------------hash-------------------------------------------
5329 // Type-specific hashing function.
5330 int TypeFunc::hash(void) const {
5331   return (intptr_t)_domain + (intptr_t)_range;
5332 }
5333 
5334 //------------------------------dump2------------------------------------------
5335 // Dump Function Type
5336 #ifndef PRODUCT
5337 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5338   if( _range-&gt;cnt() &lt;= Parms )
5339     st-&gt;print(&quot;void&quot;);
5340   else {
5341     uint i;
5342     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {
5343       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5344       st-&gt;print(&quot;/&quot;);
5345     }
5346     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5347   }
5348   st-&gt;print(&quot; &quot;);
5349   st-&gt;print(&quot;( &quot;);
5350   if( !depth || d[this] ) {     // Check for recursive dump
5351     st-&gt;print(&quot;...)&quot;);
5352     return;
5353   }
5354   d.Insert((void*)this,(void*)this);    // Stop recursion
5355   if (Parms &lt; _domain-&gt;cnt())
5356     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5357   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {
5358     st-&gt;print(&quot;, &quot;);
5359     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5360   }
5361   st-&gt;print(&quot; )&quot;);
5362 }
5363 #endif
5364 
5365 //------------------------------singleton--------------------------------------
5366 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5367 // constants (Ldi nodes).  Singletons are integer, float or double constants
5368 // or a single symbol.
5369 bool TypeFunc::singleton(void) const {
5370   return false;                 // Never a singleton
5371 }
5372 
5373 bool TypeFunc::empty(void) const {
5374   return false;                 // Never empty
5375 }
5376 
5377 
5378 BasicType TypeFunc::return_type() const{
5379   if (range()-&gt;cnt() == TypeFunc::Parms) {
5380     return T_VOID;
5381   }
5382   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5383 }
    </pre>
  </body>
</html>
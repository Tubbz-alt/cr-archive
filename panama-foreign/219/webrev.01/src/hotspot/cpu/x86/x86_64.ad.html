<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 int MachCallNativeNode::ret_addr_offset() {
  463   int offset = 13; // movq r10,#addr; callq (r10)
  464   return offset;
  465 }
  466 //
  467 // Compute padding required for nodes which need alignment
  468 //
  469 
  470 // The address of the call instruction needs to be 4-byte aligned to
  471 // ensure that it does not span a cache line so that it can be patched.
  472 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  473 {
  474   current_offset += clear_avx_size(); // skip vzeroupper
  475   current_offset += 1; // skip call opcode byte
  476   return align_up(current_offset, alignment_required()) - current_offset;
  477 }
  478 
  479 // The address of the call instruction needs to be 4-byte aligned to
  480 // ensure that it does not span a cache line so that it can be patched.
  481 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  482 {
  483   current_offset += clear_avx_size(); // skip vzeroupper
  484   current_offset += 11; // skip movq instruction + call opcode byte
  485   return align_up(current_offset, alignment_required()) - current_offset;
  486 }
  487 
  488 // EMIT_RM()
  489 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  490   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  491   cbuf.insts()-&gt;emit_int8(c);
  492 }
  493 
  494 // EMIT_CC()
  495 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  496   unsigned char c = (unsigned char) (f1 | f2);
  497   cbuf.insts()-&gt;emit_int8(c);
  498 }
  499 
  500 // EMIT_OPCODE()
  501 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  502   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  503 }
  504 
  505 // EMIT_OPCODE() w/ relocation information
  506 void emit_opcode(CodeBuffer &amp;cbuf,
  507                  int code, relocInfo::relocType reloc, int offset, int format)
  508 {
  509   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  510   emit_opcode(cbuf, code);
  511 }
  512 
  513 // EMIT_D8()
  514 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  515   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  516 }
  517 
  518 // EMIT_D16()
  519 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  520   cbuf.insts()-&gt;emit_int16(d16);
  521 }
  522 
  523 // EMIT_D32()
  524 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  525   cbuf.insts()-&gt;emit_int32(d32);
  526 }
  527 
  528 // EMIT_D64()
  529 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  530   cbuf.insts()-&gt;emit_int64(d64);
  531 }
  532 
  533 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  534 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  535                     int d32,
  536                     relocInfo::relocType reloc,
  537                     int format)
  538 {
  539   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  540   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  541   cbuf.insts()-&gt;emit_int32(d32);
  542 }
  543 
  544 // emit 32 bit value and construct relocation entry from RelocationHolder
  545 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  546 #ifdef ASSERT
  547   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  548       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  549     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  550     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  551   }
  552 #endif
  553   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  554   cbuf.insts()-&gt;emit_int32(d32);
  555 }
  556 
  557 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  558   address next_ip = cbuf.insts_end() + 4;
  559   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  560                  external_word_Relocation::spec(addr),
  561                  RELOC_DISP32);
  562 }
  563 
  564 
  565 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  566 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  567   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  568   cbuf.insts()-&gt;emit_int64(d64);
  569 }
  570 
  571 // emit 64 bit value and construct relocation entry from RelocationHolder
  572 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  573 #ifdef ASSERT
  574   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  575       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  576     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  577     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  578   }
  579 #endif
  580   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  581   cbuf.insts()-&gt;emit_int64(d64);
  582 }
  583 
  584 // Access stack slot for load or store
  585 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  586 {
  587   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  588   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  589     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  592   } else {
  593     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  594     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  595     emit_d32(cbuf, disp);     // Displacement // R/M byte
  596   }
  597 }
  598 
  599    // rRegI ereg, memory mem) %{    // emit_reg_mem
  600 void encode_RegMem(CodeBuffer &amp;cbuf,
  601                    int reg,
  602                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  603 {
  604   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  605   int regenc = reg &amp; 7;
  606   int baseenc = base &amp; 7;
  607   int indexenc = index &amp; 7;
  608 
  609   // There is no index &amp; no scale, use form without SIB byte
  610   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  611     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  612     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  613       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  614     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  615       // If 8-bit displacement, mode 0x1
  616       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  617       emit_d8(cbuf, disp);
  618     } else {
  619       // If 32-bit displacement
  620       if (base == -1) { // Special flag for absolute address
  621         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  622         if (disp_reloc != relocInfo::none) {
  623           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  624         } else {
  625           emit_d32(cbuf, disp);
  626         }
  627       } else {
  628         // Normal base + offset
  629         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  630         if (disp_reloc != relocInfo::none) {
  631           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  632         } else {
  633           emit_d32(cbuf, disp);
  634         }
  635       }
  636     }
  637   } else {
  638     // Else, encode with the SIB byte
  639     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  640     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  641       // If no displacement
  642       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  643       emit_rm(cbuf, scale, indexenc, baseenc);
  644     } else {
  645       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  646         // If 8-bit displacement, mode 0x1
  647         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  648         emit_rm(cbuf, scale, indexenc, baseenc);
  649         emit_d8(cbuf, disp);
  650       } else {
  651         // If 32-bit displacement
  652         if (base == 0x04 ) {
  653           emit_rm(cbuf, 0x2, regenc, 0x4);
  654           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  655         } else {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, baseenc); // *
  658         }
  659         if (disp_reloc != relocInfo::none) {
  660           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  661         } else {
  662           emit_d32(cbuf, disp);
  663         }
  664       }
  665     }
  666   }
  667 }
  668 
  669 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  670 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  671   Label exit;
  672   __ jccb(Assembler::noParity, exit);
  673   __ pushf();
  674   //
  675   // comiss/ucomiss instructions set ZF,PF,CF flags and
  676   // zero OF,AF,SF for NaN values.
  677   // Fixup flags by zeroing ZF,PF so that compare of NaN
  678   // values returns &#39;less than&#39; result (CF is set).
  679   // Leave the rest of flags unchanged.
  680   //
  681   //    7 6 5 4 3 2 1 0
  682   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  683   //    0 0 1 0 1 0 1 1   (0x2B)
  684   //
  685   __ andq(Address(rsp, 0), 0xffffff2b);
  686   __ popf();
  687   __ bind(exit);
  688 }
  689 
  690 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  691   Label done;
  692   __ movl(dst, -1);
  693   __ jcc(Assembler::parity, done);
  694   __ jcc(Assembler::below, done);
  695   __ setb(Assembler::notEqual, dst);
  696   __ movzbl(dst, dst);
  697   __ bind(done);
  698 }
  699 
  700 // Math.min()    # Math.max()
  701 // --------------------------
  702 // ucomis[s/d]   #
  703 // ja   -&gt; b     # a
  704 // jp   -&gt; NaN   # NaN
  705 // jb   -&gt; a     # b
  706 // je            #
  707 // |-jz -&gt; a | b # a &amp; b
  708 // |    -&gt; a     #
  709 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  710                      XMMRegister a, XMMRegister b,
  711                      XMMRegister xmmt, Register rt,
  712                      bool min, bool single) {
  713 
  714   Label nan, zero, below, above, done;
  715 
  716   if (single)
  717     __ ucomiss(a, b);
  718   else
  719     __ ucomisd(a, b);
  720 
  721   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  722     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  723   else
  724     __ jccb(Assembler::above, done);
  725 
  726   __ jccb(Assembler::parity, nan);  // PF=1
  727   __ jccb(Assembler::below, below); // CF=1
  728 
  729   // equal
  730   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  731   if (single) {
  732     __ ucomiss(a, xmmt);
  733     __ jccb(Assembler::equal, zero);
  734 
  735     __ movflt(dst, a);
  736     __ jmp(done);
  737   }
  738   else {
  739     __ ucomisd(a, xmmt);
  740     __ jccb(Assembler::equal, zero);
  741 
  742     __ movdbl(dst, a);
  743     __ jmp(done);
  744   }
  745 
  746   __ bind(zero);
  747   if (min)
  748     __ vpor(dst, a, b, Assembler::AVX_128bit);
  749   else
  750     __ vpand(dst, a, b, Assembler::AVX_128bit);
  751 
  752   __ jmp(done);
  753 
  754   __ bind(above);
  755   if (single)
  756     __ movflt(dst, min ? b : a);
  757   else
  758     __ movdbl(dst, min ? b : a);
  759 
  760   __ jmp(done);
  761 
  762   __ bind(nan);
  763   if (single) {
  764     __ movl(rt, 0x7fc00000); // Float.NaN
  765     __ movdl(dst, rt);
  766   }
  767   else {
  768     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  769     __ movdq(dst, rt);
  770   }
  771   __ jmp(done);
  772 
  773   __ bind(below);
  774   if (single)
  775     __ movflt(dst, min ? a : b);
  776   else
  777     __ movdbl(dst, min ? a : b);
  778 
  779   __ bind(done);
  780 }
  781 
  782 //=============================================================================
  783 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  784 
  785 int ConstantTable::calculate_table_base_offset() const {
  786   return 0;  // absolute addressing, no offset
  787 }
  788 
  789 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  790 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  791   ShouldNotReachHere();
  792 }
  793 
  794 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  795   // Empty encoding
  796 }
  797 
  798 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  799   return 0;
  800 }
  801 
  802 #ifndef PRODUCT
  803 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  804   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  805 }
  806 #endif
  807 
  808 
  809 //=============================================================================
  810 #ifndef PRODUCT
  811 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  812   Compile* C = ra_-&gt;C;
  813 
  814   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  815   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  816   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  817   // Remove wordSize for return addr which is already pushed.
  818   framesize -= wordSize;
  819 
  820   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  821     framesize -= wordSize;
  822     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  823     st-&gt;print(&quot;\n\t&quot;);
  824     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  825     if (PreserveFramePointer) {
  826         st-&gt;print(&quot;\n\t&quot;);
  827         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  828     }
  829     if (framesize) {
  830       st-&gt;print(&quot;\n\t&quot;);
  831       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  832     }
  833   } else {
  834     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     st-&gt;print(&quot;\n\t&quot;);
  836     framesize -= wordSize;
  837     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  838     if (PreserveFramePointer) {
  839       st-&gt;print(&quot;\n\t&quot;);
  840       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  841       if (framesize &gt; 0) {
  842         st-&gt;print(&quot;\n\t&quot;);
  843         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  844       }
  845     }
  846   }
  847 
  848   if (VerifyStackAtCalls) {
  849     st-&gt;print(&quot;\n\t&quot;);
  850     framesize -= wordSize;
  851     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  852 #ifdef ASSERT
  853     st-&gt;print(&quot;\n\t&quot;);
  854     st-&gt;print(&quot;# stack alignment check&quot;);
  855 #endif
  856   }
  857   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  860     st-&gt;print(&quot;\n\t&quot;);
  861     st-&gt;print(&quot;je      fast_entry\t&quot;);
  862     st-&gt;print(&quot;\n\t&quot;);
  863     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  864     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  865   }
  866   st-&gt;cr();
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
  872   MacroAssembler _masm(&amp;cbuf);
  873 
  874   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  875   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  876 
  877   if (C-&gt;clinit_barrier_on_entry()) {
  878     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  879     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  893 
  894   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  895 
  896   if (C-&gt;has_mach_constant_base_node()) {
  897     // NOTE: We set the table base offset here because users might be
  898     // emitted before MachConstantBaseNode.
  899     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  900     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  901   }
  902 }
  903 
  904 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  905 {
  906   return MachNode::size(ra_); // too many variables; just compute it
  907                               // the hard way
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
  925   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  940                  &quot;testl   rax, [rscratch1]\t&quot;
  941                  &quot;# Safepoint: poll for GC&quot;);
  942   }
  943 }
  944 #endif
  945 
  946 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  947 {
  948   Compile* C = ra_-&gt;C;
  949   MacroAssembler _masm(&amp;cbuf);
  950 
  951   if (generate_vzeroupper(C)) {
  952     // Clear upper bits of YMM registers when current compiled code uses
  953     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  954     __ vzeroupper();
  955   }
  956 
  957   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  958   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  959   // Remove word for return adr already pushed
  960   // and RBP
  961   framesize -= 2*wordSize;
  962 
  963   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  964 
  965   if (framesize) {
  966     emit_opcode(cbuf, Assembler::REX_W);
  967     if (framesize &lt; 0x80) {
  968       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  970       emit_d8(cbuf, framesize);
  971     } else {
  972       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  973       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  974       emit_d32(cbuf, framesize);
  975     }
  976   }
  977 
  978   // popq rbp
  979   emit_opcode(cbuf, 0x58 | RBP_enc);
  980 
  981   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  982     __ reserved_stack_check();
  983   }
  984 
  985   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  986     MacroAssembler _masm(&amp;cbuf);
  987     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  988     __ relocate(relocInfo::poll_return_type);
  989     __ testl(rax, Address(rscratch1, 0));
  990   }
  991 }
  992 
  993 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  994 {
  995   return MachNode::size(ra_); // too many variables; just compute it
  996                               // the hard way
  997 }
  998 
  999 int MachEpilogNode::reloc() const
 1000 {
 1001   return 2; // a large enough number
 1002 }
 1003 
 1004 const Pipeline* MachEpilogNode::pipeline() const
 1005 {
 1006   return MachNode::pipeline_class();
 1007 }
 1008 
 1009 //=============================================================================
 1010 
 1011 enum RC {
 1012   rc_bad,
 1013   rc_int,
 1014   rc_float,
 1015   rc_stack
 1016 };
 1017 
 1018 static enum RC rc_class(OptoReg::Name reg)
 1019 {
 1020   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1021 
 1022   if (OptoReg::is_stack(reg)) return rc_stack;
 1023 
 1024   VMReg r = OptoReg::as_VMReg(reg);
 1025 
 1026   if (r-&gt;is_Register()) return rc_int;
 1027 
 1028   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1029   return rc_float;
 1030 }
 1031 
 1032 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1033 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1034                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1035 
 1036 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1037                      int stack_offset, int reg, uint ireg, outputStream* st);
 1038 
 1039 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1040                                       int dst_offset, uint ireg, outputStream* st) {
 1041   if (cbuf) {
 1042     MacroAssembler _masm(cbuf);
 1043     switch (ireg) {
 1044     case Op_VecS:
 1045       __ movq(Address(rsp, -8), rax);
 1046       __ movl(rax, Address(rsp, src_offset));
 1047       __ movl(Address(rsp, dst_offset), rax);
 1048       __ movq(rax, Address(rsp, -8));
 1049       break;
 1050     case Op_VecD:
 1051       __ pushq(Address(rsp, src_offset));
 1052       __ popq (Address(rsp, dst_offset));
 1053       break;
 1054     case Op_VecX:
 1055       __ pushq(Address(rsp, src_offset));
 1056       __ popq (Address(rsp, dst_offset));
 1057       __ pushq(Address(rsp, src_offset+8));
 1058       __ popq (Address(rsp, dst_offset+8));
 1059       break;
 1060     case Op_VecY:
 1061       __ vmovdqu(Address(rsp, -32), xmm0);
 1062       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1063       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1064       __ vmovdqu(xmm0, Address(rsp, -32));
 1065       break;
 1066     case Op_VecZ:
 1067       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1068       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1069       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1070       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1071       break;
 1072     default:
 1073       ShouldNotReachHere();
 1074     }
 1075 #ifndef PRODUCT
 1076   } else {
 1077     switch (ireg) {
 1078     case Op_VecS:
 1079       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1080                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1081                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1082                 &quot;movq    rax, [rsp - #8]&quot;,
 1083                 src_offset, dst_offset);
 1084       break;
 1085     case Op_VecD:
 1086       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1087                 &quot;popq    [rsp + #%d]&quot;,
 1088                 src_offset, dst_offset);
 1089       break;
 1090      case Op_VecX:
 1091       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1092                 &quot;popq    [rsp + #%d]\n\t&quot;
 1093                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1094                 &quot;popq    [rsp + #%d]&quot;,
 1095                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1096       break;
 1097     case Op_VecY:
 1098       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1099                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1100                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1101                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1102                 src_offset, dst_offset);
 1103       break;
 1104     case Op_VecZ:
 1105       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1106                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1107                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1108                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1109                 src_offset, dst_offset);
 1110       break;
 1111     default:
 1112       ShouldNotReachHere();
 1113     }
 1114 #endif
 1115   }
 1116 }
 1117 
 1118 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1119                                        PhaseRegAlloc* ra_,
 1120                                        bool do_size,
 1121                                        outputStream* st) const {
 1122   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1123   // Get registers to move
 1124   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1125   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1126   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1127   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1128 
 1129   enum RC src_second_rc = rc_class(src_second);
 1130   enum RC src_first_rc = rc_class(src_first);
 1131   enum RC dst_second_rc = rc_class(dst_second);
 1132   enum RC dst_first_rc = rc_class(dst_first);
 1133 
 1134   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1135          &quot;must move at least 1 register&quot; );
 1136 
 1137   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1138     // Self copy, no move
 1139     return 0;
 1140   }
 1141   if (bottom_type()-&gt;isa_vect() != NULL) {
 1142     uint ireg = ideal_reg();
 1143     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1144     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1145     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1146       // mem -&gt; mem
 1147       int src_offset = ra_-&gt;reg2offset(src_first);
 1148       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1149       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1150     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1151       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1152     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1153       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1154       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1155     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1156       int stack_offset = ra_-&gt;reg2offset(src_first);
 1157       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1158     } else {
 1159       ShouldNotReachHere();
 1160     }
 1161     return 0;
 1162   }
 1163   if (src_first_rc == rc_stack) {
 1164     // mem -&gt;
 1165     if (dst_first_rc == rc_stack) {
 1166       // mem -&gt; mem
 1167       assert(src_second != dst_first, &quot;overlap&quot;);
 1168       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1169           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1170         // 64-bit
 1171         int src_offset = ra_-&gt;reg2offset(src_first);
 1172         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1173         if (cbuf) {
 1174           MacroAssembler _masm(cbuf);
 1175           __ pushq(Address(rsp, src_offset));
 1176           __ popq (Address(rsp, dst_offset));
 1177 #ifndef PRODUCT
 1178         } else {
 1179           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1180                     &quot;popq    [rsp + #%d]&quot;,
 1181                      src_offset, dst_offset);
 1182 #endif
 1183         }
 1184       } else {
 1185         // 32-bit
 1186         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1187         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1188         // No pushl/popl, so:
 1189         int src_offset = ra_-&gt;reg2offset(src_first);
 1190         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1191         if (cbuf) {
 1192           MacroAssembler _masm(cbuf);
 1193           __ movq(Address(rsp, -8), rax);
 1194           __ movl(rax, Address(rsp, src_offset));
 1195           __ movl(Address(rsp, dst_offset), rax);
 1196           __ movq(rax, Address(rsp, -8));
 1197 #ifndef PRODUCT
 1198         } else {
 1199           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1200                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1201                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1202                     &quot;movq    rax, [rsp - #8]&quot;,
 1203                      src_offset, dst_offset);
 1204 #endif
 1205         }
 1206       }
 1207       return 0;
 1208     } else if (dst_first_rc == rc_int) {
 1209       // mem -&gt; gpr
 1210       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1211           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1212         // 64-bit
 1213         int offset = ra_-&gt;reg2offset(src_first);
 1214         if (cbuf) {
 1215           MacroAssembler _masm(cbuf);
 1216           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1217 #ifndef PRODUCT
 1218         } else {
 1219           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1220                      Matcher::regName[dst_first],
 1221                      offset);
 1222 #endif
 1223         }
 1224       } else {
 1225         // 32-bit
 1226         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1227         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1228         int offset = ra_-&gt;reg2offset(src_first);
 1229         if (cbuf) {
 1230           MacroAssembler _masm(cbuf);
 1231           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1232 #ifndef PRODUCT
 1233         } else {
 1234           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1235                      Matcher::regName[dst_first],
 1236                      offset);
 1237 #endif
 1238         }
 1239       }
 1240       return 0;
 1241     } else if (dst_first_rc == rc_float) {
 1242       // mem-&gt; xmm
 1243       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1244           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1245         // 64-bit
 1246         int offset = ra_-&gt;reg2offset(src_first);
 1247         if (cbuf) {
 1248           MacroAssembler _masm(cbuf);
 1249           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1250 #ifndef PRODUCT
 1251         } else {
 1252           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1253                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1254                      Matcher::regName[dst_first],
 1255                      offset);
 1256 #endif
 1257         }
 1258       } else {
 1259         // 32-bit
 1260         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1261         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1262         int offset = ra_-&gt;reg2offset(src_first);
 1263         if (cbuf) {
 1264           MacroAssembler _masm(cbuf);
 1265           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1266 #ifndef PRODUCT
 1267         } else {
 1268           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1269                      Matcher::regName[dst_first],
 1270                      offset);
 1271 #endif
 1272         }
 1273       }
 1274       return 0;
 1275     }
 1276   } else if (src_first_rc == rc_int) {
 1277     // gpr -&gt;
 1278     if (dst_first_rc == rc_stack) {
 1279       // gpr -&gt; mem
 1280       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1281           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1282         // 64-bit
 1283         int offset = ra_-&gt;reg2offset(dst_first);
 1284         if (cbuf) {
 1285           MacroAssembler _masm(cbuf);
 1286           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1287 #ifndef PRODUCT
 1288         } else {
 1289           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1290                      offset,
 1291                      Matcher::regName[src_first]);
 1292 #endif
 1293         }
 1294       } else {
 1295         // 32-bit
 1296         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1297         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1298         int offset = ra_-&gt;reg2offset(dst_first);
 1299         if (cbuf) {
 1300           MacroAssembler _masm(cbuf);
 1301           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1302 #ifndef PRODUCT
 1303         } else {
 1304           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1305                      offset,
 1306                      Matcher::regName[src_first]);
 1307 #endif
 1308         }
 1309       }
 1310       return 0;
 1311     } else if (dst_first_rc == rc_int) {
 1312       // gpr -&gt; gpr
 1313       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1314           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1315         // 64-bit
 1316         if (cbuf) {
 1317           MacroAssembler _masm(cbuf);
 1318           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1319                   as_Register(Matcher::_regEncode[src_first]));
 1320 #ifndef PRODUCT
 1321         } else {
 1322           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1323                      Matcher::regName[dst_first],
 1324                      Matcher::regName[src_first]);
 1325 #endif
 1326         }
 1327         return 0;
 1328       } else {
 1329         // 32-bit
 1330         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1331         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1332         if (cbuf) {
 1333           MacroAssembler _masm(cbuf);
 1334           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1335                   as_Register(Matcher::_regEncode[src_first]));
 1336 #ifndef PRODUCT
 1337         } else {
 1338           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1339                      Matcher::regName[dst_first],
 1340                      Matcher::regName[src_first]);
 1341 #endif
 1342         }
 1343         return 0;
 1344       }
 1345     } else if (dst_first_rc == rc_float) {
 1346       // gpr -&gt; xmm
 1347       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1348           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1349         // 64-bit
 1350         if (cbuf) {
 1351           MacroAssembler _masm(cbuf);
 1352           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1353 #ifndef PRODUCT
 1354         } else {
 1355           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1356                      Matcher::regName[dst_first],
 1357                      Matcher::regName[src_first]);
 1358 #endif
 1359         }
 1360       } else {
 1361         // 32-bit
 1362         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1363         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1364         if (cbuf) {
 1365           MacroAssembler _masm(cbuf);
 1366           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1367 #ifndef PRODUCT
 1368         } else {
 1369           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1370                      Matcher::regName[dst_first],
 1371                      Matcher::regName[src_first]);
 1372 #endif
 1373         }
 1374       }
 1375       return 0;
 1376     }
 1377   } else if (src_first_rc == rc_float) {
 1378     // xmm -&gt;
 1379     if (dst_first_rc == rc_stack) {
 1380       // xmm -&gt; mem
 1381       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1382           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1383         // 64-bit
 1384         int offset = ra_-&gt;reg2offset(dst_first);
 1385         if (cbuf) {
 1386           MacroAssembler _masm(cbuf);
 1387           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1388 #ifndef PRODUCT
 1389         } else {
 1390           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1391                      offset,
 1392                      Matcher::regName[src_first]);
 1393 #endif
 1394         }
 1395       } else {
 1396         // 32-bit
 1397         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1398         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1399         int offset = ra_-&gt;reg2offset(dst_first);
 1400         if (cbuf) {
 1401           MacroAssembler _masm(cbuf);
 1402           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1403 #ifndef PRODUCT
 1404         } else {
 1405           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1406                      offset,
 1407                      Matcher::regName[src_first]);
 1408 #endif
 1409         }
 1410       }
 1411       return 0;
 1412     } else if (dst_first_rc == rc_int) {
 1413       // xmm -&gt; gpr
 1414       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1415           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1416         // 64-bit
 1417         if (cbuf) {
 1418           MacroAssembler _masm(cbuf);
 1419           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1420 #ifndef PRODUCT
 1421         } else {
 1422           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1423                      Matcher::regName[dst_first],
 1424                      Matcher::regName[src_first]);
 1425 #endif
 1426         }
 1427       } else {
 1428         // 32-bit
 1429         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1430         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1431         if (cbuf) {
 1432           MacroAssembler _masm(cbuf);
 1433           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1434 #ifndef PRODUCT
 1435         } else {
 1436           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1437                      Matcher::regName[dst_first],
 1438                      Matcher::regName[src_first]);
 1439 #endif
 1440         }
 1441       }
 1442       return 0;
 1443     } else if (dst_first_rc == rc_float) {
 1444       // xmm -&gt; xmm
 1445       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1446           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1447         // 64-bit
 1448         if (cbuf) {
 1449           MacroAssembler _masm(cbuf);
 1450           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1451 #ifndef PRODUCT
 1452         } else {
 1453           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1454                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1455                      Matcher::regName[dst_first],
 1456                      Matcher::regName[src_first]);
 1457 #endif
 1458         }
 1459       } else {
 1460         // 32-bit
 1461         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1462         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1463         if (cbuf) {
 1464           MacroAssembler _masm(cbuf);
 1465           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1466 #ifndef PRODUCT
 1467         } else {
 1468           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1469                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1470                      Matcher::regName[dst_first],
 1471                      Matcher::regName[src_first]);
 1472 #endif
 1473         }
 1474       }
 1475       return 0;
 1476     }
 1477   }
 1478 
 1479   assert(0,&quot; foo &quot;);
 1480   Unimplemented();
 1481   return 0;
 1482 }
 1483 
 1484 #ifndef PRODUCT
 1485 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1486   implementation(NULL, ra_, false, st);
 1487 }
 1488 #endif
 1489 
 1490 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1491   implementation(&amp;cbuf, ra_, false, NULL);
 1492 }
 1493 
 1494 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1495   return MachNode::size(ra_);
 1496 }
 1497 
 1498 //=============================================================================
 1499 #ifndef PRODUCT
 1500 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1501 {
 1502   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1503   int reg = ra_-&gt;get_reg_first(this);
 1504   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1505             Matcher::regName[reg], offset);
 1506 }
 1507 #endif
 1508 
 1509 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1510 {
 1511   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1512   int reg = ra_-&gt;get_encode(this);
 1513   if (offset &gt;= 0x80) {
 1514     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1515     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1516     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1517     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1518     emit_d32(cbuf, offset);
 1519   } else {
 1520     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1521     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1522     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1523     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1524     emit_d8(cbuf, offset);
 1525   }
 1526 }
 1527 
 1528 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1529 {
 1530   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1531   return (offset &lt; 0x80) ? 5 : 8; // REX
 1532 }
 1533 
 1534 //=============================================================================
 1535 #ifndef PRODUCT
 1536 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1537 {
 1538   if (UseCompressedClassPointers) {
 1539     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1540     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1541     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1542   } else {
 1543     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1544                  &quot;# Inline cache check&quot;);
 1545   }
 1546   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1547   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1548 }
 1549 #endif
 1550 
 1551 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1552 {
 1553   MacroAssembler masm(&amp;cbuf);
 1554   uint insts_size = cbuf.insts_size();
 1555   if (UseCompressedClassPointers) {
 1556     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1557     masm.cmpptr(rax, rscratch1);
 1558   } else {
 1559     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1560   }
 1561 
 1562   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1563 
 1564   /* WARNING these NOPs are critical so that verified entry point is properly
 1565      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1566   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1567   if (OptoBreakpoint) {
 1568     // Leave space for int3
 1569     nops_cnt -= 1;
 1570   }
 1571   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1572   if (nops_cnt &gt; 0)
 1573     masm.nop(nops_cnt);
 1574 }
 1575 
 1576 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1577 {
 1578   return MachNode::size(ra_); // too many variables; just compute it
 1579                               // the hard way
 1580 }
 1581 
 1582 
 1583 //=============================================================================
 1584 
 1585 int Matcher::regnum_to_fpu_offset(int regnum)
 1586 {
 1587   return regnum - 32; // The FP registers are in the second chunk
 1588 }
 1589 
 1590 // This is UltraSparc specific, true just means we have fast l2f conversion
 1591 const bool Matcher::convL2FSupported(void) {
 1592   return true;
 1593 }
 1594 
 1595 // Is this branch offset short enough that a short branch can be used?
 1596 //
 1597 // NOTE: If the platform does not provide any short branch variants, then
 1598 //       this method should return false for offset 0.
 1599 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1600   // The passed offset is relative to address of the branch.
 1601   // On 86 a branch displacement is calculated relative to address
 1602   // of a next instruction.
 1603   offset -= br_size;
 1604 
 1605   // the short version of jmpConUCF2 contains multiple branches,
 1606   // making the reach slightly less
 1607   if (rule == jmpConUCF2_rule)
 1608     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1609   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1610 }
 1611 
 1612 const bool Matcher::isSimpleConstant64(jlong value) {
 1613   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1614   //return value == (int) value;  // Cf. storeImmL and immL32.
 1615 
 1616   // Probably always true, even if a temp register is required.
 1617   return true;
 1618 }
 1619 
 1620 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1621 const bool Matcher::init_array_count_is_in_bytes = false;
 1622 
 1623 // No additional cost for CMOVL.
 1624 const int Matcher::long_cmove_cost() { return 0; }
 1625 
 1626 // No CMOVF/CMOVD with SSE2
 1627 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1628 
 1629 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1630 const bool Matcher::require_postalloc_expand = false;
 1631 
 1632 // Do we need to mask the count passed to shift instructions or does
 1633 // the cpu only look at the lower 5/6 bits anyway?
 1634 const bool Matcher::need_masked_shift_count = false;
 1635 
 1636 bool Matcher::narrow_oop_use_complex_address() {
 1637   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1638   return (LogMinObjAlignmentInBytes &lt;= 3);
 1639 }
 1640 
 1641 bool Matcher::narrow_klass_use_complex_address() {
 1642   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1643   return (LogKlassAlignmentInBytes &lt;= 3);
 1644 }
 1645 
 1646 bool Matcher::const_oop_prefer_decode() {
 1647   // Prefer ConN+DecodeN over ConP.
 1648   return true;
 1649 }
 1650 
 1651 bool Matcher::const_klass_prefer_decode() {
 1652   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1653   //       or condisider the following:
 1654   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1655   //return CompressedKlassPointers::base() == NULL;
 1656   return true;
 1657 }
 1658 
 1659 // Is it better to copy float constants, or load them directly from
 1660 // memory?  Intel can load a float constant from a direct address,
 1661 // requiring no extra registers.  Most RISCs will have to materialize
 1662 // an address into a register first, so they would do better to copy
 1663 // the constant from stack.
 1664 const bool Matcher::rematerialize_float_constants = true; // XXX
 1665 
 1666 // If CPU can load and store mis-aligned doubles directly then no
 1667 // fixup is needed.  Else we split the double into 2 integer pieces
 1668 // and move it piece-by-piece.  Only happens when passing doubles into
 1669 // C code as the Java calling convention forces doubles to be aligned.
 1670 const bool Matcher::misaligned_doubles_ok = true;
 1671 
 1672 // No-op on amd64
 1673 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1674 
 1675 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1676 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1677 
 1678 // Are floats conerted to double when stored to stack during deoptimization?
 1679 // On x64 it is stored without convertion so we can use normal access.
 1680 bool Matcher::float_in_double() { return false; }
 1681 
 1682 // Do ints take an entire long register or just half?
 1683 const bool Matcher::int_in_long = true;
 1684 
 1685 // Return whether or not this register is ever used as an argument.
 1686 // This function is used on startup to build the trampoline stubs in
 1687 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1688 // call in the trampoline, and arguments in those registers not be
 1689 // available to the callee.
 1690 bool Matcher::can_be_java_arg(int reg)
 1691 {
 1692   return
 1693     reg ==  RDI_num || reg == RDI_H_num ||
 1694     reg ==  RSI_num || reg == RSI_H_num ||
 1695     reg ==  RDX_num || reg == RDX_H_num ||
 1696     reg ==  RCX_num || reg == RCX_H_num ||
 1697     reg ==   R8_num || reg ==  R8_H_num ||
 1698     reg ==   R9_num || reg ==  R9_H_num ||
 1699     reg ==  R12_num || reg == R12_H_num ||
 1700     reg == XMM0_num || reg == XMM0b_num ||
 1701     reg == XMM1_num || reg == XMM1b_num ||
 1702     reg == XMM2_num || reg == XMM2b_num ||
 1703     reg == XMM3_num || reg == XMM3b_num ||
 1704     reg == XMM4_num || reg == XMM4b_num ||
 1705     reg == XMM5_num || reg == XMM5b_num ||
 1706     reg == XMM6_num || reg == XMM6b_num ||
 1707     reg == XMM7_num || reg == XMM7b_num;
 1708 }
 1709 
 1710 bool Matcher::is_spillable_arg(int reg)
 1711 {
 1712   return can_be_java_arg(reg);
 1713 }
 1714 
 1715 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1716   // In 64 bit mode a code which use multiply when
 1717   // devisor is constant is faster than hardware
 1718   // DIV instruction (it uses MulHiL).
 1719   return false;
 1720 }
 1721 
 1722 // Register for DIVI projection of divmodI
 1723 RegMask Matcher::divI_proj_mask() {
 1724   return INT_RAX_REG_mask();
 1725 }
 1726 
 1727 // Register for MODI projection of divmodI
 1728 RegMask Matcher::modI_proj_mask() {
 1729   return INT_RDX_REG_mask();
 1730 }
 1731 
 1732 // Register for DIVL projection of divmodL
 1733 RegMask Matcher::divL_proj_mask() {
 1734   return LONG_RAX_REG_mask();
 1735 }
 1736 
 1737 // Register for MODL projection of divmodL
 1738 RegMask Matcher::modL_proj_mask() {
 1739   return LONG_RDX_REG_mask();
 1740 }
 1741 
 1742 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1743 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1744     return NO_REG_mask();
 1745 }
 1746 
 1747 %}
 1748 
 1749 //----------ENCODING BLOCK-----------------------------------------------------
 1750 // This block specifies the encoding classes used by the compiler to
 1751 // output byte streams.  Encoding classes are parameterized macros
 1752 // used by Machine Instruction Nodes in order to generate the bit
 1753 // encoding of the instruction.  Operands specify their base encoding
 1754 // interface with the interface keyword.  There are currently
 1755 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1756 // COND_INTER.  REG_INTER causes an operand to generate a function
 1757 // which returns its register number when queried.  CONST_INTER causes
 1758 // an operand to generate a function which returns the value of the
 1759 // constant when queried.  MEMORY_INTER causes an operand to generate
 1760 // four functions which return the Base Register, the Index Register,
 1761 // the Scale Value, and the Offset Value of the operand when queried.
 1762 // COND_INTER causes an operand to generate six functions which return
 1763 // the encoding code (ie - encoding bits for the instruction)
 1764 // associated with each basic boolean condition for a conditional
 1765 // instruction.
 1766 //
 1767 // Instructions specify two basic values for encoding.  Again, a
 1768 // function is available to check if the constant displacement is an
 1769 // oop. They use the ins_encode keyword to specify their encoding
 1770 // classes (which must be a sequence of enc_class names, and their
 1771 // parameters, specified in the encoding block), and they use the
 1772 // opcode keyword to specify, in order, their primary, secondary, and
 1773 // tertiary opcode.  Only the opcode sections which a particular
 1774 // instruction needs for encoding need to be specified.
 1775 encode %{
 1776   // Build emit functions for each basic byte or larger field in the
 1777   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1778   // from C++ code in the enc_class source block.  Emit functions will
 1779   // live in the main source block for now.  In future, we can
 1780   // generalize this by adding a syntax that specifies the sizes of
 1781   // fields in an order, so that the adlc can build the emit functions
 1782   // automagically
 1783 
 1784   // Emit primary opcode
 1785   enc_class OpcP
 1786   %{
 1787     emit_opcode(cbuf, $primary);
 1788   %}
 1789 
 1790   // Emit secondary opcode
 1791   enc_class OpcS
 1792   %{
 1793     emit_opcode(cbuf, $secondary);
 1794   %}
 1795 
 1796   // Emit tertiary opcode
 1797   enc_class OpcT
 1798   %{
 1799     emit_opcode(cbuf, $tertiary);
 1800   %}
 1801 
 1802   // Emit opcode directly
 1803   enc_class Opcode(immI d8)
 1804   %{
 1805     emit_opcode(cbuf, $d8$$constant);
 1806   %}
 1807 
 1808   // Emit size prefix
 1809   enc_class SizePrefix
 1810   %{
 1811     emit_opcode(cbuf, 0x66);
 1812   %}
 1813 
 1814   enc_class reg(rRegI reg)
 1815   %{
 1816     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1817   %}
 1818 
 1819   enc_class reg_reg(rRegI dst, rRegI src)
 1820   %{
 1821     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1822   %}
 1823 
 1824   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1825   %{
 1826     emit_opcode(cbuf, $opcode$$constant);
 1827     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1828   %}
 1829 
 1830   enc_class cdql_enc(no_rax_rdx_RegI div)
 1831   %{
 1832     // Full implementation of Java idiv and irem; checks for
 1833     // special case as described in JVM spec., p.243 &amp; p.271.
 1834     //
 1835     //         normal case                           special case
 1836     //
 1837     // input : rax: dividend                         min_int
 1838     //         reg: divisor                          -1
 1839     //
 1840     // output: rax: quotient  (= rax idiv reg)       min_int
 1841     //         rdx: remainder (= rax irem reg)       0
 1842     //
 1843     //  Code sequnce:
 1844     //
 1845     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1846     //    5:   75 07/08                jne    e &lt;normal&gt;
 1847     //    7:   33 d2                   xor    %edx,%edx
 1848     //  [div &gt;= 8 -&gt; offset + 1]
 1849     //  [REX_B]
 1850     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1851     //    c:   74 03/04                je     11 &lt;done&gt;
 1852     // 000000000000000e &lt;normal&gt;:
 1853     //    e:   99                      cltd
 1854     //  [div &gt;= 8 -&gt; offset + 1]
 1855     //  [REX_B]
 1856     //    f:   f7 f9                   idiv   $div
 1857     // 0000000000000011 &lt;done&gt;:
 1858 
 1859     // cmp    $0x80000000,%eax
 1860     emit_opcode(cbuf, 0x3d);
 1861     emit_d8(cbuf, 0x00);
 1862     emit_d8(cbuf, 0x00);
 1863     emit_d8(cbuf, 0x00);
 1864     emit_d8(cbuf, 0x80);
 1865 
 1866     // jne    e &lt;normal&gt;
 1867     emit_opcode(cbuf, 0x75);
 1868     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1869 
 1870     // xor    %edx,%edx
 1871     emit_opcode(cbuf, 0x33);
 1872     emit_d8(cbuf, 0xD2);
 1873 
 1874     // cmp    $0xffffffffffffffff,%ecx
 1875     if ($div$$reg &gt;= 8) {
 1876       emit_opcode(cbuf, Assembler::REX_B);
 1877     }
 1878     emit_opcode(cbuf, 0x83);
 1879     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1880     emit_d8(cbuf, 0xFF);
 1881 
 1882     // je     11 &lt;done&gt;
 1883     emit_opcode(cbuf, 0x74);
 1884     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1885 
 1886     // &lt;normal&gt;
 1887     // cltd
 1888     emit_opcode(cbuf, 0x99);
 1889 
 1890     // idivl (note: must be emitted by the user of this rule)
 1891     // &lt;done&gt;
 1892   %}
 1893 
 1894   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1895   %{
 1896     // Full implementation of Java ldiv and lrem; checks for
 1897     // special case as described in JVM spec., p.243 &amp; p.271.
 1898     //
 1899     //         normal case                           special case
 1900     //
 1901     // input : rax: dividend                         min_long
 1902     //         reg: divisor                          -1
 1903     //
 1904     // output: rax: quotient  (= rax idiv reg)       min_long
 1905     //         rdx: remainder (= rax irem reg)       0
 1906     //
 1907     //  Code sequnce:
 1908     //
 1909     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1910     //    7:   00 00 80
 1911     //    a:   48 39 d0                cmp    %rdx,%rax
 1912     //    d:   75 08                   jne    17 &lt;normal&gt;
 1913     //    f:   33 d2                   xor    %edx,%edx
 1914     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1915     //   15:   74 05                   je     1c &lt;done&gt;
 1916     // 0000000000000017 &lt;normal&gt;:
 1917     //   17:   48 99                   cqto
 1918     //   19:   48 f7 f9                idiv   $div
 1919     // 000000000000001c &lt;done&gt;:
 1920 
 1921     // mov    $0x8000000000000000,%rdx
 1922     emit_opcode(cbuf, Assembler::REX_W);
 1923     emit_opcode(cbuf, 0xBA);
 1924     emit_d8(cbuf, 0x00);
 1925     emit_d8(cbuf, 0x00);
 1926     emit_d8(cbuf, 0x00);
 1927     emit_d8(cbuf, 0x00);
 1928     emit_d8(cbuf, 0x00);
 1929     emit_d8(cbuf, 0x00);
 1930     emit_d8(cbuf, 0x00);
 1931     emit_d8(cbuf, 0x80);
 1932 
 1933     // cmp    %rdx,%rax
 1934     emit_opcode(cbuf, Assembler::REX_W);
 1935     emit_opcode(cbuf, 0x39);
 1936     emit_d8(cbuf, 0xD0);
 1937 
 1938     // jne    17 &lt;normal&gt;
 1939     emit_opcode(cbuf, 0x75);
 1940     emit_d8(cbuf, 0x08);
 1941 
 1942     // xor    %edx,%edx
 1943     emit_opcode(cbuf, 0x33);
 1944     emit_d8(cbuf, 0xD2);
 1945 
 1946     // cmp    $0xffffffffffffffff,$div
 1947     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1948     emit_opcode(cbuf, 0x83);
 1949     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1950     emit_d8(cbuf, 0xFF);
 1951 
 1952     // je     1e &lt;done&gt;
 1953     emit_opcode(cbuf, 0x74);
 1954     emit_d8(cbuf, 0x05);
 1955 
 1956     // &lt;normal&gt;
 1957     // cqto
 1958     emit_opcode(cbuf, Assembler::REX_W);
 1959     emit_opcode(cbuf, 0x99);
 1960 
 1961     // idivq (note: must be emitted by the user of this rule)
 1962     // &lt;done&gt;
 1963   %}
 1964 
 1965   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1966   enc_class OpcSE(immI imm)
 1967   %{
 1968     // Emit primary opcode and set sign-extend bit
 1969     // Check for 8-bit immediate, and set sign extend bit in opcode
 1970     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1971       emit_opcode(cbuf, $primary | 0x02);
 1972     } else {
 1973       // 32-bit immediate
 1974       emit_opcode(cbuf, $primary);
 1975     }
 1976   %}
 1977 
 1978   enc_class OpcSErm(rRegI dst, immI imm)
 1979   %{
 1980     // OpcSEr/m
 1981     int dstenc = $dst$$reg;
 1982     if (dstenc &gt;= 8) {
 1983       emit_opcode(cbuf, Assembler::REX_B);
 1984       dstenc -= 8;
 1985     }
 1986     // Emit primary opcode and set sign-extend bit
 1987     // Check for 8-bit immediate, and set sign extend bit in opcode
 1988     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1989       emit_opcode(cbuf, $primary | 0x02);
 1990     } else {
 1991       // 32-bit immediate
 1992       emit_opcode(cbuf, $primary);
 1993     }
 1994     // Emit r/m byte with secondary opcode, after primary opcode.
 1995     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1996   %}
 1997 
 1998   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1999   %{
 2000     // OpcSEr/m
 2001     int dstenc = $dst$$reg;
 2002     if (dstenc &lt; 8) {
 2003       emit_opcode(cbuf, Assembler::REX_W);
 2004     } else {
 2005       emit_opcode(cbuf, Assembler::REX_WB);
 2006       dstenc -= 8;
 2007     }
 2008     // Emit primary opcode and set sign-extend bit
 2009     // Check for 8-bit immediate, and set sign extend bit in opcode
 2010     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2011       emit_opcode(cbuf, $primary | 0x02);
 2012     } else {
 2013       // 32-bit immediate
 2014       emit_opcode(cbuf, $primary);
 2015     }
 2016     // Emit r/m byte with secondary opcode, after primary opcode.
 2017     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2018   %}
 2019 
 2020   enc_class Con8or32(immI imm)
 2021   %{
 2022     // Check for 8-bit immediate, and set sign extend bit in opcode
 2023     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2024       $$$emit8$imm$$constant;
 2025     } else {
 2026       // 32-bit immediate
 2027       $$$emit32$imm$$constant;
 2028     }
 2029   %}
 2030 
 2031   enc_class opc2_reg(rRegI dst)
 2032   %{
 2033     // BSWAP
 2034     emit_cc(cbuf, $secondary, $dst$$reg);
 2035   %}
 2036 
 2037   enc_class opc3_reg(rRegI dst)
 2038   %{
 2039     // BSWAP
 2040     emit_cc(cbuf, $tertiary, $dst$$reg);
 2041   %}
 2042 
 2043   enc_class reg_opc(rRegI div)
 2044   %{
 2045     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2046     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2047   %}
 2048 
 2049   enc_class enc_cmov(cmpOp cop)
 2050   %{
 2051     // CMOV
 2052     $$$emit8$primary;
 2053     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2054   %}
 2055 
 2056   enc_class enc_PartialSubtypeCheck()
 2057   %{
 2058     Register Rrdi = as_Register(RDI_enc); // result register
 2059     Register Rrax = as_Register(RAX_enc); // super class
 2060     Register Rrcx = as_Register(RCX_enc); // killed
 2061     Register Rrsi = as_Register(RSI_enc); // sub class
 2062     Label miss;
 2063     const bool set_cond_codes = true;
 2064 
 2065     MacroAssembler _masm(&amp;cbuf);
 2066     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2067                                      NULL, &amp;miss,
 2068                                      /*set_cond_codes:*/ true);
 2069     if ($primary) {
 2070       __ xorptr(Rrdi, Rrdi);
 2071     }
 2072     __ bind(miss);
 2073   %}
 2074 
 2075   enc_class clear_avx %{
 2076     debug_only(int off0 = cbuf.insts_size());
 2077     if (generate_vzeroupper(Compile::current())) {
 2078       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2079       // Clear upper bits of YMM registers when current compiled code uses
 2080       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2081       MacroAssembler _masm(&amp;cbuf);
 2082       __ vzeroupper();
 2083     }
 2084     debug_only(int off1 = cbuf.insts_size());
 2085     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2086   %}
 2087 
 2088   enc_class Java_To_Runtime(method meth) %{
 2089     // No relocation needed
 2090     MacroAssembler _masm(&amp;cbuf);
 2091     __ mov64(r10, (int64_t) $meth$$method);
 2092     __ call(r10);
 2093   %}
 2094 
 2095   enc_class Java_To_Interpreter(method meth)
 2096   %{
 2097     // CALL Java_To_Interpreter
 2098     // This is the instruction starting address for relocation info.
 2099     cbuf.set_insts_mark();
 2100     $$$emit8$primary;
 2101     // CALL directly to the runtime
 2102     emit_d32_reloc(cbuf,
 2103                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2104                    runtime_call_Relocation::spec(),
 2105                    RELOC_DISP32);
 2106   %}
 2107 
 2108   enc_class Java_Static_Call(method meth)
 2109   %{
 2110     // JAVA STATIC CALL
 2111     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2112     // determine who we intended to call.
 2113     cbuf.set_insts_mark();
 2114     $$$emit8$primary;
 2115 
 2116     if (!_method) {
 2117       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2118                      runtime_call_Relocation::spec(),
 2119                      RELOC_DISP32);
 2120     } else {
 2121       int method_index = resolved_method_index(cbuf);
 2122       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2123                                                   : static_call_Relocation::spec(method_index);
 2124       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2125                      rspec, RELOC_DISP32);
 2126       // Emit stubs for static call.
 2127       address mark = cbuf.insts_mark();
 2128       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2129       if (stub == NULL) {
 2130         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2131         return;
 2132       }
 2133 #if INCLUDE_AOT
 2134       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2135 #endif
 2136     }
 2137   %}
 2138 
 2139   enc_class Java_Dynamic_Call(method meth) %{
 2140     MacroAssembler _masm(&amp;cbuf);
 2141     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2142   %}
 2143 
 2144   enc_class Java_Compiled_Call(method meth)
 2145   %{
 2146     // JAVA COMPILED CALL
 2147     int disp = in_bytes(Method:: from_compiled_offset());
 2148 
 2149     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2150     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2151 
 2152     // callq *disp(%rax)
 2153     cbuf.set_insts_mark();
 2154     $$$emit8$primary;
 2155     if (disp &lt; 0x80) {
 2156       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2157       emit_d8(cbuf, disp); // Displacement
 2158     } else {
 2159       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2160       emit_d32(cbuf, disp); // Displacement
 2161     }
 2162   %}
 2163 
 2164   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2165   %{
 2166     // SAL, SAR, SHR
 2167     int dstenc = $dst$$reg;
 2168     if (dstenc &gt;= 8) {
 2169       emit_opcode(cbuf, Assembler::REX_B);
 2170       dstenc -= 8;
 2171     }
 2172     $$$emit8$primary;
 2173     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2174     $$$emit8$shift$$constant;
 2175   %}
 2176 
 2177   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2178   %{
 2179     // SAL, SAR, SHR
 2180     int dstenc = $dst$$reg;
 2181     if (dstenc &lt; 8) {
 2182       emit_opcode(cbuf, Assembler::REX_W);
 2183     } else {
 2184       emit_opcode(cbuf, Assembler::REX_WB);
 2185       dstenc -= 8;
 2186     }
 2187     $$$emit8$primary;
 2188     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2189     $$$emit8$shift$$constant;
 2190   %}
 2191 
 2192   enc_class load_immI(rRegI dst, immI src)
 2193   %{
 2194     int dstenc = $dst$$reg;
 2195     if (dstenc &gt;= 8) {
 2196       emit_opcode(cbuf, Assembler::REX_B);
 2197       dstenc -= 8;
 2198     }
 2199     emit_opcode(cbuf, 0xB8 | dstenc);
 2200     $$$emit32$src$$constant;
 2201   %}
 2202 
 2203   enc_class load_immL(rRegL dst, immL src)
 2204   %{
 2205     int dstenc = $dst$$reg;
 2206     if (dstenc &lt; 8) {
 2207       emit_opcode(cbuf, Assembler::REX_W);
 2208     } else {
 2209       emit_opcode(cbuf, Assembler::REX_WB);
 2210       dstenc -= 8;
 2211     }
 2212     emit_opcode(cbuf, 0xB8 | dstenc);
 2213     emit_d64(cbuf, $src$$constant);
 2214   %}
 2215 
 2216   enc_class load_immUL32(rRegL dst, immUL32 src)
 2217   %{
 2218     // same as load_immI, but this time we care about zeroes in the high word
 2219     int dstenc = $dst$$reg;
 2220     if (dstenc &gt;= 8) {
 2221       emit_opcode(cbuf, Assembler::REX_B);
 2222       dstenc -= 8;
 2223     }
 2224     emit_opcode(cbuf, 0xB8 | dstenc);
 2225     $$$emit32$src$$constant;
 2226   %}
 2227 
 2228   enc_class load_immL32(rRegL dst, immL32 src)
 2229   %{
 2230     int dstenc = $dst$$reg;
 2231     if (dstenc &lt; 8) {
 2232       emit_opcode(cbuf, Assembler::REX_W);
 2233     } else {
 2234       emit_opcode(cbuf, Assembler::REX_WB);
 2235       dstenc -= 8;
 2236     }
 2237     emit_opcode(cbuf, 0xC7);
 2238     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2239     $$$emit32$src$$constant;
 2240   %}
 2241 
 2242   enc_class load_immP31(rRegP dst, immP32 src)
 2243   %{
 2244     // same as load_immI, but this time we care about zeroes in the high word
 2245     int dstenc = $dst$$reg;
 2246     if (dstenc &gt;= 8) {
 2247       emit_opcode(cbuf, Assembler::REX_B);
 2248       dstenc -= 8;
 2249     }
 2250     emit_opcode(cbuf, 0xB8 | dstenc);
 2251     $$$emit32$src$$constant;
 2252   %}
 2253 
 2254   enc_class load_immP(rRegP dst, immP src)
 2255   %{
 2256     int dstenc = $dst$$reg;
 2257     if (dstenc &lt; 8) {
 2258       emit_opcode(cbuf, Assembler::REX_W);
 2259     } else {
 2260       emit_opcode(cbuf, Assembler::REX_WB);
 2261       dstenc -= 8;
 2262     }
 2263     emit_opcode(cbuf, 0xB8 | dstenc);
 2264     // This next line should be generated from ADLC
 2265     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2266       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2267     } else {
 2268       emit_d64(cbuf, $src$$constant);
 2269     }
 2270   %}
 2271 
 2272   enc_class Con32(immI src)
 2273   %{
 2274     // Output immediate
 2275     $$$emit32$src$$constant;
 2276   %}
 2277 
 2278   enc_class Con32F_as_bits(immF src)
 2279   %{
 2280     // Output Float immediate bits
 2281     jfloat jf = $src$$constant;
 2282     jint jf_as_bits = jint_cast(jf);
 2283     emit_d32(cbuf, jf_as_bits);
 2284   %}
 2285 
 2286   enc_class Con16(immI src)
 2287   %{
 2288     // Output immediate
 2289     $$$emit16$src$$constant;
 2290   %}
 2291 
 2292   // How is this different from Con32??? XXX
 2293   enc_class Con_d32(immI src)
 2294   %{
 2295     emit_d32(cbuf,$src$$constant);
 2296   %}
 2297 
 2298   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2299     // Output immediate memory reference
 2300     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2301     emit_d32(cbuf, 0x00);
 2302   %}
 2303 
 2304   enc_class lock_prefix()
 2305   %{
 2306     emit_opcode(cbuf, 0xF0); // lock
 2307   %}
 2308 
 2309   enc_class REX_mem(memory mem)
 2310   %{
 2311     if ($mem$$base &gt;= 8) {
 2312       if ($mem$$index &lt; 8) {
 2313         emit_opcode(cbuf, Assembler::REX_B);
 2314       } else {
 2315         emit_opcode(cbuf, Assembler::REX_XB);
 2316       }
 2317     } else {
 2318       if ($mem$$index &gt;= 8) {
 2319         emit_opcode(cbuf, Assembler::REX_X);
 2320       }
 2321     }
 2322   %}
 2323 
 2324   enc_class REX_mem_wide(memory mem)
 2325   %{
 2326     if ($mem$$base &gt;= 8) {
 2327       if ($mem$$index &lt; 8) {
 2328         emit_opcode(cbuf, Assembler::REX_WB);
 2329       } else {
 2330         emit_opcode(cbuf, Assembler::REX_WXB);
 2331       }
 2332     } else {
 2333       if ($mem$$index &lt; 8) {
 2334         emit_opcode(cbuf, Assembler::REX_W);
 2335       } else {
 2336         emit_opcode(cbuf, Assembler::REX_WX);
 2337       }
 2338     }
 2339   %}
 2340 
 2341   // for byte regs
 2342   enc_class REX_breg(rRegI reg)
 2343   %{
 2344     if ($reg$$reg &gt;= 4) {
 2345       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2346     }
 2347   %}
 2348 
 2349   // for byte regs
 2350   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2351   %{
 2352     if ($dst$$reg &lt; 8) {
 2353       if ($src$$reg &gt;= 4) {
 2354         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2355       }
 2356     } else {
 2357       if ($src$$reg &lt; 8) {
 2358         emit_opcode(cbuf, Assembler::REX_R);
 2359       } else {
 2360         emit_opcode(cbuf, Assembler::REX_RB);
 2361       }
 2362     }
 2363   %}
 2364 
 2365   // for byte regs
 2366   enc_class REX_breg_mem(rRegI reg, memory mem)
 2367   %{
 2368     if ($reg$$reg &lt; 8) {
 2369       if ($mem$$base &lt; 8) {
 2370         if ($mem$$index &gt;= 8) {
 2371           emit_opcode(cbuf, Assembler::REX_X);
 2372         } else if ($reg$$reg &gt;= 4) {
 2373           emit_opcode(cbuf, Assembler::REX);
 2374         }
 2375       } else {
 2376         if ($mem$$index &lt; 8) {
 2377           emit_opcode(cbuf, Assembler::REX_B);
 2378         } else {
 2379           emit_opcode(cbuf, Assembler::REX_XB);
 2380         }
 2381       }
 2382     } else {
 2383       if ($mem$$base &lt; 8) {
 2384         if ($mem$$index &lt; 8) {
 2385           emit_opcode(cbuf, Assembler::REX_R);
 2386         } else {
 2387           emit_opcode(cbuf, Assembler::REX_RX);
 2388         }
 2389       } else {
 2390         if ($mem$$index &lt; 8) {
 2391           emit_opcode(cbuf, Assembler::REX_RB);
 2392         } else {
 2393           emit_opcode(cbuf, Assembler::REX_RXB);
 2394         }
 2395       }
 2396     }
 2397   %}
 2398 
 2399   enc_class REX_reg(rRegI reg)
 2400   %{
 2401     if ($reg$$reg &gt;= 8) {
 2402       emit_opcode(cbuf, Assembler::REX_B);
 2403     }
 2404   %}
 2405 
 2406   enc_class REX_reg_wide(rRegI reg)
 2407   %{
 2408     if ($reg$$reg &lt; 8) {
 2409       emit_opcode(cbuf, Assembler::REX_W);
 2410     } else {
 2411       emit_opcode(cbuf, Assembler::REX_WB);
 2412     }
 2413   %}
 2414 
 2415   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2416   %{
 2417     if ($dst$$reg &lt; 8) {
 2418       if ($src$$reg &gt;= 8) {
 2419         emit_opcode(cbuf, Assembler::REX_B);
 2420       }
 2421     } else {
 2422       if ($src$$reg &lt; 8) {
 2423         emit_opcode(cbuf, Assembler::REX_R);
 2424       } else {
 2425         emit_opcode(cbuf, Assembler::REX_RB);
 2426       }
 2427     }
 2428   %}
 2429 
 2430   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2431   %{
 2432     if ($dst$$reg &lt; 8) {
 2433       if ($src$$reg &lt; 8) {
 2434         emit_opcode(cbuf, Assembler::REX_W);
 2435       } else {
 2436         emit_opcode(cbuf, Assembler::REX_WB);
 2437       }
 2438     } else {
 2439       if ($src$$reg &lt; 8) {
 2440         emit_opcode(cbuf, Assembler::REX_WR);
 2441       } else {
 2442         emit_opcode(cbuf, Assembler::REX_WRB);
 2443       }
 2444     }
 2445   %}
 2446 
 2447   enc_class REX_reg_mem(rRegI reg, memory mem)
 2448   %{
 2449     if ($reg$$reg &lt; 8) {
 2450       if ($mem$$base &lt; 8) {
 2451         if ($mem$$index &gt;= 8) {
 2452           emit_opcode(cbuf, Assembler::REX_X);
 2453         }
 2454       } else {
 2455         if ($mem$$index &lt; 8) {
 2456           emit_opcode(cbuf, Assembler::REX_B);
 2457         } else {
 2458           emit_opcode(cbuf, Assembler::REX_XB);
 2459         }
 2460       }
 2461     } else {
 2462       if ($mem$$base &lt; 8) {
 2463         if ($mem$$index &lt; 8) {
 2464           emit_opcode(cbuf, Assembler::REX_R);
 2465         } else {
 2466           emit_opcode(cbuf, Assembler::REX_RX);
 2467         }
 2468       } else {
 2469         if ($mem$$index &lt; 8) {
 2470           emit_opcode(cbuf, Assembler::REX_RB);
 2471         } else {
 2472           emit_opcode(cbuf, Assembler::REX_RXB);
 2473         }
 2474       }
 2475     }
 2476   %}
 2477 
 2478   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2479   %{
 2480     if ($reg$$reg &lt; 8) {
 2481       if ($mem$$base &lt; 8) {
 2482         if ($mem$$index &lt; 8) {
 2483           emit_opcode(cbuf, Assembler::REX_W);
 2484         } else {
 2485           emit_opcode(cbuf, Assembler::REX_WX);
 2486         }
 2487       } else {
 2488         if ($mem$$index &lt; 8) {
 2489           emit_opcode(cbuf, Assembler::REX_WB);
 2490         } else {
 2491           emit_opcode(cbuf, Assembler::REX_WXB);
 2492         }
 2493       }
 2494     } else {
 2495       if ($mem$$base &lt; 8) {
 2496         if ($mem$$index &lt; 8) {
 2497           emit_opcode(cbuf, Assembler::REX_WR);
 2498         } else {
 2499           emit_opcode(cbuf, Assembler::REX_WRX);
 2500         }
 2501       } else {
 2502         if ($mem$$index &lt; 8) {
 2503           emit_opcode(cbuf, Assembler::REX_WRB);
 2504         } else {
 2505           emit_opcode(cbuf, Assembler::REX_WRXB);
 2506         }
 2507       }
 2508     }
 2509   %}
 2510 
 2511   enc_class reg_mem(rRegI ereg, memory mem)
 2512   %{
 2513     // High registers handle in encode_RegMem
 2514     int reg = $ereg$$reg;
 2515     int base = $mem$$base;
 2516     int index = $mem$$index;
 2517     int scale = $mem$$scale;
 2518     int disp = $mem$$disp;
 2519     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2520 
 2521     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2522   %}
 2523 
 2524   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2525   %{
 2526     int rm_byte_opcode = $rm_opcode$$constant;
 2527 
 2528     // High registers handle in encode_RegMem
 2529     int base = $mem$$base;
 2530     int index = $mem$$index;
 2531     int scale = $mem$$scale;
 2532     int displace = $mem$$disp;
 2533 
 2534     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2535                                             // working with static
 2536                                             // globals
 2537     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2538                   disp_reloc);
 2539   %}
 2540 
 2541   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2542   %{
 2543     int reg_encoding = $dst$$reg;
 2544     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2545     int index        = 0x04;            // 0x04 indicates no index
 2546     int scale        = 0x00;            // 0x00 indicates no scale
 2547     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2548     relocInfo::relocType disp_reloc = relocInfo::none;
 2549     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2550                   disp_reloc);
 2551   %}
 2552 
 2553   enc_class neg_reg(rRegI dst)
 2554   %{
 2555     int dstenc = $dst$$reg;
 2556     if (dstenc &gt;= 8) {
 2557       emit_opcode(cbuf, Assembler::REX_B);
 2558       dstenc -= 8;
 2559     }
 2560     // NEG $dst
 2561     emit_opcode(cbuf, 0xF7);
 2562     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2563   %}
 2564 
 2565   enc_class neg_reg_wide(rRegI dst)
 2566   %{
 2567     int dstenc = $dst$$reg;
 2568     if (dstenc &lt; 8) {
 2569       emit_opcode(cbuf, Assembler::REX_W);
 2570     } else {
 2571       emit_opcode(cbuf, Assembler::REX_WB);
 2572       dstenc -= 8;
 2573     }
 2574     // NEG $dst
 2575     emit_opcode(cbuf, 0xF7);
 2576     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2577   %}
 2578 
 2579   enc_class setLT_reg(rRegI dst)
 2580   %{
 2581     int dstenc = $dst$$reg;
 2582     if (dstenc &gt;= 8) {
 2583       emit_opcode(cbuf, Assembler::REX_B);
 2584       dstenc -= 8;
 2585     } else if (dstenc &gt;= 4) {
 2586       emit_opcode(cbuf, Assembler::REX);
 2587     }
 2588     // SETLT $dst
 2589     emit_opcode(cbuf, 0x0F);
 2590     emit_opcode(cbuf, 0x9C);
 2591     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2592   %}
 2593 
 2594   enc_class setNZ_reg(rRegI dst)
 2595   %{
 2596     int dstenc = $dst$$reg;
 2597     if (dstenc &gt;= 8) {
 2598       emit_opcode(cbuf, Assembler::REX_B);
 2599       dstenc -= 8;
 2600     } else if (dstenc &gt;= 4) {
 2601       emit_opcode(cbuf, Assembler::REX);
 2602     }
 2603     // SETNZ $dst
 2604     emit_opcode(cbuf, 0x0F);
 2605     emit_opcode(cbuf, 0x95);
 2606     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2607   %}
 2608 
 2609 
 2610   // Compare the lonogs and set -1, 0, or 1 into dst
 2611   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2612   %{
 2613     int src1enc = $src1$$reg;
 2614     int src2enc = $src2$$reg;
 2615     int dstenc = $dst$$reg;
 2616 
 2617     // cmpq $src1, $src2
 2618     if (src1enc &lt; 8) {
 2619       if (src2enc &lt; 8) {
 2620         emit_opcode(cbuf, Assembler::REX_W);
 2621       } else {
 2622         emit_opcode(cbuf, Assembler::REX_WB);
 2623       }
 2624     } else {
 2625       if (src2enc &lt; 8) {
 2626         emit_opcode(cbuf, Assembler::REX_WR);
 2627       } else {
 2628         emit_opcode(cbuf, Assembler::REX_WRB);
 2629       }
 2630     }
 2631     emit_opcode(cbuf, 0x3B);
 2632     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2633 
 2634     // movl $dst, -1
 2635     if (dstenc &gt;= 8) {
 2636       emit_opcode(cbuf, Assembler::REX_B);
 2637     }
 2638     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2639     emit_d32(cbuf, -1);
 2640 
 2641     // jl,s done
 2642     emit_opcode(cbuf, 0x7C);
 2643     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2644 
 2645     // setne $dst
 2646     if (dstenc &gt;= 4) {
 2647       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2648     }
 2649     emit_opcode(cbuf, 0x0F);
 2650     emit_opcode(cbuf, 0x95);
 2651     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2652 
 2653     // movzbl $dst, $dst
 2654     if (dstenc &gt;= 4) {
 2655       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2656     }
 2657     emit_opcode(cbuf, 0x0F);
 2658     emit_opcode(cbuf, 0xB6);
 2659     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2660   %}
 2661 
 2662   enc_class Push_ResultXD(regD dst) %{
 2663     MacroAssembler _masm(&amp;cbuf);
 2664     __ fstp_d(Address(rsp, 0));
 2665     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2666     __ addptr(rsp, 8);
 2667   %}
 2668 
 2669   enc_class Push_SrcXD(regD src) %{
 2670     MacroAssembler _masm(&amp;cbuf);
 2671     __ subptr(rsp, 8);
 2672     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2673     __ fld_d(Address(rsp, 0));
 2674   %}
 2675 
 2676 
 2677   enc_class enc_rethrow()
 2678   %{
 2679     cbuf.set_insts_mark();
 2680     emit_opcode(cbuf, 0xE9); // jmp entry
 2681     emit_d32_reloc(cbuf,
 2682                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2683                    runtime_call_Relocation::spec(),
 2684                    RELOC_DISP32);
 2685   %}
 2686 
 2687 %}
 2688 
 2689 
 2690 
 2691 //----------FRAME--------------------------------------------------------------
 2692 // Definition of frame structure and management information.
 2693 //
 2694 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2695 //                             |   (to get allocators register number
 2696 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2697 //  r   CALLER     |        |
 2698 //  o     |        +--------+      pad to even-align allocators stack-slot
 2699 //  w     V        |  pad0  |        numbers; owned by CALLER
 2700 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2701 //  h     ^        |   in   |  5
 2702 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2703 //  |     |        |        |  3
 2704 //  |     |        +--------+
 2705 //  V     |        | old out|      Empty on Intel, window on Sparc
 2706 //        |    old |preserve|      Must be even aligned.
 2707 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2708 //        |        |   in   |  3   area for Intel ret address
 2709 //     Owned by    |preserve|      Empty on Sparc.
 2710 //       SELF      +--------+
 2711 //        |        |  pad2  |  2   pad to align old SP
 2712 //        |        +--------+  1
 2713 //        |        | locks  |  0
 2714 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2715 //        |        |  pad1  | 11   pad to align new SP
 2716 //        |        +--------+
 2717 //        |        |        | 10
 2718 //        |        | spills |  9   spills
 2719 //        V        |        |  8   (pad0 slot for callee)
 2720 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2721 //        ^        |  out   |  7
 2722 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2723 //     Owned by    +--------+
 2724 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2725 //        |    new |preserve|      Must be even-aligned.
 2726 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2727 //        |        |        |
 2728 //
 2729 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2730 //         known from SELF&#39;s arguments and the Java calling convention.
 2731 //         Region 6-7 is determined per call site.
 2732 // Note 2: If the calling convention leaves holes in the incoming argument
 2733 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2734 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2735 //         incoming area, as the Java calling convention is completely under
 2736 //         the control of the AD file.  Doubles can be sorted and packed to
 2737 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2738 //         varargs C calling conventions.
 2739 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2740 //         even aligned with pad0 as needed.
 2741 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2742 //         region 6-11 is even aligned; it may be padded out more so that
 2743 //         the region from SP to FP meets the minimum stack alignment.
 2744 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2745 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2746 //         SP meets the minimum alignment.
 2747 
 2748 frame
 2749 %{
 2750   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2751   stack_direction(TOWARDS_LOW);
 2752 
 2753   // These three registers define part of the calling convention
 2754   // between compiled code and the interpreter.
 2755   inline_cache_reg(RAX);                // Inline Cache Register
 2756   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2757                                         // calling interpreter
 2758 
 2759   // Optional: name the operand used by cisc-spilling to access
 2760   // [stack_pointer + offset]
 2761   cisc_spilling_operand_name(indOffset32);
 2762 
 2763   // Number of stack slots consumed by locking an object
 2764   sync_stack_slots(2);
 2765 
 2766   // Compiled code&#39;s Frame Pointer
 2767   frame_pointer(RSP);
 2768 
 2769   // Interpreter stores its frame pointer in a register which is
 2770   // stored to the stack by I2CAdaptors.
 2771   // I2CAdaptors convert from interpreted java to compiled java.
 2772   interpreter_frame_pointer(RBP);
 2773 
 2774   // Stack alignment requirement
 2775   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2776 
 2777   // Number of stack slots between incoming argument block and the start of
 2778   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2779   // EPILOG must remove this many slots.  amd64 needs two slots for
 2780   // return address.
 2781   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2782 
 2783   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2784   // for calls to C.  Supports the var-args backing area for register parms.
 2785   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2786 
 2787   // The after-PROLOG location of the return address.  Location of
 2788   // return address specifies a type (REG or STACK) and a number
 2789   // representing the register number (i.e. - use a register name) or
 2790   // stack slot.
 2791   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2792   // Otherwise, it is above the locks and verification slot and alignment word
 2793   return_addr(STACK - 2 +
 2794               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2795                         Compile::current()-&gt;fixed_slots()),
 2796                        stack_alignment_in_slots()));
 2797 
 2798   // Body of function which returns an integer array locating
 2799   // arguments either in registers or in stack slots.  Passed an array
 2800   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2801   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2802   // arguments for a CALLEE.  Incoming stack arguments are
 2803   // automatically biased by the preserve_stack_slots field above.
 2804 
 2805   calling_convention
 2806   %{
 2807     // No difference between ingoing/outgoing just pass false
 2808     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2809   %}
 2810 
 2811   c_calling_convention
 2812   %{
 2813     // This is obviously always outgoing
 2814     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2815   %}
 2816 
 2817   // Location of compiled Java return values.  Same as C for now.
 2818   return_value
 2819   %{
 2820     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2821            &quot;only return normal values&quot;);
 2822 
 2823     static const int lo[Op_RegL + 1] = {
 2824       0,
 2825       0,
 2826       RAX_num,  // Op_RegN
 2827       RAX_num,  // Op_RegI
 2828       RAX_num,  // Op_RegP
 2829       XMM0_num, // Op_RegF
 2830       XMM0_num, // Op_RegD
 2831       RAX_num   // Op_RegL
 2832     };
 2833     static const int hi[Op_RegL + 1] = {
 2834       0,
 2835       0,
 2836       OptoReg::Bad, // Op_RegN
 2837       OptoReg::Bad, // Op_RegI
 2838       RAX_H_num,    // Op_RegP
 2839       OptoReg::Bad, // Op_RegF
 2840       XMM0b_num,    // Op_RegD
 2841       RAX_H_num     // Op_RegL
 2842     };
 2843     // Excluded flags and vector registers.
 2844     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2845     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2846   %}
 2847 %}
 2848 
 2849 //----------ATTRIBUTES---------------------------------------------------------
 2850 //----------Operand Attributes-------------------------------------------------
 2851 op_attrib op_cost(0);        // Required cost attribute
 2852 
 2853 //----------Instruction Attributes---------------------------------------------
 2854 ins_attrib ins_cost(100);       // Required cost attribute
 2855 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2856 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2857                                 // a non-matching short branch variant
 2858                                 // of some long branch?
 2859 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2860                                 // be a power of 2) specifies the
 2861                                 // alignment that some part of the
 2862                                 // instruction (not necessarily the
 2863                                 // start) requires.  If &gt; 1, a
 2864                                 // compute_padding() function must be
 2865                                 // provided for the instruction
 2866 
 2867 //----------OPERANDS-----------------------------------------------------------
 2868 // Operand definitions must precede instruction definitions for correct parsing
 2869 // in the ADLC because operands constitute user defined types which are used in
 2870 // instruction definitions.
 2871 
 2872 //----------Simple Operands----------------------------------------------------
 2873 // Immediate Operands
 2874 // Integer Immediate
 2875 operand immI()
 2876 %{
 2877   match(ConI);
 2878 
 2879   op_cost(10);
 2880   format %{ %}
 2881   interface(CONST_INTER);
 2882 %}
 2883 
 2884 // Constant for test vs zero
 2885 operand immI0()
 2886 %{
 2887   predicate(n-&gt;get_int() == 0);
 2888   match(ConI);
 2889 
 2890   op_cost(0);
 2891   format %{ %}
 2892   interface(CONST_INTER);
 2893 %}
 2894 
 2895 // Constant for increment
 2896 operand immI1()
 2897 %{
 2898   predicate(n-&gt;get_int() == 1);
 2899   match(ConI);
 2900 
 2901   op_cost(0);
 2902   format %{ %}
 2903   interface(CONST_INTER);
 2904 %}
 2905 
 2906 // Constant for decrement
 2907 operand immI_M1()
 2908 %{
 2909   predicate(n-&gt;get_int() == -1);
 2910   match(ConI);
 2911 
 2912   op_cost(0);
 2913   format %{ %}
 2914   interface(CONST_INTER);
 2915 %}
 2916 
 2917 // Valid scale values for addressing modes
 2918 operand immI2()
 2919 %{
 2920   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2921   match(ConI);
 2922 
 2923   format %{ %}
 2924   interface(CONST_INTER);
 2925 %}
 2926 
 2927 operand immI8()
 2928 %{
 2929   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2930   match(ConI);
 2931 
 2932   op_cost(5);
 2933   format %{ %}
 2934   interface(CONST_INTER);
 2935 %}
 2936 
 2937 operand immU8()
 2938 %{
 2939   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2940   match(ConI);
 2941 
 2942   op_cost(5);
 2943   format %{ %}
 2944   interface(CONST_INTER);
 2945 %}
 2946 
 2947 operand immI16()
 2948 %{
 2949   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2950   match(ConI);
 2951 
 2952   op_cost(10);
 2953   format %{ %}
 2954   interface(CONST_INTER);
 2955 %}
 2956 
 2957 // Int Immediate non-negative
 2958 operand immU31()
 2959 %{
 2960   predicate(n-&gt;get_int() &gt;= 0);
 2961   match(ConI);
 2962 
 2963   op_cost(0);
 2964   format %{ %}
 2965   interface(CONST_INTER);
 2966 %}
 2967 
 2968 // Constant for long shifts
 2969 operand immI_32()
 2970 %{
 2971   predicate( n-&gt;get_int() == 32 );
 2972   match(ConI);
 2973 
 2974   op_cost(0);
 2975   format %{ %}
 2976   interface(CONST_INTER);
 2977 %}
 2978 
 2979 // Constant for long shifts
 2980 operand immI_64()
 2981 %{
 2982   predicate( n-&gt;get_int() == 64 );
 2983   match(ConI);
 2984 
 2985   op_cost(0);
 2986   format %{ %}
 2987   interface(CONST_INTER);
 2988 %}
 2989 
 2990 // Pointer Immediate
 2991 operand immP()
 2992 %{
 2993   match(ConP);
 2994 
 2995   op_cost(10);
 2996   format %{ %}
 2997   interface(CONST_INTER);
 2998 %}
 2999 
 3000 // NULL Pointer Immediate
 3001 operand immP0()
 3002 %{
 3003   predicate(n-&gt;get_ptr() == 0);
 3004   match(ConP);
 3005 
 3006   op_cost(5);
 3007   format %{ %}
 3008   interface(CONST_INTER);
 3009 %}
 3010 
 3011 // Pointer Immediate
 3012 operand immN() %{
 3013   match(ConN);
 3014 
 3015   op_cost(10);
 3016   format %{ %}
 3017   interface(CONST_INTER);
 3018 %}
 3019 
 3020 operand immNKlass() %{
 3021   match(ConNKlass);
 3022 
 3023   op_cost(10);
 3024   format %{ %}
 3025   interface(CONST_INTER);
 3026 %}
 3027 
 3028 // NULL Pointer Immediate
 3029 operand immN0() %{
 3030   predicate(n-&gt;get_narrowcon() == 0);
 3031   match(ConN);
 3032 
 3033   op_cost(5);
 3034   format %{ %}
 3035   interface(CONST_INTER);
 3036 %}
 3037 
 3038 operand immP31()
 3039 %{
 3040   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3041             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3042   match(ConP);
 3043 
 3044   op_cost(5);
 3045   format %{ %}
 3046   interface(CONST_INTER);
 3047 %}
 3048 
 3049 
 3050 // Long Immediate
 3051 operand immL()
 3052 %{
 3053   match(ConL);
 3054 
 3055   op_cost(20);
 3056   format %{ %}
 3057   interface(CONST_INTER);
 3058 %}
 3059 
 3060 // Long Immediate 8-bit
 3061 operand immL8()
 3062 %{
 3063   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3064   match(ConL);
 3065 
 3066   op_cost(5);
 3067   format %{ %}
 3068   interface(CONST_INTER);
 3069 %}
 3070 
 3071 // Long Immediate 32-bit unsigned
 3072 operand immUL32()
 3073 %{
 3074   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3075   match(ConL);
 3076 
 3077   op_cost(10);
 3078   format %{ %}
 3079   interface(CONST_INTER);
 3080 %}
 3081 
 3082 // Long Immediate 32-bit signed
 3083 operand immL32()
 3084 %{
 3085   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3086   match(ConL);
 3087 
 3088   op_cost(15);
 3089   format %{ %}
 3090   interface(CONST_INTER);
 3091 %}
 3092 
 3093 operand immL_Pow2()
 3094 %{
 3095   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3096   match(ConL);
 3097 
 3098   op_cost(15);
 3099   format %{ %}
 3100   interface(CONST_INTER);
 3101 %}
 3102 
 3103 operand immL_NotPow2()
 3104 %{
 3105   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3106   match(ConL);
 3107 
 3108   op_cost(15);
 3109   format %{ %}
 3110   interface(CONST_INTER);
 3111 %}
 3112 
 3113 // Long Immediate zero
 3114 operand immL0()
 3115 %{
 3116   predicate(n-&gt;get_long() == 0L);
 3117   match(ConL);
 3118 
 3119   op_cost(10);
 3120   format %{ %}
 3121   interface(CONST_INTER);
 3122 %}
 3123 
 3124 // Constant for increment
 3125 operand immL1()
 3126 %{
 3127   predicate(n-&gt;get_long() == 1);
 3128   match(ConL);
 3129 
 3130   format %{ %}
 3131   interface(CONST_INTER);
 3132 %}
 3133 
 3134 // Constant for decrement
 3135 operand immL_M1()
 3136 %{
 3137   predicate(n-&gt;get_long() == -1);
 3138   match(ConL);
 3139 
 3140   format %{ %}
 3141   interface(CONST_INTER);
 3142 %}
 3143 
 3144 // Long Immediate: the value 10
 3145 operand immL10()
 3146 %{
 3147   predicate(n-&gt;get_long() == 10);
 3148   match(ConL);
 3149 
 3150   format %{ %}
 3151   interface(CONST_INTER);
 3152 %}
 3153 
 3154 // Long immediate from 0 to 127.
 3155 // Used for a shorter form of long mul by 10.
 3156 operand immL_127()
 3157 %{
 3158   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3159   match(ConL);
 3160 
 3161   op_cost(10);
 3162   format %{ %}
 3163   interface(CONST_INTER);
 3164 %}
 3165 
 3166 // Long Immediate: low 32-bit mask
 3167 operand immL_32bits()
 3168 %{
 3169   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3170   match(ConL);
 3171   op_cost(20);
 3172 
 3173   format %{ %}
 3174   interface(CONST_INTER);
 3175 %}
 3176 
 3177 // Float Immediate zero
 3178 operand immF0()
 3179 %{
 3180   predicate(jint_cast(n-&gt;getf()) == 0);
 3181   match(ConF);
 3182 
 3183   op_cost(5);
 3184   format %{ %}
 3185   interface(CONST_INTER);
 3186 %}
 3187 
 3188 // Float Immediate
 3189 operand immF()
 3190 %{
 3191   match(ConF);
 3192 
 3193   op_cost(15);
 3194   format %{ %}
 3195   interface(CONST_INTER);
 3196 %}
 3197 
 3198 // Double Immediate zero
 3199 operand immD0()
 3200 %{
 3201   predicate(jlong_cast(n-&gt;getd()) == 0);
 3202   match(ConD);
 3203 
 3204   op_cost(5);
 3205   format %{ %}
 3206   interface(CONST_INTER);
 3207 %}
 3208 
 3209 // Double Immediate
 3210 operand immD()
 3211 %{
 3212   match(ConD);
 3213 
 3214   op_cost(15);
 3215   format %{ %}
 3216   interface(CONST_INTER);
 3217 %}
 3218 
 3219 // Immediates for special shifts (sign extend)
 3220 
 3221 // Constants for increment
 3222 operand immI_16()
 3223 %{
 3224   predicate(n-&gt;get_int() == 16);
 3225   match(ConI);
 3226 
 3227   format %{ %}
 3228   interface(CONST_INTER);
 3229 %}
 3230 
 3231 operand immI_24()
 3232 %{
 3233   predicate(n-&gt;get_int() == 24);
 3234   match(ConI);
 3235 
 3236   format %{ %}
 3237   interface(CONST_INTER);
 3238 %}
 3239 
 3240 // Constant for byte-wide masking
 3241 operand immI_255()
 3242 %{
 3243   predicate(n-&gt;get_int() == 255);
 3244   match(ConI);
 3245 
 3246   format %{ %}
 3247   interface(CONST_INTER);
 3248 %}
 3249 
 3250 // Constant for short-wide masking
 3251 operand immI_65535()
 3252 %{
 3253   predicate(n-&gt;get_int() == 65535);
 3254   match(ConI);
 3255 
 3256   format %{ %}
 3257   interface(CONST_INTER);
 3258 %}
 3259 
 3260 // Constant for byte-wide masking
 3261 operand immL_255()
 3262 %{
 3263   predicate(n-&gt;get_long() == 255);
 3264   match(ConL);
 3265 
 3266   format %{ %}
 3267   interface(CONST_INTER);
 3268 %}
 3269 
 3270 // Constant for short-wide masking
 3271 operand immL_65535()
 3272 %{
 3273   predicate(n-&gt;get_long() == 65535);
 3274   match(ConL);
 3275 
 3276   format %{ %}
 3277   interface(CONST_INTER);
 3278 %}
 3279 
 3280 // Register Operands
 3281 // Integer Register
 3282 operand rRegI()
 3283 %{
 3284   constraint(ALLOC_IN_RC(int_reg));
 3285   match(RegI);
 3286 
 3287   match(rax_RegI);
 3288   match(rbx_RegI);
 3289   match(rcx_RegI);
 3290   match(rdx_RegI);
 3291   match(rdi_RegI);
 3292 
 3293   format %{ %}
 3294   interface(REG_INTER);
 3295 %}
 3296 
 3297 // Special Registers
 3298 operand rax_RegI()
 3299 %{
 3300   constraint(ALLOC_IN_RC(int_rax_reg));
 3301   match(RegI);
 3302   match(rRegI);
 3303 
 3304   format %{ &quot;RAX&quot; %}
 3305   interface(REG_INTER);
 3306 %}
 3307 
 3308 // Special Registers
 3309 operand rbx_RegI()
 3310 %{
 3311   constraint(ALLOC_IN_RC(int_rbx_reg));
 3312   match(RegI);
 3313   match(rRegI);
 3314 
 3315   format %{ &quot;RBX&quot; %}
 3316   interface(REG_INTER);
 3317 %}
 3318 
 3319 operand rcx_RegI()
 3320 %{
 3321   constraint(ALLOC_IN_RC(int_rcx_reg));
 3322   match(RegI);
 3323   match(rRegI);
 3324 
 3325   format %{ &quot;RCX&quot; %}
 3326   interface(REG_INTER);
 3327 %}
 3328 
 3329 operand rdx_RegI()
 3330 %{
 3331   constraint(ALLOC_IN_RC(int_rdx_reg));
 3332   match(RegI);
 3333   match(rRegI);
 3334 
 3335   format %{ &quot;RDX&quot; %}
 3336   interface(REG_INTER);
 3337 %}
 3338 
 3339 operand rdi_RegI()
 3340 %{
 3341   constraint(ALLOC_IN_RC(int_rdi_reg));
 3342   match(RegI);
 3343   match(rRegI);
 3344 
 3345   format %{ &quot;RDI&quot; %}
 3346   interface(REG_INTER);
 3347 %}
 3348 
 3349 operand no_rcx_RegI()
 3350 %{
 3351   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3352   match(RegI);
 3353   match(rax_RegI);
 3354   match(rbx_RegI);
 3355   match(rdx_RegI);
 3356   match(rdi_RegI);
 3357 
 3358   format %{ %}
 3359   interface(REG_INTER);
 3360 %}
 3361 
 3362 operand no_rax_rdx_RegI()
 3363 %{
 3364   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3365   match(RegI);
 3366   match(rbx_RegI);
 3367   match(rcx_RegI);
 3368   match(rdi_RegI);
 3369 
 3370   format %{ %}
 3371   interface(REG_INTER);
 3372 %}
 3373 
 3374 // Pointer Register
 3375 operand any_RegP()
 3376 %{
 3377   constraint(ALLOC_IN_RC(any_reg));
 3378   match(RegP);
 3379   match(rax_RegP);
 3380   match(rbx_RegP);
 3381   match(rdi_RegP);
 3382   match(rsi_RegP);
 3383   match(rbp_RegP);
 3384   match(r15_RegP);
 3385   match(rRegP);
 3386 
 3387   format %{ %}
 3388   interface(REG_INTER);
 3389 %}
 3390 
 3391 operand rRegP()
 3392 %{
 3393   constraint(ALLOC_IN_RC(ptr_reg));
 3394   match(RegP);
 3395   match(rax_RegP);
 3396   match(rbx_RegP);
 3397   match(rdi_RegP);
 3398   match(rsi_RegP);
 3399   match(rbp_RegP);  // See Q&amp;A below about
 3400   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3401 
 3402   format %{ %}
 3403   interface(REG_INTER);
 3404 %}
 3405 
 3406 operand rRegN() %{
 3407   constraint(ALLOC_IN_RC(int_reg));
 3408   match(RegN);
 3409 
 3410   format %{ %}
 3411   interface(REG_INTER);
 3412 %}
 3413 
 3414 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3415 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3416 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3417 // The output of an instruction is controlled by the allocator, which respects
 3418 // register class masks, not match rules.  Unless an instruction mentions
 3419 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3420 // by the allocator as an input.
 3421 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3422 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3423 // result, RBP is not included in the output of the instruction either.
 3424 
 3425 operand no_rax_RegP()
 3426 %{
 3427   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3428   match(RegP);
 3429   match(rbx_RegP);
 3430   match(rsi_RegP);
 3431   match(rdi_RegP);
 3432 
 3433   format %{ %}
 3434   interface(REG_INTER);
 3435 %}
 3436 
 3437 // This operand is not allowed to use RBP even if
 3438 // RBP is not used to hold the frame pointer.
 3439 operand no_rbp_RegP()
 3440 %{
 3441   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3442   match(RegP);
 3443   match(rbx_RegP);
 3444   match(rsi_RegP);
 3445   match(rdi_RegP);
 3446 
 3447   format %{ %}
 3448   interface(REG_INTER);
 3449 %}
 3450 
 3451 operand no_rax_rbx_RegP()
 3452 %{
 3453   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3454   match(RegP);
 3455   match(rsi_RegP);
 3456   match(rdi_RegP);
 3457 
 3458   format %{ %}
 3459   interface(REG_INTER);
 3460 %}
 3461 
 3462 // Special Registers
 3463 // Return a pointer value
 3464 operand rax_RegP()
 3465 %{
 3466   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3467   match(RegP);
 3468   match(rRegP);
 3469 
 3470   format %{ %}
 3471   interface(REG_INTER);
 3472 %}
 3473 
 3474 // Special Registers
 3475 // Return a compressed pointer value
 3476 operand rax_RegN()
 3477 %{
 3478   constraint(ALLOC_IN_RC(int_rax_reg));
 3479   match(RegN);
 3480   match(rRegN);
 3481 
 3482   format %{ %}
 3483   interface(REG_INTER);
 3484 %}
 3485 
 3486 // Used in AtomicAdd
 3487 operand rbx_RegP()
 3488 %{
 3489   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3490   match(RegP);
 3491   match(rRegP);
 3492 
 3493   format %{ %}
 3494   interface(REG_INTER);
 3495 %}
 3496 
 3497 operand rsi_RegP()
 3498 %{
 3499   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3500   match(RegP);
 3501   match(rRegP);
 3502 
 3503   format %{ %}
 3504   interface(REG_INTER);
 3505 %}
 3506 
 3507 operand rbp_RegP()
 3508 %{
 3509   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3510   match(RegP);
 3511   match(rRegP);
 3512 
 3513   format %{ %}
 3514   interface(REG_INTER);
 3515 %}
 3516 
 3517 // Used in rep stosq
 3518 operand rdi_RegP()
 3519 %{
 3520   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3521   match(RegP);
 3522   match(rRegP);
 3523 
 3524   format %{ %}
 3525   interface(REG_INTER);
 3526 %}
 3527 
 3528 operand r15_RegP()
 3529 %{
 3530   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3531   match(RegP);
 3532   match(rRegP);
 3533 
 3534   format %{ %}
 3535   interface(REG_INTER);
 3536 %}
 3537 
 3538 operand rRegL()
 3539 %{
 3540   constraint(ALLOC_IN_RC(long_reg));
 3541   match(RegL);
 3542   match(rax_RegL);
 3543   match(rdx_RegL);
 3544 
 3545   format %{ %}
 3546   interface(REG_INTER);
 3547 %}
 3548 
 3549 // Special Registers
 3550 operand no_rax_rdx_RegL()
 3551 %{
 3552   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3553   match(RegL);
 3554   match(rRegL);
 3555 
 3556   format %{ %}
 3557   interface(REG_INTER);
 3558 %}
 3559 
 3560 operand no_rax_RegL()
 3561 %{
 3562   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3563   match(RegL);
 3564   match(rRegL);
 3565   match(rdx_RegL);
 3566 
 3567   format %{ %}
 3568   interface(REG_INTER);
 3569 %}
 3570 
 3571 operand no_rcx_RegL()
 3572 %{
 3573   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3574   match(RegL);
 3575   match(rRegL);
 3576 
 3577   format %{ %}
 3578   interface(REG_INTER);
 3579 %}
 3580 
 3581 operand rax_RegL()
 3582 %{
 3583   constraint(ALLOC_IN_RC(long_rax_reg));
 3584   match(RegL);
 3585   match(rRegL);
 3586 
 3587   format %{ &quot;RAX&quot; %}
 3588   interface(REG_INTER);
 3589 %}
 3590 
 3591 operand rcx_RegL()
 3592 %{
 3593   constraint(ALLOC_IN_RC(long_rcx_reg));
 3594   match(RegL);
 3595   match(rRegL);
 3596 
 3597   format %{ %}
 3598   interface(REG_INTER);
 3599 %}
 3600 
 3601 operand rdx_RegL()
 3602 %{
 3603   constraint(ALLOC_IN_RC(long_rdx_reg));
 3604   match(RegL);
 3605   match(rRegL);
 3606 
 3607   format %{ %}
 3608   interface(REG_INTER);
 3609 %}
 3610 
 3611 // Flags register, used as output of compare instructions
 3612 operand rFlagsReg()
 3613 %{
 3614   constraint(ALLOC_IN_RC(int_flags));
 3615   match(RegFlags);
 3616 
 3617   format %{ &quot;RFLAGS&quot; %}
 3618   interface(REG_INTER);
 3619 %}
 3620 
 3621 // Flags register, used as output of FLOATING POINT compare instructions
 3622 operand rFlagsRegU()
 3623 %{
 3624   constraint(ALLOC_IN_RC(int_flags));
 3625   match(RegFlags);
 3626 
 3627   format %{ &quot;RFLAGS_U&quot; %}
 3628   interface(REG_INTER);
 3629 %}
 3630 
 3631 operand rFlagsRegUCF() %{
 3632   constraint(ALLOC_IN_RC(int_flags));
 3633   match(RegFlags);
 3634   predicate(false);
 3635 
 3636   format %{ &quot;RFLAGS_U_CF&quot; %}
 3637   interface(REG_INTER);
 3638 %}
 3639 
 3640 // Float register operands
 3641 operand regF() %{
 3642    constraint(ALLOC_IN_RC(float_reg));
 3643    match(RegF);
 3644 
 3645    format %{ %}
 3646    interface(REG_INTER);
 3647 %}
 3648 
 3649 // Float register operands
 3650 operand legRegF() %{
 3651    constraint(ALLOC_IN_RC(float_reg_legacy));
 3652    match(RegF);
 3653 
 3654    format %{ %}
 3655    interface(REG_INTER);
 3656 %}
 3657 
 3658 // Float register operands
 3659 operand vlRegF() %{
 3660    constraint(ALLOC_IN_RC(float_reg_vl));
 3661    match(RegF);
 3662 
 3663    format %{ %}
 3664    interface(REG_INTER);
 3665 %}
 3666 
 3667 // Double register operands
 3668 operand regD() %{
 3669    constraint(ALLOC_IN_RC(double_reg));
 3670    match(RegD);
 3671 
 3672    format %{ %}
 3673    interface(REG_INTER);
 3674 %}
 3675 
 3676 // Double register operands
 3677 operand legRegD() %{
 3678    constraint(ALLOC_IN_RC(double_reg_legacy));
 3679    match(RegD);
 3680 
 3681    format %{ %}
 3682    interface(REG_INTER);
 3683 %}
 3684 
 3685 // Double register operands
 3686 operand vlRegD() %{
 3687    constraint(ALLOC_IN_RC(double_reg_vl));
 3688    match(RegD);
 3689 
 3690    format %{ %}
 3691    interface(REG_INTER);
 3692 %}
 3693 
 3694 //----------Memory Operands----------------------------------------------------
 3695 // Direct Memory Operand
 3696 // operand direct(immP addr)
 3697 // %{
 3698 //   match(addr);
 3699 
 3700 //   format %{ &quot;[$addr]&quot; %}
 3701 //   interface(MEMORY_INTER) %{
 3702 //     base(0xFFFFFFFF);
 3703 //     index(0x4);
 3704 //     scale(0x0);
 3705 //     disp($addr);
 3706 //   %}
 3707 // %}
 3708 
 3709 // Indirect Memory Operand
 3710 operand indirect(any_RegP reg)
 3711 %{
 3712   constraint(ALLOC_IN_RC(ptr_reg));
 3713   match(reg);
 3714 
 3715   format %{ &quot;[$reg]&quot; %}
 3716   interface(MEMORY_INTER) %{
 3717     base($reg);
 3718     index(0x4);
 3719     scale(0x0);
 3720     disp(0x0);
 3721   %}
 3722 %}
 3723 
 3724 // Indirect Memory Plus Short Offset Operand
 3725 operand indOffset8(any_RegP reg, immL8 off)
 3726 %{
 3727   constraint(ALLOC_IN_RC(ptr_reg));
 3728   match(AddP reg off);
 3729 
 3730   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3731   interface(MEMORY_INTER) %{
 3732     base($reg);
 3733     index(0x4);
 3734     scale(0x0);
 3735     disp($off);
 3736   %}
 3737 %}
 3738 
 3739 // Indirect Memory Plus Long Offset Operand
 3740 operand indOffset32(any_RegP reg, immL32 off)
 3741 %{
 3742   constraint(ALLOC_IN_RC(ptr_reg));
 3743   match(AddP reg off);
 3744 
 3745   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3746   interface(MEMORY_INTER) %{
 3747     base($reg);
 3748     index(0x4);
 3749     scale(0x0);
 3750     disp($off);
 3751   %}
 3752 %}
 3753 
 3754 // Indirect Memory Plus Index Register Plus Offset Operand
 3755 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3756 %{
 3757   constraint(ALLOC_IN_RC(ptr_reg));
 3758   match(AddP (AddP reg lreg) off);
 3759 
 3760   op_cost(10);
 3761   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3762   interface(MEMORY_INTER) %{
 3763     base($reg);
 3764     index($lreg);
 3765     scale(0x0);
 3766     disp($off);
 3767   %}
 3768 %}
 3769 
 3770 // Indirect Memory Plus Index Register Plus Offset Operand
 3771 operand indIndex(any_RegP reg, rRegL lreg)
 3772 %{
 3773   constraint(ALLOC_IN_RC(ptr_reg));
 3774   match(AddP reg lreg);
 3775 
 3776   op_cost(10);
 3777   format %{&quot;[$reg + $lreg]&quot; %}
 3778   interface(MEMORY_INTER) %{
 3779     base($reg);
 3780     index($lreg);
 3781     scale(0x0);
 3782     disp(0x0);
 3783   %}
 3784 %}
 3785 
 3786 // Indirect Memory Times Scale Plus Index Register
 3787 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3788 %{
 3789   constraint(ALLOC_IN_RC(ptr_reg));
 3790   match(AddP reg (LShiftL lreg scale));
 3791 
 3792   op_cost(10);
 3793   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3794   interface(MEMORY_INTER) %{
 3795     base($reg);
 3796     index($lreg);
 3797     scale($scale);
 3798     disp(0x0);
 3799   %}
 3800 %}
 3801 
 3802 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3803 %{
 3804   constraint(ALLOC_IN_RC(ptr_reg));
 3805   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3806   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3807 
 3808   op_cost(10);
 3809   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3810   interface(MEMORY_INTER) %{
 3811     base($reg);
 3812     index($idx);
 3813     scale($scale);
 3814     disp(0x0);
 3815   %}
 3816 %}
 3817 
 3818 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3819 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3820 %{
 3821   constraint(ALLOC_IN_RC(ptr_reg));
 3822   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3823 
 3824   op_cost(10);
 3825   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3826   interface(MEMORY_INTER) %{
 3827     base($reg);
 3828     index($lreg);
 3829     scale($scale);
 3830     disp($off);
 3831   %}
 3832 %}
 3833 
 3834 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3835 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3836 %{
 3837   constraint(ALLOC_IN_RC(ptr_reg));
 3838   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3839   match(AddP (AddP reg (ConvI2L idx)) off);
 3840 
 3841   op_cost(10);
 3842   format %{&quot;[$reg + $off + $idx]&quot; %}
 3843   interface(MEMORY_INTER) %{
 3844     base($reg);
 3845     index($idx);
 3846     scale(0x0);
 3847     disp($off);
 3848   %}
 3849 %}
 3850 
 3851 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3852 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3853 %{
 3854   constraint(ALLOC_IN_RC(ptr_reg));
 3855   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3856   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3857 
 3858   op_cost(10);
 3859   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3860   interface(MEMORY_INTER) %{
 3861     base($reg);
 3862     index($idx);
 3863     scale($scale);
 3864     disp($off);
 3865   %}
 3866 %}
 3867 
 3868 // Indirect Narrow Oop Plus Offset Operand
 3869 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3870 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3871 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3872   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3873   constraint(ALLOC_IN_RC(ptr_reg));
 3874   match(AddP (DecodeN reg) off);
 3875 
 3876   op_cost(10);
 3877   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3878   interface(MEMORY_INTER) %{
 3879     base(0xc); // R12
 3880     index($reg);
 3881     scale(0x3);
 3882     disp($off);
 3883   %}
 3884 %}
 3885 
 3886 // Indirect Memory Operand
 3887 operand indirectNarrow(rRegN reg)
 3888 %{
 3889   predicate(CompressedOops::shift() == 0);
 3890   constraint(ALLOC_IN_RC(ptr_reg));
 3891   match(DecodeN reg);
 3892 
 3893   format %{ &quot;[$reg]&quot; %}
 3894   interface(MEMORY_INTER) %{
 3895     base($reg);
 3896     index(0x4);
 3897     scale(0x0);
 3898     disp(0x0);
 3899   %}
 3900 %}
 3901 
 3902 // Indirect Memory Plus Short Offset Operand
 3903 operand indOffset8Narrow(rRegN reg, immL8 off)
 3904 %{
 3905   predicate(CompressedOops::shift() == 0);
 3906   constraint(ALLOC_IN_RC(ptr_reg));
 3907   match(AddP (DecodeN reg) off);
 3908 
 3909   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3910   interface(MEMORY_INTER) %{
 3911     base($reg);
 3912     index(0x4);
 3913     scale(0x0);
 3914     disp($off);
 3915   %}
 3916 %}
 3917 
 3918 // Indirect Memory Plus Long Offset Operand
 3919 operand indOffset32Narrow(rRegN reg, immL32 off)
 3920 %{
 3921   predicate(CompressedOops::shift() == 0);
 3922   constraint(ALLOC_IN_RC(ptr_reg));
 3923   match(AddP (DecodeN reg) off);
 3924 
 3925   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3926   interface(MEMORY_INTER) %{
 3927     base($reg);
 3928     index(0x4);
 3929     scale(0x0);
 3930     disp($off);
 3931   %}
 3932 %}
 3933 
 3934 // Indirect Memory Plus Index Register Plus Offset Operand
 3935 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3936 %{
 3937   predicate(CompressedOops::shift() == 0);
 3938   constraint(ALLOC_IN_RC(ptr_reg));
 3939   match(AddP (AddP (DecodeN reg) lreg) off);
 3940 
 3941   op_cost(10);
 3942   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3943   interface(MEMORY_INTER) %{
 3944     base($reg);
 3945     index($lreg);
 3946     scale(0x0);
 3947     disp($off);
 3948   %}
 3949 %}
 3950 
 3951 // Indirect Memory Plus Index Register Plus Offset Operand
 3952 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3953 %{
 3954   predicate(CompressedOops::shift() == 0);
 3955   constraint(ALLOC_IN_RC(ptr_reg));
 3956   match(AddP (DecodeN reg) lreg);
 3957 
 3958   op_cost(10);
 3959   format %{&quot;[$reg + $lreg]&quot; %}
 3960   interface(MEMORY_INTER) %{
 3961     base($reg);
 3962     index($lreg);
 3963     scale(0x0);
 3964     disp(0x0);
 3965   %}
 3966 %}
 3967 
 3968 // Indirect Memory Times Scale Plus Index Register
 3969 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3970 %{
 3971   predicate(CompressedOops::shift() == 0);
 3972   constraint(ALLOC_IN_RC(ptr_reg));
 3973   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3974 
 3975   op_cost(10);
 3976   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3977   interface(MEMORY_INTER) %{
 3978     base($reg);
 3979     index($lreg);
 3980     scale($scale);
 3981     disp(0x0);
 3982   %}
 3983 %}
 3984 
 3985 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3986 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3987 %{
 3988   predicate(CompressedOops::shift() == 0);
 3989   constraint(ALLOC_IN_RC(ptr_reg));
 3990   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3991 
 3992   op_cost(10);
 3993   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3994   interface(MEMORY_INTER) %{
 3995     base($reg);
 3996     index($lreg);
 3997     scale($scale);
 3998     disp($off);
 3999   %}
 4000 %}
 4001 
 4002 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4003 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4004 %{
 4005   constraint(ALLOC_IN_RC(ptr_reg));
 4006   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4007   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4008 
 4009   op_cost(10);
 4010   format %{&quot;[$reg + $off + $idx]&quot; %}
 4011   interface(MEMORY_INTER) %{
 4012     base($reg);
 4013     index($idx);
 4014     scale(0x0);
 4015     disp($off);
 4016   %}
 4017 %}
 4018 
 4019 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4020 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4021 %{
 4022   constraint(ALLOC_IN_RC(ptr_reg));
 4023   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4024   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4025 
 4026   op_cost(10);
 4027   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4028   interface(MEMORY_INTER) %{
 4029     base($reg);
 4030     index($idx);
 4031     scale($scale);
 4032     disp($off);
 4033   %}
 4034 %}
 4035 
 4036 //----------Special Memory Operands--------------------------------------------
 4037 // Stack Slot Operand - This operand is used for loading and storing temporary
 4038 //                      values on the stack where a match requires a value to
 4039 //                      flow through memory.
 4040 operand stackSlotP(sRegP reg)
 4041 %{
 4042   constraint(ALLOC_IN_RC(stack_slots));
 4043   // No match rule because this operand is only generated in matching
 4044 
 4045   format %{ &quot;[$reg]&quot; %}
 4046   interface(MEMORY_INTER) %{
 4047     base(0x4);   // RSP
 4048     index(0x4);  // No Index
 4049     scale(0x0);  // No Scale
 4050     disp($reg);  // Stack Offset
 4051   %}
 4052 %}
 4053 
 4054 operand stackSlotI(sRegI reg)
 4055 %{
 4056   constraint(ALLOC_IN_RC(stack_slots));
 4057   // No match rule because this operand is only generated in matching
 4058 
 4059   format %{ &quot;[$reg]&quot; %}
 4060   interface(MEMORY_INTER) %{
 4061     base(0x4);   // RSP
 4062     index(0x4);  // No Index
 4063     scale(0x0);  // No Scale
 4064     disp($reg);  // Stack Offset
 4065   %}
 4066 %}
 4067 
 4068 operand stackSlotF(sRegF reg)
 4069 %{
 4070   constraint(ALLOC_IN_RC(stack_slots));
 4071   // No match rule because this operand is only generated in matching
 4072 
 4073   format %{ &quot;[$reg]&quot; %}
 4074   interface(MEMORY_INTER) %{
 4075     base(0x4);   // RSP
 4076     index(0x4);  // No Index
 4077     scale(0x0);  // No Scale
 4078     disp($reg);  // Stack Offset
 4079   %}
 4080 %}
 4081 
 4082 operand stackSlotD(sRegD reg)
 4083 %{
 4084   constraint(ALLOC_IN_RC(stack_slots));
 4085   // No match rule because this operand is only generated in matching
 4086 
 4087   format %{ &quot;[$reg]&quot; %}
 4088   interface(MEMORY_INTER) %{
 4089     base(0x4);   // RSP
 4090     index(0x4);  // No Index
 4091     scale(0x0);  // No Scale
 4092     disp($reg);  // Stack Offset
 4093   %}
 4094 %}
 4095 operand stackSlotL(sRegL reg)
 4096 %{
 4097   constraint(ALLOC_IN_RC(stack_slots));
 4098   // No match rule because this operand is only generated in matching
 4099 
 4100   format %{ &quot;[$reg]&quot; %}
 4101   interface(MEMORY_INTER) %{
 4102     base(0x4);   // RSP
 4103     index(0x4);  // No Index
 4104     scale(0x0);  // No Scale
 4105     disp($reg);  // Stack Offset
 4106   %}
 4107 %}
 4108 
 4109 //----------Conditional Branch Operands----------------------------------------
 4110 // Comparison Op  - This is the operation of the comparison, and is limited to
 4111 //                  the following set of codes:
 4112 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4113 //
 4114 // Other attributes of the comparison, such as unsignedness, are specified
 4115 // by the comparison instruction that sets a condition code flags register.
 4116 // That result is represented by a flags operand whose subtype is appropriate
 4117 // to the unsignedness (etc.) of the comparison.
 4118 //
 4119 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4120 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4121 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4122 
 4123 // Comparision Code
 4124 operand cmpOp()
 4125 %{
 4126   match(Bool);
 4127 
 4128   format %{ &quot;&quot; %}
 4129   interface(COND_INTER) %{
 4130     equal(0x4, &quot;e&quot;);
 4131     not_equal(0x5, &quot;ne&quot;);
 4132     less(0xC, &quot;l&quot;);
 4133     greater_equal(0xD, &quot;ge&quot;);
 4134     less_equal(0xE, &quot;le&quot;);
 4135     greater(0xF, &quot;g&quot;);
 4136     overflow(0x0, &quot;o&quot;);
 4137     no_overflow(0x1, &quot;no&quot;);
 4138   %}
 4139 %}
 4140 
 4141 // Comparison Code, unsigned compare.  Used by FP also, with
 4142 // C2 (unordered) turned into GT or LT already.  The other bits
 4143 // C0 and C3 are turned into Carry &amp; Zero flags.
 4144 operand cmpOpU()
 4145 %{
 4146   match(Bool);
 4147 
 4148   format %{ &quot;&quot; %}
 4149   interface(COND_INTER) %{
 4150     equal(0x4, &quot;e&quot;);
 4151     not_equal(0x5, &quot;ne&quot;);
 4152     less(0x2, &quot;b&quot;);
 4153     greater_equal(0x3, &quot;nb&quot;);
 4154     less_equal(0x6, &quot;be&quot;);
 4155     greater(0x7, &quot;nbe&quot;);
 4156     overflow(0x0, &quot;o&quot;);
 4157     no_overflow(0x1, &quot;no&quot;);
 4158   %}
 4159 %}
 4160 
 4161 
 4162 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4163 operand cmpOpUCF() %{
 4164   match(Bool);
 4165   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4166             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4167             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4168             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4169   format %{ &quot;&quot; %}
 4170   interface(COND_INTER) %{
 4171     equal(0x4, &quot;e&quot;);
 4172     not_equal(0x5, &quot;ne&quot;);
 4173     less(0x2, &quot;b&quot;);
 4174     greater_equal(0x3, &quot;nb&quot;);
 4175     less_equal(0x6, &quot;be&quot;);
 4176     greater(0x7, &quot;nbe&quot;);
 4177     overflow(0x0, &quot;o&quot;);
 4178     no_overflow(0x1, &quot;no&quot;);
 4179   %}
 4180 %}
 4181 
 4182 
 4183 // Floating comparisons that can be fixed up with extra conditional jumps
 4184 operand cmpOpUCF2() %{
 4185   match(Bool);
 4186   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4187             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4188   format %{ &quot;&quot; %}
 4189   interface(COND_INTER) %{
 4190     equal(0x4, &quot;e&quot;);
 4191     not_equal(0x5, &quot;ne&quot;);
 4192     less(0x2, &quot;b&quot;);
 4193     greater_equal(0x3, &quot;nb&quot;);
 4194     less_equal(0x6, &quot;be&quot;);
 4195     greater(0x7, &quot;nbe&quot;);
 4196     overflow(0x0, &quot;o&quot;);
 4197     no_overflow(0x1, &quot;no&quot;);
 4198   %}
 4199 %}
 4200 
 4201 //----------OPERAND CLASSES----------------------------------------------------
 4202 // Operand Classes are groups of operands that are used as to simplify
 4203 // instruction definitions by not requiring the AD writer to specify separate
 4204 // instructions for every form of operand when the instruction accepts
 4205 // multiple operand types with the same basic encoding and format.  The classic
 4206 // case of this is memory operands.
 4207 
 4208 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4209                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4210                indCompressedOopOffset,
 4211                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4212                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4213                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4214 
 4215 //----------PIPELINE-----------------------------------------------------------
 4216 // Rules which define the behavior of the target architectures pipeline.
 4217 pipeline %{
 4218 
 4219 //----------ATTRIBUTES---------------------------------------------------------
 4220 attributes %{
 4221   variable_size_instructions;        // Fixed size instructions
 4222   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4223   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4224   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4225   instruction_fetch_units = 1;       // of 16 bytes
 4226 
 4227   // List of nop instructions
 4228   nops( MachNop );
 4229 %}
 4230 
 4231 //----------RESOURCES----------------------------------------------------------
 4232 // Resources are the functional units available to the machine
 4233 
 4234 // Generic P2/P3 pipeline
 4235 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4236 // 3 instructions decoded per cycle.
 4237 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4238 // 3 ALU op, only ALU0 handles mul instructions.
 4239 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4240            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4241            BR, FPU,
 4242            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4243 
 4244 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4245 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4246 
 4247 // Generic P2/P3 pipeline
 4248 pipe_desc(S0, S1, S2, S3, S4, S5);
 4249 
 4250 //----------PIPELINE CLASSES---------------------------------------------------
 4251 // Pipeline Classes describe the stages in which input and output are
 4252 // referenced by the hardware pipeline.
 4253 
 4254 // Naming convention: ialu or fpu
 4255 // Then: _reg
 4256 // Then: _reg if there is a 2nd register
 4257 // Then: _long if it&#39;s a pair of instructions implementing a long
 4258 // Then: _fat if it requires the big decoder
 4259 //   Or: _mem if it requires the big decoder and a memory unit.
 4260 
 4261 // Integer ALU reg operation
 4262 pipe_class ialu_reg(rRegI dst)
 4263 %{
 4264     single_instruction;
 4265     dst    : S4(write);
 4266     dst    : S3(read);
 4267     DECODE : S0;        // any decoder
 4268     ALU    : S3;        // any alu
 4269 %}
 4270 
 4271 // Long ALU reg operation
 4272 pipe_class ialu_reg_long(rRegL dst)
 4273 %{
 4274     instruction_count(2);
 4275     dst    : S4(write);
 4276     dst    : S3(read);
 4277     DECODE : S0(2);     // any 2 decoders
 4278     ALU    : S3(2);     // both alus
 4279 %}
 4280 
 4281 // Integer ALU reg operation using big decoder
 4282 pipe_class ialu_reg_fat(rRegI dst)
 4283 %{
 4284     single_instruction;
 4285     dst    : S4(write);
 4286     dst    : S3(read);
 4287     D0     : S0;        // big decoder only
 4288     ALU    : S3;        // any alu
 4289 %}
 4290 
 4291 // Long ALU reg operation using big decoder
 4292 pipe_class ialu_reg_long_fat(rRegL dst)
 4293 %{
 4294     instruction_count(2);
 4295     dst    : S4(write);
 4296     dst    : S3(read);
 4297     D0     : S0(2);     // big decoder only; twice
 4298     ALU    : S3(2);     // any 2 alus
 4299 %}
 4300 
 4301 // Integer ALU reg-reg operation
 4302 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4303 %{
 4304     single_instruction;
 4305     dst    : S4(write);
 4306     src    : S3(read);
 4307     DECODE : S0;        // any decoder
 4308     ALU    : S3;        // any alu
 4309 %}
 4310 
 4311 // Long ALU reg-reg operation
 4312 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4313 %{
 4314     instruction_count(2);
 4315     dst    : S4(write);
 4316     src    : S3(read);
 4317     DECODE : S0(2);     // any 2 decoders
 4318     ALU    : S3(2);     // both alus
 4319 %}
 4320 
 4321 // Integer ALU reg-reg operation
 4322 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4323 %{
 4324     single_instruction;
 4325     dst    : S4(write);
 4326     src    : S3(read);
 4327     D0     : S0;        // big decoder only
 4328     ALU    : S3;        // any alu
 4329 %}
 4330 
 4331 // Long ALU reg-reg operation
 4332 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4333 %{
 4334     instruction_count(2);
 4335     dst    : S4(write);
 4336     src    : S3(read);
 4337     D0     : S0(2);     // big decoder only; twice
 4338     ALU    : S3(2);     // both alus
 4339 %}
 4340 
 4341 // Integer ALU reg-mem operation
 4342 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4343 %{
 4344     single_instruction;
 4345     dst    : S5(write);
 4346     mem    : S3(read);
 4347     D0     : S0;        // big decoder only
 4348     ALU    : S4;        // any alu
 4349     MEM    : S3;        // any mem
 4350 %}
 4351 
 4352 // Integer mem operation (prefetch)
 4353 pipe_class ialu_mem(memory mem)
 4354 %{
 4355     single_instruction;
 4356     mem    : S3(read);
 4357     D0     : S0;        // big decoder only
 4358     MEM    : S3;        // any mem
 4359 %}
 4360 
 4361 // Integer Store to Memory
 4362 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4363 %{
 4364     single_instruction;
 4365     mem    : S3(read);
 4366     src    : S5(read);
 4367     D0     : S0;        // big decoder only
 4368     ALU    : S4;        // any alu
 4369     MEM    : S3;
 4370 %}
 4371 
 4372 // // Long Store to Memory
 4373 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4374 // %{
 4375 //     instruction_count(2);
 4376 //     mem    : S3(read);
 4377 //     src    : S5(read);
 4378 //     D0     : S0(2);          // big decoder only; twice
 4379 //     ALU    : S4(2);     // any 2 alus
 4380 //     MEM    : S3(2);  // Both mems
 4381 // %}
 4382 
 4383 // Integer Store to Memory
 4384 pipe_class ialu_mem_imm(memory mem)
 4385 %{
 4386     single_instruction;
 4387     mem    : S3(read);
 4388     D0     : S0;        // big decoder only
 4389     ALU    : S4;        // any alu
 4390     MEM    : S3;
 4391 %}
 4392 
 4393 // Integer ALU0 reg-reg operation
 4394 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4395 %{
 4396     single_instruction;
 4397     dst    : S4(write);
 4398     src    : S3(read);
 4399     D0     : S0;        // Big decoder only
 4400     ALU0   : S3;        // only alu0
 4401 %}
 4402 
 4403 // Integer ALU0 reg-mem operation
 4404 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4405 %{
 4406     single_instruction;
 4407     dst    : S5(write);
 4408     mem    : S3(read);
 4409     D0     : S0;        // big decoder only
 4410     ALU0   : S4;        // ALU0 only
 4411     MEM    : S3;        // any mem
 4412 %}
 4413 
 4414 // Integer ALU reg-reg operation
 4415 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4416 %{
 4417     single_instruction;
 4418     cr     : S4(write);
 4419     src1   : S3(read);
 4420     src2   : S3(read);
 4421     DECODE : S0;        // any decoder
 4422     ALU    : S3;        // any alu
 4423 %}
 4424 
 4425 // Integer ALU reg-imm operation
 4426 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4427 %{
 4428     single_instruction;
 4429     cr     : S4(write);
 4430     src1   : S3(read);
 4431     DECODE : S0;        // any decoder
 4432     ALU    : S3;        // any alu
 4433 %}
 4434 
 4435 // Integer ALU reg-mem operation
 4436 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4437 %{
 4438     single_instruction;
 4439     cr     : S4(write);
 4440     src1   : S3(read);
 4441     src2   : S3(read);
 4442     D0     : S0;        // big decoder only
 4443     ALU    : S4;        // any alu
 4444     MEM    : S3;
 4445 %}
 4446 
 4447 // Conditional move reg-reg
 4448 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4449 %{
 4450     instruction_count(4);
 4451     y      : S4(read);
 4452     q      : S3(read);
 4453     p      : S3(read);
 4454     DECODE : S0(4);     // any decoder
 4455 %}
 4456 
 4457 // Conditional move reg-reg
 4458 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4459 %{
 4460     single_instruction;
 4461     dst    : S4(write);
 4462     src    : S3(read);
 4463     cr     : S3(read);
 4464     DECODE : S0;        // any decoder
 4465 %}
 4466 
 4467 // Conditional move reg-mem
 4468 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4469 %{
 4470     single_instruction;
 4471     dst    : S4(write);
 4472     src    : S3(read);
 4473     cr     : S3(read);
 4474     DECODE : S0;        // any decoder
 4475     MEM    : S3;
 4476 %}
 4477 
 4478 // Conditional move reg-reg long
 4479 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4480 %{
 4481     single_instruction;
 4482     dst    : S4(write);
 4483     src    : S3(read);
 4484     cr     : S3(read);
 4485     DECODE : S0(2);     // any 2 decoders
 4486 %}
 4487 
 4488 // XXX
 4489 // // Conditional move double reg-reg
 4490 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4491 // %{
 4492 //     single_instruction;
 4493 //     dst    : S4(write);
 4494 //     src    : S3(read);
 4495 //     cr     : S3(read);
 4496 //     DECODE : S0;     // any decoder
 4497 // %}
 4498 
 4499 // Float reg-reg operation
 4500 pipe_class fpu_reg(regD dst)
 4501 %{
 4502     instruction_count(2);
 4503     dst    : S3(read);
 4504     DECODE : S0(2);     // any 2 decoders
 4505     FPU    : S3;
 4506 %}
 4507 
 4508 // Float reg-reg operation
 4509 pipe_class fpu_reg_reg(regD dst, regD src)
 4510 %{
 4511     instruction_count(2);
 4512     dst    : S4(write);
 4513     src    : S3(read);
 4514     DECODE : S0(2);     // any 2 decoders
 4515     FPU    : S3;
 4516 %}
 4517 
 4518 // Float reg-reg operation
 4519 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4520 %{
 4521     instruction_count(3);
 4522     dst    : S4(write);
 4523     src1   : S3(read);
 4524     src2   : S3(read);
 4525     DECODE : S0(3);     // any 3 decoders
 4526     FPU    : S3(2);
 4527 %}
 4528 
 4529 // Float reg-reg operation
 4530 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4531 %{
 4532     instruction_count(4);
 4533     dst    : S4(write);
 4534     src1   : S3(read);
 4535     src2   : S3(read);
 4536     src3   : S3(read);
 4537     DECODE : S0(4);     // any 3 decoders
 4538     FPU    : S3(2);
 4539 %}
 4540 
 4541 // Float reg-reg operation
 4542 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4543 %{
 4544     instruction_count(4);
 4545     dst    : S4(write);
 4546     src1   : S3(read);
 4547     src2   : S3(read);
 4548     src3   : S3(read);
 4549     DECODE : S1(3);     // any 3 decoders
 4550     D0     : S0;        // Big decoder only
 4551     FPU    : S3(2);
 4552     MEM    : S3;
 4553 %}
 4554 
 4555 // Float reg-mem operation
 4556 pipe_class fpu_reg_mem(regD dst, memory mem)
 4557 %{
 4558     instruction_count(2);
 4559     dst    : S5(write);
 4560     mem    : S3(read);
 4561     D0     : S0;        // big decoder only
 4562     DECODE : S1;        // any decoder for FPU POP
 4563     FPU    : S4;
 4564     MEM    : S3;        // any mem
 4565 %}
 4566 
 4567 // Float reg-mem operation
 4568 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4569 %{
 4570     instruction_count(3);
 4571     dst    : S5(write);
 4572     src1   : S3(read);
 4573     mem    : S3(read);
 4574     D0     : S0;        // big decoder only
 4575     DECODE : S1(2);     // any decoder for FPU POP
 4576     FPU    : S4;
 4577     MEM    : S3;        // any mem
 4578 %}
 4579 
 4580 // Float mem-reg operation
 4581 pipe_class fpu_mem_reg(memory mem, regD src)
 4582 %{
 4583     instruction_count(2);
 4584     src    : S5(read);
 4585     mem    : S3(read);
 4586     DECODE : S0;        // any decoder for FPU PUSH
 4587     D0     : S1;        // big decoder only
 4588     FPU    : S4;
 4589     MEM    : S3;        // any mem
 4590 %}
 4591 
 4592 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4593 %{
 4594     instruction_count(3);
 4595     src1   : S3(read);
 4596     src2   : S3(read);
 4597     mem    : S3(read);
 4598     DECODE : S0(2);     // any decoder for FPU PUSH
 4599     D0     : S1;        // big decoder only
 4600     FPU    : S4;
 4601     MEM    : S3;        // any mem
 4602 %}
 4603 
 4604 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4605 %{
 4606     instruction_count(3);
 4607     src1   : S3(read);
 4608     src2   : S3(read);
 4609     mem    : S4(read);
 4610     DECODE : S0;        // any decoder for FPU PUSH
 4611     D0     : S0(2);     // big decoder only
 4612     FPU    : S4;
 4613     MEM    : S3(2);     // any mem
 4614 %}
 4615 
 4616 pipe_class fpu_mem_mem(memory dst, memory src1)
 4617 %{
 4618     instruction_count(2);
 4619     src1   : S3(read);
 4620     dst    : S4(read);
 4621     D0     : S0(2);     // big decoder only
 4622     MEM    : S3(2);     // any mem
 4623 %}
 4624 
 4625 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4626 %{
 4627     instruction_count(3);
 4628     src1   : S3(read);
 4629     src2   : S3(read);
 4630     dst    : S4(read);
 4631     D0     : S0(3);     // big decoder only
 4632     FPU    : S4;
 4633     MEM    : S3(3);     // any mem
 4634 %}
 4635 
 4636 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4637 %{
 4638     instruction_count(3);
 4639     src1   : S4(read);
 4640     mem    : S4(read);
 4641     DECODE : S0;        // any decoder for FPU PUSH
 4642     D0     : S0(2);     // big decoder only
 4643     FPU    : S4;
 4644     MEM    : S3(2);     // any mem
 4645 %}
 4646 
 4647 // Float load constant
 4648 pipe_class fpu_reg_con(regD dst)
 4649 %{
 4650     instruction_count(2);
 4651     dst    : S5(write);
 4652     D0     : S0;        // big decoder only for the load
 4653     DECODE : S1;        // any decoder for FPU POP
 4654     FPU    : S4;
 4655     MEM    : S3;        // any mem
 4656 %}
 4657 
 4658 // Float load constant
 4659 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4660 %{
 4661     instruction_count(3);
 4662     dst    : S5(write);
 4663     src    : S3(read);
 4664     D0     : S0;        // big decoder only for the load
 4665     DECODE : S1(2);     // any decoder for FPU POP
 4666     FPU    : S4;
 4667     MEM    : S3;        // any mem
 4668 %}
 4669 
 4670 // UnConditional branch
 4671 pipe_class pipe_jmp(label labl)
 4672 %{
 4673     single_instruction;
 4674     BR   : S3;
 4675 %}
 4676 
 4677 // Conditional branch
 4678 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4679 %{
 4680     single_instruction;
 4681     cr    : S1(read);
 4682     BR    : S3;
 4683 %}
 4684 
 4685 // Allocation idiom
 4686 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4687 %{
 4688     instruction_count(1); force_serialization;
 4689     fixed_latency(6);
 4690     heap_ptr : S3(read);
 4691     DECODE   : S0(3);
 4692     D0       : S2;
 4693     MEM      : S3;
 4694     ALU      : S3(2);
 4695     dst      : S5(write);
 4696     BR       : S5;
 4697 %}
 4698 
 4699 // Generic big/slow expanded idiom
 4700 pipe_class pipe_slow()
 4701 %{
 4702     instruction_count(10); multiple_bundles; force_serialization;
 4703     fixed_latency(100);
 4704     D0  : S0(2);
 4705     MEM : S3(2);
 4706 %}
 4707 
 4708 // The real do-nothing guy
 4709 pipe_class empty()
 4710 %{
 4711     instruction_count(0);
 4712 %}
 4713 
 4714 // Define the class for the Nop node
 4715 define
 4716 %{
 4717    MachNop = empty;
 4718 %}
 4719 
 4720 %}
 4721 
 4722 //----------INSTRUCTIONS-------------------------------------------------------
 4723 //
 4724 // match      -- States which machine-independent subtree may be replaced
 4725 //               by this instruction.
 4726 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4727 //               selection to identify a minimum cost tree of machine
 4728 //               instructions that matches a tree of machine-independent
 4729 //               instructions.
 4730 // format     -- A string providing the disassembly for this instruction.
 4731 //               The value of an instruction&#39;s operand may be inserted
 4732 //               by referring to it with a &#39;$&#39; prefix.
 4733 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4734 //               to within an encode class as $primary, $secondary, and $tertiary
 4735 //               rrspectively.  The primary opcode is commonly used to
 4736 //               indicate the type of machine instruction, while secondary
 4737 //               and tertiary are often used for prefix options or addressing
 4738 //               modes.
 4739 // ins_encode -- A list of encode classes with parameters. The encode class
 4740 //               name must have been defined in an &#39;enc_class&#39; specification
 4741 //               in the encode section of the architecture description.
 4742 
 4743 
 4744 //----------Load/Store/Move Instructions---------------------------------------
 4745 //----------Load Instructions--------------------------------------------------
 4746 
 4747 // Load Byte (8 bit signed)
 4748 instruct loadB(rRegI dst, memory mem)
 4749 %{
 4750   match(Set dst (LoadB mem));
 4751 
 4752   ins_cost(125);
 4753   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4754 
 4755   ins_encode %{
 4756     __ movsbl($dst$$Register, $mem$$Address);
 4757   %}
 4758 
 4759   ins_pipe(ialu_reg_mem);
 4760 %}
 4761 
 4762 // Load Byte (8 bit signed) into Long Register
 4763 instruct loadB2L(rRegL dst, memory mem)
 4764 %{
 4765   match(Set dst (ConvI2L (LoadB mem)));
 4766 
 4767   ins_cost(125);
 4768   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4769 
 4770   ins_encode %{
 4771     __ movsbq($dst$$Register, $mem$$Address);
 4772   %}
 4773 
 4774   ins_pipe(ialu_reg_mem);
 4775 %}
 4776 
 4777 // Load Unsigned Byte (8 bit UNsigned)
 4778 instruct loadUB(rRegI dst, memory mem)
 4779 %{
 4780   match(Set dst (LoadUB mem));
 4781 
 4782   ins_cost(125);
 4783   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4784 
 4785   ins_encode %{
 4786     __ movzbl($dst$$Register, $mem$$Address);
 4787   %}
 4788 
 4789   ins_pipe(ialu_reg_mem);
 4790 %}
 4791 
 4792 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4793 instruct loadUB2L(rRegL dst, memory mem)
 4794 %{
 4795   match(Set dst (ConvI2L (LoadUB mem)));
 4796 
 4797   ins_cost(125);
 4798   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4799 
 4800   ins_encode %{
 4801     __ movzbq($dst$$Register, $mem$$Address);
 4802   %}
 4803 
 4804   ins_pipe(ialu_reg_mem);
 4805 %}
 4806 
 4807 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4808 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4809   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4810   effect(KILL cr);
 4811 
 4812   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4813             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4814   ins_encode %{
 4815     Register Rdst = $dst$$Register;
 4816     __ movzbq(Rdst, $mem$$Address);
 4817     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4818   %}
 4819   ins_pipe(ialu_reg_mem);
 4820 %}
 4821 
 4822 // Load Short (16 bit signed)
 4823 instruct loadS(rRegI dst, memory mem)
 4824 %{
 4825   match(Set dst (LoadS mem));
 4826 
 4827   ins_cost(125);
 4828   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4829 
 4830   ins_encode %{
 4831     __ movswl($dst$$Register, $mem$$Address);
 4832   %}
 4833 
 4834   ins_pipe(ialu_reg_mem);
 4835 %}
 4836 
 4837 // Load Short (16 bit signed) to Byte (8 bit signed)
 4838 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4839   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4840 
 4841   ins_cost(125);
 4842   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4843   ins_encode %{
 4844     __ movsbl($dst$$Register, $mem$$Address);
 4845   %}
 4846   ins_pipe(ialu_reg_mem);
 4847 %}
 4848 
 4849 // Load Short (16 bit signed) into Long Register
 4850 instruct loadS2L(rRegL dst, memory mem)
 4851 %{
 4852   match(Set dst (ConvI2L (LoadS mem)));
 4853 
 4854   ins_cost(125);
 4855   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4856 
 4857   ins_encode %{
 4858     __ movswq($dst$$Register, $mem$$Address);
 4859   %}
 4860 
 4861   ins_pipe(ialu_reg_mem);
 4862 %}
 4863 
 4864 // Load Unsigned Short/Char (16 bit UNsigned)
 4865 instruct loadUS(rRegI dst, memory mem)
 4866 %{
 4867   match(Set dst (LoadUS mem));
 4868 
 4869   ins_cost(125);
 4870   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4871 
 4872   ins_encode %{
 4873     __ movzwl($dst$$Register, $mem$$Address);
 4874   %}
 4875 
 4876   ins_pipe(ialu_reg_mem);
 4877 %}
 4878 
 4879 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4880 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4881   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4882 
 4883   ins_cost(125);
 4884   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4885   ins_encode %{
 4886     __ movsbl($dst$$Register, $mem$$Address);
 4887   %}
 4888   ins_pipe(ialu_reg_mem);
 4889 %}
 4890 
 4891 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4892 instruct loadUS2L(rRegL dst, memory mem)
 4893 %{
 4894   match(Set dst (ConvI2L (LoadUS mem)));
 4895 
 4896   ins_cost(125);
 4897   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4898 
 4899   ins_encode %{
 4900     __ movzwq($dst$$Register, $mem$$Address);
 4901   %}
 4902 
 4903   ins_pipe(ialu_reg_mem);
 4904 %}
 4905 
 4906 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4907 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4908   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4909 
 4910   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4911   ins_encode %{
 4912     __ movzbq($dst$$Register, $mem$$Address);
 4913   %}
 4914   ins_pipe(ialu_reg_mem);
 4915 %}
 4916 
 4917 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4918 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4919   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4920   effect(KILL cr);
 4921 
 4922   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4923             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4924   ins_encode %{
 4925     Register Rdst = $dst$$Register;
 4926     __ movzwq(Rdst, $mem$$Address);
 4927     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4928   %}
 4929   ins_pipe(ialu_reg_mem);
 4930 %}
 4931 
 4932 // Load Integer
 4933 instruct loadI(rRegI dst, memory mem)
 4934 %{
 4935   match(Set dst (LoadI mem));
 4936 
 4937   ins_cost(125);
 4938   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4939 
 4940   ins_encode %{
 4941     __ movl($dst$$Register, $mem$$Address);
 4942   %}
 4943 
 4944   ins_pipe(ialu_reg_mem);
 4945 %}
 4946 
 4947 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4948 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4949   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4950 
 4951   ins_cost(125);
 4952   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4953   ins_encode %{
 4954     __ movsbl($dst$$Register, $mem$$Address);
 4955   %}
 4956   ins_pipe(ialu_reg_mem);
 4957 %}
 4958 
 4959 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4960 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4961   match(Set dst (AndI (LoadI mem) mask));
 4962 
 4963   ins_cost(125);
 4964   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4965   ins_encode %{
 4966     __ movzbl($dst$$Register, $mem$$Address);
 4967   %}
 4968   ins_pipe(ialu_reg_mem);
 4969 %}
 4970 
 4971 // Load Integer (32 bit signed) to Short (16 bit signed)
 4972 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4973   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4974 
 4975   ins_cost(125);
 4976   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4977   ins_encode %{
 4978     __ movswl($dst$$Register, $mem$$Address);
 4979   %}
 4980   ins_pipe(ialu_reg_mem);
 4981 %}
 4982 
 4983 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4984 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4985   match(Set dst (AndI (LoadI mem) mask));
 4986 
 4987   ins_cost(125);
 4988   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4989   ins_encode %{
 4990     __ movzwl($dst$$Register, $mem$$Address);
 4991   %}
 4992   ins_pipe(ialu_reg_mem);
 4993 %}
 4994 
 4995 // Load Integer into Long Register
 4996 instruct loadI2L(rRegL dst, memory mem)
 4997 %{
 4998   match(Set dst (ConvI2L (LoadI mem)));
 4999 
 5000   ins_cost(125);
 5001   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5002 
 5003   ins_encode %{
 5004     __ movslq($dst$$Register, $mem$$Address);
 5005   %}
 5006 
 5007   ins_pipe(ialu_reg_mem);
 5008 %}
 5009 
 5010 // Load Integer with mask 0xFF into Long Register
 5011 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5012   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5013 
 5014   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5015   ins_encode %{
 5016     __ movzbq($dst$$Register, $mem$$Address);
 5017   %}
 5018   ins_pipe(ialu_reg_mem);
 5019 %}
 5020 
 5021 // Load Integer with mask 0xFFFF into Long Register
 5022 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5023   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5024 
 5025   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5026   ins_encode %{
 5027     __ movzwq($dst$$Register, $mem$$Address);
 5028   %}
 5029   ins_pipe(ialu_reg_mem);
 5030 %}
 5031 
 5032 // Load Integer with a 31-bit mask into Long Register
 5033 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5034   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5035   effect(KILL cr);
 5036 
 5037   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5038             &quot;andl    $dst, $mask&quot; %}
 5039   ins_encode %{
 5040     Register Rdst = $dst$$Register;
 5041     __ movl(Rdst, $mem$$Address);
 5042     __ andl(Rdst, $mask$$constant);
 5043   %}
 5044   ins_pipe(ialu_reg_mem);
 5045 %}
 5046 
 5047 // Load Unsigned Integer into Long Register
 5048 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5049 %{
 5050   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5051 
 5052   ins_cost(125);
 5053   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5054 
 5055   ins_encode %{
 5056     __ movl($dst$$Register, $mem$$Address);
 5057   %}
 5058 
 5059   ins_pipe(ialu_reg_mem);
 5060 %}
 5061 
 5062 // Load Long
 5063 instruct loadL(rRegL dst, memory mem)
 5064 %{
 5065   match(Set dst (LoadL mem));
 5066 
 5067   ins_cost(125);
 5068   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5069 
 5070   ins_encode %{
 5071     __ movq($dst$$Register, $mem$$Address);
 5072   %}
 5073 
 5074   ins_pipe(ialu_reg_mem); // XXX
 5075 %}
 5076 
 5077 // Load Range
 5078 instruct loadRange(rRegI dst, memory mem)
 5079 %{
 5080   match(Set dst (LoadRange mem));
 5081 
 5082   ins_cost(125); // XXX
 5083   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5084   opcode(0x8B);
 5085   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5086   ins_pipe(ialu_reg_mem);
 5087 %}
 5088 
 5089 // Load Pointer
 5090 instruct loadP(rRegP dst, memory mem)
 5091 %{
 5092   match(Set dst (LoadP mem));
 5093   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5094 
 5095   ins_cost(125); // XXX
 5096   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5097   opcode(0x8B);
 5098   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5099   ins_pipe(ialu_reg_mem); // XXX
 5100 %}
 5101 
 5102 // Load Compressed Pointer
 5103 instruct loadN(rRegN dst, memory mem)
 5104 %{
 5105    match(Set dst (LoadN mem));
 5106 
 5107    ins_cost(125); // XXX
 5108    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5109    ins_encode %{
 5110      __ movl($dst$$Register, $mem$$Address);
 5111    %}
 5112    ins_pipe(ialu_reg_mem); // XXX
 5113 %}
 5114 
 5115 
 5116 // Load Klass Pointer
 5117 instruct loadKlass(rRegP dst, memory mem)
 5118 %{
 5119   match(Set dst (LoadKlass mem));
 5120 
 5121   ins_cost(125); // XXX
 5122   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5123   opcode(0x8B);
 5124   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5125   ins_pipe(ialu_reg_mem); // XXX
 5126 %}
 5127 
 5128 // Load narrow Klass Pointer
 5129 instruct loadNKlass(rRegN dst, memory mem)
 5130 %{
 5131   match(Set dst (LoadNKlass mem));
 5132 
 5133   ins_cost(125); // XXX
 5134   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5135   ins_encode %{
 5136     __ movl($dst$$Register, $mem$$Address);
 5137   %}
 5138   ins_pipe(ialu_reg_mem); // XXX
 5139 %}
 5140 
 5141 // Load Float
 5142 instruct loadF(regF dst, memory mem)
 5143 %{
 5144   match(Set dst (LoadF mem));
 5145 
 5146   ins_cost(145); // XXX
 5147   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5148   ins_encode %{
 5149     __ movflt($dst$$XMMRegister, $mem$$Address);
 5150   %}
 5151   ins_pipe(pipe_slow); // XXX
 5152 %}
 5153 
 5154 // Load Float
 5155 instruct MoveF2VL(vlRegF dst, regF src) %{
 5156   match(Set dst src);
 5157   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5158   ins_encode %{
 5159     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5160   %}
 5161   ins_pipe( fpu_reg_reg );
 5162 %}
 5163 
 5164 // Load Float
 5165 instruct MoveF2LEG(legRegF dst, regF src) %{
 5166   match(Set dst src);
 5167   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5168   ins_encode %{
 5169     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5170   %}
 5171   ins_pipe( fpu_reg_reg );
 5172 %}
 5173 
 5174 // Load Float
 5175 instruct MoveVL2F(regF dst, vlRegF src) %{
 5176   match(Set dst src);
 5177   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5178   ins_encode %{
 5179     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5180   %}
 5181   ins_pipe( fpu_reg_reg );
 5182 %}
 5183 
 5184 // Load Float
 5185 instruct MoveLEG2F(regF dst, legRegF src) %{
 5186   match(Set dst src);
 5187   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5188   ins_encode %{
 5189     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5190   %}
 5191   ins_pipe( fpu_reg_reg );
 5192 %}
 5193 
 5194 // Load Double
 5195 instruct loadD_partial(regD dst, memory mem)
 5196 %{
 5197   predicate(!UseXmmLoadAndClearUpper);
 5198   match(Set dst (LoadD mem));
 5199 
 5200   ins_cost(145); // XXX
 5201   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5202   ins_encode %{
 5203     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5204   %}
 5205   ins_pipe(pipe_slow); // XXX
 5206 %}
 5207 
 5208 instruct loadD(regD dst, memory mem)
 5209 %{
 5210   predicate(UseXmmLoadAndClearUpper);
 5211   match(Set dst (LoadD mem));
 5212 
 5213   ins_cost(145); // XXX
 5214   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5215   ins_encode %{
 5216     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5217   %}
 5218   ins_pipe(pipe_slow); // XXX
 5219 %}
 5220 
 5221 // Load Double
 5222 instruct MoveD2VL(vlRegD dst, regD src) %{
 5223   match(Set dst src);
 5224   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5225   ins_encode %{
 5226     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5227   %}
 5228   ins_pipe( fpu_reg_reg );
 5229 %}
 5230 
 5231 // Load Double
 5232 instruct MoveD2LEG(legRegD dst, regD src) %{
 5233   match(Set dst src);
 5234   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5235   ins_encode %{
 5236     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5237   %}
 5238   ins_pipe( fpu_reg_reg );
 5239 %}
 5240 
 5241 // Load Double
 5242 instruct MoveVL2D(regD dst, vlRegD src) %{
 5243   match(Set dst src);
 5244   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5245   ins_encode %{
 5246     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5247   %}
 5248   ins_pipe( fpu_reg_reg );
 5249 %}
 5250 
 5251 // Load Double
 5252 instruct MoveLEG2D(regD dst, legRegD src) %{
 5253   match(Set dst src);
 5254   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5255   ins_encode %{
 5256     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5257   %}
 5258   ins_pipe( fpu_reg_reg );
 5259 %}
 5260 
 5261 // Following pseudo code describes the algorithm for max[FD]:
 5262 // Min algorithm is on similar lines
 5263 //  btmp = (b &lt; +0.0) ? a : b
 5264 //  atmp = (b &lt; +0.0) ? b : a
 5265 //  Tmp  = Max_Float(atmp , btmp)
 5266 //  Res  = (atmp == NaN) ? atmp : Tmp
 5267 
 5268 // max = java.lang.Math.max(float a, float b)
 5269 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5270   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5271   match(Set dst (MaxF a b));
 5272   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5273   format %{
 5274      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5275      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5276      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5277      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5278      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5279   %}
 5280   ins_encode %{
 5281     int vector_len = Assembler::AVX_128bit;
 5282     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5283     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5284     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5285     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5286     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5287  %}
 5288   ins_pipe( pipe_slow );
 5289 %}
 5290 
 5291 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5292   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5293   match(Set dst (MaxF a b));
 5294   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5295 
 5296   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5297   ins_encode %{
 5298     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5299                     false /*min*/, true /*single*/);
 5300   %}
 5301   ins_pipe( pipe_slow );
 5302 %}
 5303 
 5304 // max = java.lang.Math.max(double a, double b)
 5305 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5306   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5307   match(Set dst (MaxD a b));
 5308   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5309   format %{
 5310      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5311      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5312      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5313      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5314      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5315   %}
 5316   ins_encode %{
 5317     int vector_len = Assembler::AVX_128bit;
 5318     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5319     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5320     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5321     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5322     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5323   %}
 5324   ins_pipe( pipe_slow );
 5325 %}
 5326 
 5327 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5328   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5329   match(Set dst (MaxD a b));
 5330   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5331 
 5332   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5333   ins_encode %{
 5334     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5335                     false /*min*/, false /*single*/);
 5336   %}
 5337   ins_pipe( pipe_slow );
 5338 %}
 5339 
 5340 // min = java.lang.Math.min(float a, float b)
 5341 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5342   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5343   match(Set dst (MinF a b));
 5344   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5345   format %{
 5346      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5347      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5348      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5349      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5350      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5351   %}
 5352   ins_encode %{
 5353     int vector_len = Assembler::AVX_128bit;
 5354     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5355     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5356     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5357     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5358     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5359   %}
 5360   ins_pipe( pipe_slow );
 5361 %}
 5362 
 5363 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5364   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5365   match(Set dst (MinF a b));
 5366   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5367 
 5368   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5369   ins_encode %{
 5370     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5371                     true /*min*/, true /*single*/);
 5372   %}
 5373   ins_pipe( pipe_slow );
 5374 %}
 5375 
 5376 // min = java.lang.Math.min(double a, double b)
 5377 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5378   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5379   match(Set dst (MinD a b));
 5380   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5381   format %{
 5382      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5383      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5384      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5385      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5386      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5387   %}
 5388   ins_encode %{
 5389     int vector_len = Assembler::AVX_128bit;
 5390     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5391     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5392     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5393     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5394     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5395   %}
 5396   ins_pipe( pipe_slow );
 5397 %}
 5398 
 5399 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5400   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5401   match(Set dst (MinD a b));
 5402   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5403 
 5404   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5405   ins_encode %{
 5406     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5407                     true /*min*/, false /*single*/);
 5408   %}
 5409   ins_pipe( pipe_slow );
 5410 %}
 5411 
 5412 // Load Effective Address
 5413 instruct leaP8(rRegP dst, indOffset8 mem)
 5414 %{
 5415   match(Set dst mem);
 5416 
 5417   ins_cost(110); // XXX
 5418   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5419   opcode(0x8D);
 5420   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5421   ins_pipe(ialu_reg_reg_fat);
 5422 %}
 5423 
 5424 instruct leaP32(rRegP dst, indOffset32 mem)
 5425 %{
 5426   match(Set dst mem);
 5427 
 5428   ins_cost(110);
 5429   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5430   opcode(0x8D);
 5431   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5432   ins_pipe(ialu_reg_reg_fat);
 5433 %}
 5434 
 5435 // instruct leaPIdx(rRegP dst, indIndex mem)
 5436 // %{
 5437 //   match(Set dst mem);
 5438 
 5439 //   ins_cost(110);
 5440 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5441 //   opcode(0x8D);
 5442 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5443 //   ins_pipe(ialu_reg_reg_fat);
 5444 // %}
 5445 
 5446 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5447 %{
 5448   match(Set dst mem);
 5449 
 5450   ins_cost(110);
 5451   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5452   opcode(0x8D);
 5453   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5454   ins_pipe(ialu_reg_reg_fat);
 5455 %}
 5456 
 5457 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5458 %{
 5459   match(Set dst mem);
 5460 
 5461   ins_cost(110);
 5462   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5463   opcode(0x8D);
 5464   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5465   ins_pipe(ialu_reg_reg_fat);
 5466 %}
 5467 
 5468 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5469 %{
 5470   match(Set dst mem);
 5471 
 5472   ins_cost(110);
 5473   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5474   opcode(0x8D);
 5475   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5476   ins_pipe(ialu_reg_reg_fat);
 5477 %}
 5478 
 5479 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5480 %{
 5481   match(Set dst mem);
 5482 
 5483   ins_cost(110);
 5484   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5485   opcode(0x8D);
 5486   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5487   ins_pipe(ialu_reg_reg_fat);
 5488 %}
 5489 
 5490 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5491 %{
 5492   match(Set dst mem);
 5493 
 5494   ins_cost(110);
 5495   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5496   opcode(0x8D);
 5497   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5498   ins_pipe(ialu_reg_reg_fat);
 5499 %}
 5500 
 5501 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5502 %{
 5503   match(Set dst mem);
 5504 
 5505   ins_cost(110);
 5506   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5507   opcode(0x8D);
 5508   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5509   ins_pipe(ialu_reg_reg_fat);
 5510 %}
 5511 
 5512 // Load Effective Address which uses Narrow (32-bits) oop
 5513 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5514 %{
 5515   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5516   match(Set dst mem);
 5517 
 5518   ins_cost(110);
 5519   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5520   opcode(0x8D);
 5521   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5522   ins_pipe(ialu_reg_reg_fat);
 5523 %}
 5524 
 5525 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5526 %{
 5527   predicate(CompressedOops::shift() == 0);
 5528   match(Set dst mem);
 5529 
 5530   ins_cost(110); // XXX
 5531   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5532   opcode(0x8D);
 5533   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5534   ins_pipe(ialu_reg_reg_fat);
 5535 %}
 5536 
 5537 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5538 %{
 5539   predicate(CompressedOops::shift() == 0);
 5540   match(Set dst mem);
 5541 
 5542   ins_cost(110);
 5543   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5544   opcode(0x8D);
 5545   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5546   ins_pipe(ialu_reg_reg_fat);
 5547 %}
 5548 
 5549 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5550 %{
 5551   predicate(CompressedOops::shift() == 0);
 5552   match(Set dst mem);
 5553 
 5554   ins_cost(110);
 5555   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5556   opcode(0x8D);
 5557   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5558   ins_pipe(ialu_reg_reg_fat);
 5559 %}
 5560 
 5561 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5562 %{
 5563   predicate(CompressedOops::shift() == 0);
 5564   match(Set dst mem);
 5565 
 5566   ins_cost(110);
 5567   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5568   opcode(0x8D);
 5569   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5570   ins_pipe(ialu_reg_reg_fat);
 5571 %}
 5572 
 5573 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5574 %{
 5575   predicate(CompressedOops::shift() == 0);
 5576   match(Set dst mem);
 5577 
 5578   ins_cost(110);
 5579   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5580   opcode(0x8D);
 5581   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5582   ins_pipe(ialu_reg_reg_fat);
 5583 %}
 5584 
 5585 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5586 %{
 5587   predicate(CompressedOops::shift() == 0);
 5588   match(Set dst mem);
 5589 
 5590   ins_cost(110);
 5591   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5592   opcode(0x8D);
 5593   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5594   ins_pipe(ialu_reg_reg_fat);
 5595 %}
 5596 
 5597 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5598 %{
 5599   predicate(CompressedOops::shift() == 0);
 5600   match(Set dst mem);
 5601 
 5602   ins_cost(110);
 5603   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5604   opcode(0x8D);
 5605   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5606   ins_pipe(ialu_reg_reg_fat);
 5607 %}
 5608 
 5609 instruct loadConI(rRegI dst, immI src)
 5610 %{
 5611   match(Set dst src);
 5612 
 5613   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5614   ins_encode(load_immI(dst, src));
 5615   ins_pipe(ialu_reg_fat); // XXX
 5616 %}
 5617 
 5618 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5619 %{
 5620   match(Set dst src);
 5621   effect(KILL cr);
 5622 
 5623   ins_cost(50);
 5624   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5625   opcode(0x33); /* + rd */
 5626   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5627   ins_pipe(ialu_reg);
 5628 %}
 5629 
 5630 instruct loadConL(rRegL dst, immL src)
 5631 %{
 5632   match(Set dst src);
 5633 
 5634   ins_cost(150);
 5635   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5636   ins_encode(load_immL(dst, src));
 5637   ins_pipe(ialu_reg);
 5638 %}
 5639 
 5640 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5641 %{
 5642   match(Set dst src);
 5643   effect(KILL cr);
 5644 
 5645   ins_cost(50);
 5646   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5647   opcode(0x33); /* + rd */
 5648   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5649   ins_pipe(ialu_reg); // XXX
 5650 %}
 5651 
 5652 instruct loadConUL32(rRegL dst, immUL32 src)
 5653 %{
 5654   match(Set dst src);
 5655 
 5656   ins_cost(60);
 5657   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5658   ins_encode(load_immUL32(dst, src));
 5659   ins_pipe(ialu_reg);
 5660 %}
 5661 
 5662 instruct loadConL32(rRegL dst, immL32 src)
 5663 %{
 5664   match(Set dst src);
 5665 
 5666   ins_cost(70);
 5667   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5668   ins_encode(load_immL32(dst, src));
 5669   ins_pipe(ialu_reg);
 5670 %}
 5671 
 5672 instruct loadConP(rRegP dst, immP con) %{
 5673   match(Set dst con);
 5674 
 5675   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5676   ins_encode(load_immP(dst, con));
 5677   ins_pipe(ialu_reg_fat); // XXX
 5678 %}
 5679 
 5680 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5681 %{
 5682   match(Set dst src);
 5683   effect(KILL cr);
 5684 
 5685   ins_cost(50);
 5686   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5687   opcode(0x33); /* + rd */
 5688   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5689   ins_pipe(ialu_reg);
 5690 %}
 5691 
 5692 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5693 %{
 5694   match(Set dst src);
 5695   effect(KILL cr);
 5696 
 5697   ins_cost(60);
 5698   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5699   ins_encode(load_immP31(dst, src));
 5700   ins_pipe(ialu_reg);
 5701 %}
 5702 
 5703 instruct loadConF(regF dst, immF con) %{
 5704   match(Set dst con);
 5705   ins_cost(125);
 5706   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5707   ins_encode %{
 5708     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5709   %}
 5710   ins_pipe(pipe_slow);
 5711 %}
 5712 
 5713 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5714   match(Set dst src);
 5715   effect(KILL cr);
 5716   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5717   ins_encode %{
 5718     __ xorq($dst$$Register, $dst$$Register);
 5719   %}
 5720   ins_pipe(ialu_reg);
 5721 %}
 5722 
 5723 instruct loadConN(rRegN dst, immN src) %{
 5724   match(Set dst src);
 5725 
 5726   ins_cost(125);
 5727   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5728   ins_encode %{
 5729     address con = (address)$src$$constant;
 5730     if (con == NULL) {
 5731       ShouldNotReachHere();
 5732     } else {
 5733       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5734     }
 5735   %}
 5736   ins_pipe(ialu_reg_fat); // XXX
 5737 %}
 5738 
 5739 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5740   match(Set dst src);
 5741 
 5742   ins_cost(125);
 5743   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5744   ins_encode %{
 5745     address con = (address)$src$$constant;
 5746     if (con == NULL) {
 5747       ShouldNotReachHere();
 5748     } else {
 5749       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5750     }
 5751   %}
 5752   ins_pipe(ialu_reg_fat); // XXX
 5753 %}
 5754 
 5755 instruct loadConF0(regF dst, immF0 src)
 5756 %{
 5757   match(Set dst src);
 5758   ins_cost(100);
 5759 
 5760   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5761   ins_encode %{
 5762     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5763   %}
 5764   ins_pipe(pipe_slow);
 5765 %}
 5766 
 5767 // Use the same format since predicate() can not be used here.
 5768 instruct loadConD(regD dst, immD con) %{
 5769   match(Set dst con);
 5770   ins_cost(125);
 5771   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5772   ins_encode %{
 5773     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5774   %}
 5775   ins_pipe(pipe_slow);
 5776 %}
 5777 
 5778 instruct loadConD0(regD dst, immD0 src)
 5779 %{
 5780   match(Set dst src);
 5781   ins_cost(100);
 5782 
 5783   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5784   ins_encode %{
 5785     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5786   %}
 5787   ins_pipe(pipe_slow);
 5788 %}
 5789 
 5790 instruct loadSSI(rRegI dst, stackSlotI src)
 5791 %{
 5792   match(Set dst src);
 5793 
 5794   ins_cost(125);
 5795   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5796   opcode(0x8B);
 5797   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5798   ins_pipe(ialu_reg_mem);
 5799 %}
 5800 
 5801 instruct loadSSL(rRegL dst, stackSlotL src)
 5802 %{
 5803   match(Set dst src);
 5804 
 5805   ins_cost(125);
 5806   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5807   opcode(0x8B);
 5808   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5809   ins_pipe(ialu_reg_mem);
 5810 %}
 5811 
 5812 instruct loadSSP(rRegP dst, stackSlotP src)
 5813 %{
 5814   match(Set dst src);
 5815 
 5816   ins_cost(125);
 5817   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5818   opcode(0x8B);
 5819   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5820   ins_pipe(ialu_reg_mem);
 5821 %}
 5822 
 5823 instruct loadSSF(regF dst, stackSlotF src)
 5824 %{
 5825   match(Set dst src);
 5826 
 5827   ins_cost(125);
 5828   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5829   ins_encode %{
 5830     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5831   %}
 5832   ins_pipe(pipe_slow); // XXX
 5833 %}
 5834 
 5835 // Use the same format since predicate() can not be used here.
 5836 instruct loadSSD(regD dst, stackSlotD src)
 5837 %{
 5838   match(Set dst src);
 5839 
 5840   ins_cost(125);
 5841   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5842   ins_encode  %{
 5843     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5844   %}
 5845   ins_pipe(pipe_slow); // XXX
 5846 %}
 5847 
 5848 // Prefetch instructions for allocation.
 5849 // Must be safe to execute with invalid address (cannot fault).
 5850 
 5851 instruct prefetchAlloc( memory mem ) %{
 5852   predicate(AllocatePrefetchInstr==3);
 5853   match(PrefetchAllocation mem);
 5854   ins_cost(125);
 5855 
 5856   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5857   ins_encode %{
 5858     __ prefetchw($mem$$Address);
 5859   %}
 5860   ins_pipe(ialu_mem);
 5861 %}
 5862 
 5863 instruct prefetchAllocNTA( memory mem ) %{
 5864   predicate(AllocatePrefetchInstr==0);
 5865   match(PrefetchAllocation mem);
 5866   ins_cost(125);
 5867 
 5868   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5869   ins_encode %{
 5870     __ prefetchnta($mem$$Address);
 5871   %}
 5872   ins_pipe(ialu_mem);
 5873 %}
 5874 
 5875 instruct prefetchAllocT0( memory mem ) %{
 5876   predicate(AllocatePrefetchInstr==1);
 5877   match(PrefetchAllocation mem);
 5878   ins_cost(125);
 5879 
 5880   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5881   ins_encode %{
 5882     __ prefetcht0($mem$$Address);
 5883   %}
 5884   ins_pipe(ialu_mem);
 5885 %}
 5886 
 5887 instruct prefetchAllocT2( memory mem ) %{
 5888   predicate(AllocatePrefetchInstr==2);
 5889   match(PrefetchAllocation mem);
 5890   ins_cost(125);
 5891 
 5892   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5893   ins_encode %{
 5894     __ prefetcht2($mem$$Address);
 5895   %}
 5896   ins_pipe(ialu_mem);
 5897 %}
 5898 
 5899 //----------Store Instructions-------------------------------------------------
 5900 
 5901 // Store Byte
 5902 instruct storeB(memory mem, rRegI src)
 5903 %{
 5904   match(Set mem (StoreB mem src));
 5905 
 5906   ins_cost(125); // XXX
 5907   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5908   opcode(0x88);
 5909   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5910   ins_pipe(ialu_mem_reg);
 5911 %}
 5912 
 5913 // Store Char/Short
 5914 instruct storeC(memory mem, rRegI src)
 5915 %{
 5916   match(Set mem (StoreC mem src));
 5917 
 5918   ins_cost(125); // XXX
 5919   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5920   opcode(0x89);
 5921   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5922   ins_pipe(ialu_mem_reg);
 5923 %}
 5924 
 5925 // Store Integer
 5926 instruct storeI(memory mem, rRegI src)
 5927 %{
 5928   match(Set mem (StoreI mem src));
 5929 
 5930   ins_cost(125); // XXX
 5931   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5932   opcode(0x89);
 5933   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5934   ins_pipe(ialu_mem_reg);
 5935 %}
 5936 
 5937 // Store Long
 5938 instruct storeL(memory mem, rRegL src)
 5939 %{
 5940   match(Set mem (StoreL mem src));
 5941 
 5942   ins_cost(125); // XXX
 5943   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5944   opcode(0x89);
 5945   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5946   ins_pipe(ialu_mem_reg); // XXX
 5947 %}
 5948 
 5949 // Store Pointer
 5950 instruct storeP(memory mem, any_RegP src)
 5951 %{
 5952   match(Set mem (StoreP mem src));
 5953 
 5954   ins_cost(125); // XXX
 5955   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5956   opcode(0x89);
 5957   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5958   ins_pipe(ialu_mem_reg);
 5959 %}
 5960 
 5961 instruct storeImmP0(memory mem, immP0 zero)
 5962 %{
 5963   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 5964   match(Set mem (StoreP mem zero));
 5965 
 5966   ins_cost(125); // XXX
 5967   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5968   ins_encode %{
 5969     __ movq($mem$$Address, r12);
 5970   %}
 5971   ins_pipe(ialu_mem_reg);
 5972 %}
 5973 
 5974 // Store NULL Pointer, mark word, or other simple pointer constant.
 5975 instruct storeImmP(memory mem, immP31 src)
 5976 %{
 5977   match(Set mem (StoreP mem src));
 5978 
 5979   ins_cost(150); // XXX
 5980   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5981   opcode(0xC7); /* C7 /0 */
 5982   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5983   ins_pipe(ialu_mem_imm);
 5984 %}
 5985 
 5986 // Store Compressed Pointer
 5987 instruct storeN(memory mem, rRegN src)
 5988 %{
 5989   match(Set mem (StoreN mem src));
 5990 
 5991   ins_cost(125); // XXX
 5992   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5993   ins_encode %{
 5994     __ movl($mem$$Address, $src$$Register);
 5995   %}
 5996   ins_pipe(ialu_mem_reg);
 5997 %}
 5998 
 5999 instruct storeNKlass(memory mem, rRegN src)
 6000 %{
 6001   match(Set mem (StoreNKlass mem src));
 6002 
 6003   ins_cost(125); // XXX
 6004   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6005   ins_encode %{
 6006     __ movl($mem$$Address, $src$$Register);
 6007   %}
 6008   ins_pipe(ialu_mem_reg);
 6009 %}
 6010 
 6011 instruct storeImmN0(memory mem, immN0 zero)
 6012 %{
 6013   predicate(CompressedOops::base() == NULL);
 6014   match(Set mem (StoreN mem zero));
 6015 
 6016   ins_cost(125); // XXX
 6017   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6018   ins_encode %{
 6019     __ movl($mem$$Address, r12);
 6020   %}
 6021   ins_pipe(ialu_mem_reg);
 6022 %}
 6023 
 6024 instruct storeImmN(memory mem, immN src)
 6025 %{
 6026   match(Set mem (StoreN mem src));
 6027 
 6028   ins_cost(150); // XXX
 6029   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6030   ins_encode %{
 6031     address con = (address)$src$$constant;
 6032     if (con == NULL) {
 6033       __ movl($mem$$Address, (int32_t)0);
 6034     } else {
 6035       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6036     }
 6037   %}
 6038   ins_pipe(ialu_mem_imm);
 6039 %}
 6040 
 6041 instruct storeImmNKlass(memory mem, immNKlass src)
 6042 %{
 6043   match(Set mem (StoreNKlass mem src));
 6044 
 6045   ins_cost(150); // XXX
 6046   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6047   ins_encode %{
 6048     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6049   %}
 6050   ins_pipe(ialu_mem_imm);
 6051 %}
 6052 
 6053 // Store Integer Immediate
 6054 instruct storeImmI0(memory mem, immI0 zero)
 6055 %{
 6056   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6057   match(Set mem (StoreI mem zero));
 6058 
 6059   ins_cost(125); // XXX
 6060   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6061   ins_encode %{
 6062     __ movl($mem$$Address, r12);
 6063   %}
 6064   ins_pipe(ialu_mem_reg);
 6065 %}
 6066 
 6067 instruct storeImmI(memory mem, immI src)
 6068 %{
 6069   match(Set mem (StoreI mem src));
 6070 
 6071   ins_cost(150);
 6072   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6073   opcode(0xC7); /* C7 /0 */
 6074   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6075   ins_pipe(ialu_mem_imm);
 6076 %}
 6077 
 6078 // Store Long Immediate
 6079 instruct storeImmL0(memory mem, immL0 zero)
 6080 %{
 6081   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6082   match(Set mem (StoreL mem zero));
 6083 
 6084   ins_cost(125); // XXX
 6085   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6086   ins_encode %{
 6087     __ movq($mem$$Address, r12);
 6088   %}
 6089   ins_pipe(ialu_mem_reg);
 6090 %}
 6091 
 6092 instruct storeImmL(memory mem, immL32 src)
 6093 %{
 6094   match(Set mem (StoreL mem src));
 6095 
 6096   ins_cost(150);
 6097   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6098   opcode(0xC7); /* C7 /0 */
 6099   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6100   ins_pipe(ialu_mem_imm);
 6101 %}
 6102 
 6103 // Store Short/Char Immediate
 6104 instruct storeImmC0(memory mem, immI0 zero)
 6105 %{
 6106   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6107   match(Set mem (StoreC mem zero));
 6108 
 6109   ins_cost(125); // XXX
 6110   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6111   ins_encode %{
 6112     __ movw($mem$$Address, r12);
 6113   %}
 6114   ins_pipe(ialu_mem_reg);
 6115 %}
 6116 
 6117 instruct storeImmI16(memory mem, immI16 src)
 6118 %{
 6119   predicate(UseStoreImmI16);
 6120   match(Set mem (StoreC mem src));
 6121 
 6122   ins_cost(150);
 6123   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6124   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6125   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6126   ins_pipe(ialu_mem_imm);
 6127 %}
 6128 
 6129 // Store Byte Immediate
 6130 instruct storeImmB0(memory mem, immI0 zero)
 6131 %{
 6132   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6133   match(Set mem (StoreB mem zero));
 6134 
 6135   ins_cost(125); // XXX
 6136   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6137   ins_encode %{
 6138     __ movb($mem$$Address, r12);
 6139   %}
 6140   ins_pipe(ialu_mem_reg);
 6141 %}
 6142 
 6143 instruct storeImmB(memory mem, immI8 src)
 6144 %{
 6145   match(Set mem (StoreB mem src));
 6146 
 6147   ins_cost(150); // XXX
 6148   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6149   opcode(0xC6); /* C6 /0 */
 6150   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6151   ins_pipe(ialu_mem_imm);
 6152 %}
 6153 
 6154 // Store CMS card-mark Immediate
 6155 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6156 %{
 6157   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6158   match(Set mem (StoreCM mem zero));
 6159 
 6160   ins_cost(125); // XXX
 6161   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6162   ins_encode %{
 6163     __ movb($mem$$Address, r12);
 6164   %}
 6165   ins_pipe(ialu_mem_reg);
 6166 %}
 6167 
 6168 instruct storeImmCM0(memory mem, immI0 src)
 6169 %{
 6170   match(Set mem (StoreCM mem src));
 6171 
 6172   ins_cost(150); // XXX
 6173   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6174   opcode(0xC6); /* C6 /0 */
 6175   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6176   ins_pipe(ialu_mem_imm);
 6177 %}
 6178 
 6179 // Store Float
 6180 instruct storeF(memory mem, regF src)
 6181 %{
 6182   match(Set mem (StoreF mem src));
 6183 
 6184   ins_cost(95); // XXX
 6185   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6186   ins_encode %{
 6187     __ movflt($mem$$Address, $src$$XMMRegister);
 6188   %}
 6189   ins_pipe(pipe_slow); // XXX
 6190 %}
 6191 
 6192 // Store immediate Float value (it is faster than store from XMM register)
 6193 instruct storeF0(memory mem, immF0 zero)
 6194 %{
 6195   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6196   match(Set mem (StoreF mem zero));
 6197 
 6198   ins_cost(25); // XXX
 6199   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6200   ins_encode %{
 6201     __ movl($mem$$Address, r12);
 6202   %}
 6203   ins_pipe(ialu_mem_reg);
 6204 %}
 6205 
 6206 instruct storeF_imm(memory mem, immF src)
 6207 %{
 6208   match(Set mem (StoreF mem src));
 6209 
 6210   ins_cost(50);
 6211   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6212   opcode(0xC7); /* C7 /0 */
 6213   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6214   ins_pipe(ialu_mem_imm);
 6215 %}
 6216 
 6217 // Store Double
 6218 instruct storeD(memory mem, regD src)
 6219 %{
 6220   match(Set mem (StoreD mem src));
 6221 
 6222   ins_cost(95); // XXX
 6223   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6224   ins_encode %{
 6225     __ movdbl($mem$$Address, $src$$XMMRegister);
 6226   %}
 6227   ins_pipe(pipe_slow); // XXX
 6228 %}
 6229 
 6230 // Store immediate double 0.0 (it is faster than store from XMM register)
 6231 instruct storeD0_imm(memory mem, immD0 src)
 6232 %{
 6233   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6234   match(Set mem (StoreD mem src));
 6235 
 6236   ins_cost(50);
 6237   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6238   opcode(0xC7); /* C7 /0 */
 6239   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6240   ins_pipe(ialu_mem_imm);
 6241 %}
 6242 
 6243 instruct storeD0(memory mem, immD0 zero)
 6244 %{
 6245   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6246   match(Set mem (StoreD mem zero));
 6247 
 6248   ins_cost(25); // XXX
 6249   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6250   ins_encode %{
 6251     __ movq($mem$$Address, r12);
 6252   %}
 6253   ins_pipe(ialu_mem_reg);
 6254 %}
 6255 
 6256 instruct storeSSI(stackSlotI dst, rRegI src)
 6257 %{
 6258   match(Set dst src);
 6259 
 6260   ins_cost(100);
 6261   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6262   opcode(0x89);
 6263   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6264   ins_pipe( ialu_mem_reg );
 6265 %}
 6266 
 6267 instruct storeSSL(stackSlotL dst, rRegL src)
 6268 %{
 6269   match(Set dst src);
 6270 
 6271   ins_cost(100);
 6272   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6273   opcode(0x89);
 6274   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6275   ins_pipe(ialu_mem_reg);
 6276 %}
 6277 
 6278 instruct storeSSP(stackSlotP dst, rRegP src)
 6279 %{
 6280   match(Set dst src);
 6281 
 6282   ins_cost(100);
 6283   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6284   opcode(0x89);
 6285   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6286   ins_pipe(ialu_mem_reg);
 6287 %}
 6288 
 6289 instruct storeSSF(stackSlotF dst, regF src)
 6290 %{
 6291   match(Set dst src);
 6292 
 6293   ins_cost(95); // XXX
 6294   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6295   ins_encode %{
 6296     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6297   %}
 6298   ins_pipe(pipe_slow); // XXX
 6299 %}
 6300 
 6301 instruct storeSSD(stackSlotD dst, regD src)
 6302 %{
 6303   match(Set dst src);
 6304 
 6305   ins_cost(95); // XXX
 6306   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6307   ins_encode %{
 6308     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6309   %}
 6310   ins_pipe(pipe_slow); // XXX
 6311 %}
 6312 
 6313 instruct cacheWB(indirect addr)
 6314 %{
 6315   predicate(VM_Version::supports_data_cache_line_flush());
 6316   match(CacheWB addr);
 6317 
 6318   ins_cost(100);
 6319   format %{&quot;cache wb $addr&quot; %}
 6320   ins_encode %{
 6321     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6322     assert($addr$$disp == 0, &quot;should be&quot;);
 6323     __ cache_wb(Address($addr$$base$$Register, 0));
 6324   %}
 6325   ins_pipe(pipe_slow); // XXX
 6326 %}
 6327 
 6328 instruct cacheWBPreSync()
 6329 %{
 6330   predicate(VM_Version::supports_data_cache_line_flush());
 6331   match(CacheWBPreSync);
 6332 
 6333   ins_cost(100);
 6334   format %{&quot;cache wb presync&quot; %}
 6335   ins_encode %{
 6336     __ cache_wbsync(true);
 6337   %}
 6338   ins_pipe(pipe_slow); // XXX
 6339 %}
 6340 
 6341 instruct cacheWBPostSync()
 6342 %{
 6343   predicate(VM_Version::supports_data_cache_line_flush());
 6344   match(CacheWBPostSync);
 6345 
 6346   ins_cost(100);
 6347   format %{&quot;cache wb postsync&quot; %}
 6348   ins_encode %{
 6349     __ cache_wbsync(false);
 6350   %}
 6351   ins_pipe(pipe_slow); // XXX
 6352 %}
 6353 
 6354 //----------BSWAP Instructions-------------------------------------------------
 6355 instruct bytes_reverse_int(rRegI dst) %{
 6356   match(Set dst (ReverseBytesI dst));
 6357 
 6358   format %{ &quot;bswapl  $dst&quot; %}
 6359   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6360   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6361   ins_pipe( ialu_reg );
 6362 %}
 6363 
 6364 instruct bytes_reverse_long(rRegL dst) %{
 6365   match(Set dst (ReverseBytesL dst));
 6366 
 6367   format %{ &quot;bswapq  $dst&quot; %}
 6368   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6369   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6370   ins_pipe( ialu_reg);
 6371 %}
 6372 
 6373 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6374   match(Set dst (ReverseBytesUS dst));
 6375   effect(KILL cr);
 6376 
 6377   format %{ &quot;bswapl  $dst\n\t&quot;
 6378             &quot;shrl    $dst,16\n\t&quot; %}
 6379   ins_encode %{
 6380     __ bswapl($dst$$Register);
 6381     __ shrl($dst$$Register, 16);
 6382   %}
 6383   ins_pipe( ialu_reg );
 6384 %}
 6385 
 6386 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6387   match(Set dst (ReverseBytesS dst));
 6388   effect(KILL cr);
 6389 
 6390   format %{ &quot;bswapl  $dst\n\t&quot;
 6391             &quot;sar     $dst,16\n\t&quot; %}
 6392   ins_encode %{
 6393     __ bswapl($dst$$Register);
 6394     __ sarl($dst$$Register, 16);
 6395   %}
 6396   ins_pipe( ialu_reg );
 6397 %}
 6398 
 6399 //---------- Zeros Count Instructions ------------------------------------------
 6400 
 6401 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6402   predicate(UseCountLeadingZerosInstruction);
 6403   match(Set dst (CountLeadingZerosI src));
 6404   effect(KILL cr);
 6405 
 6406   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6407   ins_encode %{
 6408     __ lzcntl($dst$$Register, $src$$Register);
 6409   %}
 6410   ins_pipe(ialu_reg);
 6411 %}
 6412 
 6413 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6414   predicate(!UseCountLeadingZerosInstruction);
 6415   match(Set dst (CountLeadingZerosI src));
 6416   effect(KILL cr);
 6417 
 6418   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6419             &quot;jnz     skip\n\t&quot;
 6420             &quot;movl    $dst, -1\n&quot;
 6421       &quot;skip:\n\t&quot;
 6422             &quot;negl    $dst\n\t&quot;
 6423             &quot;addl    $dst, 31&quot; %}
 6424   ins_encode %{
 6425     Register Rdst = $dst$$Register;
 6426     Register Rsrc = $src$$Register;
 6427     Label skip;
 6428     __ bsrl(Rdst, Rsrc);
 6429     __ jccb(Assembler::notZero, skip);
 6430     __ movl(Rdst, -1);
 6431     __ bind(skip);
 6432     __ negl(Rdst);
 6433     __ addl(Rdst, BitsPerInt - 1);
 6434   %}
 6435   ins_pipe(ialu_reg);
 6436 %}
 6437 
 6438 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6439   predicate(UseCountLeadingZerosInstruction);
 6440   match(Set dst (CountLeadingZerosL src));
 6441   effect(KILL cr);
 6442 
 6443   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6444   ins_encode %{
 6445     __ lzcntq($dst$$Register, $src$$Register);
 6446   %}
 6447   ins_pipe(ialu_reg);
 6448 %}
 6449 
 6450 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6451   predicate(!UseCountLeadingZerosInstruction);
 6452   match(Set dst (CountLeadingZerosL src));
 6453   effect(KILL cr);
 6454 
 6455   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6456             &quot;jnz     skip\n\t&quot;
 6457             &quot;movl    $dst, -1\n&quot;
 6458       &quot;skip:\n\t&quot;
 6459             &quot;negl    $dst\n\t&quot;
 6460             &quot;addl    $dst, 63&quot; %}
 6461   ins_encode %{
 6462     Register Rdst = $dst$$Register;
 6463     Register Rsrc = $src$$Register;
 6464     Label skip;
 6465     __ bsrq(Rdst, Rsrc);
 6466     __ jccb(Assembler::notZero, skip);
 6467     __ movl(Rdst, -1);
 6468     __ bind(skip);
 6469     __ negl(Rdst);
 6470     __ addl(Rdst, BitsPerLong - 1);
 6471   %}
 6472   ins_pipe(ialu_reg);
 6473 %}
 6474 
 6475 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6476   predicate(UseCountTrailingZerosInstruction);
 6477   match(Set dst (CountTrailingZerosI src));
 6478   effect(KILL cr);
 6479 
 6480   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6481   ins_encode %{
 6482     __ tzcntl($dst$$Register, $src$$Register);
 6483   %}
 6484   ins_pipe(ialu_reg);
 6485 %}
 6486 
 6487 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6488   predicate(!UseCountTrailingZerosInstruction);
 6489   match(Set dst (CountTrailingZerosI src));
 6490   effect(KILL cr);
 6491 
 6492   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6493             &quot;jnz     done\n\t&quot;
 6494             &quot;movl    $dst, 32\n&quot;
 6495       &quot;done:&quot; %}
 6496   ins_encode %{
 6497     Register Rdst = $dst$$Register;
 6498     Label done;
 6499     __ bsfl(Rdst, $src$$Register);
 6500     __ jccb(Assembler::notZero, done);
 6501     __ movl(Rdst, BitsPerInt);
 6502     __ bind(done);
 6503   %}
 6504   ins_pipe(ialu_reg);
 6505 %}
 6506 
 6507 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6508   predicate(UseCountTrailingZerosInstruction);
 6509   match(Set dst (CountTrailingZerosL src));
 6510   effect(KILL cr);
 6511 
 6512   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6513   ins_encode %{
 6514     __ tzcntq($dst$$Register, $src$$Register);
 6515   %}
 6516   ins_pipe(ialu_reg);
 6517 %}
 6518 
 6519 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6520   predicate(!UseCountTrailingZerosInstruction);
 6521   match(Set dst (CountTrailingZerosL src));
 6522   effect(KILL cr);
 6523 
 6524   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6525             &quot;jnz     done\n\t&quot;
 6526             &quot;movl    $dst, 64\n&quot;
 6527       &quot;done:&quot; %}
 6528   ins_encode %{
 6529     Register Rdst = $dst$$Register;
 6530     Label done;
 6531     __ bsfq(Rdst, $src$$Register);
 6532     __ jccb(Assembler::notZero, done);
 6533     __ movl(Rdst, BitsPerLong);
 6534     __ bind(done);
 6535   %}
 6536   ins_pipe(ialu_reg);
 6537 %}
 6538 
 6539 
 6540 //---------- Population Count Instructions -------------------------------------
 6541 
 6542 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6543   predicate(UsePopCountInstruction);
 6544   match(Set dst (PopCountI src));
 6545   effect(KILL cr);
 6546 
 6547   format %{ &quot;popcnt  $dst, $src&quot; %}
 6548   ins_encode %{
 6549     __ popcntl($dst$$Register, $src$$Register);
 6550   %}
 6551   ins_pipe(ialu_reg);
 6552 %}
 6553 
 6554 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6555   predicate(UsePopCountInstruction);
 6556   match(Set dst (PopCountI (LoadI mem)));
 6557   effect(KILL cr);
 6558 
 6559   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6560   ins_encode %{
 6561     __ popcntl($dst$$Register, $mem$$Address);
 6562   %}
 6563   ins_pipe(ialu_reg);
 6564 %}
 6565 
 6566 // Note: Long.bitCount(long) returns an int.
 6567 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6568   predicate(UsePopCountInstruction);
 6569   match(Set dst (PopCountL src));
 6570   effect(KILL cr);
 6571 
 6572   format %{ &quot;popcnt  $dst, $src&quot; %}
 6573   ins_encode %{
 6574     __ popcntq($dst$$Register, $src$$Register);
 6575   %}
 6576   ins_pipe(ialu_reg);
 6577 %}
 6578 
 6579 // Note: Long.bitCount(long) returns an int.
 6580 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6581   predicate(UsePopCountInstruction);
 6582   match(Set dst (PopCountL (LoadL mem)));
 6583   effect(KILL cr);
 6584 
 6585   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6586   ins_encode %{
 6587     __ popcntq($dst$$Register, $mem$$Address);
 6588   %}
 6589   ins_pipe(ialu_reg);
 6590 %}
 6591 
 6592 
 6593 //----------MemBar Instructions-----------------------------------------------
 6594 // Memory barrier flavors
 6595 
 6596 instruct membar_acquire()
 6597 %{
 6598   match(MemBarAcquire);
 6599   match(LoadFence);
 6600   ins_cost(0);
 6601 
 6602   size(0);
 6603   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6604   ins_encode();
 6605   ins_pipe(empty);
 6606 %}
 6607 
 6608 instruct membar_acquire_lock()
 6609 %{
 6610   match(MemBarAcquireLock);
 6611   ins_cost(0);
 6612 
 6613   size(0);
 6614   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6615   ins_encode();
 6616   ins_pipe(empty);
 6617 %}
 6618 
 6619 instruct membar_release()
 6620 %{
 6621   match(MemBarRelease);
 6622   match(StoreFence);
 6623   ins_cost(0);
 6624 
 6625   size(0);
 6626   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6627   ins_encode();
 6628   ins_pipe(empty);
 6629 %}
 6630 
 6631 instruct membar_release_lock()
 6632 %{
 6633   match(MemBarReleaseLock);
 6634   ins_cost(0);
 6635 
 6636   size(0);
 6637   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6638   ins_encode();
 6639   ins_pipe(empty);
 6640 %}
 6641 
 6642 instruct membar_volatile(rFlagsReg cr) %{
 6643   match(MemBarVolatile);
 6644   effect(KILL cr);
 6645   ins_cost(400);
 6646 
 6647   format %{
 6648     $$template
 6649     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6650   %}
 6651   ins_encode %{
 6652     __ membar(Assembler::StoreLoad);
 6653   %}
 6654   ins_pipe(pipe_slow);
 6655 %}
 6656 
 6657 instruct unnecessary_membar_volatile()
 6658 %{
 6659   match(MemBarVolatile);
 6660   predicate(Matcher::post_store_load_barrier(n));
 6661   ins_cost(0);
 6662 
 6663   size(0);
 6664   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6665   ins_encode();
 6666   ins_pipe(empty);
 6667 %}
 6668 
 6669 instruct membar_storestore() %{
 6670   match(MemBarStoreStore);
 6671   ins_cost(0);
 6672 
 6673   size(0);
 6674   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6675   ins_encode( );
 6676   ins_pipe(empty);
 6677 %}
 6678 
 6679 //----------Move Instructions--------------------------------------------------
 6680 
 6681 instruct castX2P(rRegP dst, rRegL src)
 6682 %{
 6683   match(Set dst (CastX2P src));
 6684 
 6685   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6686   ins_encode %{
 6687     if ($dst$$reg != $src$$reg) {
 6688       __ movptr($dst$$Register, $src$$Register);
 6689     }
 6690   %}
 6691   ins_pipe(ialu_reg_reg); // XXX
 6692 %}
 6693 
 6694 instruct castP2X(rRegL dst, rRegP src)
 6695 %{
 6696   match(Set dst (CastP2X src));
 6697 
 6698   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6699   ins_encode %{
 6700     if ($dst$$reg != $src$$reg) {
 6701       __ movptr($dst$$Register, $src$$Register);
 6702     }
 6703   %}
 6704   ins_pipe(ialu_reg_reg); // XXX
 6705 %}
 6706 
 6707 // Convert oop into int for vectors alignment masking
 6708 instruct convP2I(rRegI dst, rRegP src)
 6709 %{
 6710   match(Set dst (ConvL2I (CastP2X src)));
 6711 
 6712   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6713   ins_encode %{
 6714     __ movl($dst$$Register, $src$$Register);
 6715   %}
 6716   ins_pipe(ialu_reg_reg); // XXX
 6717 %}
 6718 
 6719 // Convert compressed oop into int for vectors alignment masking
 6720 // in case of 32bit oops (heap &lt; 4Gb).
 6721 instruct convN2I(rRegI dst, rRegN src)
 6722 %{
 6723   predicate(CompressedOops::shift() == 0);
 6724   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6725 
 6726   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6727   ins_encode %{
 6728     __ movl($dst$$Register, $src$$Register);
 6729   %}
 6730   ins_pipe(ialu_reg_reg); // XXX
 6731 %}
 6732 
 6733 // Convert oop pointer into compressed form
 6734 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6735   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6736   match(Set dst (EncodeP src));
 6737   effect(KILL cr);
 6738   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6739   ins_encode %{
 6740     Register s = $src$$Register;
 6741     Register d = $dst$$Register;
 6742     if (s != d) {
 6743       __ movq(d, s);
 6744     }
 6745     __ encode_heap_oop(d);
 6746   %}
 6747   ins_pipe(ialu_reg_long);
 6748 %}
 6749 
 6750 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6751   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6752   match(Set dst (EncodeP src));
 6753   effect(KILL cr);
 6754   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6755   ins_encode %{
 6756     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6757   %}
 6758   ins_pipe(ialu_reg_long);
 6759 %}
 6760 
 6761 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6762   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6763             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6764   match(Set dst (DecodeN src));
 6765   effect(KILL cr);
 6766   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6767   ins_encode %{
 6768     Register s = $src$$Register;
 6769     Register d = $dst$$Register;
 6770     if (s != d) {
 6771       __ movq(d, s);
 6772     }
 6773     __ decode_heap_oop(d);
 6774   %}
 6775   ins_pipe(ialu_reg_long);
 6776 %}
 6777 
 6778 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6779   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6780             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6781   match(Set dst (DecodeN src));
 6782   effect(KILL cr);
 6783   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6784   ins_encode %{
 6785     Register s = $src$$Register;
 6786     Register d = $dst$$Register;
 6787     if (s != d) {
 6788       __ decode_heap_oop_not_null(d, s);
 6789     } else {
 6790       __ decode_heap_oop_not_null(d);
 6791     }
 6792   %}
 6793   ins_pipe(ialu_reg_long);
 6794 %}
 6795 
 6796 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6797   match(Set dst (EncodePKlass src));
 6798   effect(TEMP dst, KILL cr);
 6799   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}
 6800   ins_encode %{
 6801     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6802   %}
 6803   ins_pipe(ialu_reg_long);
 6804 %}
 6805 
 6806 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6807   match(Set dst (DecodeNKlass src));
 6808   effect(TEMP dst, KILL cr);
 6809   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}
 6810   ins_encode %{
 6811     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6812   %}
 6813   ins_pipe(ialu_reg_long);
 6814 %}
 6815 
 6816 //----------Conditional Move---------------------------------------------------
 6817 // Jump
 6818 // dummy instruction for generating temp registers
 6819 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6820   match(Jump (LShiftL switch_val shift));
 6821   ins_cost(350);
 6822   predicate(false);
 6823   effect(TEMP dest);
 6824 
 6825   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6826             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6827   ins_encode %{
 6828     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6829     // to do that and the compiler is using that register as one it can allocate.
 6830     // So we build it all by hand.
 6831     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6832     // ArrayAddress dispatch(table, index);
 6833     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6834     __ lea($dest$$Register, $constantaddress);
 6835     __ jmp(dispatch);
 6836   %}
 6837   ins_pipe(pipe_jmp);
 6838 %}
 6839 
 6840 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6841   match(Jump (AddL (LShiftL switch_val shift) offset));
 6842   ins_cost(350);
 6843   effect(TEMP dest);
 6844 
 6845   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6846             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6847   ins_encode %{
 6848     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6849     // to do that and the compiler is using that register as one it can allocate.
 6850     // So we build it all by hand.
 6851     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6852     // ArrayAddress dispatch(table, index);
 6853     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6854     __ lea($dest$$Register, $constantaddress);
 6855     __ jmp(dispatch);
 6856   %}
 6857   ins_pipe(pipe_jmp);
 6858 %}
 6859 
 6860 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6861   match(Jump switch_val);
 6862   ins_cost(350);
 6863   effect(TEMP dest);
 6864 
 6865   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6866             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6867   ins_encode %{
 6868     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6869     // to do that and the compiler is using that register as one it can allocate.
 6870     // So we build it all by hand.
 6871     // Address index(noreg, switch_reg, Address::times_1);
 6872     // ArrayAddress dispatch(table, index);
 6873     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6874     __ lea($dest$$Register, $constantaddress);
 6875     __ jmp(dispatch);
 6876   %}
 6877   ins_pipe(pipe_jmp);
 6878 %}
 6879 
 6880 // Conditional move
 6881 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6882 %{
 6883   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6884 
 6885   ins_cost(200); // XXX
 6886   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6887   opcode(0x0F, 0x40);
 6888   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6889   ins_pipe(pipe_cmov_reg);
 6890 %}
 6891 
 6892 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6893   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6894 
 6895   ins_cost(200); // XXX
 6896   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6897   opcode(0x0F, 0x40);
 6898   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6899   ins_pipe(pipe_cmov_reg);
 6900 %}
 6901 
 6902 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6903   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6904   ins_cost(200);
 6905   expand %{
 6906     cmovI_regU(cop, cr, dst, src);
 6907   %}
 6908 %}
 6909 
 6910 // Conditional move
 6911 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6912   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6913 
 6914   ins_cost(250); // XXX
 6915   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6916   opcode(0x0F, 0x40);
 6917   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6918   ins_pipe(pipe_cmov_mem);
 6919 %}
 6920 
 6921 // Conditional move
 6922 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6923 %{
 6924   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6925 
 6926   ins_cost(250); // XXX
 6927   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6928   opcode(0x0F, 0x40);
 6929   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6930   ins_pipe(pipe_cmov_mem);
 6931 %}
 6932 
 6933 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6934   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6935   ins_cost(250);
 6936   expand %{
 6937     cmovI_memU(cop, cr, dst, src);
 6938   %}
 6939 %}
 6940 
 6941 // Conditional move
 6942 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6943 %{
 6944   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6945 
 6946   ins_cost(200); // XXX
 6947   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6948   opcode(0x0F, 0x40);
 6949   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6950   ins_pipe(pipe_cmov_reg);
 6951 %}
 6952 
 6953 // Conditional move
 6954 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6955 %{
 6956   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6957 
 6958   ins_cost(200); // XXX
 6959   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6960   opcode(0x0F, 0x40);
 6961   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6962   ins_pipe(pipe_cmov_reg);
 6963 %}
 6964 
 6965 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 6966   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6967   ins_cost(200);
 6968   expand %{
 6969     cmovN_regU(cop, cr, dst, src);
 6970   %}
 6971 %}
 6972 
 6973 // Conditional move
 6974 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 6975 %{
 6976   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6977 
 6978   ins_cost(200); // XXX
 6979   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 6980   opcode(0x0F, 0x40);
 6981   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6982   ins_pipe(pipe_cmov_reg);  // XXX
 6983 %}
 6984 
 6985 // Conditional move
 6986 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 6987 %{
 6988   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6989 
 6990   ins_cost(200); // XXX
 6991   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 6992   opcode(0x0F, 0x40);
 6993   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6994   ins_pipe(pipe_cmov_reg); // XXX
 6995 %}
 6996 
 6997 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 6998   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6999   ins_cost(200);
 7000   expand %{
 7001     cmovP_regU(cop, cr, dst, src);
 7002   %}
 7003 %}
 7004 
 7005 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7006 // correctly meets the two pointer arguments; one is an incoming
 7007 // register but the other is a memory operand.  ALSO appears to
 7008 // be buggy with implicit null checks.
 7009 //
 7010 //// Conditional move
 7011 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7012 //%{
 7013 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7014 //  ins_cost(250);
 7015 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7016 //  opcode(0x0F,0x40);
 7017 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7018 //  ins_pipe( pipe_cmov_mem );
 7019 //%}
 7020 //
 7021 //// Conditional move
 7022 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7023 //%{
 7024 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7025 //  ins_cost(250);
 7026 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7027 //  opcode(0x0F,0x40);
 7028 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7029 //  ins_pipe( pipe_cmov_mem );
 7030 //%}
 7031 
 7032 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7033 %{
 7034   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7035 
 7036   ins_cost(200); // XXX
 7037   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7038   opcode(0x0F, 0x40);
 7039   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7040   ins_pipe(pipe_cmov_reg);  // XXX
 7041 %}
 7042 
 7043 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7044 %{
 7045   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7046 
 7047   ins_cost(200); // XXX
 7048   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7049   opcode(0x0F, 0x40);
 7050   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7051   ins_pipe(pipe_cmov_mem);  // XXX
 7052 %}
 7053 
 7054 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7055 %{
 7056   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7057 
 7058   ins_cost(200); // XXX
 7059   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7060   opcode(0x0F, 0x40);
 7061   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7062   ins_pipe(pipe_cmov_reg); // XXX
 7063 %}
 7064 
 7065 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7066   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7067   ins_cost(200);
 7068   expand %{
 7069     cmovL_regU(cop, cr, dst, src);
 7070   %}
 7071 %}
 7072 
 7073 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7074 %{
 7075   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7076 
 7077   ins_cost(200); // XXX
 7078   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7079   opcode(0x0F, 0x40);
 7080   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7081   ins_pipe(pipe_cmov_mem); // XXX
 7082 %}
 7083 
 7084 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7085   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7086   ins_cost(200);
 7087   expand %{
 7088     cmovL_memU(cop, cr, dst, src);
 7089   %}
 7090 %}
 7091 
 7092 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7093 %{
 7094   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7095 
 7096   ins_cost(200); // XXX
 7097   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7098             &quot;movss     $dst, $src\n&quot;
 7099     &quot;skip:&quot; %}
 7100   ins_encode %{
 7101     Label Lskip;
 7102     // Invert sense of branch from sense of CMOV
 7103     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7104     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7105     __ bind(Lskip);
 7106   %}
 7107   ins_pipe(pipe_slow);
 7108 %}
 7109 
 7110 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7111 // %{
 7112 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7113 
 7114 //   ins_cost(200); // XXX
 7115 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7116 //             &quot;movss     $dst, $src\n&quot;
 7117 //     &quot;skip:&quot; %}
 7118 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7119 //   ins_pipe(pipe_slow);
 7120 // %}
 7121 
 7122 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7123 %{
 7124   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7125 
 7126   ins_cost(200); // XXX
 7127   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7128             &quot;movss     $dst, $src\n&quot;
 7129     &quot;skip:&quot; %}
 7130   ins_encode %{
 7131     Label Lskip;
 7132     // Invert sense of branch from sense of CMOV
 7133     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7134     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7135     __ bind(Lskip);
 7136   %}
 7137   ins_pipe(pipe_slow);
 7138 %}
 7139 
 7140 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7141   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7142   ins_cost(200);
 7143   expand %{
 7144     cmovF_regU(cop, cr, dst, src);
 7145   %}
 7146 %}
 7147 
 7148 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7149 %{
 7150   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7151 
 7152   ins_cost(200); // XXX
 7153   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7154             &quot;movsd     $dst, $src\n&quot;
 7155     &quot;skip:&quot; %}
 7156   ins_encode %{
 7157     Label Lskip;
 7158     // Invert sense of branch from sense of CMOV
 7159     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7160     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7161     __ bind(Lskip);
 7162   %}
 7163   ins_pipe(pipe_slow);
 7164 %}
 7165 
 7166 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7167 %{
 7168   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7169 
 7170   ins_cost(200); // XXX
 7171   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7172             &quot;movsd     $dst, $src\n&quot;
 7173     &quot;skip:&quot; %}
 7174   ins_encode %{
 7175     Label Lskip;
 7176     // Invert sense of branch from sense of CMOV
 7177     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7178     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7179     __ bind(Lskip);
 7180   %}
 7181   ins_pipe(pipe_slow);
 7182 %}
 7183 
 7184 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7185   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7186   ins_cost(200);
 7187   expand %{
 7188     cmovD_regU(cop, cr, dst, src);
 7189   %}
 7190 %}
 7191 
 7192 //----------Arithmetic Instructions--------------------------------------------
 7193 //----------Addition Instructions----------------------------------------------
 7194 
 7195 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7196 %{
 7197   match(Set dst (AddI dst src));
 7198   effect(KILL cr);
 7199 
 7200   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7201   opcode(0x03);
 7202   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7203   ins_pipe(ialu_reg_reg);
 7204 %}
 7205 
 7206 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7207 %{
 7208   match(Set dst (AddI dst src));
 7209   effect(KILL cr);
 7210 
 7211   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7212   opcode(0x81, 0x00); /* /0 id */
 7213   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7214   ins_pipe( ialu_reg );
 7215 %}
 7216 
 7217 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7218 %{
 7219   match(Set dst (AddI dst (LoadI src)));
 7220   effect(KILL cr);
 7221 
 7222   ins_cost(125); // XXX
 7223   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7224   opcode(0x03);
 7225   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7226   ins_pipe(ialu_reg_mem);
 7227 %}
 7228 
 7229 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7230 %{
 7231   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7232   effect(KILL cr);
 7233 
 7234   ins_cost(150); // XXX
 7235   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7236   opcode(0x01); /* Opcode 01 /r */
 7237   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7238   ins_pipe(ialu_mem_reg);
 7239 %}
 7240 
 7241 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7242 %{
 7243   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7244   effect(KILL cr);
 7245 
 7246   ins_cost(125); // XXX
 7247   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7248   opcode(0x81); /* Opcode 81 /0 id */
 7249   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7250   ins_pipe(ialu_mem_imm);
 7251 %}
 7252 
 7253 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7254 %{
 7255   predicate(UseIncDec);
 7256   match(Set dst (AddI dst src));
 7257   effect(KILL cr);
 7258 
 7259   format %{ &quot;incl    $dst\t# int&quot; %}
 7260   opcode(0xFF, 0x00); // FF /0
 7261   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7262   ins_pipe(ialu_reg);
 7263 %}
 7264 
 7265 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7266 %{
 7267   predicate(UseIncDec);
 7268   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7269   effect(KILL cr);
 7270 
 7271   ins_cost(125); // XXX
 7272   format %{ &quot;incl    $dst\t# int&quot; %}
 7273   opcode(0xFF); /* Opcode FF /0 */
 7274   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7275   ins_pipe(ialu_mem_imm);
 7276 %}
 7277 
 7278 // XXX why does that use AddI
 7279 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7280 %{
 7281   predicate(UseIncDec);
 7282   match(Set dst (AddI dst src));
 7283   effect(KILL cr);
 7284 
 7285   format %{ &quot;decl    $dst\t# int&quot; %}
 7286   opcode(0xFF, 0x01); // FF /1
 7287   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7288   ins_pipe(ialu_reg);
 7289 %}
 7290 
 7291 // XXX why does that use AddI
 7292 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7293 %{
 7294   predicate(UseIncDec);
 7295   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7296   effect(KILL cr);
 7297 
 7298   ins_cost(125); // XXX
 7299   format %{ &quot;decl    $dst\t# int&quot; %}
 7300   opcode(0xFF); /* Opcode FF /1 */
 7301   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7302   ins_pipe(ialu_mem_imm);
 7303 %}
 7304 
 7305 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7306 %{
 7307   match(Set dst (AddI src0 src1));
 7308 
 7309   ins_cost(110);
 7310   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7311   opcode(0x8D); /* 0x8D /r */
 7312   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7313   ins_pipe(ialu_reg_reg);
 7314 %}
 7315 
 7316 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7317 %{
 7318   match(Set dst (AddL dst src));
 7319   effect(KILL cr);
 7320 
 7321   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7322   opcode(0x03);
 7323   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7324   ins_pipe(ialu_reg_reg);
 7325 %}
 7326 
 7327 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7328 %{
 7329   match(Set dst (AddL dst src));
 7330   effect(KILL cr);
 7331 
 7332   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7333   opcode(0x81, 0x00); /* /0 id */
 7334   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7335   ins_pipe( ialu_reg );
 7336 %}
 7337 
 7338 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7339 %{
 7340   match(Set dst (AddL dst (LoadL src)));
 7341   effect(KILL cr);
 7342 
 7343   ins_cost(125); // XXX
 7344   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7345   opcode(0x03);
 7346   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7347   ins_pipe(ialu_reg_mem);
 7348 %}
 7349 
 7350 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7351 %{
 7352   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7353   effect(KILL cr);
 7354 
 7355   ins_cost(150); // XXX
 7356   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7357   opcode(0x01); /* Opcode 01 /r */
 7358   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7359   ins_pipe(ialu_mem_reg);
 7360 %}
 7361 
 7362 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7363 %{
 7364   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7365   effect(KILL cr);
 7366 
 7367   ins_cost(125); // XXX
 7368   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7369   opcode(0x81); /* Opcode 81 /0 id */
 7370   ins_encode(REX_mem_wide(dst),
 7371              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7372   ins_pipe(ialu_mem_imm);
 7373 %}
 7374 
 7375 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7376 %{
 7377   predicate(UseIncDec);
 7378   match(Set dst (AddL dst src));
 7379   effect(KILL cr);
 7380 
 7381   format %{ &quot;incq    $dst\t# long&quot; %}
 7382   opcode(0xFF, 0x00); // FF /0
 7383   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7384   ins_pipe(ialu_reg);
 7385 %}
 7386 
 7387 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7388 %{
 7389   predicate(UseIncDec);
 7390   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7391   effect(KILL cr);
 7392 
 7393   ins_cost(125); // XXX
 7394   format %{ &quot;incq    $dst\t# long&quot; %}
 7395   opcode(0xFF); /* Opcode FF /0 */
 7396   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7397   ins_pipe(ialu_mem_imm);
 7398 %}
 7399 
 7400 // XXX why does that use AddL
 7401 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7402 %{
 7403   predicate(UseIncDec);
 7404   match(Set dst (AddL dst src));
 7405   effect(KILL cr);
 7406 
 7407   format %{ &quot;decq    $dst\t# long&quot; %}
 7408   opcode(0xFF, 0x01); // FF /1
 7409   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7410   ins_pipe(ialu_reg);
 7411 %}
 7412 
 7413 // XXX why does that use AddL
 7414 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7415 %{
 7416   predicate(UseIncDec);
 7417   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7418   effect(KILL cr);
 7419 
 7420   ins_cost(125); // XXX
 7421   format %{ &quot;decq    $dst\t# long&quot; %}
 7422   opcode(0xFF); /* Opcode FF /1 */
 7423   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7424   ins_pipe(ialu_mem_imm);
 7425 %}
 7426 
 7427 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7428 %{
 7429   match(Set dst (AddL src0 src1));
 7430 
 7431   ins_cost(110);
 7432   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7433   opcode(0x8D); /* 0x8D /r */
 7434   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7435   ins_pipe(ialu_reg_reg);
 7436 %}
 7437 
 7438 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7439 %{
 7440   match(Set dst (AddP dst src));
 7441   effect(KILL cr);
 7442 
 7443   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7444   opcode(0x03);
 7445   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7446   ins_pipe(ialu_reg_reg);
 7447 %}
 7448 
 7449 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7450 %{
 7451   match(Set dst (AddP dst src));
 7452   effect(KILL cr);
 7453 
 7454   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7455   opcode(0x81, 0x00); /* /0 id */
 7456   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7457   ins_pipe( ialu_reg );
 7458 %}
 7459 
 7460 // XXX addP mem ops ????
 7461 
 7462 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7463 %{
 7464   match(Set dst (AddP src0 src1));
 7465 
 7466   ins_cost(110);
 7467   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7468   opcode(0x8D); /* 0x8D /r */
 7469   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7470   ins_pipe(ialu_reg_reg);
 7471 %}
 7472 
 7473 instruct checkCastPP(rRegP dst)
 7474 %{
 7475   match(Set dst (CheckCastPP dst));
 7476 
 7477   size(0);
 7478   format %{ &quot;# checkcastPP of $dst&quot; %}
 7479   ins_encode(/* empty encoding */);
 7480   ins_pipe(empty);
 7481 %}
 7482 
 7483 instruct castPP(rRegP dst)
 7484 %{
 7485   match(Set dst (CastPP dst));
 7486 
 7487   size(0);
 7488   format %{ &quot;# castPP of $dst&quot; %}
 7489   ins_encode(/* empty encoding */);
 7490   ins_pipe(empty);
 7491 %}
 7492 
 7493 instruct castII(rRegI dst)
 7494 %{
 7495   match(Set dst (CastII dst));
 7496 
 7497   size(0);
 7498   format %{ &quot;# castII of $dst&quot; %}
 7499   ins_encode(/* empty encoding */);
 7500   ins_cost(0);
 7501   ins_pipe(empty);
 7502 %}
 7503 
 7504 // LoadP-locked same as a regular LoadP when used with compare-swap
 7505 instruct loadPLocked(rRegP dst, memory mem)
 7506 %{
 7507   match(Set dst (LoadPLocked mem));
 7508 
 7509   ins_cost(125); // XXX
 7510   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7511   opcode(0x8B);
 7512   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7513   ins_pipe(ialu_reg_mem); // XXX
 7514 %}
 7515 
 7516 // Conditional-store of the updated heap-top.
 7517 // Used during allocation of the shared heap.
 7518 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7519 
 7520 instruct storePConditional(memory heap_top_ptr,
 7521                            rax_RegP oldval, rRegP newval,
 7522                            rFlagsReg cr)
 7523 %{
 7524   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7525   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7526 
 7527   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7528             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7529   opcode(0x0F, 0xB1);
 7530   ins_encode(lock_prefix,
 7531              REX_reg_mem_wide(newval, heap_top_ptr),
 7532              OpcP, OpcS,
 7533              reg_mem(newval, heap_top_ptr));
 7534   ins_pipe(pipe_cmpxchg);
 7535 %}
 7536 
 7537 // Conditional-store of an int value.
 7538 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7539 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7540 %{
 7541   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7542   effect(KILL oldval);
 7543 
 7544   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7545   opcode(0x0F, 0xB1);
 7546   ins_encode(lock_prefix,
 7547              REX_reg_mem(newval, mem),
 7548              OpcP, OpcS,
 7549              reg_mem(newval, mem));
 7550   ins_pipe(pipe_cmpxchg);
 7551 %}
 7552 
 7553 // Conditional-store of a long value.
 7554 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7555 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7556 %{
 7557   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7558   effect(KILL oldval);
 7559 
 7560   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7561   opcode(0x0F, 0xB1);
 7562   ins_encode(lock_prefix,
 7563              REX_reg_mem_wide(newval, mem),
 7564              OpcP, OpcS,
 7565              reg_mem(newval, mem));
 7566   ins_pipe(pipe_cmpxchg);
 7567 %}
 7568 
 7569 
 7570 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7571 instruct compareAndSwapP(rRegI res,
 7572                          memory mem_ptr,
 7573                          rax_RegP oldval, rRegP newval,
 7574                          rFlagsReg cr)
 7575 %{
 7576   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7577   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7578   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7579   effect(KILL cr, KILL oldval);
 7580 
 7581   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7582             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7583             &quot;sete    $res\n\t&quot;
 7584             &quot;movzbl  $res, $res&quot; %}
 7585   opcode(0x0F, 0xB1);
 7586   ins_encode(lock_prefix,
 7587              REX_reg_mem_wide(newval, mem_ptr),
 7588              OpcP, OpcS,
 7589              reg_mem(newval, mem_ptr),
 7590              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7591              REX_reg_breg(res, res), // movzbl
 7592              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7593   ins_pipe( pipe_cmpxchg );
 7594 %}
 7595 
 7596 instruct compareAndSwapL(rRegI res,
 7597                          memory mem_ptr,
 7598                          rax_RegL oldval, rRegL newval,
 7599                          rFlagsReg cr)
 7600 %{
 7601   predicate(VM_Version::supports_cx8());
 7602   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7603   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7604   effect(KILL cr, KILL oldval);
 7605 
 7606   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7607             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7608             &quot;sete    $res\n\t&quot;
 7609             &quot;movzbl  $res, $res&quot; %}
 7610   opcode(0x0F, 0xB1);
 7611   ins_encode(lock_prefix,
 7612              REX_reg_mem_wide(newval, mem_ptr),
 7613              OpcP, OpcS,
 7614              reg_mem(newval, mem_ptr),
 7615              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7616              REX_reg_breg(res, res), // movzbl
 7617              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7618   ins_pipe( pipe_cmpxchg );
 7619 %}
 7620 
 7621 instruct compareAndSwapI(rRegI res,
 7622                          memory mem_ptr,
 7623                          rax_RegI oldval, rRegI newval,
 7624                          rFlagsReg cr)
 7625 %{
 7626   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7627   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7628   effect(KILL cr, KILL oldval);
 7629 
 7630   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7631             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7632             &quot;sete    $res\n\t&quot;
 7633             &quot;movzbl  $res, $res&quot; %}
 7634   opcode(0x0F, 0xB1);
 7635   ins_encode(lock_prefix,
 7636              REX_reg_mem(newval, mem_ptr),
 7637              OpcP, OpcS,
 7638              reg_mem(newval, mem_ptr),
 7639              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7640              REX_reg_breg(res, res), // movzbl
 7641              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7642   ins_pipe( pipe_cmpxchg );
 7643 %}
 7644 
 7645 instruct compareAndSwapB(rRegI res,
 7646                          memory mem_ptr,
 7647                          rax_RegI oldval, rRegI newval,
 7648                          rFlagsReg cr)
 7649 %{
 7650   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7651   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7652   effect(KILL cr, KILL oldval);
 7653 
 7654   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7655             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7656             &quot;sete    $res\n\t&quot;
 7657             &quot;movzbl  $res, $res&quot; %}
 7658   opcode(0x0F, 0xB0);
 7659   ins_encode(lock_prefix,
 7660              REX_breg_mem(newval, mem_ptr),
 7661              OpcP, OpcS,
 7662              reg_mem(newval, mem_ptr),
 7663              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7664              REX_reg_breg(res, res), // movzbl
 7665              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7666   ins_pipe( pipe_cmpxchg );
 7667 %}
 7668 
 7669 instruct compareAndSwapS(rRegI res,
 7670                          memory mem_ptr,
 7671                          rax_RegI oldval, rRegI newval,
 7672                          rFlagsReg cr)
 7673 %{
 7674   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7675   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7676   effect(KILL cr, KILL oldval);
 7677 
 7678   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7679             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7680             &quot;sete    $res\n\t&quot;
 7681             &quot;movzbl  $res, $res&quot; %}
 7682   opcode(0x0F, 0xB1);
 7683   ins_encode(lock_prefix,
 7684              SizePrefix,
 7685              REX_reg_mem(newval, mem_ptr),
 7686              OpcP, OpcS,
 7687              reg_mem(newval, mem_ptr),
 7688              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7689              REX_reg_breg(res, res), // movzbl
 7690              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7691   ins_pipe( pipe_cmpxchg );
 7692 %}
 7693 
 7694 instruct compareAndSwapN(rRegI res,
 7695                           memory mem_ptr,
 7696                           rax_RegN oldval, rRegN newval,
 7697                           rFlagsReg cr) %{
 7698   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7699   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7700   effect(KILL cr, KILL oldval);
 7701 
 7702   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7703             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7704             &quot;sete    $res\n\t&quot;
 7705             &quot;movzbl  $res, $res&quot; %}
 7706   opcode(0x0F, 0xB1);
 7707   ins_encode(lock_prefix,
 7708              REX_reg_mem(newval, mem_ptr),
 7709              OpcP, OpcS,
 7710              reg_mem(newval, mem_ptr),
 7711              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7712              REX_reg_breg(res, res), // movzbl
 7713              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7714   ins_pipe( pipe_cmpxchg );
 7715 %}
 7716 
 7717 instruct compareAndExchangeB(
 7718                          memory mem_ptr,
 7719                          rax_RegI oldval, rRegI newval,
 7720                          rFlagsReg cr)
 7721 %{
 7722   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7723   effect(KILL cr);
 7724 
 7725   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7726             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7727   opcode(0x0F, 0xB0);
 7728   ins_encode(lock_prefix,
 7729              REX_breg_mem(newval, mem_ptr),
 7730              OpcP, OpcS,
 7731              reg_mem(newval, mem_ptr) // lock cmpxchg
 7732              );
 7733   ins_pipe( pipe_cmpxchg );
 7734 %}
 7735 
 7736 instruct compareAndExchangeS(
 7737                          memory mem_ptr,
 7738                          rax_RegI oldval, rRegI newval,
 7739                          rFlagsReg cr)
 7740 %{
 7741   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7742   effect(KILL cr);
 7743 
 7744   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7745             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7746   opcode(0x0F, 0xB1);
 7747   ins_encode(lock_prefix,
 7748              SizePrefix,
 7749              REX_reg_mem(newval, mem_ptr),
 7750              OpcP, OpcS,
 7751              reg_mem(newval, mem_ptr) // lock cmpxchg
 7752              );
 7753   ins_pipe( pipe_cmpxchg );
 7754 %}
 7755 
 7756 instruct compareAndExchangeI(
 7757                          memory mem_ptr,
 7758                          rax_RegI oldval, rRegI newval,
 7759                          rFlagsReg cr)
 7760 %{
 7761   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7762   effect(KILL cr);
 7763 
 7764   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7765             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7766   opcode(0x0F, 0xB1);
 7767   ins_encode(lock_prefix,
 7768              REX_reg_mem(newval, mem_ptr),
 7769              OpcP, OpcS,
 7770              reg_mem(newval, mem_ptr) // lock cmpxchg
 7771              );
 7772   ins_pipe( pipe_cmpxchg );
 7773 %}
 7774 
 7775 instruct compareAndExchangeL(
 7776                          memory mem_ptr,
 7777                          rax_RegL oldval, rRegL newval,
 7778                          rFlagsReg cr)
 7779 %{
 7780   predicate(VM_Version::supports_cx8());
 7781   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7782   effect(KILL cr);
 7783 
 7784   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7785             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7786   opcode(0x0F, 0xB1);
 7787   ins_encode(lock_prefix,
 7788              REX_reg_mem_wide(newval, mem_ptr),
 7789              OpcP, OpcS,
 7790              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7791             );
 7792   ins_pipe( pipe_cmpxchg );
 7793 %}
 7794 
 7795 instruct compareAndExchangeN(
 7796                           memory mem_ptr,
 7797                           rax_RegN oldval, rRegN newval,
 7798                           rFlagsReg cr) %{
 7799   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7800   effect(KILL cr);
 7801 
 7802   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7803             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7804   opcode(0x0F, 0xB1);
 7805   ins_encode(lock_prefix,
 7806              REX_reg_mem(newval, mem_ptr),
 7807              OpcP, OpcS,
 7808              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7809           );
 7810   ins_pipe( pipe_cmpxchg );
 7811 %}
 7812 
 7813 instruct compareAndExchangeP(
 7814                          memory mem_ptr,
 7815                          rax_RegP oldval, rRegP newval,
 7816                          rFlagsReg cr)
 7817 %{
 7818   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7819   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7820   effect(KILL cr);
 7821 
 7822   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7823             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7824   opcode(0x0F, 0xB1);
 7825   ins_encode(lock_prefix,
 7826              REX_reg_mem_wide(newval, mem_ptr),
 7827              OpcP, OpcS,
 7828              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7829           );
 7830   ins_pipe( pipe_cmpxchg );
 7831 %}
 7832 
 7833 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7834   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7835   match(Set dummy (GetAndAddB mem add));
 7836   effect(KILL cr);
 7837   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7838   ins_encode %{
 7839     __ lock();
 7840     __ addb($mem$$Address, $add$$constant);
 7841   %}
 7842   ins_pipe( pipe_cmpxchg );
 7843 %}
 7844 
 7845 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7846   match(Set newval (GetAndAddB mem newval));
 7847   effect(KILL cr);
 7848   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7849   ins_encode %{
 7850     __ lock();
 7851     __ xaddb($mem$$Address, $newval$$Register);
 7852   %}
 7853   ins_pipe( pipe_cmpxchg );
 7854 %}
 7855 
 7856 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7857   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7858   match(Set dummy (GetAndAddS mem add));
 7859   effect(KILL cr);
 7860   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7861   ins_encode %{
 7862     __ lock();
 7863     __ addw($mem$$Address, $add$$constant);
 7864   %}
 7865   ins_pipe( pipe_cmpxchg );
 7866 %}
 7867 
 7868 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7869   match(Set newval (GetAndAddS mem newval));
 7870   effect(KILL cr);
 7871   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7872   ins_encode %{
 7873     __ lock();
 7874     __ xaddw($mem$$Address, $newval$$Register);
 7875   %}
 7876   ins_pipe( pipe_cmpxchg );
 7877 %}
 7878 
 7879 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7880   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7881   match(Set dummy (GetAndAddI mem add));
 7882   effect(KILL cr);
 7883   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7884   ins_encode %{
 7885     __ lock();
 7886     __ addl($mem$$Address, $add$$constant);
 7887   %}
 7888   ins_pipe( pipe_cmpxchg );
 7889 %}
 7890 
 7891 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7892   match(Set newval (GetAndAddI mem newval));
 7893   effect(KILL cr);
 7894   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7895   ins_encode %{
 7896     __ lock();
 7897     __ xaddl($mem$$Address, $newval$$Register);
 7898   %}
 7899   ins_pipe( pipe_cmpxchg );
 7900 %}
 7901 
 7902 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7903   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7904   match(Set dummy (GetAndAddL mem add));
 7905   effect(KILL cr);
 7906   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7907   ins_encode %{
 7908     __ lock();
 7909     __ addq($mem$$Address, $add$$constant);
 7910   %}
 7911   ins_pipe( pipe_cmpxchg );
 7912 %}
 7913 
 7914 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7915   match(Set newval (GetAndAddL mem newval));
 7916   effect(KILL cr);
 7917   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7918   ins_encode %{
 7919     __ lock();
 7920     __ xaddq($mem$$Address, $newval$$Register);
 7921   %}
 7922   ins_pipe( pipe_cmpxchg );
 7923 %}
 7924 
 7925 instruct xchgB( memory mem, rRegI newval) %{
 7926   match(Set newval (GetAndSetB mem newval));
 7927   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7928   ins_encode %{
 7929     __ xchgb($newval$$Register, $mem$$Address);
 7930   %}
 7931   ins_pipe( pipe_cmpxchg );
 7932 %}
 7933 
 7934 instruct xchgS( memory mem, rRegI newval) %{
 7935   match(Set newval (GetAndSetS mem newval));
 7936   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7937   ins_encode %{
 7938     __ xchgw($newval$$Register, $mem$$Address);
 7939   %}
 7940   ins_pipe( pipe_cmpxchg );
 7941 %}
 7942 
 7943 instruct xchgI( memory mem, rRegI newval) %{
 7944   match(Set newval (GetAndSetI mem newval));
 7945   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7946   ins_encode %{
 7947     __ xchgl($newval$$Register, $mem$$Address);
 7948   %}
 7949   ins_pipe( pipe_cmpxchg );
 7950 %}
 7951 
 7952 instruct xchgL( memory mem, rRegL newval) %{
 7953   match(Set newval (GetAndSetL mem newval));
 7954   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7955   ins_encode %{
 7956     __ xchgq($newval$$Register, $mem$$Address);
 7957   %}
 7958   ins_pipe( pipe_cmpxchg );
 7959 %}
 7960 
 7961 instruct xchgP( memory mem, rRegP newval) %{
 7962   match(Set newval (GetAndSetP mem newval));
 7963   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7964   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 7965   ins_encode %{
 7966     __ xchgq($newval$$Register, $mem$$Address);
 7967   %}
 7968   ins_pipe( pipe_cmpxchg );
 7969 %}
 7970 
 7971 instruct xchgN( memory mem, rRegN newval) %{
 7972   match(Set newval (GetAndSetN mem newval));
 7973   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 7974   ins_encode %{
 7975     __ xchgl($newval$$Register, $mem$$Address);
 7976   %}
 7977   ins_pipe( pipe_cmpxchg );
 7978 %}
 7979 
 7980 //----------Abs Instructions-------------------------------------------
 7981 
 7982 // Integer Absolute Instructions
 7983 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 7984 %{
 7985   match(Set dst (AbsI src));
 7986   effect(TEMP dst, TEMP tmp, KILL cr);
 7987   format %{ &quot;movl $tmp, $src\n\t&quot;
 7988             &quot;sarl $tmp, 31\n\t&quot;
 7989             &quot;movl $dst, $src\n\t&quot;
 7990             &quot;xorl $dst, $tmp\n\t&quot;
 7991             &quot;subl $dst, $tmp\n&quot;
 7992           %}
 7993   ins_encode %{
 7994     __ movl($tmp$$Register, $src$$Register);
 7995     __ sarl($tmp$$Register, 31);
 7996     __ movl($dst$$Register, $src$$Register);
 7997     __ xorl($dst$$Register, $tmp$$Register);
 7998     __ subl($dst$$Register, $tmp$$Register);
 7999   %}
 8000 
 8001   ins_pipe(ialu_reg_reg);
 8002 %}
 8003 
 8004 // Long Absolute Instructions
 8005 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8006 %{
 8007   match(Set dst (AbsL src));
 8008   effect(TEMP dst, TEMP tmp, KILL cr);
 8009   format %{ &quot;movq $tmp, $src\n\t&quot;
 8010             &quot;sarq $tmp, 63\n\t&quot;
 8011             &quot;movq $dst, $src\n\t&quot;
 8012             &quot;xorq $dst, $tmp\n\t&quot;
 8013             &quot;subq $dst, $tmp\n&quot;
 8014           %}
 8015   ins_encode %{
 8016     __ movq($tmp$$Register, $src$$Register);
 8017     __ sarq($tmp$$Register, 63);
 8018     __ movq($dst$$Register, $src$$Register);
 8019     __ xorq($dst$$Register, $tmp$$Register);
 8020     __ subq($dst$$Register, $tmp$$Register);
 8021   %}
 8022 
 8023   ins_pipe(ialu_reg_reg);
 8024 %}
 8025 
 8026 //----------Subtraction Instructions-------------------------------------------
 8027 
 8028 // Integer Subtraction Instructions
 8029 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8030 %{
 8031   match(Set dst (SubI dst src));
 8032   effect(KILL cr);
 8033 
 8034   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8035   opcode(0x2B);
 8036   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8037   ins_pipe(ialu_reg_reg);
 8038 %}
 8039 
 8040 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8041 %{
 8042   match(Set dst (SubI dst src));
 8043   effect(KILL cr);
 8044 
 8045   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8046   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8047   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8048   ins_pipe(ialu_reg);
 8049 %}
 8050 
 8051 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8052 %{
 8053   match(Set dst (SubI dst (LoadI src)));
 8054   effect(KILL cr);
 8055 
 8056   ins_cost(125);
 8057   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8058   opcode(0x2B);
 8059   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8060   ins_pipe(ialu_reg_mem);
 8061 %}
 8062 
 8063 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8064 %{
 8065   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8066   effect(KILL cr);
 8067 
 8068   ins_cost(150);
 8069   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8070   opcode(0x29); /* Opcode 29 /r */
 8071   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8072   ins_pipe(ialu_mem_reg);
 8073 %}
 8074 
 8075 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8076 %{
 8077   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8078   effect(KILL cr);
 8079 
 8080   ins_cost(125); // XXX
 8081   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8082   opcode(0x81); /* Opcode 81 /5 id */
 8083   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8084   ins_pipe(ialu_mem_imm);
 8085 %}
 8086 
 8087 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8088 %{
 8089   match(Set dst (SubL dst src));
 8090   effect(KILL cr);
 8091 
 8092   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8093   opcode(0x2B);
 8094   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8095   ins_pipe(ialu_reg_reg);
 8096 %}
 8097 
 8098 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8099 %{
 8100   match(Set dst (SubL dst src));
 8101   effect(KILL cr);
 8102 
 8103   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8104   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8105   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8106   ins_pipe(ialu_reg);
 8107 %}
 8108 
 8109 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8110 %{
 8111   match(Set dst (SubL dst (LoadL src)));
 8112   effect(KILL cr);
 8113 
 8114   ins_cost(125);
 8115   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8116   opcode(0x2B);
 8117   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8118   ins_pipe(ialu_reg_mem);
 8119 %}
 8120 
 8121 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8122 %{
 8123   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8124   effect(KILL cr);
 8125 
 8126   ins_cost(150);
 8127   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8128   opcode(0x29); /* Opcode 29 /r */
 8129   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8130   ins_pipe(ialu_mem_reg);
 8131 %}
 8132 
 8133 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8134 %{
 8135   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8136   effect(KILL cr);
 8137 
 8138   ins_cost(125); // XXX
 8139   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8140   opcode(0x81); /* Opcode 81 /5 id */
 8141   ins_encode(REX_mem_wide(dst),
 8142              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8143   ins_pipe(ialu_mem_imm);
 8144 %}
 8145 
 8146 // Subtract from a pointer
 8147 // XXX hmpf???
 8148 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8149 %{
 8150   match(Set dst (AddP dst (SubI zero src)));
 8151   effect(KILL cr);
 8152 
 8153   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8154   opcode(0x2B);
 8155   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8156   ins_pipe(ialu_reg_reg);
 8157 %}
 8158 
 8159 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8160 %{
 8161   match(Set dst (SubI zero dst));
 8162   effect(KILL cr);
 8163 
 8164   format %{ &quot;negl    $dst\t# int&quot; %}
 8165   opcode(0xF7, 0x03);  // Opcode F7 /3
 8166   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8167   ins_pipe(ialu_reg);
 8168 %}
 8169 
 8170 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8171 %{
 8172   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8173   effect(KILL cr);
 8174 
 8175   format %{ &quot;negl    $dst\t# int&quot; %}
 8176   opcode(0xF7, 0x03);  // Opcode F7 /3
 8177   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8178   ins_pipe(ialu_reg);
 8179 %}
 8180 
 8181 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8182 %{
 8183   match(Set dst (SubL zero dst));
 8184   effect(KILL cr);
 8185 
 8186   format %{ &quot;negq    $dst\t# long&quot; %}
 8187   opcode(0xF7, 0x03);  // Opcode F7 /3
 8188   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8189   ins_pipe(ialu_reg);
 8190 %}
 8191 
 8192 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8193 %{
 8194   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8195   effect(KILL cr);
 8196 
 8197   format %{ &quot;negq    $dst\t# long&quot; %}
 8198   opcode(0xF7, 0x03);  // Opcode F7 /3
 8199   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8200   ins_pipe(ialu_reg);
 8201 %}
 8202 
 8203 //----------Multiplication/Division Instructions-------------------------------
 8204 // Integer Multiplication Instructions
 8205 // Multiply Register
 8206 
 8207 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8208 %{
 8209   match(Set dst (MulI dst src));
 8210   effect(KILL cr);
 8211 
 8212   ins_cost(300);
 8213   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8214   opcode(0x0F, 0xAF);
 8215   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8216   ins_pipe(ialu_reg_reg_alu0);
 8217 %}
 8218 
 8219 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8220 %{
 8221   match(Set dst (MulI src imm));
 8222   effect(KILL cr);
 8223 
 8224   ins_cost(300);
 8225   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8226   opcode(0x69); /* 69 /r id */
 8227   ins_encode(REX_reg_reg(dst, src),
 8228              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8229   ins_pipe(ialu_reg_reg_alu0);
 8230 %}
 8231 
 8232 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8233 %{
 8234   match(Set dst (MulI dst (LoadI src)));
 8235   effect(KILL cr);
 8236 
 8237   ins_cost(350);
 8238   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8239   opcode(0x0F, 0xAF);
 8240   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8241   ins_pipe(ialu_reg_mem_alu0);
 8242 %}
 8243 
 8244 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8245 %{
 8246   match(Set dst (MulI (LoadI src) imm));
 8247   effect(KILL cr);
 8248 
 8249   ins_cost(300);
 8250   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8251   opcode(0x69); /* 69 /r id */
 8252   ins_encode(REX_reg_mem(dst, src),
 8253              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8254   ins_pipe(ialu_reg_mem_alu0);
 8255 %}
 8256 
 8257 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8258 %{
 8259   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8260   effect(KILL cr, KILL src2);
 8261 
 8262   expand %{ mulI_rReg(dst, src1, cr);
 8263            mulI_rReg(src2, src3, cr);
 8264            addI_rReg(dst, src2, cr); %}
 8265 %}
 8266 
 8267 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8268 %{
 8269   match(Set dst (MulL dst src));
 8270   effect(KILL cr);
 8271 
 8272   ins_cost(300);
 8273   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8274   opcode(0x0F, 0xAF);
 8275   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8276   ins_pipe(ialu_reg_reg_alu0);
 8277 %}
 8278 
 8279 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8280 %{
 8281   match(Set dst (MulL src imm));
 8282   effect(KILL cr);
 8283 
 8284   ins_cost(300);
 8285   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8286   opcode(0x69); /* 69 /r id */
 8287   ins_encode(REX_reg_reg_wide(dst, src),
 8288              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8289   ins_pipe(ialu_reg_reg_alu0);
 8290 %}
 8291 
 8292 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8293 %{
 8294   match(Set dst (MulL dst (LoadL src)));
 8295   effect(KILL cr);
 8296 
 8297   ins_cost(350);
 8298   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8299   opcode(0x0F, 0xAF);
 8300   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8301   ins_pipe(ialu_reg_mem_alu0);
 8302 %}
 8303 
 8304 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8305 %{
 8306   match(Set dst (MulL (LoadL src) imm));
 8307   effect(KILL cr);
 8308 
 8309   ins_cost(300);
 8310   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8311   opcode(0x69); /* 69 /r id */
 8312   ins_encode(REX_reg_mem_wide(dst, src),
 8313              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8314   ins_pipe(ialu_reg_mem_alu0);
 8315 %}
 8316 
 8317 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8318 %{
 8319   match(Set dst (MulHiL src rax));
 8320   effect(USE_KILL rax, KILL cr);
 8321 
 8322   ins_cost(300);
 8323   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8324   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8325   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8326   ins_pipe(ialu_reg_reg_alu0);
 8327 %}
 8328 
 8329 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8330                    rFlagsReg cr)
 8331 %{
 8332   match(Set rax (DivI rax div));
 8333   effect(KILL rdx, KILL cr);
 8334 
 8335   ins_cost(30*100+10*100); // XXX
 8336   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8337             &quot;jne,s   normal\n\t&quot;
 8338             &quot;xorl    rdx, rdx\n\t&quot;
 8339             &quot;cmpl    $div, -1\n\t&quot;
 8340             &quot;je,s    done\n&quot;
 8341     &quot;normal: cdql\n\t&quot;
 8342             &quot;idivl   $div\n&quot;
 8343     &quot;done:&quot;        %}
 8344   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8345   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8346   ins_pipe(ialu_reg_reg_alu0);
 8347 %}
 8348 
 8349 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8350                    rFlagsReg cr)
 8351 %{
 8352   match(Set rax (DivL rax div));
 8353   effect(KILL rdx, KILL cr);
 8354 
 8355   ins_cost(30*100+10*100); // XXX
 8356   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8357             &quot;cmpq    rax, rdx\n\t&quot;
 8358             &quot;jne,s   normal\n\t&quot;
 8359             &quot;xorl    rdx, rdx\n\t&quot;
 8360             &quot;cmpq    $div, -1\n\t&quot;
 8361             &quot;je,s    done\n&quot;
 8362     &quot;normal: cdqq\n\t&quot;
 8363             &quot;idivq   $div\n&quot;
 8364     &quot;done:&quot;        %}
 8365   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8366   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8367   ins_pipe(ialu_reg_reg_alu0);
 8368 %}
 8369 
 8370 // Integer DIVMOD with Register, both quotient and mod results
 8371 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8372                              rFlagsReg cr)
 8373 %{
 8374   match(DivModI rax div);
 8375   effect(KILL cr);
 8376 
 8377   ins_cost(30*100+10*100); // XXX
 8378   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8379             &quot;jne,s   normal\n\t&quot;
 8380             &quot;xorl    rdx, rdx\n\t&quot;
 8381             &quot;cmpl    $div, -1\n\t&quot;
 8382             &quot;je,s    done\n&quot;
 8383     &quot;normal: cdql\n\t&quot;
 8384             &quot;idivl   $div\n&quot;
 8385     &quot;done:&quot;        %}
 8386   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8387   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8388   ins_pipe(pipe_slow);
 8389 %}
 8390 
 8391 // Long DIVMOD with Register, both quotient and mod results
 8392 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8393                              rFlagsReg cr)
 8394 %{
 8395   match(DivModL rax div);
 8396   effect(KILL cr);
 8397 
 8398   ins_cost(30*100+10*100); // XXX
 8399   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8400             &quot;cmpq    rax, rdx\n\t&quot;
 8401             &quot;jne,s   normal\n\t&quot;
 8402             &quot;xorl    rdx, rdx\n\t&quot;
 8403             &quot;cmpq    $div, -1\n\t&quot;
 8404             &quot;je,s    done\n&quot;
 8405     &quot;normal: cdqq\n\t&quot;
 8406             &quot;idivq   $div\n&quot;
 8407     &quot;done:&quot;        %}
 8408   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8409   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8410   ins_pipe(pipe_slow);
 8411 %}
 8412 
 8413 //----------- DivL-By-Constant-Expansions--------------------------------------
 8414 // DivI cases are handled by the compiler
 8415 
 8416 // Magic constant, reciprocal of 10
 8417 instruct loadConL_0x6666666666666667(rRegL dst)
 8418 %{
 8419   effect(DEF dst);
 8420 
 8421   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8422   ins_encode(load_immL(dst, 0x6666666666666667));
 8423   ins_pipe(ialu_reg);
 8424 %}
 8425 
 8426 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8427 %{
 8428   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8429 
 8430   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8431   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8432   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8433   ins_pipe(ialu_reg_reg_alu0);
 8434 %}
 8435 
 8436 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8437 %{
 8438   effect(USE_DEF dst, KILL cr);
 8439 
 8440   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8441   opcode(0xC1, 0x7); /* C1 /7 ib */
 8442   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8443   ins_pipe(ialu_reg);
 8444 %}
 8445 
 8446 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8447 %{
 8448   effect(USE_DEF dst, KILL cr);
 8449 
 8450   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8451   opcode(0xC1, 0x7); /* C1 /7 ib */
 8452   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8453   ins_pipe(ialu_reg);
 8454 %}
 8455 
 8456 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8457 %{
 8458   match(Set dst (DivL src div));
 8459 
 8460   ins_cost((5+8)*100);
 8461   expand %{
 8462     rax_RegL rax;                     // Killed temp
 8463     rFlagsReg cr;                     // Killed
 8464     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8465     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8466     sarL_rReg_63(src, cr);            // sarq  src, 63
 8467     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8468     subL_rReg(dst, src, cr);          // subl  rdx, src
 8469   %}
 8470 %}
 8471 
 8472 //-----------------------------------------------------------------------------
 8473 
 8474 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8475                    rFlagsReg cr)
 8476 %{
 8477   match(Set rdx (ModI rax div));
 8478   effect(KILL rax, KILL cr);
 8479 
 8480   ins_cost(300); // XXX
 8481   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8482             &quot;jne,s   normal\n\t&quot;
 8483             &quot;xorl    rdx, rdx\n\t&quot;
 8484             &quot;cmpl    $div, -1\n\t&quot;
 8485             &quot;je,s    done\n&quot;
 8486     &quot;normal: cdql\n\t&quot;
 8487             &quot;idivl   $div\n&quot;
 8488     &quot;done:&quot;        %}
 8489   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8490   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8491   ins_pipe(ialu_reg_reg_alu0);
 8492 %}
 8493 
 8494 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8495                    rFlagsReg cr)
 8496 %{
 8497   match(Set rdx (ModL rax div));
 8498   effect(KILL rax, KILL cr);
 8499 
 8500   ins_cost(300); // XXX
 8501   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8502             &quot;cmpq    rax, rdx\n\t&quot;
 8503             &quot;jne,s   normal\n\t&quot;
 8504             &quot;xorl    rdx, rdx\n\t&quot;
 8505             &quot;cmpq    $div, -1\n\t&quot;
 8506             &quot;je,s    done\n&quot;
 8507     &quot;normal: cdqq\n\t&quot;
 8508             &quot;idivq   $div\n&quot;
 8509     &quot;done:&quot;        %}
 8510   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8511   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8512   ins_pipe(ialu_reg_reg_alu0);
 8513 %}
 8514 
 8515 // Integer Shift Instructions
 8516 // Shift Left by one
 8517 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8518 %{
 8519   match(Set dst (LShiftI dst shift));
 8520   effect(KILL cr);
 8521 
 8522   format %{ &quot;sall    $dst, $shift&quot; %}
 8523   opcode(0xD1, 0x4); /* D1 /4 */
 8524   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8525   ins_pipe(ialu_reg);
 8526 %}
 8527 
 8528 // Shift Left by one
 8529 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8530 %{
 8531   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8532   effect(KILL cr);
 8533 
 8534   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8535   opcode(0xD1, 0x4); /* D1 /4 */
 8536   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8537   ins_pipe(ialu_mem_imm);
 8538 %}
 8539 
 8540 // Shift Left by 8-bit immediate
 8541 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8542 %{
 8543   match(Set dst (LShiftI dst shift));
 8544   effect(KILL cr);
 8545 
 8546   format %{ &quot;sall    $dst, $shift&quot; %}
 8547   opcode(0xC1, 0x4); /* C1 /4 ib */
 8548   ins_encode(reg_opc_imm(dst, shift));
 8549   ins_pipe(ialu_reg);
 8550 %}
 8551 
 8552 // Shift Left by 8-bit immediate
 8553 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8554 %{
 8555   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8556   effect(KILL cr);
 8557 
 8558   format %{ &quot;sall    $dst, $shift&quot; %}
 8559   opcode(0xC1, 0x4); /* C1 /4 ib */
 8560   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8561   ins_pipe(ialu_mem_imm);
 8562 %}
 8563 
 8564 // Shift Left by variable
 8565 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8566 %{
 8567   match(Set dst (LShiftI dst shift));
 8568   effect(KILL cr);
 8569 
 8570   format %{ &quot;sall    $dst, $shift&quot; %}
 8571   opcode(0xD3, 0x4); /* D3 /4 */
 8572   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8573   ins_pipe(ialu_reg_reg);
 8574 %}
 8575 
 8576 // Shift Left by variable
 8577 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8578 %{
 8579   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8580   effect(KILL cr);
 8581 
 8582   format %{ &quot;sall    $dst, $shift&quot; %}
 8583   opcode(0xD3, 0x4); /* D3 /4 */
 8584   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8585   ins_pipe(ialu_mem_reg);
 8586 %}
 8587 
 8588 // Arithmetic shift right by one
 8589 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8590 %{
 8591   match(Set dst (RShiftI dst shift));
 8592   effect(KILL cr);
 8593 
 8594   format %{ &quot;sarl    $dst, $shift&quot; %}
 8595   opcode(0xD1, 0x7); /* D1 /7 */
 8596   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8597   ins_pipe(ialu_reg);
 8598 %}
 8599 
 8600 // Arithmetic shift right by one
 8601 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8602 %{
 8603   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8604   effect(KILL cr);
 8605 
 8606   format %{ &quot;sarl    $dst, $shift&quot; %}
 8607   opcode(0xD1, 0x7); /* D1 /7 */
 8608   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8609   ins_pipe(ialu_mem_imm);
 8610 %}
 8611 
 8612 // Arithmetic Shift Right by 8-bit immediate
 8613 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8614 %{
 8615   match(Set dst (RShiftI dst shift));
 8616   effect(KILL cr);
 8617 
 8618   format %{ &quot;sarl    $dst, $shift&quot; %}
 8619   opcode(0xC1, 0x7); /* C1 /7 ib */
 8620   ins_encode(reg_opc_imm(dst, shift));
 8621   ins_pipe(ialu_mem_imm);
 8622 %}
 8623 
 8624 // Arithmetic Shift Right by 8-bit immediate
 8625 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8626 %{
 8627   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8628   effect(KILL cr);
 8629 
 8630   format %{ &quot;sarl    $dst, $shift&quot; %}
 8631   opcode(0xC1, 0x7); /* C1 /7 ib */
 8632   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8633   ins_pipe(ialu_mem_imm);
 8634 %}
 8635 
 8636 // Arithmetic Shift Right by variable
 8637 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8638 %{
 8639   match(Set dst (RShiftI dst shift));
 8640   effect(KILL cr);
 8641 
 8642   format %{ &quot;sarl    $dst, $shift&quot; %}
 8643   opcode(0xD3, 0x7); /* D3 /7 */
 8644   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8645   ins_pipe(ialu_reg_reg);
 8646 %}
 8647 
 8648 // Arithmetic Shift Right by variable
 8649 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8650 %{
 8651   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8652   effect(KILL cr);
 8653 
 8654   format %{ &quot;sarl    $dst, $shift&quot; %}
 8655   opcode(0xD3, 0x7); /* D3 /7 */
 8656   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8657   ins_pipe(ialu_mem_reg);
 8658 %}
 8659 
 8660 // Logical shift right by one
 8661 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8662 %{
 8663   match(Set dst (URShiftI dst shift));
 8664   effect(KILL cr);
 8665 
 8666   format %{ &quot;shrl    $dst, $shift&quot; %}
 8667   opcode(0xD1, 0x5); /* D1 /5 */
 8668   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8669   ins_pipe(ialu_reg);
 8670 %}
 8671 
 8672 // Logical shift right by one
 8673 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8674 %{
 8675   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8676   effect(KILL cr);
 8677 
 8678   format %{ &quot;shrl    $dst, $shift&quot; %}
 8679   opcode(0xD1, 0x5); /* D1 /5 */
 8680   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8681   ins_pipe(ialu_mem_imm);
 8682 %}
 8683 
 8684 // Logical Shift Right by 8-bit immediate
 8685 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8686 %{
 8687   match(Set dst (URShiftI dst shift));
 8688   effect(KILL cr);
 8689 
 8690   format %{ &quot;shrl    $dst, $shift&quot; %}
 8691   opcode(0xC1, 0x5); /* C1 /5 ib */
 8692   ins_encode(reg_opc_imm(dst, shift));
 8693   ins_pipe(ialu_reg);
 8694 %}
 8695 
 8696 // Logical Shift Right by 8-bit immediate
 8697 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8698 %{
 8699   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8700   effect(KILL cr);
 8701 
 8702   format %{ &quot;shrl    $dst, $shift&quot; %}
 8703   opcode(0xC1, 0x5); /* C1 /5 ib */
 8704   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8705   ins_pipe(ialu_mem_imm);
 8706 %}
 8707 
 8708 // Logical Shift Right by variable
 8709 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8710 %{
 8711   match(Set dst (URShiftI dst shift));
 8712   effect(KILL cr);
 8713 
 8714   format %{ &quot;shrl    $dst, $shift&quot; %}
 8715   opcode(0xD3, 0x5); /* D3 /5 */
 8716   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8717   ins_pipe(ialu_reg_reg);
 8718 %}
 8719 
 8720 // Logical Shift Right by variable
 8721 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8722 %{
 8723   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8724   effect(KILL cr);
 8725 
 8726   format %{ &quot;shrl    $dst, $shift&quot; %}
 8727   opcode(0xD3, 0x5); /* D3 /5 */
 8728   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8729   ins_pipe(ialu_mem_reg);
 8730 %}
 8731 
 8732 // Long Shift Instructions
 8733 // Shift Left by one
 8734 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8735 %{
 8736   match(Set dst (LShiftL dst shift));
 8737   effect(KILL cr);
 8738 
 8739   format %{ &quot;salq    $dst, $shift&quot; %}
 8740   opcode(0xD1, 0x4); /* D1 /4 */
 8741   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8742   ins_pipe(ialu_reg);
 8743 %}
 8744 
 8745 // Shift Left by one
 8746 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8747 %{
 8748   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8749   effect(KILL cr);
 8750 
 8751   format %{ &quot;salq    $dst, $shift&quot; %}
 8752   opcode(0xD1, 0x4); /* D1 /4 */
 8753   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8754   ins_pipe(ialu_mem_imm);
 8755 %}
 8756 
 8757 // Shift Left by 8-bit immediate
 8758 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8759 %{
 8760   match(Set dst (LShiftL dst shift));
 8761   effect(KILL cr);
 8762 
 8763   format %{ &quot;salq    $dst, $shift&quot; %}
 8764   opcode(0xC1, 0x4); /* C1 /4 ib */
 8765   ins_encode(reg_opc_imm_wide(dst, shift));
 8766   ins_pipe(ialu_reg);
 8767 %}
 8768 
 8769 // Shift Left by 8-bit immediate
 8770 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8771 %{
 8772   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8773   effect(KILL cr);
 8774 
 8775   format %{ &quot;salq    $dst, $shift&quot; %}
 8776   opcode(0xC1, 0x4); /* C1 /4 ib */
 8777   ins_encode(REX_mem_wide(dst), OpcP,
 8778              RM_opc_mem(secondary, dst), Con8or32(shift));
 8779   ins_pipe(ialu_mem_imm);
 8780 %}
 8781 
 8782 // Shift Left by variable
 8783 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8784 %{
 8785   match(Set dst (LShiftL dst shift));
 8786   effect(KILL cr);
 8787 
 8788   format %{ &quot;salq    $dst, $shift&quot; %}
 8789   opcode(0xD3, 0x4); /* D3 /4 */
 8790   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8791   ins_pipe(ialu_reg_reg);
 8792 %}
 8793 
 8794 // Shift Left by variable
 8795 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8796 %{
 8797   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8798   effect(KILL cr);
 8799 
 8800   format %{ &quot;salq    $dst, $shift&quot; %}
 8801   opcode(0xD3, 0x4); /* D3 /4 */
 8802   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8803   ins_pipe(ialu_mem_reg);
 8804 %}
 8805 
 8806 // Arithmetic shift right by one
 8807 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8808 %{
 8809   match(Set dst (RShiftL dst shift));
 8810   effect(KILL cr);
 8811 
 8812   format %{ &quot;sarq    $dst, $shift&quot; %}
 8813   opcode(0xD1, 0x7); /* D1 /7 */
 8814   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8815   ins_pipe(ialu_reg);
 8816 %}
 8817 
 8818 // Arithmetic shift right by one
 8819 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8820 %{
 8821   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8822   effect(KILL cr);
 8823 
 8824   format %{ &quot;sarq    $dst, $shift&quot; %}
 8825   opcode(0xD1, 0x7); /* D1 /7 */
 8826   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8827   ins_pipe(ialu_mem_imm);
 8828 %}
 8829 
 8830 // Arithmetic Shift Right by 8-bit immediate
 8831 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8832 %{
 8833   match(Set dst (RShiftL dst shift));
 8834   effect(KILL cr);
 8835 
 8836   format %{ &quot;sarq    $dst, $shift&quot; %}
 8837   opcode(0xC1, 0x7); /* C1 /7 ib */
 8838   ins_encode(reg_opc_imm_wide(dst, shift));
 8839   ins_pipe(ialu_mem_imm);
 8840 %}
 8841 
 8842 // Arithmetic Shift Right by 8-bit immediate
 8843 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8844 %{
 8845   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8846   effect(KILL cr);
 8847 
 8848   format %{ &quot;sarq    $dst, $shift&quot; %}
 8849   opcode(0xC1, 0x7); /* C1 /7 ib */
 8850   ins_encode(REX_mem_wide(dst), OpcP,
 8851              RM_opc_mem(secondary, dst), Con8or32(shift));
 8852   ins_pipe(ialu_mem_imm);
 8853 %}
 8854 
 8855 // Arithmetic Shift Right by variable
 8856 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8857 %{
 8858   match(Set dst (RShiftL dst shift));
 8859   effect(KILL cr);
 8860 
 8861   format %{ &quot;sarq    $dst, $shift&quot; %}
 8862   opcode(0xD3, 0x7); /* D3 /7 */
 8863   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8864   ins_pipe(ialu_reg_reg);
 8865 %}
 8866 
 8867 // Arithmetic Shift Right by variable
 8868 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8869 %{
 8870   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8871   effect(KILL cr);
 8872 
 8873   format %{ &quot;sarq    $dst, $shift&quot; %}
 8874   opcode(0xD3, 0x7); /* D3 /7 */
 8875   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8876   ins_pipe(ialu_mem_reg);
 8877 %}
 8878 
 8879 // Logical shift right by one
 8880 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8881 %{
 8882   match(Set dst (URShiftL dst shift));
 8883   effect(KILL cr);
 8884 
 8885   format %{ &quot;shrq    $dst, $shift&quot; %}
 8886   opcode(0xD1, 0x5); /* D1 /5 */
 8887   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8888   ins_pipe(ialu_reg);
 8889 %}
 8890 
 8891 // Logical shift right by one
 8892 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8893 %{
 8894   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8895   effect(KILL cr);
 8896 
 8897   format %{ &quot;shrq    $dst, $shift&quot; %}
 8898   opcode(0xD1, 0x5); /* D1 /5 */
 8899   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8900   ins_pipe(ialu_mem_imm);
 8901 %}
 8902 
 8903 // Logical Shift Right by 8-bit immediate
 8904 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8905 %{
 8906   match(Set dst (URShiftL dst shift));
 8907   effect(KILL cr);
 8908 
 8909   format %{ &quot;shrq    $dst, $shift&quot; %}
 8910   opcode(0xC1, 0x5); /* C1 /5 ib */
 8911   ins_encode(reg_opc_imm_wide(dst, shift));
 8912   ins_pipe(ialu_reg);
 8913 %}
 8914 
 8915 
 8916 // Logical Shift Right by 8-bit immediate
 8917 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8918 %{
 8919   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8920   effect(KILL cr);
 8921 
 8922   format %{ &quot;shrq    $dst, $shift&quot; %}
 8923   opcode(0xC1, 0x5); /* C1 /5 ib */
 8924   ins_encode(REX_mem_wide(dst), OpcP,
 8925              RM_opc_mem(secondary, dst), Con8or32(shift));
 8926   ins_pipe(ialu_mem_imm);
 8927 %}
 8928 
 8929 // Logical Shift Right by variable
 8930 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8931 %{
 8932   match(Set dst (URShiftL dst shift));
 8933   effect(KILL cr);
 8934 
 8935   format %{ &quot;shrq    $dst, $shift&quot; %}
 8936   opcode(0xD3, 0x5); /* D3 /5 */
 8937   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8938   ins_pipe(ialu_reg_reg);
 8939 %}
 8940 
 8941 // Logical Shift Right by variable
 8942 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8943 %{
 8944   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8945   effect(KILL cr);
 8946 
 8947   format %{ &quot;shrq    $dst, $shift&quot; %}
 8948   opcode(0xD3, 0x5); /* D3 /5 */
 8949   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8950   ins_pipe(ialu_mem_reg);
 8951 %}
 8952 
 8953 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8954 // This idiom is used by the compiler for the i2b bytecode.
 8955 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 8956 %{
 8957   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8958 
 8959   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 8960   opcode(0x0F, 0xBE);
 8961   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8962   ins_pipe(ialu_reg_reg);
 8963 %}
 8964 
 8965 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8966 // This idiom is used by the compiler the i2s bytecode.
 8967 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 8968 %{
 8969   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8970 
 8971   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 8972   opcode(0x0F, 0xBF);
 8973   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8974   ins_pipe(ialu_reg_reg);
 8975 %}
 8976 
 8977 // ROL/ROR instructions
 8978 
 8979 // ROL expand
 8980 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 8981   effect(KILL cr, USE_DEF dst);
 8982 
 8983   format %{ &quot;roll    $dst&quot; %}
 8984   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 8985   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8986   ins_pipe(ialu_reg);
 8987 %}
 8988 
 8989 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 8990   effect(USE_DEF dst, USE shift, KILL cr);
 8991 
 8992   format %{ &quot;roll    $dst, $shift&quot; %}
 8993   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 8994   ins_encode( reg_opc_imm(dst, shift) );
 8995   ins_pipe(ialu_reg);
 8996 %}
 8997 
 8998 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 8999 %{
 9000   effect(USE_DEF dst, USE shift, KILL cr);
 9001 
 9002   format %{ &quot;roll    $dst, $shift&quot; %}
 9003   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9004   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9005   ins_pipe(ialu_reg_reg);
 9006 %}
 9007 // end of ROL expand
 9008 
 9009 // Rotate Left by one
 9010 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9011 %{
 9012   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9013 
 9014   expand %{
 9015     rolI_rReg_imm1(dst, cr);
 9016   %}
 9017 %}
 9018 
 9019 // Rotate Left by 8-bit immediate
 9020 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9021 %{
 9022   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9023   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9024 
 9025   expand %{
 9026     rolI_rReg_imm8(dst, lshift, cr);
 9027   %}
 9028 %}
 9029 
 9030 // Rotate Left by variable
 9031 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9032 %{
 9033   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9034 
 9035   expand %{
 9036     rolI_rReg_CL(dst, shift, cr);
 9037   %}
 9038 %}
 9039 
 9040 // Rotate Left by variable
 9041 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9042 %{
 9043   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9044 
 9045   expand %{
 9046     rolI_rReg_CL(dst, shift, cr);
 9047   %}
 9048 %}
 9049 
 9050 // ROR expand
 9051 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9052 %{
 9053   effect(USE_DEF dst, KILL cr);
 9054 
 9055   format %{ &quot;rorl    $dst&quot; %}
 9056   opcode(0xD1, 0x1); /* D1 /1 */
 9057   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9058   ins_pipe(ialu_reg);
 9059 %}
 9060 
 9061 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9062 %{
 9063   effect(USE_DEF dst, USE shift, KILL cr);
 9064 
 9065   format %{ &quot;rorl    $dst, $shift&quot; %}
 9066   opcode(0xC1, 0x1); /* C1 /1 ib */
 9067   ins_encode(reg_opc_imm(dst, shift));
 9068   ins_pipe(ialu_reg);
 9069 %}
 9070 
 9071 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9072 %{
 9073   effect(USE_DEF dst, USE shift, KILL cr);
 9074 
 9075   format %{ &quot;rorl    $dst, $shift&quot; %}
 9076   opcode(0xD3, 0x1); /* D3 /1 */
 9077   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9078   ins_pipe(ialu_reg_reg);
 9079 %}
 9080 // end of ROR expand
 9081 
 9082 // Rotate Right by one
 9083 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9084 %{
 9085   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9086 
 9087   expand %{
 9088     rorI_rReg_imm1(dst, cr);
 9089   %}
 9090 %}
 9091 
 9092 // Rotate Right by 8-bit immediate
 9093 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9094 %{
 9095   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9096   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9097 
 9098   expand %{
 9099     rorI_rReg_imm8(dst, rshift, cr);
 9100   %}
 9101 %}
 9102 
 9103 // Rotate Right by variable
 9104 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9105 %{
 9106   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9107 
 9108   expand %{
 9109     rorI_rReg_CL(dst, shift, cr);
 9110   %}
 9111 %}
 9112 
 9113 // Rotate Right by variable
 9114 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9115 %{
 9116   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9117 
 9118   expand %{
 9119     rorI_rReg_CL(dst, shift, cr);
 9120   %}
 9121 %}
 9122 
 9123 // for long rotate
 9124 // ROL expand
 9125 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9126   effect(USE_DEF dst, KILL cr);
 9127 
 9128   format %{ &quot;rolq    $dst&quot; %}
 9129   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9130   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9131   ins_pipe(ialu_reg);
 9132 %}
 9133 
 9134 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9135   effect(USE_DEF dst, USE shift, KILL cr);
 9136 
 9137   format %{ &quot;rolq    $dst, $shift&quot; %}
 9138   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9139   ins_encode( reg_opc_imm_wide(dst, shift) );
 9140   ins_pipe(ialu_reg);
 9141 %}
 9142 
 9143 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9144 %{
 9145   effect(USE_DEF dst, USE shift, KILL cr);
 9146 
 9147   format %{ &quot;rolq    $dst, $shift&quot; %}
 9148   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9149   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9150   ins_pipe(ialu_reg_reg);
 9151 %}
 9152 // end of ROL expand
 9153 
 9154 // Rotate Left by one
 9155 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9156 %{
 9157   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9158 
 9159   expand %{
 9160     rolL_rReg_imm1(dst, cr);
 9161   %}
 9162 %}
 9163 
 9164 // Rotate Left by 8-bit immediate
 9165 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9166 %{
 9167   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9168   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9169 
 9170   expand %{
 9171     rolL_rReg_imm8(dst, lshift, cr);
 9172   %}
 9173 %}
 9174 
 9175 // Rotate Left by variable
 9176 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9177 %{
 9178   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9179 
 9180   expand %{
 9181     rolL_rReg_CL(dst, shift, cr);
 9182   %}
 9183 %}
 9184 
 9185 // Rotate Left by variable
 9186 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9187 %{
 9188   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9189 
 9190   expand %{
 9191     rolL_rReg_CL(dst, shift, cr);
 9192   %}
 9193 %}
 9194 
 9195 // ROR expand
 9196 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9197 %{
 9198   effect(USE_DEF dst, KILL cr);
 9199 
 9200   format %{ &quot;rorq    $dst&quot; %}
 9201   opcode(0xD1, 0x1); /* D1 /1 */
 9202   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9203   ins_pipe(ialu_reg);
 9204 %}
 9205 
 9206 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9207 %{
 9208   effect(USE_DEF dst, USE shift, KILL cr);
 9209 
 9210   format %{ &quot;rorq    $dst, $shift&quot; %}
 9211   opcode(0xC1, 0x1); /* C1 /1 ib */
 9212   ins_encode(reg_opc_imm_wide(dst, shift));
 9213   ins_pipe(ialu_reg);
 9214 %}
 9215 
 9216 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9217 %{
 9218   effect(USE_DEF dst, USE shift, KILL cr);
 9219 
 9220   format %{ &quot;rorq    $dst, $shift&quot; %}
 9221   opcode(0xD3, 0x1); /* D3 /1 */
 9222   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9223   ins_pipe(ialu_reg_reg);
 9224 %}
 9225 // end of ROR expand
 9226 
 9227 // Rotate Right by one
 9228 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9229 %{
 9230   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9231 
 9232   expand %{
 9233     rorL_rReg_imm1(dst, cr);
 9234   %}
 9235 %}
 9236 
 9237 // Rotate Right by 8-bit immediate
 9238 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9239 %{
 9240   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9241   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9242 
 9243   expand %{
 9244     rorL_rReg_imm8(dst, rshift, cr);
 9245   %}
 9246 %}
 9247 
 9248 // Rotate Right by variable
 9249 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9250 %{
 9251   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9252 
 9253   expand %{
 9254     rorL_rReg_CL(dst, shift, cr);
 9255   %}
 9256 %}
 9257 
 9258 // Rotate Right by variable
 9259 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9260 %{
 9261   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9262 
 9263   expand %{
 9264     rorL_rReg_CL(dst, shift, cr);
 9265   %}
 9266 %}
 9267 
 9268 // Logical Instructions
 9269 
 9270 // Integer Logical Instructions
 9271 
 9272 // And Instructions
 9273 // And Register with Register
 9274 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9275 %{
 9276   match(Set dst (AndI dst src));
 9277   effect(KILL cr);
 9278 
 9279   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9280   opcode(0x23);
 9281   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9282   ins_pipe(ialu_reg_reg);
 9283 %}
 9284 
 9285 // And Register with Immediate 255
 9286 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9287 %{
 9288   match(Set dst (AndI dst src));
 9289 
 9290   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9291   opcode(0x0F, 0xB6);
 9292   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9293   ins_pipe(ialu_reg);
 9294 %}
 9295 
 9296 // And Register with Immediate 255 and promote to long
 9297 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9298 %{
 9299   match(Set dst (ConvI2L (AndI src mask)));
 9300 
 9301   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9302   opcode(0x0F, 0xB6);
 9303   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9304   ins_pipe(ialu_reg);
 9305 %}
 9306 
 9307 // And Register with Immediate 65535
 9308 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9309 %{
 9310   match(Set dst (AndI dst src));
 9311 
 9312   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9313   opcode(0x0F, 0xB7);
 9314   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9315   ins_pipe(ialu_reg);
 9316 %}
 9317 
 9318 // And Register with Immediate 65535 and promote to long
 9319 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9320 %{
 9321   match(Set dst (ConvI2L (AndI src mask)));
 9322 
 9323   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9324   opcode(0x0F, 0xB7);
 9325   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9326   ins_pipe(ialu_reg);
 9327 %}
 9328 
 9329 // And Register with Immediate
 9330 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9331 %{
 9332   match(Set dst (AndI dst src));
 9333   effect(KILL cr);
 9334 
 9335   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9336   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9337   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9338   ins_pipe(ialu_reg);
 9339 %}
 9340 
 9341 // And Register with Memory
 9342 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9343 %{
 9344   match(Set dst (AndI dst (LoadI src)));
 9345   effect(KILL cr);
 9346 
 9347   ins_cost(125);
 9348   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9349   opcode(0x23);
 9350   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9351   ins_pipe(ialu_reg_mem);
 9352 %}
 9353 
 9354 // And Memory with Register
 9355 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9356 %{
 9357   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9358   effect(KILL cr);
 9359 
 9360   ins_cost(150);
 9361   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9362   opcode(0x20);
 9363   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9364   ins_pipe(ialu_mem_reg);
 9365 %}
 9366 
 9367 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9368 %{
 9369   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9370   effect(KILL cr);
 9371 
 9372   ins_cost(150);
 9373   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9374   opcode(0x21); /* Opcode 21 /r */
 9375   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9376   ins_pipe(ialu_mem_reg);
 9377 %}
 9378 
 9379 // And Memory with Immediate
 9380 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9381 %{
 9382   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9383   effect(KILL cr);
 9384 
 9385   ins_cost(125);
 9386   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9387   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9388   ins_encode(REX_mem(dst), OpcSE(src),
 9389              RM_opc_mem(secondary, dst), Con8or32(src));
 9390   ins_pipe(ialu_mem_imm);
 9391 %}
 9392 
 9393 // BMI1 instructions
 9394 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9395   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9396   predicate(UseBMI1Instructions);
 9397   effect(KILL cr);
 9398 
 9399   ins_cost(125);
 9400   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9401 
 9402   ins_encode %{
 9403     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9404   %}
 9405   ins_pipe(ialu_reg_mem);
 9406 %}
 9407 
 9408 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9409   match(Set dst (AndI (XorI src1 minus_1) src2));
 9410   predicate(UseBMI1Instructions);
 9411   effect(KILL cr);
 9412 
 9413   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9414 
 9415   ins_encode %{
 9416     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9417   %}
 9418   ins_pipe(ialu_reg);
 9419 %}
 9420 
 9421 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9422   match(Set dst (AndI (SubI imm_zero src) src));
 9423   predicate(UseBMI1Instructions);
 9424   effect(KILL cr);
 9425 
 9426   format %{ &quot;blsil  $dst, $src&quot; %}
 9427 
 9428   ins_encode %{
 9429     __ blsil($dst$$Register, $src$$Register);
 9430   %}
 9431   ins_pipe(ialu_reg);
 9432 %}
 9433 
 9434 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9435   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9436   predicate(UseBMI1Instructions);
 9437   effect(KILL cr);
 9438 
 9439   ins_cost(125);
 9440   format %{ &quot;blsil  $dst, $src&quot; %}
 9441 
 9442   ins_encode %{
 9443     __ blsil($dst$$Register, $src$$Address);
 9444   %}
 9445   ins_pipe(ialu_reg_mem);
 9446 %}
 9447 
 9448 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9449 %{
 9450   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9451   predicate(UseBMI1Instructions);
 9452   effect(KILL cr);
 9453 
 9454   ins_cost(125);
 9455   format %{ &quot;blsmskl $dst, $src&quot; %}
 9456 
 9457   ins_encode %{
 9458     __ blsmskl($dst$$Register, $src$$Address);
 9459   %}
 9460   ins_pipe(ialu_reg_mem);
 9461 %}
 9462 
 9463 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9464 %{
 9465   match(Set dst (XorI (AddI src minus_1) src));
 9466   predicate(UseBMI1Instructions);
 9467   effect(KILL cr);
 9468 
 9469   format %{ &quot;blsmskl $dst, $src&quot; %}
 9470 
 9471   ins_encode %{
 9472     __ blsmskl($dst$$Register, $src$$Register);
 9473   %}
 9474 
 9475   ins_pipe(ialu_reg);
 9476 %}
 9477 
 9478 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9479 %{
 9480   match(Set dst (AndI (AddI src minus_1) src) );
 9481   predicate(UseBMI1Instructions);
 9482   effect(KILL cr);
 9483 
 9484   format %{ &quot;blsrl  $dst, $src&quot; %}
 9485 
 9486   ins_encode %{
 9487     __ blsrl($dst$$Register, $src$$Register);
 9488   %}
 9489 
 9490   ins_pipe(ialu_reg_mem);
 9491 %}
 9492 
 9493 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9494 %{
 9495   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9496   predicate(UseBMI1Instructions);
 9497   effect(KILL cr);
 9498 
 9499   ins_cost(125);
 9500   format %{ &quot;blsrl  $dst, $src&quot; %}
 9501 
 9502   ins_encode %{
 9503     __ blsrl($dst$$Register, $src$$Address);
 9504   %}
 9505 
 9506   ins_pipe(ialu_reg);
 9507 %}
 9508 
 9509 // Or Instructions
 9510 // Or Register with Register
 9511 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9512 %{
 9513   match(Set dst (OrI dst src));
 9514   effect(KILL cr);
 9515 
 9516   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9517   opcode(0x0B);
 9518   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9519   ins_pipe(ialu_reg_reg);
 9520 %}
 9521 
 9522 // Or Register with Immediate
 9523 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9524 %{
 9525   match(Set dst (OrI dst src));
 9526   effect(KILL cr);
 9527 
 9528   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9529   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9530   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9531   ins_pipe(ialu_reg);
 9532 %}
 9533 
 9534 // Or Register with Memory
 9535 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9536 %{
 9537   match(Set dst (OrI dst (LoadI src)));
 9538   effect(KILL cr);
 9539 
 9540   ins_cost(125);
 9541   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9542   opcode(0x0B);
 9543   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9544   ins_pipe(ialu_reg_mem);
 9545 %}
 9546 
 9547 // Or Memory with Register
 9548 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9549 %{
 9550   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9551   effect(KILL cr);
 9552 
 9553   ins_cost(150);
 9554   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9555   opcode(0x08);
 9556   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9557   ins_pipe(ialu_mem_reg);
 9558 %}
 9559 
 9560 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9561 %{
 9562   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9563   effect(KILL cr);
 9564 
 9565   ins_cost(150);
 9566   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9567   opcode(0x09); /* Opcode 09 /r */
 9568   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9569   ins_pipe(ialu_mem_reg);
 9570 %}
 9571 
 9572 // Or Memory with Immediate
 9573 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9574 %{
 9575   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9576   effect(KILL cr);
 9577 
 9578   ins_cost(125);
 9579   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9580   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9581   ins_encode(REX_mem(dst), OpcSE(src),
 9582              RM_opc_mem(secondary, dst), Con8or32(src));
 9583   ins_pipe(ialu_mem_imm);
 9584 %}
 9585 
 9586 // Xor Instructions
 9587 // Xor Register with Register
 9588 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9589 %{
 9590   match(Set dst (XorI dst src));
 9591   effect(KILL cr);
 9592 
 9593   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9594   opcode(0x33);
 9595   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9596   ins_pipe(ialu_reg_reg);
 9597 %}
 9598 
 9599 // Xor Register with Immediate -1
 9600 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9601   match(Set dst (XorI dst imm));
 9602 
 9603   format %{ &quot;not    $dst&quot; %}
 9604   ins_encode %{
 9605      __ notl($dst$$Register);
 9606   %}
 9607   ins_pipe(ialu_reg);
 9608 %}
 9609 
 9610 // Xor Register with Immediate
 9611 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9612 %{
 9613   match(Set dst (XorI dst src));
 9614   effect(KILL cr);
 9615 
 9616   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9617   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9618   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9619   ins_pipe(ialu_reg);
 9620 %}
 9621 
 9622 // Xor Register with Memory
 9623 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9624 %{
 9625   match(Set dst (XorI dst (LoadI src)));
 9626   effect(KILL cr);
 9627 
 9628   ins_cost(125);
 9629   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9630   opcode(0x33);
 9631   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9632   ins_pipe(ialu_reg_mem);
 9633 %}
 9634 
 9635 // Xor Memory with Register
 9636 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9637 %{
 9638   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9639   effect(KILL cr);
 9640 
 9641   ins_cost(150);
 9642   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9643   opcode(0x30);
 9644   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9645   ins_pipe(ialu_mem_reg);
 9646 %}
 9647 
 9648 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9649 %{
 9650   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9651   effect(KILL cr);
 9652 
 9653   ins_cost(150);
 9654   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9655   opcode(0x31); /* Opcode 31 /r */
 9656   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9657   ins_pipe(ialu_mem_reg);
 9658 %}
 9659 
 9660 // Xor Memory with Immediate
 9661 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9662 %{
 9663   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9664   effect(KILL cr);
 9665 
 9666   ins_cost(125);
 9667   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9668   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9669   ins_encode(REX_mem(dst), OpcSE(src),
 9670              RM_opc_mem(secondary, dst), Con8or32(src));
 9671   ins_pipe(ialu_mem_imm);
 9672 %}
 9673 
 9674 
 9675 // Long Logical Instructions
 9676 
 9677 // And Instructions
 9678 // And Register with Register
 9679 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9680 %{
 9681   match(Set dst (AndL dst src));
 9682   effect(KILL cr);
 9683 
 9684   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9685   opcode(0x23);
 9686   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9687   ins_pipe(ialu_reg_reg);
 9688 %}
 9689 
 9690 // And Register with Immediate 255
 9691 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9692 %{
 9693   match(Set dst (AndL dst src));
 9694 
 9695   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9696   opcode(0x0F, 0xB6);
 9697   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9698   ins_pipe(ialu_reg);
 9699 %}
 9700 
 9701 // And Register with Immediate 65535
 9702 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9703 %{
 9704   match(Set dst (AndL dst src));
 9705 
 9706   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9707   opcode(0x0F, 0xB7);
 9708   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9709   ins_pipe(ialu_reg);
 9710 %}
 9711 
 9712 // And Register with Immediate
 9713 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9714 %{
 9715   match(Set dst (AndL dst src));
 9716   effect(KILL cr);
 9717 
 9718   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9719   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9720   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9721   ins_pipe(ialu_reg);
 9722 %}
 9723 
 9724 // And Register with Memory
 9725 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9726 %{
 9727   match(Set dst (AndL dst (LoadL src)));
 9728   effect(KILL cr);
 9729 
 9730   ins_cost(125);
 9731   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9732   opcode(0x23);
 9733   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9734   ins_pipe(ialu_reg_mem);
 9735 %}
 9736 
 9737 // And Memory with Register
 9738 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9739 %{
 9740   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9741   effect(KILL cr);
 9742 
 9743   ins_cost(150);
 9744   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9745   opcode(0x21); /* Opcode 21 /r */
 9746   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9747   ins_pipe(ialu_mem_reg);
 9748 %}
 9749 
 9750 // And Memory with Immediate
 9751 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9752 %{
 9753   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9754   effect(KILL cr);
 9755 
 9756   ins_cost(125);
 9757   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9758   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9759   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9760              RM_opc_mem(secondary, dst), Con8or32(src));
 9761   ins_pipe(ialu_mem_imm);
 9762 %}
 9763 
 9764 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9765 %{
 9766   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9767   // because AND/OR works well enough for 8/32-bit values.
 9768   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9769 
 9770   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9771   effect(KILL cr);
 9772 
 9773   ins_cost(125);
 9774   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9775   ins_encode %{
 9776     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9777   %}
 9778   ins_pipe(ialu_mem_imm);
 9779 %}
 9780 
 9781 // BMI1 instructions
 9782 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9783   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9784   predicate(UseBMI1Instructions);
 9785   effect(KILL cr);
 9786 
 9787   ins_cost(125);
 9788   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9789 
 9790   ins_encode %{
 9791     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9792   %}
 9793   ins_pipe(ialu_reg_mem);
 9794 %}
 9795 
 9796 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9797   match(Set dst (AndL (XorL src1 minus_1) src2));
 9798   predicate(UseBMI1Instructions);
 9799   effect(KILL cr);
 9800 
 9801   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9802 
 9803   ins_encode %{
 9804   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9805   %}
 9806   ins_pipe(ialu_reg_mem);
 9807 %}
 9808 
 9809 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9810   match(Set dst (AndL (SubL imm_zero src) src));
 9811   predicate(UseBMI1Instructions);
 9812   effect(KILL cr);
 9813 
 9814   format %{ &quot;blsiq  $dst, $src&quot; %}
 9815 
 9816   ins_encode %{
 9817     __ blsiq($dst$$Register, $src$$Register);
 9818   %}
 9819   ins_pipe(ialu_reg);
 9820 %}
 9821 
 9822 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9823   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9824   predicate(UseBMI1Instructions);
 9825   effect(KILL cr);
 9826 
 9827   ins_cost(125);
 9828   format %{ &quot;blsiq  $dst, $src&quot; %}
 9829 
 9830   ins_encode %{
 9831     __ blsiq($dst$$Register, $src$$Address);
 9832   %}
 9833   ins_pipe(ialu_reg_mem);
 9834 %}
 9835 
 9836 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9837 %{
 9838   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9839   predicate(UseBMI1Instructions);
 9840   effect(KILL cr);
 9841 
 9842   ins_cost(125);
 9843   format %{ &quot;blsmskq $dst, $src&quot; %}
 9844 
 9845   ins_encode %{
 9846     __ blsmskq($dst$$Register, $src$$Address);
 9847   %}
 9848   ins_pipe(ialu_reg_mem);
 9849 %}
 9850 
 9851 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9852 %{
 9853   match(Set dst (XorL (AddL src minus_1) src));
 9854   predicate(UseBMI1Instructions);
 9855   effect(KILL cr);
 9856 
 9857   format %{ &quot;blsmskq $dst, $src&quot; %}
 9858 
 9859   ins_encode %{
 9860     __ blsmskq($dst$$Register, $src$$Register);
 9861   %}
 9862 
 9863   ins_pipe(ialu_reg);
 9864 %}
 9865 
 9866 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9867 %{
 9868   match(Set dst (AndL (AddL src minus_1) src) );
 9869   predicate(UseBMI1Instructions);
 9870   effect(KILL cr);
 9871 
 9872   format %{ &quot;blsrq  $dst, $src&quot; %}
 9873 
 9874   ins_encode %{
 9875     __ blsrq($dst$$Register, $src$$Register);
 9876   %}
 9877 
 9878   ins_pipe(ialu_reg);
 9879 %}
 9880 
 9881 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9882 %{
 9883   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9884   predicate(UseBMI1Instructions);
 9885   effect(KILL cr);
 9886 
 9887   ins_cost(125);
 9888   format %{ &quot;blsrq  $dst, $src&quot; %}
 9889 
 9890   ins_encode %{
 9891     __ blsrq($dst$$Register, $src$$Address);
 9892   %}
 9893 
 9894   ins_pipe(ialu_reg);
 9895 %}
 9896 
 9897 // Or Instructions
 9898 // Or Register with Register
 9899 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9900 %{
 9901   match(Set dst (OrL dst src));
 9902   effect(KILL cr);
 9903 
 9904   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9905   opcode(0x0B);
 9906   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9907   ins_pipe(ialu_reg_reg);
 9908 %}
 9909 
 9910 // Use any_RegP to match R15 (TLS register) without spilling.
 9911 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9912   match(Set dst (OrL dst (CastP2X src)));
 9913   effect(KILL cr);
 9914 
 9915   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9916   opcode(0x0B);
 9917   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9918   ins_pipe(ialu_reg_reg);
 9919 %}
 9920 
 9921 
 9922 // Or Register with Immediate
 9923 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9924 %{
 9925   match(Set dst (OrL dst src));
 9926   effect(KILL cr);
 9927 
 9928   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9929   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9930   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9931   ins_pipe(ialu_reg);
 9932 %}
 9933 
 9934 // Or Register with Memory
 9935 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9936 %{
 9937   match(Set dst (OrL dst (LoadL src)));
 9938   effect(KILL cr);
 9939 
 9940   ins_cost(125);
 9941   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9942   opcode(0x0B);
 9943   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9944   ins_pipe(ialu_reg_mem);
 9945 %}
 9946 
 9947 // Or Memory with Register
 9948 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9949 %{
 9950   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9951   effect(KILL cr);
 9952 
 9953   ins_cost(150);
 9954   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9955   opcode(0x09); /* Opcode 09 /r */
 9956   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9957   ins_pipe(ialu_mem_reg);
 9958 %}
 9959 
 9960 // Or Memory with Immediate
 9961 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9962 %{
 9963   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9964   effect(KILL cr);
 9965 
 9966   ins_cost(125);
 9967   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9968   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9969   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9970              RM_opc_mem(secondary, dst), Con8or32(src));
 9971   ins_pipe(ialu_mem_imm);
 9972 %}
 9973 
 9974 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9975 %{
 9976   // con should be a pure 64-bit power of 2 immediate
 9977   // because AND/OR works well enough for 8/32-bit values.
 9978   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9979 
 9980   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9981   effect(KILL cr);
 9982 
 9983   ins_cost(125);
 9984   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9985   ins_encode %{
 9986     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
 9987   %}
 9988   ins_pipe(ialu_mem_imm);
 9989 %}
 9990 
 9991 // Xor Instructions
 9992 // Xor Register with Register
 9993 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9994 %{
 9995   match(Set dst (XorL dst src));
 9996   effect(KILL cr);
 9997 
 9998   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
 9999   opcode(0x33);
10000   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10001   ins_pipe(ialu_reg_reg);
10002 %}
10003 
10004 // Xor Register with Immediate -1
10005 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10006   match(Set dst (XorL dst imm));
10007 
10008   format %{ &quot;notq   $dst&quot; %}
10009   ins_encode %{
10010      __ notq($dst$$Register);
10011   %}
10012   ins_pipe(ialu_reg);
10013 %}
10014 
10015 // Xor Register with Immediate
10016 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10017 %{
10018   match(Set dst (XorL dst src));
10019   effect(KILL cr);
10020 
10021   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10022   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10023   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10024   ins_pipe(ialu_reg);
10025 %}
10026 
10027 // Xor Register with Memory
10028 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10029 %{
10030   match(Set dst (XorL dst (LoadL src)));
10031   effect(KILL cr);
10032 
10033   ins_cost(125);
10034   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10035   opcode(0x33);
10036   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10037   ins_pipe(ialu_reg_mem);
10038 %}
10039 
10040 // Xor Memory with Register
10041 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10042 %{
10043   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10044   effect(KILL cr);
10045 
10046   ins_cost(150);
10047   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10048   opcode(0x31); /* Opcode 31 /r */
10049   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10050   ins_pipe(ialu_mem_reg);
10051 %}
10052 
10053 // Xor Memory with Immediate
10054 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10055 %{
10056   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10057   effect(KILL cr);
10058 
10059   ins_cost(125);
10060   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10061   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10062   ins_encode(REX_mem_wide(dst), OpcSE(src),
10063              RM_opc_mem(secondary, dst), Con8or32(src));
10064   ins_pipe(ialu_mem_imm);
10065 %}
10066 
10067 // Convert Int to Boolean
10068 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10069 %{
10070   match(Set dst (Conv2B src));
10071   effect(KILL cr);
10072 
10073   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10074             &quot;setnz   $dst\n\t&quot;
10075             &quot;movzbl  $dst, $dst&quot; %}
10076   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10077              setNZ_reg(dst),
10078              REX_reg_breg(dst, dst), // movzbl
10079              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10080   ins_pipe(pipe_slow); // XXX
10081 %}
10082 
10083 // Convert Pointer to Boolean
10084 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10085 %{
10086   match(Set dst (Conv2B src));
10087   effect(KILL cr);
10088 
10089   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10090             &quot;setnz   $dst\n\t&quot;
10091             &quot;movzbl  $dst, $dst&quot; %}
10092   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10093              setNZ_reg(dst),
10094              REX_reg_breg(dst, dst), // movzbl
10095              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10096   ins_pipe(pipe_slow); // XXX
10097 %}
10098 
10099 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10100 %{
10101   match(Set dst (CmpLTMask p q));
10102   effect(KILL cr);
10103 
10104   ins_cost(400);
10105   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10106             &quot;setlt   $dst\n\t&quot;
10107             &quot;movzbl  $dst, $dst\n\t&quot;
10108             &quot;negl    $dst&quot; %}
10109   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10110              setLT_reg(dst),
10111              REX_reg_breg(dst, dst), // movzbl
10112              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10113              neg_reg(dst));
10114   ins_pipe(pipe_slow);
10115 %}
10116 
10117 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10118 %{
10119   match(Set dst (CmpLTMask dst zero));
10120   effect(KILL cr);
10121 
10122   ins_cost(100);
10123   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10124   ins_encode %{
10125   __ sarl($dst$$Register, 31);
10126   %}
10127   ins_pipe(ialu_reg);
10128 %}
10129 
10130 /* Better to save a register than avoid a branch */
10131 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10132 %{
10133   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10134   effect(KILL cr);
10135   ins_cost(300);
10136   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10137             &quot;jge     done\n\t&quot;
10138             &quot;addl    $p,$y\n&quot;
10139             &quot;done:   &quot; %}
10140   ins_encode %{
10141     Register Rp = $p$$Register;
10142     Register Rq = $q$$Register;
10143     Register Ry = $y$$Register;
10144     Label done;
10145     __ subl(Rp, Rq);
10146     __ jccb(Assembler::greaterEqual, done);
10147     __ addl(Rp, Ry);
10148     __ bind(done);
10149   %}
10150   ins_pipe(pipe_cmplt);
10151 %}
10152 
10153 /* Better to save a register than avoid a branch */
10154 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10155 %{
10156   match(Set y (AndI (CmpLTMask p q) y));
10157   effect(KILL cr);
10158 
10159   ins_cost(300);
10160 
10161   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10162             &quot;jlt     done\n\t&quot;
10163             &quot;xorl    $y, $y\n&quot;
10164             &quot;done:   &quot; %}
10165   ins_encode %{
10166     Register Rp = $p$$Register;
10167     Register Rq = $q$$Register;
10168     Register Ry = $y$$Register;
10169     Label done;
10170     __ cmpl(Rp, Rq);
10171     __ jccb(Assembler::less, done);
10172     __ xorl(Ry, Ry);
10173     __ bind(done);
10174   %}
10175   ins_pipe(pipe_cmplt);
10176 %}
10177 
10178 
10179 //---------- FP Instructions------------------------------------------------
10180 
10181 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10182 %{
10183   match(Set cr (CmpF src1 src2));
10184 
10185   ins_cost(145);
10186   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10187             &quot;jnp,s   exit\n\t&quot;
10188             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10189             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10190             &quot;popfq\n&quot;
10191     &quot;exit:&quot; %}
10192   ins_encode %{
10193     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10194     emit_cmpfp_fixup(_masm);
10195   %}
10196   ins_pipe(pipe_slow);
10197 %}
10198 
10199 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10200   match(Set cr (CmpF src1 src2));
10201 
10202   ins_cost(100);
10203   format %{ &quot;ucomiss $src1, $src2&quot; %}
10204   ins_encode %{
10205     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10206   %}
10207   ins_pipe(pipe_slow);
10208 %}
10209 
10210 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10211 %{
10212   match(Set cr (CmpF src1 (LoadF src2)));
10213 
10214   ins_cost(145);
10215   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10216             &quot;jnp,s   exit\n\t&quot;
10217             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10218             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10219             &quot;popfq\n&quot;
10220     &quot;exit:&quot; %}
10221   ins_encode %{
10222     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10223     emit_cmpfp_fixup(_masm);
10224   %}
10225   ins_pipe(pipe_slow);
10226 %}
10227 
10228 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10229   match(Set cr (CmpF src1 (LoadF src2)));
10230 
10231   ins_cost(100);
10232   format %{ &quot;ucomiss $src1, $src2&quot; %}
10233   ins_encode %{
10234     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10235   %}
10236   ins_pipe(pipe_slow);
10237 %}
10238 
10239 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10240   match(Set cr (CmpF src con));
10241 
10242   ins_cost(145);
10243   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10244             &quot;jnp,s   exit\n\t&quot;
10245             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10246             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10247             &quot;popfq\n&quot;
10248     &quot;exit:&quot; %}
10249   ins_encode %{
10250     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10251     emit_cmpfp_fixup(_masm);
10252   %}
10253   ins_pipe(pipe_slow);
10254 %}
10255 
10256 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10257   match(Set cr (CmpF src con));
10258   ins_cost(100);
10259   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10260   ins_encode %{
10261     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10262   %}
10263   ins_pipe(pipe_slow);
10264 %}
10265 
10266 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10267 %{
10268   match(Set cr (CmpD src1 src2));
10269 
10270   ins_cost(145);
10271   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10272             &quot;jnp,s   exit\n\t&quot;
10273             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10274             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10275             &quot;popfq\n&quot;
10276     &quot;exit:&quot; %}
10277   ins_encode %{
10278     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10279     emit_cmpfp_fixup(_masm);
10280   %}
10281   ins_pipe(pipe_slow);
10282 %}
10283 
10284 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10285   match(Set cr (CmpD src1 src2));
10286 
10287   ins_cost(100);
10288   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10289   ins_encode %{
10290     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10291   %}
10292   ins_pipe(pipe_slow);
10293 %}
10294 
10295 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10296 %{
10297   match(Set cr (CmpD src1 (LoadD src2)));
10298 
10299   ins_cost(145);
10300   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10301             &quot;jnp,s   exit\n\t&quot;
10302             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10303             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10304             &quot;popfq\n&quot;
10305     &quot;exit:&quot; %}
10306   ins_encode %{
10307     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10308     emit_cmpfp_fixup(_masm);
10309   %}
10310   ins_pipe(pipe_slow);
10311 %}
10312 
10313 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10314   match(Set cr (CmpD src1 (LoadD src2)));
10315 
10316   ins_cost(100);
10317   format %{ &quot;ucomisd $src1, $src2&quot; %}
10318   ins_encode %{
10319     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10320   %}
10321   ins_pipe(pipe_slow);
10322 %}
10323 
10324 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10325   match(Set cr (CmpD src con));
10326 
10327   ins_cost(145);
10328   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10329             &quot;jnp,s   exit\n\t&quot;
10330             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10331             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10332             &quot;popfq\n&quot;
10333     &quot;exit:&quot; %}
10334   ins_encode %{
10335     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10336     emit_cmpfp_fixup(_masm);
10337   %}
10338   ins_pipe(pipe_slow);
10339 %}
10340 
10341 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10342   match(Set cr (CmpD src con));
10343   ins_cost(100);
10344   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10345   ins_encode %{
10346     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10347   %}
10348   ins_pipe(pipe_slow);
10349 %}
10350 
10351 // Compare into -1,0,1
10352 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10353 %{
10354   match(Set dst (CmpF3 src1 src2));
10355   effect(KILL cr);
10356 
10357   ins_cost(275);
10358   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10359             &quot;movl    $dst, #-1\n\t&quot;
10360             &quot;jp,s    done\n\t&quot;
10361             &quot;jb,s    done\n\t&quot;
10362             &quot;setne   $dst\n\t&quot;
10363             &quot;movzbl  $dst, $dst\n&quot;
10364     &quot;done:&quot; %}
10365   ins_encode %{
10366     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10367     emit_cmpfp3(_masm, $dst$$Register);
10368   %}
10369   ins_pipe(pipe_slow);
10370 %}
10371 
10372 // Compare into -1,0,1
10373 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10374 %{
10375   match(Set dst (CmpF3 src1 (LoadF src2)));
10376   effect(KILL cr);
10377 
10378   ins_cost(275);
10379   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10380             &quot;movl    $dst, #-1\n\t&quot;
10381             &quot;jp,s    done\n\t&quot;
10382             &quot;jb,s    done\n\t&quot;
10383             &quot;setne   $dst\n\t&quot;
10384             &quot;movzbl  $dst, $dst\n&quot;
10385     &quot;done:&quot; %}
10386   ins_encode %{
10387     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10388     emit_cmpfp3(_masm, $dst$$Register);
10389   %}
10390   ins_pipe(pipe_slow);
10391 %}
10392 
10393 // Compare into -1,0,1
10394 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10395   match(Set dst (CmpF3 src con));
10396   effect(KILL cr);
10397 
10398   ins_cost(275);
10399   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10400             &quot;movl    $dst, #-1\n\t&quot;
10401             &quot;jp,s    done\n\t&quot;
10402             &quot;jb,s    done\n\t&quot;
10403             &quot;setne   $dst\n\t&quot;
10404             &quot;movzbl  $dst, $dst\n&quot;
10405     &quot;done:&quot; %}
10406   ins_encode %{
10407     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10408     emit_cmpfp3(_masm, $dst$$Register);
10409   %}
10410   ins_pipe(pipe_slow);
10411 %}
10412 
10413 // Compare into -1,0,1
10414 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10415 %{
10416   match(Set dst (CmpD3 src1 src2));
10417   effect(KILL cr);
10418 
10419   ins_cost(275);
10420   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10421             &quot;movl    $dst, #-1\n\t&quot;
10422             &quot;jp,s    done\n\t&quot;
10423             &quot;jb,s    done\n\t&quot;
10424             &quot;setne   $dst\n\t&quot;
10425             &quot;movzbl  $dst, $dst\n&quot;
10426     &quot;done:&quot; %}
10427   ins_encode %{
10428     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10429     emit_cmpfp3(_masm, $dst$$Register);
10430   %}
10431   ins_pipe(pipe_slow);
10432 %}
10433 
10434 // Compare into -1,0,1
10435 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10436 %{
10437   match(Set dst (CmpD3 src1 (LoadD src2)));
10438   effect(KILL cr);
10439 
10440   ins_cost(275);
10441   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10442             &quot;movl    $dst, #-1\n\t&quot;
10443             &quot;jp,s    done\n\t&quot;
10444             &quot;jb,s    done\n\t&quot;
10445             &quot;setne   $dst\n\t&quot;
10446             &quot;movzbl  $dst, $dst\n&quot;
10447     &quot;done:&quot; %}
10448   ins_encode %{
10449     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10450     emit_cmpfp3(_masm, $dst$$Register);
10451   %}
10452   ins_pipe(pipe_slow);
10453 %}
10454 
10455 // Compare into -1,0,1
10456 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10457   match(Set dst (CmpD3 src con));
10458   effect(KILL cr);
10459 
10460   ins_cost(275);
10461   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10462             &quot;movl    $dst, #-1\n\t&quot;
10463             &quot;jp,s    done\n\t&quot;
10464             &quot;jb,s    done\n\t&quot;
10465             &quot;setne   $dst\n\t&quot;
10466             &quot;movzbl  $dst, $dst\n&quot;
10467     &quot;done:&quot; %}
10468   ins_encode %{
10469     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10470     emit_cmpfp3(_masm, $dst$$Register);
10471   %}
10472   ins_pipe(pipe_slow);
10473 %}
10474 
10475 //----------Arithmetic Conversion Instructions---------------------------------
10476 
10477 instruct convF2D_reg_reg(regD dst, regF src)
10478 %{
10479   match(Set dst (ConvF2D src));
10480 
10481   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10482   ins_encode %{
10483     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10484   %}
10485   ins_pipe(pipe_slow); // XXX
10486 %}
10487 
10488 instruct convF2D_reg_mem(regD dst, memory src)
10489 %{
10490   match(Set dst (ConvF2D (LoadF src)));
10491 
10492   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10493   ins_encode %{
10494     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10495   %}
10496   ins_pipe(pipe_slow); // XXX
10497 %}
10498 
10499 instruct convD2F_reg_reg(regF dst, regD src)
10500 %{
10501   match(Set dst (ConvD2F src));
10502 
10503   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10504   ins_encode %{
10505     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10506   %}
10507   ins_pipe(pipe_slow); // XXX
10508 %}
10509 
10510 instruct convD2F_reg_mem(regF dst, memory src)
10511 %{
10512   match(Set dst (ConvD2F (LoadD src)));
10513 
10514   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10515   ins_encode %{
10516     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10517   %}
10518   ins_pipe(pipe_slow); // XXX
10519 %}
10520 
10521 // XXX do mem variants
10522 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10523 %{
10524   match(Set dst (ConvF2I src));
10525   effect(KILL cr);
10526   format %{ &quot;convert_f2i $dst,$src&quot; %}
10527   ins_encode %{
10528     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10529   %}
10530   ins_pipe(pipe_slow);
10531 %}
10532 
10533 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10534 %{
10535   match(Set dst (ConvF2L src));
10536   effect(KILL cr);
10537   format %{ &quot;convert_f2l $dst,$src&quot;%}
10538   ins_encode %{
10539     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10540   %}
10541   ins_pipe(pipe_slow);
10542 %}
10543 
10544 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10545 %{
10546   match(Set dst (ConvD2I src));
10547   effect(KILL cr);
10548   format %{ &quot;convert_d2i $dst,$src&quot;%}
10549   ins_encode %{
10550     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10551   %}
10552   ins_pipe(pipe_slow);
10553 %}
10554 
10555 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10556 %{
10557   match(Set dst (ConvD2L src));
10558   effect(KILL cr);
10559   format %{ &quot;convert_d2l $dst,$src&quot;%}
10560   ins_encode %{
10561     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10562   %}
10563   ins_pipe(pipe_slow);
10564 %}
10565 
10566 instruct convI2F_reg_reg(regF dst, rRegI src)
10567 %{
10568   predicate(!UseXmmI2F);
10569   match(Set dst (ConvI2F src));
10570 
10571   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10572   ins_encode %{
10573     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10574   %}
10575   ins_pipe(pipe_slow); // XXX
10576 %}
10577 
10578 instruct convI2F_reg_mem(regF dst, memory src)
10579 %{
10580   match(Set dst (ConvI2F (LoadI src)));
10581 
10582   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10583   ins_encode %{
10584     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10585   %}
10586   ins_pipe(pipe_slow); // XXX
10587 %}
10588 
10589 instruct convI2D_reg_reg(regD dst, rRegI src)
10590 %{
10591   predicate(!UseXmmI2D);
10592   match(Set dst (ConvI2D src));
10593 
10594   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10595   ins_encode %{
10596     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10597   %}
10598   ins_pipe(pipe_slow); // XXX
10599 %}
10600 
10601 instruct convI2D_reg_mem(regD dst, memory src)
10602 %{
10603   match(Set dst (ConvI2D (LoadI src)));
10604 
10605   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10606   ins_encode %{
10607     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10608   %}
10609   ins_pipe(pipe_slow); // XXX
10610 %}
10611 
10612 instruct convXI2F_reg(regF dst, rRegI src)
10613 %{
10614   predicate(UseXmmI2F);
10615   match(Set dst (ConvI2F src));
10616 
10617   format %{ &quot;movdl $dst, $src\n\t&quot;
10618             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10619   ins_encode %{
10620     __ movdl($dst$$XMMRegister, $src$$Register);
10621     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10622   %}
10623   ins_pipe(pipe_slow); // XXX
10624 %}
10625 
10626 instruct convXI2D_reg(regD dst, rRegI src)
10627 %{
10628   predicate(UseXmmI2D);
10629   match(Set dst (ConvI2D src));
10630 
10631   format %{ &quot;movdl $dst, $src\n\t&quot;
10632             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10633   ins_encode %{
10634     __ movdl($dst$$XMMRegister, $src$$Register);
10635     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10636   %}
10637   ins_pipe(pipe_slow); // XXX
10638 %}
10639 
10640 instruct convL2F_reg_reg(regF dst, rRegL src)
10641 %{
10642   match(Set dst (ConvL2F src));
10643 
10644   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10645   ins_encode %{
10646     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10647   %}
10648   ins_pipe(pipe_slow); // XXX
10649 %}
10650 
10651 instruct convL2F_reg_mem(regF dst, memory src)
10652 %{
10653   match(Set dst (ConvL2F (LoadL src)));
10654 
10655   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10656   ins_encode %{
10657     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10658   %}
10659   ins_pipe(pipe_slow); // XXX
10660 %}
10661 
10662 instruct convL2D_reg_reg(regD dst, rRegL src)
10663 %{
10664   match(Set dst (ConvL2D src));
10665 
10666   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10667   ins_encode %{
10668     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10669   %}
10670   ins_pipe(pipe_slow); // XXX
10671 %}
10672 
10673 instruct convL2D_reg_mem(regD dst, memory src)
10674 %{
10675   match(Set dst (ConvL2D (LoadL src)));
10676 
10677   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10678   ins_encode %{
10679     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10680   %}
10681   ins_pipe(pipe_slow); // XXX
10682 %}
10683 
10684 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10685 %{
10686   match(Set dst (ConvI2L src));
10687 
10688   ins_cost(125);
10689   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10690   ins_encode %{
10691     __ movslq($dst$$Register, $src$$Register);
10692   %}
10693   ins_pipe(ialu_reg_reg);
10694 %}
10695 
10696 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10697 // %{
10698 //   match(Set dst (ConvI2L src));
10699 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10700 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10701 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10702 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10703 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10704 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10705 
10706 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10707 //   ins_encode(enc_copy(dst, src));
10708 // //   opcode(0x63); // needs REX.W
10709 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10710 //   ins_pipe(ialu_reg_reg);
10711 // %}
10712 
10713 // Zero-extend convert int to long
10714 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10715 %{
10716   match(Set dst (AndL (ConvI2L src) mask));
10717 
10718   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10719   ins_encode %{
10720     if ($dst$$reg != $src$$reg) {
10721       __ movl($dst$$Register, $src$$Register);
10722     }
10723   %}
10724   ins_pipe(ialu_reg_reg);
10725 %}
10726 
10727 // Zero-extend convert int to long
10728 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10729 %{
10730   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10731 
10732   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10733   ins_encode %{
10734     __ movl($dst$$Register, $src$$Address);
10735   %}
10736   ins_pipe(ialu_reg_mem);
10737 %}
10738 
10739 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10740 %{
10741   match(Set dst (AndL src mask));
10742 
10743   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10744   ins_encode %{
10745     __ movl($dst$$Register, $src$$Register);
10746   %}
10747   ins_pipe(ialu_reg_reg);
10748 %}
10749 
10750 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10751 %{
10752   match(Set dst (ConvL2I src));
10753 
10754   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10755   ins_encode %{
10756     __ movl($dst$$Register, $src$$Register);
10757   %}
10758   ins_pipe(ialu_reg_reg);
10759 %}
10760 
10761 
10762 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10763   match(Set dst (MoveF2I src));
10764   effect(DEF dst, USE src);
10765 
10766   ins_cost(125);
10767   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10768   ins_encode %{
10769     __ movl($dst$$Register, Address(rsp, $src$$disp));
10770   %}
10771   ins_pipe(ialu_reg_mem);
10772 %}
10773 
10774 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10775   match(Set dst (MoveI2F src));
10776   effect(DEF dst, USE src);
10777 
10778   ins_cost(125);
10779   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10780   ins_encode %{
10781     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10782   %}
10783   ins_pipe(pipe_slow);
10784 %}
10785 
10786 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10787   match(Set dst (MoveD2L src));
10788   effect(DEF dst, USE src);
10789 
10790   ins_cost(125);
10791   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10792   ins_encode %{
10793     __ movq($dst$$Register, Address(rsp, $src$$disp));
10794   %}
10795   ins_pipe(ialu_reg_mem);
10796 %}
10797 
10798 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10799   predicate(!UseXmmLoadAndClearUpper);
10800   match(Set dst (MoveL2D src));
10801   effect(DEF dst, USE src);
10802 
10803   ins_cost(125);
10804   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10805   ins_encode %{
10806     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10807   %}
10808   ins_pipe(pipe_slow);
10809 %}
10810 
10811 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10812   predicate(UseXmmLoadAndClearUpper);
10813   match(Set dst (MoveL2D src));
10814   effect(DEF dst, USE src);
10815 
10816   ins_cost(125);
10817   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10818   ins_encode %{
10819     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10820   %}
10821   ins_pipe(pipe_slow);
10822 %}
10823 
10824 
10825 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10826   match(Set dst (MoveF2I src));
10827   effect(DEF dst, USE src);
10828 
10829   ins_cost(95); // XXX
10830   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10831   ins_encode %{
10832     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10833   %}
10834   ins_pipe(pipe_slow);
10835 %}
10836 
10837 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10838   match(Set dst (MoveI2F src));
10839   effect(DEF dst, USE src);
10840 
10841   ins_cost(100);
10842   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10843   ins_encode %{
10844     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10845   %}
10846   ins_pipe( ialu_mem_reg );
10847 %}
10848 
10849 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10850   match(Set dst (MoveD2L src));
10851   effect(DEF dst, USE src);
10852 
10853   ins_cost(95); // XXX
10854   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10855   ins_encode %{
10856     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10857   %}
10858   ins_pipe(pipe_slow);
10859 %}
10860 
10861 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10862   match(Set dst (MoveL2D src));
10863   effect(DEF dst, USE src);
10864 
10865   ins_cost(100);
10866   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10867   ins_encode %{
10868     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10869   %}
10870   ins_pipe(ialu_mem_reg);
10871 %}
10872 
10873 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10874   match(Set dst (MoveF2I src));
10875   effect(DEF dst, USE src);
10876   ins_cost(85);
10877   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10878   ins_encode %{
10879     __ movdl($dst$$Register, $src$$XMMRegister);
10880   %}
10881   ins_pipe( pipe_slow );
10882 %}
10883 
10884 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10885   match(Set dst (MoveD2L src));
10886   effect(DEF dst, USE src);
10887   ins_cost(85);
10888   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10889   ins_encode %{
10890     __ movdq($dst$$Register, $src$$XMMRegister);
10891   %}
10892   ins_pipe( pipe_slow );
10893 %}
10894 
10895 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10896   match(Set dst (MoveI2F src));
10897   effect(DEF dst, USE src);
10898   ins_cost(100);
10899   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10900   ins_encode %{
10901     __ movdl($dst$$XMMRegister, $src$$Register);
10902   %}
10903   ins_pipe( pipe_slow );
10904 %}
10905 
10906 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10907   match(Set dst (MoveL2D src));
10908   effect(DEF dst, USE src);
10909   ins_cost(100);
10910   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10911   ins_encode %{
10912      __ movdq($dst$$XMMRegister, $src$$Register);
10913   %}
10914   ins_pipe( pipe_slow );
10915 %}
10916 
10917 
10918 // =======================================================================
10919 // fast clearing of an array
10920 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10921                   Universe dummy, rFlagsReg cr)
10922 %{
10923   predicate(!((ClearArrayNode*)n)-&gt;is_large());
10924   match(Set dummy (ClearArray cnt base));
10925   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10926 
10927   format %{ $$template
10928     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10929     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10930     $$emit$$&quot;jg      LARGE\n\t&quot;
10931     $$emit$$&quot;dec     rcx\n\t&quot;
10932     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10933     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10934     $$emit$$&quot;dec     rcx\n\t&quot;
10935     $$emit$$&quot;jge     LOOP\n\t&quot;
10936     $$emit$$&quot;jmp     DONE\n\t&quot;
10937     $$emit$$&quot;# LARGE:\n\t&quot;
10938     if (UseFastStosb) {
10939        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10940        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10941     } else if (UseXMMForObjInit) {
10942        $$emit$$&quot;mov     rdi,rax\n\t&quot;
10943        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10944        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10945        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10946        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10947        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10948        $$emit$$&quot;add     0x40,rax\n\t&quot;
10949        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10950        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10951        $$emit$$&quot;jge     L_loop\n\t&quot;
10952        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10953        $$emit$$&quot;jl      L_tail\n\t&quot;
10954        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10955        $$emit$$&quot;add     0x20,rax\n\t&quot;
10956        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10957        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10958        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10959        $$emit$$&quot;jle     L_end\n\t&quot;
10960        $$emit$$&quot;dec     rcx\n\t&quot;
10961        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10962        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10963        $$emit$$&quot;add     0x8,rax\n\t&quot;
10964        $$emit$$&quot;dec     rcx\n\t&quot;
10965        $$emit$$&quot;jge     L_sloop\n\t&quot;
10966        $$emit$$&quot;# L_end:\n\t&quot;
10967     } else {
10968        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10969     }
10970     $$emit$$&quot;# DONE&quot;
10971   %}
10972   ins_encode %{
10973     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
10974                  $tmp$$XMMRegister, false);
10975   %}
10976   ins_pipe(pipe_slow);
10977 %}
10978 
10979 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10980                         Universe dummy, rFlagsReg cr)
10981 %{
10982   predicate(((ClearArrayNode*)n)-&gt;is_large());
10983   match(Set dummy (ClearArray cnt base));
10984   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10985 
10986   format %{ $$template
10987     if (UseFastStosb) {
10988        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10989        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10990        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10991     } else if (UseXMMForObjInit) {
10992        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
10993        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10994        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10995        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10996        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10997        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10998        $$emit$$&quot;add     0x40,rax\n\t&quot;
10999        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11000        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11001        $$emit$$&quot;jge     L_loop\n\t&quot;
11002        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;jl      L_tail\n\t&quot;
11004        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11005        $$emit$$&quot;add     0x20,rax\n\t&quot;
11006        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11007        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11008        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11009        $$emit$$&quot;jle     L_end\n\t&quot;
11010        $$emit$$&quot;dec     rcx\n\t&quot;
11011        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11012        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11013        $$emit$$&quot;add     0x8,rax\n\t&quot;
11014        $$emit$$&quot;dec     rcx\n\t&quot;
11015        $$emit$$&quot;jge     L_sloop\n\t&quot;
11016        $$emit$$&quot;# L_end:\n\t&quot;
11017     } else {
11018        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11019        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11020     }
11021   %}
11022   ins_encode %{
11023     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11024                  $tmp$$XMMRegister, true);
11025   %}
11026   ins_pipe(pipe_slow);
11027 %}
11028 
11029 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11030                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11031 %{
11032   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11033   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11034   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11035 
11036   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11037   ins_encode %{
11038     __ string_compare($str1$$Register, $str2$$Register,
11039                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11040                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11041   %}
11042   ins_pipe( pipe_slow );
11043 %}
11044 
11045 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11046                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11047 %{
11048   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11049   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11050   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11051 
11052   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11053   ins_encode %{
11054     __ string_compare($str1$$Register, $str2$$Register,
11055                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11056                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11057   %}
11058   ins_pipe( pipe_slow );
11059 %}
11060 
11061 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11062                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11063 %{
11064   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11065   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11066   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11067 
11068   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11069   ins_encode %{
11070     __ string_compare($str1$$Register, $str2$$Register,
11071                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11072                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11073   %}
11074   ins_pipe( pipe_slow );
11075 %}
11076 
11077 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11078                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11079 %{
11080   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11081   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11082   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11083 
11084   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11085   ins_encode %{
11086     __ string_compare($str2$$Register, $str1$$Register,
11087                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11088                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11089   %}
11090   ins_pipe( pipe_slow );
11091 %}
11092 
11093 // fast search of substring with known size.
11094 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11095                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11096 %{
11097   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11098   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11099   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11100 
11101   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11102   ins_encode %{
11103     int icnt2 = (int)$int_cnt2$$constant;
11104     if (icnt2 &gt;= 16) {
11105       // IndexOf for constant substrings with size &gt;= 16 elements
11106       // which don&#39;t need to be loaded through stack.
11107       __ string_indexofC8($str1$$Register, $str2$$Register,
11108                           $cnt1$$Register, $cnt2$$Register,
11109                           icnt2, $result$$Register,
11110                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11111     } else {
11112       // Small strings are loaded through stack if they cross page boundary.
11113       __ string_indexof($str1$$Register, $str2$$Register,
11114                         $cnt1$$Register, $cnt2$$Register,
11115                         icnt2, $result$$Register,
11116                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11117     }
11118   %}
11119   ins_pipe( pipe_slow );
11120 %}
11121 
11122 // fast search of substring with known size.
11123 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11124                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11125 %{
11126   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11127   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11128   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11129 
11130   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11131   ins_encode %{
11132     int icnt2 = (int)$int_cnt2$$constant;
11133     if (icnt2 &gt;= 8) {
11134       // IndexOf for constant substrings with size &gt;= 8 elements
11135       // which don&#39;t need to be loaded through stack.
11136       __ string_indexofC8($str1$$Register, $str2$$Register,
11137                           $cnt1$$Register, $cnt2$$Register,
11138                           icnt2, $result$$Register,
11139                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11140     } else {
11141       // Small strings are loaded through stack if they cross page boundary.
11142       __ string_indexof($str1$$Register, $str2$$Register,
11143                         $cnt1$$Register, $cnt2$$Register,
11144                         icnt2, $result$$Register,
11145                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11146     }
11147   %}
11148   ins_pipe( pipe_slow );
11149 %}
11150 
11151 // fast search of substring with known size.
11152 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11153                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11154 %{
11155   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11156   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11157   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11158 
11159   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11160   ins_encode %{
11161     int icnt2 = (int)$int_cnt2$$constant;
11162     if (icnt2 &gt;= 8) {
11163       // IndexOf for constant substrings with size &gt;= 8 elements
11164       // which don&#39;t need to be loaded through stack.
11165       __ string_indexofC8($str1$$Register, $str2$$Register,
11166                           $cnt1$$Register, $cnt2$$Register,
11167                           icnt2, $result$$Register,
11168                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11169     } else {
11170       // Small strings are loaded through stack if they cross page boundary.
11171       __ string_indexof($str1$$Register, $str2$$Register,
11172                         $cnt1$$Register, $cnt2$$Register,
11173                         icnt2, $result$$Register,
11174                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11175     }
11176   %}
11177   ins_pipe( pipe_slow );
11178 %}
11179 
11180 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11181                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11182 %{
11183   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11184   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11185   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11186 
11187   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11188   ins_encode %{
11189     __ string_indexof($str1$$Register, $str2$$Register,
11190                       $cnt1$$Register, $cnt2$$Register,
11191                       (-1), $result$$Register,
11192                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11193   %}
11194   ins_pipe( pipe_slow );
11195 %}
11196 
11197 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11198                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11199 %{
11200   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11201   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11202   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11203 
11204   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11205   ins_encode %{
11206     __ string_indexof($str1$$Register, $str2$$Register,
11207                       $cnt1$$Register, $cnt2$$Register,
11208                       (-1), $result$$Register,
11209                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11210   %}
11211   ins_pipe( pipe_slow );
11212 %}
11213 
11214 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11215                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11216 %{
11217   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11218   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11219   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11220 
11221   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11222   ins_encode %{
11223     __ string_indexof($str1$$Register, $str2$$Register,
11224                       $cnt1$$Register, $cnt2$$Register,
11225                       (-1), $result$$Register,
11226                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11227   %}
11228   ins_pipe( pipe_slow );
11229 %}
11230 
11231 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11232                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11233 %{
11234   predicate(UseSSE42Intrinsics);
11235   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11236   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11237   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11238   ins_encode %{
11239     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11240                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11241   %}
11242   ins_pipe( pipe_slow );
11243 %}
11244 
11245 // fast string equals
11246 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11247                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11248 %{
11249   match(Set result (StrEquals (Binary str1 str2) cnt));
11250   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11251 
11252   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11253   ins_encode %{
11254     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11255                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11256                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11257   %}
11258   ins_pipe( pipe_slow );
11259 %}
11260 
11261 // fast array equals
11262 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11263                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11264 %{
11265   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11266   match(Set result (AryEq ary1 ary2));
11267   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11268 
11269   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11270   ins_encode %{
11271     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11272                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11273                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11274   %}
11275   ins_pipe( pipe_slow );
11276 %}
11277 
11278 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11279                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11280 %{
11281   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11282   match(Set result (AryEq ary1 ary2));
11283   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11284 
11285   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11286   ins_encode %{
11287     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11288                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11289                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11290   %}
11291   ins_pipe( pipe_slow );
11292 %}
11293 
11294 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11295                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11296 %{
11297   match(Set result (HasNegatives ary1 len));
11298   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11299 
11300   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11301   ins_encode %{
11302     __ has_negatives($ary1$$Register, $len$$Register,
11303                      $result$$Register, $tmp3$$Register,
11304                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11305   %}
11306   ins_pipe( pipe_slow );
11307 %}
11308 
11309 // fast char[] to byte[] compression
11310 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11311                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11312   match(Set result (StrCompressedCopy src (Binary dst len)));
11313   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11314 
11315   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11316   ins_encode %{
11317     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11318                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11319                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11320   %}
11321   ins_pipe( pipe_slow );
11322 %}
11323 
11324 // fast byte[] to char[] inflation
11325 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11326                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11327   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11328   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11329 
11330   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11331   ins_encode %{
11332     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11333                           $tmp1$$XMMRegister, $tmp2$$Register);
11334   %}
11335   ins_pipe( pipe_slow );
11336 %}
11337 
11338 // encode char[] to byte[] in ISO_8859_1
11339 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11340                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11341                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11342   match(Set result (EncodeISOArray src (Binary dst len)));
11343   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11344 
11345   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11346   ins_encode %{
11347     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11348                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11349                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11350   %}
11351   ins_pipe( pipe_slow );
11352 %}
11353 
11354 //----------Overflow Math Instructions-----------------------------------------
11355 
11356 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11357 %{
11358   match(Set cr (OverflowAddI op1 op2));
11359   effect(DEF cr, USE_KILL op1, USE op2);
11360 
11361   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11362 
11363   ins_encode %{
11364     __ addl($op1$$Register, $op2$$Register);
11365   %}
11366   ins_pipe(ialu_reg_reg);
11367 %}
11368 
11369 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11370 %{
11371   match(Set cr (OverflowAddI op1 op2));
11372   effect(DEF cr, USE_KILL op1, USE op2);
11373 
11374   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11375 
11376   ins_encode %{
11377     __ addl($op1$$Register, $op2$$constant);
11378   %}
11379   ins_pipe(ialu_reg_reg);
11380 %}
11381 
11382 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11383 %{
11384   match(Set cr (OverflowAddL op1 op2));
11385   effect(DEF cr, USE_KILL op1, USE op2);
11386 
11387   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11388   ins_encode %{
11389     __ addq($op1$$Register, $op2$$Register);
11390   %}
11391   ins_pipe(ialu_reg_reg);
11392 %}
11393 
11394 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11395 %{
11396   match(Set cr (OverflowAddL op1 op2));
11397   effect(DEF cr, USE_KILL op1, USE op2);
11398 
11399   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11400   ins_encode %{
11401     __ addq($op1$$Register, $op2$$constant);
11402   %}
11403   ins_pipe(ialu_reg_reg);
11404 %}
11405 
11406 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11407 %{
11408   match(Set cr (OverflowSubI op1 op2));
11409 
11410   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11411   ins_encode %{
11412     __ cmpl($op1$$Register, $op2$$Register);
11413   %}
11414   ins_pipe(ialu_reg_reg);
11415 %}
11416 
11417 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11418 %{
11419   match(Set cr (OverflowSubI op1 op2));
11420 
11421   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11422   ins_encode %{
11423     __ cmpl($op1$$Register, $op2$$constant);
11424   %}
11425   ins_pipe(ialu_reg_reg);
11426 %}
11427 
11428 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11429 %{
11430   match(Set cr (OverflowSubL op1 op2));
11431 
11432   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11433   ins_encode %{
11434     __ cmpq($op1$$Register, $op2$$Register);
11435   %}
11436   ins_pipe(ialu_reg_reg);
11437 %}
11438 
11439 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11440 %{
11441   match(Set cr (OverflowSubL op1 op2));
11442 
11443   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11444   ins_encode %{
11445     __ cmpq($op1$$Register, $op2$$constant);
11446   %}
11447   ins_pipe(ialu_reg_reg);
11448 %}
11449 
11450 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11451 %{
11452   match(Set cr (OverflowSubI zero op2));
11453   effect(DEF cr, USE_KILL op2);
11454 
11455   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11456   ins_encode %{
11457     __ negl($op2$$Register);
11458   %}
11459   ins_pipe(ialu_reg_reg);
11460 %}
11461 
11462 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11463 %{
11464   match(Set cr (OverflowSubL zero op2));
11465   effect(DEF cr, USE_KILL op2);
11466 
11467   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11468   ins_encode %{
11469     __ negq($op2$$Register);
11470   %}
11471   ins_pipe(ialu_reg_reg);
11472 %}
11473 
11474 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11475 %{
11476   match(Set cr (OverflowMulI op1 op2));
11477   effect(DEF cr, USE_KILL op1, USE op2);
11478 
11479   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11480   ins_encode %{
11481     __ imull($op1$$Register, $op2$$Register);
11482   %}
11483   ins_pipe(ialu_reg_reg_alu0);
11484 %}
11485 
11486 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11487 %{
11488   match(Set cr (OverflowMulI op1 op2));
11489   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11490 
11491   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11492   ins_encode %{
11493     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11494   %}
11495   ins_pipe(ialu_reg_reg_alu0);
11496 %}
11497 
11498 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11499 %{
11500   match(Set cr (OverflowMulL op1 op2));
11501   effect(DEF cr, USE_KILL op1, USE op2);
11502 
11503   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11504   ins_encode %{
11505     __ imulq($op1$$Register, $op2$$Register);
11506   %}
11507   ins_pipe(ialu_reg_reg_alu0);
11508 %}
11509 
11510 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11511 %{
11512   match(Set cr (OverflowMulL op1 op2));
11513   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11514 
11515   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11516   ins_encode %{
11517     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11518   %}
11519   ins_pipe(ialu_reg_reg_alu0);
11520 %}
11521 
11522 
11523 //----------Control Flow Instructions------------------------------------------
11524 // Signed compare Instructions
11525 
11526 // XXX more variants!!
11527 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11528 %{
11529   match(Set cr (CmpI op1 op2));
11530   effect(DEF cr, USE op1, USE op2);
11531 
11532   format %{ &quot;cmpl    $op1, $op2&quot; %}
11533   opcode(0x3B);  /* Opcode 3B /r */
11534   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11535   ins_pipe(ialu_cr_reg_reg);
11536 %}
11537 
11538 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11539 %{
11540   match(Set cr (CmpI op1 op2));
11541 
11542   format %{ &quot;cmpl    $op1, $op2&quot; %}
11543   opcode(0x81, 0x07); /* Opcode 81 /7 */
11544   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11545   ins_pipe(ialu_cr_reg_imm);
11546 %}
11547 
11548 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11549 %{
11550   match(Set cr (CmpI op1 (LoadI op2)));
11551 
11552   ins_cost(500); // XXX
11553   format %{ &quot;cmpl    $op1, $op2&quot; %}
11554   opcode(0x3B); /* Opcode 3B /r */
11555   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11556   ins_pipe(ialu_cr_reg_mem);
11557 %}
11558 
11559 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11560 %{
11561   match(Set cr (CmpI src zero));
11562 
11563   format %{ &quot;testl   $src, $src&quot; %}
11564   opcode(0x85);
11565   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11566   ins_pipe(ialu_cr_reg_imm);
11567 %}
11568 
11569 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11570 %{
11571   match(Set cr (CmpI (AndI src con) zero));
11572 
11573   format %{ &quot;testl   $src, $con&quot; %}
11574   opcode(0xF7, 0x00);
11575   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11576   ins_pipe(ialu_cr_reg_imm);
11577 %}
11578 
11579 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11580 %{
11581   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11582 
11583   format %{ &quot;testl   $src, $mem&quot; %}
11584   opcode(0x85);
11585   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11586   ins_pipe(ialu_cr_reg_mem);
11587 %}
11588 
11589 // Unsigned compare Instructions; really, same as signed except they
11590 // produce an rFlagsRegU instead of rFlagsReg.
11591 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11592 %{
11593   match(Set cr (CmpU op1 op2));
11594 
11595   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11596   opcode(0x3B); /* Opcode 3B /r */
11597   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11598   ins_pipe(ialu_cr_reg_reg);
11599 %}
11600 
11601 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11602 %{
11603   match(Set cr (CmpU op1 op2));
11604 
11605   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11606   opcode(0x81,0x07); /* Opcode 81 /7 */
11607   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11608   ins_pipe(ialu_cr_reg_imm);
11609 %}
11610 
11611 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11612 %{
11613   match(Set cr (CmpU op1 (LoadI op2)));
11614 
11615   ins_cost(500); // XXX
11616   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11617   opcode(0x3B); /* Opcode 3B /r */
11618   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11619   ins_pipe(ialu_cr_reg_mem);
11620 %}
11621 
11622 // // // Cisc-spilled version of cmpU_rReg
11623 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11624 // //%{
11625 // //  match(Set cr (CmpU (LoadI op1) op2));
11626 // //
11627 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11628 // //  ins_cost(500);
11629 // //  opcode(0x39);  /* Opcode 39 /r */
11630 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11631 // //%}
11632 
11633 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11634 %{
11635   match(Set cr (CmpU src zero));
11636 
11637   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11638   opcode(0x85);
11639   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11640   ins_pipe(ialu_cr_reg_imm);
11641 %}
11642 
11643 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11644 %{
11645   match(Set cr (CmpP op1 op2));
11646 
11647   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11648   opcode(0x3B); /* Opcode 3B /r */
11649   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11650   ins_pipe(ialu_cr_reg_reg);
11651 %}
11652 
11653 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11654 %{
11655   match(Set cr (CmpP op1 (LoadP op2)));
11656   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11657 
11658   ins_cost(500); // XXX
11659   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11660   opcode(0x3B); /* Opcode 3B /r */
11661   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11662   ins_pipe(ialu_cr_reg_mem);
11663 %}
11664 
11665 // // // Cisc-spilled version of cmpP_rReg
11666 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11667 // //%{
11668 // //  match(Set cr (CmpP (LoadP op1) op2));
11669 // //
11670 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11671 // //  ins_cost(500);
11672 // //  opcode(0x39);  /* Opcode 39 /r */
11673 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11674 // //%}
11675 
11676 // XXX this is generalized by compP_rReg_mem???
11677 // Compare raw pointer (used in out-of-heap check).
11678 // Only works because non-oop pointers must be raw pointers
11679 // and raw pointers have no anti-dependencies.
11680 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11681 %{
11682   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11683             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11684   match(Set cr (CmpP op1 (LoadP op2)));
11685 
11686   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11687   opcode(0x3B); /* Opcode 3B /r */
11688   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11689   ins_pipe(ialu_cr_reg_mem);
11690 %}
11691 
11692 // This will generate a signed flags result. This should be OK since
11693 // any compare to a zero should be eq/neq.
11694 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11695 %{
11696   match(Set cr (CmpP src zero));
11697 
11698   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11699   opcode(0x85);
11700   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11701   ins_pipe(ialu_cr_reg_imm);
11702 %}
11703 
11704 // This will generate a signed flags result. This should be OK since
11705 // any compare to a zero should be eq/neq.
11706 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11707 %{
11708   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11709             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11710   match(Set cr (CmpP (LoadP op) zero));
11711 
11712   ins_cost(500); // XXX
11713   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11714   opcode(0xF7); /* Opcode F7 /0 */
11715   ins_encode(REX_mem_wide(op),
11716              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11717   ins_pipe(ialu_cr_reg_imm);
11718 %}
11719 
11720 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11721 %{
11722   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11723             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11724   match(Set cr (CmpP (LoadP mem) zero));
11725 
11726   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11727   ins_encode %{
11728     __ cmpq(r12, $mem$$Address);
11729   %}
11730   ins_pipe(ialu_cr_reg_mem);
11731 %}
11732 
11733 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11734 %{
11735   match(Set cr (CmpN op1 op2));
11736 
11737   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11738   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11739   ins_pipe(ialu_cr_reg_reg);
11740 %}
11741 
11742 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11743 %{
11744   match(Set cr (CmpN src (LoadN mem)));
11745 
11746   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11747   ins_encode %{
11748     __ cmpl($src$$Register, $mem$$Address);
11749   %}
11750   ins_pipe(ialu_cr_reg_mem);
11751 %}
11752 
11753 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11754   match(Set cr (CmpN op1 op2));
11755 
11756   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11757   ins_encode %{
11758     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11759   %}
11760   ins_pipe(ialu_cr_reg_imm);
11761 %}
11762 
11763 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11764 %{
11765   match(Set cr (CmpN src (LoadN mem)));
11766 
11767   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11768   ins_encode %{
11769     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11770   %}
11771   ins_pipe(ialu_cr_reg_mem);
11772 %}
11773 
11774 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11775   match(Set cr (CmpN op1 op2));
11776 
11777   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11778   ins_encode %{
11779     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11780   %}
11781   ins_pipe(ialu_cr_reg_imm);
11782 %}
11783 
11784 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11785 %{
11786   match(Set cr (CmpN src (LoadNKlass mem)));
11787 
11788   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11789   ins_encode %{
11790     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11791   %}
11792   ins_pipe(ialu_cr_reg_mem);
11793 %}
11794 
11795 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11796   match(Set cr (CmpN src zero));
11797 
11798   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11799   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11800   ins_pipe(ialu_cr_reg_imm);
11801 %}
11802 
11803 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11804 %{
11805   predicate(CompressedOops::base() != NULL);
11806   match(Set cr (CmpN (LoadN mem) zero));
11807 
11808   ins_cost(500); // XXX
11809   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11810   ins_encode %{
11811     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11812   %}
11813   ins_pipe(ialu_cr_reg_mem);
11814 %}
11815 
11816 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11817 %{
11818   predicate(CompressedOops::base() == NULL);
11819   match(Set cr (CmpN (LoadN mem) zero));
11820 
11821   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11822   ins_encode %{
11823     __ cmpl(r12, $mem$$Address);
11824   %}
11825   ins_pipe(ialu_cr_reg_mem);
11826 %}
11827 
11828 // Yanked all unsigned pointer compare operations.
11829 // Pointer compares are done with CmpP which is already unsigned.
11830 
11831 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11832 %{
11833   match(Set cr (CmpL op1 op2));
11834 
11835   format %{ &quot;cmpq    $op1, $op2&quot; %}
11836   opcode(0x3B);  /* Opcode 3B /r */
11837   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11838   ins_pipe(ialu_cr_reg_reg);
11839 %}
11840 
11841 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11842 %{
11843   match(Set cr (CmpL op1 op2));
11844 
11845   format %{ &quot;cmpq    $op1, $op2&quot; %}
11846   opcode(0x81, 0x07); /* Opcode 81 /7 */
11847   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11848   ins_pipe(ialu_cr_reg_imm);
11849 %}
11850 
11851 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11852 %{
11853   match(Set cr (CmpL op1 (LoadL op2)));
11854 
11855   format %{ &quot;cmpq    $op1, $op2&quot; %}
11856   opcode(0x3B); /* Opcode 3B /r */
11857   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11858   ins_pipe(ialu_cr_reg_mem);
11859 %}
11860 
11861 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11862 %{
11863   match(Set cr (CmpL src zero));
11864 
11865   format %{ &quot;testq   $src, $src&quot; %}
11866   opcode(0x85);
11867   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11868   ins_pipe(ialu_cr_reg_imm);
11869 %}
11870 
11871 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11872 %{
11873   match(Set cr (CmpL (AndL src con) zero));
11874 
11875   format %{ &quot;testq   $src, $con\t# long&quot; %}
11876   opcode(0xF7, 0x00);
11877   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11878   ins_pipe(ialu_cr_reg_imm);
11879 %}
11880 
11881 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11882 %{
11883   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11884 
11885   format %{ &quot;testq   $src, $mem&quot; %}
11886   opcode(0x85);
11887   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11888   ins_pipe(ialu_cr_reg_mem);
11889 %}
11890 
11891 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11892 %{
11893   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11894 
11895   format %{ &quot;testq   $src, $mem&quot; %}
11896   opcode(0x85);
11897   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11898   ins_pipe(ialu_cr_reg_mem);
11899 %}
11900 
11901 // Manifest a CmpL result in an integer register.  Very painful.
11902 // This is the test to avoid.
11903 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11904 %{
11905   match(Set dst (CmpL3 src1 src2));
11906   effect(KILL flags);
11907 
11908   ins_cost(275); // XXX
11909   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11910             &quot;movl    $dst, -1\n\t&quot;
11911             &quot;jl,s    done\n\t&quot;
11912             &quot;setne   $dst\n\t&quot;
11913             &quot;movzbl  $dst, $dst\n\t&quot;
11914     &quot;done:&quot; %}
11915   ins_encode(cmpl3_flag(src1, src2, dst));
11916   ins_pipe(pipe_slow);
11917 %}
11918 
11919 // Unsigned long compare Instructions; really, same as signed long except they
11920 // produce an rFlagsRegU instead of rFlagsReg.
11921 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11922 %{
11923   match(Set cr (CmpUL op1 op2));
11924 
11925   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11926   opcode(0x3B);  /* Opcode 3B /r */
11927   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11928   ins_pipe(ialu_cr_reg_reg);
11929 %}
11930 
11931 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11932 %{
11933   match(Set cr (CmpUL op1 op2));
11934 
11935   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11936   opcode(0x81, 0x07); /* Opcode 81 /7 */
11937   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11938   ins_pipe(ialu_cr_reg_imm);
11939 %}
11940 
11941 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11942 %{
11943   match(Set cr (CmpUL op1 (LoadL op2)));
11944 
11945   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11946   opcode(0x3B); /* Opcode 3B /r */
11947   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11948   ins_pipe(ialu_cr_reg_mem);
11949 %}
11950 
11951 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11952 %{
11953   match(Set cr (CmpUL src zero));
11954 
11955   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
11956   opcode(0x85);
11957   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11958   ins_pipe(ialu_cr_reg_imm);
11959 %}
11960 
11961 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
11962 %{
11963   match(Set cr (CmpI (LoadB mem) imm));
11964 
11965   ins_cost(125);
11966   format %{ &quot;cmpb    $mem, $imm&quot; %}
11967   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
11968   ins_pipe(ialu_cr_reg_mem);
11969 %}
11970 
11971 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
11972 %{
11973   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
11974 
11975   ins_cost(125);
11976   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
11977   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11978   ins_pipe(ialu_cr_reg_mem);
11979 %}
11980 
11981 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
11982 %{
11983   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
11984 
11985   ins_cost(125);
11986   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
11987   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11988   ins_pipe(ialu_cr_reg_mem);
11989 %}
11990 
11991 //----------Max and Min--------------------------------------------------------
11992 // Min Instructions
11993 
11994 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11995 %{
11996   effect(USE_DEF dst, USE src, USE cr);
11997 
11998   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
11999   opcode(0x0F, 0x4F);
12000   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12001   ins_pipe(pipe_cmov_reg);
12002 %}
12003 
12004 
12005 instruct minI_rReg(rRegI dst, rRegI src)
12006 %{
12007   match(Set dst (MinI dst src));
12008 
12009   ins_cost(200);
12010   expand %{
12011     rFlagsReg cr;
12012     compI_rReg(cr, dst, src);
12013     cmovI_reg_g(dst, src, cr);
12014   %}
12015 %}
12016 
12017 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12018 %{
12019   effect(USE_DEF dst, USE src, USE cr);
12020 
12021   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12022   opcode(0x0F, 0x4C);
12023   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12024   ins_pipe(pipe_cmov_reg);
12025 %}
12026 
12027 
12028 instruct maxI_rReg(rRegI dst, rRegI src)
12029 %{
12030   match(Set dst (MaxI dst src));
12031 
12032   ins_cost(200);
12033   expand %{
12034     rFlagsReg cr;
12035     compI_rReg(cr, dst, src);
12036     cmovI_reg_l(dst, src, cr);
12037   %}
12038 %}
12039 
12040 // ============================================================================
12041 // Branch Instructions
12042 
12043 // Jump Direct - Label defines a relative address from JMP+1
12044 instruct jmpDir(label labl)
12045 %{
12046   match(Goto);
12047   effect(USE labl);
12048 
12049   ins_cost(300);
12050   format %{ &quot;jmp     $labl&quot; %}
12051   size(5);
12052   ins_encode %{
12053     Label* L = $labl$$label;
12054     __ jmp(*L, false); // Always long jump
12055   %}
12056   ins_pipe(pipe_jmp);
12057 %}
12058 
12059 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12060 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12061 %{
12062   match(If cop cr);
12063   effect(USE labl);
12064 
12065   ins_cost(300);
12066   format %{ &quot;j$cop     $labl&quot; %}
12067   size(6);
12068   ins_encode %{
12069     Label* L = $labl$$label;
12070     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12071   %}
12072   ins_pipe(pipe_jcc);
12073 %}
12074 
12075 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12076 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12077 %{
12078   predicate(!n-&gt;has_vector_mask_set());
12079   match(CountedLoopEnd cop cr);
12080   effect(USE labl);
12081 
12082   ins_cost(300);
12083   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12084   size(6);
12085   ins_encode %{
12086     Label* L = $labl$$label;
12087     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12088   %}
12089   ins_pipe(pipe_jcc);
12090 %}
12091 
12092 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12093 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12094   predicate(!n-&gt;has_vector_mask_set());
12095   match(CountedLoopEnd cop cmp);
12096   effect(USE labl);
12097 
12098   ins_cost(300);
12099   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12100   size(6);
12101   ins_encode %{
12102     Label* L = $labl$$label;
12103     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12104   %}
12105   ins_pipe(pipe_jcc);
12106 %}
12107 
12108 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12109   predicate(!n-&gt;has_vector_mask_set());
12110   match(CountedLoopEnd cop cmp);
12111   effect(USE labl);
12112 
12113   ins_cost(200);
12114   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12115   size(6);
12116   ins_encode %{
12117     Label* L = $labl$$label;
12118     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12119   %}
12120   ins_pipe(pipe_jcc);
12121 %}
12122 
12123 // mask version
12124 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12125 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12126 %{
12127   predicate(n-&gt;has_vector_mask_set());
12128   match(CountedLoopEnd cop cr);
12129   effect(USE labl);
12130 
12131   ins_cost(400);
12132   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12133             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12134   size(10);
12135   ins_encode %{
12136     Label* L = $labl$$label;
12137     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12138     __ restorevectmask();
12139   %}
12140   ins_pipe(pipe_jcc);
12141 %}
12142 
12143 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12144 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12145   predicate(n-&gt;has_vector_mask_set());
12146   match(CountedLoopEnd cop cmp);
12147   effect(USE labl);
12148 
12149   ins_cost(400);
12150   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12151             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12152   size(10);
12153   ins_encode %{
12154     Label* L = $labl$$label;
12155     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12156     __ restorevectmask();
12157   %}
12158   ins_pipe(pipe_jcc);
12159 %}
12160 
12161 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12162   predicate(n-&gt;has_vector_mask_set());
12163   match(CountedLoopEnd cop cmp);
12164   effect(USE labl);
12165 
12166   ins_cost(300);
12167   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12168             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12169   size(10);
12170   ins_encode %{
12171     Label* L = $labl$$label;
12172     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12173     __ restorevectmask();
12174   %}
12175   ins_pipe(pipe_jcc);
12176 %}
12177 
12178 // Jump Direct Conditional - using unsigned comparison
12179 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12180   match(If cop cmp);
12181   effect(USE labl);
12182 
12183   ins_cost(300);
12184   format %{ &quot;j$cop,u   $labl&quot; %}
12185   size(6);
12186   ins_encode %{
12187     Label* L = $labl$$label;
12188     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12189   %}
12190   ins_pipe(pipe_jcc);
12191 %}
12192 
12193 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12194   match(If cop cmp);
12195   effect(USE labl);
12196 
12197   ins_cost(200);
12198   format %{ &quot;j$cop,u   $labl&quot; %}
12199   size(6);
12200   ins_encode %{
12201     Label* L = $labl$$label;
12202     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12203   %}
12204   ins_pipe(pipe_jcc);
12205 %}
12206 
12207 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12208   match(If cop cmp);
12209   effect(USE labl);
12210 
12211   ins_cost(200);
12212   format %{ $$template
12213     if ($cop$$cmpcode == Assembler::notEqual) {
12214       $$emit$$&quot;jp,u    $labl\n\t&quot;
12215       $$emit$$&quot;j$cop,u   $labl&quot;
12216     } else {
12217       $$emit$$&quot;jp,u    done\n\t&quot;
12218       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12219       $$emit$$&quot;done:&quot;
12220     }
12221   %}
12222   ins_encode %{
12223     Label* l = $labl$$label;
12224     if ($cop$$cmpcode == Assembler::notEqual) {
12225       __ jcc(Assembler::parity, *l, false);
12226       __ jcc(Assembler::notEqual, *l, false);
12227     } else if ($cop$$cmpcode == Assembler::equal) {
12228       Label done;
12229       __ jccb(Assembler::parity, done);
12230       __ jcc(Assembler::equal, *l, false);
12231       __ bind(done);
12232     } else {
12233        ShouldNotReachHere();
12234     }
12235   %}
12236   ins_pipe(pipe_jcc);
12237 %}
12238 
12239 // ============================================================================
12240 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12241 // superklass array for an instance of the superklass.  Set a hidden
12242 // internal cache on a hit (cache is checked with exposed code in
12243 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12244 // encoding ALSO sets flags.
12245 
12246 instruct partialSubtypeCheck(rdi_RegP result,
12247                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12248                              rFlagsReg cr)
12249 %{
12250   match(Set result (PartialSubtypeCheck sub super));
12251   effect(KILL rcx, KILL cr);
12252 
12253   ins_cost(1100);  // slightly larger than the next version
12254   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12255             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12256             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12257             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12258             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12259             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12260             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12261     &quot;miss:\t&quot; %}
12262 
12263   opcode(0x1); // Force a XOR of RDI
12264   ins_encode(enc_PartialSubtypeCheck());
12265   ins_pipe(pipe_slow);
12266 %}
12267 
12268 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12269                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12270                                      immP0 zero,
12271                                      rdi_RegP result)
12272 %{
12273   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12274   effect(KILL rcx, KILL result);
12275 
12276   ins_cost(1000);
12277   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12278             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12279             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12280             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12281             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12282             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12283     &quot;miss:\t&quot; %}
12284 
12285   opcode(0x0); // No need to XOR RDI
12286   ins_encode(enc_PartialSubtypeCheck());
12287   ins_pipe(pipe_slow);
12288 %}
12289 
12290 // ============================================================================
12291 // Branch Instructions -- short offset versions
12292 //
12293 // These instructions are used to replace jumps of a long offset (the default
12294 // match) with jumps of a shorter offset.  These instructions are all tagged
12295 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12296 // match rules in general matching.  Instead, the ADLC generates a conversion
12297 // method in the MachNode which can be used to do in-place replacement of the
12298 // long variant with the shorter variant.  The compiler will determine if a
12299 // branch can be taken by the is_short_branch_offset() predicate in the machine
12300 // specific code section of the file.
12301 
12302 // Jump Direct - Label defines a relative address from JMP+1
12303 instruct jmpDir_short(label labl) %{
12304   match(Goto);
12305   effect(USE labl);
12306 
12307   ins_cost(300);
12308   format %{ &quot;jmp,s   $labl&quot; %}
12309   size(2);
12310   ins_encode %{
12311     Label* L = $labl$$label;
12312     __ jmpb(*L);
12313   %}
12314   ins_pipe(pipe_jmp);
12315   ins_short_branch(1);
12316 %}
12317 
12318 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12319 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12320   match(If cop cr);
12321   effect(USE labl);
12322 
12323   ins_cost(300);
12324   format %{ &quot;j$cop,s   $labl&quot; %}
12325   size(2);
12326   ins_encode %{
12327     Label* L = $labl$$label;
12328     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12329   %}
12330   ins_pipe(pipe_jcc);
12331   ins_short_branch(1);
12332 %}
12333 
12334 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12335 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12336   match(CountedLoopEnd cop cr);
12337   effect(USE labl);
12338 
12339   ins_cost(300);
12340   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12341   size(2);
12342   ins_encode %{
12343     Label* L = $labl$$label;
12344     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12345   %}
12346   ins_pipe(pipe_jcc);
12347   ins_short_branch(1);
12348 %}
12349 
12350 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12351 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12352   match(CountedLoopEnd cop cmp);
12353   effect(USE labl);
12354 
12355   ins_cost(300);
12356   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12357   size(2);
12358   ins_encode %{
12359     Label* L = $labl$$label;
12360     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12361   %}
12362   ins_pipe(pipe_jcc);
12363   ins_short_branch(1);
12364 %}
12365 
12366 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12367   match(CountedLoopEnd cop cmp);
12368   effect(USE labl);
12369 
12370   ins_cost(300);
12371   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12372   size(2);
12373   ins_encode %{
12374     Label* L = $labl$$label;
12375     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12376   %}
12377   ins_pipe(pipe_jcc);
12378   ins_short_branch(1);
12379 %}
12380 
12381 // Jump Direct Conditional - using unsigned comparison
12382 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12383   match(If cop cmp);
12384   effect(USE labl);
12385 
12386   ins_cost(300);
12387   format %{ &quot;j$cop,us  $labl&quot; %}
12388   size(2);
12389   ins_encode %{
12390     Label* L = $labl$$label;
12391     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12392   %}
12393   ins_pipe(pipe_jcc);
12394   ins_short_branch(1);
12395 %}
12396 
12397 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12398   match(If cop cmp);
12399   effect(USE labl);
12400 
12401   ins_cost(300);
12402   format %{ &quot;j$cop,us  $labl&quot; %}
12403   size(2);
12404   ins_encode %{
12405     Label* L = $labl$$label;
12406     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12407   %}
12408   ins_pipe(pipe_jcc);
12409   ins_short_branch(1);
12410 %}
12411 
12412 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12413   match(If cop cmp);
12414   effect(USE labl);
12415 
12416   ins_cost(300);
12417   format %{ $$template
12418     if ($cop$$cmpcode == Assembler::notEqual) {
12419       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12420       $$emit$$&quot;j$cop,u,s  $labl&quot;
12421     } else {
12422       $$emit$$&quot;jp,u,s  done\n\t&quot;
12423       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12424       $$emit$$&quot;done:&quot;
12425     }
12426   %}
12427   size(4);
12428   ins_encode %{
12429     Label* l = $labl$$label;
12430     if ($cop$$cmpcode == Assembler::notEqual) {
12431       __ jccb(Assembler::parity, *l);
12432       __ jccb(Assembler::notEqual, *l);
12433     } else if ($cop$$cmpcode == Assembler::equal) {
12434       Label done;
12435       __ jccb(Assembler::parity, done);
12436       __ jccb(Assembler::equal, *l);
12437       __ bind(done);
12438     } else {
12439        ShouldNotReachHere();
12440     }
12441   %}
12442   ins_pipe(pipe_jcc);
12443   ins_short_branch(1);
12444 %}
12445 
12446 // ============================================================================
12447 // inlined locking and unlocking
12448 
12449 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12450   predicate(Compile::current()-&gt;use_rtm());
12451   match(Set cr (FastLock object box));
12452   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12453   ins_cost(300);
12454   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12455   ins_encode %{
12456     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12457                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12458                  _counters, _rtm_counters, _stack_rtm_counters,
12459                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12460                  true, ra_-&gt;C-&gt;profile_rtm());
12461   %}
12462   ins_pipe(pipe_slow);
12463 %}
12464 
12465 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{
12466   predicate(!Compile::current()-&gt;use_rtm());
12467   match(Set cr (FastLock object box));
12468   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);
12469   ins_cost(300);
12470   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12471   ins_encode %{
12472     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12473                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);
12474   %}
12475   ins_pipe(pipe_slow);
12476 %}
12477 
12478 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12479   match(Set cr (FastUnlock object box));
12480   effect(TEMP tmp, USE_KILL box);
12481   ins_cost(300);
12482   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12483   ins_encode %{
12484     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12485   %}
12486   ins_pipe(pipe_slow);
12487 %}
12488 
12489 
12490 // ============================================================================
12491 // Safepoint Instructions
12492 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12493 %{
12494   match(SafePoint poll);
12495   effect(KILL cr, USE poll);
12496 
12497   format %{ &quot;testl   rax, [$poll]\t&quot;
12498             &quot;# Safepoint: poll for GC&quot; %}
12499   ins_cost(125);
12500   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12501   ins_encode %{
12502     __ relocate(relocInfo::poll_type);
12503     address pre_pc = __ pc();
12504     __ testl(rax, Address($poll$$Register, 0));
12505     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12506   %}
12507   ins_pipe(ialu_reg_mem);
12508 %}
12509 
12510 // ============================================================================
12511 // Procedure Call/Return Instructions
12512 // Call Java Static Instruction
12513 // Note: If this code changes, the corresponding ret_addr_offset() and
12514 //       compute_padding() functions will have to be adjusted.
12515 instruct CallStaticJavaDirect(method meth) %{
12516   match(CallStaticJava);
12517   effect(USE meth);
12518 
12519   ins_cost(300);
12520   format %{ &quot;call,static &quot; %}
12521   opcode(0xE8); /* E8 cd */
12522   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12523   ins_pipe(pipe_slow);
12524   ins_alignment(4);
12525 %}
12526 
12527 // Call Java Dynamic Instruction
12528 // Note: If this code changes, the corresponding ret_addr_offset() and
12529 //       compute_padding() functions will have to be adjusted.
12530 instruct CallDynamicJavaDirect(method meth)
12531 %{
12532   match(CallDynamicJava);
12533   effect(USE meth);
12534 
12535   ins_cost(300);
12536   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12537             &quot;call,dynamic &quot; %}
12538   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12539   ins_pipe(pipe_slow);
12540   ins_alignment(4);
12541 %}
12542 
12543 // Call Runtime Instruction
12544 instruct CallRuntimeDirect(method meth)
12545 %{
12546   match(CallRuntime);
12547   effect(USE meth);
12548 
12549   ins_cost(300);
12550   format %{ &quot;call,runtime &quot; %}
12551   ins_encode(clear_avx, Java_To_Runtime(meth));
12552   ins_pipe(pipe_slow);
12553 %}
12554 
12555 // Call runtime without safepoint
12556 instruct CallLeafDirect(method meth)
12557 %{
12558   match(CallLeaf);
12559   effect(USE meth);
12560 
12561   ins_cost(300);
12562   format %{ &quot;call_leaf,runtime &quot; %}
12563   ins_encode(clear_avx, Java_To_Runtime(meth));
12564   ins_pipe(pipe_slow);
12565 %}
12566 
12567 //
12568 instruct CallNativeDirect(method meth)
12569 %{
12570   match(CallNative);
12571   effect(USE meth);
12572 
12573   ins_cost(300);
12574   format %{ &quot;call_native &quot; %}
12575   ins_encode %{
12576     __ call(RuntimeAddress((address) $meth$$method));
12577   %}
12578   ins_pipe(pipe_slow);
12579 %}
12580 
12581 // Call runtime without safepoint
12582 instruct CallLeafNoFPDirect(method meth)
12583 %{
12584   match(CallLeafNoFP);
12585   effect(USE meth);
12586 
12587   ins_cost(300);
12588   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12589   ins_encode(clear_avx, Java_To_Runtime(meth));
12590   ins_pipe(pipe_slow);
12591 %}
12592 
12593 // Return Instruction
12594 // Remove the return address &amp; jump to it.
12595 // Notice: We always emit a nop after a ret to make sure there is room
12596 // for safepoint patching
12597 instruct Ret()
12598 %{
12599   match(Return);
12600 
12601   format %{ &quot;ret&quot; %}
12602   opcode(0xC3);
12603   ins_encode(OpcP);
12604   ins_pipe(pipe_jmp);
12605 %}
12606 
12607 // Tail Call; Jump from runtime stub to Java code.
12608 // Also known as an &#39;interprocedural jump&#39;.
12609 // Target of jump will eventually return to caller.
12610 // TailJump below removes the return address.
12611 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12612 %{
12613   match(TailCall jump_target method_oop);
12614 
12615   ins_cost(300);
12616   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12617   opcode(0xFF, 0x4); /* Opcode FF /4 */
12618   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12619   ins_pipe(pipe_jmp);
12620 %}
12621 
12622 // Tail Jump; remove the return address; jump to target.
12623 // TailCall above leaves the return address around.
12624 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12625 %{
12626   match(TailJump jump_target ex_oop);
12627 
12628   ins_cost(300);
12629   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12630             &quot;jmp     $jump_target&quot; %}
12631   opcode(0xFF, 0x4); /* Opcode FF /4 */
12632   ins_encode(Opcode(0x5a), // popq rdx
12633              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12634   ins_pipe(pipe_jmp);
12635 %}
12636 
12637 // Create exception oop: created by stack-crawling runtime code.
12638 // Created exception is now available to this handler, and is setup
12639 // just prior to jumping to this handler.  No code emitted.
12640 instruct CreateException(rax_RegP ex_oop)
12641 %{
12642   match(Set ex_oop (CreateEx));
12643 
12644   size(0);
12645   // use the following format syntax
12646   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12647   ins_encode();
12648   ins_pipe(empty);
12649 %}
12650 
12651 // Rethrow exception:
12652 // The exception oop will come in the first argument position.
12653 // Then JUMP (not call) to the rethrow stub code.
12654 instruct RethrowException()
12655 %{
12656   match(Rethrow);
12657 
12658   // use the following format syntax
12659   format %{ &quot;jmp     rethrow_stub&quot; %}
12660   ins_encode(enc_rethrow);
12661   ins_pipe(pipe_jmp);
12662 %}
12663 
12664 // ============================================================================
12665 // This name is KNOWN by the ADLC and cannot be changed.
12666 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12667 // for this guy.
12668 instruct tlsLoadP(r15_RegP dst) %{
12669   match(Set dst (ThreadLocal));
12670   effect(DEF dst);
12671 
12672   size(0);
12673   format %{ &quot;# TLS is in R15&quot; %}
12674   ins_encode( /*empty encoding*/ );
12675   ins_pipe(ialu_reg_reg);
12676 %}
12677 
12678 
12679 //----------PEEPHOLE RULES-----------------------------------------------------
12680 // These must follow all instruction definitions as they use the names
12681 // defined in the instructions definitions.
12682 //
12683 // peepmatch ( root_instr_name [preceding_instruction]* );
12684 //
12685 // peepconstraint %{
12686 // (instruction_number.operand_name relational_op instruction_number.operand_name
12687 //  [, ...] );
12688 // // instruction numbers are zero-based using left to right order in peepmatch
12689 //
12690 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12691 // // provide an instruction_number.operand_name for each operand that appears
12692 // // in the replacement instruction&#39;s match rule
12693 //
12694 // ---------VM FLAGS---------------------------------------------------------
12695 //
12696 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12697 //
12698 // Each peephole rule is given an identifying number starting with zero and
12699 // increasing by one in the order seen by the parser.  An individual peephole
12700 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12701 // on the command-line.
12702 //
12703 // ---------CURRENT LIMITATIONS----------------------------------------------
12704 //
12705 // Only match adjacent instructions in same basic block
12706 // Only equality constraints
12707 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12708 // Only one replacement instruction
12709 //
12710 // ---------EXAMPLE----------------------------------------------------------
12711 //
12712 // // pertinent parts of existing instructions in architecture description
12713 // instruct movI(rRegI dst, rRegI src)
12714 // %{
12715 //   match(Set dst (CopyI src));
12716 // %}
12717 //
12718 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12719 // %{
12720 //   match(Set dst (AddI dst src));
12721 //   effect(KILL cr);
12722 // %}
12723 //
12724 // // Change (inc mov) to lea
12725 // peephole %{
12726 //   // increment preceeded by register-register move
12727 //   peepmatch ( incI_rReg movI );
12728 //   // require that the destination register of the increment
12729 //   // match the destination register of the move
12730 //   peepconstraint ( 0.dst == 1.dst );
12731 //   // construct a replacement instruction that sets
12732 //   // the destination to ( move&#39;s source register + one )
12733 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12734 // %}
12735 //
12736 
12737 // Implementation no longer uses movX instructions since
12738 // machine-independent system no longer uses CopyX nodes.
12739 //
12740 // peephole
12741 // %{
12742 //   peepmatch (incI_rReg movI);
12743 //   peepconstraint (0.dst == 1.dst);
12744 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12745 // %}
12746 
12747 // peephole
12748 // %{
12749 //   peepmatch (decI_rReg movI);
12750 //   peepconstraint (0.dst == 1.dst);
12751 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12752 // %}
12753 
12754 // peephole
12755 // %{
12756 //   peepmatch (addI_rReg_imm movI);
12757 //   peepconstraint (0.dst == 1.dst);
12758 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12759 // %}
12760 
12761 // peephole
12762 // %{
12763 //   peepmatch (incL_rReg movL);
12764 //   peepconstraint (0.dst == 1.dst);
12765 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12766 // %}
12767 
12768 // peephole
12769 // %{
12770 //   peepmatch (decL_rReg movL);
12771 //   peepconstraint (0.dst == 1.dst);
12772 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12773 // %}
12774 
12775 // peephole
12776 // %{
12777 //   peepmatch (addL_rReg_imm movL);
12778 //   peepconstraint (0.dst == 1.dst);
12779 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12780 // %}
12781 
12782 // peephole
12783 // %{
12784 //   peepmatch (addP_rReg_imm movP);
12785 //   peepconstraint (0.dst == 1.dst);
12786 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12787 // %}
12788 
12789 // // Change load of spilled value to only a spill
12790 // instruct storeI(memory mem, rRegI src)
12791 // %{
12792 //   match(Set mem (StoreI mem src));
12793 // %}
12794 //
12795 // instruct loadI(rRegI dst, memory mem)
12796 // %{
12797 //   match(Set dst (LoadI mem));
12798 // %}
12799 //
12800 
12801 peephole
12802 %{
12803   peepmatch (loadI storeI);
12804   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12805   peepreplace (storeI(1.mem 1.mem 1.src));
12806 %}
12807 
12808 peephole
12809 %{
12810   peepmatch (loadL storeL);
12811   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12812   peepreplace (storeL(1.mem 1.mem 1.src));
12813 %}
12814 
12815 //----------SMARTSPILL RULES---------------------------------------------------
12816 // These must follow all instruction definitions as they use the names
12817 // defined in the instructions definitions.
    </pre>
  </body>
</html>
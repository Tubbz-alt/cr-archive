<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package jdk.incubator.jextract.tool;
 26 
 27 import jdk.incubator.jextract.Declaration;
 28 import jdk.incubator.foreign.FunctionDescriptor;
 29 import jdk.incubator.foreign.GroupLayout;
 30 import jdk.incubator.foreign.MemoryAddress;
 31 import jdk.incubator.foreign.MemoryLayout;
<a name="1" id="anc1"></a><span class="line-removed"> 32 import jdk.incubator.foreign.MemoryLayouts;</span>
 33 import jdk.incubator.foreign.MemorySegment;
 34 import jdk.incubator.foreign.SequenceLayout;
 35 import jdk.incubator.foreign.SystemABI;
 36 import jdk.incubator.foreign.ValueLayout;
 37 import jdk.internal.foreign.InternalForeign;
 38 
 39 import java.lang.invoke.MethodType;
<a name="2" id="anc2"></a><span class="line-removed"> 40 import java.lang.reflect.Field;</span>
 41 import java.util.ArrayList;
 42 import java.util.List;
 43 import java.util.stream.Collectors;
<a name="3" id="anc3"></a><span class="line-removed"> 44 import java.util.stream.IntStream;</span>
 45 import java.util.stream.Stream;
 46 import javax.lang.model.SourceVersion;
 47 
 48 import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
 49 
 50 /**
 51  * A helper class to generate header interface class in source form.
 52  * After aggregating various constituents of a .java source, build
 53  * method is called to get overall generated source string.
 54  */
 55 class JavaSourceBuilder {
 56     private static final String ABI = InternalForeign.getInstancePrivileged().getSystemABI().name();
 57     // buffer
 58     protected StringBuffer sb;
 59     // current line alignment (number of 4-spaces)
 60     protected int align;
 61 
 62     JavaSourceBuilder(int align) {
 63         this.align = align;
 64         this.sb = new StringBuffer();
 65     }
 66 
 67     JavaSourceBuilder() {
 68         this(0);
 69     }
 70 
 71     protected int align() {
 72         return align;
 73     }
 74 
 75     final String PUB_CLS_MODS = &quot;public final &quot;;
 76     final String PUB_MODS = &quot;public static final &quot;;
 77     final String PRI_MODS = &quot;private static final &quot;;
 78 
 79     protected void addPackagePrefix(String pkgName) {
 80         assert pkgName.indexOf(&#39;/&#39;) == -1 : &quot;package name invalid: &quot; + pkgName;
 81         sb.append(&quot;// Generated by jextract\n\n&quot;);
 82         if (!pkgName.isEmpty()) {
 83             sb.append(&quot;package &quot;);
 84             sb.append(pkgName);
 85             sb.append(&quot;;\n\n&quot;);
 86         }
 87         addImportSection();
 88     }
 89 
 90     protected void addImportSection() {
 91         sb.append(&quot;import java.lang.invoke.MethodHandle;\n&quot;);
 92         sb.append(&quot;import java.lang.invoke.VarHandle;\n&quot;);
 93         sb.append(&quot;import jdk.incubator.foreign.*;\n&quot;);
 94         sb.append(&quot;import jdk.incubator.foreign.MemoryLayout.PathElement;\n&quot;);
 95         sb.append(&quot;import static &quot;);
 96         sb.append(HandleSourceFactory.C_LANG_CONSTANTS_HOLDER);
 97         sb.append(&quot;.*;\n&quot;);
 98     }
 99 
100     protected void classBegin(String name) {
101         indent();
102         sb.append(PUB_CLS_MODS + &quot;class &quot;);
103         sb.append(name);
104         sb.append(&quot; {\n\n&quot;);
105     }
106 
107     protected void classEnd() {
108         indent();
109         sb.append(&quot;}\n\n&quot;);
110     }
111 
112     protected void addLibraries(String[] libraryNames) {
113         incrAlign();
114         indent();
115         sb.append(PRI_MODS + &quot;LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(&quot;);
116         sb.append(stringArray(libraryNames) + &quot;);\n&quot;);
117         decrAlign();
118     }
119 
120     private String stringArray(String[] elements) {
121         return Stream.of(elements)
122                 .map(n -&gt; &quot;\&quot;&quot; + n + &quot;\&quot;&quot;)
123                 .collect(Collectors.joining(&quot;,&quot;, &quot;new String[] {&quot;, &quot;}&quot;));
124     }
125 
126     protected void addLayout(String elementName, MemoryLayout layout) {
127         incrAlign();
128         indent();
129         sb.append(PUB_MODS + &quot;MemoryLayout &quot; + javaSafeIdentifier(elementName) + &quot;$LAYOUT = &quot;);
130         addLayout(layout);
131         sb.append(&quot;;\n&quot;);
132         decrAlign();
133     }
134 
135     private void addLayout(MemoryLayout l) {
136         if (l instanceof ValueLayout) {
137             SystemABI.Type type = l.attribute(NATIVE_TYPE)
138                                    .map(SystemABI.Type.class::cast)
139                                    .orElseThrow(()-&gt;new AssertionError(&quot;Should not get here: &quot; + l));
<a name="4" id="anc4"></a><span class="line-modified">140             sb.append(switch (type) {</span>
<span class="line-removed">141                 case BOOL -&gt; &quot;C_BOOL&quot;;</span>
<span class="line-removed">142                 case SIGNED_CHAR -&gt; &quot;C_SCHAR&quot;;</span>
<span class="line-removed">143                 case UNSIGNED_CHAR -&gt; &quot;C_UCHAR&quot;;</span>
<span class="line-removed">144                 case CHAR -&gt; &quot;C_CHAR&quot;;</span>
<span class="line-removed">145                 case SHORT -&gt; &quot;C_SHORT&quot;;</span>
<span class="line-removed">146                 case UNSIGNED_SHORT -&gt; &quot;C_USHORT&quot;;</span>
<span class="line-removed">147                 case INT -&gt; &quot;C_INT&quot;;</span>
<span class="line-removed">148                 case UNSIGNED_INT -&gt; &quot;C_UINT&quot;;</span>
<span class="line-removed">149                 case LONG -&gt; &quot;C_LONG&quot;;</span>
<span class="line-removed">150                 case UNSIGNED_LONG -&gt; &quot;C_ULONG&quot;;</span>
<span class="line-removed">151                 case LONG_LONG -&gt; &quot;C_LONGLONG&quot;;</span>
<span class="line-removed">152                 case UNSIGNED_LONG_LONG -&gt; &quot;C_ULONGLONG&quot;;</span>
<span class="line-removed">153                 case FLOAT -&gt; &quot;C_FLOAT&quot;;</span>
<span class="line-removed">154                 case DOUBLE -&gt; &quot;C_DOUBLE&quot;;</span>
<span class="line-removed">155                 case LONG_DOUBLE -&gt; &quot;C_LONGDOUBLE&quot;;</span>
<span class="line-removed">156                 case POINTER -&gt; &quot;C_POINTER&quot;;</span>
<span class="line-removed">157                 default -&gt; { throw new RuntimeException(&quot;should not reach here: &quot; + type); }</span>
<span class="line-removed">158             });</span>
159         } else if (l instanceof SequenceLayout) {
160             sb.append(&quot;MemoryLayout.ofSequence(&quot;);
161             if (((SequenceLayout) l).elementCount().isPresent()) {
162                 sb.append(((SequenceLayout) l).elementCount().getAsLong() + &quot;, &quot;);
163             }
164             addLayout(((SequenceLayout) l).elementLayout());
165             sb.append(&quot;)&quot;);
166         } else if (l instanceof GroupLayout) {
167             SystemABI.Type type = l.attribute(NATIVE_TYPE)
168                                    .map(SystemABI.Type.class::cast)
169                                    .orElse(null);
170             if (type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
171                 if (!ABI.equals(SystemABI.ABI_SYSV)) {
172                     throw new RuntimeException(&quot;complex long double is supported only for SysV ABI&quot;);
173                 } else {
174                     sb.append(&quot;C_COMPLEX_LONGDOUBLE&quot;);
175                 }
176             } else {
177                 if (((GroupLayout) l).isStruct()) {
178                     sb.append(&quot;MemoryLayout.ofStruct(\n&quot;);
179                 } else {
180                     sb.append(&quot;MemoryLayout.ofUnion(\n&quot;);
181                 }
182                 incrAlign();
183                 String delim = &quot;&quot;;
184                 for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
185                     sb.append(delim);
186                     indent();
187                     addLayout(e);
188                     delim = &quot;,\n&quot;;
189                 }
190                 sb.append(&quot;\n&quot;);
191                 decrAlign();
192                 indent();
193                 sb.append(&quot;)&quot;);
194             }
195         } else {
196             //padding
197             sb.append(&quot;MemoryLayout.ofPaddingBits(&quot; + l.bitSize() + &quot;)&quot;);
198         }
199         if (l.name().isPresent()) {
200             sb.append(&quot;.withName(\&quot;&quot; +  l.name().get() + &quot;\&quot;)&quot;);
201         }
202     }
203 
204     protected void addVarHandle(String name, Class&lt;?&gt; type, String parentName) {
205         incrAlign();
206         indent();
207         parentName = parentName != null? javaSafeIdentifier(parentName) : parentName;
208         name = javaSafeIdentifier(name);
209         String vhName = parentName != null ?
210                 parentName + &quot;$&quot; + name : name;
211         sb.append(PUB_MODS + &quot;VarHandle &quot; + vhName + &quot; = &quot;);
212         if (parentName != null) {
213             addHandlePath(type, parentName, name);
214         } else {
215             addHandlePath(type, name);
216         }
217         sb.append(&quot;;\n&quot;);
218         decrAlign();
219     }
220 
221     protected void addHandlePath(Class&lt;?&gt; type, String strName, String fieldName) {
222         String ty = type.getName();
223         if (ty.contains(&quot;MemoryAddress&quot;)) {
224             ty = &quot;long&quot;;
225         }
226         sb.append(strName + &quot;$LAYOUT.varHandle(&quot; + ty + &quot;.class, &quot;);
227         sb.append(&quot;PathElement.groupElement(\&quot;&quot; + fieldName +&quot;\&quot;)&quot;);
228         sb.append(&quot;)&quot;);
229     }
230 
231     protected void addHandlePath(Class&lt;?&gt; type, String varName) {
232         String ty = type.getName();
233         if (ty.contains(&quot;MemoryAddress&quot;)) {
234             ty = &quot;long&quot;;
235         }
236         sb.append(varName + &quot;$LAYOUT.varHandle(&quot; + ty + &quot;.class)&quot;);
237     }
238 
239     protected void addMethodHandle(Declaration.Function funcTree, MethodType mtype, FunctionDescriptor desc) {
240         incrAlign();
241         indent();
242         sb.append(PUB_MODS + &quot;MethodHandle &quot; + javaSafeIdentifier(funcTree.name()) + &quot; = &quot;);
243         sb.append(&quot;RuntimeHelper.downcallHandle(\n&quot;);
244         incrAlign();
245         indent();
246         sb.append(&quot;LIBRARIES, \&quot;&quot; + funcTree.name() + &quot;\&quot;&quot;);
247         sb.append(&quot;,\n&quot;);
248         indent();
249         sb.append(&quot;\&quot;&quot; + mtype.toMethodDescriptorString() + &quot;\&quot;,\n&quot;);
250         indent();
251         addFunction(desc);
252         sb.append(&quot;,\n&quot;);
253         indent();
254         sb.append(funcTree.type().varargs());
255         decrAlign();
256         sb.append(&quot;\n&quot;);
257         indent();
258         sb.append(&quot;);\n&quot;);
259         decrAlign();
260     }
261 
262     protected void addAddressLookup(String name) {
263         sb.append(&quot;RuntimeHelper.lookupGlobalVariable(LIBRARIES, \&quot;&quot; + name + &quot;\&quot;)&quot;);
264     }
265 
266     private void addFunction(FunctionDescriptor f) {
267         final boolean noArgs = f.argumentLayouts().isEmpty();
268         if (f.returnLayout().isPresent()) {
269             sb.append(&quot;FunctionDescriptor.of(&quot;);
270             addLayout(f.returnLayout().get());
271             if (!noArgs) {
272                 sb.append(&quot;, &quot;);
273             }
274         } else {
275             sb.append(&quot;FunctionDescriptor.ofVoid(&quot;);
276         }
277         if (!noArgs) {
278             sb.append(&quot;\n&quot;);
279             incrAlign();
280             String delim = &quot;&quot;;
281             for (MemoryLayout e : f.argumentLayouts()) {
282                 sb.append(delim);
283                 indent();
284                 addLayout(e);
285                 delim = &quot;,\n&quot;;
286             }
287             sb.append(&quot;\n&quot;);
288             decrAlign();
289             indent();
290         }
291         sb.append(&quot;)&quot;);
292     }
293 
294     protected void addAddress(String name) {
295         incrAlign();
296         indent();
297         sb.append(PUB_MODS + &quot;MemoryAddress &quot; + javaSafeIdentifier(name) + &quot;$ADDR&quot; + &quot; = &quot;);
298         addAddressLookup(name);
299         sb.append(&quot;;\n&quot;);
300         decrAlign();
301     }
302 
303     protected void addConstant(String name, Class&lt;?&gt; type, Object value) {
304         incrAlign();
305         indent();
306         if (type == MemoryAddress.class || type == MemorySegment.class) {
307             //todo, skip for now (address constants and string constants)
308         } else {
309             sb.append(PUB_MODS + type.getName() + &quot; &quot; + javaSafeIdentifier(name));
310             sb.append(&quot; = &quot;);
311             if (type == float.class) {
312                 float f = ((Number)value).floatValue();
313                 if (Float.isNaN(f)) {
314                     sb.append(&quot;Float.NaN&quot;);
315                 } else if (Float.isInfinite(f)) {
316                     sb.append(f &gt; 0? &quot;Float.POSITIVE_INFINITY&quot; : &quot;Float.NEGATIVE_INFINITY&quot;);
317                 } else {
318                     sb.append(value);
319                     sb.append(&quot;f&quot;);
320                 }
321             } else if (type == long.class) {
322                 sb.append(value);
323                 sb.append(&quot;L&quot;);
324             } else if (type == double.class) {
325                 double d = ((Number)value).doubleValue();
326                 if (Double.isNaN(d)) {
327                     sb.append(&quot;Double.NaN&quot;);
328                 } else if (Double.isInfinite(d)) {
329                     sb.append(d &gt; 0? &quot;Double.POSITIVE_INFINITY&quot; : &quot;Double.NEGATIVE_INFINITY&quot;);
330                 } else {
331                    sb.append(value);
332                    sb.append(&quot;d&quot;);
333                 }
334             } else {
335                 sb.append(&quot;(&quot; + type.getName() + &quot;)&quot;);
336                 sb.append(value + &quot;L&quot;);
337             }
338             sb.append(&quot;;\n&quot;);
339         }
340 
341         decrAlign();
342     }
343 
344     static int funcIntfCounter = 0;
345 
346     protected void addUpcallFactory(FunctionDescriptor desc) {
347         String fnName = &quot;FI&quot; + funcIntfCounter++;
348         incrAlign();
349         indent();
350         sb.append(PRI_MODS + &quot;FunctionDescriptor &quot; + fnName + &quot;$DESC = &quot;);
351         addFunction(desc);
352         sb.append(&quot;;\n&quot;);
353         indent();
354         sb.append(PUB_MODS + &quot;MemoryAddress &quot; + fnName + &quot;$make(MethodHandle handle) {\n&quot;);
355         incrAlign();
356         indent();
357         sb.append(&quot;return RuntimeHelper.upcallStub(handle, &quot; + fnName + &quot;$DESC);\n&quot;);
358         decrAlign();
359         indent();
360         sb.append(&quot;}\n&quot;);
361         decrAlign();
362     }
363 
364     protected void addStaticFunctionWrapper(Declaration.Function f, MethodType mtype) {
365         incrAlign();
366         indent();
367         sb.append(PUB_MODS + mtype.returnType().getName() + &quot; &quot; + javaSafeIdentifier(f.name()) + &quot; (&quot;);
368         String delim = &quot;&quot;;
369         List&lt;String&gt; pNames = new ArrayList&lt;&gt;();
370         final int numParams = f.parameters().size();
371         for (int i = 0 ; i &lt; numParams; i++) {
372             String pName = f.parameters().get(i).name();
373             if (pName.isEmpty()) {
374                 pName = &quot;x&quot; + i;
375             }
376             pName = javaSafeIdentifier(pName);
377             pNames.add(pName);
378             sb.append(delim + mtype.parameterType(i).getName() + &quot; &quot; + pName);
379             delim = &quot;, &quot;;
380         }
381         if (f.type().varargs()) {
382             String lastArg = &quot;x&quot; + numParams;
383             if (numParams &gt; 0) {
384                 sb.append(&quot;, &quot;);
385             }
386             sb.append(&quot;Object... &quot; + lastArg);
387             pNames.add(lastArg);
388         }
389         sb.append(&quot;) {\n&quot;);
390         incrAlign();
391         indent();
392         sb.append(&quot;try {\n&quot;);
393         incrAlign();
394         indent();
395         if (!mtype.returnType().equals(void.class)) {
396             sb.append(&quot;return (&quot; + mtype.returnType().getName() + &quot;)&quot;);
397         }
398         sb.append(f.name() + &quot;.invokeExact(&quot; + String.join(&quot;, &quot;, pNames) + &quot;);\n&quot;);
399         decrAlign();
400         indent();
401         sb.append(&quot;} catch (Throwable ex) {\n&quot;);
402         incrAlign();
403         indent();
404         sb.append(&quot;throw new AssertionError(ex);\n&quot;);
405         decrAlign();
406         indent();
407         sb.append(&quot;}\n&quot;);
408         decrAlign();
409         indent();
410         sb.append(&quot;}\n&quot;);
411         decrAlign();
412     }
413 
414     void addDescriptor(String name, FunctionDescriptor desc) {
415         incrAlign();
416         indent();
417         sb.append(PRI_MODS + &quot;FunctionDescriptor &quot; + name + &quot;$DESC = &quot;);
418         addFunction(desc);
419         sb.append(&quot;;\n&quot;);
420         decrAlign();
421         indent();
422     }
423 
424     void addFunctionalInterface(String name, MethodType mtype) {
425         incrAlign();
426         indent();
427         sb.append(&quot;public interface &quot; + javaSafeIdentifier(name) + &quot; {\n&quot;);
428         incrAlign();
429         indent();
430         sb.append(mtype.returnType().getName() + &quot; apply(&quot;);
431         String delim = &quot;&quot;;
432         for (int i = 0 ; i &lt; mtype.parameterCount() ; i++) {
433             sb.append(delim + mtype.parameterType(i).getName() + &quot; x&quot; + i);
434             delim = &quot;, &quot;;
435         }
436         sb.append(&quot;);\n&quot;);
437         decrAlign();
438         indent();
439         sb.append(&quot;}\n&quot;);
440         decrAlign();
441         indent();
442     }
443 
444     protected void addFunctionalFactory(String name, MethodType mtype) {
445         incrAlign();
446         indent();
447         sb.append(PUB_MODS + &quot;MemoryAddress &quot; + name + &quot;$make(&quot; + name + &quot; fi) {\n&quot;);
448         incrAlign();
449         indent();
450         sb.append(&quot;return RuntimeHelper.upcallStub(&quot; + name + &quot;.class, fi, &quot; + name + &quot;$DESC, &quot; +
451                 &quot;\&quot;&quot; + mtype.toMethodDescriptorString() + &quot;\&quot;);\n&quot;);
452         decrAlign();
453         indent();
454         sb.append(&quot;}\n&quot;);
455         decrAlign();
456     }
457 
458     void addGetter(String name, Class&lt;?&gt; type, String parent) {
459         incrAlign();
460         indent();
461         name = javaSafeIdentifier(name);
462         String vhName = (parent != null ? (javaSafeIdentifier(parent) + &quot;$&quot;) : &quot;&quot;) + name;
463         String param = parent != null ? (MemorySegment.class.getName() + &quot; seg&quot;) : &quot;&quot;;
464         sb.append(PUB_MODS + type.getName() + &quot; &quot; + vhName + &quot;$get(&quot; + param + &quot;) {\n&quot;);
465         incrAlign();
466         indent();
467         String vhParam = parent != null ?
468                 &quot;seg.baseAddress()&quot; : name + &quot;$ADDR&quot;;
469         sb.append(&quot;return (&quot; + type.getName() + &quot;)&quot; + vhName + &quot;.get(&quot; + vhParam + &quot;);\n&quot;);
470         decrAlign();
471         indent();
472         sb.append(&quot;}\n&quot;);
473         decrAlign();
474     }
475 
476     void addSetter(String name, Class&lt;?&gt; type, String parent) {
477         incrAlign();
478         indent();
479         name = javaSafeIdentifier(name);
480         String vhName = (parent != null ? (javaSafeIdentifier(parent) + &quot;$&quot;) : &quot;&quot;) + name;
481         String param = parent != null ? (MemorySegment.class.getName() + &quot; seg, &quot;) : &quot;&quot;;
482         sb.append(PUB_MODS + &quot;void &quot; + vhName + &quot;$set(&quot; + param + type.getName() + &quot; x) {\n&quot;);
483         incrAlign();
484         indent();
485         String vhParam = parent != null ?
486                 &quot;seg.baseAddress()&quot; : name + &quot;$ADDR&quot;;
487         sb.append(vhName + &quot;.set(&quot; + vhParam + &quot;, x);\n&quot;);
488         decrAlign();
489         indent();
490         sb.append(&quot;}\n&quot;);
491         decrAlign();
492     }
493 
494     protected String build() {
495         String res = sb.toString();
496         this.sb = null;
497         return res.toString();
498     }
499 
500     protected void indent() {
501         for (int i = 0; i &lt; align; i++) {
502             sb.append(&quot;    &quot;);
503         }
504     }
505 
506     protected void incrAlign() {
507         align++;
508     }
509 
510     protected void decrAlign() {
511         align--;
512     }
513 
514     protected final String javaSafeIdentifier(String name) {
515         // We never get the problem of Java non-identifiers (like 123, ab-xy) as
516         // C identifiers. But we may have a java keyword used as a C identifier.
517         assert SourceVersion.isIdentifier(name);
518 
519         return SourceVersion.isKeyword(name)? (name + &quot;_&quot;) : name;
520     }
521 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
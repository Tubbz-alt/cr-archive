diff a/src/java.base/share/classes/java/nio/Buffer.java b/src/java.base/share/classes/java/nio/Buffer.java
--- a/src/java.base/share/classes/java/nio/Buffer.java
+++ b/src/java.base/share/classes/java/nio/Buffer.java
@@ -31,10 +31,11 @@
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 import jdk.internal.misc.Unsafe;
 import jdk.internal.vm.annotation.ForceInline;
 
+import java.io.FileDescriptor;
 import java.util.Spliterator;
 
 /**
  * A container for data of a specific primitive type.
  *
@@ -799,9 +800,24 @@
 
                 @Override
                 public MemorySegmentProxy bufferSegment(Buffer buffer) {
                     return buffer.segment;
                 }
+
+                @Override
+                public void force(FileDescriptor fd, long address, boolean isSync, long offset, long size) {
+                    MappedMemoryUtils.force(fd, address, isSync, offset, size);
+                }
+
+                @Override
+                public void load(long address, boolean isSync, long size) {
+                    MappedMemoryUtils.load(address, isSync, size);
+                }
+
+                @Override
+                public boolean isLoaded(long address, boolean isSync, long size) {
+                    return MappedMemoryUtils.isLoaded(address, isSync, size);
+                }
             });
     }
 
 }
diff a/src/java.base/share/classes/java/nio/MappedByteBuffer.java b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
--- a/src/java.base/share/classes/java/nio/MappedByteBuffer.java
+++ b/src/java.base/share/classes/java/nio/MappedByteBuffer.java
@@ -29,11 +29,10 @@
 import java.lang.ref.Reference;
 import java.util.Objects;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
-import jdk.internal.misc.Unsafe;
 
 
 /**
  * A direct byte buffer whose content is a memory-mapped region of a file.
  *
@@ -133,64 +132,10 @@
                         throw new UnsupportedOperationException();
                     }
                 } : null;
     }
 
-    // Returns the distance (in bytes) of the buffer start from the
-    // largest page aligned address of the mapping less than or equal
-    // to the start address.
-    private long mappingOffset() {
-        return mappingOffset(0);
-    }
-
-    // Returns the distance (in bytes) of the buffer element
-    // identified by index from the largest page aligned address of
-    // the mapping less than or equal to the element address. Computed
-    // each time to avoid storing in every direct buffer.
-    private long mappingOffset(int index) {
-        int ps = Bits.pageSize();
-        long indexAddress = address + index;
-        long baseAddress = alignDown(indexAddress, ps);
-        return indexAddress - baseAddress;
-    }
-
-    // Given an offset previously obtained from calling
-    // mappingOffset() returns the largest page aligned address of the
-    // mapping less than or equal to the buffer start address.
-    private long mappingAddress(long mappingOffset) {
-        return mappingAddress(mappingOffset, 0);
-    }
-
-    // Given an offset previously otained from calling
-    // mappingOffset(index) returns the largest page aligned address
-    // of the mapping less than or equal to the address of the buffer
-    // element identified by index.
-    private long mappingAddress(long mappingOffset, long index) {
-        long indexAddress = address + index;
-        return indexAddress - mappingOffset;
-    }
-
-    // given a mappingOffset previously otained from calling
-    // mappingOffset() return that offset added to the buffer
-    // capacity.
-    private long mappingLength(long mappingOffset) {
-        return mappingLength(mappingOffset, (long)capacity());
-    }
-
-    // given a mappingOffset previously otained from calling
-    // mappingOffset(index) return that offset added to the supplied
-    // length.
-    private long mappingLength(long mappingOffset, long length) {
-        return length + mappingOffset;
-    }
-
-    // align address down to page size
-    private static long alignDown(long address, int pageSize) {
-        // pageSize must be a power of 2
-        return address & ~(pageSize - 1);
-    }
-
     /**
      * Tells whether this buffer was mapped against a non-volatile
      * memory device by passing one of the sync map modes {@link
      * jdk.nio.mapmode.ExtendedMapMode#READ_ONLY_SYNC
      * ExtendedMapModeMapMode#READ_ONLY_SYNC} or {@link
@@ -226,24 +171,13 @@
      */
     public final boolean isLoaded() {
         if (fd == null) {
             return true;
         }
-        // a sync mapped buffer is always loaded
-        if (isSync()) {
-            return true;
-        }
-        if ((address == 0) || (capacity() == 0))
-            return true;
-        long offset = mappingOffset();
-        long length = mappingLength(offset);
-        return isLoaded0(mappingAddress(offset), length, Bits.pageCount(length));
+        return MappedMemoryUtils.isLoaded(address, isSync, capacity());
     }
 
-    // not used, but a potential target for a store, see load() for details.
-    private static byte unused;
-
     /**
      * Loads this buffer's content into physical memory.
      *
      * <p> This method makes a best effort to ensure that, when it returns,
      * this buffer's content is resident in physical memory.  Invoking this
@@ -254,41 +188,15 @@
      */
     public final MappedByteBuffer load() {
         if (fd == null) {
             return this;
         }
-        // no need to load a sync mapped buffer
-        if (isSync()) {
-            return this;
-        }
-        if ((address == 0) || (capacity() == 0))
-            return this;
-        long offset = mappingOffset();
-        long length = mappingLength(offset);
-        load0(mappingAddress(offset), length);
-
-        // Read a byte from each page to bring it into memory. A checksum
-        // is computed as we go along to prevent the compiler from otherwise
-        // considering the loop as dead code.
-        Unsafe unsafe = Unsafe.getUnsafe();
-        int ps = Bits.pageSize();
-        int count = Bits.pageCount(length);
-        long a = mappingAddress(offset);
-        byte x = 0;
         try {
-            for (int i=0; i<count; i++) {
-                // TODO consider changing to getByteOpaque thus avoiding
-                // dead code elimination and the need to calculate a checksum
-                x ^= unsafe.getByte(a);
-                a += ps;
-            }
+            MappedMemoryUtils.load(address, isSync, capacity());
         } finally {
             Reference.reachabilityFence(this);
         }
-        if (unused != 0)
-            unused = x;
-
         return this;
     }
 
     /**
      * Forces any changes made to this buffer's content to be written to the
@@ -317,12 +225,11 @@
         }
         if (isSync) {
             return force(0, limit());
         }
         if ((address != 0) && (capacity() != 0)) {
-            long offset = mappingOffset();
-            force0(fd, mappingAddress(offset), mappingLength(offset));
+            return force(0, capacity());
         }
         return this;
     }
 
     /**
@@ -372,26 +279,15 @@
             return this;
         }
         if ((address != 0) && (limit() != 0)) {
             // check inputs
             Objects.checkFromIndexSize(index, length, limit());
-            if (isSync) {
-                // simply force writeback of associated cache lines
-                Unsafe.getUnsafe().writebackMemory(address + index, length);
-            } else {
-                // force writeback via file descriptor
-                long offset = mappingOffset(index);
-                force0(fd, mappingAddress(offset, index), mappingLength(offset, length));
-            }
+            MappedMemoryUtils.force(fd, address, isSync, index, length);
         }
         return this;
     }
 
-    private native boolean isLoaded0(long address, long length, int pageCount);
-    private native void load0(long address, long length);
-    private native void force0(FileDescriptor fd, long address, long length);
-
     // -- Covariant return type overrides
 
     /**
      * {@inheritDoc}
      */
diff a/src/java.base/share/classes/java/nio/MappedMemoryUtils.java b/src/java.base/share/classes/java/nio/MappedMemoryUtils.java
--- /dev/null
+++ b/src/java.base/share/classes/java/nio/MappedMemoryUtils.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package java.nio;
+
+import jdk.internal.misc.Unsafe;
+
+import java.io.FileDescriptor;
+
+/* package */ class MappedMemoryUtils {
+
+    static boolean isLoaded(long address, boolean isSync, long size) {
+        // a sync mapped buffer is always loaded
+        if (isSync) {
+            return true;
+        }
+        if ((address == 0) || (size == 0))
+            return true;
+        long offset = mappingOffset(address);
+        long length = mappingLength(offset, size);
+        return isLoaded0(mappingAddress(address, offset), length, Bits.pageCount(length));
+    }
+
+    static void load(long address, boolean isSync, long size) {
+        // no need to load a sync mapped buffer
+        if (isSync) {
+            return;
+        }
+        if ((address == 0) || (size == 0))
+            return;
+        long offset = mappingOffset(address);
+        long length = mappingLength(offset, size);
+        load0(mappingAddress(address, offset), length);
+
+        // Read a byte from each page to bring it into memory. A checksum
+        // is computed as we go along to prevent the compiler from otherwise
+        // considering the loop as dead code.
+        Unsafe unsafe = Unsafe.getUnsafe();
+        int ps = Bits.pageSize();
+        int count = Bits.pageCount(length);
+        long a = mappingAddress(address, offset);
+        byte x = 0;
+        for (int i=0; i<count; i++) {
+            // TODO consider changing to getByteOpaque thus avoiding
+            // dead code elimination and the need to calculate a checksum
+            x ^= unsafe.getByte(a);
+            a += ps;
+        }
+        if (unused != 0)
+            unused = x;
+    }
+
+    // not used, but a potential target for a store, see load() for details.
+    private static byte unused;
+
+    static void force(FileDescriptor fd, long address, boolean isSync, long index, long length) {
+        if (isSync) {
+            // simply force writeback of associated cache lines
+            Unsafe.getUnsafe().writebackMemory(address + index, length);
+        } else {
+            // force writeback via file descriptor
+            long offset = mappingOffset(address, index);
+            force0(fd, mappingAddress(address, offset, index), mappingLength(offset, length));
+        }
+    }
+
+    // native methods
+
+    private static native boolean isLoaded0(long address, long length, int pageCount);
+    private static native void load0(long address, long length);
+    private static native void force0(FileDescriptor fd, long address, long length);
+
+    // utility methods
+
+    // Returns the distance (in bytes) of the buffer start from the
+    // largest page aligned address of the mapping less than or equal
+    // to the start address.
+    private static long mappingOffset(long address) {
+        return mappingOffset(address, 0);
+    }
+
+    // Returns the distance (in bytes) of the buffer element
+    // identified by index from the largest page aligned address of
+    // the mapping less than or equal to the element address. Computed
+    // each time to avoid storing in every direct buffer.
+    private static long mappingOffset(long address, long index) {
+        int ps = Bits.pageSize();
+        long indexAddress = address + index;
+        long baseAddress = alignDown(indexAddress, ps);
+        return indexAddress - baseAddress;
+    }
+
+    // Given an offset previously obtained from calling
+    // mappingOffset() returns the largest page aligned address of the
+    // mapping less than or equal to the buffer start address.
+    private static long mappingAddress(long address, long mappingOffset) {
+        return mappingAddress(address, mappingOffset, 0);
+    }
+
+    // Given an offset previously otained from calling
+    // mappingOffset(index) returns the largest page aligned address
+    // of the mapping less than or equal to the address of the buffer
+    // element identified by index.
+    private static long mappingAddress(long address, long mappingOffset, long index) {
+        long indexAddress = address + index;
+        return indexAddress - mappingOffset;
+    }
+
+    // given a mappingOffset previously otained from calling
+    // mappingOffset(index) return that offset added to the supplied
+    // length.
+    private static long mappingLength(long mappingOffset, long length) {
+        return length + mappingOffset;
+    }
+
+    // align address down to page size
+    private static long alignDown(long address, int pageSize) {
+        // pageSize must be a power of 2
+        return address & ~(pageSize - 1);
+    }
+}
diff a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
--- a/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
+++ b/src/java.base/share/classes/jdk/internal/access/JavaNioAccess.java
@@ -26,10 +26,11 @@
 package jdk.internal.access;
 
 import jdk.internal.access.foreign.MemorySegmentProxy;
 import jdk.internal.access.foreign.UnmapperProxy;
 
+import java.io.FileDescriptor;
 import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
 public interface JavaNioAccess {
     /**
@@ -85,6 +86,21 @@
 
     /**
      * Used by {@code jdk.internal.foreign.AbstractMemorySegmentImpl} and byte buffer var handle views.
      */
     MemorySegmentProxy bufferSegment(Buffer buffer);
+
+    /**
+     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.
+     */
+    void force(FileDescriptor fd, long address, boolean isSync, long offset, long size);
+
+    /**
+     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.
+     */
+    void load(long address, boolean isSync, long size);
+
+    /**
+     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.
+     */
+    boolean isLoaded(long address, boolean isSync, long size);
 }
diff a/src/java.base/unix/native/libnio/MappedByteBuffer.c b/src/java.base/unix/native/libnio/MappedByteBuffer.c
--- a/src/java.base/unix/native/libnio/MappedByteBuffer.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jvm.h"
-#include "jlong.h"
-#include "java_nio_MappedByteBuffer.h"
-#include <assert.h>
-#include <sys/mman.h>
-#include <stddef.h>
-#include <stdlib.h>
-
-#ifdef _AIX
-#include <unistd.h>
-#endif
-
-/* Output type for mincore(2) */
-#ifdef __linux__
-typedef unsigned char mincore_vec_t;
-#else
-typedef char mincore_vec_t;
-#endif
-
-#ifdef _AIX
-static long calculate_number_of_pages_in_range(void* address, size_t len, size_t pagesize) {
-    uintptr_t address_unaligned = (uintptr_t) address;
-    uintptr_t address_aligned = address_unaligned & (~(pagesize - 1));
-    size_t len2 = len + (address_unaligned - address_aligned);
-    long numPages = (len2 + pagesize - 1) / pagesize;
-    return numPages;
-}
-#endif
-
-JNIEXPORT jboolean JNICALL
-Java_java_nio_MappedByteBuffer_isLoaded0(JNIEnv *env, jobject obj, jlong address,
-                                         jlong len, jint numPages)
-{
-    jboolean loaded = JNI_TRUE;
-    int result = 0;
-    int i = 0;
-    void *a = (void *) jlong_to_ptr(address);
-    mincore_vec_t* vec = NULL;
-
-#ifdef _AIX
-    /* See JDK-8186665 */
-    size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);
-    if ((long)pagesize == -1) {
-        return JNI_FALSE;
-    }
-    numPages = (jint) calculate_number_of_pages_in_range(a, len, pagesize);
-#endif
-
-    /* Include space for one sentinel byte at the end of the buffer
-     * to catch overflows. */
-    vec = (mincore_vec_t*) malloc(numPages + 1);
-
-    if (vec == NULL) {
-        JNU_ThrowOutOfMemoryError(env, NULL);
-        return JNI_FALSE;
-    }
-
-    vec[numPages] = '\x7f'; /* Write sentinel. */
-    result = mincore(a, (size_t)len, vec);
-    assert(vec[numPages] == '\x7f'); /* Check sentinel. */
-
-    if (result == -1) {
-        JNU_ThrowIOExceptionWithLastError(env, "mincore failed");
-        free(vec);
-        return JNI_FALSE;
-    }
-
-    for (i=0; i<numPages; i++) {
-        if (vec[i] == 0) {
-            loaded = JNI_FALSE;
-            break;
-        }
-    }
-    free(vec);
-    return loaded;
-}
-
-
-JNIEXPORT void JNICALL
-Java_java_nio_MappedByteBuffer_load0(JNIEnv *env, jobject obj, jlong address,
-                                     jlong len)
-{
-    char *a = (char *)jlong_to_ptr(address);
-    int result = madvise((caddr_t)a, (size_t)len, MADV_WILLNEED);
-    if (result == -1) {
-        JNU_ThrowIOExceptionWithLastError(env, "madvise failed");
-    }
-}
-
-
-JNIEXPORT void JNICALL
-Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jobject fdo,
-                                      jlong address, jlong len)
-{
-    void* a = (void *)jlong_to_ptr(address);
-    int result = msync(a, (size_t)len, MS_SYNC);
-    if (result == -1) {
-        JNU_ThrowIOExceptionWithLastError(env, "msync failed");
-    }
-}
diff a/src/java.base/unix/native/libnio/MappedMemoryUtils.c b/src/java.base/unix/native/libnio/MappedMemoryUtils.c
--- /dev/null
+++ b/src/java.base/unix/native/libnio/MappedMemoryUtils.c
@@ -0,0 +1,127 @@
+/*
+ * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "java_nio_MappedMemoryUtils.h"
+#include <assert.h>
+#include <sys/mman.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+#ifdef _AIX
+#include <unistd.h>
+#endif
+
+/* Output type for mincore(2) */
+#ifdef __linux__
+typedef unsigned char mincore_vec_t;
+#else
+typedef char mincore_vec_t;
+#endif
+
+#ifdef _AIX
+static long calculate_number_of_pages_in_range(void* address, size_t len, size_t pagesize) {
+    uintptr_t address_unaligned = (uintptr_t) address;
+    uintptr_t address_aligned = address_unaligned & (~(pagesize - 1));
+    size_t len2 = len + (address_unaligned - address_aligned);
+    long numPages = (len2 + pagesize - 1) / pagesize;
+    return numPages;
+}
+#endif
+
+JNIEXPORT jboolean JNICALL
+Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,
+                                         jlong len, jint numPages)
+{
+    jboolean loaded = JNI_TRUE;
+    int result = 0;
+    int i = 0;
+    void *a = (void *) jlong_to_ptr(address);
+    mincore_vec_t* vec = NULL;
+
+#ifdef _AIX
+    /* See JDK-8186665 */
+    size_t pagesize = (size_t)sysconf(_SC_PAGESIZE);
+    if ((long)pagesize == -1) {
+        return JNI_FALSE;
+    }
+    numPages = (jint) calculate_number_of_pages_in_range(a, len, pagesize);
+#endif
+
+    /* Include space for one sentinel byte at the end of the buffer
+     * to catch overflows. */
+    vec = (mincore_vec_t*) malloc(numPages + 1);
+
+    if (vec == NULL) {
+        JNU_ThrowOutOfMemoryError(env, NULL);
+        return JNI_FALSE;
+    }
+
+    vec[numPages] = '\x7f'; /* Write sentinel. */
+    result = mincore(a, (size_t)len, vec);
+    assert(vec[numPages] == '\x7f'); /* Check sentinel. */
+
+    if (result == -1) {
+        JNU_ThrowIOExceptionWithLastError(env, "mincore failed");
+        free(vec);
+        return JNI_FALSE;
+    }
+
+    for (i=0; i<numPages; i++) {
+        if (vec[i] == 0) {
+            loaded = JNI_FALSE;
+            break;
+        }
+    }
+    free(vec);
+    return loaded;
+}
+
+
+JNIEXPORT void JNICALL
+Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,
+                                     jlong len)
+{
+    char *a = (char *)jlong_to_ptr(address);
+    int result = madvise((caddr_t)a, (size_t)len, MADV_WILLNEED);
+    if (result == -1) {
+        JNU_ThrowIOExceptionWithLastError(env, "madvise failed");
+    }
+}
+
+
+JNIEXPORT void JNICALL
+Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,
+                                      jlong address, jlong len)
+{
+    void* a = (void *)jlong_to_ptr(address);
+    int result = msync(a, (size_t)len, MS_SYNC);
+    if (result == -1) {
+        JNU_ThrowIOExceptionWithLastError(env, "msync failed");
+    }
+}
diff a/src/java.base/windows/native/libnio/MappedByteBuffer.c b/src/java.base/windows/native/libnio/MappedByteBuffer.c
--- a/src/java.base/windows/native/libnio/MappedByteBuffer.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jvm.h"
-#include "jlong.h"
-#include "java_nio_MappedByteBuffer.h"
-#include <stdlib.h>
-
-JNIEXPORT jboolean JNICALL
-Java_java_nio_MappedByteBuffer_isLoaded0(JNIEnv *env, jobject obj, jlong address,
-                                         jlong len, jint numPages)
-{
-    jboolean loaded = JNI_FALSE;
-    /* Information not available?
-    MEMORY_BASIC_INFORMATION info;
-    void *a = (void *) jlong_to_ptr(address);
-    int result = VirtualQuery(a, &info, (DWORD)len);
-    */
-    return loaded;
-}
-
-JNIEXPORT void JNICALL
-Java_java_nio_MappedByteBuffer_load0(JNIEnv *env, jobject obj, jlong address,
-                                     jlong len)
-{
-    // no madvise available
-}
-
-JNIEXPORT void JNICALL
-Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jobject fdo,
-                                      jlong address, jlong len)
-{
-    void *a = (void *) jlong_to_ptr(address);
-    BOOL result;
-    int retry;
-
-    /*
-     * FlushViewOfFile can fail with ERROR_LOCK_VIOLATION if the memory
-     * system is writing dirty pages to disk. As there is no way to
-     * synchronize the flushing then we retry a limited number of times.
-     */
-    retry = 0;
-    do {
-        result = FlushViewOfFile(a, (DWORD)len);
-        if ((result != 0) || (GetLastError() != ERROR_LOCK_VIOLATION))
-            break;
-        retry++;
-    } while (retry < 3);
-
-    /**
-     * FlushViewOfFile only initiates the writing of dirty pages to disk
-     * so we have to call FlushFileBuffers to and ensure they are written.
-     */
-    if (result != 0) {
-        // by right, the jfieldID initialization should be in a static
-        // initializer but we do it here instead to avoiding needing to
-        // load nio.dll during startup.
-        static jfieldID handle_fdID;
-        HANDLE h;
-        if (handle_fdID == NULL) {
-            jclass clazz = (*env)->FindClass(env, "java/io/FileDescriptor");
-            CHECK_NULL(clazz); //exception thrown
-            handle_fdID = (*env)->GetFieldID(env, clazz, "handle", "J");
-            CHECK_NULL(handle_fdID);
-        }
-        h = jlong_to_ptr((*env)->GetLongField(env, fdo, handle_fdID));
-        result = FlushFileBuffers(h);
-        if (result == 0 && GetLastError() == ERROR_ACCESS_DENIED) {
-            // read-only mapping
-            result = 1;
-        }
-    }
-
-    if (result == 0) {
-        JNU_ThrowIOExceptionWithLastError(env, "Flush failed");
-    }
-}
diff a/src/java.base/windows/native/libnio/MappedMemoryUtils.c b/src/java.base/windows/native/libnio/MappedMemoryUtils.c
--- /dev/null
+++ b/src/java.base/windows/native/libnio/MappedMemoryUtils.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "jni.h"
+#include "jni_util.h"
+#include "jvm.h"
+#include "jlong.h"
+#include "java_nio_MappedMemoryUtils.h"
+#include <stdlib.h>
+
+JNIEXPORT jboolean JNICALL
+Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,
+                                         jlong len, jint numPages)
+{
+    jboolean loaded = JNI_FALSE;
+    /* Information not available?
+    MEMORY_BASIC_INFORMATION info;
+    void *a = (void *) jlong_to_ptr(address);
+    int result = VirtualQuery(a, &info, (DWORD)len);
+    */
+    return loaded;
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,
+                                     jlong len)
+{
+    // no madvise available
+}
+
+JNIEXPORT void JNICALL
+Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,
+                                      jlong address, jlong len)
+{
+    void *a = (void *) jlong_to_ptr(address);
+    BOOL result;
+    int retry;
+
+    /*
+     * FlushViewOfFile can fail with ERROR_LOCK_VIOLATION if the memory
+     * system is writing dirty pages to disk. As there is no way to
+     * synchronize the flushing then we retry a limited number of times.
+     */
+    retry = 0;
+    do {
+        result = FlushViewOfFile(a, (DWORD)len);
+        if ((result != 0) || (GetLastError() != ERROR_LOCK_VIOLATION))
+            break;
+        retry++;
+    } while (retry < 3);
+
+    /**
+     * FlushViewOfFile only initiates the writing of dirty pages to disk
+     * so we have to call FlushFileBuffers to and ensure they are written.
+     */
+    if (result != 0) {
+        // by right, the jfieldID initialization should be in a static
+        // initializer but we do it here instead to avoiding needing to
+        // load nio.dll during startup.
+        static jfieldID handle_fdID;
+        HANDLE h;
+        if (handle_fdID == NULL) {
+            jclass clazz = (*env)->FindClass(env, "java/io/FileDescriptor");
+            CHECK_NULL(clazz); //exception thrown
+            handle_fdID = (*env)->GetFieldID(env, clazz, "handle", "J");
+            CHECK_NULL(handle_fdID);
+        }
+        h = jlong_to_ptr((*env)->GetLongField(env, fdo, handle_fdID));
+        result = FlushFileBuffers(h);
+        if (result == 0 && GetLastError() == ERROR_ACCESS_DENIED) {
+            // read-only mapping
+            result = 1;
+        }
+    }
+
+    if (result == 0) {
+        JNU_ThrowIOExceptionWithLastError(env, "Flush failed");
+    }
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MappedMemorySegment.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.foreign;
+
+import java.nio.channels.FileChannel;
+import java.nio.file.Path;
+
+/**
+ * A mapped memory segment, that is, a memory segment backed by memory-mapped file.
+ *
+ * <p> Mapped memory segments are created via the {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}.
+ * Mapped memory segments behave like ordinary segments, but also provide additional capabilities that are specific to
+ * mapped memory segments, such as {@link #force()} and {@link #load()}.
+ * <p>
+ * All implementations of this interface must be <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
+ * use of identity-sensitive operations (including reference equality ({@code ==}), identity hash code, or synchronization) on
+ * instances of {@code MemoryLayout} may have unpredictable results and should be avoided. The {@code equals} method should
+ * be used for comparisons.
+ * <p>
+ * Non-platform classes should not implement {@linkplain MappedMemorySegment} directly.
+ *
+ * <p> The content of a mapped memory segment can change at any time, for example
+ * if the content of the corresponding region of the mapped file is changed by
+ * this (or another) program.  Whether or not such changes occur, and when they
+ * occur, is operating-system dependent and therefore unspecified.
+ *
+ * All or part of a mapped memory segment may become
+ * inaccessible at any time, for example if the backing mapped file is truncated.  An
+ * attempt to access an inaccessible region of a mapped memory segment will not
+ * change the segment's content and will cause an unspecified exception to be
+ * thrown either at the time of the access or at some later time.  It is
+ * therefore strongly recommended that appropriate precautions be taken to
+ * avoid the manipulation of a mapped file by this (or another) program, except to read or write
+ * the file's content.
+ *
+ * @apiNote In the future, if the Java language permits, {@link MemorySegment}
+ * may become a {@code sealed} interface, which would prohibit subclassing except by
+ * explicitly permitted subtypes.
+ */
+public interface MappedMemorySegment extends MemorySegment {
+
+    @Override
+    MappedMemorySegment withAccessModes(int accessModes);
+
+    @Override
+    MappedMemorySegment asSlice(long offset, long newSize);
+
+    /**
+     * Forces any changes made to this segment's content to be written to the
+     * storage device containing the mapped file.
+     *
+     * <p> If the file mapped into this segment resides on a local storage
+     * device then when this method returns it is guaranteed that all changes
+     * made to the segment since it was created, or since this method was last
+     * invoked, will have been written to that device.
+     *
+     * <p> If the file does not reside on a local device then no such guarantee
+     * is made.
+     *
+     * <p> If this segment was not mapped in read/write mode ({@link
+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then
+     * invoking this method may have no effect. In particular, the
+     * method has no effect for segments mapped in read-only or private
+     * mapping modes. This method may or may not have an effect for
+     * implementation-specific mapping modes.
+     * </p>
+     */
+    void force();
+
+    /**
+     * Loads this segment's content into physical memory.
+     *
+     * <p> This method makes a best effort to ensure that, when it returns,
+     * this segment's content is resident in physical memory.  Invoking this
+     * method may cause some number of page faults and I/O operations to
+     * occur. </p>
+     */
+    void load();
+
+    /**
+     * Tells whether or not this segment's content is resident in physical
+     * memory.
+     *
+     * <p> A return value of {@code true} implies that it is highly likely
+     * that all of the data in this segment is resident in physical memory and
+     * may therefore be accessed without incurring any virtual-memory page
+     * faults or I/O operations.  A return value of {@code false} does not
+     * necessarily imply that the segment's content is not resident in physical
+     * memory.
+     *
+     * <p> The returned value is a hint, rather than a guarantee, because the
+     * underlying operating system may have paged out some of the segment's data
+     * by the time that an invocation of this method returns.  </p>
+     *
+     * @return  {@code true} if it is likely that this segment's content
+     *          is resident in physical memory
+     */
+    boolean isLoaded();
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -70,11 +70,12 @@
  * depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
  * segment obtained from a byte buffer created with the {@link ByteBuffer#allocateDirect(int)} method will be backed
  * by native memory.
  * <p>
  * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
- * {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>.
+ * {@link MemorySegment#mapFromPath(Path, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments</em>
+ * (see {@link MappedMemorySegment}).
  *
  * <h2>Closing a memory segment</h2>
  *
  * Memory segments are closed explicitly (see {@link MemorySegment#close()}). In general when a segment is closed, all off-heap
  * resources associated with it are released; this has different meanings depending on the kind of memory segment being
@@ -144,11 +145,11 @@
  * {@link ByteBuffer} API, but need to operate on large memory segments. Byte buffers obtained in such a way support
  * the same spatial and temporal access restrictions associated to the memory address from which they originated.
  *
  * @apiNote In the future, if the Java language permits, {@link MemorySegment}
  * may become a {@code sealed} interface, which would prohibit subclassing except by
- * explicitly permitted types.
+ * {@link MappedMemorySegment} and other explicitly permitted subtypes.
  *
  * @implSpec
  * Implementations of this interface are immutable and thread-safe.
  */
 public interface MemorySegment extends AutoCloseable {
@@ -160,11 +161,11 @@
      * @return The base memory address.
      */
     MemoryAddress baseAddress();
 
     /**
-     * Returns a spliterator for this memory segment. The returned spliterator reports {@link Spliterator#SIZED},
+     * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
      * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
      * characteristics.
      * <p>
      * The returned spliterator splits the segment according to the specified sequence layout; that is,
      * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}
@@ -175,16 +176,20 @@
      * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
      * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
      * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
      * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
+     * @param segment the segment to be used for splitting.
      * @param layout the layout to be used for splitting.
+     * @param <S> the memory segment type
      * @return the element spliterator for this segment
-     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * @throws IllegalStateException if the segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment
      */
-    Spliterator<MemorySegment> spliterator(SequenceLayout layout);
+    static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {
+        return AbstractMemorySegmentImpl.spliterator(segment, layout);
+    }
 
     /**
      * The thread owning this segment.
      * @return the thread owning this segment.
      */
@@ -244,11 +249,11 @@
      * or to access the memory associated with the segment will fail with {@link IllegalStateException}. Depending on
      * the kind of memory segment being closed, calling this method further trigger deallocation of all the resources
      * associated with the memory segment.
      * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
-     * thread (see {@link #spliterator(SequenceLayout)}).
+     * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
      */
     void close();
 
     /**
@@ -434,17 +439,18 @@
      * @implNote When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
      * of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.
      *
      * @param path the path to the file to memory map.
      * @param bytesSize the size (in bytes) of the mapped memory backing the memory segment.
-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}.
+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode
+     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegment#force()}).
      * @return a new mapped memory segment.
      * @throws IllegalArgumentException if {@code bytesSize < 0}.
      * @throws UnsupportedOperationException if an unsupported map mode is specified.
      * @throws IOException if the specified path does not point to an existing file, or if some other I/O error occurs.
      */
-    static MemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
+    static MappedMemorySegment mapFromPath(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
         return MappedMemorySegmentImpl.makeMappedSegment(path, bytesSize, mapMode);
     }
 
     /**
      * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
@@ -496,11 +502,11 @@
      */
     int CLOSE = WRITE << 1;
 
     /**
      * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
-     * (see {@link #spliterator(SequenceLayout)}).
+     * (see {@link #spliterator(MemorySegment, SequenceLayout)}).
      * @see MemorySegment#accessModes()
      * @see MemorySegment#withAccessModes(int)
      */
     int ACQUIRE = CLOSE << 1;
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -91,27 +91,27 @@
                 DEFAULT_MASK | SMALL :
                 DEFAULT_MASK;
     }
 
     @Override
-    public final MemorySegment asSlice(long offset, long newSize) {
+    public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
         checkBounds(offset, newSize);
         return asSliceNoCheck(offset, newSize);
     }
 
     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
         return dup(offset, newSize, mask, owner, scope);
     }
 
-    @Override
-    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {
-        checkValidState();
-        if (sequenceLayout.byteSize() != byteSize()) {
+    @SuppressWarnings("unchecked")
+    public static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout sequenceLayout) {
+        ((AbstractMemorySegmentImpl)segment).checkValidState();
+        if (sequenceLayout.byteSize() != segment.byteSize()) {
             throw new IllegalArgumentException();
         }
-        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
-                this.withAccessModes(accessModes() & ~CLOSE));
+        return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
+                (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/HeapMemorySegmentImpl.java
@@ -67,11 +67,11 @@
     long min() {
         return offset;
     }
 
     @Override
-    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+    HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new HeapMemorySegmentImpl<H>(this.offset + offset, baseProvider, size, mask, owner, scope);
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MappedMemorySegmentImpl.java
@@ -23,11 +23,11 @@
  * questions.
  */
 
 package jdk.internal.foreign;
 
-import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.MappedMemorySegment;
 import jdk.internal.access.JavaNioAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.access.foreign.UnmapperProxy;
 import sun.nio.ch.FileChannelImpl;
 
@@ -42,11 +42,11 @@
  * Implementation for a mapped memory segments. A mapped memory segment is a native memory segment, which
  * additionally features an {@link UnmapperProxy} object. This object provides detailed information about the
  * memory mapped segment, such as the file descriptor associated with the mapping. This information is crucial
  * in order to correctly reconstruct a byte buffer object from the segment (see {@link #makeByteBuffer()}).
  */
-public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {
+public class MappedMemorySegmentImpl extends NativeMemorySegmentImpl implements MappedMemorySegment {
 
     private final UnmapperProxy unmapper;
 
     MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, Thread owner, MemoryScope scope) {
         super(min, length, mask, owner, scope);
@@ -58,17 +58,45 @@
         JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();
         return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);
     }
 
     @Override
-    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+    MappedMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new MappedMemorySegmentImpl(min + offset, unmapper, size, mask, owner, scope);
     }
 
+    // mapped segment methods
+
+
+    @Override
+    public MappedMemorySegmentImpl asSlice(long offset, long newSize) {
+        return (MappedMemorySegmentImpl)super.asSlice(offset, newSize);
+    }
+
+    @Override
+    public MappedMemorySegmentImpl withAccessModes(int accessModes) {
+        return (MappedMemorySegmentImpl)super.withAccessModes(accessModes);
+    }
+
+    @Override
+    public void load() {
+        nioAccess.load(min, unmapper.isSync(), length);
+    }
+
+    @Override
+    public boolean isLoaded() {
+        return nioAccess.isLoaded(min, unmapper.isSync(), length);
+    }
+
+    @Override
+    public void force() {
+        nioAccess.force(unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);
+    }
+
     // factories
 
-    public static MemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
+    public static MappedMemorySegment makeMappedSegment(Path path, long bytesSize, FileChannel.MapMode mapMode) throws IOException {
         if (bytesSize <= 0) throw new IllegalArgumentException("Requested bytes size must be > 0.");
         try (FileChannelImpl channelImpl = (FileChannelImpl)FileChannel.open(path, openOptions(mapMode))) {
             UnmapperProxy unmapperProxy = channelImpl.mapInternal(mapMode, 0L, bytesSize);
             MemoryScope scope = new MemoryScope(null, unmapperProxy::unmap);
             return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -94,15 +94,15 @@
         return new MemoryAddressImpl(segment, offset + bytes);
     }
 
     @Override
     public MemoryAddress rebase(MemorySegment segment) {
-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl) segment;
+        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
         if (segmentImpl.base() != this.segment.base()) {
             throw new IllegalArgumentException("Invalid rebase target: " + segment);
         }
-        return new MemoryAddressImpl((AbstractMemorySegmentImpl) segment,
+        return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,
                 unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());
     }
 
     // MemoryAddressProxy methods
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/NativeMemorySegmentImpl.java
@@ -56,11 +56,11 @@
         super(length, mask, owner, scope);
         this.min = min;
     }
 
     @Override
-    AbstractMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
+    NativeMemorySegmentImpl dup(long offset, long size, int mask, Thread owner, MemoryScope scope) {
         return new NativeMemorySegmentImpl(min + offset, size, mask, owner, scope);
     }
 
     @Override
     ByteBuffer makeByteBuffer() {
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -29,10 +29,11 @@
  *          jdk.incubator.foreign/jdk.internal.foreign
  * @run testng TestByteBuffer
  */
 
 
+import jdk.incubator.foreign.MappedMemorySegment;
 import jdk.incubator.foreign.MemoryLayouts;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemorySegment;
 import jdk.incubator.foreign.MemoryLayout.PathElement;
@@ -219,11 +220,11 @@
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
                 MemoryAddress base = segment.baseAddress();
                 initTuples(base);
-                ((MappedByteBuffer)segment.asByteBuffer()).force(); //force via segment
+                mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
@@ -240,13 +241,14 @@
         File f = new File("test2.out");
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
-        try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
+        try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
             MemoryAddress base = segment.baseAddress();
             initTuples(base);
+            segment.force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
             MemoryAddress base = segment.baseAddress();
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -230,11 +230,10 @@
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
                 "close",
-                "spliterator",
                 "toByteArray"
         );
 
         public SegmentMember(Method method, Object[] params) {
             this.method = method;
@@ -290,11 +289,11 @@
     enum AccessActions {
         ACQUIRE(MemorySegment.ACQUIRE) {
             @Override
             void run(MemorySegment segment) {
                 Spliterator<MemorySegment> spliterator =
-                        segment.spliterator(MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));
+                        MemorySegment.spliterator(segment, MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));
                 AtomicReference<RuntimeException> exception = new AtomicReference<>();
                 Runnable action = () -> {
                     try {
                         spliterator.tryAdvance(s -> { });
                     } catch (RuntimeException e) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -60,11 +60,11 @@
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
                 setInt(s.baseAddress().addOffset(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
-            spliterators.add(s.spliterator(layout));
+            spliterators.add(MemorySegment.spliterator(s, layout));
             while (true) {
                 boolean progress = false;
                 List<Spliterator<MemorySegment>> newSpliterators = new ArrayList<>();
                 for (Spliterator<MemorySegment> spliterator : spliterators) {
                     Spliterator<MemorySegment> sub = spliterator.trySplit();
@@ -123,11 +123,12 @@
 
 
     @Test(expectedExceptions=IllegalStateException.class)
     public void testBadCloseWithPendingAcquire() throws InterruptedException {
         try (MemorySegment segment = MemorySegment.allocateNative(16)) {
-            Spliterator<MemorySegment> spliterator = segment.spliterator(MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
+            Spliterator<MemorySegment> spliterator = MemorySegment.spliterator(segment,
+                    MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
             Runnable r = () -> spliterator.forEachRemaining(s -> {
                 try {
                     Thread.sleep(5000 * 100);
                 } catch (InterruptedException ex) {
                     throw new AssertionError(ex);
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -66,17 +66,17 @@
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
         //parallel counted completer
-        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();
+        long parallelCounted = new SumSegmentCounted(null, MemorySegment.spliterator(segment, layout), threshold).invoke();
         assertEquals(parallelCounted, expected);
         //parallel recursive action
-        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();
+        long parallelRecursive = new SumSegmentRecursive(MemorySegment.spliterator(segment, layout), threshold).invoke();
         assertEquals(parallelRecursive, expected);
         //parallel stream
-        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)
+        long streamParallel = StreamSupport.stream(MemorySegment.spliterator(segment, layout), true)
                 .reduce(0L, TestSpliterator::sumSingle, Long::sum);
         assertEquals(streamParallel, expected);
         segment.close();
     }
 
@@ -90,12 +90,12 @@
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
-        segment.withAccessModes(MemorySegment.READ)
-                .spliterator(layout).forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
+        MemorySegment.spliterator(segment.withAccessModes(MemorySegment.READ), layout)
+                .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
         return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
diff a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
--- a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
+++ b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SpliteratorTest.java
@@ -64,10 +64,10 @@
 
     @Test(dataProvider = "SegmentSpliterator", dataProviderClass = SegmentTestDataProvider.class )
     public void testSegmentSpliterator(String name, SequenceLayout layout, SpliteratorTestHelper.ContentAsserter<MemorySegment> contentAsserter) {
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
             SegmentTestDataProvider.initSegment(segment);
-            SpliteratorTestHelper.testSpliterator(() -> segment.spliterator(layout),
+            SpliteratorTestHelper.testSpliterator(() -> MemorySegment.spliterator(segment, layout),
                     SegmentTestDataProvider::segmentCopier, contentAsserter);
         }
     }
 }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -116,27 +116,27 @@
         return res;
     }
 
     @Benchmark
     public int segment_parallel() {
-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();
+        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();
     }
 
     @Benchmark
     public int segment_parallel_bulk() {
-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();
+        return new SumSegment(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();
     }
 
     @Benchmark
     public int segment_stream_parallel() {
-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)
+        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
                 .mapToInt(SEGMENT_TO_INT).sum();
     }
 
     @Benchmark
     public int segment_stream_parallel_bulk() {
-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)
+        return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
         (int) VH_int.get(slice.baseAddress(), 0L);

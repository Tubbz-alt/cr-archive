<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New make/autoconf/util_windows.m4</title>
    <link rel="stylesheet" href="../../style.css" />
  </head>
  <body>
    <pre>
  1 #
  2 # Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4 #
  5 # This code is free software; you can redistribute it and/or modify it
  6 # under the terms of the GNU General Public License version 2 only, as
  7 # published by the Free Software Foundation.  Oracle designates this
  8 # particular file as subject to the &quot;Classpath&quot; exception as provided
  9 # by Oracle in the LICENSE file that accompanied this code.
 10 #
 11 # This code is distributed in the hope that it will be useful, but WITHOUT
 12 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14 # version 2 for more details (a copy is included in the LICENSE file that
 15 # accompanied this code).
 16 #
 17 # You should have received a copy of the GNU General Public License version
 18 # 2 along with this work; if not, write to the Free Software Foundation,
 19 # Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20 #
 21 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22 # or visit www.oracle.com if you need additional information or have any
 23 # questions.
 24 #
 25 
 26 AC_DEFUN([UTIL_REWRITE_AS_UNIX_PATH],
 27 [
 28   windows_path=&quot;[$]$1&quot;
 29   if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.cygwin&quot;; then
 30     unix_path=`$CYGPATH -u &quot;$windows_path&quot;`
 31     $1=&quot;$unix_path&quot;
 32   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.msys&quot;; then
 33     unix_path=`$ECHO &quot;$windows_path&quot; | $SED -e &#39;s,^\\(.\\):,/\\1,g&#39; -e &#39;s,\\\\,/,g&#39;`
 34     $1=&quot;$unix_path&quot;
 35   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
 36     # wslpath does not check the input, only call if an actual windows path was
 37     # given.
 38     if $ECHO &quot;$windows_path&quot; | $GREP -q [&quot;^[a-zA-Z]:[\\\\/]&quot;]; then
 39       unix_path=`$WSLPATH -u &quot;$windows_path&quot;`
 40       $1=&quot;$unix_path&quot;
 41     fi
 42   fi
 43 ])
 44 
 45 AC_DEFUN([UTIL_REWRITE_AS_WINDOWS_MIXED_PATH],
 46 [
 47   unix_path=&quot;[$]$1&quot;
 48   if test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.cygwin&quot;; then
 49     windows_path=`$CYGPATH -m &quot;$unix_path&quot;`
 50     $1=&quot;$windows_path&quot;
 51   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.msys&quot;; then
 52     windows_path=`cmd //c echo $unix_path`
 53     $1=&quot;$windows_path&quot;
 54   elif test &quot;x$OPENJDK_BUILD_OS_ENV&quot; = &quot;xwindows.wsl&quot;; then
 55     windows_path=`$WSLPATH -m &quot;$unix_path&quot;`
 56     $1=&quot;$windows_path&quot;
 57   fi
 58 ])
 59 
 60 # Helper function which possibly converts a path using DOS-style short mode.
 61 # If so, the updated path is stored in $new_path.
 62 # $1: The path to check
 63 AC_DEFUN([UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN],
 64 [
 65   input_path=&quot;$1&quot;
 66   # Check if we need to convert this using DOS-style short mode. If the path
 67   # contains just simple characters, use it. Otherwise (spaces, weird characters),
 68   # take no chances and rewrite it.
 69   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
 70   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP @&lt;:@^-._/a-zA-Z0-9@:&gt;@`
 71   if test &quot;x$has_forbidden_chars&quot; != x; then
 72     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
 73     shortmode_path=`$CYGPATH -s -m -a &quot;$input_path&quot;`
 74     path_after_shortmode=`$CYGPATH -u &quot;$shortmode_path&quot;`
 75     if test &quot;x$path_after_shortmode&quot; != &quot;x$input_to_shortpath&quot;; then
 76       # Going to short mode and back again did indeed matter. Since short mode is
 77       # case insensitive, let&#39;s make it lowercase to improve readability.
 78       shortmode_path=`$ECHO &quot;$shortmode_path&quot; | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
 79       # Now convert it back to Unix-style (cygpath)
 80       input_path=`$CYGPATH -u &quot;$shortmode_path&quot;`
 81       new_path=&quot;$input_path&quot;
 82     fi
 83   fi
 84 
 85   test_cygdrive_prefix=`$ECHO $input_path | $GREP ^/cygdrive/`
 86   if test &quot;x$test_cygdrive_prefix&quot; = x; then
 87     # As a simple fix, exclude /usr/bin since it&#39;s not a real path.
 88     if test &quot;x`$ECHO $1 | $GREP ^/usr/bin/`&quot; = x; then
 89       # The path is in a Cygwin special directory (e.g. /home). We need this converted to
 90       # a path prefixed by /cygdrive for fixpath to work.
 91       new_path=&quot;$CYGWIN_ROOT_PATH$input_path&quot;
 92     fi
 93   fi
 94 ])
 95 
 96 # Helper function which possibly converts a path using DOS-style short mode.
 97 # If so, the updated path is stored in $new_path.
 98 # $1: The path to check
 99 AC_DEFUN([UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS],
100 [
101   input_path=&quot;$1&quot;
102   # Check if we need to convert this using DOS-style short mode. If the path
103   # contains just simple characters, use it. Otherwise (spaces, weird characters),
104   # take no chances and rewrite it.
105   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
106   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP @&lt;:@^-_/:a-zA-Z0-9@:&gt;@`
107   if test &quot;x$has_forbidden_chars&quot; != x; then
108     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
109     new_path=`cmd /c &quot;for %A in (\&quot;$input_path\&quot;) do @echo %~sA&quot;|$TR \\\\\\\\ / | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
110   fi
111 ])
112 
113 # Helper function which possibly converts a path using DOS-style short mode.
114 # If so, the updated path is stored in $new_path.
115 # $1: The path to check
116 AC_DEFUN([UTIL_MAKE_WINDOWS_SPACE_SAFE_WSL],
117 [
118   input_path=&quot;$1&quot;
119   # Check if we need to convert this using DOS-style short mode. If the path
120   # contains just simple characters, use it. Otherwise (spaces, weird characters),
121   # take no chances and rewrite it.
122   # Note: m4 eats our [], so we need to use @&lt;:@ and @:&gt;@ instead.
123   has_forbidden_chars=`$ECHO &quot;$input_path&quot; | $GREP [[^-_/:a-zA-Z0-9\\.]]`
124   if test &quot;x$has_forbidden_chars&quot; != x; then
125     # Now convert it to mixed DOS-style, short mode (no spaces, and / instead of \)
126     TOPDIR_windows=&quot;$TOPDIR&quot;
127     UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([TOPDIR_windows])
128     # First convert to Windows path to make input valid for cmd
129     UTIL_REWRITE_AS_WINDOWS_MIXED_PATH([input_path])
130     # Reset PATH since it can contain a mix of WSL/linux paths and Windows paths from VS,
131     # which, in combination with WSLENV, will make the WSL layer complain
132     old_path=&quot;$PATH&quot;
133     PATH=
134     new_path=`$CMD /c $TOPDIR_windows/make/scripts/windowsShortName.bat &quot;$input_path&quot; \
135         | $SED -e &#39;s|\r||g&#39; \
136         | $TR \\\\\\\\ / | $TR &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39; &#39;abcdefghijklmnopqrstuvwxyz&#39;`
137     # Rewrite back to unix style
138     PATH=&quot;$old_path&quot;
139     UTIL_REWRITE_AS_UNIX_PATH([new_path])
140   fi
141 ])
142 
143 # FIXME: The UTIL_FIXUP_*_CYGWIN/MSYS is most likely too convoluted
144 # and could probably be heavily simplified. However, all changes in this
145 # area tend to need lot of testing in different scenarios, and in lack of
146 # proper unit testing, cleaning this up has not been deemed worth the effort
147 # at the moment.
148 
149 AC_DEFUN([UTIL_FIXUP_PATH_CYGWIN],
150 [
151   # Input might be given as Windows format, start by converting to
152   # unix format.
153   path=&quot;[$]$1&quot;
154   new_path=`$CYGPATH -u &quot;$path&quot;`
155 
156   UTIL_ABSOLUTE_PATH(new_path)
157 
158   # Cygwin tries to hide some aspects of the Windows file system, such that binaries are
159   # named .exe but called without that suffix. Therefore, &quot;foo&quot; and &quot;foo.exe&quot; are considered
160   # the same file, most of the time (as in &quot;test -f&quot;). But not when running cygpath -s, then
161   # &quot;foo.exe&quot; is OK but &quot;foo&quot; is an error.
162   #
163   # This test is therefore slightly more accurate than &quot;test -f&quot; to check for file precense.
164   # It is also a way to make sure we got the proper file name for the real test later on.
165   test_shortpath=`$CYGPATH -s -m &quot;$new_path&quot; 2&gt; /dev/null`
166   if test &quot;x$test_shortpath&quot; = x; then
167     AC_MSG_NOTICE([The path of $1, which resolves as &quot;$path&quot;, is invalid.])
168     AC_MSG_ERROR([Cannot locate the the path of $1])
169   fi
170 
171   # Call helper function which possibly converts this using DOS-style short mode.
172   # If so, the updated path is stored in $new_path.
173   UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$new_path])
174 
175   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
176     $1=&quot;$new_path&quot;
177     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
178   fi
179 ])
180 
181 AC_DEFUN([UTIL_FIXUP_PATH_MSYS],
182 [
183   path=&quot;[$]$1&quot;
184   has_colon=`$ECHO $path | $GREP ^.:`
185   new_path=&quot;$path&quot;
186   if test &quot;x$has_colon&quot; = x; then
187     # Not in mixed or Windows style, start by that.
188     new_path=`cmd //c echo $path`
189   fi
190 
191   UTIL_ABSOLUTE_PATH(new_path)
192 
193   UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])
194   UTIL_REWRITE_AS_UNIX_PATH(new_path)
195   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
196     $1=&quot;$new_path&quot;
197     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
198   fi
199 
200   # Save the first 10 bytes of this path to the storage, so fixpath can work.
201   all_fixpath_prefixes=(&quot;${all_fixpath_prefixes@&lt;:@@@:&gt;@}&quot; &quot;${new_path:0:10}&quot;)
202 ])
203 
204 AC_DEFUN([UTIL_FIXUP_PATH_WSL],
205 [
206   # Input might be given as Windows format, start by converting to
207   # unix format.
208   new_path=&quot;[$]$1&quot;
209   UTIL_REWRITE_AS_UNIX_PATH([new_path])
210 
211   UTIL_ABSOLUTE_PATH(new_path)
212 
213   # Call helper function which possibly converts this using DOS-style short mode.
214   # If so, the updated path is stored in $new_path.
215   UTIL_MAKE_WINDOWS_SPACE_SAFE_WSL([$new_path])
216 
217   if test &quot;x$path&quot; != &quot;x$new_path&quot;; then
218     $1=&quot;$new_path&quot;
219     AC_MSG_NOTICE([Rewriting $1 to &quot;$new_path&quot;])
220   fi
221 ])
222 
223 AC_DEFUN([UTIL_FIXUP_EXECUTABLE_CYGWIN],
224 [
225   # First separate the path from the arguments. This will split at the first
226   # space.
227   complete=&quot;[$]$1&quot;
228   path=&quot;${complete%% *}&quot;
229   tmp=&quot;$complete EOL&quot;
230   arguments=&quot;${tmp#* }&quot;
231 
232   # Input might be given as Windows format, start by converting to
233   # unix format.
234   new_path=`$CYGPATH -u &quot;$path&quot;`
235 
236   # Now try to locate executable using which
237   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
238   # bat and cmd files are not always considered executable in cygwin causing which
239   # to not find them
240   if test &quot;x$new_path&quot; = x \
241       &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
242       &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
243     new_path=`$CYGPATH -u &quot;$path&quot;`
244   fi
245   if test &quot;x$new_path&quot; = x; then
246     # Oops. Which didn&#39;t find the executable.
247     # The splitting of arguments from the executable at a space might have been incorrect,
248     # since paths with space are more likely in Windows. Give it another try with the whole
249     # argument.
250     path=&quot;$complete&quot;
251     arguments=&quot;EOL&quot;
252     new_path=`$CYGPATH -u &quot;$path&quot;`
253     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
254     # bat and cmd files are not always considered executable in cygwin causing which
255     # to not find them
256     if test &quot;x$new_path&quot; = x \
257         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
258         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
259       new_path=`$CYGPATH -u &quot;$path&quot;`
260     fi
261     if test &quot;x$new_path&quot; = x; then
262       # It&#39;s still not found. Now this is an unrecoverable error.
263       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
264       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
265       if test &quot;x$has_space&quot; != x; then
266         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
267       fi
268       AC_MSG_ERROR([Cannot locate the the path of $1])
269     fi
270   fi
271 
272   # Cygwin tries to hide some aspects of the Windows file system, such that binaries are
273   # named .exe but called without that suffix. Therefore, &quot;foo&quot; and &quot;foo.exe&quot; are considered
274   # the same file, most of the time (as in &quot;test -f&quot;). But not when running cygpath -s, then
275   # &quot;foo.exe&quot; is OK but &quot;foo&quot; is an error.
276   #
277   # This test is therefore slightly more accurate than &quot;test -f&quot; to check for file presence.
278   # It is also a way to make sure we got the proper file name for the real test later on.
279   test_shortpath=`$CYGPATH -s -m &quot;$new_path&quot; 2&gt; /dev/null`
280   if test &quot;x$test_shortpath&quot; = x; then
281     # Short path failed, file does not exist as specified.
282     # Try adding .exe or .cmd
283     if test -f &quot;${new_path}.exe&quot;; then
284       input_to_shortpath=&quot;${new_path}.exe&quot;
285     elif test -f &quot;${new_path}.cmd&quot;; then
286       input_to_shortpath=&quot;${new_path}.cmd&quot;
287     else
288       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$new_path&quot;, is invalid.])
289       AC_MSG_NOTICE([Neither &quot;$new_path&quot; nor &quot;$new_path.exe/cmd&quot; can be found])
290       AC_MSG_ERROR([Cannot locate the the path of $1])
291     fi
292   else
293     input_to_shortpath=&quot;$new_path&quot;
294   fi
295 
296   # Call helper function which possibly converts this using DOS-style short mode.
297   # If so, the updated path is stored in $new_path.
298   new_path=&quot;$input_to_shortpath&quot;
299   UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$input_to_shortpath])
300   # remove trailing .exe if any
301   new_path=&quot;${new_path/%.exe/}&quot;
302 ])
303 
304 AC_DEFUN([UTIL_FIXUP_EXECUTABLE_MSYS],
305 [
306   # First separate the path from the arguments. This will split at the first
307   # space.
308   complete=&quot;[$]$1&quot;
309   path=&quot;${complete%% *}&quot;
310   tmp=&quot;$complete EOL&quot;
311   arguments=&quot;${tmp#* }&quot;
312 
313   # Input might be given as Windows format, start by converting to
314   # unix format.
315   new_path=&quot;$path&quot;
316   UTIL_REWRITE_AS_UNIX_PATH(new_path)
317 
318   # Now try to locate executable using which
319   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
320 
321   if test &quot;x$new_path&quot; = x; then
322     # Oops. Which didn&#39;t find the executable.
323     # The splitting of arguments from the executable at a space might have been incorrect,
324     # since paths with space are more likely in Windows. Give it another try with the whole
325     # argument.
326     path=&quot;$complete&quot;
327     arguments=&quot;EOL&quot;
328     new_path=&quot;$path&quot;
329     UTIL_REWRITE_AS_UNIX_PATH(new_path)
330 
331     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
332     # bat and cmd files are not always considered executable in MSYS causing which
333     # to not find them
334     if test &quot;x$new_path&quot; = x \
335         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
336         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
337       new_path=&quot;$path&quot;
338       UTIL_REWRITE_AS_UNIX_PATH(new_path)
339     fi
340 
341     if test &quot;x$new_path&quot; = x; then
342       # It&#39;s still not found. Now this is an unrecoverable error.
343       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
344       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
345       if test &quot;x$has_space&quot; != x; then
346         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
347       fi
348       AC_MSG_ERROR([Cannot locate the the path of $1])
349     fi
350   fi
351 
352   # Now new_path has a complete unix path to the binary
353   if test &quot;x`$ECHO $new_path | $GREP ^/bin/`&quot; != x; then
354     # Keep paths in /bin as-is, but remove trailing .exe if any
355     new_path=&quot;${new_path/%.exe/}&quot;
356     # Do not save /bin paths to all_fixpath_prefixes!
357   else
358     # Not in mixed or Windows style, start by that.
359     new_path=`cmd //c echo $new_path`
360     UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])
361     # Output is in $new_path
362     UTIL_REWRITE_AS_UNIX_PATH(new_path)
363     # remove trailing .exe if any
364     new_path=&quot;${new_path/%.exe/}&quot;
365 
366     # Save the first 10 bytes of this path to the storage, so fixpath can work.
367     all_fixpath_prefixes=(&quot;${all_fixpath_prefixes@&lt;:@@@:&gt;@}&quot; &quot;${new_path:0:10}&quot;)
368   fi
369 ])
370 
371 AC_DEFUN([UTIL_FIXUP_EXECUTABLE_WSL],
372 [
373   # First separate the path from the arguments. This will split at the first
374   # space.
375   complete=&quot;[$]$1&quot;
376   path=&quot;${complete%% *}&quot;
377   tmp=&quot;$complete EOL&quot;
378   arguments=&quot;${tmp#* }&quot;
379 
380   # Input might be given as Windows format, start by converting to
381   # unix format.
382   new_path=&quot;$path&quot;
383   UTIL_REWRITE_AS_UNIX_PATH([new_path])
384 
385   # Now try to locate executable using which
386   new_path_bak=&quot;$new_path&quot;
387   new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
388   # bat and cmd files are not considered executable in WSL
389   if test &quot;x$new_path&quot; = x \
390       &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
391       &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
392     new_path=&quot;$new_path_back&quot;
393   fi
394   if test &quot;x$new_path&quot; = x; then
395     # Oops. Which didn&#39;t find the executable.
396     # The splitting of arguments from the executable at a space might have been incorrect,
397     # since paths with space are more likely in Windows. Give it another try with the whole
398     # argument.
399     path=&quot;$complete&quot;
400     arguments=&quot;EOL&quot;
401     new_path=&quot;$path&quot;
402     UTIL_REWRITE_AS_UNIX_PATH([new_path])
403     new_path_bak=&quot;$new_path&quot;
404     new_path=`$WHICH &quot;$new_path&quot; 2&gt; /dev/null`
405     # bat and cmd files are not considered executable in WSL
406     if test &quot;x$new_path&quot; = x \
407         &amp;&amp; test &quot;x`$ECHO \&quot;$path\&quot; | $GREP -i -e \&quot;\\.bat$\&quot; -e \&quot;\\.cmd$\&quot;`&quot; != x \
408         &amp;&amp; test &quot;x`$LS \&quot;$path\&quot; 2&gt;/dev/null`&quot; != x; then
409       new_path=&quot;$new_path_bak&quot;
410     fi
411     if test &quot;x$new_path&quot; = x; then
412       # It&#39;s still not found. Now this is an unrecoverable error.
413       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$complete&quot;, is not found.])
414       has_space=`$ECHO &quot;$complete&quot; | $GREP &quot; &quot;`
415       if test &quot;x$has_space&quot; != x; then
416         AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])
417       fi
418       AC_MSG_ERROR([Cannot locate the the path of $1])
419     fi
420   fi
421 
422   # In WSL, suffixes must be present for Windows executables
423   if test ! -f &quot;$new_path&quot;; then
424     # Try adding .exe or .cmd
425     if test -f &quot;${new_path}.exe&quot;; then
426       input_to_shortpath=&quot;${new_path}.exe&quot;
427     elif test -f &quot;${new_path}.cmd&quot;; then
428       input_to_shortpath=&quot;${new_path}.cmd&quot;
429     else
430       AC_MSG_NOTICE([The path of $1, which resolves as &quot;$new_path&quot;, is invalid.])
431       AC_MSG_NOTICE([Neither &quot;$new_path&quot; nor &quot;$new_path.exe/cmd&quot; can be found])
432       AC_MSG_ERROR([Cannot locate the the path of $1])
433     fi
434   else
435     input_to_shortpath=&quot;$new_path&quot;
436   fi
437 
438   # Call helper function which possibly converts this using DOS-style short mode.
439   # If so, the updated path is stored in $new_path.
440   new_path=&quot;$input_to_shortpath&quot;
441   UTIL_MAKE_WINDOWS_SPACE_SAFE_WSL([$input_to_shortpath])
442 ])
443 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/classes/javax/swing/text/Utilities.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javax.swing.text;
  26 
  27 import java.awt.Component;
  28 import java.awt.Rectangle;
  29 import java.awt.Graphics;
  30 import java.awt.FontMetrics;
  31 import java.awt.Shape;
  32 import java.awt.Graphics2D;
  33 import java.awt.font.TextAttribute;
  34 import java.awt.geom.Rectangle2D;
  35 
  36 import java.text.*;
  37 import javax.swing.JComponent;
  38 import javax.swing.SwingConstants;
  39 import javax.swing.text.ParagraphView.Row;
  40 import sun.swing.SwingUtilities2;
  41 import static sun.swing.SwingUtilities2.drawChars;
  42 import static sun.swing.SwingUtilities2.getFontCharWidth;
  43 import static sun.swing.SwingUtilities2.getFontCharsWidth;
  44 
  45 /**
  46  * A collection of methods to deal with various text
  47  * related activities.
  48  *
  49  * @author  Timothy Prinzing
  50  */
  51 public class Utilities {
  52     /**
  53      * If &lt;code&gt;view&lt;/code&gt;&#39;s container is a &lt;code&gt;JComponent&lt;/code&gt; it
  54      * is returned, after casting.
  55      */
  56     static JComponent getJComponent(View view) {
  57         if (view != null) {
  58             Component component = view.getContainer();
  59             if (component instanceof JComponent) {
  60                 return (JComponent)component;
  61             }
  62         }
  63         return null;
  64     }
  65 
  66     /**
  67      * Draws the given text, expanding any tabs that are contained
  68      * using the given tab expansion technique.  This particular
  69      * implementation renders in a 1.1 style coordinate system
  70      * where ints are used and 72dpi is assumed.
  71      *
  72      * @param s  the source of the text
  73      * @param x  the X origin &amp;gt;= 0
  74      * @param y  the Y origin &amp;gt;= 0
  75      * @param g  the graphics context
  76      * @param e  how to expand the tabs.  If this value is null,
  77      *   tabs will be expanded as a space character.
  78      * @param startOffset starting offset of the text in the document &amp;gt;= 0
  79      * @return  the X location at the end of the rendered text
  80      *
  81      * @deprecated replaced by
  82      * {@link #drawTabbedText(Segment, float, float, Graphics2D, TabExpander, int)}
  83      */
  84     @Deprecated(since = &quot;9&quot;)
  85     public static final int drawTabbedText(Segment s, int x, int y, Graphics g,
  86                                            TabExpander e, int startOffset) {
  87         return drawTabbedText(null, s, x, y, g, e, startOffset);
  88     }
  89 
  90     /**
  91      * Draws the given text, expanding any tabs that are contained
  92      * using the given tab expansion technique.
  93      *
  94      * @param s  the source of the text
  95      * @param x  the X origin {@code &gt;= 0}
  96      * @param y  the Y origin {@code &gt;= 0}
  97      * @param g  the graphics context
  98      * @param e  how to expand the tabs.  If this value is null,
  99      *           tabs will be expanded as a space character.
 100      * @param startOffset starting offset of the text in the document {@code &gt;= 0}
 101      * @return  the X location at the end of the rendered text
 102      *
 103      * @since 9
 104      */
 105     public static final float drawTabbedText(Segment s, float x, float y,
 106                                              Graphics2D g,
 107                                              TabExpander e,
 108                                              int startOffset)
 109     {
 110         return drawTabbedText(null, s, x, y, g, e, startOffset, null, true);
 111     }
 112 
 113     /**
 114      * Draws the given text, expanding any tabs that are contained
 115      * using the given tab expansion technique.  This particular
 116      * implementation renders in a 1.1 style coordinate system
 117      * where ints are used and 72dpi is assumed.
 118      *
 119      * @param view View requesting rendering, may be null.
 120      * @param s  the source of the text
 121      * @param x  the X origin &amp;gt;= 0
 122      * @param y  the Y origin &amp;gt;= 0
 123      * @param g  the graphics context
 124      * @param e  how to expand the tabs.  If this value is null,
 125      *   tabs will be expanded as a space character.
 126      * @param startOffset starting offset of the text in the document &amp;gt;= 0
 127      * @return  the X location at the end of the rendered text
 128      */
 129     static final int drawTabbedText(View view,
 130                                 Segment s, int x, int y, Graphics g,
 131                                 TabExpander e, int startOffset) {
 132         return drawTabbedText(view, s, x, y, g, e, startOffset, null);
 133     }
 134 
 135     // In addition to the previous method it can extend spaces for
 136     // justification.
 137     //
 138     // all params are the same as in the preious method except the last
 139     // one:
 140     // @param justificationData justificationData for the row.
 141     // if null not justification is needed
 142     static final int drawTabbedText(View view,
 143                                 Segment s, int x, int y, Graphics g,
 144                                 TabExpander e, int startOffset,
 145                                 int [] justificationData) {
 146         return (int) drawTabbedText(view, s, x, y, g, e, startOffset,
 147                                     justificationData, false);
 148     }
 149 
 150     static final float drawTabbedText(View view,
 151                                 Segment s, float x, float y, Graphics g,
 152                                 TabExpander e, int startOffset,
 153                                 int [] justificationData,
 154                                 boolean useFPAPI)
 155     {
 156         JComponent component = getJComponent(view);
 157         FontMetrics metrics = SwingUtilities2.getFontMetrics(component, g);
 158         float nextX = x;
 159         char[] txt = s.array;
 160         int txtOffset = s.offset;
 161         int flushLen = 0;
 162         int flushIndex = s.offset;
 163         int spaceAddon = 0;
 164         int spaceAddonLeftoverEnd = -1;
 165         int startJustifiableContent = 0;
 166         int endJustifiableContent = 0;
 167         if (justificationData != null) {
 168             int offset = - startOffset + txtOffset;
 169             View parent = null;
 170             if (view != null
 171                   &amp;&amp; (parent = view.getParent()) != null) {
 172                 offset += parent.getStartOffset();
 173             }
 174             spaceAddon =
 175                 justificationData[Row.SPACE_ADDON];
 176             spaceAddonLeftoverEnd =
 177                 justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
 178             startJustifiableContent =
 179                 justificationData[Row.START_JUSTIFIABLE] + offset;
 180             endJustifiableContent =
 181                 justificationData[Row.END_JUSTIFIABLE] + offset;
 182         }
 183         int n = s.offset + s.count;
 184         for (int i = txtOffset; i &lt; n; i++) {
 185             if (txt[i] == &#39;\t&#39;
 186                 || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
 187                     &amp;&amp; (txt[i] == &#39; &#39;)
 188                     &amp;&amp; startJustifiableContent &lt;= i
 189                     &amp;&amp; i &lt;= endJustifiableContent
 190                     )) {
 191                 if (flushLen &gt; 0) {
 192                     nextX = drawChars(component, g, txt, flushIndex, flushLen, x, y);
 193                     flushLen = 0;
 194                 }
 195                 flushIndex = i + 1;
 196                 if (txt[i] == &#39;\t&#39;) {
 197                     if (e != null) {
 198                         nextX = e.nextTabStop(nextX, startOffset + i - txtOffset);
 199                     } else {
 200                         nextX += getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 201                     }
 202                 } else if (txt[i] == &#39; &#39;) {
 203                     float spaceWidth = getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 204                     nextX += spaceWidth + spaceAddon;
 205                     if (i &lt;= spaceAddonLeftoverEnd) {
 206                         nextX++;
 207                     }
 208                 }
 209                 x = nextX;
 210             } else if ((txt[i] == &#39;\n&#39;) || (txt[i] == &#39;\r&#39;)) {
 211                 if (flushLen &gt; 0) {
 212                     nextX = drawChars(component, g, txt, flushIndex, flushLen,
 213                                       x, y, useFPAPI);
 214                     flushLen = 0;
 215                 }
 216                 flushIndex = i + 1;
 217                 x = nextX;
 218             } else {
 219                 flushLen += 1;
 220             }
 221         }
 222         if (flushLen &gt; 0) {
 223             nextX = drawChars(component, g,txt, flushIndex, flushLen, x, y, useFPAPI);
 224         }
 225         return nextX;
 226     }
 227 
 228     /**
 229      * Determines the width of the given segment of text taking tabs
 230      * into consideration.  This is implemented in a 1.1 style coordinate
 231      * system where ints are used and 72dpi is assumed.
 232      *
 233      * @param s  the source of the text
 234      * @param metrics the font metrics to use for the calculation
 235      * @param x  the X origin &amp;gt;= 0
 236      * @param e  how to expand the tabs.  If this value is null,
 237      *   tabs will be expanded as a space character.
 238      * @param startOffset starting offset of the text in the document &amp;gt;= 0
 239      * @return  the width of the text
 240      *
 241      * @deprecated replaced by
 242      *     {@link #getTabbedTextWidth(Segment, FontMetrics, float, TabExpander, int)}
 243      */
 244     @Deprecated(since = &quot;9&quot;)
 245     public static final int getTabbedTextWidth(Segment s, FontMetrics metrics, int x,
 246                                                TabExpander e, int startOffset) {
 247         return getTabbedTextWidth(null, s, metrics, x, e, startOffset, null);
 248     }
 249 
 250     /**
 251      * Determines the width of the given segment of text taking tabs
 252      * into consideration.
 253      *
 254      * @param s  the source of the text
 255      * @param metrics the font metrics to use for the calculation
 256      * @param x  the X origin {@code &gt;= 0}
 257      * @param e  how to expand the tabs.  If this value is null,
 258      *   tabs will be expanded as a space character.
 259      * @param startOffset starting offset of the text in the document {@code &gt;= 0}
 260      * @return  the width of the text
 261      *
 262      * @since 9
 263      */
 264     public static final float getTabbedTextWidth(Segment s, FontMetrics metrics,
 265                                                  float x, TabExpander e,
 266                                                  int startOffset) {
 267         return getTabbedTextWidth(null, s, metrics, x, e, startOffset, null);
 268     }
 269 
 270     // In addition to the previous method it can extend spaces for
 271     // justification.
 272     //
 273     // all params are the same as in the preious method except the last
 274     // one:
 275     // @param justificationData justificationData for the row.
 276     // if null not justification is needed
 277     static final int getTabbedTextWidth(View view, Segment s,
 278                                         FontMetrics metrics, int x,
 279                                         TabExpander e, int startOffset,
 280                                         int[] justificationData)
 281     {
 282         return (int) getTabbedTextWidth(view, s, metrics, x, e, startOffset,
 283                                         justificationData, false);
 284 
 285     }
 286 
 287     static final float getTabbedTextWidth(View view, Segment s,
 288                                         FontMetrics metrics, float x,
 289                                         TabExpander e, int startOffset,
 290                                         int[] justificationData)
 291     {
 292         return  getTabbedTextWidth(view, s, metrics, x, e, startOffset,
 293                                    justificationData, true);
 294 
 295     }
 296 
 297     static final float getTabbedTextWidth(View view, Segment s,
 298                                         FontMetrics metrics, float x,
 299                                         TabExpander e, int startOffset,
 300                                         int[] justificationData,
 301                                         boolean useFPAPI) {
 302         float nextX = x;
 303         char[] txt = s.array;
 304         int txtOffset = s.offset;
 305         int n = s.offset + s.count;
 306         int charCount = 0;
 307         int spaceAddon = 0;
 308         int spaceAddonLeftoverEnd = -1;
 309         int startJustifiableContent = 0;
 310         int endJustifiableContent = 0;
 311         if (justificationData != null) {
 312             int offset = - startOffset + txtOffset;
 313             View parent = null;
 314             if (view != null
 315                   &amp;&amp; (parent = view.getParent()) != null) {
 316                 offset += parent.getStartOffset();
 317             }
 318             spaceAddon =
 319                 justificationData[Row.SPACE_ADDON];
 320             spaceAddonLeftoverEnd =
 321                 justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
 322             startJustifiableContent =
 323                 justificationData[Row.START_JUSTIFIABLE] + offset;
 324             endJustifiableContent =
 325                 justificationData[Row.END_JUSTIFIABLE] + offset;
 326         }
 327 
 328         for (int i = txtOffset; i &lt; n; i++) {
 329             if (txt[i] == &#39;\t&#39;
 330                 || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
 331                     &amp;&amp; (txt[i] == &#39; &#39;)
 332                     &amp;&amp; startJustifiableContent &lt;= i
 333                     &amp;&amp; i &lt;= endJustifiableContent
 334                     )) {
 335                 nextX += metrics.charsWidth(txt, i-charCount, charCount);
 336                 charCount = 0;
 337                 if (txt[i] == &#39;\t&#39;) {
 338                     if (e != null) {
 339                         nextX = e.nextTabStop(nextX, startOffset + i - txtOffset);
 340                     } else {
 341                         nextX += getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 342                     }
 343                 } else if (txt[i] == &#39; &#39;) {
 344                     float spaceWidth = getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 345                     nextX += spaceWidth + spaceAddon;
 346                     if (i &lt;= spaceAddonLeftoverEnd) {
 347                         nextX++;
 348                     }
 349                 }
 350             } else if(txt[i] == &#39;\n&#39;) {
 351             // Ignore newlines, they take up space and we shouldn&#39;t be
 352             // counting them.
 353                 nextX += getFontCharsWidth(txt, i - charCount, charCount,
 354                                            metrics, useFPAPI);
 355                 charCount = 0;
 356             } else {
 357                 charCount++;
 358         }
 359         }
 360         nextX += getFontCharsWidth(txt, n - charCount, charCount,
 361                                    metrics, useFPAPI);
 362         return nextX - x;
 363     }
 364 
 365     /**
 366      * Determines the relative offset into the given text that
 367      * best represents the given span in the view coordinate
 368      * system.  This is implemented in a 1.1 style coordinate
 369      * system where ints are used and 72dpi is assumed.
 370      *
 371      * @param s  the source of the text
 372      * @param metrics the font metrics to use for the calculation
 373      * @param x0 the starting view location representing the start
 374      *   of the given text &amp;gt;= 0.
 375      * @param x  the target view location to translate to an
 376      *   offset into the text &amp;gt;= 0.
 377      * @param e  how to expand the tabs.  If this value is null,
 378      *   tabs will be expanded as a space character.
 379      * @param startOffset starting offset of the text in the document &amp;gt;= 0
 380      * @return  the offset into the text &amp;gt;= 0
 381      *
 382      * @deprecated replaced by
 383      *     {@link #getTabbedTextOffset(Segment, FontMetrics, float, float,
 384      *                                 TabExpander, int, boolean)}
 385      */
 386     @Deprecated(since = &quot;9&quot;)
 387     public static final int getTabbedTextOffset(Segment s, FontMetrics metrics,
 388                                              int x0, int x, TabExpander e,
 389                                              int startOffset) {
 390         return getTabbedTextOffset(s, metrics, x0, x, e, startOffset, true);
 391     }
 392 
 393     static final int getTabbedTextOffset(View view, Segment s, FontMetrics metrics,
 394                                          int x0, int x, TabExpander e,
 395                                          int startOffset,
 396                                          int[] justificationData) {
 397         return getTabbedTextOffset(view, s, metrics, x0, x, e, startOffset, true,
 398                                    justificationData, false);
 399     }
 400 
 401     static final int getTabbedTextOffset(View view, Segment s, FontMetrics metrics,
 402                                          float x0, float x, TabExpander e,
 403                                          int startOffset,
 404                                          int[] justificationData) {
 405         return getTabbedTextOffset(view, s, metrics, x0, x, e, startOffset, true,
 406                 justificationData, true);
 407     }
 408 
 409     /**
 410      * Determines the relative offset into the given text that
 411      * best represents the given span in the view coordinate
 412      * system.
 413      *
 414      * @param s  the source of the text
 415      * @param metrics the font metrics to use for the calculation
 416      * @param x0 the starting view location representing the start
 417      *   of the given text &amp;gt;= 0.
 418      * @param x  the target view location to translate to an
 419      *   offset into the text &amp;gt;= 0.
 420      * @param e  how to expand the tabs.  If this value is null,
 421      *   tabs will be expanded as a space character.
 422      * @param startOffset starting offset of the text in the document &amp;gt;= 0
 423      * @param round whether or not to round
 424      * @return  the offset into the text &amp;gt;= 0
 425      *
 426      * @deprecated replaced by
 427      *     {@link #getTabbedTextOffset(Segment, FontMetrics, float, float,
 428      *                                 TabExpander, int, boolean)}
 429      */
 430     @Deprecated(since = &quot;9&quot;)
 431     public static final int getTabbedTextOffset(Segment s,
 432                                                 FontMetrics metrics,
 433                                                 int x0, int x, TabExpander e,
 434                                                 int startOffset,
 435                                                 boolean round) {
 436         return getTabbedTextOffset(null, s, metrics, x0, x, e, startOffset,
 437                                    round, null, false);
 438     }
 439 
 440     /**
 441      * Determines the relative offset into the given text that
 442      * best represents the given span in the view coordinate
 443      * system.
 444      *
 445      * @param s  the source of the text
 446      * @param metrics the font metrics to use for the calculation
 447      * @param x0 the starting view location representing the start
 448      *   of the given text {@code &gt;= 0}.
 449      * @param x  the target view location to translate to an
 450      *   offset into the text {@code &gt;= 0}.
 451      * @param e  how to expand the tabs.  If this value is null,
 452      *   tabs will be expanded as a space character.
 453      * @param startOffset starting offset of the text in the document {@code &gt;= 0}
 454      * @param round whether or not to round
 455      * @return  the offset into the text {@code &gt;= 0}
 456      *
 457      * @since 9
 458      */
 459     public static final int getTabbedTextOffset(Segment s,
 460                                                 FontMetrics metrics,
 461                                                 float x0, float x,
 462                                                 TabExpander e,
 463                                                 int startOffset,
 464                                                 boolean round)
 465     {
 466         return getTabbedTextOffset(null, s, metrics, x0, x, e,
 467                                    startOffset, round, null, true);
 468     }
 469 
 470     // In addition to the previous method it can extend spaces for
 471     // justification.
 472     //
 473     // all params are the same as in the preious method except the last
 474     // one:
 475     // @param justificationData justificationData for the row.
 476     // if null not justification is needed
 477     static final int getTabbedTextOffset(View view,
 478                                          Segment s,
 479                                          FontMetrics metrics,
 480                                          float x0, float x, TabExpander e,
 481                                          int startOffset,
 482                                          boolean round,
 483                                          int[] justificationData,
 484                                          boolean useFPAPI) {
 485         if (x0 &gt;= x) {
 486             // x before x0, return.
 487             return 0;
 488         }
 489         float nextX = x0;
 490         // s may be a shared segment, so it is copied prior to calling
 491         // the tab expander
 492         char[] txt = s.array;
 493         int txtOffset = s.offset;
 494         int txtCount = s.count;
 495         int spaceAddon = 0 ;
 496         int spaceAddonLeftoverEnd = -1;
 497         int startJustifiableContent = 0 ;
 498         int endJustifiableContent = 0;
 499         if (justificationData != null) {
 500             int offset = - startOffset + txtOffset;
 501             View parent = null;
 502             if (view != null
 503                   &amp;&amp; (parent = view.getParent()) != null) {
 504                 offset += parent.getStartOffset();
 505             }
 506             spaceAddon =
 507                 justificationData[Row.SPACE_ADDON];
 508             spaceAddonLeftoverEnd =
 509                 justificationData[Row.SPACE_ADDON_LEFTOVER_END] + offset;
 510             startJustifiableContent =
 511                 justificationData[Row.START_JUSTIFIABLE] + offset;
 512             endJustifiableContent =
 513                 justificationData[Row.END_JUSTIFIABLE] + offset;
 514         }
 515         int n = s.offset + s.count;
 516         for (int i = s.offset; i &lt; n; i++) {
 517             if (txt[i] == &#39;\t&#39;
 518                 || ((spaceAddon != 0 || i &lt;= spaceAddonLeftoverEnd)
 519                     &amp;&amp; (txt[i] == &#39; &#39;)
 520                     &amp;&amp; startJustifiableContent &lt;= i
 521                     &amp;&amp; i &lt;= endJustifiableContent
 522                     )){
 523                 if (txt[i] == &#39;\t&#39;) {
 524                     if (e != null) {
 525                         nextX = e.nextTabStop(nextX, startOffset + i - txtOffset);
 526                     } else {
 527                         nextX += getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 528                     }
 529                 } else if (txt[i] == &#39; &#39;) {
 530                     nextX += getFontCharWidth(&#39; &#39;, metrics, useFPAPI);
 531                     nextX += spaceAddon;
 532                     if (i &lt;= spaceAddonLeftoverEnd) {
 533                         nextX++;
 534                     }
 535                 }
 536             } else {
 537                 nextX += getFontCharWidth(txt[i], metrics, useFPAPI);
 538             }
 539             if (x &lt; nextX) {
 540                 // found the hit position... return the appropriate side
 541                 int offset;
 542 
 543                 // the length of the string measured as a whole may differ from
 544                 // the sum of individual character lengths, for example if
 545                 // fractional metrics are enabled; and we must guard from this.
 546                 if (round) {
 547                     offset = i + 1 - txtOffset;
 548 
 549                     float width = getFontCharsWidth(txt, txtOffset, offset,
 550                                                     metrics, useFPAPI);
 551                     float span = x - x0;
 552 
 553                     if (span &lt; width) {
 554                         while (offset &gt; 0) {
 555                             float charsWidth = getFontCharsWidth(txt, txtOffset,
 556                                     offset - 1, metrics, useFPAPI);
 557                             float nextWidth = offset &gt; 1 ? charsWidth : 0;
 558 
 559                             if (span &gt;= nextWidth) {
 560                                 if (span - nextWidth &lt; width - span) {
 561                                     offset--;
 562                                 }
 563 
 564                                 break;
 565                             }
 566 
 567                             width = nextWidth;
 568                             offset--;
 569                         }
 570                     }
 571                 } else {
 572                     offset = i - txtOffset;
 573 
 574                     while (offset &gt; 0 &amp;&amp; getFontCharsWidth(txt, txtOffset, offset,
 575                                                            metrics, useFPAPI)
 576                             &gt; (x - x0)) {
 577                         offset--;
 578                     }
 579                 }
 580 
 581                 return offset;
 582             }
 583         }
 584 
 585         // didn&#39;t find, return end offset
 586         return txtCount;
 587     }
 588 
 589     /**
 590      * Determine where to break the given text to fit
 591      * within the given span. This tries to find a word boundary.
 592      * @param s  the source of the text
 593      * @param metrics the font metrics to use for the calculation
 594      * @param x0 the starting view location representing the start
 595      *   of the given text.
 596      * @param x  the target view location to translate to an
 597      *   offset into the text.
 598      * @param e  how to expand the tabs.  If this value is null,
 599      *   tabs will be expanded as a space character.
 600      * @param startOffset starting offset in the document of the text
 601      * @return  the offset into the given text
 602      *
 603      * @deprecated replaced by
 604      *     {@link #getBreakLocation(Segment, FontMetrics, float, float,
 605      *                              TabExpander, int)}
 606      */
 607     @Deprecated(since = &quot;9&quot;)
 608     public static final int getBreakLocation(Segment s, FontMetrics metrics,
 609                                              int x0, int x, TabExpander e,
 610                                              int startOffset) {
 611         return getBreakLocation(s, metrics, x0, x, e, startOffset, false);
 612     }
 613 
 614     static final int getBreakLocation(Segment s, FontMetrics metrics,
 615                                       float x0, float x, TabExpander e,
 616                                       int startOffset, boolean useFPIAPI) {
 617         char[] txt = s.array;
 618         int txtOffset = s.offset;
 619         int txtCount = s.count;
 620         int index = getTabbedTextOffset(null, s, metrics, x0, x, e, startOffset,
 621                                         false, null, useFPIAPI);
 622 
 623         if (index &gt;= txtCount - 1) {
 624             return txtCount;
 625         }
 626 
 627         for (int i = txtOffset + index; i &gt;= txtOffset; i--) {
 628             char ch = txt[i];
 629             if (ch &lt; 256) {
 630                 // break on whitespace
 631                 if (Character.isWhitespace(ch)) {
 632                     index = i - txtOffset + 1;
 633                     break;
 634                 }
 635             } else {
 636                 // a multibyte char found; use BreakIterator to find line break
 637                 BreakIterator bit = BreakIterator.getLineInstance();
 638                 bit.setText(s);
 639                 int breakPos = bit.preceding(i + 1);
 640                 if (breakPos &gt; txtOffset) {
 641                     index = breakPos - txtOffset;
 642                 }
 643                 break;
 644             }
 645         }
 646         return index;
 647     }
 648 
 649     /**
 650      * Determine where to break the given text to fit
 651      * within the given span. This tries to find a word boundary.
 652      * @param s  the source of the text
 653      * @param metrics the font metrics to use for the calculation
 654      * @param x0 the starting view location representing the start
 655      *        of the given text.
 656      * @param x  the target view location to translate to an
 657      *        offset into the text.
 658      * @param e  how to expand the tabs.  If this value is null,
 659      *        tabs will be expanded as a space character.
 660      * @param startOffset starting offset in the document of the text
 661      * @return  the offset into the given text
 662      *
 663      * @since 9
 664      */
 665     public static final int getBreakLocation(Segment s, FontMetrics metrics,
 666                                              float x0, float x, TabExpander e,
 667                                              int startOffset) {
 668         return getBreakLocation(s, metrics, x0, x, e, startOffset, true);
 669     }
 670 
 671     /**
 672      * Determines the starting row model position of the row that contains
 673      * the specified model position.  The component given must have a
 674      * size to compute the result.  If the component doesn&#39;t have a size
 675      * a value of -1 will be returned.
 676      *
 677      * @param c the editor
 678      * @param offs the offset in the document &amp;gt;= 0
 679      * @return the position &amp;gt;= 0 if the request can be computed, otherwise
 680      *  a value of -1 will be returned.
 681      * @exception BadLocationException if the offset is out of range
 682      */
 683     @SuppressWarnings(&quot;deprecation&quot;)
 684     public static final int getRowStart(JTextComponent c, int offs) throws BadLocationException {
 685         Rectangle r = c.modelToView(offs);
 686         if (r == null) {
 687             return -1;
 688         }
 689         int lastOffs = offs;
 690         int y = r.y;
 691         while ((r != null) &amp;&amp; (y == r.y)) {
 692             // Skip invisible elements
 693             if(r.height !=0) {
 694                 offs = lastOffs;
 695             }
 696             lastOffs -= 1;
 697             r = (lastOffs &gt;= 0) ? c.modelToView(lastOffs) : null;
 698         }
 699         return offs;
 700     }
 701 
 702     /**
 703      * Determines the ending row model position of the row that contains
 704      * the specified model position.  The component given must have a
 705      * size to compute the result.  If the component doesn&#39;t have a size
 706      * a value of -1 will be returned.
 707      *
 708      * @param c the editor
 709      * @param offs the offset in the document &amp;gt;= 0
 710      * @return the position &amp;gt;= 0 if the request can be computed, otherwise
 711      *  a value of -1 will be returned.
 712      * @exception BadLocationException if the offset is out of range
 713      */
 714     @SuppressWarnings(&quot;deprecation&quot;)
 715     public static final int getRowEnd(JTextComponent c, int offs) throws BadLocationException {
 716         Rectangle2D r = c.modelToView2D(offs);
 717         if (r == null) {
 718             return -1;
 719         }
 720         int n = c.getDocument().getLength();
 721         int lastOffs = offs;
 722         double y = r.getY();
 723         while ((r != null) &amp;&amp; (y == r.getY())) {
 724             // Skip invisible elements
 725             if (r.getHeight() !=0) {
 726                 offs = lastOffs;
 727             }
 728             lastOffs += 1;
 729             r = (lastOffs &lt;= n) ? c.modelToView(lastOffs) : null;
 730         }
 731         return offs;
 732     }
 733 
 734     /**
 735      * Determines the position in the model that is closest to the given
 736      * view location in the row above.  The component given must have a
 737      * size to compute the result.  If the component doesn&#39;t have a size
 738      * a value of -1 will be returned.
 739      *
 740      * @param c the editor
 741      * @param offs the offset in the document &amp;gt;= 0
 742      * @param x the X coordinate &amp;gt;= 0
 743      * @return the position &amp;gt;= 0 if the request can be computed, otherwise
 744      *  a value of -1 will be returned.
 745      * @exception BadLocationException if the offset is out of range
 746      *
 747      * @deprecated replaced by
 748      *     {@link #getPositionAbove(JTextComponent, int, float)}
 749      */
 750     @Deprecated(since = &quot;9&quot;)
 751     public static final int getPositionAbove(JTextComponent c, int offs, int x)
 752             throws BadLocationException
 753     {
 754         return getPositionAbove(c, offs, x, false);
 755     }
 756 
 757     @SuppressWarnings(&quot;deprecation&quot;)
 758     static final int getPositionAbove(JTextComponent c, int offs, float x,
 759                                       boolean useFPAPI) throws BadLocationException
 760     {
 761         int lastOffs = getRowStart(c, offs) - 1;
 762         if (lastOffs &lt; 0) {
 763             return -1;
 764         }
 765         double bestSpan = Integer.MAX_VALUE;
 766         double y = 0;
 767         Rectangle2D r = null;
 768         if (lastOffs &gt;= 0) {
 769             r = useFPAPI ? c.modelToView2D(lastOffs) : c.modelToView(lastOffs);
 770             y = r.getY();
 771         }
 772         while ((r != null) &amp;&amp; (y == r.getY())) {
 773             double span = Math.abs(r.getX() - x);
 774             if (span &lt; bestSpan) {
 775                 offs = lastOffs;
 776                 bestSpan = span;
 777             }
 778             lastOffs -= 1;
 779 
 780             if ((lastOffs &gt;= 0)) {
 781                 r = useFPAPI ? c.modelToView2D(lastOffs) : c.modelToView(lastOffs);
 782             } else {
 783                 r = null;
 784             }
 785         }
 786         return offs;
 787     }
 788 
 789     /**
 790      * Determines the position in the model that is closest to the given
 791      * view location in the row above.  The component given must have a
 792      * size to compute the result.  If the component doesn&#39;t have a size
 793      * a value of -1 will be returned.
 794      *
 795      * @param c the editor
 796      * @param offs the offset in the document {@code &gt;= 0}
 797      * @param x the X coordinate {@code &gt;= 0}
 798      * @return the position {@code &gt;= 0} if the request can be computed, otherwise
 799      *  a value of -1 will be returned.
 800      * @exception BadLocationException if the offset is out of range
 801      *
 802      * @since 9
 803      */
 804     public static final int getPositionAbove(JTextComponent c, int offs, float x)
 805             throws BadLocationException {
 806         return getPositionAbove(c, offs, x, true);
 807     }
 808 
 809     /**
 810      * Determines the position in the model that is closest to the given
 811      * view location in the row below.  The component given must have a
 812      * size to compute the result.  If the component doesn&#39;t have a size
 813      * a value of -1 will be returned.
 814      *
 815      * @param c the editor
 816      * @param offs the offset in the document &amp;gt;= 0
 817      * @param x the X coordinate &amp;gt;= 0
 818      * @return the position &amp;gt;= 0 if the request can be computed, otherwise
 819      *  a value of -1 will be returned.
 820      * @exception BadLocationException if the offset is out of range
 821      *
 822      * @deprecated replaced by
 823      *     {@link #getPositionBelow(JTextComponent, int, float)}
 824      */
 825     @Deprecated(since = &quot;9&quot;)
 826     public static final int getPositionBelow(JTextComponent c, int offs, int x)
 827             throws BadLocationException
 828     {
 829         return getPositionBelow(c, offs, x, false);
 830     }
 831 
 832     @SuppressWarnings(&quot;deprecation&quot;)
 833     static final int getPositionBelow(JTextComponent c, int offs, float x,
 834                                       boolean useFPAPI) throws BadLocationException
 835     {
 836         int lastOffs = getRowEnd(c, offs) + 1;
 837         if (lastOffs &lt;= 0) {
 838             return -1;
 839         }
 840         double bestSpan = Integer.MAX_VALUE;
 841         int n = c.getDocument().getLength();
 842         double y = 0;
 843         Rectangle2D r = null;
 844         if (lastOffs &lt;= n) {
 845             r = useFPAPI ? c.modelToView2D(lastOffs) : c.modelToView(lastOffs);
 846             y = r.getY();
 847         }
 848         while ((r != null) &amp;&amp; (y == r.getY())) {
 849             double span = Math.abs(x - r.getX());
 850             if (span &lt; bestSpan) {
 851                 offs = lastOffs;
 852                 bestSpan = span;
 853             }
 854             lastOffs += 1;
 855 
 856             if (lastOffs &lt;= n) {
 857                 r = useFPAPI ? c.modelToView2D(lastOffs) : c.modelToView(lastOffs);
 858             } else {
 859                 r = null;
 860             }
 861         }
 862         return offs;
 863     }
 864 
 865     /**
 866      * Determines the position in the model that is closest to the given
 867      * view location in the row below.  The component given must have a
 868      * size to compute the result.  If the component doesn&#39;t have a size
 869      * a value of -1 will be returned.
 870      *
 871      * @param c the editor
 872      * @param offs the offset in the document {@code &gt;= 0}
 873      * @param x the X coordinate {@code &gt;= 0}
 874      * @return the position {@code &gt;= 0} if the request can be computed, otherwise
 875      *  a value of -1 will be returned.
 876      * @exception BadLocationException if the offset is out of range
 877      *
 878      * @since 9
 879      */
 880     public static final int getPositionBelow(JTextComponent c, int offs, float x)
 881             throws BadLocationException {
 882         return getPositionBelow(c, offs, x, true);
 883     }
 884 
 885     /**
 886      * Determines the start of a word for the given model location.
 887      * Uses BreakIterator.getWordInstance() to actually get the words.
 888      *
 889      * @param c the editor
 890      * @param offs the offset in the document &amp;gt;= 0
 891      * @return the location in the model of the word start &amp;gt;= 0
 892      * @exception BadLocationException if the offset is out of range
 893      */
 894     public static final int getWordStart(JTextComponent c, int offs) throws BadLocationException {
 895         Document doc = c.getDocument();
 896         Element line = getParagraphElement(c, offs);
 897         if (line == null) {
 898             throw new BadLocationException(&quot;No word at &quot; + offs, offs);
 899         }
 900         int lineStart = line.getStartOffset();
 901         int lineEnd = Math.min(line.getEndOffset(), doc.getLength());
 902 
 903         Segment seg = SegmentCache.getSharedSegment();
 904         doc.getText(lineStart, lineEnd - lineStart, seg);
 905         if(seg.count &gt; 0) {
 906             BreakIterator words = BreakIterator.getWordInstance(c.getLocale());
 907             words.setText(seg);
 908             int wordPosition = seg.offset + offs - lineStart;
 909             if(wordPosition &gt;= words.last()) {
 910                 wordPosition = words.last() - 1;
 911             }
 912             words.following(wordPosition);
 913             offs = lineStart + words.previous() - seg.offset;
 914         }
 915         SegmentCache.releaseSharedSegment(seg);
 916         return offs;
 917     }
 918 
 919     /**
 920      * Determines the end of a word for the given location.
 921      * Uses BreakIterator.getWordInstance() to actually get the words.
 922      *
 923      * @param c the editor
 924      * @param offs the offset in the document &amp;gt;= 0
 925      * @return the location in the model of the word end &amp;gt;= 0
 926      * @exception BadLocationException if the offset is out of range
 927      */
 928     public static final int getWordEnd(JTextComponent c, int offs) throws BadLocationException {
 929         Document doc = c.getDocument();
 930         Element line = getParagraphElement(c, offs);
 931         if (line == null) {
 932             throw new BadLocationException(&quot;No word at &quot; + offs, offs);
 933         }
 934         int lineStart = line.getStartOffset();
 935         int lineEnd = Math.min(line.getEndOffset(), doc.getLength());
 936 
 937         Segment seg = SegmentCache.getSharedSegment();
 938         doc.getText(lineStart, lineEnd - lineStart, seg);
 939         if(seg.count &gt; 0) {
 940             BreakIterator words = BreakIterator.getWordInstance(c.getLocale());
 941             words.setText(seg);
 942             int wordPosition = offs - lineStart + seg.offset;
 943             if(wordPosition &gt;= words.last()) {
 944                 wordPosition = words.last() - 1;
 945             }
 946             offs = lineStart + words.following(wordPosition) - seg.offset;
 947         }
 948         SegmentCache.releaseSharedSegment(seg);
 949         return offs;
 950     }
 951 
 952     /**
 953      * Determines the start of the next word for the given location.
 954      * Uses BreakIterator.getWordInstance() to actually get the words.
 955      *
 956      * @param c the editor
 957      * @param offs the offset in the document &amp;gt;= 0
 958      * @return the location in the model of the word start &amp;gt;= 0
 959      * @exception BadLocationException if the offset is out of range
 960      */
 961     public static final int getNextWord(JTextComponent c, int offs) throws BadLocationException {
 962         int nextWord;
 963         Element line = getParagraphElement(c, offs);
 964         for (nextWord = getNextWordInParagraph(c, line, offs, false);
 965              nextWord == BreakIterator.DONE;
 966              nextWord = getNextWordInParagraph(c, line, offs, true)) {
 967 
 968             // didn&#39;t find in this line, try the next line
 969             offs = line.getEndOffset();
 970             line = getParagraphElement(c, offs);
 971         }
 972         return nextWord;
 973     }
 974 
 975     /**
 976      * Finds the next word in the given elements text.  The first
 977      * parameter allows searching multiple paragraphs where even
 978      * the first offset is desired.
 979      * Returns the offset of the next word, or BreakIterator.DONE
 980      * if there are no more words in the element.
 981      */
 982     static int getNextWordInParagraph(JTextComponent c, Element line, int offs, boolean first) throws BadLocationException {
 983         if (line == null) {
 984             throw new BadLocationException(&quot;No more words&quot;, offs);
 985         }
 986         Document doc = line.getDocument();
 987         int lineStart = line.getStartOffset();
 988         int lineEnd = Math.min(line.getEndOffset(), doc.getLength());
 989         if ((offs &gt;= lineEnd) || (offs &lt; lineStart)) {
 990             throw new BadLocationException(&quot;No more words&quot;, offs);
 991         }
 992         Segment seg = SegmentCache.getSharedSegment();
 993         doc.getText(lineStart, lineEnd - lineStart, seg);
 994         BreakIterator words = BreakIterator.getWordInstance(c.getLocale());
 995         words.setText(seg);
 996         if ((first &amp;&amp; (words.first() == (seg.offset + offs - lineStart))) &amp;&amp;
 997             (! Character.isWhitespace(seg.array[words.first()]))) {
 998 
 999             return offs;
1000         }
1001         int wordPosition = words.following(seg.offset + offs - lineStart);
1002         if ((wordPosition == BreakIterator.DONE) ||
1003             (wordPosition &gt;= seg.offset + seg.count)) {
1004                 // there are no more words on this line.
1005                 return BreakIterator.DONE;
1006         }
1007         // if we haven&#39;t shot past the end... check to
1008         // see if the current boundary represents whitespace.
1009         // if so, we need to try again
1010         char ch = seg.array[wordPosition];
1011         if (! Character.isWhitespace(ch)) {
1012             return lineStart + wordPosition - seg.offset;
1013         }
1014 
1015         // it was whitespace, try again.  The assumption
1016         // is that it must be a word start if the last
1017         // one had whitespace following it.
1018         wordPosition = words.next();
1019         if (wordPosition != BreakIterator.DONE) {
1020             offs = lineStart + wordPosition - seg.offset;
1021             if (offs != lineEnd) {
1022                 return offs;
1023             }
1024         }
1025         SegmentCache.releaseSharedSegment(seg);
1026         return BreakIterator.DONE;
1027     }
1028 
1029 
1030     /**
1031      * Determine the start of the prev word for the given location.
1032      * Uses BreakIterator.getWordInstance() to actually get the words.
1033      *
1034      * @param c the editor
1035      * @param offs the offset in the document &amp;gt;= 0
1036      * @return the location in the model of the word start &amp;gt;= 0
1037      * @exception BadLocationException if the offset is out of range
1038      */
1039     public static final int getPreviousWord(JTextComponent c, int offs) throws BadLocationException {
1040         int prevWord;
1041         Element line = getParagraphElement(c, offs);
1042         for (prevWord = getPrevWordInParagraph(c, line, offs);
1043              prevWord == BreakIterator.DONE;
1044              prevWord = getPrevWordInParagraph(c, line, offs)) {
1045 
1046             // didn&#39;t find in this line, try the prev line
1047             offs = line.getStartOffset() - 1;
1048             line = getParagraphElement(c, offs);
1049         }
1050         return prevWord;
1051     }
1052 
1053     /**
1054      * Finds the previous word in the given elements text.  The first
1055      * parameter allows searching multiple paragraphs where even
1056      * the first offset is desired.
1057      * Returns the offset of the next word, or BreakIterator.DONE
1058      * if there are no more words in the element.
1059      */
1060     static int getPrevWordInParagraph(JTextComponent c, Element line, int offs) throws BadLocationException {
1061         if (line == null) {
1062             throw new BadLocationException(&quot;No more words&quot;, offs);
1063         }
1064         Document doc = line.getDocument();
1065         int lineStart = line.getStartOffset();
1066         int lineEnd = line.getEndOffset();
1067         if ((offs &gt; lineEnd) || (offs &lt; lineStart)) {
1068             throw new BadLocationException(&quot;No more words&quot;, offs);
1069         }
1070         Segment seg = SegmentCache.getSharedSegment();
1071         doc.getText(lineStart, lineEnd - lineStart, seg);
1072         BreakIterator words = BreakIterator.getWordInstance(c.getLocale());
1073         words.setText(seg);
1074         if (words.following(seg.offset + offs - lineStart) == BreakIterator.DONE) {
1075             words.last();
1076         }
1077         int wordPosition = words.previous();
1078         if (wordPosition == (seg.offset + offs - lineStart)) {
1079             wordPosition = words.previous();
1080         }
1081 
1082         if (wordPosition == BreakIterator.DONE) {
1083             // there are no more words on this line.
1084             return BreakIterator.DONE;
1085         }
1086         // if we haven&#39;t shot past the end... check to
1087         // see if the current boundary represents whitespace.
1088         // if so, we need to try again
1089         char ch = seg.array[wordPosition];
1090         if (! Character.isWhitespace(ch)) {
1091             return lineStart + wordPosition - seg.offset;
1092         }
1093 
1094         // it was whitespace, try again.  The assumption
1095         // is that it must be a word start if the last
1096         // one had whitespace following it.
1097         wordPosition = words.previous();
1098         if (wordPosition != BreakIterator.DONE) {
1099             return lineStart + wordPosition - seg.offset;
1100         }
1101         SegmentCache.releaseSharedSegment(seg);
1102         return BreakIterator.DONE;
1103     }
1104 
1105     /**
1106      * Determines the element to use for a paragraph/line.
1107      *
1108      * @param c the editor
1109      * @param offs the starting offset in the document &amp;gt;= 0
1110      * @return the element
1111      */
1112     public static final Element getParagraphElement(JTextComponent c, int offs) {
1113         Document doc = c.getDocument();
1114         if (doc instanceof StyledDocument) {
1115             return ((StyledDocument)doc).getParagraphElement(offs);
1116         }
1117         Element map = doc.getDefaultRootElement();
1118         int index = map.getElementIndex(offs);
1119         Element paragraph = map.getElement(index);
1120         if ((offs &gt;= paragraph.getStartOffset()) &amp;&amp; (offs &lt; paragraph.getEndOffset())) {
1121             return paragraph;
1122         }
1123         return null;
1124     }
1125 
1126     static boolean isComposedTextElement(Document doc, int offset) {
1127         Element elem = doc.getDefaultRootElement();
1128         while (!elem.isLeaf()) {
1129             elem = elem.getElement(elem.getElementIndex(offset));
1130         }
1131         return isComposedTextElement(elem);
1132     }
1133 
1134     static boolean isComposedTextElement(Element elem) {
1135         AttributeSet as = elem.getAttributes();
1136         return isComposedTextAttributeDefined(as);
1137     }
1138 
1139     static boolean isComposedTextAttributeDefined(AttributeSet as) {
1140         return ((as != null) &amp;&amp;
1141                 (as.isDefined(StyleConstants.ComposedTextAttribute)));
1142     }
1143 
1144     /**
1145      * Draws the given composed text passed from an input method.
1146      *
1147      * @param view View hosting text
1148      * @param attr the attributes containing the composed text
1149      * @param g  the graphics context
1150      * @param x  the X origin
1151      * @param y  the Y origin
1152      * @param p0 starting offset in the composed text to be rendered
1153      * @param p1 ending offset in the composed text to be rendered
1154      * @return  the new insertion position
1155      */
1156     static int drawComposedText(View view, AttributeSet attr, Graphics g,
1157                                 int x, int y, int p0, int p1)
1158             throws BadLocationException
1159     {
1160         return (int) drawComposedText(view, attr, g, x, y, p0, p1, false);
1161     }
1162 
1163     static float drawComposedText(View view, AttributeSet attr, Graphics g,
1164                                   float x, float y, int p0, int p1)
1165             throws BadLocationException
1166     {
1167         return drawComposedText(view, attr, g, x, y, p0, p1, true);
1168     }
1169 
1170     static float drawComposedText(View view, AttributeSet attr, Graphics g,
1171                                   float x, float y, int p0, int p1,
1172                                   boolean useFPAPI)
1173             throws BadLocationException
1174     {
1175         Graphics2D g2d = (Graphics2D)g;
1176         AttributedString as = (AttributedString)attr.getAttribute(
1177             StyleConstants.ComposedTextAttribute);
1178         as.addAttribute(TextAttribute.FONT, g.getFont());
1179 
1180         if (p0 &gt;= p1)
1181             return x;
1182 
1183         AttributedCharacterIterator aci = as.getIterator(null, p0, p1);
1184         return x + SwingUtilities2.drawString(getJComponent(view), g2d, aci, x, y);
1185     }
1186 
1187     /**
1188      * Paints the composed text in a GlyphView
1189      */
1190     static void paintComposedText(Graphics g, Rectangle alloc, GlyphView v) {
1191         if (g instanceof Graphics2D) {
1192             Graphics2D g2d = (Graphics2D) g;
1193             int p0 = v.getStartOffset();
1194             int p1 = v.getEndOffset();
1195             AttributeSet attrSet = v.getElement().getAttributes();
1196             AttributedString as =
1197                 (AttributedString)attrSet.getAttribute(StyleConstants.ComposedTextAttribute);
1198             int start = v.getElement().getStartOffset();
1199             int y = alloc.y + alloc.height - (int)v.getGlyphPainter().getDescent(v);
1200             int x = alloc.x;
1201 
1202             //Add text attributes
1203             as.addAttribute(TextAttribute.FONT, v.getFont());
1204             as.addAttribute(TextAttribute.FOREGROUND, v.getForeground());
1205             if (StyleConstants.isBold(v.getAttributes())) {
1206                 as.addAttribute(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);
1207             }
1208             if (StyleConstants.isItalic(v.getAttributes())) {
1209                 as.addAttribute(TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);
1210             }
1211             if (v.isUnderline()) {
1212                 as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
1213             }
1214             if (v.isStrikeThrough()) {
1215                 as.addAttribute(TextAttribute.STRIKETHROUGH, TextAttribute.STRIKETHROUGH_ON);
1216             }
1217             if (v.isSuperscript()) {
1218                 as.addAttribute(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUPER);
1219             }
1220             if (v.isSubscript()) {
1221                 as.addAttribute(TextAttribute.SUPERSCRIPT, TextAttribute.SUPERSCRIPT_SUB);
1222             }
1223 
1224             // draw
1225             AttributedCharacterIterator aci = as.getIterator(null, p0 - start, p1 - start);
1226             SwingUtilities2.drawString(getJComponent(v),
1227                                        g2d,aci,x,y);
1228         }
1229     }
1230 
1231     /*
1232      * Convenience function for determining ComponentOrientation.  Helps us
1233      * avoid having Munge directives throughout the code.
1234      */
1235     static boolean isLeftToRight( java.awt.Component c ) {
1236         return c.getComponentOrientation().isLeftToRight();
1237     }
1238 
1239 
1240     /**
1241      * Provides a way to determine the next visually represented model
1242      * location that one might place a caret.  Some views may not be visible,
1243      * they might not be in the same order found in the model, or they just
1244      * might not allow access to some of the locations in the model.
1245      * &lt;p&gt;
1246      * This implementation assumes the views are layed out in a logical
1247      * manner. That is, that the view at index x + 1 is visually after
1248      * the View at index x, and that the View at index x - 1 is visually
1249      * before the View at x. There is support for reversing this behavior
1250      * only if the passed in &lt;code&gt;View&lt;/code&gt; is an instance of
1251      * &lt;code&gt;CompositeView&lt;/code&gt;. The &lt;code&gt;CompositeView&lt;/code&gt;
1252      * must then override the &lt;code&gt;flipEastAndWestAtEnds&lt;/code&gt; method.
1253      *
1254      * @param v View to query
1255      * @param pos the position to convert &amp;gt;= 0
1256      * @param alloc the allocated region to render into
1257      * @param direction the direction from the current position that can
1258      *  be thought of as the arrow keys typically found on a keyboard;
1259      *  this may be one of the following:
1260      *  &lt;ul&gt;
1261      *  &lt;li&gt;&lt;code&gt;SwingConstants.WEST&lt;/code&gt;
1262      *  &lt;li&gt;&lt;code&gt;SwingConstants.EAST&lt;/code&gt;
1263      *  &lt;li&gt;&lt;code&gt;SwingConstants.NORTH&lt;/code&gt;
1264      *  &lt;li&gt;&lt;code&gt;SwingConstants.SOUTH&lt;/code&gt;
1265      *  &lt;/ul&gt;
1266      * @param biasRet an array contain the bias that was checked
1267      * @return the location within the model that best represents the next
1268      *  location visual position
1269      * @exception BadLocationException
1270      * @exception IllegalArgumentException if &lt;code&gt;direction&lt;/code&gt; is invalid
1271      */
1272     static int getNextVisualPositionFrom(View v, int pos, Position.Bias b,
1273                                           Shape alloc, int direction,
1274                                           Position.Bias[] biasRet)
1275                              throws BadLocationException {
1276         if (v.getViewCount() == 0) {
1277             // Nothing to do.
1278             return pos;
1279         }
1280         boolean top = (direction == SwingConstants.NORTH ||
1281                        direction == SwingConstants.WEST);
1282         int retValue;
1283         if (pos == -1) {
1284             // Start from the first View.
1285             int childIndex = (top) ? v.getViewCount() - 1 : 0;
1286             View child = v.getView(childIndex);
1287             Shape childBounds = v.getChildAllocation(childIndex, alloc);
1288             retValue = child.getNextVisualPositionFrom(pos, b, childBounds,
1289                                                        direction, biasRet);
1290             if (retValue == -1 &amp;&amp; !top &amp;&amp; v.getViewCount() &gt; 1) {
1291                 // Special case that should ONLY happen if first view
1292                 // isn&#39;t valid (can happen when end position is put at
1293                 // beginning of line.
1294                 child = v.getView(1);
1295                 childBounds = v.getChildAllocation(1, alloc);
1296                 retValue = child.getNextVisualPositionFrom(-1, biasRet[0],
1297                                                            childBounds,
1298                                                            direction, biasRet);
1299             }
1300         }
1301         else {
1302             int increment = (top) ? -1 : 1;
1303             int childIndex;
1304             if (b == Position.Bias.Backward &amp;&amp; pos &gt; 0) {
1305                 childIndex = v.getViewIndex(pos - 1, Position.Bias.Forward);
1306             }
1307             else {
1308                 childIndex = v.getViewIndex(pos, Position.Bias.Forward);
1309             }
1310             View child = v.getView(childIndex);
1311             Shape childBounds = v.getChildAllocation(childIndex, alloc);
1312             retValue = child.getNextVisualPositionFrom(pos, b, childBounds,
1313                                                        direction, biasRet);
1314             if ((direction == SwingConstants.EAST ||
1315                  direction == SwingConstants.WEST) &amp;&amp;
1316                 (v instanceof CompositeView) &amp;&amp;
1317                 ((CompositeView)v).flipEastAndWestAtEnds(pos, b)) {
1318                 increment *= -1;
1319             }
1320             childIndex += increment;
1321             if (retValue == -1 &amp;&amp; childIndex &gt;= 0 &amp;&amp;
1322                                   childIndex &lt; v.getViewCount()) {
1323                 child = v.getView(childIndex);
1324                 childBounds = v.getChildAllocation(childIndex, alloc);
1325                 retValue = child.getNextVisualPositionFrom(
1326                                      -1, b, childBounds, direction, biasRet);
1327                 // If there is a bias change, it is a fake position
1328                 // and we should skip it. This is usually the result
1329                 // of two elements side be side flowing the same way.
1330                 if (retValue == pos &amp;&amp; biasRet[0] != b) {
1331                     return getNextVisualPositionFrom(v, pos, biasRet[0],
1332                                                      alloc, direction,
1333                                                      biasRet);
1334                 }
1335             }
1336             else if (retValue != -1 &amp;&amp; biasRet[0] != b &amp;&amp;
1337                      ((increment == 1 &amp;&amp; child.getEndOffset() == retValue) ||
1338                       (increment == -1 &amp;&amp;
1339                        child.getStartOffset() == retValue)) &amp;&amp;
1340                      childIndex &gt;= 0 &amp;&amp; childIndex &lt; v.getViewCount()) {
1341                 // Reached the end of a view, make sure the next view
1342                 // is a different direction.
1343                 child = v.getView(childIndex);
1344                 childBounds = v.getChildAllocation(childIndex, alloc);
1345                 Position.Bias originalBias = biasRet[0];
1346                 int nextPos = child.getNextVisualPositionFrom(
1347                                     -1, b, childBounds, direction, biasRet);
1348                 if (biasRet[0] == b) {
1349                     retValue = nextPos;
1350                 }
1351                 else {
1352                     biasRet[0] = originalBias;
1353                 }
1354             }
1355         }
1356         return retValue;
1357     }
1358 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.ci/share/classes/jdk.vm.ci.hotspot/src/jdk/vm/ci/hotspot/HotSpotResolvedObjectTypeImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package jdk.vm.ci.hotspot;
  24 
  25 import static java.util.Objects.requireNonNull;
  26 import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;
  27 import static jdk.vm.ci.hotspot.HotSpotConstantPool.isSignaturePolymorphicHolder;
  28 import static jdk.vm.ci.hotspot.HotSpotJVMCIRuntime.runtime;
  29 import static jdk.vm.ci.hotspot.HotSpotModifiers.jvmClassModifiers;
  30 import static jdk.vm.ci.hotspot.HotSpotVMConfig.config;
  31 import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;
  32 
  33 import java.lang.annotation.Annotation;
  34 import java.lang.reflect.Field;
  35 import java.lang.reflect.Modifier;
  36 import java.nio.ByteOrder;
  37 import java.util.Arrays;
  38 import java.util.Comparator;
  39 import java.util.HashMap;
  40 
  41 import jdk.vm.ci.common.JVMCIError;
  42 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
  43 import jdk.vm.ci.meta.Assumptions.ConcreteMethod;
  44 import jdk.vm.ci.meta.Assumptions.ConcreteSubtype;
  45 import jdk.vm.ci.meta.Assumptions.LeafType;
  46 import jdk.vm.ci.meta.Assumptions.NoFinalizableSubclass;
  47 import jdk.vm.ci.meta.Constant;
  48 import jdk.vm.ci.meta.JavaConstant;
  49 import jdk.vm.ci.meta.JavaKind;
  50 import jdk.vm.ci.meta.JavaType;
  51 import jdk.vm.ci.meta.ResolvedJavaField;
  52 import jdk.vm.ci.meta.ResolvedJavaMethod;
  53 import jdk.vm.ci.meta.ResolvedJavaType;
  54 import jdk.vm.ci.meta.UnresolvedJavaField;
  55 import jdk.vm.ci.meta.UnresolvedJavaType;
  56 
  57 /**
  58  * Implementation of {@link JavaType} for resolved non-primitive HotSpot classes. This class is not
  59  * an {@link MetaspaceHandleObject} because it doesn&#39;t have to be scanned for GC. It&#39;s liveness is
  60  * maintained by a reference to the {@link Class} instance.
  61  */
  62 final class HotSpotResolvedObjectTypeImpl extends HotSpotResolvedJavaType implements HotSpotResolvedObjectType, MetaspaceObject {
  63 
  64     private static final HotSpotResolvedJavaField[] NO_FIELDS = new HotSpotResolvedJavaField[0];
  65     private static final int METHOD_CACHE_ARRAY_CAPACITY = 8;
  66     private static final SortByOffset fieldSortingMethod = new SortByOffset();
  67 
  68     /**
  69      * The Java class this type represents.
  70      */
  71     private final long metadataPointer;
  72 
  73     private HotSpotResolvedJavaMethodImpl[] methodCacheArray;
  74     private HashMap&lt;Long, HotSpotResolvedJavaMethodImpl&gt; methodCacheHashMap;
  75     private volatile HotSpotResolvedJavaField[] instanceFields;
  76     private volatile HotSpotResolvedObjectTypeImpl[] interfaces;
  77     private HotSpotConstantPool constantPool;
  78     private final JavaConstant mirror;
  79     private HotSpotResolvedObjectTypeImpl superClass;
  80 
  81     /**
  82      * Managed exclusively by {@link HotSpotJDKReflection#getField}.
  83      */
  84     HashMap&lt;HotSpotResolvedJavaFieldImpl, Field&gt; reflectionFieldCache;
  85 
  86     static HotSpotResolvedObjectTypeImpl getJavaLangObject() {
  87         return runtime().getJavaLangObject();
  88     }
  89 
  90     /**
  91      * Gets the JVMCI mirror from a HotSpot type.
  92      *
  93      * Called from the VM.
  94      *
  95      * @param klassPointer a native pointer to the Klass*
  96      * @return the {@link ResolvedJavaType} corresponding to {@code javaClass}
  97      */
  98     @SuppressWarnings(&quot;unused&quot;)
  99     @VMEntryPoint
 100     private static HotSpotResolvedObjectTypeImpl fromMetaspace(long klassPointer, String signature) {
 101         return runtime().fromMetaspace(klassPointer, signature);
 102     }
 103 
 104     /**
 105      * Creates the JVMCI mirror for a {@link Class} object.
 106      *
 107      * &lt;b&gt;NOTE&lt;/b&gt;: Creating an instance of this class does not install the mirror for the
 108      * {@link Class} type.
 109      * &lt;/p&gt;
 110      *
 111      * @param metadataPointer the Klass* to create the mirror for
 112      */
 113     @SuppressWarnings(&quot;try&quot;)
 114     HotSpotResolvedObjectTypeImpl(long metadataPointer, String name) {
 115         super(name);
 116         assert metadataPointer != 0;
 117         this.metadataPointer = metadataPointer;
 118 
 119         // The mirror object must be in the global scope since
 120         // this object will be cached in HotSpotJVMCIRuntime.resolvedJavaTypes
 121         // and live across more than one compilation.
 122         try (HotSpotObjectConstantScope global = HotSpotObjectConstantScope.enterGlobalScope()) {
 123             this.mirror = runtime().compilerToVm.getJavaMirror(this);
 124             assert getName().charAt(0) != &#39;[&#39; || isArray() : getName();
 125         }
 126     }
 127 
 128     /**
 129      * Gets the metaspace Klass for this type.
 130      */
 131     long getMetaspaceKlass() {
 132         long metaspacePointer = getMetaspacePointer();
 133         if (metaspacePointer == 0) {
 134             throw new NullPointerException(&quot;Klass* is null&quot;);
 135         }
 136         return metaspacePointer;
 137     }
 138 
 139     @Override
 140     public long getMetaspacePointer() {
 141         return metadataPointer;
 142     }
 143 
 144     @Override
 145     public int getModifiers() {
 146         if (isArray()) {
 147             return (getElementalType().getModifiers() &amp; (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED)) | Modifier.FINAL | Modifier.ABSTRACT;
 148         } else {
 149             return getAccessFlags() &amp; jvmClassModifiers();
 150         }
 151     }
 152 
 153     public int getAccessFlags() {
 154         HotSpotVMConfig config = config();
 155         return UNSAFE.getInt(getMetaspaceKlass() + config.klassAccessFlagsOffset);
 156     }
 157 
 158     @Override
 159     public ResolvedJavaType getComponentType() {
 160         return runtime().compilerToVm.getComponentType(this);
 161     }
 162 
 163     @Override
 164     public AssumptionResult&lt;ResolvedJavaType&gt; findLeafConcreteSubtype() {
 165         if (isLeaf()) {
 166             // No assumptions are required.
 167             return new AssumptionResult&lt;&gt;(this);
 168         }
 169         HotSpotVMConfig config = config();
 170         if (isArray()) {
 171             ResolvedJavaType elementalType = getElementalType();
 172             AssumptionResult&lt;ResolvedJavaType&gt; elementType = elementalType.findLeafConcreteSubtype();
 173             if (elementType != null &amp;&amp; elementType.getResult().equals(elementalType)) {
 174                 /*
 175                  * If the elementType is leaf then the array is leaf under the same assumptions but
 176                  * only if the element type is exactly the leaf type. The element type can be
 177                  * abstract even if there is only one implementor of the abstract type.
 178                  */
 179                 AssumptionResult&lt;ResolvedJavaType&gt; result = new AssumptionResult&lt;&gt;(this);
 180                 result.add(elementType);
 181                 return result;
 182             }
 183             return null;
 184         } else if (isInterface()) {
 185             HotSpotResolvedObjectTypeImpl implementor = getSingleImplementor();
 186             /*
 187              * If the implementor field contains itself that indicates that the interface has more
 188              * than one implementors (see: InstanceKlass::add_implementor).
 189              */
 190             if (implementor == null || implementor.equals(this)) {
 191                 return null;
 192             }
 193 
 194             assert !implementor.isInterface();
 195             if (implementor.isAbstract() || !implementor.isLeafClass()) {
 196                 AssumptionResult&lt;ResolvedJavaType&gt; leafConcreteSubtype = implementor.findLeafConcreteSubtype();
 197                 if (leafConcreteSubtype != null) {
 198                     assert !leafConcreteSubtype.getResult().equals(implementor);
 199                     AssumptionResult&lt;ResolvedJavaType&gt; newResult = new AssumptionResult&lt;&gt;(leafConcreteSubtype.getResult(), new ConcreteSubtype(this, implementor));
 200                     // Accumulate leaf assumptions and return the combined result.
 201                     newResult.add(leafConcreteSubtype);
 202                     return newResult;
 203                 }
 204                 return null;
 205             }
 206             return concreteSubtype(implementor);
 207         } else {
 208             HotSpotResolvedObjectTypeImpl type = this;
 209             while (type.isAbstract()) {
 210                 HotSpotResolvedObjectTypeImpl subklass = type.getSubklass();
 211                 if (subklass == null || UNSAFE.getAddress(subklass.getMetaspaceKlass() + config.nextSiblingOffset) != 0) {
 212                     return null;
 213                 }
 214                 type = subklass;
 215             }
 216             if (type.isAbstract() || type.isInterface() || !type.isLeafClass()) {
 217                 return null;
 218             }
 219             if (this.isAbstract()) {
 220                 return concreteSubtype(type);
 221             } else {
 222                 assert this.equals(type);
 223                 return new AssumptionResult&lt;&gt;(type, new LeafType(type));
 224             }
 225         }
 226     }
 227 
 228     private AssumptionResult&lt;ResolvedJavaType&gt; concreteSubtype(HotSpotResolvedObjectTypeImpl type) {
 229         if (type.isLeaf()) {
 230             return new AssumptionResult&lt;&gt;(type, new ConcreteSubtype(this, type));
 231         } else {
 232             return new AssumptionResult&lt;&gt;(type, new LeafType(type), new ConcreteSubtype(this, type));
 233         }
 234     }
 235 
 236     /**
 237      * Returns if type {@code type} is a leaf class. This is the case if the
 238      * {@code Klass::_subklass} field of the underlying class is zero.
 239      *
 240      * @return true if the type is a leaf class
 241      */
 242     private boolean isLeafClass() {
 243         return UNSAFE.getLong(this.getMetaspaceKlass() + config().subklassOffset) == 0;
 244     }
 245 
 246     /**
 247      * Returns the {@code Klass::_subklass} field of the underlying metaspace klass for the given
 248      * type {@code type}.
 249      *
 250      * @return value of the subklass field as metaspace klass pointer
 251      */
 252     private HotSpotResolvedObjectTypeImpl getSubklass() {
 253         return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false);
 254     }
 255 
 256     @Override
 257     public HotSpotResolvedObjectTypeImpl getSuperclass() {
 258         if (isInterface()) {
 259             return null;
 260         }
 261         HotSpotResolvedObjectTypeImpl javaLangObject = runtime().getJavaLangObject();
 262         if (this.equals(javaLangObject)) {
 263             return null;
 264         }
 265         if (isArray()) {
 266             return javaLangObject;
 267         }
 268 
 269         // Cache result of native call
 270         if (superClass == null) {
 271             superClass = compilerToVM().getResolvedJavaType(this, config().superOffset, false);
 272         }
 273         return superClass;
 274     }
 275 
 276     @Override
 277     public HotSpotResolvedObjectTypeImpl[] getInterfaces() {
 278         if (interfaces == null) {
 279             if (isArray()) {
 280                 HotSpotResolvedObjectTypeImpl[] types = new HotSpotResolvedObjectTypeImpl[2];
 281                 types[0] = runtime().getJavaLangCloneable();
 282                 types[1] = runtime().getJavaLangSerializable();
 283                 this.interfaces = types;
 284             } else {
 285                 interfaces = runtime().compilerToVm.getInterfaces(this);
 286             }
 287         }
 288         return interfaces;
 289     }
 290 
 291     @Override
 292     public HotSpotResolvedObjectTypeImpl getSingleImplementor() {
 293         if (!isInterface()) {
 294             throw new JVMCIError(&quot;Cannot call getSingleImplementor() on a non-interface type: %s&quot;, this);
 295         }
 296         return compilerToVM().getImplementor(this);
 297     }
 298 
 299     @Override
 300     public HotSpotResolvedObjectTypeImpl getSupertype() {
 301         if (isArray()) {
 302             ResolvedJavaType componentType = getComponentType();
 303             if (componentType.equals(getJavaLangObject()) || componentType.isPrimitive()) {
 304                 return getJavaLangObject();
 305             }
 306             HotSpotResolvedObjectTypeImpl supertype = ((HotSpotResolvedObjectTypeImpl) componentType).getSupertype();
 307             return (HotSpotResolvedObjectTypeImpl) supertype.getArrayClass();
 308         }
 309         if (isInterface()) {
 310             return getJavaLangObject();
 311         }
 312         return getSuperclass();
 313     }
 314 
 315     @Override
 316     public HotSpotResolvedObjectType findLeastCommonAncestor(ResolvedJavaType otherType) {
 317         if (otherType.isPrimitive()) {
 318             return null;
 319         } else {
 320             HotSpotResolvedObjectTypeImpl t1 = this;
 321             HotSpotResolvedObjectTypeImpl t2 = (HotSpotResolvedObjectTypeImpl) otherType;
 322             while (true) {
 323                 if (t1.isAssignableFrom(t2)) {
 324                     return t1;
 325                 }
 326                 if (t2.isAssignableFrom(t1)) {
 327                     return t2;
 328                 }
 329                 t1 = t1.getSupertype();
 330                 t2 = t2.getSupertype();
 331             }
 332         }
 333     }
 334 
 335     @Override
 336     public AssumptionResult&lt;Boolean&gt; hasFinalizableSubclass() {
 337         assert !isArray();
 338         if (!compilerToVM().hasFinalizableSubclass(this)) {
 339             return new AssumptionResult&lt;&gt;(false, new NoFinalizableSubclass(this));
 340         }
 341         return new AssumptionResult&lt;&gt;(true);
 342     }
 343 
 344     @Override
 345     public boolean hasFinalizer() {
 346         return (getAccessFlags() &amp; config().jvmAccHasFinalizer) != 0;
 347     }
 348 
 349     @Override
 350     public boolean isArray() {
 351         return layoutHelper() &lt; config().klassLayoutHelperNeutralValue;
 352     }
 353 
 354     @Override
 355     public boolean isEnum() {
 356         HotSpotResolvedObjectTypeImpl superclass = getSuperclass();
 357         return superclass != null &amp;&amp; superclass.equals(runtime().getJavaLangEnum());
 358     }
 359 
 360     @Override
 361     public boolean isInitialized() {
 362         return isArray() ? true : getInitState() == config().instanceKlassStateFullyInitialized;
 363     }
 364 
 365     @Override
 366     public boolean isBeingInitialized() {
 367         return isArray() ? false : getInitState() == config().instanceKlassStateBeingInitialized;
 368     }
 369 
 370     @Override
 371     public boolean isLinked() {
 372         return isArray() ? true : getInitState() &gt;= config().instanceKlassStateLinked;
 373     }
 374 
 375     /**
 376      * Returns the value of the state field {@code InstanceKlass::_init_state} of the metaspace
 377      * klass.
 378      *
 379      * @return state field value of this type
 380      */
 381     private int getInitState() {
 382         assert !isArray() : &quot;_init_state only exists in InstanceKlass&quot;;
 383         return UNSAFE.getByte(getMetaspaceKlass() + config().instanceKlassInitStateOffset) &amp; 0xFF;
 384     }
 385 
 386     @Override
 387     public void initialize() {
 388         if (!isInitialized()) {
 389             runtime().compilerToVm.ensureInitialized(this);
 390             assert isInitialized() || isBeingInitialized();
 391         }
 392     }
 393 
 394     @Override
 395     public boolean isInstance(JavaConstant obj) {
 396         if (obj.getJavaKind() == JavaKind.Object &amp;&amp; !obj.isNull()) {
 397             return runtime().reflection.isInstance(this, (HotSpotObjectConstantImpl) obj);
 398         }
 399         return false;
 400     }
 401 
 402     @Override
 403     public boolean isInstanceClass() {
 404         return !isArray() &amp;&amp; !isInterface();
 405     }
 406 
 407     @Override
 408     public boolean isInterface() {
 409         return (getAccessFlags() &amp; config().jvmAccInterface) != 0;
 410     }
 411 
 412     @Override
 413     public boolean isAssignableFrom(ResolvedJavaType other) {
 414         assert other != null;
 415         if (other instanceof HotSpotResolvedObjectTypeImpl) {
 416             HotSpotResolvedObjectTypeImpl otherType = (HotSpotResolvedObjectTypeImpl) other;
 417             return runtime().reflection.isAssignableFrom(this, otherType);
 418         }
 419         return false;
 420     }
 421 
 422     @Override
 423     public ResolvedJavaType getHostClass() {
 424         if (isArray()) {
 425             return null;
 426         }
 427         return compilerToVM().getHostClass(this);
 428     }
 429 
 430     @Override
 431     public boolean isJavaLangObject() {
 432         return getName().equals(&quot;Ljava/lang/Object;&quot;);
 433     }
 434 
 435     @Override
 436     public JavaKind getJavaKind() {
 437         return JavaKind.Object;
 438     }
 439 
 440     @Override
 441     public ResolvedJavaMethod resolveMethod(ResolvedJavaMethod method, ResolvedJavaType callerType) {
 442         assert !callerType.isArray();
 443         if (isInterface()) {
 444             // Methods can only be resolved against concrete types
 445             return null;
 446         }
 447         if (method.isConcrete() &amp;&amp; method.getDeclaringClass().equals(this) &amp;&amp; method.isPublic() &amp;&amp; !isSignaturePolymorphicHolder(method.getDeclaringClass())) {
 448             return method;
 449         }
 450         if (!method.getDeclaringClass().isAssignableFrom(this)) {
 451             return null;
 452         }
 453         HotSpotResolvedJavaMethodImpl hotSpotMethod = (HotSpotResolvedJavaMethodImpl) method;
 454         HotSpotResolvedObjectTypeImpl hotSpotCallerType = (HotSpotResolvedObjectTypeImpl) callerType;
 455         return compilerToVM().resolveMethod(this, hotSpotMethod, hotSpotCallerType);
 456     }
 457 
 458     @Override
 459     public HotSpotConstantPool getConstantPool() {
 460         if (constantPool == null || !isArray() &amp;&amp; UNSAFE.getAddress(getMetaspaceKlass() + config().instanceKlassConstantsOffset) != constantPool.getMetaspaceConstantPool()) {
 461             /*
 462              * If the pointer to the ConstantPool has changed since this was last read refresh the
 463              * HotSpotConstantPool wrapper object. This ensures that uses of the constant pool are
 464              * operating on the latest one and that HotSpotResolvedJavaMethodImpls will be able to
 465              * use the shared copy instead of creating their own instance.
 466              */
 467             constantPool = compilerToVM().getConstantPool(this);
 468         }
 469         return constantPool;
 470     }
 471 
 472     /**
 473      * Gets the instance size of this type. If an instance of this type cannot be fast path
 474      * allocated, then the returned value is negative (its absolute value gives the size). Must not
 475      * be called if this is an array or interface type.
 476      */
 477     @Override
 478     public int instanceSize() {
 479         assert !isArray();
 480         assert !isInterface();
 481 
 482         HotSpotVMConfig config = config();
 483         final int layoutHelper = layoutHelper();
 484         assert layoutHelper &gt; config.klassLayoutHelperNeutralValue : &quot;must be instance&quot;;
 485 
 486         // See: Klass::layout_helper_size_in_bytes
 487         int size = layoutHelper &amp; ~config.klassLayoutHelperInstanceSlowPathBit;
 488 
 489         // See: Klass::layout_helper_needs_slow_path
 490         boolean needsSlowPath = (layoutHelper &amp; config.klassLayoutHelperInstanceSlowPathBit) != 0;
 491 
 492         return needsSlowPath ? -size : size;
 493     }
 494 
 495     @Override
 496     public int layoutHelper() {
 497         HotSpotVMConfig config = config();
 498         assert getMetaspaceKlass() != 0 : getName();
 499         return UNSAFE.getInt(getMetaspaceKlass() + config.klassLayoutHelperOffset);
 500     }
 501 
 502     @Override
 503     public long getFingerprint() {
 504         return compilerToVM().getFingerprint(getMetaspaceKlass());
 505     }
 506 
 507     synchronized HotSpotResolvedJavaMethod createMethod(long metaspaceHandle) {
 508         long metaspaceMethod = UNSAFE.getLong(metaspaceHandle);
 509         // Maintain cache as array.
 510         if (methodCacheArray == null) {
 511             methodCacheArray = new HotSpotResolvedJavaMethodImpl[METHOD_CACHE_ARRAY_CAPACITY];
 512         }
 513 
 514         int i = 0;
 515         for (; i &lt; methodCacheArray.length; ++i) {
 516             HotSpotResolvedJavaMethodImpl curMethod = methodCacheArray[i];
 517             if (curMethod == null) {
 518                 HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 519                 methodCacheArray[i] = newMethod;
 520                 return newMethod;
 521             } else if (curMethod.getMetaspaceMethod() == metaspaceMethod) {
 522                 return curMethod;
 523             }
 524         }
 525 
 526         // Fall-back to hash table.
 527         if (methodCacheHashMap == null) {
 528             methodCacheHashMap = new HashMap&lt;&gt;();
 529         }
 530 
 531         HotSpotResolvedJavaMethodImpl lookupResult = methodCacheHashMap.get(metaspaceMethod);
 532         if (lookupResult == null) {
 533             HotSpotResolvedJavaMethodImpl newMethod = new HotSpotResolvedJavaMethodImpl(this, metaspaceHandle);
 534             methodCacheHashMap.put(metaspaceMethod, newMethod);
 535             return newMethod;
 536         } else {
 537             return lookupResult;
 538         }
 539     }
 540 
 541     @Override
 542     public int getVtableLength() {
 543         HotSpotVMConfig config = config();
 544         if (isInterface() || isArray()) {
 545             /* Everything has the core vtable of java.lang.Object */
 546             return config.baseVtableLength();
 547         }
 548         int result = UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) / (config.vtableEntrySize / config.heapWordSize);
 549         assert result &gt;= config.baseVtableLength() : UNSAFE.getInt(getMetaspaceKlass() + config.klassVtableLengthOffset) + &quot; &quot; + config.vtableEntrySize;
 550         return result;
 551     }
 552 
 553     HotSpotResolvedJavaField createField(JavaType type, long offset, int rawFlags, int index) {
 554         return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);
 555     }
 556 
 557     @Override
 558     public AssumptionResult&lt;ResolvedJavaMethod&gt; findUniqueConcreteMethod(ResolvedJavaMethod method) {
 559         HotSpotResolvedJavaMethod hmethod = (HotSpotResolvedJavaMethod) method;
 560         HotSpotResolvedObjectType declaredHolder = hmethod.getDeclaringClass();
 561         /*
 562          * Sometimes the receiver type in the graph hasn&#39;t stabilized to a subtype of declared
 563          * holder, usually because of phis, so make sure that the type is related to the declared
 564          * type before using it for lookup. Unlinked types should also be ignored because we can&#39;t
 565          * resolve the proper method to invoke. Generally unlinked types in invokes should result in
 566          * a deopt instead since they can&#39;t really be used if they aren&#39;t linked yet.
 567          */
 568         if (!declaredHolder.isAssignableFrom(this) || this.isArray() || this.equals(declaredHolder) || !isLinked() || isInterface()) {
 569             if (hmethod.canBeStaticallyBound()) {
 570                 // No assumptions are required.
 571                 return new AssumptionResult&lt;&gt;(hmethod);
 572             }
 573             ResolvedJavaMethod result = hmethod.uniqueConcreteMethod(declaredHolder);
 574             if (result != null) {
 575                 return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, declaredHolder, result));
 576             }
 577             return null;
 578         }
 579         /*
 580          * The holder may be a subtype of the declaredHolder so make sure to resolve the method to
 581          * the correct method for the subtype.
 582          */
 583         HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) resolveMethod(hmethod, this);
 584         if (resolvedMethod == null) {
 585             // The type isn&#39;t known to implement the method.
 586             return null;
 587         }
 588         if (resolvedMethod.canBeStaticallyBound()) {
 589             // No assumptions are required.
 590             return new AssumptionResult&lt;&gt;(resolvedMethod);
 591         }
 592 
 593         ResolvedJavaMethod result = resolvedMethod.uniqueConcreteMethod(this);
 594         if (result != null) {
 595             return new AssumptionResult&lt;&gt;(result, new ConcreteMethod(method, this, result));
 596         }
 597         return null;
 598     }
 599 
 600     FieldInfo createFieldInfo(int index) {
 601         return new FieldInfo(index);
 602     }
 603 
 604     public void ensureInitialized() {
 605         runtime().compilerToVm.ensureInitialized(this);
 606     }
 607 
 608     @Override
 609     public boolean equals(Object obj) {
 610         if (obj == this) {
 611             return true;
 612         }
 613         if (!(obj instanceof HotSpotResolvedObjectTypeImpl)) {
 614             return false;
 615         }
 616         HotSpotResolvedObjectTypeImpl that = (HotSpotResolvedObjectTypeImpl) obj;
 617         return getMetaspaceKlass() == that.getMetaspaceKlass();
 618     }
 619 
 620     @Override
 621     JavaConstant getJavaMirror() {
 622         return mirror;
 623     }
 624 
 625     /**
 626      * This class represents the field information for one field contained in the fields array of an
 627      * {@code InstanceKlass}. The implementation is similar to the native {@code FieldInfo} class.
 628      */
 629     class FieldInfo {
 630         /**
 631          * Native pointer into the array of Java shorts.
 632          */
 633         private final long metaspaceData;
 634 
 635         /**
 636          * Creates a field info for the field in the fields array at index {@code index}.
 637          *
 638          * @param index index to the fields array
 639          */
 640         FieldInfo(int index) {
 641             HotSpotVMConfig config = config();
 642             // Get Klass::_fields
 643             final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 644             assert config.fieldInfoFieldSlots == 6 : &quot;revisit the field parsing code&quot;;
 645             int offset = config.fieldInfoFieldSlots * Short.BYTES * index;
 646             metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;
 647         }
 648 
 649         private int getAccessFlags() {
 650             return readFieldSlot(config().fieldInfoAccessFlagsOffset);
 651         }
 652 
 653         private int getNameIndex() {
 654             return readFieldSlot(config().fieldInfoNameIndexOffset);
 655         }
 656 
 657         private int getSignatureIndex() {
 658             return readFieldSlot(config().fieldInfoSignatureIndexOffset);
 659         }
 660 
 661         public int getOffset() {
 662             HotSpotVMConfig config = config();
 663             final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);
 664             final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);
 665             final int offset = ((highPacked &lt;&lt; Short.SIZE) | lowPacked) &gt;&gt; config.fieldInfoTagSize;
 666             return offset;
 667         }
 668 
 669         /**
 670          * Helper method to read an entry (slot) from the field array. Currently field info is laid
 671          * on top an array of Java shorts.
 672          */
 673         private int readFieldSlot(int index) {
 674             int offset = Short.BYTES * index;
 675             return UNSAFE.getChar(metaspaceData + offset);
 676         }
 677 
 678         /**
 679          * Returns the name of this field as a {@link String}. If the field is an internal field the
 680          * name index is pointing into the vmSymbols table.
 681          */
 682         public String getName() {
 683             final int nameIndex = getNameIndex();
 684             return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);
 685         }
 686 
 687         /**
 688          * Returns the signature of this field as {@link String}. If the field is an internal field
 689          * the signature index is pointing into the vmSymbols table.
 690          */
 691         public String getSignature() {
 692             final int signatureIndex = getSignatureIndex();
 693             return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);
 694         }
 695 
 696         public JavaType getType() {
 697             String signature = getSignature();
 698             return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);
 699         }
 700 
 701         private boolean isInternal() {
 702             return (getAccessFlags() &amp; config().jvmAccFieldInternal) != 0;
 703         }
 704 
 705         public boolean isStatic() {
 706             return Modifier.isStatic(getAccessFlags());
 707         }
 708 
 709         public boolean hasGenericSignature() {
 710             return (getAccessFlags() &amp; config().jvmAccFieldHasGenericSignature) != 0;
 711         }
 712     }
 713 
 714     static class SortByOffset implements Comparator&lt;ResolvedJavaField&gt; {
 715         public int compare(ResolvedJavaField a, ResolvedJavaField b) {
 716             return a.getOffset() - b.getOffset();
 717         }
 718     }
 719 
 720     @Override
 721     public ResolvedJavaField[] getInstanceFields(boolean includeSuperclasses) {
 722         if (instanceFields == null) {
 723             if (isArray() || isInterface()) {
 724                 instanceFields = NO_FIELDS;
 725             } else {
 726                 HotSpotResolvedJavaField[] prepend = NO_FIELDS;
 727                 if (getSuperclass() != null) {
 728                     prepend = (HotSpotResolvedJavaField[]) getSuperclass().getInstanceFields(true);
 729                 }
 730                 instanceFields = getFields(false, prepend);
 731             }
 732         }
 733         if (!includeSuperclasses &amp;&amp; getSuperclass() != null) {
 734             int superClassFieldCount = getSuperclass().getInstanceFields(true).length;
 735             if (superClassFieldCount == instanceFields.length) {
 736                 // This class does not have any instance fields of its own.
 737                 return NO_FIELDS;
 738             } else if (superClassFieldCount != 0) {
 739                 // Fields of the current class can be interleaved with fields of its super-classes
 740                 // but the array of fields to be returned must be sorted by increasing offset
 741                 // This code populates the array, then applies the sorting function
 742                 HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[instanceFields.length - superClassFieldCount];
 743                 int i = 0;
 744                 for (HotSpotResolvedJavaField f : instanceFields) {
 745                     if (f.getDeclaringClass() == this) {
 746                         result[i++] = f;
 747                     }
 748                 }
 749                 Arrays.sort(result, fieldSortingMethod);
 750                 return result;
 751             } else {
 752                 // The super classes of this class do not have any instance fields.
 753             }
 754         }
 755         return instanceFields;
 756     }
 757 
 758     @Override
 759     public ResolvedJavaField[] getStaticFields() {
 760         if (isArray()) {
 761             return new HotSpotResolvedJavaField[0];
 762         } else {
 763             return getFields(true, NO_FIELDS);
 764         }
 765     }
 766 
 767     /**
 768      * Gets the instance or static fields of this class.
 769      *
 770      * @param retrieveStaticFields specifies whether to return instance or static fields
 771      * @param prepend an array to be prepended to the returned result
 772      */
 773     private HotSpotResolvedJavaField[] getFields(boolean retrieveStaticFields, HotSpotResolvedJavaField[] prepend) {
 774         HotSpotVMConfig config = config();
 775         final long metaspaceFields = UNSAFE.getAddress(getMetaspaceKlass() + config.instanceKlassFieldsOffset);
 776         int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);
 777         int resultCount = 0;
 778         int index = 0;
 779         for (int i = 0; i &lt; metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {
 780             FieldInfo field = new FieldInfo(index);
 781             if (field.hasGenericSignature()) {
 782                 metaspaceFieldsLength--;
 783             }
 784 
 785             if (field.isStatic() == retrieveStaticFields) {
 786                 resultCount++;
 787             }
 788         }
 789 
 790         if (resultCount == 0) {
 791             return prepend;
 792         }
 793 
 794         int prependLength = prepend.length;
 795         resultCount += prependLength;
 796 
 797         HotSpotResolvedJavaField[] result = new HotSpotResolvedJavaField[resultCount];
 798         if (prependLength != 0) {
 799             System.arraycopy(prepend, 0, result, 0, prependLength);
 800         }
 801 
 802         // Fields of the current class can be interleaved with fields of its super-classes
 803         // but the array of fields to be returned must be sorted by increasing offset
 804         // This code populates the array, then applies the sorting function
 805         int resultIndex = prependLength;
 806         for (int i = 0; i &lt; index; ++i) {
 807             FieldInfo field = new FieldInfo(i);
 808             if (field.isStatic() == retrieveStaticFields) {
 809                 int offset = field.getOffset();
 810                 HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);
 811                 result[resultIndex++] = resolvedJavaField;
 812             }
 813         }
 814         Arrays.sort(result, fieldSortingMethod);
 815         return result;
 816     }
 817 
 818     @Override
 819     public String getSourceFileName() {
 820         if (isArray()) {
 821             return null;
 822         }
 823         return getConstantPool().getSourceFileName();
 824     }
 825 
 826     @Override
 827     public Annotation[] getAnnotations() {
 828         return runtime().reflection.getAnnotations(this);
 829     }
 830 
 831     @Override
 832     public Annotation[] getDeclaredAnnotations() {
 833         return runtime().reflection.getDeclaredAnnotations(this);
 834     }
 835 
 836     @Override
 837     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
 838         return runtime().reflection.getAnnotation(this, annotationClass);
 839     }
 840 
 841     /**
 842      * Performs a fast-path check that this type is resolved in the context of a given accessing
 843      * class. A negative result does not mean this type is not resolved with respect to
 844      * {@code accessingClass}. That can only be determined by
 845      * {@linkplain HotSpotJVMCIRuntime#lookupType(String, HotSpotResolvedObjectType, boolean)
 846      * re-resolving} the type.
 847      */
 848     @Override
 849     public boolean isDefinitelyResolvedWithRespectTo(ResolvedJavaType accessingClass) {
 850         assert accessingClass != null;
 851         ResolvedJavaType elementType = getElementalType();
 852         if (elementType.isPrimitive()) {
 853             // Primitive type resolution is context free.
 854             return true;
 855         }
 856         if (elementType.getName().startsWith(&quot;Ljava/&quot;) &amp;&amp; hasSameClassLoader(runtime().getJavaLangObject())) {
 857             // Classes in a java.* package defined by the boot class loader are always resolved.
 858             return true;
 859         }
 860         HotSpotResolvedObjectTypeImpl otherMirror = ((HotSpotResolvedObjectTypeImpl) accessingClass);
 861         return hasSameClassLoader(otherMirror);
 862     }
 863 
 864     private boolean hasSameClassLoader(HotSpotResolvedObjectTypeImpl otherMirror) {
 865         return UnsafeAccess.UNSAFE.getAddress(getMetaspaceKlass() + config().classLoaderDataOffset) == UnsafeAccess.UNSAFE.getAddress(
 866                         otherMirror.getMetaspaceKlass() + config().classLoaderDataOffset);
 867     }
 868 
 869     @Override
 870     public ResolvedJavaType resolve(ResolvedJavaType accessingClass) {
 871         if (isDefinitelyResolvedWithRespectTo(requireNonNull(accessingClass))) {
 872             return this;
 873         }
 874         HotSpotResolvedObjectTypeImpl accessingType = (HotSpotResolvedObjectTypeImpl) accessingClass;
 875         return (ResolvedJavaType) runtime().lookupType(getName(), accessingType, true);
 876     }
 877 
 878     /**
 879      * Gets the metaspace Klass boxed in a {@link JavaConstant}.
 880      */
 881     @Override
 882     public Constant klass() {
 883         return HotSpotMetaspaceConstantImpl.forMetaspaceObject(this, false);
 884     }
 885 
 886     @Override
 887     public boolean isPrimaryType() {
 888         return config().secondarySuperCacheOffset != superCheckOffset();
 889     }
 890 
 891     @Override
 892     public int superCheckOffset() {
 893         HotSpotVMConfig config = config();
 894         return UNSAFE.getInt(getMetaspaceKlass() + config.superCheckOffsetOffset);
 895     }
 896 
 897     @Override
 898     public long prototypeMarkWord() {
 899         HotSpotVMConfig config = config();
 900         if (isArray()) {
 901             return config.arrayPrototypeMarkWord();
 902         } else {
 903             return UNSAFE.getAddress(getMetaspaceKlass() + config.prototypeMarkWordOffset);
 904         }
 905     }
 906 
 907     @Override
 908     public ResolvedJavaField findInstanceFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 909         ResolvedJavaField[] declaredFields = getInstanceFields(true);
 910         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 911     }
 912 
 913     public ResolvedJavaField findStaticFieldWithOffset(long offset, JavaKind expectedEntryKind) {
 914         ResolvedJavaField[] declaredFields = getStaticFields();
 915         return findFieldWithOffset(offset, expectedEntryKind, declaredFields);
 916     }
 917 
 918     private static ResolvedJavaField findFieldWithOffset(long offset, JavaKind expectedEntryKind, ResolvedJavaField[] declaredFields) {
 919         for (ResolvedJavaField field : declaredFields) {
 920             long resolvedFieldOffset = field.getOffset();
 921             // @formatter:off
 922             if (ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN &amp;&amp;
 923                     expectedEntryKind.isPrimitive() &amp;&amp;
 924                     !expectedEntryKind.equals(JavaKind.Void) &amp;&amp;
 925                     field.getJavaKind().isPrimitive()) {
 926                 resolvedFieldOffset +=
 927                         field.getJavaKind().getByteCount() -
 928                                 Math.min(field.getJavaKind().getByteCount(), 4 + expectedEntryKind.getByteCount());
 929             }
 930             if (resolvedFieldOffset == offset) {
 931                 return field;
 932             }
 933             // @formatter:on
 934         }
 935         return null;
 936     }
 937 
 938     @Override
 939     public boolean isLocal() {
 940         return runtime().reflection.isLocalClass(this);
 941     }
 942 
 943     @Override
 944     public boolean isMember() {
 945         return runtime().reflection.isMemberClass(this);
 946     }
 947 
 948     @Override
 949     public HotSpotResolvedObjectType getEnclosingType() {
 950         return runtime().reflection.getEnclosingClass(this);
 951     }
 952 
 953     @Override
 954     public ResolvedJavaMethod[] getDeclaredConstructors() {
 955         return runtime().compilerToVm.getDeclaredConstructors(this);
 956     }
 957 
 958     @Override
 959     public ResolvedJavaMethod[] getDeclaredMethods() {
 960         return runtime().compilerToVm.getDeclaredMethods(this);
 961     }
 962 
 963     @Override
 964     public ResolvedJavaMethod getClassInitializer() {
 965         if (!isArray()) {
 966             return compilerToVM().getClassInitializer(this);
 967         }
 968         return null;
 969     }
 970 
 971     @Override
 972     public String toString() {
 973         return &quot;HotSpotType&lt;&quot; + getName() + &quot;, resolved&gt;&quot;;
 974     }
 975 
 976     @Override
 977     public ResolvedJavaType lookupType(UnresolvedJavaType unresolvedJavaType, boolean resolve) {
 978         JavaType javaType = HotSpotJVMCIRuntime.runtime().lookupType(unresolvedJavaType.getName(), this, resolve);
 979         if (javaType instanceof ResolvedJavaType) {
 980             return (ResolvedJavaType) javaType;
 981         }
 982         return null;
 983     }
 984 
 985     @Override
 986     public ResolvedJavaField resolveField(UnresolvedJavaField unresolvedJavaField, ResolvedJavaType accessingClass) {
 987         for (ResolvedJavaField field : getInstanceFields(false)) {
 988             if (field.getName().equals(unresolvedJavaField.getName())) {
 989                 return field;
 990             }
 991         }
 992         for (ResolvedJavaField field : getStaticFields()) {
 993             if (field.getName().equals(unresolvedJavaField.getName())) {
 994                 return field;
 995             }
 996         }
 997         throw new InternalError(unresolvedJavaField.toString());
 998     }
 999 
1000     @Override
1001     public boolean isCloneableWithAllocation() {
1002         return (getAccessFlags() &amp; config().jvmAccIsCloneableFast) != 0;
1003     }
1004 
1005     JavaConstant readFieldValue(HotSpotResolvedJavaField field, boolean isVolatile) {
1006         return runtime().reflection.readFieldValue(this, field, isVolatile);
1007     }
1008 
1009     private int getMiscFlags() {
1010         return UNSAFE.getInt(getMetaspaceKlass() + config().instanceKlassMiscFlagsOffset);
1011     }
1012 
1013     @Override
1014     public boolean isUnsafeAnonymous() {
1015         return (getMiscFlags() &amp; config().instanceKlassMiscIsUnsafeAnonymous) != 0;
1016     }
1017 
1018 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jlink/share/classes/jdk/tools/jmod/JmodTask.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.tools.jmod;
  27 
  28 import java.io.ByteArrayInputStream;
  29 import java.io.ByteArrayOutputStream;
  30 import java.io.File;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.OutputStream;
  34 import java.io.PrintWriter;
  35 import java.io.UncheckedIOException;
  36 import java.lang.module.Configuration;
  37 import java.lang.module.FindException;
  38 import java.lang.module.ModuleDescriptor;
  39 import java.lang.module.ModuleDescriptor.Exports;
  40 import java.lang.module.ModuleDescriptor.Opens;
  41 import java.lang.module.ModuleDescriptor.Provides;
  42 import java.lang.module.ModuleDescriptor.Version;
  43 import java.lang.module.ModuleFinder;
  44 import java.lang.module.ModuleReader;
  45 import java.lang.module.ModuleReference;
  46 import java.lang.module.ResolutionException;
  47 import java.lang.module.ResolvedModule;
  48 import java.net.URI;
  49 import java.nio.file.*;
  50 import java.nio.file.attribute.BasicFileAttributes;
  51 import java.text.MessageFormat;
  52 import java.util.*;
  53 import java.util.function.Consumer;
  54 import java.util.function.Predicate;
  55 import java.util.function.Supplier;
  56 import java.util.jar.JarEntry;
  57 import java.util.jar.JarFile;
  58 import java.util.jar.JarOutputStream;
  59 import java.util.regex.Pattern;
  60 import java.util.regex.PatternSyntaxException;
  61 import java.util.stream.Collectors;
  62 import java.util.zip.ZipEntry;
  63 import java.util.zip.ZipException;
  64 import java.util.zip.ZipFile;
  65 
  66 import jdk.internal.jmod.JmodFile;
  67 import jdk.internal.jmod.JmodFile.Section;
  68 import jdk.internal.joptsimple.BuiltinHelpFormatter;
  69 import jdk.internal.joptsimple.NonOptionArgumentSpec;
  70 import jdk.internal.joptsimple.OptionDescriptor;
  71 import jdk.internal.joptsimple.OptionException;
  72 import jdk.internal.joptsimple.OptionParser;
  73 import jdk.internal.joptsimple.OptionSet;
  74 import jdk.internal.joptsimple.OptionSpec;
  75 import jdk.internal.joptsimple.ValueConverter;
  76 import jdk.internal.module.ModuleHashes;
  77 import jdk.internal.module.ModuleHashesBuilder;
  78 import jdk.internal.module.ModuleInfo;
  79 import jdk.internal.module.ModuleInfoExtender;
  80 import jdk.internal.module.ModulePath;
  81 import jdk.internal.module.ModuleResolution;
  82 import jdk.internal.module.ModuleTarget;
  83 import jdk.internal.module.Resources;
  84 import jdk.tools.jlink.internal.Utils;
  85 
  86 import static java.util.stream.Collectors.joining;
  87 
  88 /**
  89  * Implementation for the jmod tool.
  90  */
  91 public class JmodTask {
  92 
  93     static class CommandException extends RuntimeException {
  94         private static final long serialVersionUID = 0L;
  95         boolean showUsage;
  96 
  97         CommandException(String key, Object... args) {
  98             super(getMessageOrKey(key, args));
  99         }
 100 
 101         CommandException showUsage(boolean b) {
 102             showUsage = b;
 103             return this;
 104         }
 105 
 106         private static String getMessageOrKey(String key, Object... args) {
 107             try {
 108                 return MessageFormat.format(ResourceBundleHelper.bundle.getString(key), args);
 109             } catch (MissingResourceException e) {
 110                 return key;
 111             }
 112         }
 113     }
 114 
 115     private static final String PROGNAME = &quot;jmod&quot;;
 116     private static final String MODULE_INFO = &quot;module-info.class&quot;;
 117 
 118     private static final Path CWD = Paths.get(&quot;&quot;);
 119 
 120     private Options options;
 121     private PrintWriter out = new PrintWriter(System.out, true);
 122     void setLog(PrintWriter out, PrintWriter err) {
 123         this.out = out;
 124     }
 125 
 126     /* Result codes. */
 127     static final int EXIT_OK = 0, // Completed with no errors.
 128                      EXIT_ERROR = 1, // Completed but reported errors.
 129                      EXIT_CMDERR = 2, // Bad command-line arguments
 130                      EXIT_SYSERR = 3, // System error or resource exhaustion.
 131                      EXIT_ABNORMAL = 4;// terminated abnormally
 132 
 133     enum Mode {
 134         CREATE,
 135         EXTRACT,
 136         LIST,
 137         DESCRIBE,
 138         HASH
 139     };
 140 
 141     static class Options {
 142         Mode mode;
 143         Path jmodFile;
 144         boolean help;
 145         boolean helpExtra;
 146         boolean version;
 147         List&lt;Path&gt; classpath;
 148         List&lt;Path&gt; cmds;
 149         List&lt;Path&gt; configs;
 150         List&lt;Path&gt; libs;
 151         List&lt;Path&gt; headerFiles;
 152         List&lt;Path&gt; manPages;
 153         List&lt;Path&gt; legalNotices;;
 154         ModuleFinder moduleFinder;
 155         Version moduleVersion;
 156         String mainClass;
 157         String targetPlatform;
 158         Pattern modulesToHash;
 159         ModuleResolution moduleResolution;
 160         boolean dryrun;
 161         List&lt;PathMatcher&gt; excludes;
 162         Path extractDir;
 163     }
 164 
 165     public int run(String[] args) {
 166 
 167         try {
 168             handleOptions(args);
 169             if (options == null) {
 170                 showUsageSummary();
 171                 return EXIT_CMDERR;
 172             }
 173             if (options.help || options.helpExtra) {
 174                 showHelp();
 175                 return EXIT_OK;
 176             }
 177             if (options.version) {
 178                 showVersion();
 179                 return EXIT_OK;
 180             }
 181 
 182             boolean ok;
 183             switch (options.mode) {
 184                 case CREATE:
 185                     ok = create();
 186                     break;
 187                 case EXTRACT:
 188                     ok = extract();
 189                     break;
 190                 case LIST:
 191                     ok = list();
 192                     break;
 193                 case DESCRIBE:
 194                     ok = describe();
 195                     break;
 196                 case HASH:
 197                     ok = hashModules();
 198                     break;
 199                 default:
 200                     throw new AssertionError(&quot;Unknown mode: &quot; + options.mode.name());
 201             }
 202 
 203             return ok ? EXIT_OK : EXIT_ERROR;
 204         } catch (CommandException e) {
 205             reportError(e.getMessage());
 206             if (e.showUsage)
 207                 showUsageSummary();
 208             return EXIT_CMDERR;
 209         } catch (Exception x) {
 210             reportError(x.getMessage());
 211             x.printStackTrace();
 212             return EXIT_ABNORMAL;
 213         } finally {
 214             out.flush();
 215         }
 216     }
 217 
 218     private boolean list() throws IOException {
 219         ZipFile zip = null;
 220         try {
 221             try {
 222                 zip = new ZipFile(options.jmodFile.toFile());
 223             } catch (IOException x) {
 224                 throw new IOException(&quot;error opening jmod file&quot;, x);
 225             }
 226 
 227             // Trivially print the archive entries for now, pending a more complete implementation
 228             zip.stream().forEach(e -&gt; out.println(e.getName()));
 229             return true;
 230         } finally {
 231             if (zip != null)
 232                 zip.close();
 233         }
 234     }
 235 
 236     private boolean extract() throws IOException {
 237         Path dir = options.extractDir != null ? options.extractDir : CWD;
 238         try (JmodFile jf = new JmodFile(options.jmodFile)) {
 239             jf.stream().forEach(e -&gt; {
 240                 try {
 241                     ZipEntry entry = e.zipEntry();
 242                     String name = entry.getName();
 243                     int index = name.lastIndexOf(&quot;/&quot;);
 244                     if (index != -1) {
 245                         Path p = dir.resolve(name.substring(0, index));
 246                         if (Files.notExists(p))
 247                             Files.createDirectories(p);
 248                     }
 249 
 250                     try (OutputStream os = Files.newOutputStream(dir.resolve(name))) {
 251                         jf.getInputStream(e).transferTo(os);
 252                     }
 253                 } catch (IOException x) {
 254                     throw new UncheckedIOException(x);
 255                 }
 256             });
 257 
 258             return true;
 259         }
 260     }
 261 
 262     private boolean hashModules() {
 263         if (options.dryrun) {
 264             out.println(&quot;Dry run:&quot;);
 265         }
 266 
 267         Hasher hasher = new Hasher(options.moduleFinder);
 268         hasher.computeHashes().forEach((mn, hashes) -&gt; {
 269             if (options.dryrun) {
 270                 out.format(&quot;%s%n&quot;, mn);
 271                 hashes.names().stream()
 272                     .sorted()
 273                     .forEach(name -&gt; out.format(&quot;  hashes %s %s %s%n&quot;,
 274                         name, hashes.algorithm(), toHex(hashes.hashFor(name))));
 275             } else {
 276                 try {
 277                     hasher.updateModuleInfo(mn, hashes);
 278                 } catch (IOException ex) {
 279                     throw new UncheckedIOException(ex);
 280                 }
 281             }
 282         });
 283         return true;
 284     }
 285 
 286     private boolean describe() throws IOException {
 287         try (JmodFile jf = new JmodFile(options.jmodFile)) {
 288             try (InputStream in = jf.getInputStream(Section.CLASSES, MODULE_INFO)) {
 289                 ModuleInfo.Attributes attrs = ModuleInfo.read(in, null);
 290                 describeModule(attrs.descriptor(),
 291                                attrs.target(),
 292                                attrs.recordedHashes());
 293                 return true;
 294             } catch (IOException e) {
 295                 throw new CommandException(&quot;err.module.descriptor.not.found&quot;);
 296             }
 297         }
 298     }
 299 
 300     static &lt;T&gt; String toLowerCaseString(Collection&lt;T&gt; c) {
 301         if (c.isEmpty()) { return &quot;&quot;; }
 302         return &quot; &quot; + c.stream().map(e -&gt; e.toString().toLowerCase(Locale.ROOT))
 303                 .sorted().collect(joining(&quot; &quot;));
 304     }
 305 
 306     static &lt;T&gt; String toString(Collection&lt;T&gt; c) {
 307         if (c.isEmpty()) { return &quot;&quot;; }
 308         return &quot; &quot; + c.stream().map(e -&gt; e.toString()).sorted().collect(joining(&quot; &quot;));
 309     }
 310 
 311     private void describeModule(ModuleDescriptor md,
 312                                 ModuleTarget target,
 313                                 ModuleHashes hashes)
 314         throws IOException
 315     {
 316         StringBuilder sb = new StringBuilder();
 317 
 318         sb.append(md.toNameAndVersion());
 319 
 320         if (md.isOpen())
 321             sb.append(&quot; open&quot;);
 322         if (md.isAutomatic())
 323             sb.append(&quot; automatic&quot;);
 324         sb.append(&quot;\n&quot;);
 325 
 326         // unqualified exports (sorted by package)
 327         md.exports().stream()
 328                 .sorted(Comparator.comparing(Exports::source))
 329                 .filter(e -&gt; !e.isQualified())
 330                 .forEach(e -&gt; sb.append(&quot;exports &quot;).append(e.source())
 331                                 .append(toLowerCaseString(e.modifiers())).append(&quot;\n&quot;));
 332 
 333         // dependences
 334         md.requires().stream().sorted()
 335                 .forEach(r -&gt; sb.append(&quot;requires &quot;).append(r.name())
 336                                 .append(toLowerCaseString(r.modifiers())).append(&quot;\n&quot;));
 337 
 338         // service use and provides
 339         md.uses().stream().sorted()
 340                 .forEach(s -&gt; sb.append(&quot;uses &quot;).append(s).append(&quot;\n&quot;));
 341 
 342         md.provides().stream()
 343                 .sorted(Comparator.comparing(Provides::service))
 344                 .forEach(p -&gt; sb.append(&quot;provides &quot;).append(p.service())
 345                                 .append(&quot; with&quot;)
 346                                 .append(toString(p.providers()))
 347                                 .append(&quot;\n&quot;));
 348 
 349         // qualified exports
 350         md.exports().stream()
 351                 .sorted(Comparator.comparing(Exports::source))
 352                 .filter(Exports::isQualified)
 353                 .forEach(e -&gt; sb.append(&quot;qualified exports &quot;).append(e.source())
 354                                 .append(&quot; to&quot;).append(toLowerCaseString(e.targets()))
 355                                 .append(&quot;\n&quot;));
 356 
 357         // open packages
 358         md.opens().stream()
 359                 .sorted(Comparator.comparing(Opens::source))
 360                 .filter(o -&gt; !o.isQualified())
 361                 .forEach(o -&gt; sb.append(&quot;opens &quot;).append(o.source())
 362                                  .append(toLowerCaseString(o.modifiers()))
 363                                  .append(&quot;\n&quot;));
 364 
 365         md.opens().stream()
 366                 .sorted(Comparator.comparing(Opens::source))
 367                 .filter(Opens::isQualified)
 368                 .forEach(o -&gt; sb.append(&quot;qualified opens &quot;).append(o.source())
 369                                  .append(toLowerCaseString(o.modifiers()))
 370                                  .append(&quot; to&quot;).append(toLowerCaseString(o.targets()))
 371                                  .append(&quot;\n&quot;));
 372 
 373         // non-exported/non-open packages
 374         Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
 375         md.exports().stream().map(Exports::source).forEach(concealed::remove);
 376         md.opens().stream().map(Opens::source).forEach(concealed::remove);
 377         concealed.forEach(p -&gt; sb.append(&quot;contains &quot;).append(p).append(&quot;\n&quot;));
 378 
 379         md.mainClass().ifPresent(v -&gt; sb.append(&quot;main-class &quot;).append(v).append(&quot;\n&quot;));
 380 
 381         if (target != null) {
 382             String targetPlatform = target.targetPlatform();
 383             if (!targetPlatform.isEmpty())
 384                 sb.append(&quot;platform &quot;).append(targetPlatform).append(&quot;\n&quot;);
 385        }
 386 
 387        if (hashes != null) {
 388            hashes.names().stream().sorted().forEach(
 389                    mod -&gt; sb.append(&quot;hashes &quot;).append(mod).append(&quot; &quot;)
 390                             .append(hashes.algorithm()).append(&quot; &quot;)
 391                             .append(toHex(hashes.hashFor(mod)))
 392                             .append(&quot;\n&quot;));
 393         }
 394 
 395         out.println(sb.toString());
 396     }
 397 
 398     private String toHex(byte[] ba) {
 399         StringBuilder sb = new StringBuilder(ba.length);
 400         for (byte b: ba) {
 401             sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
 402         }
 403         return sb.toString();
 404     }
 405 
 406     private boolean create() throws IOException {
 407         JmodFileWriter jmod = new JmodFileWriter();
 408 
 409         // create jmod with temporary name to avoid it being examined
 410         // when scanning the module path
 411         Path target = options.jmodFile;
 412         Path tempTarget = jmodTempFilePath(target);
 413         try {
 414             try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget)) {
 415                 jmod.write(jos);
 416             }
 417             Files.move(tempTarget, target);
 418         } catch (Exception e) {
 419             try {
 420                 Files.deleteIfExists(tempTarget);
 421             } catch (IOException ioe) {
 422                 e.addSuppressed(ioe);
 423             }
 424             throw e;
 425         }
 426         return true;
 427     }
 428 
 429     /*
 430      * Create a JMOD .tmp file for the given target JMOD file
 431      */
 432     private static Path jmodTempFilePath(Path target) throws IOException {
 433         return target.resolveSibling(&quot;.&quot; + target.getFileName() + &quot;.tmp&quot;);
 434     }
 435 
 436     private class JmodFileWriter {
 437         final List&lt;Path&gt; cmds = options.cmds;
 438         final List&lt;Path&gt; libs = options.libs;
 439         final List&lt;Path&gt; configs = options.configs;
 440         final List&lt;Path&gt; classpath = options.classpath;
 441         final List&lt;Path&gt; headerFiles = options.headerFiles;
 442         final List&lt;Path&gt; manPages = options.manPages;
 443         final List&lt;Path&gt; legalNotices = options.legalNotices;
 444 
 445         final Version moduleVersion = options.moduleVersion;
 446         final String mainClass = options.mainClass;
 447         final String targetPlatform = options.targetPlatform;
 448         final List&lt;PathMatcher&gt; excludes = options.excludes;
 449         final ModuleResolution moduleResolution = options.moduleResolution;
 450 
 451         JmodFileWriter() { }
 452 
 453         /**
 454          * Writes the jmod to the given output stream.
 455          */
 456         void write(JmodOutputStream out) throws IOException {
 457             // module-info.class
 458             writeModuleInfo(out, findPackages(classpath));
 459 
 460             // classes
 461             processClasses(out, classpath);
 462 
 463             processSection(out, Section.CONFIG, configs);
 464             processSection(out, Section.HEADER_FILES, headerFiles);
 465             processSection(out, Section.LEGAL_NOTICES, legalNotices);
 466             processSection(out, Section.MAN_PAGES, manPages);
 467             processSection(out, Section.NATIVE_CMDS, cmds);
 468             processSection(out, Section.NATIVE_LIBS, libs);
 469 
 470         }
 471 
 472         /**
 473          * Returns a supplier of an input stream to the module-info.class
 474          * on the class path of directories and JAR files.
 475          */
 476         Supplier&lt;InputStream&gt; newModuleInfoSupplier() throws IOException {
 477             ByteArrayOutputStream baos = new ByteArrayOutputStream();
 478             for (Path e: classpath) {
 479                 if (Files.isDirectory(e)) {
 480                     Path mi = e.resolve(MODULE_INFO);
 481                     if (Files.isRegularFile(mi)) {
 482                         Files.copy(mi, baos);
 483                         break;
 484                     }
 485                 } else if (Files.isRegularFile(e) &amp;&amp; e.toString().endsWith(&quot;.jar&quot;)) {
 486                     try (JarFile jf = new JarFile(e.toFile())) {
 487                         ZipEntry entry = jf.getEntry(MODULE_INFO);
 488                         if (entry != null) {
 489                             jf.getInputStream(entry).transferTo(baos);
 490                             break;
 491                         }
 492                     } catch (ZipException x) {
 493                         // Skip. Do nothing. No packages will be added.
 494                     }
 495                 }
 496             }
 497             if (baos.size() == 0) {
 498                 return null;
 499             } else {
 500                 byte[] bytes = baos.toByteArray();
 501                 return () -&gt; new ByteArrayInputStream(bytes);
 502             }
 503         }
 504 
 505         /**
 506          * Writes the updated module-info.class to the ZIP output stream.
 507          *
 508          * The updated module-info.class will have a Packages attribute
 509          * with the set of module-private/non-exported packages.
 510          *
 511          * If --module-version, --main-class, or other options were provided
 512          * then the corresponding class file attributes are added to the
 513          * module-info here.
 514          */
 515         void writeModuleInfo(JmodOutputStream out, Set&lt;String&gt; packages)
 516             throws IOException
 517         {
 518             Supplier&lt;InputStream&gt; miSupplier = newModuleInfoSupplier();
 519             if (miSupplier == null) {
 520                 throw new IOException(MODULE_INFO + &quot; not found&quot;);
 521             }
 522 
 523             ModuleDescriptor descriptor;
 524             try (InputStream in = miSupplier.get()) {
 525                 descriptor = ModuleDescriptor.read(in);
 526             }
 527 
 528             // copy the module-info.class into the jmod with the additional
 529             // attributes for the version, main class and other meta data
 530             try (InputStream in = miSupplier.get()) {
 531                 ModuleInfoExtender extender = ModuleInfoExtender.newExtender(in);
 532 
 533                 // Add (or replace) the Packages attribute
 534                 if (packages != null) {
 535                     validatePackages(descriptor, packages);
 536                     extender.packages(packages);
 537                 }
 538 
 539                 // --main-class
 540                 if (mainClass != null)
 541                     extender.mainClass(mainClass);
 542 
 543                 // --target-platform
 544                 if (targetPlatform != null) {
 545                     extender.targetPlatform(targetPlatform);
 546                 }
 547 
 548                 // --module-version
 549                 if (moduleVersion != null)
 550                     extender.version(moduleVersion);
 551 
 552                 // --hash-modules
 553                 if (options.modulesToHash != null) {
 554                     // To compute hashes, it creates a Configuration to resolve
 555                     // a module graph.  The post-resolution check requires
 556                     // the packages in ModuleDescriptor be available for validation.
 557                     ModuleDescriptor md;
 558                     try (InputStream is = miSupplier.get()) {
 559                         md = ModuleDescriptor.read(is, () -&gt; packages);
 560                     }
 561 
 562                     ModuleHashes moduleHashes = computeHashes(md);
 563                     if (moduleHashes != null) {
 564                         extender.hashes(moduleHashes);
 565                     } else {
 566                         warning(&quot;warn.no.module.hashes&quot;, descriptor.name());
 567                     }
 568                 }
 569 
 570                 if (moduleResolution != null &amp;&amp; moduleResolution.value() != 0) {
 571                     extender.moduleResolution(moduleResolution);
 572                 }
 573 
 574                 // write the (possibly extended or modified) module-info.class
 575                 out.writeEntry(extender.toByteArray(), Section.CLASSES, MODULE_INFO);
 576             }
 577         }
 578 
 579         private void validatePackages(ModuleDescriptor descriptor, Set&lt;String&gt; packages) {
 580             Set&lt;String&gt; nonExistPackages = new TreeSet&lt;&gt;();
 581             descriptor.exports().stream()
 582                 .map(Exports::source)
 583                 .filter(pn -&gt; !packages.contains(pn))
 584                 .forEach(nonExistPackages::add);
 585 
 586             descriptor.opens().stream()
 587                 .map(Opens::source)
 588                 .filter(pn -&gt; !packages.contains(pn))
 589                 .forEach(nonExistPackages::add);
 590 
 591             if (!nonExistPackages.isEmpty()) {
 592                 throw new CommandException(&quot;err.missing.export.or.open.packages&quot;,
 593                     descriptor.name(), nonExistPackages);
 594             }
 595         }
 596 
 597         /*
 598          * Hasher resolves a module graph using the --hash-modules PATTERN
 599          * as the roots.
 600          *
 601          * The jmod file is being created and does not exist in the
 602          * given modulepath.
 603          */
 604         private ModuleHashes computeHashes(ModuleDescriptor descriptor) {
 605             String mn = descriptor.name();
 606             URI uri = options.jmodFile.toUri();
 607             ModuleReference mref = new ModuleReference(descriptor, uri) {
 608                 @Override
 609                 public ModuleReader open() {
 610                     throw new UnsupportedOperationException(&quot;opening &quot; + mn);
 611                 }
 612             };
 613 
 614             // compose a module finder with the module path and also
 615             // a module finder that can find the jmod file being created
 616             ModuleFinder finder = ModuleFinder.compose(options.moduleFinder,
 617                 new ModuleFinder() {
 618                     @Override
 619                     public Optional&lt;ModuleReference&gt; find(String name) {
 620                         if (descriptor.name().equals(name))
 621                             return Optional.of(mref);
 622                         else return Optional.empty();
 623                     }
 624 
 625                     @Override
 626                     public Set&lt;ModuleReference&gt; findAll() {
 627                         return Collections.singleton(mref);
 628                     }
 629                 });
 630 
 631             return new Hasher(mn, finder).computeHashes().get(mn);
 632         }
 633 
 634         /**
 635          * Returns the set of all packages on the given class path.
 636          */
 637         Set&lt;String&gt; findPackages(List&lt;Path&gt; classpath) {
 638             Set&lt;String&gt; packages = new HashSet&lt;&gt;();
 639             for (Path path : classpath) {
 640                 if (Files.isDirectory(path)) {
 641                     packages.addAll(findPackages(path));
 642                 } else if (Files.isRegularFile(path) &amp;&amp; path.toString().endsWith(&quot;.jar&quot;)) {
 643                     try (JarFile jf = new JarFile(path.toString())) {
 644                         packages.addAll(findPackages(jf));
 645                     } catch (ZipException x) {
 646                         // Skip. Do nothing. No packages will be added.
 647                     } catch (IOException ioe) {
 648                         throw new UncheckedIOException(ioe);
 649                     }
 650                 }
 651             }
 652             return packages;
 653         }
 654 
 655         /**
 656          * Returns the set of packages in the given directory tree.
 657          */
 658         Set&lt;String&gt; findPackages(Path dir) {
 659             try {
 660                 return Files.find(dir, Integer.MAX_VALUE,
 661                                   ((path, attrs) -&gt; attrs.isRegularFile()))
 662                         .map(dir::relativize)
 663                         .filter(path -&gt; isResource(path.toString()))
 664                         .map(path -&gt; toPackageName(path))
 665                         .filter(pkg -&gt; pkg.length() &gt; 0)
 666                         .distinct()
 667                         .collect(Collectors.toSet());
 668             } catch (IOException ioe) {
 669                 throw new UncheckedIOException(ioe);
 670             }
 671         }
 672 
 673         /**
 674          * Returns the set of packages in the given JAR file.
 675          */
 676         Set&lt;String&gt; findPackages(JarFile jf) {
 677             return jf.stream()
 678                      .filter(e -&gt; !e.isDirectory() &amp;&amp; isResource(e.getName()))
 679                      .map(e -&gt; toPackageName(e))
 680                      .filter(pkg -&gt; pkg.length() &gt; 0)
 681                      .distinct()
 682                      .collect(Collectors.toSet());
 683         }
 684 
 685         /**
 686          * Returns true if it&#39;s a .class or a resource with an effective
 687          * package name.
 688          */
 689         boolean isResource(String name) {
 690             name = name.replace(File.separatorChar, &#39;/&#39;);
 691             return name.endsWith(&quot;.class&quot;) || Resources.canEncapsulate(name);
 692         }
 693 
 694 
 695         String toPackageName(Path path) {
 696             String name = path.toString();
 697             int index = name.lastIndexOf(File.separatorChar);
 698             if (index != -1)
 699                 return name.substring(0, index).replace(File.separatorChar, &#39;.&#39;);
 700 
 701             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.equals(MODULE_INFO)) {
 702                 IOException e = new IOException(name  + &quot; in the unnamed package&quot;);
 703                 throw new UncheckedIOException(e);
 704             }
 705             return &quot;&quot;;
 706         }
 707 
 708         String toPackageName(ZipEntry entry) {
 709             String name = entry.getName();
 710             int index = name.lastIndexOf(&quot;/&quot;);
 711             if (index != -1)
 712                 return name.substring(0, index).replace(&#39;/&#39;, &#39;.&#39;);
 713 
 714             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.equals(MODULE_INFO)) {
 715                 IOException e = new IOException(name  + &quot; in the unnamed package&quot;);
 716                 throw new UncheckedIOException(e);
 717             }
 718             return &quot;&quot;;
 719         }
 720 
 721         void processClasses(JmodOutputStream out, List&lt;Path&gt; classpaths)
 722             throws IOException
 723         {
 724             if (classpaths == null)
 725                 return;
 726 
 727             for (Path p : classpaths) {
 728                 if (Files.isDirectory(p)) {
 729                     processSection(out, Section.CLASSES, p);
 730                 } else if (Files.isRegularFile(p) &amp;&amp; p.toString().endsWith(&quot;.jar&quot;)) {
 731                     try (JarFile jf = new JarFile(p.toFile())) {
 732                         JarEntryConsumer jec = new JarEntryConsumer(out, jf);
 733                         jf.stream().filter(jec).forEach(jec);
 734                     }
 735                 }
 736             }
 737         }
 738 
 739         void processSection(JmodOutputStream out, Section section, List&lt;Path&gt; paths)
 740             throws IOException
 741         {
 742             if (paths == null)
 743                 return;
 744 
 745             for (Path p : paths) {
 746                 processSection(out, section, p);
 747             }
 748         }
 749 
 750         void processSection(JmodOutputStream out, Section section, Path path)
 751             throws IOException
 752         {
 753             Files.walkFileTree(path, Set.of(FileVisitOption.FOLLOW_LINKS),
 754                 Integer.MAX_VALUE, new SimpleFileVisitor&lt;Path&gt;() {
 755                     @Override
 756                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
 757                         throws IOException
 758                     {
 759                         Path relPath = path.relativize(file);
 760                         if (relPath.toString().equals(MODULE_INFO)
 761                                 &amp;&amp; !Section.CLASSES.equals(section))
 762                             warning(&quot;warn.ignore.entry&quot;, MODULE_INFO, section);
 763 
 764                         if (!relPath.toString().equals(MODULE_INFO)
 765                                 &amp;&amp; !matches(relPath, excludes)) {
 766                             try (InputStream in = Files.newInputStream(file)) {
 767                                 out.writeEntry(in, section, relPath.toString());
 768                             } catch (IOException x) {
 769                                 if (x.getMessage().contains(&quot;duplicate entry&quot;)) {
 770                                     warning(&quot;warn.ignore.duplicate.entry&quot;,
 771                                             relPath.toString(), section);
 772                                     return FileVisitResult.CONTINUE;
 773                                 }
 774                                 throw x;
 775                             }
 776                         }
 777                         return FileVisitResult.CONTINUE;
 778                     }
 779                 });
 780         }
 781 
 782         boolean matches(Path path, List&lt;PathMatcher&gt; matchers) {
 783             if (matchers != null) {
 784                 for (PathMatcher pm : matchers) {
 785                     if (pm.matches(path))
 786                         return true;
 787                 }
 788             }
 789             return false;
 790         }
 791 
 792         class JarEntryConsumer implements Consumer&lt;JarEntry&gt;, Predicate&lt;JarEntry&gt; {
 793             final JmodOutputStream out;
 794             final JarFile jarfile;
 795             JarEntryConsumer(JmodOutputStream out, JarFile jarfile) {
 796                 this.out = out;
 797                 this.jarfile = jarfile;
 798             }
 799             @Override
 800             public void accept(JarEntry je) {
 801                 try (InputStream in = jarfile.getInputStream(je)) {
 802                     out.writeEntry(in, Section.CLASSES, je.getName());
 803                 } catch (IOException e) {
 804                     throw new UncheckedIOException(e);
 805                 }
 806             }
 807             @Override
 808             public boolean test(JarEntry je) {
 809                 String name = je.getName();
 810                 // ## no support for excludes. Is it really needed?
 811                 return !name.endsWith(MODULE_INFO) &amp;&amp; !je.isDirectory();
 812             }
 813         }
 814     }
 815 
 816     /**
 817      * Compute and record hashes
 818      */
 819     private class Hasher {
 820         final Configuration configuration;
 821         final ModuleHashesBuilder hashesBuilder;
 822         final Set&lt;String&gt; modules;
 823         final String moduleName;  // a specific module to record hashes, if set
 824 
 825         /**
 826          * This constructor is for jmod hash command.
 827          *
 828          * This Hasher will determine which modules to record hashes, i.e.
 829          * the module in a subgraph of modules to be hashed and that
 830          * has no outgoing edges.  It will record in each of these modules,
 831          * say `M`, with the the hashes of modules that depend upon M
 832          * directly or indirectly matching the specified --hash-modules pattern.
 833          */
 834         Hasher(ModuleFinder finder) {
 835             this(null, finder);
 836         }
 837 
 838         /**
 839          * Constructs a Hasher to compute hashes.
 840          *
 841          * If a module name `M` is specified, it will compute the hashes of
 842          * modules that depend upon M directly or indirectly matching the
 843          * specified --hash-modules pattern and record in the ModuleHashes
 844          * attribute in M&#39;s module-info.class.
 845          *
 846          * @param name    name of the module to record hashes
 847          * @param finder  module finder for the specified --module-path
 848          */
 849         Hasher(String name, ModuleFinder finder) {
 850             // Determine the modules that matches the pattern {@code modulesToHash}
 851             Set&lt;String&gt; roots = finder.findAll().stream()
 852                 .map(mref -&gt; mref.descriptor().name())
 853                 .filter(mn -&gt; options.modulesToHash.matcher(mn).find())
 854                 .collect(Collectors.toSet());
 855 
 856             // use system module path unless it creates a JMOD file for
 857             // a module that is present in the system image e.g. upgradeable
 858             // module
 859             ModuleFinder system;
 860             if (name != null &amp;&amp; ModuleFinder.ofSystem().find(name).isPresent()) {
 861                 system = ModuleFinder.of();
 862             } else {
 863                 system = ModuleFinder.ofSystem();
 864             }
 865             // get a resolved module graph
 866             Configuration config = null;
 867             try {
 868                 config = Configuration.empty().resolve(system, finder, roots);
 869             } catch (FindException | ResolutionException e) {
 870                 throw new CommandException(&quot;err.module.resolution.fail&quot;, e.getMessage());
 871             }
 872 
 873             this.moduleName = name;
 874             this.configuration = config;
 875 
 876             // filter modules resolved from the system module finder
 877             this.modules = config.modules().stream()
 878                 .map(ResolvedModule::name)
 879                 .filter(mn -&gt; roots.contains(mn) &amp;&amp; !system.find(mn).isPresent())
 880                 .collect(Collectors.toSet());
 881 
 882             this.hashesBuilder = new ModuleHashesBuilder(config, modules);
 883         }
 884 
 885         /**
 886          * Returns a map of a module M to record hashes of the modules
 887          * that depend upon M directly or indirectly.
 888          *
 889          * For jmod hash command, the returned map contains one entry
 890          * for each module M that has no outgoing edges to any of the
 891          * modules matching the specified --hash-modules pattern.
 892          *
 893          * Each entry represents a leaf node in a connected subgraph containing
 894          * M and other candidate modules from the module graph where M&#39;s outgoing
 895          * edges to any module other than the ones matching the specified
 896          * --hash-modules pattern are excluded.
 897          */
 898         Map&lt;String, ModuleHashes&gt; computeHashes() {
 899             if (hashesBuilder == null)
 900                 return null;
 901 
 902             if (moduleName != null) {
 903                 return hashesBuilder.computeHashes(Set.of(moduleName));
 904             } else {
 905                 return hashesBuilder.computeHashes(modules);
 906             }
 907         }
 908 
 909         /**
 910          * Reads the given input stream of module-info.class and write
 911          * the extended module-info.class with the given ModuleHashes
 912          *
 913          * @param in       InputStream of module-info.class
 914          * @param out      OutputStream to write the extended module-info.class
 915          * @param hashes   ModuleHashes
 916          */
 917         private void recordHashes(InputStream in, OutputStream out, ModuleHashes hashes)
 918             throws IOException
 919         {
 920             ModuleInfoExtender extender = ModuleInfoExtender.newExtender(in);
 921             extender.hashes(hashes);
 922             extender.write(out);
 923         }
 924 
 925         void updateModuleInfo(String name, ModuleHashes moduleHashes)
 926             throws IOException
 927         {
 928             Path target = moduleToPath(name);
 929             Path tempTarget = jmodTempFilePath(target);
 930             try {
 931                 if (target.getFileName().toString().endsWith(&quot;.jmod&quot;)) {
 932                     updateJmodFile(target, tempTarget, moduleHashes);
 933                 } else {
 934                     updateModularJar(target, tempTarget, moduleHashes);
 935                 }
 936             } catch (IOException|RuntimeException e) {
 937                 try {
 938                     Files.deleteIfExists(tempTarget);
 939                 } catch (IOException ioe) {
 940                     e.addSuppressed(ioe);
 941                 }
 942                 throw e;
 943             }
 944 
 945             out.println(getMessage(&quot;module.hashes.recorded&quot;, name));
 946             Files.move(tempTarget, target, StandardCopyOption.REPLACE_EXISTING);
 947         }
 948 
 949         private void updateModularJar(Path target, Path tempTarget,
 950                                       ModuleHashes moduleHashes)
 951             throws IOException
 952         {
 953             try (JarFile jf = new JarFile(target.toFile());
 954                  OutputStream out = Files.newOutputStream(tempTarget);
 955                  JarOutputStream jos = new JarOutputStream(out))
 956             {
 957                 jf.stream().forEach(e -&gt; {
 958                     try (InputStream in = jf.getInputStream(e)) {
 959                         if (e.getName().equals(MODULE_INFO)) {
 960                             // what about module-info.class in versioned entries?
 961                             ZipEntry ze = new ZipEntry(e.getName());
 962                             ze.setTime(System.currentTimeMillis());
 963                             jos.putNextEntry(ze);
 964                             recordHashes(in, jos, moduleHashes);
 965                             jos.closeEntry();
 966                         } else {
 967                             // Setting &quot;compressedSize&quot; to &quot;-1&quot; prevents an error
 968                             // in ZipOutputStream.closeEntry() if the newly
 969                             // deflated entry will have another size than the
 970                             // original compressed entry. See:
 971                             // ZipOutputStream.putNextEntry()/closeEntry()
 972                             e.setCompressedSize(-1);
 973                             jos.putNextEntry(e);
 974                             jos.write(in.readAllBytes());
 975                             jos.closeEntry();
 976                         }
 977                     } catch (IOException x) {
 978                         throw new UncheckedIOException(x);
 979                     }
 980                 });
 981             }
 982         }
 983 
 984         private void updateJmodFile(Path target, Path tempTarget,
 985                                     ModuleHashes moduleHashes)
 986             throws IOException
 987         {
 988 
 989             try (JmodFile jf = new JmodFile(target);
 990                  JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget))
 991             {
 992                 jf.stream().forEach(e -&gt; {
 993                     try (InputStream in = jf.getInputStream(e.section(), e.name())) {
 994                         if (e.name().equals(MODULE_INFO)) {
 995                             // replace module-info.class
 996                             ModuleInfoExtender extender =
 997                                 ModuleInfoExtender.newExtender(in);
 998                             extender.hashes(moduleHashes);
 999                             jos.writeEntry(extender.toByteArray(), e.section(), e.name());
1000                         } else {
1001                             jos.writeEntry(in, e);
1002                         }
1003                     } catch (IOException x) {
1004                         throw new UncheckedIOException(x);
1005                     }
1006                 });
1007             }
1008         }
1009 
1010         private Path moduleToPath(String name) {
1011             ResolvedModule rm = configuration.findModule(name).orElseThrow(
1012                 () -&gt; new InternalError(&quot;Selected module &quot; + name + &quot; not on module path&quot;));
1013 
1014             URI uri = rm.reference().location().get();
1015             Path path = Paths.get(uri);
1016             String fn = path.getFileName().toString();
1017             if (!fn.endsWith(&quot;.jar&quot;) &amp;&amp; !fn.endsWith(&quot;.jmod&quot;)) {
1018                 throw new InternalError(path + &quot; is not a modular JAR or jmod file&quot;);
1019             }
1020             return path;
1021         }
1022     }
1023 
1024     /**
1025      * An abstract converter that given a string representing a list of paths,
1026      * separated by the File.pathSeparator, returns a List of java.nio.Path&#39;s.
1027      * Specific subclasses should do whatever validation is required on the
1028      * individual path elements, if any.
1029      */
1030     static abstract class AbstractPathConverter implements ValueConverter&lt;List&lt;Path&gt;&gt; {
1031         @Override
1032         public List&lt;Path&gt; convert(String value) {
1033             List&lt;Path&gt; paths = new ArrayList&lt;&gt;();
1034             String[] pathElements = value.split(File.pathSeparator);
1035             for (String pathElement : pathElements) {
1036                 paths.add(toPath(pathElement));
1037             }
1038             return paths;
1039         }
1040 
1041         @SuppressWarnings(&quot;unchecked&quot;)
1042         @Override
1043         public Class&lt;List&lt;Path&gt;&gt; valueType() {
1044             return (Class&lt;List&lt;Path&gt;&gt;)(Object)List.class;
1045         }
1046 
1047         @Override public String valuePattern() { return &quot;path&quot;; }
1048 
1049         abstract Path toPath(String path);
1050     }
1051 
1052     static class ClassPathConverter extends AbstractPathConverter {
1053         static final ValueConverter&lt;List&lt;Path&gt;&gt; INSTANCE = new ClassPathConverter();
1054 
1055         @Override
1056         public Path toPath(String value) {
1057             try {
1058                 Path path = CWD.resolve(value);
1059                 if (Files.notExists(path))
1060                     throw new CommandException(&quot;err.path.not.found&quot;, path);
1061                 if (!(Files.isDirectory(path) ||
1062                         (Files.isRegularFile(path) &amp;&amp; path.toString().endsWith(&quot;.jar&quot;))))
1063                     throw new CommandException(&quot;err.invalid.class.path.entry&quot;, path);
1064                 return path;
1065             } catch (InvalidPathException x) {
1066                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1067             }
1068         }
1069     }
1070 
1071     static class DirPathConverter extends AbstractPathConverter {
1072         static final ValueConverter&lt;List&lt;Path&gt;&gt; INSTANCE = new DirPathConverter();
1073 
1074         @Override
1075         public Path toPath(String value) {
1076             try {
1077                 Path path = CWD.resolve(value);
1078                 if (Files.notExists(path))
1079                     throw new CommandException(&quot;err.path.not.found&quot;, path);
1080                 if (!Files.isDirectory(path))
1081                     throw new CommandException(&quot;err.path.not.a.dir&quot;, path);
1082                 return path;
1083             } catch (InvalidPathException x) {
1084                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1085             }
1086         }
1087     }
1088 
1089     static class ExtractDirPathConverter implements ValueConverter&lt;Path&gt; {
1090 
1091         @Override
1092         public Path convert(String value) {
1093             try {
1094                 Path path = CWD.resolve(value);
1095                 if (Files.exists(path)) {
1096                     if (!Files.isDirectory(path))
1097                         throw new CommandException(&quot;err.cannot.create.dir&quot;, path);
1098                 }
1099                 return path;
1100             } catch (InvalidPathException x) {
1101                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1102             }
1103         }
1104 
1105         @Override  public Class&lt;Path&gt; valueType() { return Path.class; }
1106 
1107         @Override  public String valuePattern() { return &quot;path&quot;; }
1108     }
1109 
1110     static class ModuleVersionConverter implements ValueConverter&lt;Version&gt; {
1111         @Override
1112         public Version convert(String value) {
1113             try {
1114                 return Version.parse(value);
1115             } catch (IllegalArgumentException x) {
1116                 throw new CommandException(&quot;err.invalid.version&quot;, x.getMessage());
1117             }
1118         }
1119 
1120         @Override public Class&lt;Version&gt; valueType() { return Version.class; }
1121 
1122         @Override public String valuePattern() { return &quot;module-version&quot;; }
1123     }
1124 
1125     static class WarnIfResolvedReasonConverter
1126         implements ValueConverter&lt;ModuleResolution&gt;
1127     {
1128         @Override
1129         public ModuleResolution convert(String value) {
1130             if (value.equals(&quot;deprecated&quot;))
1131                 return ModuleResolution.empty().withDeprecated();
1132             else if (value.equals(&quot;deprecated-for-removal&quot;))
1133                 return ModuleResolution.empty().withDeprecatedForRemoval();
1134             else if (value.equals(&quot;incubating&quot;))
1135                 return ModuleResolution.empty().withIncubating();
1136             else
1137                 throw new CommandException(&quot;err.bad.WarnIfResolvedReason&quot;, value);
1138         }
1139 
1140         @Override public Class&lt;ModuleResolution&gt; valueType() {
1141             return ModuleResolution.class;
1142         }
1143 
1144         @Override public String valuePattern() { return &quot;reason&quot;; }
1145     }
1146 
1147     static class PatternConverter implements ValueConverter&lt;Pattern&gt; {
1148         @Override
1149         public Pattern convert(String value) {
1150             try {
1151                 if (value.startsWith(&quot;regex:&quot;)) {
1152                     value = value.substring(&quot;regex:&quot;.length()).trim();
1153                 }
1154 
1155                 return Pattern.compile(value);
1156             } catch (PatternSyntaxException e) {
1157                 throw new CommandException(&quot;err.bad.pattern&quot;, value);
1158             }
1159         }
1160 
1161         @Override public Class&lt;Pattern&gt; valueType() { return Pattern.class; }
1162 
1163         @Override public String valuePattern() { return &quot;regex-pattern&quot;; }
1164     }
1165 
1166     static class PathMatcherConverter implements ValueConverter&lt;PathMatcher&gt; {
1167         @Override
1168         public PathMatcher convert(String pattern) {
1169             try {
1170                 return Utils.getPathMatcher(FileSystems.getDefault(), pattern);
1171             } catch (PatternSyntaxException e) {
1172                 throw new CommandException(&quot;err.bad.pattern&quot;, pattern);
1173             }
1174         }
1175 
1176         @Override public Class&lt;PathMatcher&gt; valueType() { return PathMatcher.class; }
1177 
1178         @Override public String valuePattern() { return &quot;pattern-list&quot;; }
1179     }
1180 
1181     /* Support for @&lt;file&gt; in jmod help */
1182     private static final String CMD_FILENAME = &quot;@&lt;filename&gt;&quot;;
1183 
1184     /**
1185      * This formatter is adding the @filename option and does the required
1186      * formatting.
1187      */
1188     private static final class JmodHelpFormatter extends BuiltinHelpFormatter {
1189 
1190         private final Options opts;
1191 
1192         private JmodHelpFormatter(Options opts) {
1193             super(80, 2);
1194             this.opts = opts;
1195         }
1196 
1197         @Override
1198         public String format(Map&lt;String, ? extends OptionDescriptor&gt; options) {
1199             Map&lt;String, OptionDescriptor&gt; all = new LinkedHashMap&lt;&gt;();
1200             all.putAll(options);
1201 
1202             // extra options
1203             if (!opts.helpExtra) {
1204                 all.remove(&quot;do-not-resolve-by-default&quot;);
1205                 all.remove(&quot;warn-if-resolved&quot;);
1206             }
1207 
1208             all.put(CMD_FILENAME, new OptionDescriptor() {
1209                 @Override
1210                 public List&lt;String&gt; options() {
1211                     List&lt;String&gt; ret = new ArrayList&lt;&gt;();
1212                     ret.add(CMD_FILENAME);
1213                     return ret;
1214                 }
1215                 @Override
1216                 public String description() { return getMessage(&quot;main.opt.cmdfile&quot;); }
1217                 @Override
1218                 public List&lt;?&gt; defaultValues() { return Collections.emptyList(); }
1219                 @Override
1220                 public boolean isRequired() { return false; }
1221                 @Override
1222                 public boolean acceptsArguments() { return false; }
1223                 @Override
1224                 public boolean requiresArgument() { return false; }
1225                 @Override
1226                 public String argumentDescription() { return null; }
1227                 @Override
1228                 public String argumentTypeIndicator() { return null; }
1229                 @Override
1230                 public boolean representsNonOptions() { return false; }
1231             });
1232             String content = super.format(all);
1233             StringBuilder builder = new StringBuilder();
1234 
1235             builder.append(getMessage(&quot;main.opt.mode&quot;)).append(&quot;\n  &quot;);
1236             builder.append(getMessage(&quot;main.opt.mode.create&quot;)).append(&quot;\n  &quot;);
1237             builder.append(getMessage(&quot;main.opt.mode.extract&quot;)).append(&quot;\n  &quot;);
1238             builder.append(getMessage(&quot;main.opt.mode.list&quot;)).append(&quot;\n  &quot;);
1239             builder.append(getMessage(&quot;main.opt.mode.describe&quot;)).append(&quot;\n  &quot;);
1240             builder.append(getMessage(&quot;main.opt.mode.hash&quot;)).append(&quot;\n\n&quot;);
1241 
1242             String cmdfile = null;
1243             String[] lines = content.split(&quot;\n&quot;);
1244             for (String line : lines) {
1245                 if (line.startsWith(&quot;--@&quot;)) {
1246                     cmdfile = line.replace(&quot;--&quot; + CMD_FILENAME, CMD_FILENAME + &quot;  &quot;);
1247                 } else if (line.startsWith(&quot;Option&quot;) || line.startsWith(&quot;------&quot;)) {
1248                     builder.append(&quot; &quot;).append(line).append(&quot;\n&quot;);
1249                 } else if (!line.matches(&quot;Non-option arguments&quot;)){
1250                     builder.append(&quot;  &quot;).append(line).append(&quot;\n&quot;);
1251                 }
1252             }
1253             if (cmdfile != null) {
1254                 builder.append(&quot;  &quot;).append(cmdfile).append(&quot;\n&quot;);
1255             }
1256             return builder.toString();
1257         }
1258     }
1259 
1260     private final OptionParser parser = new OptionParser(&quot;hp&quot;);
1261 
1262     private void handleOptions(String[] args) {
1263         options = new Options();
1264         parser.formatHelpWith(new JmodHelpFormatter(options));
1265 
1266         OptionSpec&lt;List&lt;Path&gt;&gt; classPath
1267                 = parser.accepts(&quot;class-path&quot;, getMessage(&quot;main.opt.class-path&quot;))
1268                         .withRequiredArg()
1269                         .withValuesConvertedBy(ClassPathConverter.INSTANCE);
1270 
1271         OptionSpec&lt;List&lt;Path&gt;&gt; cmds
1272                 = parser.accepts(&quot;cmds&quot;, getMessage(&quot;main.opt.cmds&quot;))
1273                         .withRequiredArg()
1274                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1275 
1276         OptionSpec&lt;List&lt;Path&gt;&gt; config
1277                 = parser.accepts(&quot;config&quot;, getMessage(&quot;main.opt.config&quot;))
1278                         .withRequiredArg()
1279                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1280 
1281         OptionSpec&lt;Path&gt; dir
1282                 = parser.accepts(&quot;dir&quot;, getMessage(&quot;main.opt.extractDir&quot;))
1283                         .withRequiredArg()
1284                         .withValuesConvertedBy(new ExtractDirPathConverter());
1285 
1286         OptionSpec&lt;Void&gt; dryrun
1287                 = parser.accepts(&quot;dry-run&quot;, getMessage(&quot;main.opt.dry-run&quot;));
1288 
1289         OptionSpec&lt;PathMatcher&gt; excludes
1290                 = parser.accepts(&quot;exclude&quot;, getMessage(&quot;main.opt.exclude&quot;))
1291                         .withRequiredArg()
1292                         .withValuesConvertedBy(new PathMatcherConverter());
1293 
1294         OptionSpec&lt;Pattern&gt; hashModules
1295                 = parser.accepts(&quot;hash-modules&quot;, getMessage(&quot;main.opt.hash-modules&quot;))
1296                         .withRequiredArg()
1297                         .withValuesConvertedBy(new PatternConverter());
1298 
1299         OptionSpec&lt;Void&gt; help
1300                 = parser.acceptsAll(List.of(&quot;h&quot;, &quot;help&quot;, &quot;?&quot;), getMessage(&quot;main.opt.help&quot;))
1301                         .forHelp();
1302 
1303         OptionSpec&lt;Void&gt; helpExtra
1304                 = parser.accepts(&quot;help-extra&quot;, getMessage(&quot;main.opt.help-extra&quot;));
1305 
1306         OptionSpec&lt;List&lt;Path&gt;&gt; headerFiles
1307                 = parser.accepts(&quot;header-files&quot;, getMessage(&quot;main.opt.header-files&quot;))
1308                         .withRequiredArg()
1309                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1310 
1311         OptionSpec&lt;List&lt;Path&gt;&gt; libs
1312                 = parser.accepts(&quot;libs&quot;, getMessage(&quot;main.opt.libs&quot;))
1313                         .withRequiredArg()
1314                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1315 
1316         OptionSpec&lt;List&lt;Path&gt;&gt; legalNotices
1317                 = parser.accepts(&quot;legal-notices&quot;, getMessage(&quot;main.opt.legal-notices&quot;))
1318                         .withRequiredArg()
1319                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1320 
1321 
1322         OptionSpec&lt;String&gt; mainClass
1323                 = parser.accepts(&quot;main-class&quot;, getMessage(&quot;main.opt.main-class&quot;))
1324                         .withRequiredArg()
1325                         .describedAs(getMessage(&quot;main.opt.main-class.arg&quot;));
1326 
1327         OptionSpec&lt;List&lt;Path&gt;&gt; manPages
1328                 = parser.accepts(&quot;man-pages&quot;, getMessage(&quot;main.opt.man-pages&quot;))
1329                         .withRequiredArg()
1330                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1331 
1332         OptionSpec&lt;List&lt;Path&gt;&gt; modulePath
1333                 = parser.acceptsAll(List.of(&quot;p&quot;, &quot;module-path&quot;),
1334                                     getMessage(&quot;main.opt.module-path&quot;))
1335                         .withRequiredArg()
1336                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1337 
1338         OptionSpec&lt;Version&gt; moduleVersion
1339                 = parser.accepts(&quot;module-version&quot;, getMessage(&quot;main.opt.module-version&quot;))
1340                         .withRequiredArg()
1341                         .withValuesConvertedBy(new ModuleVersionConverter());
1342 
1343         OptionSpec&lt;String&gt; targetPlatform
1344                 = parser.accepts(&quot;target-platform&quot;, getMessage(&quot;main.opt.target-platform&quot;))
1345                         .withRequiredArg()
1346                         .describedAs(getMessage(&quot;main.opt.target-platform.arg&quot;));
1347 
1348         OptionSpec&lt;Void&gt; doNotResolveByDefault
1349                 = parser.accepts(&quot;do-not-resolve-by-default&quot;,
1350                                  getMessage(&quot;main.opt.do-not-resolve-by-default&quot;));
1351 
1352         OptionSpec&lt;ModuleResolution&gt; warnIfResolved
1353                 = parser.accepts(&quot;warn-if-resolved&quot;, getMessage(&quot;main.opt.warn-if-resolved&quot;))
1354                         .withRequiredArg()
1355                         .withValuesConvertedBy(new WarnIfResolvedReasonConverter());
1356 
1357         OptionSpec&lt;Void&gt; version
1358                 = parser.accepts(&quot;version&quot;, getMessage(&quot;main.opt.version&quot;));
1359 
1360         NonOptionArgumentSpec&lt;String&gt; nonOptions
1361                 = parser.nonOptions();
1362 
1363         try {
1364             OptionSet opts = parser.parse(args);
1365 
1366             if (opts.has(help) || opts.has(helpExtra) || opts.has(version)) {
1367                 options.help = opts.has(help);
1368                 options.helpExtra = opts.has(helpExtra);
1369                 options.version = opts.has(version);
1370                 return;  // informational message will be shown
1371             }
1372 
1373             List&lt;String&gt; words = opts.valuesOf(nonOptions);
1374             if (words.isEmpty())
1375                 throw new CommandException(&quot;err.missing.mode&quot;).showUsage(true);
1376             String verb = words.get(0);
1377             try {
1378                 options.mode = Enum.valueOf(Mode.class, verb.toUpperCase());
1379             } catch (IllegalArgumentException e) {
1380                 throw new CommandException(&quot;err.invalid.mode&quot;, verb).showUsage(true);
1381             }
1382 
1383             if (opts.has(classPath))
1384                 options.classpath = getLastElement(opts.valuesOf(classPath));
1385             if (opts.has(cmds))
1386                 options.cmds = getLastElement(opts.valuesOf(cmds));
1387             if (opts.has(config))
1388                 options.configs = getLastElement(opts.valuesOf(config));
1389             if (opts.has(dir))
1390                 options.extractDir = getLastElement(opts.valuesOf(dir));
1391             if (opts.has(dryrun))
1392                 options.dryrun = true;
1393             if (opts.has(excludes))
1394                 options.excludes = opts.valuesOf(excludes);  // excludes is repeatable
1395             if (opts.has(libs))
1396                 options.libs = getLastElement(opts.valuesOf(libs));
1397             if (opts.has(headerFiles))
1398                 options.headerFiles = getLastElement(opts.valuesOf(headerFiles));
1399             if (opts.has(manPages))
1400                 options.manPages = getLastElement(opts.valuesOf(manPages));
1401             if (opts.has(legalNotices))
1402                 options.legalNotices = getLastElement(opts.valuesOf(legalNotices));
1403             if (opts.has(modulePath)) {
1404                 Path[] dirs = getLastElement(opts.valuesOf(modulePath)).toArray(new Path[0]);
1405                 options.moduleFinder = ModulePath.of(Runtime.version(), true, dirs);
1406             }
1407             if (opts.has(moduleVersion))
1408                 options.moduleVersion = getLastElement(opts.valuesOf(moduleVersion));
1409             if (opts.has(mainClass))
1410                 options.mainClass = getLastElement(opts.valuesOf(mainClass));
1411             if (opts.has(targetPlatform))
1412                 options.targetPlatform = getLastElement(opts.valuesOf(targetPlatform));
1413             if (opts.has(warnIfResolved))
1414                 options.moduleResolution = getLastElement(opts.valuesOf(warnIfResolved));
1415             if (opts.has(doNotResolveByDefault)) {
1416                 if (options.moduleResolution == null)
1417                     options.moduleResolution = ModuleResolution.empty();
1418                 options.moduleResolution = options.moduleResolution.withDoNotResolveByDefault();
1419             }
1420             if (opts.has(hashModules)) {
1421                 options.modulesToHash = getLastElement(opts.valuesOf(hashModules));
1422                 // if storing hashes then the module path is required
1423                 if (options.moduleFinder == null)
1424                     throw new CommandException(&quot;err.modulepath.must.be.specified&quot;)
1425                             .showUsage(true);
1426             }
1427 
1428             if (options.mode.equals(Mode.HASH)) {
1429                 if (options.moduleFinder == null || options.modulesToHash == null)
1430                     throw new CommandException(&quot;err.modulepath.must.be.specified&quot;)
1431                             .showUsage(true);
1432             } else {
1433                 if (words.size() &lt;= 1)
1434                     throw new CommandException(&quot;err.jmod.must.be.specified&quot;).showUsage(true);
1435                 Path path = Paths.get(words.get(1));
1436 
1437                 if (options.mode.equals(Mode.CREATE) &amp;&amp; Files.exists(path))
1438                     throw new CommandException(&quot;err.file.already.exists&quot;, path);
1439                 else if ((options.mode.equals(Mode.LIST) ||
1440                             options.mode.equals(Mode.DESCRIBE) ||
1441                             options.mode.equals((Mode.EXTRACT)))
1442                          &amp;&amp; Files.notExists(path))
1443                     throw new CommandException(&quot;err.jmod.not.found&quot;, path);
1444 
1445                 if (options.dryrun) {
1446                     throw new CommandException(&quot;err.invalid.dryrun.option&quot;);
1447                 }
1448                 options.jmodFile = path;
1449 
1450                 if (words.size() &gt; 2)
1451                     throw new CommandException(&quot;err.unknown.option&quot;,
1452                             words.subList(2, words.size())).showUsage(true);
1453             }
1454 
1455             if (options.mode.equals(Mode.CREATE) &amp;&amp; options.classpath == null)
1456                 throw new CommandException(&quot;err.classpath.must.be.specified&quot;).showUsage(true);
1457             if (options.mainClass != null &amp;&amp; !isValidJavaIdentifier(options.mainClass))
1458                 throw new CommandException(&quot;err.invalid.main-class&quot;, options.mainClass);
1459             if (options.mode.equals(Mode.EXTRACT) &amp;&amp; options.extractDir != null) {
1460                 try {
1461                     Files.createDirectories(options.extractDir);
1462                 } catch (IOException ioe) {
1463                     throw new CommandException(&quot;err.cannot.create.dir&quot;, options.extractDir);
1464                 }
1465             }
1466         } catch (OptionException e) {
1467              throw new CommandException(e.getMessage());
1468         }
1469     }
1470 
1471     /**
1472      * Returns true if, and only if, the given main class is a legal.
1473      */
1474     static boolean isValidJavaIdentifier(String mainClass) {
1475         if (mainClass.length() == 0)
1476             return false;
1477 
1478         if (!Character.isJavaIdentifierStart(mainClass.charAt(0)))
1479             return false;
1480 
1481         int n = mainClass.length();
1482         for (int i=1; i &lt; n; i++) {
1483             char c = mainClass.charAt(i);
1484             if (!Character.isJavaIdentifierPart(c) &amp;&amp; c != &#39;.&#39;)
1485                 return false;
1486         }
1487         if (mainClass.charAt(n-1) == &#39;.&#39;)
1488             return false;
1489 
1490         return true;
1491     }
1492 
1493     static &lt;E&gt; E getLastElement(List&lt;E&gt; list) {
1494         if (list.size() == 0)
1495             throw new InternalError(&quot;Unexpected 0 list size&quot;);
1496         return list.get(list.size() - 1);
1497     }
1498 
1499     private void reportError(String message) {
1500         out.println(getMessage(&quot;error.prefix&quot;) + &quot; &quot; + message);
1501     }
1502 
1503     private void warning(String key, Object... args) {
1504         out.println(getMessage(&quot;warn.prefix&quot;) + &quot; &quot; + getMessage(key, args));
1505     }
1506 
1507     private void showUsageSummary() {
1508         out.println(getMessage(&quot;main.usage.summary&quot;, PROGNAME));
1509     }
1510 
1511     private void showHelp() {
1512         out.println(getMessage(&quot;main.usage&quot;, PROGNAME));
1513         try {
1514             parser.printHelpOn(out);
1515         } catch (IOException x) {
1516             throw new AssertionError(x);
1517         }
1518     }
1519 
1520     private void showVersion() {
1521         out.println(version());
1522     }
1523 
1524     private String version() {
1525         return System.getProperty(&quot;java.version&quot;);
1526     }
1527 
1528     private static String getMessage(String key, Object... args) {
1529         try {
1530             return MessageFormat.format(ResourceBundleHelper.bundle.getString(key), args);
1531         } catch (MissingResourceException e) {
1532             throw new InternalError(&quot;Missing message: &quot; + key);
1533         }
1534     }
1535 
1536     private static class ResourceBundleHelper {
1537         static final ResourceBundle bundle;
1538 
1539         static {
1540             Locale locale = Locale.getDefault();
1541             try {
1542                 bundle = ResourceBundle.getBundle(&quot;jdk.tools.jmod.resources.jmod&quot;, locale);
1543             } catch (MissingResourceException e) {
1544                 throw new InternalError(&quot;Cannot find jmod resource bundle for locale &quot; + locale);
1545             }
1546         }
1547     }
1548 }
    </pre>
  </body>
</html>
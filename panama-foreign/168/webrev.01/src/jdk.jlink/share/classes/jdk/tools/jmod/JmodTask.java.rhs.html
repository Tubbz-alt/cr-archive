<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jlink/share/classes/jdk/tools/jmod/JmodTask.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.tools.jmod;
  27 
  28 import java.io.ByteArrayInputStream;
  29 import java.io.ByteArrayOutputStream;
  30 import java.io.File;
  31 import java.io.IOException;
  32 import java.io.InputStream;
  33 import java.io.OutputStream;
  34 import java.io.PrintWriter;
  35 import java.io.UncheckedIOException;
  36 import java.lang.module.Configuration;
  37 import java.lang.module.FindException;
  38 import java.lang.module.ModuleDescriptor;
  39 import java.lang.module.ModuleDescriptor.Exports;
  40 import java.lang.module.ModuleDescriptor.Opens;
  41 import java.lang.module.ModuleDescriptor.Provides;
  42 import java.lang.module.ModuleDescriptor.Version;
  43 import java.lang.module.ModuleFinder;
  44 import java.lang.module.ModuleReader;
  45 import java.lang.module.ModuleReference;
  46 import java.lang.module.ResolutionException;
  47 import java.lang.module.ResolvedModule;
  48 import java.net.URI;
  49 import java.nio.file.*;
  50 import java.nio.file.attribute.BasicFileAttributes;
  51 import java.text.MessageFormat;
  52 import java.util.*;
  53 import java.util.function.Consumer;
  54 import java.util.function.Predicate;
  55 import java.util.function.Supplier;
  56 import java.util.jar.JarEntry;
  57 import java.util.jar.JarFile;
  58 import java.util.jar.JarOutputStream;
  59 import java.util.regex.Pattern;
  60 import java.util.regex.PatternSyntaxException;
  61 import java.util.stream.Collectors;
  62 import java.util.zip.ZipEntry;
  63 import java.util.zip.ZipException;
  64 import java.util.zip.ZipFile;
  65 
  66 import jdk.internal.jmod.JmodFile;
  67 import jdk.internal.jmod.JmodFile.Section;
  68 import jdk.internal.joptsimple.BuiltinHelpFormatter;
  69 import jdk.internal.joptsimple.NonOptionArgumentSpec;
  70 import jdk.internal.joptsimple.OptionDescriptor;
  71 import jdk.internal.joptsimple.OptionException;
  72 import jdk.internal.joptsimple.OptionParser;
  73 import jdk.internal.joptsimple.OptionSet;
  74 import jdk.internal.joptsimple.OptionSpec;
  75 import jdk.internal.joptsimple.ValueConverter;
  76 import jdk.internal.module.ModuleHashes;
  77 import jdk.internal.module.ModuleHashesBuilder;
  78 import jdk.internal.module.ModuleInfo;
  79 import jdk.internal.module.ModuleInfoExtender;
  80 import jdk.internal.module.ModulePath;
  81 import jdk.internal.module.ModuleResolution;
  82 import jdk.internal.module.ModuleTarget;
  83 import jdk.internal.module.Resources;
  84 import jdk.tools.jlink.internal.Utils;
  85 
  86 import static java.util.stream.Collectors.joining;
  87 
  88 /**
  89  * Implementation for the jmod tool.
  90  */
  91 public class JmodTask {
  92 
  93     static class CommandException extends RuntimeException {
  94         private static final long serialVersionUID = 0L;
  95         boolean showUsage;
  96 
  97         CommandException(String key, Object... args) {
  98             super(getMessageOrKey(key, args));
  99         }
 100 
 101         CommandException showUsage(boolean b) {
 102             showUsage = b;
 103             return this;
 104         }
 105 
 106         private static String getMessageOrKey(String key, Object... args) {
 107             try {
 108                 return MessageFormat.format(ResourceBundleHelper.bundle.getString(key), args);
 109             } catch (MissingResourceException e) {
 110                 return key;
 111             }
 112         }
 113     }
 114 
 115     private static final String PROGNAME = &quot;jmod&quot;;
 116     private static final String MODULE_INFO = &quot;module-info.class&quot;;
 117 
 118     private static final Path CWD = Paths.get(&quot;&quot;);
 119 
 120     private Options options;
 121     private PrintWriter out = new PrintWriter(System.out, true);
 122     void setLog(PrintWriter out, PrintWriter err) {
 123         this.out = out;
 124     }
 125 
 126     /* Result codes. */
 127     static final int EXIT_OK = 0, // Completed with no errors.
 128                      EXIT_ERROR = 1, // Completed but reported errors.
 129                      EXIT_CMDERR = 2, // Bad command-line arguments
 130                      EXIT_SYSERR = 3, // System error or resource exhaustion.
 131                      EXIT_ABNORMAL = 4;// terminated abnormally
 132 
 133     enum Mode {
 134         CREATE,
 135         EXTRACT,
 136         LIST,
 137         DESCRIBE,
 138         HASH
 139     };
 140 
 141     static class Options {
 142         Mode mode;
 143         Path jmodFile;
 144         boolean help;
 145         boolean helpExtra;
 146         boolean version;
 147         List&lt;Path&gt; classpath;
 148         List&lt;Path&gt; cmds;
 149         List&lt;Path&gt; configs;
 150         List&lt;Path&gt; libs;
 151         List&lt;Path&gt; headerFiles;
 152         List&lt;Path&gt; manPages;
 153         List&lt;Path&gt; legalNotices;;
 154         ModuleFinder moduleFinder;
 155         Version moduleVersion;
 156         String mainClass;
 157         String targetPlatform;
 158         Pattern modulesToHash;
 159         ModuleResolution moduleResolution;
 160         boolean dryrun;
 161         List&lt;PathMatcher&gt; excludes;
 162         Path extractDir;
 163     }
 164 
 165     public int run(String[] args) {
 166 
 167         try {
 168             handleOptions(args);
 169             if (options == null) {
 170                 showUsageSummary();
 171                 return EXIT_CMDERR;
 172             }
 173             if (options.help || options.helpExtra) {
 174                 showHelp();
 175                 return EXIT_OK;
 176             }
 177             if (options.version) {
 178                 showVersion();
 179                 return EXIT_OK;
 180             }
 181 
 182             boolean ok;
 183             switch (options.mode) {
 184                 case CREATE:
 185                     ok = create();
 186                     break;
 187                 case EXTRACT:
 188                     ok = extract();
 189                     break;
 190                 case LIST:
 191                     ok = list();
 192                     break;
 193                 case DESCRIBE:
 194                     ok = describe();
 195                     break;
 196                 case HASH:
 197                     ok = hashModules();
 198                     break;
 199                 default:
 200                     throw new AssertionError(&quot;Unknown mode: &quot; + options.mode.name());
 201             }
 202 
 203             return ok ? EXIT_OK : EXIT_ERROR;
 204         } catch (CommandException e) {
 205             reportError(e.getMessage());
 206             if (e.showUsage)
 207                 showUsageSummary();
 208             return EXIT_CMDERR;
 209         } catch (Exception x) {
 210             reportError(x.getMessage());
 211             x.printStackTrace();
 212             return EXIT_ABNORMAL;
 213         } finally {
 214             out.flush();
 215         }
 216     }
 217 
 218     private boolean list() throws IOException {
 219         ZipFile zip = null;
 220         try {
 221             try {
 222                 zip = new ZipFile(options.jmodFile.toFile());
 223             } catch (IOException x) {
 224                 throw new IOException(&quot;error opening jmod file&quot;, x);
 225             }
 226 
 227             // Trivially print the archive entries for now, pending a more complete implementation
 228             zip.stream().forEach(e -&gt; out.println(e.getName()));
 229             return true;
 230         } finally {
 231             if (zip != null)
 232                 zip.close();
 233         }
 234     }
 235 
 236     private boolean extract() throws IOException {
 237         Path dir = options.extractDir != null ? options.extractDir : CWD;
 238         try (JmodFile jf = new JmodFile(options.jmodFile)) {
 239             jf.stream().forEach(e -&gt; {
 240                 try {
 241                     ZipEntry entry = e.zipEntry();
 242                     String name = entry.getName();
 243                     int index = name.lastIndexOf(&quot;/&quot;);
 244                     if (index != -1) {
 245                         Path p = dir.resolve(name.substring(0, index));
 246                         if (Files.notExists(p))
 247                             Files.createDirectories(p);
 248                     }
 249 
 250                     try (OutputStream os = Files.newOutputStream(dir.resolve(name))) {
 251                         jf.getInputStream(e).transferTo(os);
 252                     }
 253                 } catch (IOException x) {
 254                     throw new UncheckedIOException(x);
 255                 }
 256             });
 257 
 258             return true;
 259         }
 260     }
 261 
 262     private boolean hashModules() {
 263         if (options.dryrun) {
 264             out.println(&quot;Dry run:&quot;);
 265         }
 266 
 267         Hasher hasher = new Hasher(options.moduleFinder);
 268         hasher.computeHashes().forEach((mn, hashes) -&gt; {
 269             if (options.dryrun) {
 270                 out.format(&quot;%s%n&quot;, mn);
 271                 hashes.names().stream()
 272                     .sorted()
 273                     .forEach(name -&gt; out.format(&quot;  hashes %s %s %s%n&quot;,
 274                         name, hashes.algorithm(), toHex(hashes.hashFor(name))));
 275             } else {
 276                 try {
 277                     hasher.updateModuleInfo(mn, hashes);
 278                 } catch (IOException ex) {
 279                     throw new UncheckedIOException(ex);
 280                 }
 281             }
 282         });
 283         return true;
 284     }
 285 
 286     private boolean describe() throws IOException {
 287         try (JmodFile jf = new JmodFile(options.jmodFile)) {
 288             try (InputStream in = jf.getInputStream(Section.CLASSES, MODULE_INFO)) {
 289                 ModuleInfo.Attributes attrs = ModuleInfo.read(in, null);
 290                 describeModule(attrs.descriptor(),
 291                                attrs.target(),
 292                                attrs.recordedHashes());
 293                 return true;
 294             } catch (IOException e) {
 295                 throw new CommandException(&quot;err.module.descriptor.not.found&quot;);
 296             }
 297         }
 298     }
 299 
 300     static &lt;T&gt; String toLowerCaseString(Collection&lt;T&gt; c) {
 301         if (c.isEmpty()) { return &quot;&quot;; }
 302         return &quot; &quot; + c.stream().map(e -&gt; e.toString().toLowerCase(Locale.ROOT))
 303                 .sorted().collect(joining(&quot; &quot;));
 304     }
 305 
 306     static &lt;T&gt; String toString(Collection&lt;T&gt; c) {
 307         if (c.isEmpty()) { return &quot;&quot;; }
 308         return &quot; &quot; + c.stream().map(e -&gt; e.toString()).sorted().collect(joining(&quot; &quot;));
 309     }
 310 
 311     private void describeModule(ModuleDescriptor md,
 312                                 ModuleTarget target,
 313                                 ModuleHashes hashes)
 314         throws IOException
 315     {
 316         StringBuilder sb = new StringBuilder();
 317 
 318         sb.append(md.toNameAndVersion());
 319 
 320         if (md.isOpen())
 321             sb.append(&quot; open&quot;);
 322         if (md.isAutomatic())
 323             sb.append(&quot; automatic&quot;);
 324         sb.append(&quot;\n&quot;);
 325 
 326         // unqualified exports (sorted by package)
 327         md.exports().stream()
 328                 .sorted(Comparator.comparing(Exports::source))
 329                 .filter(e -&gt; !e.isQualified())
 330                 .forEach(e -&gt; sb.append(&quot;exports &quot;).append(e.source())
 331                                 .append(toLowerCaseString(e.modifiers())).append(&quot;\n&quot;));
 332 
 333         // dependences
 334         md.requires().stream().sorted()
 335                 .forEach(r -&gt; sb.append(&quot;requires &quot;).append(r.name())
 336                                 .append(toLowerCaseString(r.modifiers())).append(&quot;\n&quot;));
 337 
 338         // service use and provides
 339         md.uses().stream().sorted()
 340                 .forEach(s -&gt; sb.append(&quot;uses &quot;).append(s).append(&quot;\n&quot;));
 341 
 342         md.provides().stream()
 343                 .sorted(Comparator.comparing(Provides::service))
 344                 .forEach(p -&gt; sb.append(&quot;provides &quot;).append(p.service())
 345                                 .append(&quot; with&quot;)
 346                                 .append(toString(p.providers()))
 347                                 .append(&quot;\n&quot;));
 348 
 349         // qualified exports
 350         md.exports().stream()
 351                 .sorted(Comparator.comparing(Exports::source))
 352                 .filter(Exports::isQualified)
 353                 .forEach(e -&gt; sb.append(&quot;qualified exports &quot;).append(e.source())
 354                                 .append(&quot; to&quot;).append(toLowerCaseString(e.targets()))
 355                                 .append(&quot;\n&quot;));
 356 
 357         // open packages
 358         md.opens().stream()
 359                 .sorted(Comparator.comparing(Opens::source))
 360                 .filter(o -&gt; !o.isQualified())
 361                 .forEach(o -&gt; sb.append(&quot;opens &quot;).append(o.source())
 362                                  .append(toLowerCaseString(o.modifiers()))
 363                                  .append(&quot;\n&quot;));
 364 
 365         md.opens().stream()
 366                 .sorted(Comparator.comparing(Opens::source))
 367                 .filter(Opens::isQualified)
 368                 .forEach(o -&gt; sb.append(&quot;qualified opens &quot;).append(o.source())
 369                                  .append(toLowerCaseString(o.modifiers()))
 370                                  .append(&quot; to&quot;).append(toLowerCaseString(o.targets()))
 371                                  .append(&quot;\n&quot;));
 372 
 373         // non-exported/non-open packages
 374         Set&lt;String&gt; concealed = new TreeSet&lt;&gt;(md.packages());
 375         md.exports().stream().map(Exports::source).forEach(concealed::remove);
 376         md.opens().stream().map(Opens::source).forEach(concealed::remove);
 377         concealed.forEach(p -&gt; sb.append(&quot;contains &quot;).append(p).append(&quot;\n&quot;));
 378 
 379         md.mainClass().ifPresent(v -&gt; sb.append(&quot;main-class &quot;).append(v).append(&quot;\n&quot;));
 380 
 381         if (target != null) {
 382             String targetPlatform = target.targetPlatform();
 383             if (!targetPlatform.isEmpty())
 384                 sb.append(&quot;platform &quot;).append(targetPlatform).append(&quot;\n&quot;);
 385        }
 386 
 387        if (hashes != null) {
 388            hashes.names().stream().sorted().forEach(
 389                    mod -&gt; sb.append(&quot;hashes &quot;).append(mod).append(&quot; &quot;)
 390                             .append(hashes.algorithm()).append(&quot; &quot;)
 391                             .append(toHex(hashes.hashFor(mod)))
 392                             .append(&quot;\n&quot;));
 393         }
 394 
 395         out.println(sb.toString());
 396     }
 397 
 398     private String toHex(byte[] ba) {
 399         StringBuilder sb = new StringBuilder(ba.length);
 400         for (byte b: ba) {
 401             sb.append(String.format(&quot;%02x&quot;, b &amp; 0xff));
 402         }
 403         return sb.toString();
 404     }
 405 
 406     private boolean create() throws IOException {
 407         JmodFileWriter jmod = new JmodFileWriter();
 408 
 409         // create jmod with temporary name to avoid it being examined
 410         // when scanning the module path
 411         Path target = options.jmodFile;
 412         Path tempTarget = jmodTempFilePath(target);
 413         try {
 414             try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget)) {
 415                 jmod.write(jos);
 416             }
 417             Files.move(tempTarget, target);
 418         } catch (Exception e) {
 419             try {
 420                 Files.deleteIfExists(tempTarget);
 421             } catch (IOException ioe) {
 422                 e.addSuppressed(ioe);
 423             }
 424             throw e;
 425         }
 426         return true;
 427     }
 428 
 429     /*
 430      * Create a JMOD .tmp file for the given target JMOD file
 431      */
 432     private static Path jmodTempFilePath(Path target) throws IOException {
 433         return target.resolveSibling(&quot;.&quot; + target.getFileName() + &quot;.tmp&quot;);
 434     }
 435 
 436     private class JmodFileWriter {
 437         final List&lt;Path&gt; cmds = options.cmds;
 438         final List&lt;Path&gt; libs = options.libs;
 439         final List&lt;Path&gt; configs = options.configs;
 440         final List&lt;Path&gt; classpath = options.classpath;
 441         final List&lt;Path&gt; headerFiles = options.headerFiles;
 442         final List&lt;Path&gt; manPages = options.manPages;
 443         final List&lt;Path&gt; legalNotices = options.legalNotices;
 444 
 445         final Version moduleVersion = options.moduleVersion;
 446         final String mainClass = options.mainClass;
 447         final String targetPlatform = options.targetPlatform;
 448         final List&lt;PathMatcher&gt; excludes = options.excludes;
 449         final ModuleResolution moduleResolution = options.moduleResolution;
 450 
 451         JmodFileWriter() { }
 452 
 453         /**
 454          * Writes the jmod to the given output stream.
 455          */
 456         void write(JmodOutputStream out) throws IOException {
 457             // module-info.class
 458             writeModuleInfo(out, findPackages(classpath));
 459 
 460             // classes
 461             processClasses(out, classpath);
 462 
 463             processSection(out, Section.CONFIG, configs);
 464             processSection(out, Section.HEADER_FILES, headerFiles);
 465             processSection(out, Section.LEGAL_NOTICES, legalNotices);
 466             processSection(out, Section.MAN_PAGES, manPages);
 467             processSection(out, Section.NATIVE_CMDS, cmds);
 468             processSection(out, Section.NATIVE_LIBS, libs);
 469 
 470         }
 471 
 472         /**
 473          * Returns a supplier of an input stream to the module-info.class
 474          * on the class path of directories and JAR files.
 475          */
 476         Supplier&lt;InputStream&gt; newModuleInfoSupplier() throws IOException {
 477             ByteArrayOutputStream baos = new ByteArrayOutputStream();
 478             for (Path e: classpath) {
 479                 if (Files.isDirectory(e)) {
 480                     Path mi = e.resolve(MODULE_INFO);
 481                     if (Files.isRegularFile(mi)) {
 482                         Files.copy(mi, baos);
 483                         break;
 484                     }
 485                 } else if (Files.isRegularFile(e) &amp;&amp; e.toString().endsWith(&quot;.jar&quot;)) {
 486                     try (JarFile jf = new JarFile(e.toFile())) {
 487                         ZipEntry entry = jf.getEntry(MODULE_INFO);
 488                         if (entry != null) {
 489                             jf.getInputStream(entry).transferTo(baos);
 490                             break;
 491                         }
 492                     } catch (ZipException x) {
 493                         // Skip. Do nothing. No packages will be added.
 494                     }
 495                 }
 496             }
 497             if (baos.size() == 0) {
 498                 return null;
 499             } else {
 500                 byte[] bytes = baos.toByteArray();
 501                 return () -&gt; new ByteArrayInputStream(bytes);
 502             }
 503         }
 504 
 505         /**
 506          * Writes the updated module-info.class to the ZIP output stream.
 507          *
 508          * The updated module-info.class will have a Packages attribute
 509          * with the set of module-private/non-exported packages.
 510          *
 511          * If --module-version, --main-class, or other options were provided
 512          * then the corresponding class file attributes are added to the
 513          * module-info here.
 514          */
 515         void writeModuleInfo(JmodOutputStream out, Set&lt;String&gt; packages)
 516             throws IOException
 517         {
 518             Supplier&lt;InputStream&gt; miSupplier = newModuleInfoSupplier();
 519             if (miSupplier == null) {
 520                 throw new IOException(MODULE_INFO + &quot; not found&quot;);
 521             }
 522 
 523             ModuleDescriptor descriptor;
 524             try (InputStream in = miSupplier.get()) {
 525                 descriptor = ModuleDescriptor.read(in);
 526             }
 527 
 528             // copy the module-info.class into the jmod with the additional
 529             // attributes for the version, main class and other meta data
 530             try (InputStream in = miSupplier.get()) {
 531                 ModuleInfoExtender extender = ModuleInfoExtender.newExtender(in);
 532 
 533                 // Add (or replace) the Packages attribute
 534                 if (packages != null) {
 535                     validatePackages(descriptor, packages);
 536                     extender.packages(packages);
 537                 }
 538 
 539                 // --main-class
 540                 if (mainClass != null)
 541                     extender.mainClass(mainClass);
 542 
 543                 // --target-platform
 544                 if (targetPlatform != null) {
 545                     extender.targetPlatform(targetPlatform);
 546                 }
 547 
 548                 // --module-version
 549                 if (moduleVersion != null)
 550                     extender.version(moduleVersion);
 551 
 552                 // --hash-modules
 553                 if (options.modulesToHash != null) {
 554                     // To compute hashes, it creates a Configuration to resolve
 555                     // a module graph.  The post-resolution check requires
 556                     // the packages in ModuleDescriptor be available for validation.
 557                     ModuleDescriptor md;
 558                     try (InputStream is = miSupplier.get()) {
 559                         md = ModuleDescriptor.read(is, () -&gt; packages);
 560                     }
 561 
 562                     ModuleHashes moduleHashes = computeHashes(md);
 563                     if (moduleHashes != null) {
 564                         extender.hashes(moduleHashes);
 565                     } else {
 566                         warning(&quot;warn.no.module.hashes&quot;, descriptor.name());
 567                     }
 568                 }
 569 
 570                 if (moduleResolution != null &amp;&amp; moduleResolution.value() != 0) {
 571                     extender.moduleResolution(moduleResolution);
 572                 }
 573 
 574                 // write the (possibly extended or modified) module-info.class
 575                 out.writeEntry(extender.toByteArray(), Section.CLASSES, MODULE_INFO);
 576             }
 577         }
 578 
 579         private void validatePackages(ModuleDescriptor descriptor, Set&lt;String&gt; packages) {
 580             Set&lt;String&gt; nonExistPackages = new TreeSet&lt;&gt;();
 581             descriptor.exports().stream()
 582                 .map(Exports::source)
 583                 .filter(pn -&gt; !packages.contains(pn))
 584                 .forEach(nonExistPackages::add);
 585 
 586             descriptor.opens().stream()
 587                 .map(Opens::source)
 588                 .filter(pn -&gt; !packages.contains(pn))
 589                 .forEach(nonExistPackages::add);
 590 
 591             if (!nonExistPackages.isEmpty()) {
 592                 throw new CommandException(&quot;err.missing.export.or.open.packages&quot;,
 593                     descriptor.name(), nonExistPackages);
 594             }
 595         }
 596 
 597         /*
 598          * Hasher resolves a module graph using the --hash-modules PATTERN
 599          * as the roots.
 600          *
 601          * The jmod file is being created and does not exist in the
 602          * given modulepath.
 603          */
 604         private ModuleHashes computeHashes(ModuleDescriptor descriptor) {
 605             String mn = descriptor.name();
 606             URI uri = options.jmodFile.toUri();
 607             ModuleReference mref = new ModuleReference(descriptor, uri) {
 608                 @Override
 609                 public ModuleReader open() {
 610                     throw new UnsupportedOperationException(&quot;opening &quot; + mn);
 611                 }
 612             };
 613 
 614             // compose a module finder with the module path and also
 615             // a module finder that can find the jmod file being created
 616             ModuleFinder finder = ModuleFinder.compose(options.moduleFinder,
 617                 new ModuleFinder() {
 618                     @Override
 619                     public Optional&lt;ModuleReference&gt; find(String name) {
 620                         if (descriptor.name().equals(name))
 621                             return Optional.of(mref);
 622                         else return Optional.empty();
 623                     }
 624 
 625                     @Override
 626                     public Set&lt;ModuleReference&gt; findAll() {
 627                         return Collections.singleton(mref);
 628                     }
 629                 });
 630 
 631             return new Hasher(mn, finder).computeHashes().get(mn);
 632         }
 633 
 634         /**
 635          * Returns the set of all packages on the given class path.
 636          */
 637         Set&lt;String&gt; findPackages(List&lt;Path&gt; classpath) {
 638             Set&lt;String&gt; packages = new HashSet&lt;&gt;();
 639             for (Path path : classpath) {
 640                 if (Files.isDirectory(path)) {
 641                     packages.addAll(findPackages(path));
 642                 } else if (Files.isRegularFile(path) &amp;&amp; path.toString().endsWith(&quot;.jar&quot;)) {
 643                     try (JarFile jf = new JarFile(path.toString())) {
 644                         packages.addAll(findPackages(jf));
 645                     } catch (ZipException x) {
 646                         // Skip. Do nothing. No packages will be added.
 647                     } catch (IOException ioe) {
 648                         throw new UncheckedIOException(ioe);
 649                     }
 650                 }
 651             }
 652             return packages;
 653         }
 654 
 655         /**
 656          * Returns the set of packages in the given directory tree.
 657          */
 658         Set&lt;String&gt; findPackages(Path dir) {
 659             try {
 660                 return Files.find(dir, Integer.MAX_VALUE,
 661                                   ((path, attrs) -&gt; attrs.isRegularFile()))
 662                         .map(dir::relativize)
 663                         .filter(path -&gt; isResource(path.toString()))
 664                         .map(path -&gt; toPackageName(path))
 665                         .filter(pkg -&gt; pkg.length() &gt; 0)
 666                         .distinct()
 667                         .collect(Collectors.toSet());
 668             } catch (IOException ioe) {
 669                 throw new UncheckedIOException(ioe);
 670             }
 671         }
 672 
 673         /**
 674          * Returns the set of packages in the given JAR file.
 675          */
 676         Set&lt;String&gt; findPackages(JarFile jf) {
 677             return jf.stream()
 678                      .filter(e -&gt; !e.isDirectory() &amp;&amp; isResource(e.getName()))
 679                      .map(e -&gt; toPackageName(e))
 680                      .filter(pkg -&gt; pkg.length() &gt; 0)
 681                      .distinct()
 682                      .collect(Collectors.toSet());
 683         }
 684 
 685         /**
 686          * Returns true if it&#39;s a .class or a resource with an effective
 687          * package name.
 688          */
 689         boolean isResource(String name) {
 690             name = name.replace(File.separatorChar, &#39;/&#39;);
 691             return name.endsWith(&quot;.class&quot;) || Resources.canEncapsulate(name);
 692         }
 693 
 694 
 695         String toPackageName(Path path) {
 696             String name = path.toString();
 697             int index = name.lastIndexOf(File.separatorChar);
 698             if (index != -1)
 699                 return name.substring(0, index).replace(File.separatorChar, &#39;.&#39;);
 700 
 701             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.equals(MODULE_INFO)) {
 702                 IOException e = new IOException(name  + &quot; in the unnamed package&quot;);
 703                 throw new UncheckedIOException(e);
 704             }
 705             return &quot;&quot;;
 706         }
 707 
 708         String toPackageName(ZipEntry entry) {
 709             String name = entry.getName();
 710             int index = name.lastIndexOf(&quot;/&quot;);
 711             if (index != -1)
 712                 return name.substring(0, index).replace(&#39;/&#39;, &#39;.&#39;);
 713 
 714             if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.equals(MODULE_INFO)) {
 715                 IOException e = new IOException(name  + &quot; in the unnamed package&quot;);
 716                 throw new UncheckedIOException(e);
 717             }
 718             return &quot;&quot;;
 719         }
 720 
 721         void processClasses(JmodOutputStream out, List&lt;Path&gt; classpaths)
 722             throws IOException
 723         {
 724             if (classpaths == null)
 725                 return;
 726 
 727             for (Path p : classpaths) {
 728                 if (Files.isDirectory(p)) {
 729                     processSection(out, Section.CLASSES, p);
 730                 } else if (Files.isRegularFile(p) &amp;&amp; p.toString().endsWith(&quot;.jar&quot;)) {
 731                     try (JarFile jf = new JarFile(p.toFile())) {
 732                         JarEntryConsumer jec = new JarEntryConsumer(out, jf);
 733                         jf.stream().filter(jec).forEach(jec);
 734                     }
 735                 }
 736             }
 737         }
 738 
 739         void processSection(JmodOutputStream out, Section section, List&lt;Path&gt; paths)
 740             throws IOException
 741         {
 742             if (paths == null)
 743                 return;
 744 
 745             for (Path p : paths) {
 746                 processSection(out, section, p);
 747             }
 748         }
 749 
 750         void processSection(JmodOutputStream out, Section section, Path path)
 751             throws IOException
 752         {
 753             Files.walkFileTree(path, Set.of(FileVisitOption.FOLLOW_LINKS),
 754                 Integer.MAX_VALUE, new SimpleFileVisitor&lt;Path&gt;() {
 755                     @Override
 756                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
 757                         throws IOException
 758                     {
 759                         Path relPath = path.relativize(file);
<a name="1" id="anc1"></a><span class="line-modified"> 760                         String name = relPath.toString();</span>
<span class="line-modified"> 761                         if (name.equals(MODULE_INFO)) {</span>
<span class="line-modified"> 762                             if (!Section.CLASSES.equals(section))</span>
<span class="line-modified"> 763                                 warning(&quot;warn.ignore.entry&quot;, name, section);</span>
<span class="line-modified"> 764                         } else if (!matches(relPath, excludes)) {</span>
<span class="line-modified"> 765                             if (out.contains(section, name)) {</span>
<span class="line-modified"> 766                                 warning(&quot;warn.ignore.duplicate.entry&quot;, name, section);</span>
<span class="line-modified"> 767                             } else {</span>
<span class="line-modified"> 768                                 try (InputStream in = Files.newInputStream(file)) {</span>
<span class="line-modified"> 769                                     out.writeEntry(in, section, name);</span>



 770                                 }
<a name="2" id="anc2"></a>
 771                             }
 772                         }
 773                         return FileVisitResult.CONTINUE;
 774                     }
 775                 });
 776         }
 777 
 778         boolean matches(Path path, List&lt;PathMatcher&gt; matchers) {
 779             if (matchers != null) {
 780                 for (PathMatcher pm : matchers) {
 781                     if (pm.matches(path))
 782                         return true;
 783                 }
 784             }
 785             return false;
 786         }
 787 
 788         class JarEntryConsumer implements Consumer&lt;JarEntry&gt;, Predicate&lt;JarEntry&gt; {
 789             final JmodOutputStream out;
 790             final JarFile jarfile;
 791             JarEntryConsumer(JmodOutputStream out, JarFile jarfile) {
 792                 this.out = out;
 793                 this.jarfile = jarfile;
 794             }
 795             @Override
 796             public void accept(JarEntry je) {
 797                 try (InputStream in = jarfile.getInputStream(je)) {
 798                     out.writeEntry(in, Section.CLASSES, je.getName());
 799                 } catch (IOException e) {
 800                     throw new UncheckedIOException(e);
 801                 }
 802             }
 803             @Override
 804             public boolean test(JarEntry je) {
 805                 String name = je.getName();
 806                 // ## no support for excludes. Is it really needed?
<a name="3" id="anc3"></a><span class="line-modified"> 807                 if (name.endsWith(MODULE_INFO) || je.isDirectory()) {</span>
<span class="line-added"> 808                     return false;</span>
<span class="line-added"> 809                 }</span>
<span class="line-added"> 810                 if (out.contains(Section.CLASSES, name)) {</span>
<span class="line-added"> 811                     warning(&quot;warn.ignore.duplicate.entry&quot;, name, Section.CLASSES);</span>
<span class="line-added"> 812                     return false;</span>
<span class="line-added"> 813                 }</span>
<span class="line-added"> 814                 return true;</span>
 815             }
 816         }
 817     }
 818 
 819     /**
 820      * Compute and record hashes
 821      */
 822     private class Hasher {
 823         final Configuration configuration;
 824         final ModuleHashesBuilder hashesBuilder;
 825         final Set&lt;String&gt; modules;
 826         final String moduleName;  // a specific module to record hashes, if set
 827 
 828         /**
 829          * This constructor is for jmod hash command.
 830          *
 831          * This Hasher will determine which modules to record hashes, i.e.
 832          * the module in a subgraph of modules to be hashed and that
 833          * has no outgoing edges.  It will record in each of these modules,
 834          * say `M`, with the the hashes of modules that depend upon M
 835          * directly or indirectly matching the specified --hash-modules pattern.
 836          */
 837         Hasher(ModuleFinder finder) {
 838             this(null, finder);
 839         }
 840 
 841         /**
 842          * Constructs a Hasher to compute hashes.
 843          *
 844          * If a module name `M` is specified, it will compute the hashes of
 845          * modules that depend upon M directly or indirectly matching the
 846          * specified --hash-modules pattern and record in the ModuleHashes
 847          * attribute in M&#39;s module-info.class.
 848          *
 849          * @param name    name of the module to record hashes
 850          * @param finder  module finder for the specified --module-path
 851          */
 852         Hasher(String name, ModuleFinder finder) {
 853             // Determine the modules that matches the pattern {@code modulesToHash}
 854             Set&lt;String&gt; roots = finder.findAll().stream()
 855                 .map(mref -&gt; mref.descriptor().name())
 856                 .filter(mn -&gt; options.modulesToHash.matcher(mn).find())
 857                 .collect(Collectors.toSet());
 858 
 859             // use system module path unless it creates a JMOD file for
 860             // a module that is present in the system image e.g. upgradeable
 861             // module
 862             ModuleFinder system;
 863             if (name != null &amp;&amp; ModuleFinder.ofSystem().find(name).isPresent()) {
 864                 system = ModuleFinder.of();
 865             } else {
 866                 system = ModuleFinder.ofSystem();
 867             }
 868             // get a resolved module graph
 869             Configuration config = null;
 870             try {
 871                 config = Configuration.empty().resolve(system, finder, roots);
 872             } catch (FindException | ResolutionException e) {
 873                 throw new CommandException(&quot;err.module.resolution.fail&quot;, e.getMessage());
 874             }
 875 
 876             this.moduleName = name;
 877             this.configuration = config;
 878 
 879             // filter modules resolved from the system module finder
 880             this.modules = config.modules().stream()
 881                 .map(ResolvedModule::name)
 882                 .filter(mn -&gt; roots.contains(mn) &amp;&amp; !system.find(mn).isPresent())
 883                 .collect(Collectors.toSet());
 884 
 885             this.hashesBuilder = new ModuleHashesBuilder(config, modules);
 886         }
 887 
 888         /**
 889          * Returns a map of a module M to record hashes of the modules
 890          * that depend upon M directly or indirectly.
 891          *
 892          * For jmod hash command, the returned map contains one entry
 893          * for each module M that has no outgoing edges to any of the
 894          * modules matching the specified --hash-modules pattern.
 895          *
 896          * Each entry represents a leaf node in a connected subgraph containing
 897          * M and other candidate modules from the module graph where M&#39;s outgoing
 898          * edges to any module other than the ones matching the specified
 899          * --hash-modules pattern are excluded.
 900          */
 901         Map&lt;String, ModuleHashes&gt; computeHashes() {
 902             if (hashesBuilder == null)
 903                 return null;
 904 
 905             if (moduleName != null) {
 906                 return hashesBuilder.computeHashes(Set.of(moduleName));
 907             } else {
 908                 return hashesBuilder.computeHashes(modules);
 909             }
 910         }
 911 
 912         /**
 913          * Reads the given input stream of module-info.class and write
 914          * the extended module-info.class with the given ModuleHashes
 915          *
 916          * @param in       InputStream of module-info.class
 917          * @param out      OutputStream to write the extended module-info.class
 918          * @param hashes   ModuleHashes
 919          */
 920         private void recordHashes(InputStream in, OutputStream out, ModuleHashes hashes)
 921             throws IOException
 922         {
 923             ModuleInfoExtender extender = ModuleInfoExtender.newExtender(in);
 924             extender.hashes(hashes);
 925             extender.write(out);
 926         }
 927 
 928         void updateModuleInfo(String name, ModuleHashes moduleHashes)
 929             throws IOException
 930         {
 931             Path target = moduleToPath(name);
 932             Path tempTarget = jmodTempFilePath(target);
 933             try {
 934                 if (target.getFileName().toString().endsWith(&quot;.jmod&quot;)) {
 935                     updateJmodFile(target, tempTarget, moduleHashes);
 936                 } else {
 937                     updateModularJar(target, tempTarget, moduleHashes);
 938                 }
 939             } catch (IOException|RuntimeException e) {
 940                 try {
 941                     Files.deleteIfExists(tempTarget);
 942                 } catch (IOException ioe) {
 943                     e.addSuppressed(ioe);
 944                 }
 945                 throw e;
 946             }
 947 
 948             out.println(getMessage(&quot;module.hashes.recorded&quot;, name));
 949             Files.move(tempTarget, target, StandardCopyOption.REPLACE_EXISTING);
 950         }
 951 
 952         private void updateModularJar(Path target, Path tempTarget,
 953                                       ModuleHashes moduleHashes)
 954             throws IOException
 955         {
 956             try (JarFile jf = new JarFile(target.toFile());
 957                  OutputStream out = Files.newOutputStream(tempTarget);
 958                  JarOutputStream jos = new JarOutputStream(out))
 959             {
 960                 jf.stream().forEach(e -&gt; {
 961                     try (InputStream in = jf.getInputStream(e)) {
 962                         if (e.getName().equals(MODULE_INFO)) {
 963                             // what about module-info.class in versioned entries?
 964                             ZipEntry ze = new ZipEntry(e.getName());
 965                             ze.setTime(System.currentTimeMillis());
 966                             jos.putNextEntry(ze);
 967                             recordHashes(in, jos, moduleHashes);
 968                             jos.closeEntry();
 969                         } else {
 970                             // Setting &quot;compressedSize&quot; to &quot;-1&quot; prevents an error
 971                             // in ZipOutputStream.closeEntry() if the newly
 972                             // deflated entry will have another size than the
 973                             // original compressed entry. See:
 974                             // ZipOutputStream.putNextEntry()/closeEntry()
 975                             e.setCompressedSize(-1);
 976                             jos.putNextEntry(e);
 977                             jos.write(in.readAllBytes());
 978                             jos.closeEntry();
 979                         }
 980                     } catch (IOException x) {
 981                         throw new UncheckedIOException(x);
 982                     }
 983                 });
 984             }
 985         }
 986 
 987         private void updateJmodFile(Path target, Path tempTarget,
 988                                     ModuleHashes moduleHashes)
 989             throws IOException
 990         {
 991 
 992             try (JmodFile jf = new JmodFile(target);
 993                  JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget))
 994             {
 995                 jf.stream().forEach(e -&gt; {
 996                     try (InputStream in = jf.getInputStream(e.section(), e.name())) {
 997                         if (e.name().equals(MODULE_INFO)) {
 998                             // replace module-info.class
 999                             ModuleInfoExtender extender =
1000                                 ModuleInfoExtender.newExtender(in);
1001                             extender.hashes(moduleHashes);
1002                             jos.writeEntry(extender.toByteArray(), e.section(), e.name());
1003                         } else {
1004                             jos.writeEntry(in, e);
1005                         }
1006                     } catch (IOException x) {
1007                         throw new UncheckedIOException(x);
1008                     }
1009                 });
1010             }
1011         }
1012 
1013         private Path moduleToPath(String name) {
1014             ResolvedModule rm = configuration.findModule(name).orElseThrow(
1015                 () -&gt; new InternalError(&quot;Selected module &quot; + name + &quot; not on module path&quot;));
1016 
1017             URI uri = rm.reference().location().get();
1018             Path path = Paths.get(uri);
1019             String fn = path.getFileName().toString();
1020             if (!fn.endsWith(&quot;.jar&quot;) &amp;&amp; !fn.endsWith(&quot;.jmod&quot;)) {
1021                 throw new InternalError(path + &quot; is not a modular JAR or jmod file&quot;);
1022             }
1023             return path;
1024         }
1025     }
1026 
1027     /**
1028      * An abstract converter that given a string representing a list of paths,
1029      * separated by the File.pathSeparator, returns a List of java.nio.Path&#39;s.
1030      * Specific subclasses should do whatever validation is required on the
1031      * individual path elements, if any.
1032      */
1033     static abstract class AbstractPathConverter implements ValueConverter&lt;List&lt;Path&gt;&gt; {
1034         @Override
1035         public List&lt;Path&gt; convert(String value) {
1036             List&lt;Path&gt; paths = new ArrayList&lt;&gt;();
1037             String[] pathElements = value.split(File.pathSeparator);
1038             for (String pathElement : pathElements) {
1039                 paths.add(toPath(pathElement));
1040             }
1041             return paths;
1042         }
1043 
1044         @SuppressWarnings(&quot;unchecked&quot;)
1045         @Override
1046         public Class&lt;List&lt;Path&gt;&gt; valueType() {
1047             return (Class&lt;List&lt;Path&gt;&gt;)(Object)List.class;
1048         }
1049 
1050         @Override public String valuePattern() { return &quot;path&quot;; }
1051 
1052         abstract Path toPath(String path);
1053     }
1054 
1055     static class ClassPathConverter extends AbstractPathConverter {
1056         static final ValueConverter&lt;List&lt;Path&gt;&gt; INSTANCE = new ClassPathConverter();
1057 
1058         @Override
1059         public Path toPath(String value) {
1060             try {
1061                 Path path = CWD.resolve(value);
1062                 if (Files.notExists(path))
1063                     throw new CommandException(&quot;err.path.not.found&quot;, path);
1064                 if (!(Files.isDirectory(path) ||
1065                         (Files.isRegularFile(path) &amp;&amp; path.toString().endsWith(&quot;.jar&quot;))))
1066                     throw new CommandException(&quot;err.invalid.class.path.entry&quot;, path);
1067                 return path;
1068             } catch (InvalidPathException x) {
1069                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1070             }
1071         }
1072     }
1073 
1074     static class DirPathConverter extends AbstractPathConverter {
1075         static final ValueConverter&lt;List&lt;Path&gt;&gt; INSTANCE = new DirPathConverter();
1076 
1077         @Override
1078         public Path toPath(String value) {
1079             try {
1080                 Path path = CWD.resolve(value);
1081                 if (Files.notExists(path))
1082                     throw new CommandException(&quot;err.path.not.found&quot;, path);
1083                 if (!Files.isDirectory(path))
1084                     throw new CommandException(&quot;err.path.not.a.dir&quot;, path);
1085                 return path;
1086             } catch (InvalidPathException x) {
1087                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1088             }
1089         }
1090     }
1091 
1092     static class ExtractDirPathConverter implements ValueConverter&lt;Path&gt; {
1093 
1094         @Override
1095         public Path convert(String value) {
1096             try {
1097                 Path path = CWD.resolve(value);
1098                 if (Files.exists(path)) {
1099                     if (!Files.isDirectory(path))
1100                         throw new CommandException(&quot;err.cannot.create.dir&quot;, path);
1101                 }
1102                 return path;
1103             } catch (InvalidPathException x) {
1104                 throw new CommandException(&quot;err.path.not.valid&quot;, value);
1105             }
1106         }
1107 
1108         @Override  public Class&lt;Path&gt; valueType() { return Path.class; }
1109 
1110         @Override  public String valuePattern() { return &quot;path&quot;; }
1111     }
1112 
1113     static class ModuleVersionConverter implements ValueConverter&lt;Version&gt; {
1114         @Override
1115         public Version convert(String value) {
1116             try {
1117                 return Version.parse(value);
1118             } catch (IllegalArgumentException x) {
1119                 throw new CommandException(&quot;err.invalid.version&quot;, x.getMessage());
1120             }
1121         }
1122 
1123         @Override public Class&lt;Version&gt; valueType() { return Version.class; }
1124 
1125         @Override public String valuePattern() { return &quot;module-version&quot;; }
1126     }
1127 
1128     static class WarnIfResolvedReasonConverter
1129         implements ValueConverter&lt;ModuleResolution&gt;
1130     {
1131         @Override
1132         public ModuleResolution convert(String value) {
1133             if (value.equals(&quot;deprecated&quot;))
1134                 return ModuleResolution.empty().withDeprecated();
1135             else if (value.equals(&quot;deprecated-for-removal&quot;))
1136                 return ModuleResolution.empty().withDeprecatedForRemoval();
1137             else if (value.equals(&quot;incubating&quot;))
1138                 return ModuleResolution.empty().withIncubating();
1139             else
1140                 throw new CommandException(&quot;err.bad.WarnIfResolvedReason&quot;, value);
1141         }
1142 
1143         @Override public Class&lt;ModuleResolution&gt; valueType() {
1144             return ModuleResolution.class;
1145         }
1146 
1147         @Override public String valuePattern() { return &quot;reason&quot;; }
1148     }
1149 
1150     static class PatternConverter implements ValueConverter&lt;Pattern&gt; {
1151         @Override
1152         public Pattern convert(String value) {
1153             try {
1154                 if (value.startsWith(&quot;regex:&quot;)) {
1155                     value = value.substring(&quot;regex:&quot;.length()).trim();
1156                 }
1157 
1158                 return Pattern.compile(value);
1159             } catch (PatternSyntaxException e) {
1160                 throw new CommandException(&quot;err.bad.pattern&quot;, value);
1161             }
1162         }
1163 
1164         @Override public Class&lt;Pattern&gt; valueType() { return Pattern.class; }
1165 
1166         @Override public String valuePattern() { return &quot;regex-pattern&quot;; }
1167     }
1168 
1169     static class PathMatcherConverter implements ValueConverter&lt;PathMatcher&gt; {
1170         @Override
1171         public PathMatcher convert(String pattern) {
1172             try {
1173                 return Utils.getPathMatcher(FileSystems.getDefault(), pattern);
1174             } catch (PatternSyntaxException e) {
1175                 throw new CommandException(&quot;err.bad.pattern&quot;, pattern);
1176             }
1177         }
1178 
1179         @Override public Class&lt;PathMatcher&gt; valueType() { return PathMatcher.class; }
1180 
1181         @Override public String valuePattern() { return &quot;pattern-list&quot;; }
1182     }
1183 
1184     /* Support for @&lt;file&gt; in jmod help */
1185     private static final String CMD_FILENAME = &quot;@&lt;filename&gt;&quot;;
1186 
1187     /**
1188      * This formatter is adding the @filename option and does the required
1189      * formatting.
1190      */
1191     private static final class JmodHelpFormatter extends BuiltinHelpFormatter {
1192 
1193         private final Options opts;
1194 
1195         private JmodHelpFormatter(Options opts) {
1196             super(80, 2);
1197             this.opts = opts;
1198         }
1199 
1200         @Override
1201         public String format(Map&lt;String, ? extends OptionDescriptor&gt; options) {
1202             Map&lt;String, OptionDescriptor&gt; all = new LinkedHashMap&lt;&gt;();
1203             all.putAll(options);
1204 
1205             // extra options
1206             if (!opts.helpExtra) {
1207                 all.remove(&quot;do-not-resolve-by-default&quot;);
1208                 all.remove(&quot;warn-if-resolved&quot;);
1209             }
1210 
1211             all.put(CMD_FILENAME, new OptionDescriptor() {
1212                 @Override
1213                 public List&lt;String&gt; options() {
1214                     List&lt;String&gt; ret = new ArrayList&lt;&gt;();
1215                     ret.add(CMD_FILENAME);
1216                     return ret;
1217                 }
1218                 @Override
1219                 public String description() { return getMessage(&quot;main.opt.cmdfile&quot;); }
1220                 @Override
1221                 public List&lt;?&gt; defaultValues() { return Collections.emptyList(); }
1222                 @Override
1223                 public boolean isRequired() { return false; }
1224                 @Override
1225                 public boolean acceptsArguments() { return false; }
1226                 @Override
1227                 public boolean requiresArgument() { return false; }
1228                 @Override
1229                 public String argumentDescription() { return null; }
1230                 @Override
1231                 public String argumentTypeIndicator() { return null; }
1232                 @Override
1233                 public boolean representsNonOptions() { return false; }
1234             });
1235             String content = super.format(all);
1236             StringBuilder builder = new StringBuilder();
1237 
1238             builder.append(getMessage(&quot;main.opt.mode&quot;)).append(&quot;\n  &quot;);
1239             builder.append(getMessage(&quot;main.opt.mode.create&quot;)).append(&quot;\n  &quot;);
1240             builder.append(getMessage(&quot;main.opt.mode.extract&quot;)).append(&quot;\n  &quot;);
1241             builder.append(getMessage(&quot;main.opt.mode.list&quot;)).append(&quot;\n  &quot;);
1242             builder.append(getMessage(&quot;main.opt.mode.describe&quot;)).append(&quot;\n  &quot;);
1243             builder.append(getMessage(&quot;main.opt.mode.hash&quot;)).append(&quot;\n\n&quot;);
1244 
1245             String cmdfile = null;
1246             String[] lines = content.split(&quot;\n&quot;);
1247             for (String line : lines) {
1248                 if (line.startsWith(&quot;--@&quot;)) {
1249                     cmdfile = line.replace(&quot;--&quot; + CMD_FILENAME, CMD_FILENAME + &quot;  &quot;);
1250                 } else if (line.startsWith(&quot;Option&quot;) || line.startsWith(&quot;------&quot;)) {
1251                     builder.append(&quot; &quot;).append(line).append(&quot;\n&quot;);
1252                 } else if (!line.matches(&quot;Non-option arguments&quot;)){
1253                     builder.append(&quot;  &quot;).append(line).append(&quot;\n&quot;);
1254                 }
1255             }
1256             if (cmdfile != null) {
1257                 builder.append(&quot;  &quot;).append(cmdfile).append(&quot;\n&quot;);
1258             }
1259             return builder.toString();
1260         }
1261     }
1262 
1263     private final OptionParser parser = new OptionParser(&quot;hp&quot;);
1264 
1265     private void handleOptions(String[] args) {
1266         options = new Options();
1267         parser.formatHelpWith(new JmodHelpFormatter(options));
1268 
1269         OptionSpec&lt;List&lt;Path&gt;&gt; classPath
1270                 = parser.accepts(&quot;class-path&quot;, getMessage(&quot;main.opt.class-path&quot;))
1271                         .withRequiredArg()
1272                         .withValuesConvertedBy(ClassPathConverter.INSTANCE);
1273 
1274         OptionSpec&lt;List&lt;Path&gt;&gt; cmds
1275                 = parser.accepts(&quot;cmds&quot;, getMessage(&quot;main.opt.cmds&quot;))
1276                         .withRequiredArg()
1277                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1278 
1279         OptionSpec&lt;List&lt;Path&gt;&gt; config
1280                 = parser.accepts(&quot;config&quot;, getMessage(&quot;main.opt.config&quot;))
1281                         .withRequiredArg()
1282                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1283 
1284         OptionSpec&lt;Path&gt; dir
1285                 = parser.accepts(&quot;dir&quot;, getMessage(&quot;main.opt.extractDir&quot;))
1286                         .withRequiredArg()
1287                         .withValuesConvertedBy(new ExtractDirPathConverter());
1288 
1289         OptionSpec&lt;Void&gt; dryrun
1290                 = parser.accepts(&quot;dry-run&quot;, getMessage(&quot;main.opt.dry-run&quot;));
1291 
1292         OptionSpec&lt;PathMatcher&gt; excludes
1293                 = parser.accepts(&quot;exclude&quot;, getMessage(&quot;main.opt.exclude&quot;))
1294                         .withRequiredArg()
1295                         .withValuesConvertedBy(new PathMatcherConverter());
1296 
1297         OptionSpec&lt;Pattern&gt; hashModules
1298                 = parser.accepts(&quot;hash-modules&quot;, getMessage(&quot;main.opt.hash-modules&quot;))
1299                         .withRequiredArg()
1300                         .withValuesConvertedBy(new PatternConverter());
1301 
1302         OptionSpec&lt;Void&gt; help
1303                 = parser.acceptsAll(List.of(&quot;h&quot;, &quot;help&quot;, &quot;?&quot;), getMessage(&quot;main.opt.help&quot;))
1304                         .forHelp();
1305 
1306         OptionSpec&lt;Void&gt; helpExtra
1307                 = parser.accepts(&quot;help-extra&quot;, getMessage(&quot;main.opt.help-extra&quot;));
1308 
1309         OptionSpec&lt;List&lt;Path&gt;&gt; headerFiles
1310                 = parser.accepts(&quot;header-files&quot;, getMessage(&quot;main.opt.header-files&quot;))
1311                         .withRequiredArg()
1312                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1313 
1314         OptionSpec&lt;List&lt;Path&gt;&gt; libs
1315                 = parser.accepts(&quot;libs&quot;, getMessage(&quot;main.opt.libs&quot;))
1316                         .withRequiredArg()
1317                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1318 
1319         OptionSpec&lt;List&lt;Path&gt;&gt; legalNotices
1320                 = parser.accepts(&quot;legal-notices&quot;, getMessage(&quot;main.opt.legal-notices&quot;))
1321                         .withRequiredArg()
1322                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1323 
1324 
1325         OptionSpec&lt;String&gt; mainClass
1326                 = parser.accepts(&quot;main-class&quot;, getMessage(&quot;main.opt.main-class&quot;))
1327                         .withRequiredArg()
1328                         .describedAs(getMessage(&quot;main.opt.main-class.arg&quot;));
1329 
1330         OptionSpec&lt;List&lt;Path&gt;&gt; manPages
1331                 = parser.accepts(&quot;man-pages&quot;, getMessage(&quot;main.opt.man-pages&quot;))
1332                         .withRequiredArg()
1333                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1334 
1335         OptionSpec&lt;List&lt;Path&gt;&gt; modulePath
1336                 = parser.acceptsAll(List.of(&quot;p&quot;, &quot;module-path&quot;),
1337                                     getMessage(&quot;main.opt.module-path&quot;))
1338                         .withRequiredArg()
1339                         .withValuesConvertedBy(DirPathConverter.INSTANCE);
1340 
1341         OptionSpec&lt;Version&gt; moduleVersion
1342                 = parser.accepts(&quot;module-version&quot;, getMessage(&quot;main.opt.module-version&quot;))
1343                         .withRequiredArg()
1344                         .withValuesConvertedBy(new ModuleVersionConverter());
1345 
1346         OptionSpec&lt;String&gt; targetPlatform
1347                 = parser.accepts(&quot;target-platform&quot;, getMessage(&quot;main.opt.target-platform&quot;))
1348                         .withRequiredArg()
1349                         .describedAs(getMessage(&quot;main.opt.target-platform.arg&quot;));
1350 
1351         OptionSpec&lt;Void&gt; doNotResolveByDefault
1352                 = parser.accepts(&quot;do-not-resolve-by-default&quot;,
1353                                  getMessage(&quot;main.opt.do-not-resolve-by-default&quot;));
1354 
1355         OptionSpec&lt;ModuleResolution&gt; warnIfResolved
1356                 = parser.accepts(&quot;warn-if-resolved&quot;, getMessage(&quot;main.opt.warn-if-resolved&quot;))
1357                         .withRequiredArg()
1358                         .withValuesConvertedBy(new WarnIfResolvedReasonConverter());
1359 
1360         OptionSpec&lt;Void&gt; version
1361                 = parser.accepts(&quot;version&quot;, getMessage(&quot;main.opt.version&quot;));
1362 
1363         NonOptionArgumentSpec&lt;String&gt; nonOptions
1364                 = parser.nonOptions();
1365 
1366         try {
1367             OptionSet opts = parser.parse(args);
1368 
1369             if (opts.has(help) || opts.has(helpExtra) || opts.has(version)) {
1370                 options.help = opts.has(help);
1371                 options.helpExtra = opts.has(helpExtra);
1372                 options.version = opts.has(version);
1373                 return;  // informational message will be shown
1374             }
1375 
1376             List&lt;String&gt; words = opts.valuesOf(nonOptions);
1377             if (words.isEmpty())
1378                 throw new CommandException(&quot;err.missing.mode&quot;).showUsage(true);
1379             String verb = words.get(0);
1380             try {
1381                 options.mode = Enum.valueOf(Mode.class, verb.toUpperCase());
1382             } catch (IllegalArgumentException e) {
1383                 throw new CommandException(&quot;err.invalid.mode&quot;, verb).showUsage(true);
1384             }
1385 
1386             if (opts.has(classPath))
1387                 options.classpath = getLastElement(opts.valuesOf(classPath));
1388             if (opts.has(cmds))
1389                 options.cmds = getLastElement(opts.valuesOf(cmds));
1390             if (opts.has(config))
1391                 options.configs = getLastElement(opts.valuesOf(config));
1392             if (opts.has(dir))
1393                 options.extractDir = getLastElement(opts.valuesOf(dir));
1394             if (opts.has(dryrun))
1395                 options.dryrun = true;
1396             if (opts.has(excludes))
1397                 options.excludes = opts.valuesOf(excludes);  // excludes is repeatable
1398             if (opts.has(libs))
1399                 options.libs = getLastElement(opts.valuesOf(libs));
1400             if (opts.has(headerFiles))
1401                 options.headerFiles = getLastElement(opts.valuesOf(headerFiles));
1402             if (opts.has(manPages))
1403                 options.manPages = getLastElement(opts.valuesOf(manPages));
1404             if (opts.has(legalNotices))
1405                 options.legalNotices = getLastElement(opts.valuesOf(legalNotices));
1406             if (opts.has(modulePath)) {
1407                 Path[] dirs = getLastElement(opts.valuesOf(modulePath)).toArray(new Path[0]);
1408                 options.moduleFinder = ModulePath.of(Runtime.version(), true, dirs);
1409             }
1410             if (opts.has(moduleVersion))
1411                 options.moduleVersion = getLastElement(opts.valuesOf(moduleVersion));
1412             if (opts.has(mainClass))
1413                 options.mainClass = getLastElement(opts.valuesOf(mainClass));
1414             if (opts.has(targetPlatform))
1415                 options.targetPlatform = getLastElement(opts.valuesOf(targetPlatform));
1416             if (opts.has(warnIfResolved))
1417                 options.moduleResolution = getLastElement(opts.valuesOf(warnIfResolved));
1418             if (opts.has(doNotResolveByDefault)) {
1419                 if (options.moduleResolution == null)
1420                     options.moduleResolution = ModuleResolution.empty();
1421                 options.moduleResolution = options.moduleResolution.withDoNotResolveByDefault();
1422             }
1423             if (opts.has(hashModules)) {
1424                 options.modulesToHash = getLastElement(opts.valuesOf(hashModules));
1425                 // if storing hashes then the module path is required
1426                 if (options.moduleFinder == null)
1427                     throw new CommandException(&quot;err.modulepath.must.be.specified&quot;)
1428                             .showUsage(true);
1429             }
1430 
1431             if (options.mode.equals(Mode.HASH)) {
1432                 if (options.moduleFinder == null || options.modulesToHash == null)
1433                     throw new CommandException(&quot;err.modulepath.must.be.specified&quot;)
1434                             .showUsage(true);
1435             } else {
1436                 if (words.size() &lt;= 1)
1437                     throw new CommandException(&quot;err.jmod.must.be.specified&quot;).showUsage(true);
1438                 Path path = Paths.get(words.get(1));
1439 
1440                 if (options.mode.equals(Mode.CREATE) &amp;&amp; Files.exists(path))
1441                     throw new CommandException(&quot;err.file.already.exists&quot;, path);
1442                 else if ((options.mode.equals(Mode.LIST) ||
1443                             options.mode.equals(Mode.DESCRIBE) ||
1444                             options.mode.equals((Mode.EXTRACT)))
1445                          &amp;&amp; Files.notExists(path))
1446                     throw new CommandException(&quot;err.jmod.not.found&quot;, path);
1447 
1448                 if (options.dryrun) {
1449                     throw new CommandException(&quot;err.invalid.dryrun.option&quot;);
1450                 }
1451                 options.jmodFile = path;
1452 
1453                 if (words.size() &gt; 2)
1454                     throw new CommandException(&quot;err.unknown.option&quot;,
1455                             words.subList(2, words.size())).showUsage(true);
1456             }
1457 
1458             if (options.mode.equals(Mode.CREATE) &amp;&amp; options.classpath == null)
1459                 throw new CommandException(&quot;err.classpath.must.be.specified&quot;).showUsage(true);
1460             if (options.mainClass != null &amp;&amp; !isValidJavaIdentifier(options.mainClass))
1461                 throw new CommandException(&quot;err.invalid.main-class&quot;, options.mainClass);
1462             if (options.mode.equals(Mode.EXTRACT) &amp;&amp; options.extractDir != null) {
1463                 try {
1464                     Files.createDirectories(options.extractDir);
1465                 } catch (IOException ioe) {
1466                     throw new CommandException(&quot;err.cannot.create.dir&quot;, options.extractDir);
1467                 }
1468             }
1469         } catch (OptionException e) {
1470              throw new CommandException(e.getMessage());
1471         }
1472     }
1473 
1474     /**
1475      * Returns true if, and only if, the given main class is a legal.
1476      */
1477     static boolean isValidJavaIdentifier(String mainClass) {
1478         if (mainClass.length() == 0)
1479             return false;
1480 
1481         if (!Character.isJavaIdentifierStart(mainClass.charAt(0)))
1482             return false;
1483 
1484         int n = mainClass.length();
1485         for (int i=1; i &lt; n; i++) {
1486             char c = mainClass.charAt(i);
1487             if (!Character.isJavaIdentifierPart(c) &amp;&amp; c != &#39;.&#39;)
1488                 return false;
1489         }
1490         if (mainClass.charAt(n-1) == &#39;.&#39;)
1491             return false;
1492 
1493         return true;
1494     }
1495 
1496     static &lt;E&gt; E getLastElement(List&lt;E&gt; list) {
1497         if (list.size() == 0)
1498             throw new InternalError(&quot;Unexpected 0 list size&quot;);
1499         return list.get(list.size() - 1);
1500     }
1501 
1502     private void reportError(String message) {
1503         out.println(getMessage(&quot;error.prefix&quot;) + &quot; &quot; + message);
1504     }
1505 
1506     private void warning(String key, Object... args) {
1507         out.println(getMessage(&quot;warn.prefix&quot;) + &quot; &quot; + getMessage(key, args));
1508     }
1509 
1510     private void showUsageSummary() {
1511         out.println(getMessage(&quot;main.usage.summary&quot;, PROGNAME));
1512     }
1513 
1514     private void showHelp() {
1515         out.println(getMessage(&quot;main.usage&quot;, PROGNAME));
1516         try {
1517             parser.printHelpOn(out);
1518         } catch (IOException x) {
1519             throw new AssertionError(x);
1520         }
1521     }
1522 
1523     private void showVersion() {
1524         out.println(version());
1525     }
1526 
1527     private String version() {
1528         return System.getProperty(&quot;java.version&quot;);
1529     }
1530 
1531     private static String getMessage(String key, Object... args) {
1532         try {
1533             return MessageFormat.format(ResourceBundleHelper.bundle.getString(key), args);
1534         } catch (MissingResourceException e) {
1535             throw new InternalError(&quot;Missing message: &quot; + key);
1536         }
1537     }
1538 
1539     private static class ResourceBundleHelper {
1540         static final ResourceBundle bundle;
1541 
1542         static {
1543             Locale locale = Locale.getDefault();
1544             try {
1545                 bundle = ResourceBundle.getBundle(&quot;jdk.tools.jmod.resources.jmod&quot;, locale);
1546             } catch (MissingResourceException e) {
1547                 throw new InternalError(&quot;Cannot find jmod resource bundle for locale &quot; + locale);
1548             }
1549         }
1550     }
1551 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
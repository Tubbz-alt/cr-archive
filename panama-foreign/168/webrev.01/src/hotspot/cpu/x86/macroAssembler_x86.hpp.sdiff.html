<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 298   void resolve_jobject(Register value, Register thread, Register tmp);
 299 
 300   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 301   void c2bool(Register x);
 302 
 303   // C++ bool manipulation
 304 
 305   void movbool(Register dst, Address src);
 306   void movbool(Address dst, bool boolconst);
 307   void movbool(Address dst, Register src);
 308   void testbool(Register dst);
 309 
 310   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 311   void resolve_weak_handle(Register result, Register tmp);
 312   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 313   void load_method_holder_cld(Register rresult, Register rmethod);
 314 
 315   void load_method_holder(Register holder, Register method);
 316 
 317   // oop manipulations
<span class="line-modified"> 318   void load_klass(Register dst, Register src);</span>
<span class="line-modified"> 319   void store_klass(Register dst, Register src);</span>
 320 
 321   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 322                       Register tmp1, Register thread_tmp);
 323   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 324                        Register tmp1, Register tmp2);
 325 
 326   // Resolves obj access. Result is placed in the same register.
 327   // All other registers are preserved.
 328   void resolve(DecoratorSet decorators, Register obj);
 329 
 330   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 331                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 332   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 333                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 334   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 335                       Register tmp2 = noreg, DecoratorSet decorators = 0);
 336 
 337   // Used for storing NULL. All other oop constants should be
 338   // stored using routines that take a jobject.
 339   void store_heap_oop_null(Address dst);
 340 
<span class="line-modified"> 341   void load_prototype_header(Register dst, Register src);</span>
 342 
 343 #ifdef _LP64
 344   void store_klass_gap(Register dst, Register src);
 345 
 346   // This dummy is to prevent a call to store_heap_oop from
 347   // converting a zero (like NULL) into a Register by giving
 348   // the compiler two choices it can&#39;t resolve
 349 
 350   void store_heap_oop(Address dst, void* dummy);
 351 
 352   void encode_heap_oop(Register r);
 353   void decode_heap_oop(Register r);
 354   void encode_heap_oop_not_null(Register r);
 355   void decode_heap_oop_not_null(Register r);
 356   void encode_heap_oop_not_null(Register dst, Register src);
 357   void decode_heap_oop_not_null(Register dst, Register src);
 358 
 359   void set_narrow_oop(Register dst, jobject obj);
 360   void set_narrow_oop(Address dst, jobject obj);
 361   void cmp_narrow_oop(Register dst, jobject obj);
 362   void cmp_narrow_oop(Address dst, jobject obj);
 363 
<span class="line-modified"> 364   void encode_klass_not_null(Register r);</span>
<span class="line-modified"> 365   void decode_klass_not_null(Register r);</span>
<span class="line-modified"> 366   void encode_klass_not_null(Register dst, Register src);</span>
<span class="line-modified"> 367   void decode_klass_not_null(Register dst, Register src);</span>
 368   void set_narrow_klass(Register dst, Klass* k);
 369   void set_narrow_klass(Address dst, Klass* k);
 370   void cmp_narrow_klass(Register dst, Klass* k);
 371   void cmp_narrow_klass(Address dst, Klass* k);
 372 
<span class="line-removed"> 373   // Returns the byte size of the instructions generated by decode_klass_not_null()</span>
<span class="line-removed"> 374   // when compressed klass pointers are being used.</span>
<span class="line-removed"> 375   static int instr_size_for_decode_klass_not_null();</span>
<span class="line-removed"> 376 </span>
 377   // if heap base register is used - reinit it with the correct value
 378   void reinit_heapbase();
 379 
 380   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 381 
 382 #endif // _LP64
 383 
 384   // Int division/remainder for Java
 385   // (as idivl, but checks for special case as described in JVM spec.)
 386   // returns idivl instruction offset for implicit exception handling
 387   int corrected_idivl(Register reg);
 388 
 389   // Long division/remainder for Java
 390   // (as idivq, but checks for special case as described in JVM spec.)
 391   // returns idivq instruction offset for implicit exception handling
 392   int corrected_idivq(Register reg);
 393 
 394   void int3();
 395 
 396   // Long operation macros for a 32bit cpu
</pre>
<hr />
<pre>
 654   // If thread_reg is != noreg the code assumes the register passed contains
 655   // the thread (required on 64 bit).
 656   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 657 
 658   void verify_tlab();
 659 
 660   // Biased locking support
 661   // lock_reg and obj_reg must be loaded up with the appropriate values.
 662   // swap_reg must be rax, and is killed.
 663   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 664   // be killed; if not supplied, push/pop will be used internally to
 665   // allocate a temporary (inefficient, avoid if possible).
 666   // Optional slow case is for implementations (interpreter and C1) which branch to
 667   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 668   // Returns offset of first potentially-faulting instruction for null
 669   // check info (currently consumed only by C1). If
 670   // swap_reg_contains_mark is true then returns -1 as it is assumed
 671   // the calling code has already passed any potential faults.
 672   int biased_locking_enter(Register lock_reg, Register obj_reg,
 673                            Register swap_reg, Register tmp_reg,
<span class="line-modified"> 674                            bool swap_reg_contains_mark,</span>
 675                            Label&amp; done, Label* slow_case = NULL,
 676                            BiasedLockingCounters* counters = NULL);
 677   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 678 
 679   Condition negate_condition(Condition cond);
 680 
 681   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 682   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 683   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 684   // here in MacroAssembler. The major exception to this rule is call
 685 
 686   // Arithmetics
 687 
 688 
 689   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 690   void addptr(Address dst, Register src);
 691 
 692   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 693   void addptr(Register dst, int32_t src);
 694   void addptr(Register dst, Register src);
</pre>
</td>
<td>
<hr />
<pre>
 298   void resolve_jobject(Register value, Register thread, Register tmp);
 299 
 300   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 301   void c2bool(Register x);
 302 
 303   // C++ bool manipulation
 304 
 305   void movbool(Register dst, Address src);
 306   void movbool(Address dst, bool boolconst);
 307   void movbool(Address dst, Register src);
 308   void testbool(Register dst);
 309 
 310   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 311   void resolve_weak_handle(Register result, Register tmp);
 312   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 313   void load_method_holder_cld(Register rresult, Register rmethod);
 314 
 315   void load_method_holder(Register holder, Register method);
 316 
 317   // oop manipulations
<span class="line-modified"> 318   void load_klass(Register dst, Register src, Register tmp);</span>
<span class="line-modified"> 319   void store_klass(Register dst, Register src, Register tmp);</span>
 320 
 321   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 322                       Register tmp1, Register thread_tmp);
 323   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 324                        Register tmp1, Register tmp2);
 325 
 326   // Resolves obj access. Result is placed in the same register.
 327   // All other registers are preserved.
 328   void resolve(DecoratorSet decorators, Register obj);
 329 
 330   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 331                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 332   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 333                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 334   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 335                       Register tmp2 = noreg, DecoratorSet decorators = 0);
 336 
 337   // Used for storing NULL. All other oop constants should be
 338   // stored using routines that take a jobject.
 339   void store_heap_oop_null(Address dst);
 340 
<span class="line-modified"> 341   void load_prototype_header(Register dst, Register src, Register tmp);</span>
 342 
 343 #ifdef _LP64
 344   void store_klass_gap(Register dst, Register src);
 345 
 346   // This dummy is to prevent a call to store_heap_oop from
 347   // converting a zero (like NULL) into a Register by giving
 348   // the compiler two choices it can&#39;t resolve
 349 
 350   void store_heap_oop(Address dst, void* dummy);
 351 
 352   void encode_heap_oop(Register r);
 353   void decode_heap_oop(Register r);
 354   void encode_heap_oop_not_null(Register r);
 355   void decode_heap_oop_not_null(Register r);
 356   void encode_heap_oop_not_null(Register dst, Register src);
 357   void decode_heap_oop_not_null(Register dst, Register src);
 358 
 359   void set_narrow_oop(Register dst, jobject obj);
 360   void set_narrow_oop(Address dst, jobject obj);
 361   void cmp_narrow_oop(Register dst, jobject obj);
 362   void cmp_narrow_oop(Address dst, jobject obj);
 363 
<span class="line-modified"> 364   void encode_klass_not_null(Register r, Register tmp);</span>
<span class="line-modified"> 365   void decode_klass_not_null(Register r, Register tmp);</span>
<span class="line-modified"> 366   void encode_and_move_klass_not_null(Register dst, Register src);</span>
<span class="line-modified"> 367   void decode_and_move_klass_not_null(Register dst, Register src);</span>
 368   void set_narrow_klass(Register dst, Klass* k);
 369   void set_narrow_klass(Address dst, Klass* k);
 370   void cmp_narrow_klass(Register dst, Klass* k);
 371   void cmp_narrow_klass(Address dst, Klass* k);
 372 




 373   // if heap base register is used - reinit it with the correct value
 374   void reinit_heapbase();
 375 
 376   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 377 
 378 #endif // _LP64
 379 
 380   // Int division/remainder for Java
 381   // (as idivl, but checks for special case as described in JVM spec.)
 382   // returns idivl instruction offset for implicit exception handling
 383   int corrected_idivl(Register reg);
 384 
 385   // Long division/remainder for Java
 386   // (as idivq, but checks for special case as described in JVM spec.)
 387   // returns idivq instruction offset for implicit exception handling
 388   int corrected_idivq(Register reg);
 389 
 390   void int3();
 391 
 392   // Long operation macros for a 32bit cpu
</pre>
<hr />
<pre>
 650   // If thread_reg is != noreg the code assumes the register passed contains
 651   // the thread (required on 64 bit).
 652   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 653 
 654   void verify_tlab();
 655 
 656   // Biased locking support
 657   // lock_reg and obj_reg must be loaded up with the appropriate values.
 658   // swap_reg must be rax, and is killed.
 659   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 660   // be killed; if not supplied, push/pop will be used internally to
 661   // allocate a temporary (inefficient, avoid if possible).
 662   // Optional slow case is for implementations (interpreter and C1) which branch to
 663   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 664   // Returns offset of first potentially-faulting instruction for null
 665   // check info (currently consumed only by C1). If
 666   // swap_reg_contains_mark is true then returns -1 as it is assumed
 667   // the calling code has already passed any potential faults.
 668   int biased_locking_enter(Register lock_reg, Register obj_reg,
 669                            Register swap_reg, Register tmp_reg,
<span class="line-modified"> 670                            Register tmp_reg2, bool swap_reg_contains_mark,</span>
 671                            Label&amp; done, Label* slow_case = NULL,
 672                            BiasedLockingCounters* counters = NULL);
 673   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 674 
 675   Condition negate_condition(Condition cond);
 676 
 677   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 678   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 679   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 680   // here in MacroAssembler. The major exception to this rule is call
 681 
 682   // Arithmetics
 683 
 684 
 685   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 686   void addptr(Address dst, Register src);
 687 
 688   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 689   void addptr(Register dst, int32_t src);
 690   void addptr(Register dst, Register src);
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
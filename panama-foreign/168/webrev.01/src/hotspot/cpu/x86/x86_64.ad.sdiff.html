<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/globalDefinitions_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
<span class="line-modified">  360   return UseCompressedOops || UseCompressedClassPointers;</span>
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
</pre>
<hr />
<pre>
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
 1550   uint insts_size = cbuf.insts_size();
 1551   if (UseCompressedClassPointers) {
<span class="line-modified"> 1552     masm.load_klass(rscratch1, j_rarg0);</span>
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
</pre>
<hr />
<pre>
 5939   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5940   opcode(0x89);
 5941   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5942   ins_pipe(ialu_mem_reg); // XXX
 5943 %}
 5944 
 5945 // Store Pointer
 5946 instruct storeP(memory mem, any_RegP src)
 5947 %{
 5948   match(Set mem (StoreP mem src));
 5949 
 5950   ins_cost(125); // XXX
 5951   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5952   opcode(0x89);
 5953   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5954   ins_pipe(ialu_mem_reg);
 5955 %}
 5956 
 5957 instruct storeImmP0(memory mem, immP0 zero)
 5958 %{
<span class="line-modified"> 5959   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 5960   match(Set mem (StoreP mem zero));
 5961 
 5962   ins_cost(125); // XXX
 5963   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5964   ins_encode %{
 5965     __ movq($mem$$Address, r12);
 5966   %}
 5967   ins_pipe(ialu_mem_reg);
 5968 %}
 5969 
 5970 // Store NULL Pointer, mark word, or other simple pointer constant.
 5971 instruct storeImmP(memory mem, immP31 src)
 5972 %{
 5973   match(Set mem (StoreP mem src));
 5974 
 5975   ins_cost(150); // XXX
 5976   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5977   opcode(0xC7); /* C7 /0 */
 5978   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5979   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 5989   ins_encode %{
 5990     __ movl($mem$$Address, $src$$Register);
 5991   %}
 5992   ins_pipe(ialu_mem_reg);
 5993 %}
 5994 
 5995 instruct storeNKlass(memory mem, rRegN src)
 5996 %{
 5997   match(Set mem (StoreNKlass mem src));
 5998 
 5999   ins_cost(125); // XXX
 6000   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6001   ins_encode %{
 6002     __ movl($mem$$Address, $src$$Register);
 6003   %}
 6004   ins_pipe(ialu_mem_reg);
 6005 %}
 6006 
 6007 instruct storeImmN0(memory mem, immN0 zero)
 6008 %{
<span class="line-modified"> 6009   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
 6010   match(Set mem (StoreN mem zero));
 6011 
 6012   ins_cost(125); // XXX
 6013   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6014   ins_encode %{
 6015     __ movl($mem$$Address, r12);
 6016   %}
 6017   ins_pipe(ialu_mem_reg);
 6018 %}
 6019 
 6020 instruct storeImmN(memory mem, immN src)
 6021 %{
 6022   match(Set mem (StoreN mem src));
 6023 
 6024   ins_cost(150); // XXX
 6025   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6026   ins_encode %{
 6027     address con = (address)$src$$constant;
 6028     if (con == NULL) {
 6029       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6032     }
 6033   %}
 6034   ins_pipe(ialu_mem_imm);
 6035 %}
 6036 
 6037 instruct storeImmNKlass(memory mem, immNKlass src)
 6038 %{
 6039   match(Set mem (StoreNKlass mem src));
 6040 
 6041   ins_cost(150); // XXX
 6042   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6043   ins_encode %{
 6044     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6045   %}
 6046   ins_pipe(ialu_mem_imm);
 6047 %}
 6048 
 6049 // Store Integer Immediate
 6050 instruct storeImmI0(memory mem, immI0 zero)
 6051 %{
<span class="line-modified"> 6052   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6053   match(Set mem (StoreI mem zero));
 6054 
 6055   ins_cost(125); // XXX
 6056   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6057   ins_encode %{
 6058     __ movl($mem$$Address, r12);
 6059   %}
 6060   ins_pipe(ialu_mem_reg);
 6061 %}
 6062 
 6063 instruct storeImmI(memory mem, immI src)
 6064 %{
 6065   match(Set mem (StoreI mem src));
 6066 
 6067   ins_cost(150);
 6068   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6069   opcode(0xC7); /* C7 /0 */
 6070   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6071   ins_pipe(ialu_mem_imm);
 6072 %}
 6073 
 6074 // Store Long Immediate
 6075 instruct storeImmL0(memory mem, immL0 zero)
 6076 %{
<span class="line-modified"> 6077   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6078   match(Set mem (StoreL mem zero));
 6079 
 6080   ins_cost(125); // XXX
 6081   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6082   ins_encode %{
 6083     __ movq($mem$$Address, r12);
 6084   %}
 6085   ins_pipe(ialu_mem_reg);
 6086 %}
 6087 
 6088 instruct storeImmL(memory mem, immL32 src)
 6089 %{
 6090   match(Set mem (StoreL mem src));
 6091 
 6092   ins_cost(150);
 6093   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6094   opcode(0xC7); /* C7 /0 */
 6095   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6096   ins_pipe(ialu_mem_imm);
 6097 %}
 6098 
 6099 // Store Short/Char Immediate
 6100 instruct storeImmC0(memory mem, immI0 zero)
 6101 %{
<span class="line-modified"> 6102   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6103   match(Set mem (StoreC mem zero));
 6104 
 6105   ins_cost(125); // XXX
 6106   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6107   ins_encode %{
 6108     __ movw($mem$$Address, r12);
 6109   %}
 6110   ins_pipe(ialu_mem_reg);
 6111 %}
 6112 
 6113 instruct storeImmI16(memory mem, immI16 src)
 6114 %{
 6115   predicate(UseStoreImmI16);
 6116   match(Set mem (StoreC mem src));
 6117 
 6118   ins_cost(150);
 6119   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6120   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6121   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6122   ins_pipe(ialu_mem_imm);
 6123 %}
 6124 
 6125 // Store Byte Immediate
 6126 instruct storeImmB0(memory mem, immI0 zero)
 6127 %{
<span class="line-modified"> 6128   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6129   match(Set mem (StoreB mem zero));
 6130 
 6131   ins_cost(125); // XXX
 6132   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6133   ins_encode %{
 6134     __ movb($mem$$Address, r12);
 6135   %}
 6136   ins_pipe(ialu_mem_reg);
 6137 %}
 6138 
 6139 instruct storeImmB(memory mem, immI8 src)
 6140 %{
 6141   match(Set mem (StoreB mem src));
 6142 
 6143   ins_cost(150); // XXX
 6144   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6145   opcode(0xC6); /* C6 /0 */
 6146   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6147   ins_pipe(ialu_mem_imm);
 6148 %}
 6149 
 6150 // Store CMS card-mark Immediate
 6151 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6152 %{
<span class="line-modified"> 6153   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6154   match(Set mem (StoreCM mem zero));
 6155 
 6156   ins_cost(125); // XXX
 6157   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6158   ins_encode %{
 6159     __ movb($mem$$Address, r12);
 6160   %}
 6161   ins_pipe(ialu_mem_reg);
 6162 %}
 6163 
 6164 instruct storeImmCM0(memory mem, immI0 src)
 6165 %{
 6166   match(Set mem (StoreCM mem src));
 6167 
 6168   ins_cost(150); // XXX
 6169   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6170   opcode(0xC6); /* C6 /0 */
 6171   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6172   ins_pipe(ialu_mem_imm);
 6173 %}
 6174 
 6175 // Store Float
 6176 instruct storeF(memory mem, regF src)
 6177 %{
 6178   match(Set mem (StoreF mem src));
 6179 
 6180   ins_cost(95); // XXX
 6181   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6182   ins_encode %{
 6183     __ movflt($mem$$Address, $src$$XMMRegister);
 6184   %}
 6185   ins_pipe(pipe_slow); // XXX
 6186 %}
 6187 
 6188 // Store immediate Float value (it is faster than store from XMM register)
 6189 instruct storeF0(memory mem, immF0 zero)
 6190 %{
<span class="line-modified"> 6191   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6192   match(Set mem (StoreF mem zero));
 6193 
 6194   ins_cost(25); // XXX
 6195   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6196   ins_encode %{
 6197     __ movl($mem$$Address, r12);
 6198   %}
 6199   ins_pipe(ialu_mem_reg);
 6200 %}
 6201 
 6202 instruct storeF_imm(memory mem, immF src)
 6203 %{
 6204   match(Set mem (StoreF mem src));
 6205 
 6206   ins_cost(50);
 6207   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6208   opcode(0xC7); /* C7 /0 */
 6209   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6210   ins_pipe(ialu_mem_imm);
 6211 %}
</pre>
<hr />
<pre>
 6221     __ movdbl($mem$$Address, $src$$XMMRegister);
 6222   %}
 6223   ins_pipe(pipe_slow); // XXX
 6224 %}
 6225 
 6226 // Store immediate double 0.0 (it is faster than store from XMM register)
 6227 instruct storeD0_imm(memory mem, immD0 src)
 6228 %{
 6229   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6230   match(Set mem (StoreD mem src));
 6231 
 6232   ins_cost(50);
 6233   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6234   opcode(0xC7); /* C7 /0 */
 6235   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6236   ins_pipe(ialu_mem_imm);
 6237 %}
 6238 
 6239 instruct storeD0(memory mem, immD0 zero)
 6240 %{
<span class="line-modified"> 6241   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6242   match(Set mem (StoreD mem zero));
 6243 
 6244   ins_cost(25); // XXX
 6245   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6246   ins_encode %{
 6247     __ movq($mem$$Address, r12);
 6248   %}
 6249   ins_pipe(ialu_mem_reg);
 6250 %}
 6251 
 6252 instruct storeSSI(stackSlotI dst, rRegI src)
 6253 %{
 6254   match(Set dst src);
 6255 
 6256   ins_cost(100);
 6257   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6258   opcode(0x89);
 6259   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6260   ins_pipe( ialu_mem_reg );
 6261 %}
</pre>
<hr />
<pre>
 6774 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6775   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6776             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6777   match(Set dst (DecodeN src));
 6778   effect(KILL cr);
 6779   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6780   ins_encode %{
 6781     Register s = $src$$Register;
 6782     Register d = $dst$$Register;
 6783     if (s != d) {
 6784       __ decode_heap_oop_not_null(d, s);
 6785     } else {
 6786       __ decode_heap_oop_not_null(d);
 6787     }
 6788   %}
 6789   ins_pipe(ialu_reg_long);
 6790 %}
 6791 
 6792 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6793   match(Set dst (EncodePKlass src));
<span class="line-modified"> 6794   effect(KILL cr);</span>
<span class="line-modified"> 6795   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}</span>
 6796   ins_encode %{
<span class="line-modified"> 6797     __ encode_klass_not_null($dst$$Register, $src$$Register);</span>
 6798   %}
 6799   ins_pipe(ialu_reg_long);
 6800 %}
 6801 
 6802 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6803   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 6804   effect(KILL cr);</span>
<span class="line-modified"> 6805   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}</span>
 6806   ins_encode %{
<span class="line-modified"> 6807     Register s = $src$$Register;</span>
<span class="line-removed"> 6808     Register d = $dst$$Register;</span>
<span class="line-removed"> 6809     if (s != d) {</span>
<span class="line-removed"> 6810       __ decode_klass_not_null(d, s);</span>
<span class="line-removed"> 6811     } else {</span>
<span class="line-removed"> 6812       __ decode_klass_not_null(d);</span>
<span class="line-removed"> 6813     }</span>
 6814   %}
 6815   ins_pipe(ialu_reg_long);
 6816 %}
 6817 
<span class="line-removed"> 6818 </span>
 6819 //----------Conditional Move---------------------------------------------------
 6820 // Jump
 6821 // dummy instruction for generating temp registers
 6822 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6823   match(Jump (LShiftL switch_val shift));
 6824   ins_cost(350);
 6825   predicate(false);
 6826   effect(TEMP dest);
 6827 
 6828   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6829             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6830   ins_encode %{
 6831     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6832     // to do that and the compiler is using that register as one it can allocate.
 6833     // So we build it all by hand.
 6834     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6835     // ArrayAddress dispatch(table, index);
 6836     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6837     __ lea($dest$$Register, $constantaddress);
 6838     __ jmp(dispatch);
</pre>
<hr />
<pre>
11706 
11707 // This will generate a signed flags result. This should be OK since
11708 // any compare to a zero should be eq/neq.
11709 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11710 %{
11711   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11712             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11713   match(Set cr (CmpP (LoadP op) zero));
11714 
11715   ins_cost(500); // XXX
11716   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11717   opcode(0xF7); /* Opcode F7 /0 */
11718   ins_encode(REX_mem_wide(op),
11719              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11720   ins_pipe(ialu_cr_reg_imm);
11721 %}
11722 
11723 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11724 %{
11725   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
<span class="line-removed">11726             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
11727             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11728   match(Set cr (CmpP (LoadP mem) zero));
11729 
11730   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11731   ins_encode %{
11732     __ cmpq(r12, $mem$$Address);
11733   %}
11734   ins_pipe(ialu_cr_reg_mem);
11735 %}
11736 
11737 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11738 %{
11739   match(Set cr (CmpN op1 op2));
11740 
11741   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11742   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11743   ins_pipe(ialu_cr_reg_reg);
11744 %}
11745 
11746 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
</pre>
<hr />
<pre>
11802   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11803   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11804   ins_pipe(ialu_cr_reg_imm);
11805 %}
11806 
11807 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11808 %{
11809   predicate(CompressedOops::base() != NULL);
11810   match(Set cr (CmpN (LoadN mem) zero));
11811 
11812   ins_cost(500); // XXX
11813   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11814   ins_encode %{
11815     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11816   %}
11817   ins_pipe(ialu_cr_reg_mem);
11818 %}
11819 
11820 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11821 %{
<span class="line-modified">11822   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
11823   match(Set cr (CmpN (LoadN mem) zero));
11824 
11825   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11826   ins_encode %{
11827     __ cmpl(r12, $mem$$Address);
11828   %}
11829   ins_pipe(ialu_cr_reg_mem);
11830 %}
11831 
11832 // Yanked all unsigned pointer compare operations.
11833 // Pointer compares are done with CmpP which is already unsigned.
11834 
11835 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11836 %{
11837   match(Set cr (CmpL op1 op2));
11838 
11839   format %{ &quot;cmpq    $op1, $op2&quot; %}
11840   opcode(0x3B);  /* Opcode 3B /r */
11841   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11842   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12449 
12450 // ============================================================================
12451 // inlined locking and unlocking
12452 
12453 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12454   predicate(Compile::current()-&gt;use_rtm());
12455   match(Set cr (FastLock object box));
12456   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12457   ins_cost(300);
12458   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12459   ins_encode %{
12460     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12461                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12462                  _counters, _rtm_counters, _stack_rtm_counters,
12463                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12464                  true, ra_-&gt;C-&gt;profile_rtm());
12465   %}
12466   ins_pipe(pipe_slow);
12467 %}
12468 
<span class="line-modified">12469 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{</span>
12470   predicate(!Compile::current()-&gt;use_rtm());
12471   match(Set cr (FastLock object box));
<span class="line-modified">12472   effect(TEMP tmp, TEMP scr, USE_KILL box);</span>
12473   ins_cost(300);
12474   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12475   ins_encode %{
12476     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<span class="line-modified">12477                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);</span>
12478   %}
12479   ins_pipe(pipe_slow);
12480 %}
12481 
12482 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12483   match(Set cr (FastUnlock object box));
12484   effect(TEMP tmp, USE_KILL box);
12485   ins_cost(300);
12486   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12487   ins_encode %{
12488     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12489   %}
12490   ins_pipe(pipe_slow);
12491 %}
12492 
12493 
12494 // ============================================================================
12495 // Safepoint Instructions
12496 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12497 %{
</pre>
</td>
<td>
<hr />
<pre>
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
<span class="line-modified">  360   return UseCompressedOops;</span>
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
</pre>
<hr />
<pre>
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
 1550   uint insts_size = cbuf.insts_size();
 1551   if (UseCompressedClassPointers) {
<span class="line-modified"> 1552     masm.load_klass(rscratch1, j_rarg0, rscratch2);</span>
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
</pre>
<hr />
<pre>
 5939   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5940   opcode(0x89);
 5941   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5942   ins_pipe(ialu_mem_reg); // XXX
 5943 %}
 5944 
 5945 // Store Pointer
 5946 instruct storeP(memory mem, any_RegP src)
 5947 %{
 5948   match(Set mem (StoreP mem src));
 5949 
 5950   ins_cost(125); // XXX
 5951   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5952   opcode(0x89);
 5953   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5954   ins_pipe(ialu_mem_reg);
 5955 %}
 5956 
 5957 instruct storeImmP0(memory mem, immP0 zero)
 5958 %{
<span class="line-modified"> 5959   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 5960   match(Set mem (StoreP mem zero));
 5961 
 5962   ins_cost(125); // XXX
 5963   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5964   ins_encode %{
 5965     __ movq($mem$$Address, r12);
 5966   %}
 5967   ins_pipe(ialu_mem_reg);
 5968 %}
 5969 
 5970 // Store NULL Pointer, mark word, or other simple pointer constant.
 5971 instruct storeImmP(memory mem, immP31 src)
 5972 %{
 5973   match(Set mem (StoreP mem src));
 5974 
 5975   ins_cost(150); // XXX
 5976   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5977   opcode(0xC7); /* C7 /0 */
 5978   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5979   ins_pipe(ialu_mem_imm);
</pre>
<hr />
<pre>
 5989   ins_encode %{
 5990     __ movl($mem$$Address, $src$$Register);
 5991   %}
 5992   ins_pipe(ialu_mem_reg);
 5993 %}
 5994 
 5995 instruct storeNKlass(memory mem, rRegN src)
 5996 %{
 5997   match(Set mem (StoreNKlass mem src));
 5998 
 5999   ins_cost(125); // XXX
 6000   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6001   ins_encode %{
 6002     __ movl($mem$$Address, $src$$Register);
 6003   %}
 6004   ins_pipe(ialu_mem_reg);
 6005 %}
 6006 
 6007 instruct storeImmN0(memory mem, immN0 zero)
 6008 %{
<span class="line-modified"> 6009   predicate(CompressedOops::base() == NULL);</span>
 6010   match(Set mem (StoreN mem zero));
 6011 
 6012   ins_cost(125); // XXX
 6013   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6014   ins_encode %{
 6015     __ movl($mem$$Address, r12);
 6016   %}
 6017   ins_pipe(ialu_mem_reg);
 6018 %}
 6019 
 6020 instruct storeImmN(memory mem, immN src)
 6021 %{
 6022   match(Set mem (StoreN mem src));
 6023 
 6024   ins_cost(150); // XXX
 6025   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6026   ins_encode %{
 6027     address con = (address)$src$$constant;
 6028     if (con == NULL) {
 6029       __ movl($mem$$Address, (int32_t)0);
</pre>
<hr />
<pre>
 6032     }
 6033   %}
 6034   ins_pipe(ialu_mem_imm);
 6035 %}
 6036 
 6037 instruct storeImmNKlass(memory mem, immNKlass src)
 6038 %{
 6039   match(Set mem (StoreNKlass mem src));
 6040 
 6041   ins_cost(150); // XXX
 6042   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6043   ins_encode %{
 6044     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6045   %}
 6046   ins_pipe(ialu_mem_imm);
 6047 %}
 6048 
 6049 // Store Integer Immediate
 6050 instruct storeImmI0(memory mem, immI0 zero)
 6051 %{
<span class="line-modified"> 6052   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6053   match(Set mem (StoreI mem zero));
 6054 
 6055   ins_cost(125); // XXX
 6056   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6057   ins_encode %{
 6058     __ movl($mem$$Address, r12);
 6059   %}
 6060   ins_pipe(ialu_mem_reg);
 6061 %}
 6062 
 6063 instruct storeImmI(memory mem, immI src)
 6064 %{
 6065   match(Set mem (StoreI mem src));
 6066 
 6067   ins_cost(150);
 6068   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6069   opcode(0xC7); /* C7 /0 */
 6070   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6071   ins_pipe(ialu_mem_imm);
 6072 %}
 6073 
 6074 // Store Long Immediate
 6075 instruct storeImmL0(memory mem, immL0 zero)
 6076 %{
<span class="line-modified"> 6077   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6078   match(Set mem (StoreL mem zero));
 6079 
 6080   ins_cost(125); // XXX
 6081   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6082   ins_encode %{
 6083     __ movq($mem$$Address, r12);
 6084   %}
 6085   ins_pipe(ialu_mem_reg);
 6086 %}
 6087 
 6088 instruct storeImmL(memory mem, immL32 src)
 6089 %{
 6090   match(Set mem (StoreL mem src));
 6091 
 6092   ins_cost(150);
 6093   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6094   opcode(0xC7); /* C7 /0 */
 6095   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6096   ins_pipe(ialu_mem_imm);
 6097 %}
 6098 
 6099 // Store Short/Char Immediate
 6100 instruct storeImmC0(memory mem, immI0 zero)
 6101 %{
<span class="line-modified"> 6102   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6103   match(Set mem (StoreC mem zero));
 6104 
 6105   ins_cost(125); // XXX
 6106   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6107   ins_encode %{
 6108     __ movw($mem$$Address, r12);
 6109   %}
 6110   ins_pipe(ialu_mem_reg);
 6111 %}
 6112 
 6113 instruct storeImmI16(memory mem, immI16 src)
 6114 %{
 6115   predicate(UseStoreImmI16);
 6116   match(Set mem (StoreC mem src));
 6117 
 6118   ins_cost(150);
 6119   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6120   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6121   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6122   ins_pipe(ialu_mem_imm);
 6123 %}
 6124 
 6125 // Store Byte Immediate
 6126 instruct storeImmB0(memory mem, immI0 zero)
 6127 %{
<span class="line-modified"> 6128   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6129   match(Set mem (StoreB mem zero));
 6130 
 6131   ins_cost(125); // XXX
 6132   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6133   ins_encode %{
 6134     __ movb($mem$$Address, r12);
 6135   %}
 6136   ins_pipe(ialu_mem_reg);
 6137 %}
 6138 
 6139 instruct storeImmB(memory mem, immI8 src)
 6140 %{
 6141   match(Set mem (StoreB mem src));
 6142 
 6143   ins_cost(150); // XXX
 6144   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6145   opcode(0xC6); /* C6 /0 */
 6146   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6147   ins_pipe(ialu_mem_imm);
 6148 %}
 6149 
 6150 // Store CMS card-mark Immediate
 6151 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6152 %{
<span class="line-modified"> 6153   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6154   match(Set mem (StoreCM mem zero));
 6155 
 6156   ins_cost(125); // XXX
 6157   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6158   ins_encode %{
 6159     __ movb($mem$$Address, r12);
 6160   %}
 6161   ins_pipe(ialu_mem_reg);
 6162 %}
 6163 
 6164 instruct storeImmCM0(memory mem, immI0 src)
 6165 %{
 6166   match(Set mem (StoreCM mem src));
 6167 
 6168   ins_cost(150); // XXX
 6169   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6170   opcode(0xC6); /* C6 /0 */
 6171   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6172   ins_pipe(ialu_mem_imm);
 6173 %}
 6174 
 6175 // Store Float
 6176 instruct storeF(memory mem, regF src)
 6177 %{
 6178   match(Set mem (StoreF mem src));
 6179 
 6180   ins_cost(95); // XXX
 6181   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6182   ins_encode %{
 6183     __ movflt($mem$$Address, $src$$XMMRegister);
 6184   %}
 6185   ins_pipe(pipe_slow); // XXX
 6186 %}
 6187 
 6188 // Store immediate Float value (it is faster than store from XMM register)
 6189 instruct storeF0(memory mem, immF0 zero)
 6190 %{
<span class="line-modified"> 6191   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6192   match(Set mem (StoreF mem zero));
 6193 
 6194   ins_cost(25); // XXX
 6195   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6196   ins_encode %{
 6197     __ movl($mem$$Address, r12);
 6198   %}
 6199   ins_pipe(ialu_mem_reg);
 6200 %}
 6201 
 6202 instruct storeF_imm(memory mem, immF src)
 6203 %{
 6204   match(Set mem (StoreF mem src));
 6205 
 6206   ins_cost(50);
 6207   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6208   opcode(0xC7); /* C7 /0 */
 6209   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6210   ins_pipe(ialu_mem_imm);
 6211 %}
</pre>
<hr />
<pre>
 6221     __ movdbl($mem$$Address, $src$$XMMRegister);
 6222   %}
 6223   ins_pipe(pipe_slow); // XXX
 6224 %}
 6225 
 6226 // Store immediate double 0.0 (it is faster than store from XMM register)
 6227 instruct storeD0_imm(memory mem, immD0 src)
 6228 %{
 6229   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6230   match(Set mem (StoreD mem src));
 6231 
 6232   ins_cost(50);
 6233   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6234   opcode(0xC7); /* C7 /0 */
 6235   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6236   ins_pipe(ialu_mem_imm);
 6237 %}
 6238 
 6239 instruct storeD0(memory mem, immD0 zero)
 6240 %{
<span class="line-modified"> 6241   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));</span>
 6242   match(Set mem (StoreD mem zero));
 6243 
 6244   ins_cost(25); // XXX
 6245   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6246   ins_encode %{
 6247     __ movq($mem$$Address, r12);
 6248   %}
 6249   ins_pipe(ialu_mem_reg);
 6250 %}
 6251 
 6252 instruct storeSSI(stackSlotI dst, rRegI src)
 6253 %{
 6254   match(Set dst src);
 6255 
 6256   ins_cost(100);
 6257   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6258   opcode(0x89);
 6259   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6260   ins_pipe( ialu_mem_reg );
 6261 %}
</pre>
<hr />
<pre>
 6774 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6775   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6776             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6777   match(Set dst (DecodeN src));
 6778   effect(KILL cr);
 6779   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6780   ins_encode %{
 6781     Register s = $src$$Register;
 6782     Register d = $dst$$Register;
 6783     if (s != d) {
 6784       __ decode_heap_oop_not_null(d, s);
 6785     } else {
 6786       __ decode_heap_oop_not_null(d);
 6787     }
 6788   %}
 6789   ins_pipe(ialu_reg_long);
 6790 %}
 6791 
 6792 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6793   match(Set dst (EncodePKlass src));
<span class="line-modified"> 6794   effect(TEMP dst, KILL cr);</span>
<span class="line-modified"> 6795   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}</span>
 6796   ins_encode %{
<span class="line-modified"> 6797     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>
 6798   %}
 6799   ins_pipe(ialu_reg_long);
 6800 %}
 6801 
 6802 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6803   match(Set dst (DecodeNKlass src));
<span class="line-modified"> 6804   effect(TEMP dst, KILL cr);</span>
<span class="line-modified"> 6805   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}</span>
 6806   ins_encode %{
<span class="line-modified"> 6807     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);</span>






 6808   %}
 6809   ins_pipe(ialu_reg_long);
 6810 %}
 6811 

 6812 //----------Conditional Move---------------------------------------------------
 6813 // Jump
 6814 // dummy instruction for generating temp registers
 6815 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6816   match(Jump (LShiftL switch_val shift));
 6817   ins_cost(350);
 6818   predicate(false);
 6819   effect(TEMP dest);
 6820 
 6821   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6822             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6823   ins_encode %{
 6824     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6825     // to do that and the compiler is using that register as one it can allocate.
 6826     // So we build it all by hand.
 6827     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6828     // ArrayAddress dispatch(table, index);
 6829     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6830     __ lea($dest$$Register, $constantaddress);
 6831     __ jmp(dispatch);
</pre>
<hr />
<pre>
11699 
11700 // This will generate a signed flags result. This should be OK since
11701 // any compare to a zero should be eq/neq.
11702 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11703 %{
11704   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11705             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11706   match(Set cr (CmpP (LoadP op) zero));
11707 
11708   ins_cost(500); // XXX
11709   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11710   opcode(0xF7); /* Opcode F7 /0 */
11711   ins_encode(REX_mem_wide(op),
11712              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11713   ins_pipe(ialu_cr_reg_imm);
11714 %}
11715 
11716 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11717 %{
11718   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;

11719             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11720   match(Set cr (CmpP (LoadP mem) zero));
11721 
11722   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11723   ins_encode %{
11724     __ cmpq(r12, $mem$$Address);
11725   %}
11726   ins_pipe(ialu_cr_reg_mem);
11727 %}
11728 
11729 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11730 %{
11731   match(Set cr (CmpN op1 op2));
11732 
11733   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11734   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11735   ins_pipe(ialu_cr_reg_reg);
11736 %}
11737 
11738 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
</pre>
<hr />
<pre>
11794   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11795   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11796   ins_pipe(ialu_cr_reg_imm);
11797 %}
11798 
11799 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11800 %{
11801   predicate(CompressedOops::base() != NULL);
11802   match(Set cr (CmpN (LoadN mem) zero));
11803 
11804   ins_cost(500); // XXX
11805   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11806   ins_encode %{
11807     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11808   %}
11809   ins_pipe(ialu_cr_reg_mem);
11810 %}
11811 
11812 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11813 %{
<span class="line-modified">11814   predicate(CompressedOops::base() == NULL);</span>
11815   match(Set cr (CmpN (LoadN mem) zero));
11816 
11817   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11818   ins_encode %{
11819     __ cmpl(r12, $mem$$Address);
11820   %}
11821   ins_pipe(ialu_cr_reg_mem);
11822 %}
11823 
11824 // Yanked all unsigned pointer compare operations.
11825 // Pointer compares are done with CmpP which is already unsigned.
11826 
11827 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11828 %{
11829   match(Set cr (CmpL op1 op2));
11830 
11831   format %{ &quot;cmpq    $op1, $op2&quot; %}
11832   opcode(0x3B);  /* Opcode 3B /r */
11833   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11834   ins_pipe(ialu_cr_reg_reg);
</pre>
<hr />
<pre>
12441 
12442 // ============================================================================
12443 // inlined locking and unlocking
12444 
12445 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12446   predicate(Compile::current()-&gt;use_rtm());
12447   match(Set cr (FastLock object box));
12448   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12449   ins_cost(300);
12450   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12451   ins_encode %{
12452     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12453                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12454                  _counters, _rtm_counters, _stack_rtm_counters,
12455                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12456                  true, ra_-&gt;C-&gt;profile_rtm());
12457   %}
12458   ins_pipe(pipe_slow);
12459 %}
12460 
<span class="line-modified">12461 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{</span>
12462   predicate(!Compile::current()-&gt;use_rtm());
12463   match(Set cr (FastLock object box));
<span class="line-modified">12464   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);</span>
12465   ins_cost(300);
12466   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12467   ins_encode %{
12468     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<span class="line-modified">12469                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);</span>
12470   %}
12471   ins_pipe(pipe_slow);
12472 %}
12473 
12474 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12475   match(Set cr (FastUnlock object box));
12476   effect(TEMP tmp, USE_KILL box);
12477   ins_cost(300);
12478   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12479   ins_encode %{
12480     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12481   %}
12482   ins_pipe(pipe_slow);
12483 %}
12484 
12485 
12486 // ============================================================================
12487 // Safepoint Instructions
12488 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12489 %{
</pre>
</td>
</tr>
</table>
<center><a href="x86.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../zero/globalDefinitions_zero.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
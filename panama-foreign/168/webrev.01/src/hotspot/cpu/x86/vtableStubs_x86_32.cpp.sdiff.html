<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/vtableStubs_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/vtableStubs_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
178   // Entry arguments:
179   //  rax: CompiledICHolder
180   //  rcx: Receiver
181 
182   // Most registers are in use; we&#39;ll use rax, rbx, rsi, rdi
183   // (If we need to make rsi, rdi callee-save, do a push/pop here.)
184   const Register recv_klass_reg     = rsi;
185   const Register holder_klass_reg   = rax; // declaring interface klass (DECC)
186   const Register resolved_klass_reg = rbx; // resolved interface klass (REFC)
187   const Register temp_reg           = rdi;
188 
189   const Register icholder_reg = rax;
190   __ movptr(resolved_klass_reg, Address(icholder_reg, CompiledICHolder::holder_klass_offset()));
191   __ movptr(holder_klass_reg,   Address(icholder_reg, CompiledICHolder::holder_metadata_offset()));
192 
193   Label L_no_such_interface;
194 
195   // get receiver klass (also an implicit null-check)
196   assert(VtableStub::receiver_location() ==  rcx-&gt;as_VMReg(), &quot;receiver expected in  rcx&quot;);
197   address npe_addr = __ pc();
<span class="line-modified">198   __ load_klass(recv_klass_reg, rcx);</span>
199 
200   start_pc = __ pc();
201 
202   // Receiver subtype check against REFC.
203   // Destroys recv_klass_reg value.
204   __ lookup_interface_method(// inputs: rec. class, interface
205                              recv_klass_reg, resolved_klass_reg, noreg,
206                              // outputs:  scan temp. reg1, scan temp. reg2
207                              recv_klass_reg, temp_reg,
208                              L_no_such_interface,
209                              /*return_method=*/false);
210 
211   const ptrdiff_t  typecheckSize = __ pc() - start_pc;
212   start_pc = __ pc();
213 
214   // Get selected method from declaring class and itable index
215   const Register method = rbx;
<span class="line-modified">216   __ load_klass(recv_klass_reg, rcx); // restore recv_klass_reg</span>
217   __ lookup_interface_method(// inputs: rec. class, interface, itable index
218                              recv_klass_reg, holder_klass_reg, itable_index,
219                              // outputs: method, scan temp. reg
220                              method, temp_reg,
221                              L_no_such_interface);
222 
223   const ptrdiff_t  lookupSize = __ pc() - start_pc;
224 
225   // We expect we need index_dependent_slop extra bytes. Reason:
226   // The emitted code in lookup_interface_method changes when itable_index exceeds 31.
227   // For windows, a narrow estimate was found to be 104. Other OSes not tested.
228   const ptrdiff_t estimate = 104;
229   const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;
230   slop_delta  = (int)(estimate - codesize);
231   slop_bytes += slop_delta;
232   assert(slop_delta &gt;= 0, &quot;itable #%d: Code size estimate (%d) for lookup_interface_method too small, required: %d&quot;, itable_index, (int)estimate, (int)codesize);
233 
234   // method (rbx): Method*
235   // rcx: receiver
236 
</pre>
</td>
<td>
<hr />
<pre>
178   // Entry arguments:
179   //  rax: CompiledICHolder
180   //  rcx: Receiver
181 
182   // Most registers are in use; we&#39;ll use rax, rbx, rsi, rdi
183   // (If we need to make rsi, rdi callee-save, do a push/pop here.)
184   const Register recv_klass_reg     = rsi;
185   const Register holder_klass_reg   = rax; // declaring interface klass (DECC)
186   const Register resolved_klass_reg = rbx; // resolved interface klass (REFC)
187   const Register temp_reg           = rdi;
188 
189   const Register icholder_reg = rax;
190   __ movptr(resolved_klass_reg, Address(icholder_reg, CompiledICHolder::holder_klass_offset()));
191   __ movptr(holder_klass_reg,   Address(icholder_reg, CompiledICHolder::holder_metadata_offset()));
192 
193   Label L_no_such_interface;
194 
195   // get receiver klass (also an implicit null-check)
196   assert(VtableStub::receiver_location() ==  rcx-&gt;as_VMReg(), &quot;receiver expected in  rcx&quot;);
197   address npe_addr = __ pc();
<span class="line-modified">198   __ load_klass(recv_klass_reg, rcx, noreg);</span>
199 
200   start_pc = __ pc();
201 
202   // Receiver subtype check against REFC.
203   // Destroys recv_klass_reg value.
204   __ lookup_interface_method(// inputs: rec. class, interface
205                              recv_klass_reg, resolved_klass_reg, noreg,
206                              // outputs:  scan temp. reg1, scan temp. reg2
207                              recv_klass_reg, temp_reg,
208                              L_no_such_interface,
209                              /*return_method=*/false);
210 
211   const ptrdiff_t  typecheckSize = __ pc() - start_pc;
212   start_pc = __ pc();
213 
214   // Get selected method from declaring class and itable index
215   const Register method = rbx;
<span class="line-modified">216   __ load_klass(recv_klass_reg, rcx, noreg); // restore recv_klass_reg</span>
217   __ lookup_interface_method(// inputs: rec. class, interface, itable index
218                              recv_klass_reg, holder_klass_reg, itable_index,
219                              // outputs: method, scan temp. reg
220                              method, temp_reg,
221                              L_no_such_interface);
222 
223   const ptrdiff_t  lookupSize = __ pc() - start_pc;
224 
225   // We expect we need index_dependent_slop extra bytes. Reason:
226   // The emitted code in lookup_interface_method changes when itable_index exceeds 31.
227   // For windows, a narrow estimate was found to be 104. Other OSes not tested.
228   const ptrdiff_t estimate = 104;
229   const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;
230   slop_delta  = (int)(estimate - codesize);
231   slop_bytes += slop_delta;
232   assert(slop_delta &gt;= 0, &quot;itable #%d: Code size estimate (%d) for lookup_interface_method too small, required: %d&quot;, itable_index, (int)estimate, (int)codesize);
233 
234   // method (rbx): Method*
235   // rcx: receiver
236 
</pre>
</td>
</tr>
</table>
<center><a href="templateTable_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
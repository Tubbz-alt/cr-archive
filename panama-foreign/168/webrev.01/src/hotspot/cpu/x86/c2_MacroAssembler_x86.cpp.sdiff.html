<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Runtime1_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c2_MacroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 425 //    FailureLabel
 426 
 427 
 428 // obj: object to lock
 429 // box: on-stack box address (displaced header location) - KILLED
 430 // rax,: tmp -- KILLED
 431 // scr: tmp -- KILLED
 432 void C2_MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,
 433                                  Register scrReg, Register cx1Reg, Register cx2Reg,
 434                                  BiasedLockingCounters* counters,
 435                                  RTMLockingCounters* rtm_counters,
 436                                  RTMLockingCounters* stack_rtm_counters,
 437                                  Metadata* method_data,
 438                                  bool use_rtm, bool profile_rtm) {
 439   // Ensure the register assignments are disjoint
 440   assert(tmpReg == rax, &quot;&quot;);
 441 
 442   if (use_rtm) {
 443     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);
 444   } else {
<span class="line-removed"> 445     assert(cx1Reg == noreg, &quot;&quot;);</span>
 446     assert(cx2Reg == noreg, &quot;&quot;);
 447     assert_different_registers(objReg, boxReg, tmpReg, scrReg);
 448   }
 449 
 450   if (counters != NULL) {
 451     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);
 452   }
 453 
 454   // Possible cases that we&#39;ll encounter in fast_lock
 455   // ------------------------------------------------
 456   // * Inflated
 457   //    -- unlocked
 458   //    -- Locked
 459   //       = by self
 460   //       = by other
 461   // * biased
 462   //    -- by Self
 463   //    -- by other
 464   // * neutral
 465   // * stack-locked
 466   //    -- by self
 467   //       = sp-proximity test hits
 468   //       = sp-proximity test generates false-negative
 469   //    -- by other
 470   //
 471 
 472   Label IsInflated, DONE_LABEL;
 473 
 474   // it&#39;s stack-locked, biased or neutral
 475   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage
 476   // order to reduce the number of conditional branches in the most common cases.
 477   // Beware -- there&#39;s a subtle invariant that fetch of the markword
 478   // at [FETCH], below, will never observe a biased encoding (*101b).
 479   // If this invariant is not held we risk exclusion (safety) failure.
 480   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
<span class="line-modified"> 481     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);</span>
 482   }
 483 
 484 #if INCLUDE_RTM_OPT
 485   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 486     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,
 487                       stack_rtm_counters, method_data, profile_rtm,
 488                       DONE_LABEL, IsInflated);
 489   }
 490 #endif // INCLUDE_RTM_OPT
 491 
 492   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]
 493   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased
 494   jccb(Assembler::notZero, IsInflated);
 495 
 496   // Attempt stack-locking ...
 497   orptr (tmpReg, markWord::unlocked_value);
 498   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS
 499   lock();
 500   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg
 501   if (counters != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
 425 //    FailureLabel
 426 
 427 
 428 // obj: object to lock
 429 // box: on-stack box address (displaced header location) - KILLED
 430 // rax,: tmp -- KILLED
 431 // scr: tmp -- KILLED
 432 void C2_MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,
 433                                  Register scrReg, Register cx1Reg, Register cx2Reg,
 434                                  BiasedLockingCounters* counters,
 435                                  RTMLockingCounters* rtm_counters,
 436                                  RTMLockingCounters* stack_rtm_counters,
 437                                  Metadata* method_data,
 438                                  bool use_rtm, bool profile_rtm) {
 439   // Ensure the register assignments are disjoint
 440   assert(tmpReg == rax, &quot;&quot;);
 441 
 442   if (use_rtm) {
 443     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);
 444   } else {

 445     assert(cx2Reg == noreg, &quot;&quot;);
 446     assert_different_registers(objReg, boxReg, tmpReg, scrReg);
 447   }
 448 
 449   if (counters != NULL) {
 450     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);
 451   }
 452 
 453   // Possible cases that we&#39;ll encounter in fast_lock
 454   // ------------------------------------------------
 455   // * Inflated
 456   //    -- unlocked
 457   //    -- Locked
 458   //       = by self
 459   //       = by other
 460   // * biased
 461   //    -- by Self
 462   //    -- by other
 463   // * neutral
 464   // * stack-locked
 465   //    -- by self
 466   //       = sp-proximity test hits
 467   //       = sp-proximity test generates false-negative
 468   //    -- by other
 469   //
 470 
 471   Label IsInflated, DONE_LABEL;
 472 
 473   // it&#39;s stack-locked, biased or neutral
 474   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage
 475   // order to reduce the number of conditional branches in the most common cases.
 476   // Beware -- there&#39;s a subtle invariant that fetch of the markword
 477   // at [FETCH], below, will never observe a biased encoding (*101b).
 478   // If this invariant is not held we risk exclusion (safety) failure.
 479   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {
<span class="line-modified"> 480     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, cx1Reg, false, DONE_LABEL, NULL, counters);</span>
 481   }
 482 
 483 #if INCLUDE_RTM_OPT
 484   if (UseRTMForStackLocks &amp;&amp; use_rtm) {
 485     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,
 486                       stack_rtm_counters, method_data, profile_rtm,
 487                       DONE_LABEL, IsInflated);
 488   }
 489 #endif // INCLUDE_RTM_OPT
 490 
 491   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]
 492   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased
 493   jccb(Assembler::notZero, IsInflated);
 494 
 495   // Attempt stack-locking ...
 496   orptr (tmpReg, markWord::unlocked_value);
 497   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS
 498   lock();
 499   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg
 500   if (counters != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="c1_Runtime1_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
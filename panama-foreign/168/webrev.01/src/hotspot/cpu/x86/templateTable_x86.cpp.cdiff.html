<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_32.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1126,14 ***</span>
  
    index_check_without_pop(rdx, rcx);     // kills rbx
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
    // Move subklass into rbx
<span class="line-modified">!   __ load_klass(rbx, rax);</span>
    // Move superklass into rax
<span class="line-modified">!   __ load_klass(rax, rdx);</span>
    __ movptr(rax, Address(rax,
                           ObjArrayKlass::element_klass_offset()));
  
    // Generate subtype check.  Blows rcx, rdi
    // Superklass in rax.  Subklass in rbx.
<span class="line-new-header">--- 1126,15 ---</span>
  
    index_check_without_pop(rdx, rcx);     // kills rbx
    __ testptr(rax, rax);
    __ jcc(Assembler::zero, is_null);
  
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
    // Move subklass into rbx
<span class="line-modified">!   __ load_klass(rbx, rax, tmp_load_klass);</span>
    // Move superklass into rax
<span class="line-modified">!   __ load_klass(rax, rdx, tmp_load_klass);</span>
    __ movptr(rax, Address(rax,
                           ObjArrayKlass::element_klass_offset()));
  
    // Generate subtype check.  Blows rcx, rdi
    // Superklass in rax.  Subklass in rbx.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1172,11 ***</span>
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
    // Need to check whether array is boolean or byte
    // since both types share the bastore bytecode.
<span class="line-modified">!   __ load_klass(rcx, rdx);</span>
    __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
    int diffbit = Klass::layout_helper_boolean_diffbit();
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
<span class="line-new-header">--- 1173,12 ---</span>
    // rbx: index
    // rdx: array
    index_check(rdx, rbx); // prefer index in rbx
    // Need to check whether array is boolean or byte
    // since both types share the bastore bytecode.
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rcx, rdx, tmp_load_klass);</span>
    __ movl(rcx, Address(rcx, Klass::layout_helper_offset()));
    int diffbit = Klass::layout_helper_boolean_diffbit();
    __ testl(rcx, diffbit);
    Label L_skip;
    __ jccb(Assembler::zero, L_skip);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2642,11 ***</span>
  
    if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
      assert(state == vtos, &quot;only valid state&quot;);
      Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
      __ movptr(robj, aaddress(0));
<span class="line-modified">!     __ load_klass(rdi, robj);</span>
      __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
      __ testl(rdi, JVM_ACC_HAS_FINALIZER);
      Label skip_register_finalizer;
      __ jcc(Assembler::zero, skip_register_finalizer);
  
<span class="line-new-header">--- 2644,12 ---</span>
  
    if (_desc-&gt;bytecode() == Bytecodes::_return_register_finalizer) {
      assert(state == vtos, &quot;only valid state&quot;);
      Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);
      __ movptr(robj, aaddress(0));
<span class="line-modified">!     Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+     __ load_klass(rdi, robj, tmp_load_klass);</span>
      __ movl(rdi, Address(rdi, Klass::access_flags_offset()));
      __ testl(rdi, JVM_ACC_HAS_FINALIZER);
      Label skip_register_finalizer;
      __ jcc(Assembler::zero, skip_register_finalizer);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3735,11 ***</span>
  
    __ bind(notFinal);
  
    // get receiver klass
    __ null_check(recv, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rax, recv);</span>
  
    // profile this call
    __ profile_virtual_call(rax, rlocals, rdx);
    // get target Method* &amp; entry point
    __ lookup_virtual_method(rax, index, method);
<span class="line-new-header">--- 3738,12 ---</span>
  
    __ bind(notFinal);
  
    // get receiver klass
    __ null_check(recv, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rax, recv, tmp_load_klass);</span>
  
    // profile this call
    __ profile_virtual_call(rax, rlocals, rdx);
    // get target Method* &amp; entry point
    __ lookup_virtual_method(rax, index, method);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3827,11 ***</span>
    __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
    __ jcc(Assembler::zero, notVFinal);
  
    // Get receiver klass into rlocals - also a null check
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rlocals, rcx);</span>
  
    Label subtype;
    __ check_klass_subtype(rlocals, rax, rbcp, subtype);
    // If we get here the typecheck failed
    recvKlass = rdx;
<span class="line-new-header">--- 3831,12 ---</span>
    __ andl(rlocals, (1 &lt;&lt; ConstantPoolCacheEntry::is_vfinal_shift));
    __ jcc(Assembler::zero, notVFinal);
  
    // Get receiver klass into rlocals - also a null check
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rlocals, rcx, tmp_load_klass);</span>
  
    Label subtype;
    __ check_klass_subtype(rlocals, rax, rbcp, subtype);
    // If we get here the typecheck failed
    recvKlass = rdx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3850,11 ***</span>
    __ bind(notVFinal);
  
    // Get receiver klass into rdx - also a null check
    __ restore_locals();  // restore r14
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rdx, rcx);</span>
  
    Label no_such_method;
  
    // Preserve method for throw_AbstractMethodErrorVerbose.
    __ mov(rcx, rbx);
<span class="line-new-header">--- 3855,11 ---</span>
    __ bind(notVFinal);
  
    // Get receiver klass into rdx - also a null check
    __ restore_locals();  // restore r14
    __ null_check(rcx, oopDesc::klass_offset_in_bytes());
<span class="line-modified">!   __ load_klass(rdx, rcx, tmp_load_klass);</span>
  
    Label no_such_method;
  
    // Preserve method for throw_AbstractMethodErrorVerbose.
    __ mov(rcx, rbx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4111,11 ***</span>
      }
  #ifdef _LP64
      __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)
      __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops
  #endif
<span class="line-modified">!     __ store_klass(rax, rcx);  // klass</span>
  
      {
        SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);
        // Trigger dtrace event for fastpath
        __ push(atos);
<span class="line-new-header">--- 4116,12 ---</span>
      }
  #ifdef _LP64
      __ xorl(rsi, rsi); // use zero reg to clear memory (shorter code)
      __ store_klass_gap(rax, rsi);  // zero klass gap for compressed oops
  #endif
<span class="line-modified">!     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+     __ store_klass(rax, rcx, tmp_store_klass);  // klass</span>
  
      {
        SkipIfEqual skip_if(_masm, &amp;DTraceAllocProbes, 0);
        // Trigger dtrace event for fastpath
        __ push(atos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4205,11 ***</span>
    __ bind(quicked);
    __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
<span class="line-modified">!   __ load_klass(rbx, rdx);</span>
  
    // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
    // Superklass in rax.  Subklass in rbx.
    __ gen_subtype_check(rbx, ok_is_subtype);
  
<span class="line-new-header">--- 4211,12 ---</span>
    __ bind(quicked);
    __ mov(rdx, rax); // Save object in rdx; rax needed for subtype check
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rbx, rdx, tmp_load_klass);</span>
  
    // Generate subtype check.  Blows rcx, rdi.  Object in rdx.
    // Superklass in rax.  Subklass in rbx.
    __ gen_subtype_check(rbx, ok_is_subtype);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4262,16 ***</span>
    __ get_vm_result_2(rax, r15_thread);
  #endif
  
    __ pop_ptr(rdx); // restore receiver
    __ verify_oop(rdx);
<span class="line-modified">!   __ load_klass(rdx, rdx);</span>
    __ jmpb(resolved);
  
    // Get superklass in rax and subklass in rdx
    __ bind(quicked);
<span class="line-modified">!   __ load_klass(rdx, rax);</span>
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
  
    // Generate subtype check.  Blows rcx, rdi
<span class="line-new-header">--- 4269,17 ---</span>
    __ get_vm_result_2(rax, r15_thread);
  #endif
  
    __ pop_ptr(rdx); // restore receiver
    __ verify_oop(rdx);
<span class="line-modified">!   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">+   __ load_klass(rdx, rdx, tmp_load_klass);</span>
    __ jmpb(resolved);
  
    // Get superklass in rax and subklass in rdx
    __ bind(quicked);
<span class="line-modified">!   __ load_klass(rdx, rax, tmp_load_klass);</span>
    __ load_resolved_klass_at_index(rax, rcx, rbx);
  
    __ bind(resolved);
  
    // Generate subtype check.  Blows rcx, rdi
</pre>
<center><a href="stubGenerator_x86_64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vtableStubs_x86_32.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
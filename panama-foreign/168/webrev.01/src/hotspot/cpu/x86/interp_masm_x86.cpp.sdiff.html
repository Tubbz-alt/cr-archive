<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/interp_masm_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globalDefinitions_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Implementation of InterpreterMacroAssembler
  45 
  46 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  47   assert(entry, &quot;Entry must have been generated by now&quot;);
  48   jump(RuntimeAddress(entry));
  49 }
  50 
  51 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  52   Label update, next, none;
  53 
  54   interp_verify_oop(obj, atos);
  55 
  56   testptr(obj, obj);
  57   jccb(Assembler::notZero, update);
  58   orptr(mdo_addr, TypeEntries::null_seen);
  59   jmpb(next);
  60 
  61   bind(update);
<span class="line-modified">  62   load_klass(obj, obj);</span>

  63 
  64   xorptr(obj, mdo_addr);
  65   testptr(obj, TypeEntries::type_klass_mask);
  66   jccb(Assembler::zero, next); // klass seen before, nothing to
  67                                // do. The unknown bit may have been
  68                                // set already but no need to check.
  69 
  70   testptr(obj, TypeEntries::type_unknown);
  71   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  72 
  73   cmpptr(mdo_addr, 0);
  74   jccb(Assembler::equal, none);
  75   cmpptr(mdo_addr, TypeEntries::null_seen);
  76   jccb(Assembler::equal, none);
  77   // There is a chance that the checks above (re-reading profiling
  78   // data from memory) fail if another thread has just set the
  79   // profiling to this obj&#39;s klass
  80   xorptr(obj, mdo_addr);
  81   testptr(obj, TypeEntries::type_klass_mask);
  82   jccb(Assembler::zero, next);
</pre>
<hr />
<pre>
1180             lock_reg);
1181   } else {
1182     Label done;
1183 
1184     const Register swap_reg = rax; // Must use rax for cmpxchg instruction
1185     const Register tmp_reg = rbx; // Will be passed to biased_locking_enter to avoid a
1186                                   // problematic case where tmp_reg = no_reg.
1187     const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // Will contain the oop
1188 
1189     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
1190     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
1191     const int mark_offset = lock_offset +
1192                             BasicLock::displaced_header_offset_in_bytes();
1193 
1194     Label slow_case;
1195 
1196     // Load object pointer into obj_reg
1197     movptr(obj_reg, Address(lock_reg, obj_offset));
1198 
1199     if (UseBiasedLocking) {
<span class="line-modified">1200       biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, false, done, &amp;slow_case);</span>

1201     }
1202 
1203     // Load immediate 1 into swap_reg %rax
1204     movl(swap_reg, (int32_t)1);
1205 
1206     // Load (object-&gt;mark() | 1) into swap_reg %rax
1207     orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1208 
1209     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1210     movptr(Address(lock_reg, mark_offset), swap_reg);
1211 
1212     assert(lock_offset == 0,
1213            &quot;displaced header must be first word in BasicObjectLock&quot;);
1214 
1215     lock();
1216     cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1217     if (PrintBiasedLockingStatistics) {
1218       cond_inc32(Assembler::zero,
1219                  ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));
1220     }
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Implementation of InterpreterMacroAssembler
  45 
  46 void InterpreterMacroAssembler::jump_to_entry(address entry) {
  47   assert(entry, &quot;Entry must have been generated by now&quot;);
  48   jump(RuntimeAddress(entry));
  49 }
  50 
  51 void InterpreterMacroAssembler::profile_obj_type(Register obj, const Address&amp; mdo_addr) {
  52   Label update, next, none;
  53 
  54   interp_verify_oop(obj, atos);
  55 
  56   testptr(obj, obj);
  57   jccb(Assembler::notZero, update);
  58   orptr(mdo_addr, TypeEntries::null_seen);
  59   jmpb(next);
  60 
  61   bind(update);
<span class="line-modified">  62   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">  63   load_klass(obj, obj, tmp_load_klass);</span>
  64 
  65   xorptr(obj, mdo_addr);
  66   testptr(obj, TypeEntries::type_klass_mask);
  67   jccb(Assembler::zero, next); // klass seen before, nothing to
  68                                // do. The unknown bit may have been
  69                                // set already but no need to check.
  70 
  71   testptr(obj, TypeEntries::type_unknown);
  72   jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
  73 
  74   cmpptr(mdo_addr, 0);
  75   jccb(Assembler::equal, none);
  76   cmpptr(mdo_addr, TypeEntries::null_seen);
  77   jccb(Assembler::equal, none);
  78   // There is a chance that the checks above (re-reading profiling
  79   // data from memory) fail if another thread has just set the
  80   // profiling to this obj&#39;s klass
  81   xorptr(obj, mdo_addr);
  82   testptr(obj, TypeEntries::type_klass_mask);
  83   jccb(Assembler::zero, next);
</pre>
<hr />
<pre>
1181             lock_reg);
1182   } else {
1183     Label done;
1184 
1185     const Register swap_reg = rax; // Must use rax for cmpxchg instruction
1186     const Register tmp_reg = rbx; // Will be passed to biased_locking_enter to avoid a
1187                                   // problematic case where tmp_reg = no_reg.
1188     const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); // Will contain the oop
1189 
1190     const int obj_offset = BasicObjectLock::obj_offset_in_bytes();
1191     const int lock_offset = BasicObjectLock::lock_offset_in_bytes ();
1192     const int mark_offset = lock_offset +
1193                             BasicLock::displaced_header_offset_in_bytes();
1194 
1195     Label slow_case;
1196 
1197     // Load object pointer into obj_reg
1198     movptr(obj_reg, Address(lock_reg, obj_offset));
1199 
1200     if (UseBiasedLocking) {
<span class="line-modified">1201       Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">1202       biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &amp;slow_case);</span>
1203     }
1204 
1205     // Load immediate 1 into swap_reg %rax
1206     movl(swap_reg, (int32_t)1);
1207 
1208     // Load (object-&gt;mark() | 1) into swap_reg %rax
1209     orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1210 
1211     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
1212     movptr(Address(lock_reg, mark_offset), swap_reg);
1213 
1214     assert(lock_offset == 0,
1215            &quot;displaced header must be first word in BasicObjectLock&quot;);
1216 
1217     lock();
1218     cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1219     if (PrintBiasedLockingStatistics) {
1220       cond_inc32(Assembler::zero,
1221                  ExternalAddress((address) BiasedLocking::fast_path_entry_count_addr()));
1222     }
</pre>
</td>
</tr>
</table>
<center><a href="globalDefinitions_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
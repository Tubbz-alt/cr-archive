<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/sharedRuntime_x86_32.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2092 
2093   // Lock a synchronized method
2094   if (method-&gt;is_synchronized()) {
2095     assert(!is_critical_native, &quot;unhandled&quot;);
2096 
2097 
2098     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2099 
2100     // Get the handle (the 2nd argument)
2101     __ movptr(oop_handle_reg, Address(rsp, wordSize));
2102 
2103     // Get address of the box
2104 
2105     __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));
2106 
2107     // Load the oop from the handle
2108     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2109 
2110     if (UseBiasedLocking) {
2111       // Note that oop_handle_reg is trashed during this call
<span class="line-modified">2112       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, false, lock_done, &amp;slow_path_lock);</span>
2113     }
2114 
2115     // Load immediate 1 into swap_reg %rax,
2116     __ movptr(swap_reg, 1);
2117 
2118     // Load (object-&gt;mark() | 1) into swap_reg %rax,
2119     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2120 
2121     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2122     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2123 
2124     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2125     // *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)
2126     __ lock();
2127     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2128     __ jcc(Assembler::equal, lock_done);
2129 
2130     // Test if the oopMark is an obvious stack pointer, i.e.,
2131     //  1) (mark &amp; 3) == 0, and
2132     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
</pre>
</td>
<td>
<hr />
<pre>
2092 
2093   // Lock a synchronized method
2094   if (method-&gt;is_synchronized()) {
2095     assert(!is_critical_native, &quot;unhandled&quot;);
2096 
2097 
2098     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2099 
2100     // Get the handle (the 2nd argument)
2101     __ movptr(oop_handle_reg, Address(rsp, wordSize));
2102 
2103     // Get address of the box
2104 
2105     __ lea(lock_reg, Address(rbp, lock_slot_rbp_offset));
2106 
2107     // Load the oop from the handle
2108     __ movptr(obj_reg, Address(oop_handle_reg, 0));
2109 
2110     if (UseBiasedLocking) {
2111       // Note that oop_handle_reg is trashed during this call
<span class="line-modified">2112       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, oop_handle_reg, noreg, false, lock_done, &amp;slow_path_lock);</span>
2113     }
2114 
2115     // Load immediate 1 into swap_reg %rax,
2116     __ movptr(swap_reg, 1);
2117 
2118     // Load (object-&gt;mark() | 1) into swap_reg %rax,
2119     __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2120 
2121     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2122     __ movptr(Address(lock_reg, mark_word_offset), swap_reg);
2123 
2124     // src -&gt; dest iff dest == rax, else rax, &lt;- dest
2125     // *obj_reg = lock_reg iff *obj_reg == rax, else rax, = *(obj_reg)
2126     __ lock();
2127     __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2128     __ jcc(Assembler::equal, lock_done);
2129 
2130     // Test if the oopMark is an obvious stack pointer, i.e.,
2131     //  1) (mark &amp; 3) == 0, and
2132     //  2) rsp &lt;= mark &lt; mark + os::pagesize()
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
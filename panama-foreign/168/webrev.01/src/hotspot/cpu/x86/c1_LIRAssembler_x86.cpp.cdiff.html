<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_FrameMap_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1183,10 ***</span>
<span class="line-new-header">--- 1183,11 ---</span>
    assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
    assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
  
    LIR_Address* addr = src-&gt;as_address_ptr();
    Address from_addr = as_Address(addr);
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
  
    if (addr-&gt;base()-&gt;type() == T_OBJECT) {
      __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1368,11 ***</span>
        __ verify_oop(dest-&gt;as_register());
      }
    } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ decode_klass_not_null(dest-&gt;as_register());</span>
      }
  #endif
    }
  }
  
<span class="line-new-header">--- 1369,11 ---</span>
        __ verify_oop(dest-&gt;as_register());
      }
    } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ decode_klass_not_null(dest-&gt;as_register(), tmp_load_klass);</span>
      }
  #endif
    }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1696,10 ***</span>
<span class="line-new-header">--- 1697,11 ---</span>
    Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
    Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
    Register dst = op-&gt;result_opr()-&gt;as_register();
    ciKlass* k = op-&gt;klass();
    Register Rtmp1 = noreg;
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
  
    // check if it needs to be profiled
    ciMethodData* md = NULL;
    ciProfileData* data = NULL;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1759,11 ***</span>
    if (op-&gt;fast_check()) {
      // get object class
      // not a safepoint as obj null check happens earlier
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ load_klass(Rtmp1, obj);</span>
        __ cmpptr(k_RInfo, Rtmp1);
      } else {
        __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
      }
  #else
<span class="line-new-header">--- 1761,11 ---</span>
    if (op-&gt;fast_check()) {
      // get object class
      // not a safepoint as obj null check happens earlier
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ load_klass(Rtmp1, obj, tmp_load_klass);</span>
        __ cmpptr(k_RInfo, Rtmp1);
      } else {
        __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
      }
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1776,11 ***</span>
      __ jcc(Assembler::notEqual, *failure_target);
      // successful cast, fall through to profile or jump
    } else {
      // get object class
      // not a safepoint as obj null check happens earlier
<span class="line-modified">!     __ load_klass(klass_RInfo, obj);</span>
      if (k-&gt;is_loaded()) {
        // See if we get an immediate positive hit
  #ifdef _LP64
        __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
  #else
<span class="line-new-header">--- 1778,11 ---</span>
      __ jcc(Assembler::notEqual, *failure_target);
      // successful cast, fall through to profile or jump
    } else {
      // get object class
      // not a safepoint as obj null check happens earlier
<span class="line-modified">!     __ load_klass(klass_RInfo, obj, tmp_load_klass);</span>
      if (k-&gt;is_loaded()) {
        // See if we get an immediate positive hit
  #ifdef _LP64
        __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1831,11 ***</span>
    }
    if (op-&gt;should_profile()) {
      Register mdo  = klass_RInfo, recv = k_RInfo;
      __ bind(profile_cast_success);
      __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-modified">!     __ load_klass(recv, obj);</span>
      type_profile_helper(mdo, md, data, recv, success);
      __ jmp(*success);
  
      __ bind(profile_cast_failure);
      __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-new-header">--- 1833,11 ---</span>
    }
    if (op-&gt;should_profile()) {
      Register mdo  = klass_RInfo, recv = k_RInfo;
      __ bind(profile_cast_success);
      __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-modified">!     __ load_klass(recv, obj, tmp_load_klass);</span>
      type_profile_helper(mdo, md, data, recv, success);
      __ jmp(*success);
  
      __ bind(profile_cast_failure);
      __ mov_metadata(mdo, md-&gt;constant_encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1846,10 ***</span>
<span class="line-new-header">--- 1848,11 ---</span>
    __ jmp(*success);
  }
  
  
  void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
    LIR_Code code = op-&gt;code();
    if (code == lir_store_check) {
      Register value = op-&gt;object()-&gt;as_register();
      Register array = op-&gt;array()-&gt;as_register();
      Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1891,12 ***</span>
      } else {
        __ jcc(Assembler::equal, done);
      }
  
      add_debug_info_for_null_check_here(op-&gt;info_for_exception());
<span class="line-modified">!     __ load_klass(k_RInfo, array);</span>
<span class="line-modified">!     __ load_klass(klass_RInfo, value);</span>
  
      // get instance klass (it&#39;s already uncompressed)
      __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
      // perform the fast part of the checking logic
      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
<span class="line-new-header">--- 1894,12 ---</span>
      } else {
        __ jcc(Assembler::equal, done);
      }
  
      add_debug_info_for_null_check_here(op-&gt;info_for_exception());
<span class="line-modified">!     __ load_klass(k_RInfo, array, tmp_load_klass);</span>
<span class="line-modified">!     __ load_klass(klass_RInfo, value, tmp_load_klass);</span>
  
      // get instance klass (it&#39;s already uncompressed)
      __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
      // perform the fast part of the checking logic
      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1913,11 ***</span>
  
      if (op-&gt;should_profile()) {
        Register mdo  = klass_RInfo, recv = k_RInfo;
        __ bind(profile_cast_success);
        __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-modified">!       __ load_klass(recv, value);</span>
        type_profile_helper(mdo, md, data, recv, &amp;done);
        __ jmpb(done);
  
        __ bind(profile_cast_failure);
        __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-new-header">--- 1916,11 ---</span>
  
      if (op-&gt;should_profile()) {
        Register mdo  = klass_RInfo, recv = k_RInfo;
        __ bind(profile_cast_success);
        __ mov_metadata(mdo, md-&gt;constant_encoding());
<span class="line-modified">!       __ load_klass(recv, value, tmp_load_klass);</span>
        type_profile_helper(mdo, md, data, recv, &amp;done);
        __ jmpb(done);
  
        __ bind(profile_cast_failure);
        __ mov_metadata(mdo, md-&gt;constant_encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3105,10 ***</span>
<span class="line-new-header">--- 3108,11 ---</span>
    Register dst = op-&gt;dst()-&gt;as_register();
    Register src_pos = op-&gt;src_pos()-&gt;as_register();
    Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
    Register length  = op-&gt;length()-&gt;as_register();
    Register tmp = op-&gt;tmp()-&gt;as_register();
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
  
    __ resolve(ACCESS_READ, src);
    __ resolve(ACCESS_WRITE, dst);
  
    CodeStub* stub = op-&gt;stub();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3252,17 ***</span>
    // If the compiler was not able to prove that exact type of the source or the destination
    // of the arraycopy is an array type, check at runtime if the source or the destination is
    // an instance type.
    if (flags &amp; LIR_OpArrayCopy::type_check) {
      if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<span class="line-modified">!       __ load_klass(tmp, dst);</span>
        __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
        __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
      }
  
      if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<span class="line-modified">!       __ load_klass(tmp, src);</span>
        __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
        __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
      }
    }
  
<span class="line-new-header">--- 3256,17 ---</span>
    // If the compiler was not able to prove that exact type of the source or the destination
    // of the arraycopy is an array type, check at runtime if the source or the destination is
    // an instance type.
    if (flags &amp; LIR_OpArrayCopy::type_check) {
      if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<span class="line-modified">!       __ load_klass(tmp, dst, tmp_load_klass);</span>
        __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
        __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
      }
  
      if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<span class="line-modified">!       __ load_klass(tmp, src, tmp_load_klass);</span>
        __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
        __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3315,12 ***</span>
        Label cont, slow;
  
        __ push(src);
        __ push(dst);
  
<span class="line-modified">!       __ load_klass(src, src);</span>
<span class="line-modified">!       __ load_klass(dst, dst);</span>
  
        __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
  
        __ push(src);
        __ push(dst);
<span class="line-new-header">--- 3319,12 ---</span>
        Label cont, slow;
  
        __ push(src);
        __ push(dst);
  
<span class="line-modified">!       __ load_klass(src, src, tmp_load_klass);</span>
<span class="line-modified">!       __ load_klass(dst, dst, tmp_load_klass);</span>
  
        __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
  
        __ push(src);
        __ push(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3344,13 ***</span>
          if ((flags &amp; mask) != mask) {
            // Check that at least both of them object arrays.
            assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
  
            if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<span class="line-modified">!             __ load_klass(tmp, src);</span>
            } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<span class="line-modified">!             __ load_klass(tmp, dst);</span>
            }
            int lh_offset = in_bytes(Klass::layout_helper_offset());
            Address klass_lh_addr(tmp, lh_offset);
            jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
            __ cmpl(klass_lh_addr, objArray_lh);
<span class="line-new-header">--- 3348,13 ---</span>
          if ((flags &amp; mask) != mask) {
            // Check that at least both of them object arrays.
            assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
  
            if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<span class="line-modified">!             __ load_klass(tmp, src, tmp_load_klass);</span>
            } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<span class="line-modified">!             __ load_klass(tmp, dst, tmp_load_klass);</span>
            }
            int lh_offset = in_bytes(Klass::layout_helper_offset());
            Address klass_lh_addr(tmp, lh_offset);
            jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
            __ cmpl(klass_lh_addr, objArray_lh);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3390,18 ***</span>
          assert_different_registers(c_rarg2, dst);
  
  #ifdef _WIN64
          // Allocate abi space for args but be sure to keep stack aligned
          __ subptr(rsp, 6*wordSize);
<span class="line-modified">!         __ load_klass(c_rarg3, dst);</span>
          __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
          store_parameter(c_rarg3, 4);
          __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
          __ call(RuntimeAddress(copyfunc_addr));
          __ addptr(rsp, 6*wordSize);
  #else
<span class="line-modified">!         __ load_klass(c_rarg4, dst);</span>
          __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
          __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
          __ call(RuntimeAddress(copyfunc_addr));
  #endif
  
<span class="line-new-header">--- 3394,18 ---</span>
          assert_different_registers(c_rarg2, dst);
  
  #ifdef _WIN64
          // Allocate abi space for args but be sure to keep stack aligned
          __ subptr(rsp, 6*wordSize);
<span class="line-modified">!         __ load_klass(c_rarg3, dst, tmp_load_klass);</span>
          __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
          store_parameter(c_rarg3, 4);
          __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
          __ call(RuntimeAddress(copyfunc_addr));
          __ addptr(rsp, 6*wordSize);
  #else
<span class="line-modified">!         __ load_klass(c_rarg4, dst, tmp_load_klass);</span>
          __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
          __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
          __ call(RuntimeAddress(copyfunc_addr));
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3462,11 ***</span>
      // but not necessarily exactly of type default_type.
      Label known_ok, halt;
      __ mov_metadata(tmp, default_type-&gt;constant_encoding());
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ encode_klass_not_null(tmp);</span>
      }
  #endif
  
      if (basic_type != T_OBJECT) {
  
<span class="line-new-header">--- 3466,11 ---</span>
      // but not necessarily exactly of type default_type.
      Label known_ok, halt;
      __ mov_metadata(tmp, default_type-&gt;constant_encoding());
  #ifdef _LP64
      if (UseCompressedClassPointers) {
<span class="line-modified">!       __ encode_klass_not_null(tmp, rscratch1);</span>
      }
  #endif
  
      if (basic_type != T_OBJECT) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3567,10 ***</span>
<span class="line-new-header">--- 3571,11 ---</span>
  
  void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
    ciMethod* method = op-&gt;profiled_method();
    int bci          = op-&gt;profiled_bci();
    ciMethod* callee = op-&gt;profiled_callee();
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
  
    // Update counter for all call types
    ciMethodData* md = method-&gt;method_data_or_null();
    assert(md != NULL, &quot;Sanity&quot;);
    ciProfileData* data = md-&gt;bci_to_data(bci);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3619,11 ***</span>
            __ addptr(data_addr, DataLayout::counter_increment);
            return;
          }
        }
      } else {
<span class="line-modified">!       __ load_klass(recv, recv);</span>
        Label update_done;
        type_profile_helper(mdo, md, data, recv, &amp;update_done);
        // Receiver did not match any saved receiver and there is no empty row for it.
        // Increment total counter to indicate polymorphic case.
        __ addptr(counter_addr, DataLayout::counter_increment);
<span class="line-new-header">--- 3624,11 ---</span>
            __ addptr(data_addr, DataLayout::counter_increment);
            return;
          }
        }
      } else {
<span class="line-modified">!       __ load_klass(recv, recv, tmp_load_klass);</span>
        Label update_done;
        type_profile_helper(mdo, md, data, recv, &amp;update_done);
        // Receiver did not match any saved receiver and there is no empty row for it.
        // Increment total counter to indicate polymorphic case.
        __ addptr(counter_addr, DataLayout::counter_increment);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3637,10 ***</span>
<span class="line-new-header">--- 3642,11 ---</span>
  }
  
  void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
    Register obj = op-&gt;obj()-&gt;as_register();
    Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
<span class="line-added">+   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
    Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
    ciKlass* exact_klass = op-&gt;exact_klass();
    intptr_t current_klass = op-&gt;current_klass();
    bool not_null = op-&gt;not_null();
    bool no_conflict = op-&gt;no_conflict();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3683,11 ***</span>
  
    if (do_update) {
  #ifdef ASSERT
      if (exact_klass != NULL) {
        Label ok;
<span class="line-modified">!       __ load_klass(tmp, tmp);</span>
        __ push(tmp);
        __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
        __ cmpptr(tmp, Address(rsp, 0));
        __ jcc(Assembler::equal, ok);
        __ stop(&quot;exact klass and actual klass differ&quot;);
<span class="line-new-header">--- 3689,11 ---</span>
  
    if (do_update) {
  #ifdef ASSERT
      if (exact_klass != NULL) {
        Label ok;
<span class="line-modified">!       __ load_klass(tmp, tmp, tmp_load_klass);</span>
        __ push(tmp);
        __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
        __ cmpptr(tmp, Address(rsp, 0));
        __ jcc(Assembler::equal, ok);
        __ stop(&quot;exact klass and actual klass differ&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3698,11 ***</span>
      if (!no_conflict) {
        if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
          if (exact_klass != NULL) {
            __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
          } else {
<span class="line-modified">!           __ load_klass(tmp, tmp);</span>
          }
  
          __ xorptr(tmp, mdo_addr);
          __ testptr(tmp, TypeEntries::type_klass_mask);
          // klass seen before, nothing to do. The unknown bit may have been
<span class="line-new-header">--- 3704,11 ---</span>
      if (!no_conflict) {
        if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
          if (exact_klass != NULL) {
            __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
          } else {
<span class="line-modified">!           __ load_klass(tmp, tmp, tmp_load_klass);</span>
          }
  
          __ xorptr(tmp, mdo_addr);
          __ testptr(tmp, TypeEntries::type_klass_mask);
          // klass seen before, nothing to do. The unknown bit may have been
</pre>
<center><a href="c1_FrameMap_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/stubGenerator_x86_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1081,15 +1081,12 @@</span>
      __ andptr(c_rarg2, c_rarg3);
      __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());
      __ cmpptr(c_rarg2, c_rarg3);
      __ jcc(Assembler::notZero, error);
  
<span class="udiff-line-removed">-     // set r12 to heapbase for load_klass()</span>
<span class="udiff-line-removed">-     __ reinit_heapbase();</span>
<span class="udiff-line-removed">- </span>
      // make sure klass is &#39;reasonable&#39;, which is not zero.
<span class="udiff-line-modified-removed">-     __ load_klass(rax, rax);  // get klass</span>
<span class="udiff-line-modified-added">+     __ load_klass(rax, rax, rscratch1);  // get klass</span>
      __ testptr(rax, rax);
      __ jcc(Assembler::zero, error); // if klass is NULL it is broken
  
      // return if everything seems ok
      __ bind(exit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2523,11 +2520,11 @@</span>
      __ BIND(L_load_element);
      __ load_heap_oop(rax_oop, from_element_addr, noreg, noreg, AS_RAW); // load the oop
      __ testptr(rax_oop, rax_oop);
      __ jcc(Assembler::zero, L_store_element);
  
<span class="udiff-line-modified-removed">-     __ load_klass(r11_klass, rax_oop);// query the object klass</span>
<span class="udiff-line-modified-added">+     __ load_klass(r11_klass, rax_oop, rscratch1);// query the object klass</span>
      generate_type_check(r11_klass, ckoff, ckval, L_store_element);
      // ======== end loop ========
  
      // It was a real error; we must depend on the caller to finish the job.
      // Register rdx = -1 * number of *remaining* oops, r14 = *total* oops.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2687,12 +2684,14 @@</span>
      const Register src_pos    = c_rarg1;  // source position
      const Register dst        = c_rarg2;  // destination array oop
      const Register dst_pos    = c_rarg3;  // destination position
  #ifndef _WIN64
      const Register length     = c_rarg4;
<span class="udiff-line-added">+     const Register rklass_tmp = r9;  // load_klass</span>
  #else
      const Address  length(rsp, 6 * wordSize);  // elements count is on stack on Win64
<span class="udiff-line-added">+     const Register rklass_tmp = rdi;  // load_klass</span>
  #endif
  
      { int modulus = CodeEntryAlignment;
        int target  = modulus - 5; // 5 = sizeof jmp(L_failed)
        int advance = target - (__ offset() % modulus);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2761,22 +2760,22 @@</span>
      //  if (length &lt; 0) return -1;
      __ movl(r11_length, length);        // length (elements count, 32-bits value)
      __ testl(r11_length, r11_length);
      __ jccb(Assembler::negative, L_failed_0);
  
<span class="udiff-line-modified-removed">-     __ load_klass(r10_src_klass, src);</span>
<span class="udiff-line-modified-added">+     __ load_klass(r10_src_klass, src, rklass_tmp);</span>
  #ifdef ASSERT
      //  assert(src-&gt;klass() != NULL);
      {
        BLOCK_COMMENT(&quot;assert klasses not null {&quot;);
        Label L1, L2;
        __ testptr(r10_src_klass, r10_src_klass);
        __ jcc(Assembler::notZero, L2);   // it is broken if klass is NULL
        __ bind(L1);
        __ stop(&quot;broken null klass&quot;);
        __ bind(L2);
<span class="udiff-line-modified-removed">-       __ load_klass(rax, dst);</span>
<span class="udiff-line-modified-added">+       __ load_klass(rax, dst, rklass_tmp);</span>
        __ cmpq(rax, 0);
        __ jcc(Assembler::equal, L1);     // this would be broken also
        BLOCK_COMMENT(&quot;} assert klasses not null done&quot;);
      }
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2795,11 +2794,11 @@</span>
      const jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
      __ cmpl(Address(r10_src_klass, lh_offset), objArray_lh);
      __ jcc(Assembler::equal, L_objArray);
  
      //  if (src-&gt;klass() != dst-&gt;klass()) return -1;
<span class="udiff-line-modified-removed">-     __ load_klass(rax, dst);</span>
<span class="udiff-line-modified-added">+     __ load_klass(rax, dst, rklass_tmp);</span>
      __ cmpq(r10_src_klass, rax);
      __ jcc(Assembler::notEqual, L_failed);
  
      const Register rax_lh = rax;  // layout helper
      __ movl(rax_lh, Address(r10_src_klass, lh_offset));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2894,11 +2893,11 @@</span>
    __ BIND(L_objArray);
      // live at this point:  r10_src_klass, r11_length, src[_pos], dst[_pos]
  
      Label L_plain_copy, L_checkcast_copy;
      //  test array classes for subtyping
<span class="udiff-line-modified-removed">-     __ load_klass(rax, dst);</span>
<span class="udiff-line-modified-added">+     __ load_klass(rax, dst, rklass_tmp);</span>
      __ cmpq(r10_src_klass, rax); // usual case is exact equality
      __ jcc(Assembler::notEqual, L_checkcast_copy);
  
      // Identically typed arrays can be copied without element-wise checks.
      arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2922,11 +2921,11 @@</span>
        // It is safe to examine both src.length and dst.length.
        arraycopy_range_checks(src, src_pos, dst, dst_pos, r11_length,
                               rax, L_failed);
  
        const Register r11_dst_klass = r11;
<span class="udiff-line-modified-removed">-       __ load_klass(r11_dst_klass, dst); // reload</span>
<span class="udiff-line-modified-added">+       __ load_klass(r11_dst_klass, dst, rklass_tmp); // reload</span>
  
        // Marshal the base address arguments now, freeing registers.
        __ lea(from, Address(src, src_pos, TIMES_OOP,
                     arrayOopDesc::base_offset_in_bytes(T_OBJECT)));
        __ lea(to,   Address(dst, dst_pos, TIMES_OOP,
</pre>
<center><a href="sharedRuntime_x86_64.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
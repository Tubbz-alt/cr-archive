<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -313,12 +313,12 @@</span>
    void load_method_holder_cld(Register rresult, Register rmethod);
  
    void load_method_holder(Register holder, Register method);
  
    // oop manipulations
<span class="udiff-line-modified-removed">-   void load_klass(Register dst, Register src);</span>
<span class="udiff-line-modified-removed">-   void store_klass(Register dst, Register src);</span>
<span class="udiff-line-modified-added">+   void load_klass(Register dst, Register src, Register tmp);</span>
<span class="udiff-line-modified-added">+   void store_klass(Register dst, Register src, Register tmp);</span>
  
    void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
                        Register tmp1, Register thread_tmp);
    void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
                         Register tmp1, Register tmp2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,11 +336,11 @@</span>
  
    // Used for storing NULL. All other oop constants should be
    // stored using routines that take a jobject.
    void store_heap_oop_null(Address dst);
  
<span class="udiff-line-modified-removed">-   void load_prototype_header(Register dst, Register src);</span>
<span class="udiff-line-modified-added">+   void load_prototype_header(Register dst, Register src, Register tmp);</span>
  
  #ifdef _LP64
    void store_klass_gap(Register dst, Register src);
  
    // This dummy is to prevent a call to store_heap_oop from
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -359,23 +359,19 @@</span>
    void set_narrow_oop(Register dst, jobject obj);
    void set_narrow_oop(Address dst, jobject obj);
    void cmp_narrow_oop(Register dst, jobject obj);
    void cmp_narrow_oop(Address dst, jobject obj);
  
<span class="udiff-line-modified-removed">-   void encode_klass_not_null(Register r);</span>
<span class="udiff-line-modified-removed">-   void decode_klass_not_null(Register r);</span>
<span class="udiff-line-modified-removed">-   void encode_klass_not_null(Register dst, Register src);</span>
<span class="udiff-line-modified-removed">-   void decode_klass_not_null(Register dst, Register src);</span>
<span class="udiff-line-modified-added">+   void encode_klass_not_null(Register r, Register tmp);</span>
<span class="udiff-line-modified-added">+   void decode_klass_not_null(Register r, Register tmp);</span>
<span class="udiff-line-modified-added">+   void encode_and_move_klass_not_null(Register dst, Register src);</span>
<span class="udiff-line-modified-added">+   void decode_and_move_klass_not_null(Register dst, Register src);</span>
    void set_narrow_klass(Register dst, Klass* k);
    void set_narrow_klass(Address dst, Klass* k);
    void cmp_narrow_klass(Register dst, Klass* k);
    void cmp_narrow_klass(Address dst, Klass* k);
  
<span class="udiff-line-removed">-   // Returns the byte size of the instructions generated by decode_klass_not_null()</span>
<span class="udiff-line-removed">-   // when compressed klass pointers are being used.</span>
<span class="udiff-line-removed">-   static int instr_size_for_decode_klass_not_null();</span>
<span class="udiff-line-removed">- </span>
    // if heap base register is used - reinit it with the correct value
    void reinit_heapbase();
  
    DEBUG_ONLY(void verify_heapbase(const char* msg);)
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,11 +665,11 @@</span>
    // check info (currently consumed only by C1). If
    // swap_reg_contains_mark is true then returns -1 as it is assumed
    // the calling code has already passed any potential faults.
    int biased_locking_enter(Register lock_reg, Register obj_reg,
                             Register swap_reg, Register tmp_reg,
<span class="udiff-line-modified-removed">-                            bool swap_reg_contains_mark,</span>
<span class="udiff-line-modified-added">+                            Register tmp_reg2, bool swap_reg_contains_mark,</span>
                             Label&amp; done, Label* slow_case = NULL,
                             BiasedLockingCounters* counters = NULL);
    void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
  
    Condition negate_condition(Condition cond);
</pre>
<center><a href="macroAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
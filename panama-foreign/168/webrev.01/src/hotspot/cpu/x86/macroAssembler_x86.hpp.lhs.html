<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
  31 
  32 // MacroAssembler extends Assembler by frequently used macros.
  33 //
  34 // Instructions for which a &#39;better&#39; code sequence exists depending
  35 // on arguments should also go in here.
  36 
  37 class MacroAssembler: public Assembler {
  38   friend class LIR_Assembler;
  39   friend class Runtime1;      // as_Address()
  40 
  41  public:
  42   // Support for VM calls
  43   //
  44   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  45   // may customize this version by overriding it for its purposes (e.g., to save/restore
  46   // additional registers when doing a VM call).
  47 
  48   virtual void call_VM_leaf_base(
  49     address entry_point,               // the entry point
  50     int     number_of_arguments        // the number of arguments to pop after the call
  51   );
  52 
  53  protected:
  54   // This is the base routine called by the different versions of call_VM. The interpreter
  55   // may customize this version by overriding it for its purposes (e.g., to save/restore
  56   // additional registers when doing a VM call).
  57   //
  58   // If no java_thread register is specified (noreg) than rdi will be used instead. call_VM_base
  59   // returns the register which contains the thread upon return. If a thread register has been
  60   // specified, the return value will correspond to that register. If no last_java_sp is specified
  61   // (noreg) than rsp will be used instead.
  62   virtual void call_VM_base(           // returns the register containing the thread upon return
  63     Register oop_result,               // where an oop-result ends up if any; use noreg otherwise
  64     Register java_thread,              // the thread if computed before     ; use noreg otherwise
  65     Register last_java_sp,             // to set up last_Java_frame in stubs; use noreg otherwise
  66     address  entry_point,              // the entry point
  67     int      number_of_arguments,      // the number of arguments (w/o thread) to pop after the call
  68     bool     check_exceptions          // whether to check for pending exceptions after return
  69   );
  70 
  71   void call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions = true);
  72 
  73   // helpers for FPU flag access
  74   // tmp is a temporary register, if none is available use noreg
  75   void save_rax   (Register tmp);
  76   void restore_rax(Register tmp);
  77 
  78  public:
  79   MacroAssembler(CodeBuffer* code) : Assembler(code) {}
  80 
  81  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  82  // The implementation is only non-empty for the InterpreterMacroAssembler,
  83  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  84  virtual void check_and_handle_popframe(Register java_thread);
  85  virtual void check_and_handle_earlyret(Register java_thread);
  86 
  87   Address as_Address(AddressLiteral adr);
  88   Address as_Address(ArrayAddress adr);
  89 
  90   // Support for NULL-checks
  91   //
  92   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  93   // If the accessed location is M[reg + offset] and the offset is known, provide the
  94   // offset. No explicit code generation is needed if the offset is within a certain
  95   // range (0 &lt;= offset &lt;= page_size).
  96 
  97   void null_check(Register reg, int offset = -1);
  98   static bool needs_explicit_null_check(intptr_t offset);
  99   static bool uses_implicit_null_check(void* address);
 100 
 101   // Required platform-specific helpers for Label::patch_instructions.
 102   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 103   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 104     unsigned char op = branch[0];
 105     assert(op == 0xE8 /* call */ ||
 106         op == 0xE9 /* jmp */ ||
 107         op == 0xEB /* short jmp */ ||
 108         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 109         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 110         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 111         &quot;Invalid opcode at patch point&quot;);
 112 
 113     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 114       // short offset operators (jmp and jcc)
 115       char* disp = (char*) &amp;branch[1];
 116       int imm8 = target - (address) &amp;disp[1];
 117       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 118                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 119       *disp = imm8;
 120     } else {
 121       int* disp = (int*) &amp;branch[(op == 0x0F || op == 0xC7)? 2: 1];
 122       int imm32 = target - (address) &amp;disp[1];
 123       *disp = imm32;
 124     }
 125   }
 126 
 127   // The following 4 methods return the offset of the appropriate move instruction
 128 
 129   // Support for fast byte/short loading with zero extension (depending on particular CPU)
 130   int load_unsigned_byte(Register dst, Address src);
 131   int load_unsigned_short(Register dst, Address src);
 132 
 133   // Support for fast byte/short loading with sign extension (depending on particular CPU)
 134   int load_signed_byte(Register dst, Address src);
 135   int load_signed_short(Register dst, Address src);
 136 
 137   // Support for sign-extension (hi:lo = extend_sign(lo))
 138   void extend_sign(Register hi, Register lo);
 139 
 140   // Load and store values by size and signed-ness
 141   void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);
 142   void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);
 143 
 144   // Support for inc/dec with optimal instruction selection depending on value
 145 
 146   void increment(Register reg, int value = 1) { LP64_ONLY(incrementq(reg, value)) NOT_LP64(incrementl(reg, value)) ; }
 147   void decrement(Register reg, int value = 1) { LP64_ONLY(decrementq(reg, value)) NOT_LP64(decrementl(reg, value)) ; }
 148 
 149   void decrementl(Address dst, int value = 1);
 150   void decrementl(Register reg, int value = 1);
 151 
 152   void decrementq(Register reg, int value = 1);
 153   void decrementq(Address dst, int value = 1);
 154 
 155   void incrementl(Address dst, int value = 1);
 156   void incrementl(Register reg, int value = 1);
 157 
 158   void incrementq(Register reg, int value = 1);
 159   void incrementq(Address dst, int value = 1);
 160 
 161   // Support optimal SSE move instructions.
 162   void movflt(XMMRegister dst, XMMRegister src) {
 163     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 164     if (UseXmmRegToRegMoveAll) { movaps(dst, src); return; }
 165     else                       { movss (dst, src); return; }
 166   }
 167   void movflt(XMMRegister dst, Address src) { movss(dst, src); }
 168   void movflt(XMMRegister dst, AddressLiteral src);
 169   void movflt(Address dst, XMMRegister src) { movss(dst, src); }
 170 
 171   void movdbl(XMMRegister dst, XMMRegister src) {
 172     if (dst-&gt; encoding() == src-&gt;encoding()) return;
 173     if (UseXmmRegToRegMoveAll) { movapd(dst, src); return; }
 174     else                       { movsd (dst, src); return; }
 175   }
 176 
 177   void movdbl(XMMRegister dst, AddressLiteral src);
 178 
 179   void movdbl(XMMRegister dst, Address src) {
 180     if (UseXmmLoadAndClearUpper) { movsd (dst, src); return; }
 181     else                         { movlpd(dst, src); return; }
 182   }
 183   void movdbl(Address dst, XMMRegister src) { movsd(dst, src); }
 184 
 185   void incrementl(AddressLiteral dst);
 186   void incrementl(ArrayAddress dst);
 187 
 188   void incrementq(AddressLiteral dst);
 189 
 190   // Alignment
 191   void align(int modulus);
 192   void align(int modulus, int target);
 193 
 194   // A 5 byte nop that is safe for patching (see patch_verified_entry)
 195   void fat_nop();
 196 
 197   // Stack frame creation/removal
 198   void enter();
 199   void leave();
 200 
 201   // Support for getting the JavaThread pointer (i.e.; a reference to thread-local information)
 202   // The pointer will be loaded into the thread register.
 203   void get_thread(Register thread);
 204 
 205 
 206   // Support for VM calls
 207   //
 208   // It is imperative that all calls into the VM are handled via the call_VM macros.
 209   // They make sure that the stack linkage is setup correctly. call_VM&#39;s correspond
 210   // to ENTRY/ENTRY_X entry points while call_VM_leaf&#39;s correspond to LEAF entry points.
 211 
 212 
 213   void call_VM(Register oop_result,
 214                address entry_point,
 215                bool check_exceptions = true);
 216   void call_VM(Register oop_result,
 217                address entry_point,
 218                Register arg_1,
 219                bool check_exceptions = true);
 220   void call_VM(Register oop_result,
 221                address entry_point,
 222                Register arg_1, Register arg_2,
 223                bool check_exceptions = true);
 224   void call_VM(Register oop_result,
 225                address entry_point,
 226                Register arg_1, Register arg_2, Register arg_3,
 227                bool check_exceptions = true);
 228 
 229   // Overloadings with last_Java_sp
 230   void call_VM(Register oop_result,
 231                Register last_java_sp,
 232                address entry_point,
 233                int number_of_arguments = 0,
 234                bool check_exceptions = true);
 235   void call_VM(Register oop_result,
 236                Register last_java_sp,
 237                address entry_point,
 238                Register arg_1, bool
 239                check_exceptions = true);
 240   void call_VM(Register oop_result,
 241                Register last_java_sp,
 242                address entry_point,
 243                Register arg_1, Register arg_2,
 244                bool check_exceptions = true);
 245   void call_VM(Register oop_result,
 246                Register last_java_sp,
 247                address entry_point,
 248                Register arg_1, Register arg_2, Register arg_3,
 249                bool check_exceptions = true);
 250 
 251   void get_vm_result  (Register oop_result, Register thread);
 252   void get_vm_result_2(Register metadata_result, Register thread);
 253 
 254   // These always tightly bind to MacroAssembler::call_VM_base
 255   // bypassing the virtual implementation
 256   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments = 0, bool check_exceptions = true);
 257   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions = true);
 258   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions = true);
 259   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions = true);
 260   void super_call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4, bool check_exceptions = true);
 261 
 262   void call_VM_leaf0(address entry_point);
 263   void call_VM_leaf(address entry_point,
 264                     int number_of_arguments = 0);
 265   void call_VM_leaf(address entry_point,
 266                     Register arg_1);
 267   void call_VM_leaf(address entry_point,
 268                     Register arg_1, Register arg_2);
 269   void call_VM_leaf(address entry_point,
 270                     Register arg_1, Register arg_2, Register arg_3);
 271 
 272   // These always tightly bind to MacroAssembler::call_VM_leaf_base
 273   // bypassing the virtual implementation
 274   void super_call_VM_leaf(address entry_point);
 275   void super_call_VM_leaf(address entry_point, Register arg_1);
 276   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2);
 277   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3);
 278   void super_call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3, Register arg_4);
 279 
 280   // last Java Frame (fills frame anchor)
 281   void set_last_Java_frame(Register thread,
 282                            Register last_java_sp,
 283                            Register last_java_fp,
 284                            address last_java_pc);
 285 
 286   // thread in the default location (r15_thread on 64bit)
 287   void set_last_Java_frame(Register last_java_sp,
 288                            Register last_java_fp,
 289                            address last_java_pc);
 290 
 291   void reset_last_Java_frame(Register thread, bool clear_fp);
 292 
 293   // thread in the default location (r15_thread on 64bit)
 294   void reset_last_Java_frame(bool clear_fp);
 295 
 296   // jobjects
 297   void clear_jweak_tag(Register possibly_jweak);
 298   void resolve_jobject(Register value, Register thread, Register tmp);
 299 
 300   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 301   void c2bool(Register x);
 302 
 303   // C++ bool manipulation
 304 
 305   void movbool(Register dst, Address src);
 306   void movbool(Address dst, bool boolconst);
 307   void movbool(Address dst, Register src);
 308   void testbool(Register dst);
 309 
 310   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 311   void resolve_weak_handle(Register result, Register tmp);
 312   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 313   void load_method_holder_cld(Register rresult, Register rmethod);
 314 
 315   void load_method_holder(Register holder, Register method);
 316 
 317   // oop manipulations
<a name="1" id="anc1"></a><span class="line-modified"> 318   void load_klass(Register dst, Register src);</span>
<span class="line-modified"> 319   void store_klass(Register dst, Register src);</span>
 320 
 321   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 322                       Register tmp1, Register thread_tmp);
 323   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
 324                        Register tmp1, Register tmp2);
 325 
 326   // Resolves obj access. Result is placed in the same register.
 327   // All other registers are preserved.
 328   void resolve(DecoratorSet decorators, Register obj);
 329 
 330   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 331                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 332   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 333                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 334   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
 335                       Register tmp2 = noreg, DecoratorSet decorators = 0);
 336 
 337   // Used for storing NULL. All other oop constants should be
 338   // stored using routines that take a jobject.
 339   void store_heap_oop_null(Address dst);
 340 
<a name="2" id="anc2"></a><span class="line-modified"> 341   void load_prototype_header(Register dst, Register src);</span>
 342 
 343 #ifdef _LP64
 344   void store_klass_gap(Register dst, Register src);
 345 
 346   // This dummy is to prevent a call to store_heap_oop from
 347   // converting a zero (like NULL) into a Register by giving
 348   // the compiler two choices it can&#39;t resolve
 349 
 350   void store_heap_oop(Address dst, void* dummy);
 351 
 352   void encode_heap_oop(Register r);
 353   void decode_heap_oop(Register r);
 354   void encode_heap_oop_not_null(Register r);
 355   void decode_heap_oop_not_null(Register r);
 356   void encode_heap_oop_not_null(Register dst, Register src);
 357   void decode_heap_oop_not_null(Register dst, Register src);
 358 
 359   void set_narrow_oop(Register dst, jobject obj);
 360   void set_narrow_oop(Address dst, jobject obj);
 361   void cmp_narrow_oop(Register dst, jobject obj);
 362   void cmp_narrow_oop(Address dst, jobject obj);
 363 
<a name="3" id="anc3"></a><span class="line-modified"> 364   void encode_klass_not_null(Register r);</span>
<span class="line-modified"> 365   void decode_klass_not_null(Register r);</span>
<span class="line-modified"> 366   void encode_klass_not_null(Register dst, Register src);</span>
<span class="line-modified"> 367   void decode_klass_not_null(Register dst, Register src);</span>
 368   void set_narrow_klass(Register dst, Klass* k);
 369   void set_narrow_klass(Address dst, Klass* k);
 370   void cmp_narrow_klass(Register dst, Klass* k);
 371   void cmp_narrow_klass(Address dst, Klass* k);
 372 
<a name="4" id="anc4"></a><span class="line-removed"> 373   // Returns the byte size of the instructions generated by decode_klass_not_null()</span>
<span class="line-removed"> 374   // when compressed klass pointers are being used.</span>
<span class="line-removed"> 375   static int instr_size_for_decode_klass_not_null();</span>
<span class="line-removed"> 376 </span>
 377   // if heap base register is used - reinit it with the correct value
 378   void reinit_heapbase();
 379 
 380   DEBUG_ONLY(void verify_heapbase(const char* msg);)
 381 
 382 #endif // _LP64
 383 
 384   // Int division/remainder for Java
 385   // (as idivl, but checks for special case as described in JVM spec.)
 386   // returns idivl instruction offset for implicit exception handling
 387   int corrected_idivl(Register reg);
 388 
 389   // Long division/remainder for Java
 390   // (as idivq, but checks for special case as described in JVM spec.)
 391   // returns idivq instruction offset for implicit exception handling
 392   int corrected_idivq(Register reg);
 393 
 394   void int3();
 395 
 396   // Long operation macros for a 32bit cpu
 397   // Long negation for Java
 398   void lneg(Register hi, Register lo);
 399 
 400   // Long multiplication for Java
 401   // (destroys contents of eax, ebx, ecx and edx)
 402   void lmul(int x_rsp_offset, int y_rsp_offset); // rdx:rax = x * y
 403 
 404   // Long shifts for Java
 405   // (semantics as described in JVM spec.)
 406   void lshl(Register hi, Register lo);                               // hi:lo &lt;&lt; (rcx &amp; 0x3f)
 407   void lshr(Register hi, Register lo, bool sign_extension = false);  // hi:lo &gt;&gt; (rcx &amp; 0x3f)
 408 
 409   // Long compare for Java
 410   // (semantics as described in JVM spec.)
 411   void lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo); // x_hi = lcmp(x, y)
 412 
 413 
 414   // misc
 415 
 416   // Sign extension
 417   void sign_extend_short(Register reg);
 418   void sign_extend_byte(Register reg);
 419 
 420   // Division by power of 2, rounding towards 0
 421   void division_with_shift(Register reg, int shift_value);
 422 
 423 #ifndef _LP64
 424   // Compares the top-most stack entries on the FPU stack and sets the eflags as follows:
 425   //
 426   // CF (corresponds to C0) if x &lt; y
 427   // PF (corresponds to C2) if unordered
 428   // ZF (corresponds to C3) if x = y
 429   //
 430   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 431   // tmp is a temporary register, if none is available use noreg (only matters for non-P6 code)
 432   void fcmp(Register tmp);
 433   // Variant of the above which allows y to be further down the stack
 434   // and which only pops x and y if specified. If pop_right is
 435   // specified then pop_left must also be specified.
 436   void fcmp(Register tmp, int index, bool pop_left, bool pop_right);
 437 
 438   // Floating-point comparison for Java
 439   // Compares the top-most stack entries on the FPU stack and stores the result in dst.
 440   // The arguments are in reversed order on the stack (i.e., top of stack is first argument).
 441   // (semantics as described in JVM spec.)
 442   void fcmp2int(Register dst, bool unordered_is_less);
 443   // Variant of the above which allows y to be further down the stack
 444   // and which only pops x and y if specified. If pop_right is
 445   // specified then pop_left must also be specified.
 446   void fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right);
 447 
 448   // Floating-point remainder for Java (ST0 = ST0 fremr ST1, ST1 is empty afterwards)
 449   // tmp is a temporary register, if none is available use noreg
 450   void fremr(Register tmp);
 451 
 452   // only if +VerifyFPU
 453   void verify_FPU(int stack_depth, const char* s = &quot;illegal FPU state&quot;);
 454 #endif // !LP64
 455 
 456   // dst = c = a * b + c
 457   void fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 458   void fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c);
 459 
 460   void vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 461   void vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len);
 462   void vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 463   void vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len);
 464 
 465 
 466   // same as fcmp2int, but using SSE2
 467   void cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 468   void cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less);
 469 
 470   // branch to L if FPU flag C2 is set/not set
 471   // tmp is a temporary register, if none is available use noreg
 472   void jC2 (Register tmp, Label&amp; L);
 473   void jnC2(Register tmp, Label&amp; L);
 474 
 475   // Load float value from &#39;address&#39;. If UseSSE &gt;= 1, the value is loaded into
 476   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 477   void load_float(Address src);
 478 
 479   // Store float value to &#39;address&#39;. If UseSSE &gt;= 1, the value is stored
 480   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 481   void store_float(Address dst);
 482 
 483   // Load double value from &#39;address&#39;. If UseSSE &gt;= 2, the value is loaded into
 484   // register xmm0. Otherwise, the value is loaded onto the FPU stack.
 485   void load_double(Address src);
 486 
 487   // Store double value to &#39;address&#39;. If UseSSE &gt;= 2, the value is stored
 488   // from register xmm0. Otherwise, the value is stored from the FPU stack.
 489   void store_double(Address dst);
 490 
 491 #ifndef _LP64
 492   // Pop ST (ffree &amp; fincstp combined)
 493   void fpop();
 494 
 495   void empty_FPU_stack();
 496 #endif // !_LP64
 497 
 498   void push_IU_state();
 499   void pop_IU_state();
 500 
 501   void push_FPU_state();
 502   void pop_FPU_state();
 503 
 504   void push_CPU_state();
 505   void pop_CPU_state();
 506 
 507   // Round up to a power of two
 508   void round_to(Register reg, int modulus);
 509 
 510   // Callee saved registers handling
 511   void push_callee_saved_registers();
 512   void pop_callee_saved_registers();
 513 
 514   // allocation
 515   void eden_allocate(
 516     Register thread,                   // Current thread
 517     Register obj,                      // result: pointer to object after successful allocation
 518     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 519     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 520     Register t1,                       // temp register
 521     Label&amp;   slow_case                 // continuation point if fast allocation fails
 522   );
 523   void tlab_allocate(
 524     Register thread,                   // Current thread
 525     Register obj,                      // result: pointer to object after successful allocation
 526     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 527     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 528     Register t1,                       // temp register
 529     Register t2,                       // temp register
 530     Label&amp;   slow_case                 // continuation point if fast allocation fails
 531   );
 532   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 533 
 534   // interface method calling
 535   void lookup_interface_method(Register recv_klass,
 536                                Register intf_klass,
 537                                RegisterOrConstant itable_index,
 538                                Register method_result,
 539                                Register scan_temp,
 540                                Label&amp; no_such_interface,
 541                                bool return_method = true);
 542 
 543   // virtual method calling
 544   void lookup_virtual_method(Register recv_klass,
 545                              RegisterOrConstant vtable_index,
 546                              Register method_result);
 547 
 548   // Test sub_klass against super_klass, with fast and slow paths.
 549 
 550   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 551   // One of the three labels can be NULL, meaning take the fall-through.
 552   // If super_check_offset is -1, the value is loaded up from super_klass.
 553   // No registers are killed, except temp_reg.
 554   void check_klass_subtype_fast_path(Register sub_klass,
 555                                      Register super_klass,
 556                                      Register temp_reg,
 557                                      Label* L_success,
 558                                      Label* L_failure,
 559                                      Label* L_slow_path,
 560                 RegisterOrConstant super_check_offset = RegisterOrConstant(-1));
 561 
 562   // The rest of the type check; must be wired to a corresponding fast path.
 563   // It does not repeat the fast path logic, so don&#39;t use it standalone.
 564   // The temp_reg and temp2_reg can be noreg, if no temps are available.
 565   // Updates the sub&#39;s secondary super cache as necessary.
 566   // If set_cond_codes, condition codes will be Z on success, NZ on failure.
 567   void check_klass_subtype_slow_path(Register sub_klass,
 568                                      Register super_klass,
 569                                      Register temp_reg,
 570                                      Register temp2_reg,
 571                                      Label* L_success,
 572                                      Label* L_failure,
 573                                      bool set_cond_codes = false);
 574 
 575   // Simplified, combined version, good for typical uses.
 576   // Falls through on failure.
 577   void check_klass_subtype(Register sub_klass,
 578                            Register super_klass,
 579                            Register temp_reg,
 580                            Label&amp; L_success);
 581 
 582   void clinit_barrier(Register klass,
 583                       Register thread,
 584                       Label* L_fast_path = NULL,
 585                       Label* L_slow_path = NULL);
 586 
 587   // method handles (JSR 292)
 588   Address argument_address(RegisterOrConstant arg_slot, int extra_slot_offset = 0);
 589 
 590   //----
 591   void set_word_if_not_zero(Register reg); // sets reg to 1 if not zero, otherwise 0
 592 
 593   // Debugging
 594 
 595   // only if +VerifyOops
 596   void _verify_oop(Register reg, const char* s, const char* file, int line);
 597   void _verify_oop_addr(Address addr, const char* s, const char* file, int line);
 598 
 599   // TODO: verify method and klass metadata (compare against vptr?)
 600   void _verify_method_ptr(Register reg, const char * msg, const char * file, int line) {}
 601   void _verify_klass_ptr(Register reg, const char * msg, const char * file, int line){}
 602 
 603 #define verify_oop(reg) _verify_oop(reg, &quot;broken oop &quot; #reg, __FILE__, __LINE__)
 604 #define verify_oop_msg(reg, msg) _verify_oop(reg, &quot;broken oop &quot; #reg &quot;, &quot; #msg, __FILE__, __LINE__)
 605 #define verify_oop_addr(addr) _verify_oop_addr(addr, &quot;broken oop addr &quot; #addr, __FILE__, __LINE__)
 606 #define verify_method_ptr(reg) _verify_method_ptr(reg, &quot;broken method &quot; #reg, __FILE__, __LINE__)
 607 #define verify_klass_ptr(reg) _verify_klass_ptr(reg, &quot;broken klass &quot; #reg, __FILE__, __LINE__)
 608 
 609   // Verify or restore cpu control state after JNI call
 610   void restore_cpu_control_state_after_jni();
 611 
 612   // prints msg, dumps registers and stops execution
 613   void stop(const char* msg);
 614 
 615   // prints msg and continues
 616   void warn(const char* msg);
 617 
 618   // dumps registers and other state
 619   void print_state();
 620 
 621   static void debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg);
 622   static void debug64(char* msg, int64_t pc, int64_t regs[]);
 623   static void print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip);
 624   static void print_state64(int64_t pc, int64_t regs[]);
 625 
 626   void os_breakpoint();
 627 
 628   void untested()                                { stop(&quot;untested&quot;); }
 629 
 630   void unimplemented(const char* what = &quot;&quot;);
 631 
 632   void should_not_reach_here()                   { stop(&quot;should not reach here&quot;); }
 633 
 634   void print_CPU_state();
 635 
 636   // Stack overflow checking
 637   void bang_stack_with_offset(int offset) {
 638     // stack grows down, caller passes positive offset
 639     assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
 640     movl(Address(rsp, (-offset)), rax);
 641   }
 642 
 643   // Writes to stack successive pages until offset reached to check for
 644   // stack overflow + shadow pages.  Also, clobbers tmp
 645   void bang_stack_size(Register size, Register tmp);
 646 
 647   // Check for reserved stack access in method being exited (for JIT)
 648   void reserved_stack_check();
 649 
 650   virtual RegisterOrConstant delayed_value_impl(intptr_t* delayed_value_addr,
 651                                                 Register tmp,
 652                                                 int offset);
 653 
 654   // If thread_reg is != noreg the code assumes the register passed contains
 655   // the thread (required on 64 bit).
 656   void safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg);
 657 
 658   void verify_tlab();
 659 
 660   // Biased locking support
 661   // lock_reg and obj_reg must be loaded up with the appropriate values.
 662   // swap_reg must be rax, and is killed.
 663   // tmp_reg is optional. If it is supplied (i.e., != noreg) it will
 664   // be killed; if not supplied, push/pop will be used internally to
 665   // allocate a temporary (inefficient, avoid if possible).
 666   // Optional slow case is for implementations (interpreter and C1) which branch to
 667   // slow case directly. Leaves condition codes set for C2&#39;s Fast_Lock node.
 668   // Returns offset of first potentially-faulting instruction for null
 669   // check info (currently consumed only by C1). If
 670   // swap_reg_contains_mark is true then returns -1 as it is assumed
 671   // the calling code has already passed any potential faults.
 672   int biased_locking_enter(Register lock_reg, Register obj_reg,
 673                            Register swap_reg, Register tmp_reg,
<a name="5" id="anc5"></a><span class="line-modified"> 674                            bool swap_reg_contains_mark,</span>
 675                            Label&amp; done, Label* slow_case = NULL,
 676                            BiasedLockingCounters* counters = NULL);
 677   void biased_locking_exit (Register obj_reg, Register temp_reg, Label&amp; done);
 678 
 679   Condition negate_condition(Condition cond);
 680 
 681   // Instructions that use AddressLiteral operands. These instruction can handle 32bit/64bit
 682   // operands. In general the names are modified to avoid hiding the instruction in Assembler
 683   // so that we don&#39;t need to implement all the varieties in the Assembler with trivial wrappers
 684   // here in MacroAssembler. The major exception to this rule is call
 685 
 686   // Arithmetics
 687 
 688 
 689   void addptr(Address dst, int32_t src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)) ; }
 690   void addptr(Address dst, Register src);
 691 
 692   void addptr(Register dst, Address src) { LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src)); }
 693   void addptr(Register dst, int32_t src);
 694   void addptr(Register dst, Register src);
 695   void addptr(Register dst, RegisterOrConstant src) {
 696     if (src.is_constant()) addptr(dst, (int) src.as_constant());
 697     else                   addptr(dst,       src.as_register());
 698   }
 699 
 700   void andptr(Register dst, int32_t src);
 701   void andptr(Register src1, Register src2) { LP64_ONLY(andq(src1, src2)) NOT_LP64(andl(src1, src2)) ; }
 702 
 703   void cmp8(AddressLiteral src1, int imm);
 704 
 705   // renamed to drag out the casting of address to int32_t/intptr_t
 706   void cmp32(Register src1, int32_t imm);
 707 
 708   void cmp32(AddressLiteral src1, int32_t imm);
 709   // compare reg - mem, or reg - &amp;mem
 710   void cmp32(Register src1, AddressLiteral src2);
 711 
 712   void cmp32(Register src1, Address src2);
 713 
 714 #ifndef _LP64
 715   void cmpklass(Address dst, Metadata* obj);
 716   void cmpklass(Register dst, Metadata* obj);
 717   void cmpoop(Address dst, jobject obj);
 718   void cmpoop_raw(Address dst, jobject obj);
 719 #endif // _LP64
 720 
 721   void cmpoop(Register src1, Register src2);
 722   void cmpoop(Register src1, Address src2);
 723   void cmpoop(Register dst, jobject obj);
 724   void cmpoop_raw(Register dst, jobject obj);
 725 
 726   // NOTE src2 must be the lval. This is NOT an mem-mem compare
 727   void cmpptr(Address src1, AddressLiteral src2);
 728 
 729   void cmpptr(Register src1, AddressLiteral src2);
 730 
 731   void cmpptr(Register src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 732   void cmpptr(Register src1, Address src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 733   // void cmpptr(Address src1, Register src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 734 
 735   void cmpptr(Register src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 736   void cmpptr(Address src1, int32_t src2) { LP64_ONLY(cmpq(src1, src2)) NOT_LP64(cmpl(src1, src2)) ; }
 737 
 738   // cmp64 to avoild hiding cmpq
 739   void cmp64(Register src1, AddressLiteral src);
 740 
 741   void cmpxchgptr(Register reg, Address adr);
 742 
 743   void locked_cmpxchgptr(Register reg, AddressLiteral adr);
 744 
 745 
 746   void imulptr(Register dst, Register src) { LP64_ONLY(imulq(dst, src)) NOT_LP64(imull(dst, src)); }
 747   void imulptr(Register dst, Register src, int imm32) { LP64_ONLY(imulq(dst, src, imm32)) NOT_LP64(imull(dst, src, imm32)); }
 748 
 749 
 750   void negptr(Register dst) { LP64_ONLY(negq(dst)) NOT_LP64(negl(dst)); }
 751 
 752   void notptr(Register dst) { LP64_ONLY(notq(dst)) NOT_LP64(notl(dst)); }
 753 
 754   void shlptr(Register dst, int32_t shift);
 755   void shlptr(Register dst) { LP64_ONLY(shlq(dst)) NOT_LP64(shll(dst)); }
 756 
 757   void shrptr(Register dst, int32_t shift);
 758   void shrptr(Register dst) { LP64_ONLY(shrq(dst)) NOT_LP64(shrl(dst)); }
 759 
 760   void sarptr(Register dst) { LP64_ONLY(sarq(dst)) NOT_LP64(sarl(dst)); }
 761   void sarptr(Register dst, int32_t src) { LP64_ONLY(sarq(dst, src)) NOT_LP64(sarl(dst, src)); }
 762 
 763   void subptr(Address dst, int32_t src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 764 
 765   void subptr(Register dst, Address src) { LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src)); }
 766   void subptr(Register dst, int32_t src);
 767   // Force generation of a 4 byte immediate value even if it fits into 8bit
 768   void subptr_imm32(Register dst, int32_t src);
 769   void subptr(Register dst, Register src);
 770   void subptr(Register dst, RegisterOrConstant src) {
 771     if (src.is_constant()) subptr(dst, (int) src.as_constant());
 772     else                   subptr(dst,       src.as_register());
 773   }
 774 
 775   void sbbptr(Address dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 776   void sbbptr(Register dst, int32_t src) { LP64_ONLY(sbbq(dst, src)) NOT_LP64(sbbl(dst, src)); }
 777 
 778   void xchgptr(Register src1, Register src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 779   void xchgptr(Register src1, Address src2) { LP64_ONLY(xchgq(src1, src2)) NOT_LP64(xchgl(src1, src2)) ; }
 780 
 781   void xaddptr(Address src1, Register src2) { LP64_ONLY(xaddq(src1, src2)) NOT_LP64(xaddl(src1, src2)) ; }
 782 
 783 
 784 
 785   // Helper functions for statistics gathering.
 786   // Conditionally (atomically, on MPs) increments passed counter address, preserving condition codes.
 787   void cond_inc32(Condition cond, AddressLiteral counter_addr);
 788   // Unconditional atomic increment.
 789   void atomic_incl(Address counter_addr);
 790   void atomic_incl(AddressLiteral counter_addr, Register scr = rscratch1);
 791 #ifdef _LP64
 792   void atomic_incq(Address counter_addr);
 793   void atomic_incq(AddressLiteral counter_addr, Register scr = rscratch1);
 794 #endif
 795   void atomic_incptr(AddressLiteral counter_addr, Register scr = rscratch1) { LP64_ONLY(atomic_incq(counter_addr, scr)) NOT_LP64(atomic_incl(counter_addr, scr)) ; }
 796   void atomic_incptr(Address counter_addr) { LP64_ONLY(atomic_incq(counter_addr)) NOT_LP64(atomic_incl(counter_addr)) ; }
 797 
 798   void lea(Register dst, AddressLiteral adr);
 799   void lea(Address dst, AddressLiteral adr);
 800   void lea(Register dst, Address adr) { Assembler::lea(dst, adr); }
 801 
 802   void leal32(Register dst, Address src) { leal(dst, src); }
 803 
 804   // Import other testl() methods from the parent class or else
 805   // they will be hidden by the following overriding declaration.
 806   using Assembler::testl;
 807   void testl(Register dst, AddressLiteral src);
 808 
 809   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 810   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 811   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 812   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 813 
 814   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 815   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 816   void testptr(Register src1, Register src2);
 817 
 818   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 819   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 820 
 821   // Calls
 822 
 823   void call(Label&amp; L, relocInfo::relocType rtype);
 824   void call(Register entry);
 825   void call(Address addr) { Assembler::call(addr); }
 826 
 827   // NOTE: this call transfers to the effective address of entry NOT
 828   // the address contained by entry. This is because this is more natural
 829   // for jumps/calls.
 830   void call(AddressLiteral entry);
 831 
 832   // Emit the CompiledIC call idiom
 833   void ic_call(address entry, jint method_index = 0);
 834 
 835   // Jumps
 836 
 837   // NOTE: these jumps tranfer to the effective address of dst NOT
 838   // the address contained by dst. This is because this is more natural
 839   // for jumps/calls.
 840   void jump(AddressLiteral dst);
 841   void jump_cc(Condition cc, AddressLiteral dst);
 842 
 843   // 32bit can do a case table jump in one instruction but we no longer allow the base
 844   // to be installed in the Address class. This jump will tranfers to the address
 845   // contained in the location described by entry (not the address of entry)
 846   void jump(ArrayAddress entry);
 847 
 848   // Floating
 849 
 850   void andpd(XMMRegister dst, Address src) { Assembler::andpd(dst, src); }
 851   void andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 852   void andpd(XMMRegister dst, XMMRegister src) { Assembler::andpd(dst, src); }
 853 
 854   void andps(XMMRegister dst, XMMRegister src) { Assembler::andps(dst, src); }
 855   void andps(XMMRegister dst, Address src) { Assembler::andps(dst, src); }
 856   void andps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
 857 
 858   void comiss(XMMRegister dst, XMMRegister src) { Assembler::comiss(dst, src); }
 859   void comiss(XMMRegister dst, Address src) { Assembler::comiss(dst, src); }
 860   void comiss(XMMRegister dst, AddressLiteral src);
 861 
 862   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 863   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 864   void comisd(XMMRegister dst, AddressLiteral src);
 865 
 866 #ifndef _LP64
 867   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 868   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 869 
 870   void fldcw(Address src) { Assembler::fldcw(src); }
 871   void fldcw(AddressLiteral src);
 872 
 873   void fld_s(int index)   { Assembler::fld_s(index); }
 874   void fld_s(Address src) { Assembler::fld_s(src); }
 875   void fld_s(AddressLiteral src);
 876 
 877   void fld_d(Address src) { Assembler::fld_d(src); }
 878   void fld_d(AddressLiteral src);
 879 
 880   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 881   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 882 #endif // _LP64
 883 
 884   void fld_x(Address src) { Assembler::fld_x(src); }
 885   void fld_x(AddressLiteral src);
 886 
 887   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 888   void ldmxcsr(AddressLiteral src);
 889 
 890 #ifdef _LP64
 891  private:
 892   void sha256_AVX2_one_round_compute(
 893     Register  reg_old_h,
 894     Register  reg_a,
 895     Register  reg_b,
 896     Register  reg_c,
 897     Register  reg_d,
 898     Register  reg_e,
 899     Register  reg_f,
 900     Register  reg_g,
 901     Register  reg_h,
 902     int iter);
 903   void sha256_AVX2_four_rounds_compute_first(int start);
 904   void sha256_AVX2_four_rounds_compute_last(int start);
 905   void sha256_AVX2_one_round_and_sched(
 906         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
 907         XMMRegister xmm_1,     /* ymm5 */  /* full cycle is 16 iterations */
 908         XMMRegister xmm_2,     /* ymm6 */
 909         XMMRegister xmm_3,     /* ymm7 */
 910         Register    reg_a,      /* == eax on 0 iteration, then rotate 8 register right on each next iteration */
 911         Register    reg_b,      /* ebx */    /* full cycle is 8 iterations */
 912         Register    reg_c,      /* edi */
 913         Register    reg_d,      /* esi */
 914         Register    reg_e,      /* r8d */
 915         Register    reg_f,      /* r9d */
 916         Register    reg_g,      /* r10d */
 917         Register    reg_h,      /* r11d */
 918         int iter);
 919 
 920   void addm(int disp, Register r1, Register r2);
 921   void gfmul(XMMRegister tmp0, XMMRegister t);
 922   void schoolbookAAD(int i, Register subkeyH, XMMRegister data, XMMRegister tmp0,
 923                      XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3);
 924   void generateHtbl_one_block(Register htbl);
 925   void generateHtbl_eight_blocks(Register htbl);
 926  public:
 927   void sha256_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 928                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 929                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 930                    bool multi_block, XMMRegister shuf_mask);
 931   void avx_ghash(Register state, Register htbl, Register data, Register blocks);
 932 #endif
 933 
 934 #ifdef _LP64
 935  private:
 936   void sha512_AVX2_one_round_compute(Register old_h, Register a, Register b, Register c, Register d,
 937                                      Register e, Register f, Register g, Register h, int iteration);
 938 
 939   void sha512_AVX2_one_round_and_schedule(XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 940                                           Register a, Register b, Register c, Register d, Register e, Register f,
 941                                           Register g, Register h, int iteration);
 942 
 943   void addmq(int disp, Register r1, Register r2);
 944  public:
 945   void sha512_AVX2(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 946                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 947                    Register buf, Register state, Register ofs, Register limit, Register rsp, bool multi_block,
 948                    XMMRegister shuf_mask);
 949 private:
 950   void roundEnc(XMMRegister key, int rnum);
 951   void lastroundEnc(XMMRegister key, int rnum);
 952   void roundDec(XMMRegister key, int rnum);
 953   void lastroundDec(XMMRegister key, int rnum);
 954   void ev_load_key(XMMRegister xmmdst, Register key, int offset, XMMRegister xmm_shuf_mask);
 955 
 956 public:
 957   void aesecb_encrypt(Register source_addr, Register dest_addr, Register key, Register len);
 958   void aesecb_decrypt(Register source_addr, Register dest_addr, Register key, Register len);
 959   void aesctr_encrypt(Register src_addr, Register dest_addr, Register key, Register counter,
 960                       Register len_reg, Register used, Register used_addr, Register saved_encCounter_start);
 961 
 962 #endif
 963 
 964   void fast_sha1(XMMRegister abcd, XMMRegister e0, XMMRegister e1, XMMRegister msg0,
 965                  XMMRegister msg1, XMMRegister msg2, XMMRegister msg3, XMMRegister shuf_mask,
 966                  Register buf, Register state, Register ofs, Register limit, Register rsp,
 967                  bool multi_block);
 968 
 969 #ifdef _LP64
 970   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 971                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 972                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 973                    bool multi_block, XMMRegister shuf_mask);
 974 #else
 975   void fast_sha256(XMMRegister msg, XMMRegister state0, XMMRegister state1, XMMRegister msgtmp0,
 976                    XMMRegister msgtmp1, XMMRegister msgtmp2, XMMRegister msgtmp3, XMMRegister msgtmp4,
 977                    Register buf, Register state, Register ofs, Register limit, Register rsp,
 978                    bool multi_block);
 979 #endif
 980 
 981   void fast_exp(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
 982                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 983                 Register rax, Register rcx, Register rdx, Register tmp);
 984 
 985 #ifdef _LP64
 986   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
 987                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 988                 Register rax, Register rcx, Register rdx, Register tmp1, Register tmp2);
 989 
 990   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
 991                   XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
 992                   Register rax, Register rcx, Register rdx, Register r11);
 993 
 994   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
 995                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
 996                 Register rdx, Register tmp1, Register tmp2, Register tmp3, Register tmp4);
 997 
 998   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
 999                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1000                 Register rax, Register rbx, Register rcx, Register rdx, Register tmp1, Register tmp2,
1001                 Register tmp3, Register tmp4);
1002 
1003   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1004                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1005                 Register rax, Register rcx, Register rdx, Register tmp1,
1006                 Register tmp2, Register tmp3, Register tmp4);
1007   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1008                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1009                 Register rax, Register rcx, Register rdx, Register tmp1,
1010                 Register tmp2, Register tmp3, Register tmp4);
1011 #else
1012   void fast_log(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1013                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1014                 Register rax, Register rcx, Register rdx, Register tmp1);
1015 
1016   void fast_log10(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1017                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1018                 Register rax, Register rcx, Register rdx, Register tmp);
1019 
1020   void fast_pow(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,
1021                 XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7, Register rax, Register rcx,
1022                 Register rdx, Register tmp);
1023 
1024   void fast_sin(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1025                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1026                 Register rax, Register rbx, Register rdx);
1027 
1028   void fast_cos(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1029                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1030                 Register rax, Register rcx, Register rdx, Register tmp);
1031 
1032   void libm_sincos_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1033                         Register edx, Register ebx, Register esi, Register edi,
1034                         Register ebp, Register esp);
1035 
1036   void libm_reduce_pi04l(Register eax, Register ecx, Register edx, Register ebx,
1037                          Register esi, Register edi, Register ebp, Register esp);
1038 
1039   void libm_tancot_huge(XMMRegister xmm0, XMMRegister xmm1, Register eax, Register ecx,
1040                         Register edx, Register ebx, Register esi, Register edi,
1041                         Register ebp, Register esp);
1042 
1043   void fast_tan(XMMRegister xmm0, XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,
1044                 XMMRegister xmm4, XMMRegister xmm5, XMMRegister xmm6, XMMRegister xmm7,
1045                 Register rax, Register rcx, Register rdx, Register tmp);
1046 #endif
1047 
1048 private:
1049 
1050   // these are private because users should be doing movflt/movdbl
1051 
1052   void movss(XMMRegister dst, XMMRegister src) { Assembler::movss(dst, src); }
1053   void movss(Address dst, XMMRegister src)     { Assembler::movss(dst, src); }
1054   void movss(XMMRegister dst, Address src)     { Assembler::movss(dst, src); }
1055   void movss(XMMRegister dst, AddressLiteral src);
1056 
1057   void movlpd(XMMRegister dst, Address src)    {Assembler::movlpd(dst, src); }
1058   void movlpd(XMMRegister dst, AddressLiteral src);
1059 
1060 public:
1061 
1062   void addsd(XMMRegister dst, XMMRegister src)    { Assembler::addsd(dst, src); }
1063   void addsd(XMMRegister dst, Address src)        { Assembler::addsd(dst, src); }
1064   void addsd(XMMRegister dst, AddressLiteral src);
1065 
1066   void addss(XMMRegister dst, XMMRegister src)    { Assembler::addss(dst, src); }
1067   void addss(XMMRegister dst, Address src)        { Assembler::addss(dst, src); }
1068   void addss(XMMRegister dst, AddressLiteral src);
1069 
1070   void addpd(XMMRegister dst, XMMRegister src)    { Assembler::addpd(dst, src); }
1071   void addpd(XMMRegister dst, Address src)        { Assembler::addpd(dst, src); }
1072   void addpd(XMMRegister dst, AddressLiteral src);
1073 
1074   void divsd(XMMRegister dst, XMMRegister src)    { Assembler::divsd(dst, src); }
1075   void divsd(XMMRegister dst, Address src)        { Assembler::divsd(dst, src); }
1076   void divsd(XMMRegister dst, AddressLiteral src);
1077 
1078   void divss(XMMRegister dst, XMMRegister src)    { Assembler::divss(dst, src); }
1079   void divss(XMMRegister dst, Address src)        { Assembler::divss(dst, src); }
1080   void divss(XMMRegister dst, AddressLiteral src);
1081 
1082   // Move Unaligned Double Quadword
1083   void movdqu(Address     dst, XMMRegister src);
1084   void movdqu(XMMRegister dst, Address src);
1085   void movdqu(XMMRegister dst, XMMRegister src);
1086   void movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg = rscratch1);
1087   // AVX Unaligned forms
1088   void vmovdqu(Address     dst, XMMRegister src);
1089   void vmovdqu(XMMRegister dst, Address src);
1090   void vmovdqu(XMMRegister dst, XMMRegister src);
1091   void vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1092   void evmovdquq(XMMRegister dst, Address src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1093   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1094   void evmovdquq(Address dst, XMMRegister src, int vector_len) { Assembler::evmovdquq(dst, src, vector_len); }
1095   void evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch);
1096 
1097   // Move Aligned Double Quadword
1098   void movdqa(XMMRegister dst, Address src)       { Assembler::movdqa(dst, src); }
1099   void movdqa(XMMRegister dst, XMMRegister src)   { Assembler::movdqa(dst, src); }
1100   void movdqa(XMMRegister dst, AddressLiteral src);
1101 
1102   void movsd(XMMRegister dst, XMMRegister src) { Assembler::movsd(dst, src); }
1103   void movsd(Address dst, XMMRegister src)     { Assembler::movsd(dst, src); }
1104   void movsd(XMMRegister dst, Address src)     { Assembler::movsd(dst, src); }
1105   void movsd(XMMRegister dst, AddressLiteral src);
1106 
1107   void mulpd(XMMRegister dst, XMMRegister src)    { Assembler::mulpd(dst, src); }
1108   void mulpd(XMMRegister dst, Address src)        { Assembler::mulpd(dst, src); }
1109   void mulpd(XMMRegister dst, AddressLiteral src);
1110 
1111   void mulsd(XMMRegister dst, XMMRegister src)    { Assembler::mulsd(dst, src); }
1112   void mulsd(XMMRegister dst, Address src)        { Assembler::mulsd(dst, src); }
1113   void mulsd(XMMRegister dst, AddressLiteral src);
1114 
1115   void mulss(XMMRegister dst, XMMRegister src)    { Assembler::mulss(dst, src); }
1116   void mulss(XMMRegister dst, Address src)        { Assembler::mulss(dst, src); }
1117   void mulss(XMMRegister dst, AddressLiteral src);
1118 
1119   // Carry-Less Multiplication Quadword
1120   void pclmulldq(XMMRegister dst, XMMRegister src) {
1121     // 0x00 - multiply lower 64 bits [0:63]
1122     Assembler::pclmulqdq(dst, src, 0x00);
1123   }
1124   void pclmulhdq(XMMRegister dst, XMMRegister src) {
1125     // 0x11 - multiply upper 64 bits [64:127]
1126     Assembler::pclmulqdq(dst, src, 0x11);
1127   }
1128 
1129   void pcmpeqb(XMMRegister dst, XMMRegister src);
1130   void pcmpeqw(XMMRegister dst, XMMRegister src);
1131 
1132   void pcmpestri(XMMRegister dst, Address src, int imm8);
1133   void pcmpestri(XMMRegister dst, XMMRegister src, int imm8);
1134 
1135   void pmovzxbw(XMMRegister dst, XMMRegister src);
1136   void pmovzxbw(XMMRegister dst, Address src);
1137 
1138   void pmovmskb(Register dst, XMMRegister src);
1139 
1140   void ptest(XMMRegister dst, XMMRegister src);
1141 
1142   void sqrtsd(XMMRegister dst, XMMRegister src)    { Assembler::sqrtsd(dst, src); }
1143   void sqrtsd(XMMRegister dst, Address src)        { Assembler::sqrtsd(dst, src); }
1144   void sqrtsd(XMMRegister dst, AddressLiteral src);
1145 
1146   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode)    { Assembler::roundsd(dst, src, rmode); }
1147   void roundsd(XMMRegister dst, Address src, int32_t rmode)        { Assembler::roundsd(dst, src, rmode); }
1148   void roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg);
1149 
1150   void sqrtss(XMMRegister dst, XMMRegister src)    { Assembler::sqrtss(dst, src); }
1151   void sqrtss(XMMRegister dst, Address src)        { Assembler::sqrtss(dst, src); }
1152   void sqrtss(XMMRegister dst, AddressLiteral src);
1153 
1154   void subsd(XMMRegister dst, XMMRegister src)    { Assembler::subsd(dst, src); }
1155   void subsd(XMMRegister dst, Address src)        { Assembler::subsd(dst, src); }
1156   void subsd(XMMRegister dst, AddressLiteral src);
1157 
1158   void subss(XMMRegister dst, XMMRegister src)    { Assembler::subss(dst, src); }
1159   void subss(XMMRegister dst, Address src)        { Assembler::subss(dst, src); }
1160   void subss(XMMRegister dst, AddressLiteral src);
1161 
1162   void ucomiss(XMMRegister dst, XMMRegister src) { Assembler::ucomiss(dst, src); }
1163   void ucomiss(XMMRegister dst, Address src)     { Assembler::ucomiss(dst, src); }
1164   void ucomiss(XMMRegister dst, AddressLiteral src);
1165 
1166   void ucomisd(XMMRegister dst, XMMRegister src) { Assembler::ucomisd(dst, src); }
1167   void ucomisd(XMMRegister dst, Address src)     { Assembler::ucomisd(dst, src); }
1168   void ucomisd(XMMRegister dst, AddressLiteral src);
1169 
1170   // Bitwise Logical XOR of Packed Double-Precision Floating-Point Values
1171   void xorpd(XMMRegister dst, XMMRegister src);
1172   void xorpd(XMMRegister dst, Address src)     { Assembler::xorpd(dst, src); }
1173   void xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1174 
1175   // Bitwise Logical XOR of Packed Single-Precision Floating-Point Values
1176   void xorps(XMMRegister dst, XMMRegister src);
1177   void xorps(XMMRegister dst, Address src)     { Assembler::xorps(dst, src); }
1178   void xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg = rscratch1);
1179 
1180   // Shuffle Bytes
1181   void pshufb(XMMRegister dst, XMMRegister src) { Assembler::pshufb(dst, src); }
1182   void pshufb(XMMRegister dst, Address src)     { Assembler::pshufb(dst, src); }
1183   void pshufb(XMMRegister dst, AddressLiteral src);
1184   // AVX 3-operands instructions
1185 
1186   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddsd(dst, nds, src); }
1187   void vaddsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddsd(dst, nds, src); }
1188   void vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1189 
1190   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vaddss(dst, nds, src); }
1191   void vaddss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vaddss(dst, nds, src); }
1192   void vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1193 
1194   void vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1195   void vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len);
1196 
1197   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1198   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1199 
1200   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1201   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1202 
1203   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1204   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpaddd(dst, nds, src, vector_len); }
1205   void vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch);
1206 
1207   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1208   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vpand(dst, nds, src, vector_len); }
1209   void vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1210 
1211   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
1212   void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }
1213 
1214   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1215 
1216   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1217 
1218   void vpmovzxbw(XMMRegister dst, Address src, int vector_len);
1219   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpmovzxbw(dst, src, vector_len); }
1220 
1221   void vpmovmskb(Register dst, XMMRegister src);
1222 
1223   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1224   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1225 
1226   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1227   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1228 
1229   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1230   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1231 
1232   void vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1233   void vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1234 
1235   void evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1236   void evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1237 
1238   void vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1239   void vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1240 
1241   void vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len);
1242   void vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len);
1243 
1244   void vptest(XMMRegister dst, XMMRegister src);
1245 
1246   void punpcklbw(XMMRegister dst, XMMRegister src);
1247   void punpcklbw(XMMRegister dst, Address src) { Assembler::punpcklbw(dst, src); }
1248 
1249   void pshufd(XMMRegister dst, Address src, int mode);
1250   void pshufd(XMMRegister dst, XMMRegister src, int mode) { Assembler::pshufd(dst, src, mode); }
1251 
1252   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1253   void pshuflw(XMMRegister dst, Address src, int mode) { Assembler::pshuflw(dst, src, mode); }
1254 
1255   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandpd(dst, nds, src, vector_len); }
1256   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandpd(dst, nds, src, vector_len); }
1257   void vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1258 
1259   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vandps(dst, nds, src, vector_len); }
1260   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len)     { Assembler::vandps(dst, nds, src, vector_len); }
1261   void vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1262 
1263   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivsd(dst, nds, src); }
1264   void vdivsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivsd(dst, nds, src); }
1265   void vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1266 
1267   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vdivss(dst, nds, src); }
1268   void vdivss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vdivss(dst, nds, src); }
1269   void vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1270 
1271   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulsd(dst, nds, src); }
1272   void vmulsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulsd(dst, nds, src); }
1273   void vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1274 
1275   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vmulss(dst, nds, src); }
1276   void vmulss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vmulss(dst, nds, src); }
1277   void vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1278 
1279   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubsd(dst, nds, src); }
1280   void vsubsd(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubsd(dst, nds, src); }
1281   void vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1282 
1283   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) { Assembler::vsubss(dst, nds, src); }
1284   void vsubss(XMMRegister dst, XMMRegister nds, Address src)     { Assembler::vsubss(dst, nds, src); }
1285   void vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1286 
1287   void vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1288   void vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src);
1289 
1290   // AVX Vector instructions
1291 
1292   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1293   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorpd(dst, nds, src, vector_len); }
1294   void vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1295 
1296   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1297   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) { Assembler::vxorps(dst, nds, src, vector_len); }
1298   void vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1299 
1300   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1301     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1302       Assembler::vpxor(dst, nds, src, vector_len);
1303     else
1304       Assembler::vxorpd(dst, nds, src, vector_len);
1305   }
1306   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
1307     if (UseAVX &gt; 1 || (vector_len &lt; 1)) // vpxor 256 bit is available only in AVX2
1308       Assembler::vpxor(dst, nds, src, vector_len);
1309     else
1310       Assembler::vxorpd(dst, nds, src, vector_len);
1311   }
1312   void vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg = rscratch1);
1313 
1314   // Simple version for AVX2 256bit vectors
1315   void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }
1316   void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }
1317 
1318   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
1319     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1320       Assembler::vinserti32x4(dst, dst, src, imm8);
1321     } else if (UseAVX &gt; 1) {
1322       // vinserti128 is available only in AVX2
1323       Assembler::vinserti128(dst, nds, src, imm8);
1324     } else {
1325       Assembler::vinsertf128(dst, nds, src, imm8);
1326     }
1327   }
1328 
1329   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
1330     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1331       Assembler::vinserti32x4(dst, dst, src, imm8);
1332     } else if (UseAVX &gt; 1) {
1333       // vinserti128 is available only in AVX2
1334       Assembler::vinserti128(dst, nds, src, imm8);
1335     } else {
1336       Assembler::vinsertf128(dst, nds, src, imm8);
1337     }
1338   }
1339 
1340   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
1341     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1342       Assembler::vextracti32x4(dst, src, imm8);
1343     } else if (UseAVX &gt; 1) {
1344       // vextracti128 is available only in AVX2
1345       Assembler::vextracti128(dst, src, imm8);
1346     } else {
1347       Assembler::vextractf128(dst, src, imm8);
1348     }
1349   }
1350 
1351   void vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
1352     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1353       Assembler::vextracti32x4(dst, src, imm8);
1354     } else if (UseAVX &gt; 1) {
1355       // vextracti128 is available only in AVX2
1356       Assembler::vextracti128(dst, src, imm8);
1357     } else {
1358       Assembler::vextractf128(dst, src, imm8);
1359     }
1360   }
1361 
1362   // 128bit copy to/from high 128 bits of 256bit (YMM) vector registers
1363   void vinserti128_high(XMMRegister dst, XMMRegister src) {
1364     vinserti128(dst, dst, src, 1);
1365   }
1366   void vinserti128_high(XMMRegister dst, Address src) {
1367     vinserti128(dst, dst, src, 1);
1368   }
1369   void vextracti128_high(XMMRegister dst, XMMRegister src) {
1370     vextracti128(dst, src, 1);
1371   }
1372   void vextracti128_high(Address dst, XMMRegister src) {
1373     vextracti128(dst, src, 1);
1374   }
1375 
1376   void vinsertf128_high(XMMRegister dst, XMMRegister src) {
1377     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1378       Assembler::vinsertf32x4(dst, dst, src, 1);
1379     } else {
1380       Assembler::vinsertf128(dst, dst, src, 1);
1381     }
1382   }
1383 
1384   void vinsertf128_high(XMMRegister dst, Address src) {
1385     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1386       Assembler::vinsertf32x4(dst, dst, src, 1);
1387     } else {
1388       Assembler::vinsertf128(dst, dst, src, 1);
1389     }
1390   }
1391 
1392   void vextractf128_high(XMMRegister dst, XMMRegister src) {
1393     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1394       Assembler::vextractf32x4(dst, src, 1);
1395     } else {
1396       Assembler::vextractf128(dst, src, 1);
1397     }
1398   }
1399 
1400   void vextractf128_high(Address dst, XMMRegister src) {
1401     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1402       Assembler::vextractf32x4(dst, src, 1);
1403     } else {
1404       Assembler::vextractf128(dst, src, 1);
1405     }
1406   }
1407 
1408   // 256bit copy to/from high 256 bits of 512bit (ZMM) vector registers
1409   void vinserti64x4_high(XMMRegister dst, XMMRegister src) {
1410     Assembler::vinserti64x4(dst, dst, src, 1);
1411   }
1412   void vinsertf64x4_high(XMMRegister dst, XMMRegister src) {
1413     Assembler::vinsertf64x4(dst, dst, src, 1);
1414   }
1415   void vextracti64x4_high(XMMRegister dst, XMMRegister src) {
1416     Assembler::vextracti64x4(dst, src, 1);
1417   }
1418   void vextractf64x4_high(XMMRegister dst, XMMRegister src) {
1419     Assembler::vextractf64x4(dst, src, 1);
1420   }
1421   void vextractf64x4_high(Address dst, XMMRegister src) {
1422     Assembler::vextractf64x4(dst, src, 1);
1423   }
1424   void vinsertf64x4_high(XMMRegister dst, Address src) {
1425     Assembler::vinsertf64x4(dst, dst, src, 1);
1426   }
1427 
1428   // 128bit copy to/from low 128 bits of 256bit (YMM) vector registers
1429   void vinserti128_low(XMMRegister dst, XMMRegister src) {
1430     vinserti128(dst, dst, src, 0);
1431   }
1432   void vinserti128_low(XMMRegister dst, Address src) {
1433     vinserti128(dst, dst, src, 0);
1434   }
1435   void vextracti128_low(XMMRegister dst, XMMRegister src) {
1436     vextracti128(dst, src, 0);
1437   }
1438   void vextracti128_low(Address dst, XMMRegister src) {
1439     vextracti128(dst, src, 0);
1440   }
1441 
1442   void vinsertf128_low(XMMRegister dst, XMMRegister src) {
1443     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1444       Assembler::vinsertf32x4(dst, dst, src, 0);
1445     } else {
1446       Assembler::vinsertf128(dst, dst, src, 0);
1447     }
1448   }
1449 
1450   void vinsertf128_low(XMMRegister dst, Address src) {
1451     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1452       Assembler::vinsertf32x4(dst, dst, src, 0);
1453     } else {
1454       Assembler::vinsertf128(dst, dst, src, 0);
1455     }
1456   }
1457 
1458   void vextractf128_low(XMMRegister dst, XMMRegister src) {
1459     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1460       Assembler::vextractf32x4(dst, src, 0);
1461     } else {
1462       Assembler::vextractf128(dst, src, 0);
1463     }
1464   }
1465 
1466   void vextractf128_low(Address dst, XMMRegister src) {
1467     if (UseAVX &gt; 2 &amp;&amp; VM_Version::supports_avx512novl()) {
1468       Assembler::vextractf32x4(dst, src, 0);
1469     } else {
1470       Assembler::vextractf128(dst, src, 0);
1471     }
1472   }
1473 
1474   // 256bit copy to/from low 256 bits of 512bit (ZMM) vector registers
1475   void vinserti64x4_low(XMMRegister dst, XMMRegister src) {
1476     Assembler::vinserti64x4(dst, dst, src, 0);
1477   }
1478   void vinsertf64x4_low(XMMRegister dst, XMMRegister src) {
1479     Assembler::vinsertf64x4(dst, dst, src, 0);
1480   }
1481   void vextracti64x4_low(XMMRegister dst, XMMRegister src) {
1482     Assembler::vextracti64x4(dst, src, 0);
1483   }
1484   void vextractf64x4_low(XMMRegister dst, XMMRegister src) {
1485     Assembler::vextractf64x4(dst, src, 0);
1486   }
1487   void vextractf64x4_low(Address dst, XMMRegister src) {
1488     Assembler::vextractf64x4(dst, src, 0);
1489   }
1490   void vinsertf64x4_low(XMMRegister dst, Address src) {
1491     Assembler::vinsertf64x4(dst, dst, src, 0);
1492   }
1493 
1494   // Carry-Less Multiplication Quadword
1495   void vpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1496     // 0x00 - multiply lower 64 bits [0:63]
1497     Assembler::vpclmulqdq(dst, nds, src, 0x00);
1498   }
1499   void vpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1500     // 0x11 - multiply upper 64 bits [64:127]
1501     Assembler::vpclmulqdq(dst, nds, src, 0x11);
1502   }
1503   void vpclmullqhqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1504     // 0x10 - multiply nds[0:63] and src[64:127]
1505     Assembler::vpclmulqdq(dst, nds, src, 0x10);
1506   }
1507   void vpclmulhqlqdq(XMMRegister dst, XMMRegister nds, XMMRegister src) {
1508     //0x01 - multiply nds[64:127] and src[0:63]
1509     Assembler::vpclmulqdq(dst, nds, src, 0x01);
1510   }
1511 
1512   void evpclmulldq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1513     // 0x00 - multiply lower 64 bits [0:63]
1514     Assembler::evpclmulqdq(dst, nds, src, 0x00, vector_len);
1515   }
1516   void evpclmulhdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
1517     // 0x11 - multiply upper 64 bits [64:127]
1518     Assembler::evpclmulqdq(dst, nds, src, 0x11, vector_len);
1519   }
1520 
1521   // Data
1522 
1523   void cmov32( Condition cc, Register dst, Address  src);
1524   void cmov32( Condition cc, Register dst, Register src);
1525 
1526   void cmov(   Condition cc, Register dst, Register src) { cmovptr(cc, dst, src); }
1527 
1528   void cmovptr(Condition cc, Register dst, Address  src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1529   void cmovptr(Condition cc, Register dst, Register src) { LP64_ONLY(cmovq(cc, dst, src)) NOT_LP64(cmov32(cc, dst, src)); }
1530 
1531   void movoop(Register dst, jobject obj);
1532   void movoop(Address dst, jobject obj);
1533 
1534   void mov_metadata(Register dst, Metadata* obj);
1535   void mov_metadata(Address dst, Metadata* obj);
1536 
1537   void movptr(ArrayAddress dst, Register src);
1538   // can this do an lea?
1539   void movptr(Register dst, ArrayAddress src);
1540 
1541   void movptr(Register dst, Address src);
1542 
1543 #ifdef _LP64
1544   void movptr(Register dst, AddressLiteral src, Register scratch=rscratch1);
1545 #else
1546   void movptr(Register dst, AddressLiteral src, Register scratch=noreg); // Scratch reg is ignored in 32-bit
1547 #endif
1548 
1549   void movptr(Register dst, intptr_t src);
1550   void movptr(Register dst, Register src);
1551   void movptr(Address dst, intptr_t src);
1552 
1553   void movptr(Address dst, Register src);
1554 
1555   void movptr(Register dst, RegisterOrConstant src) {
1556     if (src.is_constant()) movptr(dst, src.as_constant());
1557     else                   movptr(dst, src.as_register());
1558   }
1559 
1560 #ifdef _LP64
1561   // Generally the next two are only used for moving NULL
1562   // Although there are situations in initializing the mark word where
1563   // they could be used. They are dangerous.
1564 
1565   // They only exist on LP64 so that int32_t and intptr_t are not the same
1566   // and we have ambiguous declarations.
1567 
1568   void movptr(Address dst, int32_t imm32);
1569   void movptr(Register dst, int32_t imm32);
1570 #endif // _LP64
1571 
1572   // to avoid hiding movl
1573   void mov32(AddressLiteral dst, Register src);
1574   void mov32(Register dst, AddressLiteral src);
1575 
1576   // to avoid hiding movb
1577   void movbyte(ArrayAddress dst, int src);
1578 
1579   // Import other mov() methods from the parent class or else
1580   // they will be hidden by the following overriding declaration.
1581   using Assembler::movdl;
1582   using Assembler::movq;
1583   void movdl(XMMRegister dst, AddressLiteral src);
1584   void movq(XMMRegister dst, AddressLiteral src);
1585 
1586   // Can push value or effective address
1587   void pushptr(AddressLiteral src);
1588 
1589   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1590   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1591 
1592   void pushoop(jobject obj);
1593   void pushklass(Metadata* obj);
1594 
1595   // sign extend as need a l to ptr sized element
1596   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1597   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1598 
1599 
1600  public:
1601   // C2 compiled method&#39;s prolog code.
1602   void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);
1603 
1604   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1605   // if &#39;is_large&#39; is set, do not try to produce short loop
1606   void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large);
1607 
1608   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
1609   void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);
1610 
1611   // Fill primitive arrays
1612   void generate_fill(BasicType t, bool aligned,
1613                      Register to, Register value, Register count,
1614                      Register rtmp, XMMRegister xtmp);
1615 
1616   void encode_iso_array(Register src, Register dst, Register len,
1617                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1618                         XMMRegister tmp4, Register tmp5, Register result);
1619 
1620 #ifdef _LP64
1621   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1622   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1623                              Register y, Register y_idx, Register z,
1624                              Register carry, Register product,
1625                              Register idx, Register kdx);
1626   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1627                               Register yz_idx, Register idx,
1628                               Register carry, Register product, int offset);
1629   void multiply_128_x_128_bmi2_loop(Register y, Register z,
1630                                     Register carry, Register carry2,
1631                                     Register idx, Register jdx,
1632                                     Register yz_idx1, Register yz_idx2,
1633                                     Register tmp, Register tmp3, Register tmp4);
1634   void multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
1635                                Register yz_idx, Register idx, Register jdx,
1636                                Register carry, Register product,
1637                                Register carry2);
1638   void multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
1639                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5);
1640   void square_rshift(Register x, Register len, Register z, Register tmp1, Register tmp3,
1641                      Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1642   void multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry,
1643                             Register tmp2);
1644   void multiply_add_64(Register sum, Register op1, Register op2, Register carry,
1645                        Register rdxReg, Register raxReg);
1646   void add_one_64(Register z, Register zlen, Register carry, Register tmp1);
1647   void lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1648                        Register tmp3, Register tmp4);
1649   void square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2,
1650                      Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg);
1651 
1652   void mul_add_128_x_32_loop(Register out, Register in, Register offset, Register len, Register tmp1,
1653                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1654                Register raxReg);
1655   void mul_add(Register out, Register in, Register offset, Register len, Register k, Register tmp1,
1656                Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg,
1657                Register raxReg);
1658   void vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
1659                            Register result, Register tmp1, Register tmp2,
1660                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3);
1661 #endif
1662 
1663   // CRC32 code for java.util.zip.CRC32::updateBytes() intrinsic.
1664   void update_byte_crc32(Register crc, Register val, Register table);
1665   void kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp);
1666   // CRC32C code for java.util.zip.CRC32C::updateBytes() intrinsic
1667   // Note on a naming convention:
1668   // Prefix w = register only used on a Westmere+ architecture
1669   // Prefix n = register only used on a Nehalem architecture
1670 #ifdef _LP64
1671   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1672                        Register tmp1, Register tmp2, Register tmp3);
1673 #else
1674   void crc32c_ipl_alg4(Register in_out, uint32_t n,
1675                        Register tmp1, Register tmp2, Register tmp3,
1676                        XMMRegister xtmp1, XMMRegister xtmp2);
1677 #endif
1678   void crc32c_pclmulqdq(XMMRegister w_xtmp1,
1679                         Register in_out,
1680                         uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
1681                         XMMRegister w_xtmp2,
1682                         Register tmp1,
1683                         Register n_tmp2, Register n_tmp3);
1684   void crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
1685                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1686                        Register tmp1, Register tmp2,
1687                        Register n_tmp3);
1688   void crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
1689                          Register in_out1, Register in_out2, Register in_out3,
1690                          Register tmp1, Register tmp2, Register tmp3,
1691                          XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1692                          Register tmp4, Register tmp5,
1693                          Register n_tmp6);
1694   void crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
1695                             Register tmp1, Register tmp2, Register tmp3,
1696                             Register tmp4, Register tmp5, Register tmp6,
1697                             XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
1698                             bool is_pclmulqdq_supported);
1699   // Fold 128-bit data chunk
1700   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1701   void fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf);
1702   // Fold 8-bit data
1703   void fold_8bit_crc32(Register crc, Register table, Register tmp);
1704   void fold_8bit_crc32(XMMRegister crc, Register table, XMMRegister xtmp, Register tmp);
1705   void fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset);
1706 
1707   // Compress char[] array to byte[].
1708   void char_array_compress(Register src, Register dst, Register len,
1709                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1710                            XMMRegister tmp4, Register tmp5, Register result);
1711 
1712   // Inflate byte[] array to char[].
1713   void byte_array_inflate(Register src, Register dst, Register len,
1714                           XMMRegister tmp1, Register tmp2);
1715 
1716 #ifdef _LP64
1717   void convert_f2i(Register dst, XMMRegister src);
1718   void convert_d2i(Register dst, XMMRegister src);
1719   void convert_f2l(Register dst, XMMRegister src);
1720   void convert_d2l(Register dst, XMMRegister src);
1721 
1722   void cache_wb(Address line);
1723   void cache_wbsync(bool is_pre);
1724 #endif // _LP64
1725 
1726   void vallones(XMMRegister dst, int vector_len);
1727 };
1728 
1729 /**
1730  * class SkipIfEqual:
1731  *
1732  * Instantiating this class will result in assembly code being output that will
1733  * jump around any code emitted between the creation of the instance and it&#39;s
1734  * automatic destruction at the end of a scope block, depending on the value of
1735  * the flag passed to the constructor, which will be checked at run-time.
1736  */
1737 class SkipIfEqual {
1738  private:
1739   MacroAssembler* _masm;
1740   Label _label;
1741 
1742  public:
1743    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1744    ~SkipIfEqual();
1745 };
1746 
1747 #endif // CPU_X86_MACROASSEMBLER_X86_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;nativeInst_x86.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;utilities/powerOfTwo.hpp&quot;
  42 #include &quot;vmreg_x86.inline.hpp&quot;
  43 
  44 
  45 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  46 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  47 // fast versions of NegF/NegD and AbsF/AbsD.
  48 
  49 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  50 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  51   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  52   // of 128-bits operands for SSE instructions.
  53   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  54   // Store the value to a 128-bits operand.
  55   operand[0] = lo;
  56   operand[1] = hi;
  57   return operand;
  58 }
  59 
  60 // Buffer for 128-bits masks used by SSE instructions.
  61 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  62 
  63 // Static initialization during VM startup.
  64 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  65 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  66 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  67 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  68 
  69 
  70 NEEDS_CLEANUP // remove this definitions ?
  71 const Register IC_Klass    = rax;   // where the IC klass is cached
  72 const Register SYNC_header = rax;   // synchronization header
  73 const Register SHIFT_count = rcx;   // where count for shift operations must be
  74 
  75 #define __ _masm-&gt;
  76 
  77 
  78 static void select_different_registers(Register preserve,
  79                                        Register extra,
  80                                        Register &amp;tmp1,
  81                                        Register &amp;tmp2) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, extra);
  87     tmp2 = extra;
  88   }
  89   assert_different_registers(preserve, tmp1, tmp2);
  90 }
  91 
  92 
  93 
  94 static void select_different_registers(Register preserve,
  95                                        Register extra,
  96                                        Register &amp;tmp1,
  97                                        Register &amp;tmp2,
  98                                        Register &amp;tmp3) {
  99   if (tmp1 == preserve) {
 100     assert_different_registers(tmp1, tmp2, tmp3, extra);
 101     tmp1 = extra;
 102   } else if (tmp2 == preserve) {
 103     assert_different_registers(tmp1, tmp2, tmp3, extra);
 104     tmp2 = extra;
 105   } else if (tmp3 == preserve) {
 106     assert_different_registers(tmp1, tmp2, tmp3, extra);
 107     tmp3 = extra;
 108   }
 109   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 110 }
 111 
 112 
 113 
 114 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 115   if (opr-&gt;is_constant()) {
 116     LIR_Const* constant = opr-&gt;as_constant_ptr();
 117     switch (constant-&gt;type()) {
 118       case T_INT: {
 119         return true;
 120       }
 121 
 122       default:
 123         return false;
 124     }
 125   }
 126   return false;
 127 }
 128 
 129 
 130 LIR_Opr LIR_Assembler::receiverOpr() {
 131   return FrameMap::receiver_opr;
 132 }
 133 
 134 LIR_Opr LIR_Assembler::osrBufferPointer() {
 135   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 136 }
 137 
 138 //--------------fpu register translations-----------------------
 139 
 140 
 141 address LIR_Assembler::float_constant(float f) {
 142   address const_addr = __ float_constant(f);
 143   if (const_addr == NULL) {
 144     bailout(&quot;const section overflow&quot;);
 145     return __ code()-&gt;consts()-&gt;start();
 146   } else {
 147     return const_addr;
 148   }
 149 }
 150 
 151 
 152 address LIR_Assembler::double_constant(double d) {
 153   address const_addr = __ double_constant(d);
 154   if (const_addr == NULL) {
 155     bailout(&quot;const section overflow&quot;);
 156     return __ code()-&gt;consts()-&gt;start();
 157   } else {
 158     return const_addr;
 159   }
 160 }
 161 
 162 #ifndef _LP64
 163 void LIR_Assembler::fpop() {
 164   __ fpop();
 165 }
 166 
 167 void LIR_Assembler::fxch(int i) {
 168   __ fxch(i);
 169 }
 170 
 171 void LIR_Assembler::fld(int i) {
 172   __ fld_s(i);
 173 }
 174 
 175 void LIR_Assembler::ffree(int i) {
 176   __ ffree(i);
 177 }
 178 #endif // !_LP64
 179 
 180 void LIR_Assembler::breakpoint() {
 181   __ int3();
 182 }
 183 
 184 void LIR_Assembler::push(LIR_Opr opr) {
 185   if (opr-&gt;is_single_cpu()) {
 186     __ push_reg(opr-&gt;as_register());
 187   } else if (opr-&gt;is_double_cpu()) {
 188     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 189     __ push_reg(opr-&gt;as_register_lo());
 190   } else if (opr-&gt;is_stack()) {
 191     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 192   } else if (opr-&gt;is_constant()) {
 193     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 194     if (const_opr-&gt;type() == T_OBJECT) {
 195       __ push_oop(const_opr-&gt;as_jobject());
 196     } else if (const_opr-&gt;type() == T_INT) {
 197       __ push_jint(const_opr-&gt;as_jint());
 198     } else {
 199       ShouldNotReachHere();
 200     }
 201 
 202   } else {
 203     ShouldNotReachHere();
 204   }
 205 }
 206 
 207 void LIR_Assembler::pop(LIR_Opr opr) {
 208   if (opr-&gt;is_single_cpu()) {
 209     __ pop_reg(opr-&gt;as_register());
 210   } else {
 211     ShouldNotReachHere();
 212   }
 213 }
 214 
 215 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 216   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 217 }
 218 
 219 //-------------------------------------------
 220 
 221 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 222   return as_Address(addr, rscratch1);
 223 }
 224 
 225 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 226   if (addr-&gt;base()-&gt;is_illegal()) {
 227     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 228     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 229     if (! __ reachable(laddr)) {
 230       __ movptr(tmp, laddr.addr());
 231       Address res(tmp, 0);
 232       return res;
 233     } else {
 234       return __ as_Address(laddr);
 235     }
 236   }
 237 
 238   Register base = addr-&gt;base()-&gt;as_pointer_register();
 239 
 240   if (addr-&gt;index()-&gt;is_illegal()) {
 241     return Address( base, addr-&gt;disp());
 242   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 243     Register index = addr-&gt;index()-&gt;as_pointer_register();
 244     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 245   } else if (addr-&gt;index()-&gt;is_constant()) {
 246     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 247     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 248 
 249     return Address(base, addr_offset);
 250   } else {
 251     Unimplemented();
 252     return Address();
 253   }
 254 }
 255 
 256 
 257 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 258   Address base = as_Address(addr);
 259   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 260 }
 261 
 262 
 263 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 264   return as_Address(addr);
 265 }
 266 
 267 
 268 void LIR_Assembler::osr_entry() {
 269   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 270   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 271   ValueStack* entry_state = osr_entry-&gt;state();
 272   int number_of_locks = entry_state-&gt;locks_size();
 273 
 274   // we jump here if osr happens with the interpreter
 275   // state set up to continue at the beginning of the
 276   // loop that triggered osr - in particular, we have
 277   // the following registers setup:
 278   //
 279   // rcx: osr buffer
 280   //
 281 
 282   // build frame
 283   ciMethod* m = compilation()-&gt;method();
 284   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 285 
 286   // OSR buffer is
 287   //
 288   // locals[nlocals-1..0]
 289   // monitors[0..number_of_locks]
 290   //
 291   // locals is a direct copy of the interpreter frame so in the osr buffer
 292   // so first slot in the local array is the last local from the interpreter
 293   // and last slot is local[0] (receiver) from the interpreter
 294   //
 295   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 296   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 297   // in the interpreter frame (the method lock if a sync method)
 298 
 299   // Initialize monitors in the compiled activation.
 300   //   rcx: pointer to osr buffer
 301   //
 302   // All other registers are dead at this point and the locals will be
 303   // copied into place by code emitted in the IR.
 304 
 305   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 306   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 307     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 308       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 309     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 310     // the OSR buffer using 2 word entries: first the lock and then
 311     // the oop.
 312     for (int i = 0; i &lt; number_of_locks; i++) {
 313       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 314 #ifdef ASSERT
 315       // verify the interpreter&#39;s monitor has a non-null object
 316       {
 317         Label L;
 318         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 319         __ jcc(Assembler::notZero, L);
 320         __ stop(&quot;locked object is NULL&quot;);
 321         __ bind(L);
 322       }
 323 #endif
 324       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 325       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 327       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 328     }
 329   }
 330 }
 331 
 332 
 333 // inline cache check; done before the frame is built.
 334 int LIR_Assembler::check_icache() {
 335   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 336   Register ic_klass = IC_Klass;
 337   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 338   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 339   if (!do_post_padding) {
 340     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 341     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 342   }
 343   int offset = __ offset();
 344   __ inline_cache_check(receiver, IC_Klass);
 345   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 346   if (do_post_padding) {
 347     // force alignment after the cache check.
 348     // It&#39;s been verified to be aligned if !VerifyOops
 349     __ align(CodeEntryAlignment);
 350   }
 351   return offset;
 352 }
 353 
 354 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 355   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 356   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 357 
 358   Label L_skip_barrier;
 359   Register klass = rscratch1;
 360   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 361   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 362 
 363   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 364   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 365 
 366   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 367 
 368   __ bind(L_skip_barrier);
 369 }
 370 
 371 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 372   jobject o = NULL;
 373   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 374   __ movoop(reg, o);
 375   patching_epilog(patch, lir_patch_normal, reg, info);
 376 }
 377 
 378 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 379   Metadata* o = NULL;
 380   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 381   __ mov_metadata(reg, o);
 382   patching_epilog(patch, lir_patch_normal, reg, info);
 383 }
 384 
 385 // This specifies the rsp decrement needed to build the frame
 386 int LIR_Assembler::initial_frame_size_in_bytes() const {
 387   // if rounding, must let FrameMap know!
 388 
 389   // The frame_map records size in slots (32bit word)
 390 
 391   // subtract two words to account for return address and link
 392   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 393 }
 394 
 395 
 396 int LIR_Assembler::emit_exception_handler() {
 397   // if the last instruction is a call (typically to do a throw which
 398   // is coming at the end after block reordering) the return address
 399   // must still point into the code area in order to avoid assertion
 400   // failures when searching for the corresponding bci =&gt; add a nop
 401   // (was bug 5/14/1999 - gri)
 402   __ nop();
 403 
 404   // generate code for exception handler
 405   address handler_base = __ start_a_stub(exception_handler_size());
 406   if (handler_base == NULL) {
 407     // not enough space left for the handler
 408     bailout(&quot;exception handler overflow&quot;);
 409     return -1;
 410   }
 411 
 412   int offset = code_offset();
 413 
 414   // the exception oop and pc are in rax, and rdx
 415   // no other registers need to be preserved, so invalidate them
 416   __ invalidate_registers(false, true, true, false, true, true);
 417 
 418   // check that there is really an exception
 419   __ verify_not_null_oop(rax);
 420 
 421   // search an exception handler (rax: exception oop, rdx: throwing pc)
 422   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 423   __ should_not_reach_here();
 424   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 425   __ end_a_stub();
 426 
 427   return offset;
 428 }
 429 
 430 
 431 // Emit the code to remove the frame from the stack in the exception
 432 // unwind path.
 433 int LIR_Assembler::emit_unwind_handler() {
 434 #ifndef PRODUCT
 435   if (CommentedAssembly) {
 436     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 437   }
 438 #endif
 439 
 440   int offset = code_offset();
 441 
 442   // Fetch the exception from TLS and clear out exception related thread state
 443   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 444   NOT_LP64(__ get_thread(rsi));
 445   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 446   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 447   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 448 
 449   __ bind(_unwind_handler_entry);
 450   __ verify_not_null_oop(rax);
 451   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 452     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 453   }
 454 
 455   // Preform needed unlocking
 456   MonitorExitStub* stub = NULL;
 457   if (method()-&gt;is_synchronized()) {
 458     monitor_address(0, FrameMap::rax_opr);
 459     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 460     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 461     __ bind(*stub-&gt;continuation());
 462   }
 463 
 464   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 465 #ifdef _LP64
 466     __ mov(rdi, r15_thread);
 467     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 468 #else
 469     __ get_thread(rax);
 470     __ movptr(Address(rsp, 0), rax);
 471     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 472 #endif
 473     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 474   }
 475 
 476   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 477     __ mov(rax, rbx);  // Restore the exception
 478   }
 479 
 480   // remove the activation and dispatch to the unwind handler
 481   __ remove_frame(initial_frame_size_in_bytes());
 482   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 483 
 484   // Emit the slow path assembly
 485   if (stub != NULL) {
 486     stub-&gt;emit_code(this);
 487   }
 488 
 489   return offset;
 490 }
 491 
 492 
 493 int LIR_Assembler::emit_deopt_handler() {
 494   // if the last instruction is a call (typically to do a throw which
 495   // is coming at the end after block reordering) the return address
 496   // must still point into the code area in order to avoid assertion
 497   // failures when searching for the corresponding bci =&gt; add a nop
 498   // (was bug 5/14/1999 - gri)
 499   __ nop();
 500 
 501   // generate code for exception handler
 502   address handler_base = __ start_a_stub(deopt_handler_size());
 503   if (handler_base == NULL) {
 504     // not enough space left for the handler
 505     bailout(&quot;deopt handler overflow&quot;);
 506     return -1;
 507   }
 508 
 509   int offset = code_offset();
 510   InternalAddress here(__ pc());
 511 
 512   __ pushptr(here.addr());
 513   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 514   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 515   __ end_a_stub();
 516 
 517   return offset;
 518 }
 519 
 520 
 521 void LIR_Assembler::return_op(LIR_Opr result) {
 522   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 523   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 524     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 525   }
 526 
 527   // Pop the stack before the safepoint code
 528   __ remove_frame(initial_frame_size_in_bytes());
 529 
 530   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 531     __ reserved_stack_check();
 532   }
 533 
 534   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 535 
 536   // Note: we do not need to round double result; float result has the right precision
 537   // the poll sets the condition code, but no data registers
 538 
 539 #ifdef _LP64
 540   const Register poll_addr = rscratch1;
 541   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 542 #else
 543   const Register poll_addr = rbx;
 544   assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 545   __ get_thread(poll_addr);
 546   __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 547 #endif
 548   __ relocate(relocInfo::poll_return_type);
 549   __ testl(rax, Address(poll_addr, 0));
 550   __ ret(0);
 551 }
 552 
 553 
 554 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 555   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 556   int offset = __ offset();
 557 #ifdef _LP64
 558   const Register poll_addr = rscratch1;
 559   __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 560 #else
 561   assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 562   const Register poll_addr = tmp-&gt;as_register();
 563   __ get_thread(poll_addr);
 564   __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 565 #endif
 566   add_debug_info_for_branch(info);
 567   __ relocate(relocInfo::poll_type);
 568   address pre_pc = __ pc();
 569   __ testl(rax, Address(poll_addr, 0));
 570   address post_pc = __ pc();
 571   guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 572   return offset;
 573 }
 574 
 575 
 576 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 577   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 578 }
 579 
 580 void LIR_Assembler::swap_reg(Register a, Register b) {
 581   __ xchgptr(a, b);
 582 }
 583 
 584 
 585 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 586   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 587   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 588   LIR_Const* c = src-&gt;as_constant_ptr();
 589 
 590   switch (c-&gt;type()) {
 591     case T_INT: {
 592       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 593       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 594       break;
 595     }
 596 
 597     case T_ADDRESS: {
 598       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 599       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 600       break;
 601     }
 602 
 603     case T_LONG: {
 604       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 605 #ifdef _LP64
 606       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 607 #else
 608       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 609       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 610 #endif // _LP64
 611       break;
 612     }
 613 
 614     case T_OBJECT: {
 615       if (patch_code != lir_patch_none) {
 616         jobject2reg_with_patching(dest-&gt;as_register(), info);
 617       } else {
 618         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 619       }
 620       break;
 621     }
 622 
 623     case T_METADATA: {
 624       if (patch_code != lir_patch_none) {
 625         klass2reg_with_patching(dest-&gt;as_register(), info);
 626       } else {
 627         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 628       }
 629       break;
 630     }
 631 
 632     case T_FLOAT: {
 633       if (dest-&gt;is_single_xmm()) {
 634         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 635           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 636         } else {
 637           __ movflt(dest-&gt;as_xmm_float_reg(),
 638                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 639         }
 640       } else {
 641 #ifndef _LP64
 642         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 643         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 644         if (c-&gt;is_zero_float()) {
 645           __ fldz();
 646         } else if (c-&gt;is_one_float()) {
 647           __ fld1();
 648         } else {
 649           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 650         }
 651 #else
 652         ShouldNotReachHere();
 653 #endif // !_LP64
 654       }
 655       break;
 656     }
 657 
 658     case T_DOUBLE: {
 659       if (dest-&gt;is_double_xmm()) {
 660         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 661           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 662         } else {
 663           __ movdbl(dest-&gt;as_xmm_double_reg(),
 664                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 665         }
 666       } else {
 667 #ifndef _LP64
 668         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 669         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 670         if (c-&gt;is_zero_double()) {
 671           __ fldz();
 672         } else if (c-&gt;is_one_double()) {
 673           __ fld1();
 674         } else {
 675           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 676         }
 677 #else
 678         ShouldNotReachHere();
 679 #endif // !_LP64
 680       }
 681       break;
 682     }
 683 
 684     default:
 685       ShouldNotReachHere();
 686   }
 687 }
 688 
 689 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 690   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 691   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 692   LIR_Const* c = src-&gt;as_constant_ptr();
 693 
 694   switch (c-&gt;type()) {
 695     case T_INT:  // fall through
 696     case T_FLOAT:
 697       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 698       break;
 699 
 700     case T_ADDRESS:
 701       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 702       break;
 703 
 704     case T_OBJECT:
 705       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 706       break;
 707 
 708     case T_LONG:  // fall through
 709     case T_DOUBLE:
 710 #ifdef _LP64
 711       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 712                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 713 #else
 714       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 715                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 716       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 717                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 718 #endif // _LP64
 719       break;
 720 
 721     default:
 722       ShouldNotReachHere();
 723   }
 724 }
 725 
 726 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 727   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 728   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 729   LIR_Const* c = src-&gt;as_constant_ptr();
 730   LIR_Address* addr = dest-&gt;as_address_ptr();
 731 
 732   int null_check_here = code_offset();
 733   switch (type) {
 734     case T_INT:    // fall through
 735     case T_FLOAT:
 736       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 737       break;
 738 
 739     case T_ADDRESS:
 740       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 741       break;
 742 
 743     case T_OBJECT:  // fall through
 744     case T_ARRAY:
 745       if (c-&gt;as_jobject() == NULL) {
 746         if (UseCompressedOops &amp;&amp; !wide) {
 747           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 748         } else {
 749 #ifdef _LP64
 750           __ xorptr(rscratch1, rscratch1);
 751           null_check_here = code_offset();
 752           __ movptr(as_Address(addr), rscratch1);
 753 #else
 754           __ movptr(as_Address(addr), NULL_WORD);
 755 #endif
 756         }
 757       } else {
 758         if (is_literal_address(addr)) {
 759           ShouldNotReachHere();
 760           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 761         } else {
 762 #ifdef _LP64
 763           __ movoop(rscratch1, c-&gt;as_jobject());
 764           if (UseCompressedOops &amp;&amp; !wide) {
 765             __ encode_heap_oop(rscratch1);
 766             null_check_here = code_offset();
 767             __ movl(as_Address_lo(addr), rscratch1);
 768           } else {
 769             null_check_here = code_offset();
 770             __ movptr(as_Address_lo(addr), rscratch1);
 771           }
 772 #else
 773           __ movoop(as_Address(addr), c-&gt;as_jobject());
 774 #endif
 775         }
 776       }
 777       break;
 778 
 779     case T_LONG:    // fall through
 780     case T_DOUBLE:
 781 #ifdef _LP64
 782       if (is_literal_address(addr)) {
 783         ShouldNotReachHere();
 784         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 785       } else {
 786         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 787         null_check_here = code_offset();
 788         __ movptr(as_Address_lo(addr), r10);
 789       }
 790 #else
 791       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 792       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 793       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 794 #endif // _LP64
 795       break;
 796 
 797     case T_BOOLEAN: // fall through
 798     case T_BYTE:
 799       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 800       break;
 801 
 802     case T_CHAR:    // fall through
 803     case T_SHORT:
 804       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 805       break;
 806 
 807     default:
 808       ShouldNotReachHere();
 809   };
 810 
 811   if (info != NULL) {
 812     add_debug_info_for_null_check(null_check_here, info);
 813   }
 814 }
 815 
 816 
 817 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 818   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 819   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 820 
 821   // move between cpu-registers
 822   if (dest-&gt;is_single_cpu()) {
 823 #ifdef _LP64
 824     if (src-&gt;type() == T_LONG) {
 825       // Can do LONG -&gt; OBJECT
 826       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 827       return;
 828     }
 829 #endif
 830     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 831     if (src-&gt;type() == T_OBJECT) {
 832       __ verify_oop(src-&gt;as_register());
 833     }
 834     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 835 
 836   } else if (dest-&gt;is_double_cpu()) {
 837 #ifdef _LP64
 838     if (is_reference_type(src-&gt;type())) {
 839       // Surprising to me but we can see move of a long to t_object
 840       __ verify_oop(src-&gt;as_register());
 841       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 842       return;
 843     }
 844 #endif
 845     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 846     Register f_lo = src-&gt;as_register_lo();
 847     Register f_hi = src-&gt;as_register_hi();
 848     Register t_lo = dest-&gt;as_register_lo();
 849     Register t_hi = dest-&gt;as_register_hi();
 850 #ifdef _LP64
 851     assert(f_hi == f_lo, &quot;must be same&quot;);
 852     assert(t_hi == t_lo, &quot;must be same&quot;);
 853     move_regs(f_lo, t_lo);
 854 #else
 855     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 856 
 857 
 858     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 859       swap_reg(f_lo, f_hi);
 860     } else if (f_hi == t_lo) {
 861       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 862       move_regs(f_hi, t_hi);
 863       move_regs(f_lo, t_lo);
 864     } else {
 865       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 866       move_regs(f_lo, t_lo);
 867       move_regs(f_hi, t_hi);
 868     }
 869 #endif // LP64
 870 
 871 #ifndef _LP64
 872     // special moves from fpu-register to xmm-register
 873     // necessary for method results
 874   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 875     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 876     __ fld_s(Address(rsp, 0));
 877   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 878     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 879     __ fld_d(Address(rsp, 0));
 880   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 881     __ fstp_s(Address(rsp, 0));
 882     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 883   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 884     __ fstp_d(Address(rsp, 0));
 885     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 886 #endif // !_LP64
 887 
 888     // move between xmm-registers
 889   } else if (dest-&gt;is_single_xmm()) {
 890     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 891     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 892   } else if (dest-&gt;is_double_xmm()) {
 893     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 894     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 895 
 896 #ifndef _LP64
 897     // move between fpu-registers (no instruction necessary because of fpu-stack)
 898   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 899     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 900     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 901 #endif // !_LP64
 902 
 903   } else {
 904     ShouldNotReachHere();
 905   }
 906 }
 907 
 908 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 909   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 910   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 911 
 912   if (src-&gt;is_single_cpu()) {
 913     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 914     if (is_reference_type(type)) {
 915       __ verify_oop(src-&gt;as_register());
 916       __ movptr (dst, src-&gt;as_register());
 917     } else if (type == T_METADATA || type == T_ADDRESS) {
 918       __ movptr (dst, src-&gt;as_register());
 919     } else {
 920       __ movl (dst, src-&gt;as_register());
 921     }
 922 
 923   } else if (src-&gt;is_double_cpu()) {
 924     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 925     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 926     __ movptr (dstLO, src-&gt;as_register_lo());
 927     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 928 
 929   } else if (src-&gt;is_single_xmm()) {
 930     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 931     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 932 
 933   } else if (src-&gt;is_double_xmm()) {
 934     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 935     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 936 
 937 #ifndef _LP64
 938   } else if (src-&gt;is_single_fpu()) {
 939     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 940     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 941     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 942     else                   __ fst_s  (dst_addr);
 943 
 944   } else if (src-&gt;is_double_fpu()) {
 945     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 946     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 947     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 948     else                   __ fst_d  (dst_addr);
 949 #endif // !_LP64
 950 
 951   } else {
 952     ShouldNotReachHere();
 953   }
 954 }
 955 
 956 
 957 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 958   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 959   PatchingStub* patch = NULL;
 960   Register compressed_src = rscratch1;
 961 
 962   if (is_reference_type(type)) {
 963     __ verify_oop(src-&gt;as_register());
 964 #ifdef _LP64
 965     if (UseCompressedOops &amp;&amp; !wide) {
 966       __ movptr(compressed_src, src-&gt;as_register());
 967       __ encode_heap_oop(compressed_src);
 968       if (patch_code != lir_patch_none) {
 969         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 970       }
 971     }
 972 #endif
 973   }
 974 
 975   if (patch_code != lir_patch_none) {
 976     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
 977     Address toa = as_Address(to_addr);
 978     assert(toa.disp() != 0, &quot;must have&quot;);
 979   }
 980 
 981   int null_check_here = code_offset();
 982   switch (type) {
 983     case T_FLOAT: {
 984 #ifdef _LP64
 985       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
 986       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
 987 #else
 988       if (src-&gt;is_single_xmm()) {
 989         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
 990       } else {
 991         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
 992         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 993         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
 994         else                    __ fst_s (as_Address(to_addr));
 995       }
 996 #endif // _LP64
 997       break;
 998     }
 999 
1000     case T_DOUBLE: {
1001 #ifdef _LP64
1002       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1003       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1004 #else
1005       if (src-&gt;is_double_xmm()) {
1006         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1007       } else {
1008         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1009         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1010         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1011         else                    __ fst_d (as_Address(to_addr));
1012       }
1013 #endif // _LP64
1014       break;
1015     }
1016 
1017     case T_ARRAY:   // fall through
1018     case T_OBJECT:  // fall through
1019       if (UseCompressedOops &amp;&amp; !wide) {
1020         __ movl(as_Address(to_addr), compressed_src);
1021       } else {
1022         __ movptr(as_Address(to_addr), src-&gt;as_register());
1023       }
1024       break;
1025     case T_METADATA:
1026       // We get here to store a method pointer to the stack to pass to
1027       // a dtrace runtime call. This can&#39;t work on 64 bit with
1028       // compressed klass ptrs: T_METADATA can be a compressed klass
1029       // ptr or a 64 bit method pointer.
1030       LP64_ONLY(ShouldNotReachHere());
1031       __ movptr(as_Address(to_addr), src-&gt;as_register());
1032       break;
1033     case T_ADDRESS:
1034       __ movptr(as_Address(to_addr), src-&gt;as_register());
1035       break;
1036     case T_INT:
1037       __ movl(as_Address(to_addr), src-&gt;as_register());
1038       break;
1039 
1040     case T_LONG: {
1041       Register from_lo = src-&gt;as_register_lo();
1042       Register from_hi = src-&gt;as_register_hi();
1043 #ifdef _LP64
1044       __ movptr(as_Address_lo(to_addr), from_lo);
1045 #else
1046       Register base = to_addr-&gt;base()-&gt;as_register();
1047       Register index = noreg;
1048       if (to_addr-&gt;index()-&gt;is_register()) {
1049         index = to_addr-&gt;index()-&gt;as_register();
1050       }
1051       if (base == from_lo || index == from_lo) {
1052         assert(base != from_hi, &quot;can&#39;t be&quot;);
1053         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1054         __ movl(as_Address_hi(to_addr), from_hi);
1055         if (patch != NULL) {
1056           patching_epilog(patch, lir_patch_high, base, info);
1057           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1058           patch_code = lir_patch_low;
1059         }
1060         __ movl(as_Address_lo(to_addr), from_lo);
1061       } else {
1062         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1063         __ movl(as_Address_lo(to_addr), from_lo);
1064         if (patch != NULL) {
1065           patching_epilog(patch, lir_patch_low, base, info);
1066           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1067           patch_code = lir_patch_high;
1068         }
1069         __ movl(as_Address_hi(to_addr), from_hi);
1070       }
1071 #endif // _LP64
1072       break;
1073     }
1074 
1075     case T_BYTE:    // fall through
1076     case T_BOOLEAN: {
1077       Register src_reg = src-&gt;as_register();
1078       Address dst_addr = as_Address(to_addr);
1079       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1080       __ movb(dst_addr, src_reg);
1081       break;
1082     }
1083 
1084     case T_CHAR:    // fall through
1085     case T_SHORT:
1086       __ movw(as_Address(to_addr), src-&gt;as_register());
1087       break;
1088 
1089     default:
1090       ShouldNotReachHere();
1091   }
1092   if (info != NULL) {
1093     add_debug_info_for_null_check(null_check_here, info);
1094   }
1095 
1096   if (patch_code != lir_patch_none) {
1097     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1098   }
1099 }
1100 
1101 
1102 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1103   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1104   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1105 
1106   if (dest-&gt;is_single_cpu()) {
1107     if (is_reference_type(type)) {
1108       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1109       __ verify_oop(dest-&gt;as_register());
1110     } else if (type == T_METADATA || type == T_ADDRESS) {
1111       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1112     } else {
1113       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1114     }
1115 
1116   } else if (dest-&gt;is_double_cpu()) {
1117     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1118     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1119     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1120     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1121 
1122   } else if (dest-&gt;is_single_xmm()) {
1123     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1124     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1125 
1126   } else if (dest-&gt;is_double_xmm()) {
1127     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1128     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1129 
1130 #ifndef _LP64
1131   } else if (dest-&gt;is_single_fpu()) {
1132     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1133     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1134     __ fld_s(src_addr);
1135 
1136   } else if (dest-&gt;is_double_fpu()) {
1137     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1138     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1139     __ fld_d(src_addr);
1140 #endif // _LP64
1141 
1142   } else {
1143     ShouldNotReachHere();
1144   }
1145 }
1146 
1147 
1148 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1149   if (src-&gt;is_single_stack()) {
1150     if (is_reference_type(type)) {
1151       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1152       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1153     } else {
1154 #ifndef _LP64
1155       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1156       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1157 #else
1158       //no pushl on 64bits
1159       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1160       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1161 #endif
1162     }
1163 
1164   } else if (src-&gt;is_double_stack()) {
1165 #ifdef _LP64
1166     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1167     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1168 #else
1169     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1170     // push and pop the part at src + wordSize, adding wordSize for the previous push
1171     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1172     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1173     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1174 #endif // _LP64
1175 
1176   } else {
1177     ShouldNotReachHere();
1178   }
1179 }
1180 
1181 
1182 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1183   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1184   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1185 
1186   LIR_Address* addr = src-&gt;as_address_ptr();
1187   Address from_addr = as_Address(addr);
<a name="1" id="anc1"></a><span class="line-added">1188   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
1189 
1190   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1191     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1192   }
1193 
1194   switch (type) {
1195     case T_BOOLEAN: // fall through
1196     case T_BYTE:    // fall through
1197     case T_CHAR:    // fall through
1198     case T_SHORT:
1199       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1200         // on pre P6 processors we may get partial register stalls
1201         // so blow away the value of to_rinfo before loading a
1202         // partial word into it.  Do it here so that it precedes
1203         // the potential patch point below.
1204         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1205       }
1206       break;
1207    default:
1208      break;
1209   }
1210 
1211   PatchingStub* patch = NULL;
1212   if (patch_code != lir_patch_none) {
1213     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1214     assert(from_addr.disp() != 0, &quot;must have&quot;);
1215   }
1216   if (info != NULL) {
1217     add_debug_info_for_null_check_here(info);
1218   }
1219 
1220   switch (type) {
1221     case T_FLOAT: {
1222       if (dest-&gt;is_single_xmm()) {
1223         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1224       } else {
1225 #ifndef _LP64
1226         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1227         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1228         __ fld_s(from_addr);
1229 #else
1230         ShouldNotReachHere();
1231 #endif // !LP64
1232       }
1233       break;
1234     }
1235 
1236     case T_DOUBLE: {
1237       if (dest-&gt;is_double_xmm()) {
1238         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1239       } else {
1240 #ifndef _LP64
1241         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1242         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1243         __ fld_d(from_addr);
1244 #else
1245         ShouldNotReachHere();
1246 #endif // !LP64
1247       }
1248       break;
1249     }
1250 
1251     case T_OBJECT:  // fall through
1252     case T_ARRAY:   // fall through
1253       if (UseCompressedOops &amp;&amp; !wide) {
1254         __ movl(dest-&gt;as_register(), from_addr);
1255       } else {
1256         __ movptr(dest-&gt;as_register(), from_addr);
1257       }
1258       break;
1259 
1260     case T_ADDRESS:
1261       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1262         __ movl(dest-&gt;as_register(), from_addr);
1263       } else {
1264         __ movptr(dest-&gt;as_register(), from_addr);
1265       }
1266       break;
1267     case T_INT:
1268       __ movl(dest-&gt;as_register(), from_addr);
1269       break;
1270 
1271     case T_LONG: {
1272       Register to_lo = dest-&gt;as_register_lo();
1273       Register to_hi = dest-&gt;as_register_hi();
1274 #ifdef _LP64
1275       __ movptr(to_lo, as_Address_lo(addr));
1276 #else
1277       Register base = addr-&gt;base()-&gt;as_register();
1278       Register index = noreg;
1279       if (addr-&gt;index()-&gt;is_register()) {
1280         index = addr-&gt;index()-&gt;as_register();
1281       }
1282       if ((base == to_lo &amp;&amp; index == to_hi) ||
1283           (base == to_hi &amp;&amp; index == to_lo)) {
1284         // addresses with 2 registers are only formed as a result of
1285         // array access so this code will never have to deal with
1286         // patches or null checks.
1287         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1288         __ lea(to_hi, as_Address(addr));
1289         __ movl(to_lo, Address(to_hi, 0));
1290         __ movl(to_hi, Address(to_hi, BytesPerWord));
1291       } else if (base == to_lo || index == to_lo) {
1292         assert(base != to_hi, &quot;can&#39;t be&quot;);
1293         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1294         __ movl(to_hi, as_Address_hi(addr));
1295         if (patch != NULL) {
1296           patching_epilog(patch, lir_patch_high, base, info);
1297           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1298           patch_code = lir_patch_low;
1299         }
1300         __ movl(to_lo, as_Address_lo(addr));
1301       } else {
1302         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1303         __ movl(to_lo, as_Address_lo(addr));
1304         if (patch != NULL) {
1305           patching_epilog(patch, lir_patch_low, base, info);
1306           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1307           patch_code = lir_patch_high;
1308         }
1309         __ movl(to_hi, as_Address_hi(addr));
1310       }
1311 #endif // _LP64
1312       break;
1313     }
1314 
1315     case T_BOOLEAN: // fall through
1316     case T_BYTE: {
1317       Register dest_reg = dest-&gt;as_register();
1318       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1319       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1320         __ movsbl(dest_reg, from_addr);
1321       } else {
1322         __ movb(dest_reg, from_addr);
1323         __ shll(dest_reg, 24);
1324         __ sarl(dest_reg, 24);
1325       }
1326       break;
1327     }
1328 
1329     case T_CHAR: {
1330       Register dest_reg = dest-&gt;as_register();
1331       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1332       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1333         __ movzwl(dest_reg, from_addr);
1334       } else {
1335         __ movw(dest_reg, from_addr);
1336       }
1337       break;
1338     }
1339 
1340     case T_SHORT: {
1341       Register dest_reg = dest-&gt;as_register();
1342       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1343         __ movswl(dest_reg, from_addr);
1344       } else {
1345         __ movw(dest_reg, from_addr);
1346         __ shll(dest_reg, 16);
1347         __ sarl(dest_reg, 16);
1348       }
1349       break;
1350     }
1351 
1352     default:
1353       ShouldNotReachHere();
1354   }
1355 
1356   if (patch != NULL) {
1357     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1358   }
1359 
1360   if (is_reference_type(type)) {
1361 #ifdef _LP64
1362     if (UseCompressedOops &amp;&amp; !wide) {
1363       __ decode_heap_oop(dest-&gt;as_register());
1364     }
1365 #endif
1366 
1367     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1368     if (!UseZGC) {
1369       __ verify_oop(dest-&gt;as_register());
1370     }
1371   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1372 #ifdef _LP64
1373     if (UseCompressedClassPointers) {
<a name="2" id="anc2"></a><span class="line-modified">1374       __ decode_klass_not_null(dest-&gt;as_register(), tmp_load_klass);</span>
1375     }
1376 #endif
1377   }
1378 }
1379 
1380 
1381 NEEDS_CLEANUP; // This could be static?
1382 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1383   int elem_size = type2aelembytes(type);
1384   switch (elem_size) {
1385     case 1: return Address::times_1;
1386     case 2: return Address::times_2;
1387     case 4: return Address::times_4;
1388     case 8: return Address::times_8;
1389   }
1390   ShouldNotReachHere();
1391   return Address::no_scale;
1392 }
1393 
1394 
1395 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1396   switch (op-&gt;code()) {
1397     case lir_idiv:
1398     case lir_irem:
1399       arithmetic_idiv(op-&gt;code(),
1400                       op-&gt;in_opr1(),
1401                       op-&gt;in_opr2(),
1402                       op-&gt;in_opr3(),
1403                       op-&gt;result_opr(),
1404                       op-&gt;info());
1405       break;
1406     case lir_fmad:
1407       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1408               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1409               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1410               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1411       break;
1412     case lir_fmaf:
1413       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1414               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1415               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1416               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1417       break;
1418     default:      ShouldNotReachHere(); break;
1419   }
1420 }
1421 
1422 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1423 #ifdef ASSERT
1424   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1425   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1426   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1427 #endif
1428 
1429   if (op-&gt;cond() == lir_cond_always) {
1430     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1431     __ jmp (*(op-&gt;label()));
1432   } else {
1433     Assembler::Condition acond = Assembler::zero;
1434     if (op-&gt;code() == lir_cond_float_branch) {
1435       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1436       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1437       switch(op-&gt;cond()) {
1438         case lir_cond_equal:        acond = Assembler::equal;      break;
1439         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1440         case lir_cond_less:         acond = Assembler::below;      break;
1441         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1442         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1443         case lir_cond_greater:      acond = Assembler::above;      break;
1444         default:                         ShouldNotReachHere();
1445       }
1446     } else {
1447       switch (op-&gt;cond()) {
1448         case lir_cond_equal:        acond = Assembler::equal;       break;
1449         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1450         case lir_cond_less:         acond = Assembler::less;        break;
1451         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1452         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1453         case lir_cond_greater:      acond = Assembler::greater;     break;
1454         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1455         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1456         default:                         ShouldNotReachHere();
1457       }
1458     }
1459     __ jcc(acond,*(op-&gt;label()));
1460   }
1461 }
1462 
1463 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1464   LIR_Opr src  = op-&gt;in_opr();
1465   LIR_Opr dest = op-&gt;result_opr();
1466 
1467   switch (op-&gt;bytecode()) {
1468     case Bytecodes::_i2l:
1469 #ifdef _LP64
1470       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1471 #else
1472       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1473       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1474       __ sarl(dest-&gt;as_register_hi(), 31);
1475 #endif // LP64
1476       break;
1477 
1478     case Bytecodes::_l2i:
1479 #ifdef _LP64
1480       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1481 #else
1482       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1483 #endif
1484       break;
1485 
1486     case Bytecodes::_i2b:
1487       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1488       __ sign_extend_byte(dest-&gt;as_register());
1489       break;
1490 
1491     case Bytecodes::_i2c:
1492       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1493       __ andl(dest-&gt;as_register(), 0xFFFF);
1494       break;
1495 
1496     case Bytecodes::_i2s:
1497       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1498       __ sign_extend_short(dest-&gt;as_register());
1499       break;
1500 
1501 
1502 #ifdef _LP64
1503     case Bytecodes::_f2d:
1504       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1505       break;
1506 
1507     case Bytecodes::_d2f:
1508       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1509       break;
1510 
1511     case Bytecodes::_i2f:
1512       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1513       break;
1514 
1515     case Bytecodes::_i2d:
1516       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1517       break;
1518 
1519     case Bytecodes::_l2f:
1520       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1521       break;
1522 
1523     case Bytecodes::_l2d:
1524       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1525       break;
1526 
1527     case Bytecodes::_f2i:
1528       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1529       break;
1530 
1531     case Bytecodes::_d2i:
1532       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1533       break;
1534 
1535     case Bytecodes::_f2l:
1536       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1537       break;
1538 
1539     case Bytecodes::_d2l:
1540       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1541       break;
1542 #else
1543     case Bytecodes::_f2d:
1544     case Bytecodes::_d2f:
1545       if (dest-&gt;is_single_xmm()) {
1546         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1547       } else if (dest-&gt;is_double_xmm()) {
1548         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1549       } else {
1550         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1551         // do nothing (float result is rounded later through spilling)
1552       }
1553       break;
1554 
1555     case Bytecodes::_i2f:
1556     case Bytecodes::_i2d:
1557       if (dest-&gt;is_single_xmm()) {
1558         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1559       } else if (dest-&gt;is_double_xmm()) {
1560         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1561       } else {
1562         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1563         __ movl(Address(rsp, 0), src-&gt;as_register());
1564         __ fild_s(Address(rsp, 0));
1565       }
1566       break;
1567 
1568     case Bytecodes::_l2f:
1569     case Bytecodes::_l2d:
1570       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1571       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1572       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1573       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1574       __ fild_d(Address(rsp, 0));
1575       // float result is rounded later through spilling
1576       break;
1577 
1578     case Bytecodes::_f2i:
1579     case Bytecodes::_d2i:
1580       if (src-&gt;is_single_xmm()) {
1581         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1582       } else if (src-&gt;is_double_xmm()) {
1583         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1584       } else {
1585         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1586         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1587         __ fist_s(Address(rsp, 0));
1588         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1589         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1590       }
1591       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1592       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1593       __ cmpl(dest-&gt;as_register(), 0x80000000);
1594       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1595       __ bind(*op-&gt;stub()-&gt;continuation());
1596       break;
1597 
1598     case Bytecodes::_f2l:
1599     case Bytecodes::_d2l:
1600       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1601       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1602       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1603 
1604       // instruction sequence too long to inline it here
1605       {
1606         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1607       }
1608       break;
1609 #endif // _LP64
1610 
1611     default: ShouldNotReachHere();
1612   }
1613 }
1614 
1615 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1616   if (op-&gt;init_check()) {
1617     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1618     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1619                     InstanceKlass::init_state_offset()),
1620                     InstanceKlass::fully_initialized);
1621     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1622   }
1623   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1624                      op-&gt;tmp1()-&gt;as_register(),
1625                      op-&gt;tmp2()-&gt;as_register(),
1626                      op-&gt;header_size(),
1627                      op-&gt;object_size(),
1628                      op-&gt;klass()-&gt;as_register(),
1629                      *op-&gt;stub()-&gt;entry());
1630   __ bind(*op-&gt;stub()-&gt;continuation());
1631 }
1632 
1633 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1634   Register len =  op-&gt;len()-&gt;as_register();
1635   LP64_ONLY( __ movslq(len, len); )
1636 
1637   if (UseSlowPath ||
1638       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1639       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1640     __ jmp(*op-&gt;stub()-&gt;entry());
1641   } else {
1642     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1643     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1644     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1645     if (len == tmp1) {
1646       tmp1 = tmp3;
1647     } else if (len == tmp2) {
1648       tmp2 = tmp3;
1649     } else if (len == tmp3) {
1650       // everything is ok
1651     } else {
1652       __ mov(tmp3, len);
1653     }
1654     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1655                       len,
1656                       tmp1,
1657                       tmp2,
1658                       arrayOopDesc::header_size(op-&gt;type()),
1659                       array_element_size(op-&gt;type()),
1660                       op-&gt;klass()-&gt;as_register(),
1661                       *op-&gt;stub()-&gt;entry());
1662   }
1663   __ bind(*op-&gt;stub()-&gt;continuation());
1664 }
1665 
1666 void LIR_Assembler::type_profile_helper(Register mdo,
1667                                         ciMethodData *md, ciProfileData *data,
1668                                         Register recv, Label* update_done) {
1669   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1670     Label next_test;
1671     // See if the receiver is receiver[n].
1672     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1673     __ jccb(Assembler::notEqual, next_test);
1674     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1675     __ addptr(data_addr, DataLayout::counter_increment);
1676     __ jmp(*update_done);
1677     __ bind(next_test);
1678   }
1679 
1680   // Didn&#39;t find receiver; find next empty slot and fill it in
1681   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1682     Label next_test;
1683     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1684     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1685     __ jccb(Assembler::notEqual, next_test);
1686     __ movptr(recv_addr, recv);
1687     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1688     __ jmp(*update_done);
1689     __ bind(next_test);
1690   }
1691 }
1692 
1693 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1694   // we always need a stub for the failure case.
1695   CodeStub* stub = op-&gt;stub();
1696   Register obj = op-&gt;object()-&gt;as_register();
1697   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1698   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1699   Register dst = op-&gt;result_opr()-&gt;as_register();
1700   ciKlass* k = op-&gt;klass();
1701   Register Rtmp1 = noreg;
<a name="3" id="anc3"></a><span class="line-added">1702   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
1703 
1704   // check if it needs to be profiled
1705   ciMethodData* md = NULL;
1706   ciProfileData* data = NULL;
1707 
1708   if (op-&gt;should_profile()) {
1709     ciMethod* method = op-&gt;profiled_method();
1710     assert(method != NULL, &quot;Should have method&quot;);
1711     int bci = op-&gt;profiled_bci();
1712     md = method-&gt;method_data_or_null();
1713     assert(md != NULL, &quot;Sanity&quot;);
1714     data = md-&gt;bci_to_data(bci);
1715     assert(data != NULL,                &quot;need data for type check&quot;);
1716     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1717   }
1718   Label profile_cast_success, profile_cast_failure;
1719   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1720   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1721 
1722   if (obj == k_RInfo) {
1723     k_RInfo = dst;
1724   } else if (obj == klass_RInfo) {
1725     klass_RInfo = dst;
1726   }
1727   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1728     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1729   } else {
1730     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1731     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1732   }
1733 
1734   assert_different_registers(obj, k_RInfo, klass_RInfo);
1735 
1736   __ cmpptr(obj, (int32_t)NULL_WORD);
1737   if (op-&gt;should_profile()) {
1738     Label not_null;
1739     __ jccb(Assembler::notEqual, not_null);
1740     // Object is null; update MDO and exit
1741     Register mdo  = klass_RInfo;
1742     __ mov_metadata(mdo, md-&gt;constant_encoding());
1743     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1744     int header_bits = BitData::null_seen_byte_constant();
1745     __ orb(data_addr, header_bits);
1746     __ jmp(*obj_is_null);
1747     __ bind(not_null);
1748   } else {
1749     __ jcc(Assembler::equal, *obj_is_null);
1750   }
1751 
1752   if (!k-&gt;is_loaded()) {
1753     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1754   } else {
1755 #ifdef _LP64
1756     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1757 #endif // _LP64
1758   }
1759   __ verify_oop(obj);
1760 
1761   if (op-&gt;fast_check()) {
1762     // get object class
1763     // not a safepoint as obj null check happens earlier
1764 #ifdef _LP64
1765     if (UseCompressedClassPointers) {
<a name="4" id="anc4"></a><span class="line-modified">1766       __ load_klass(Rtmp1, obj, tmp_load_klass);</span>
1767       __ cmpptr(k_RInfo, Rtmp1);
1768     } else {
1769       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1770     }
1771 #else
1772     if (k-&gt;is_loaded()) {
1773       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1774     } else {
1775       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1776     }
1777 #endif
1778     __ jcc(Assembler::notEqual, *failure_target);
1779     // successful cast, fall through to profile or jump
1780   } else {
1781     // get object class
1782     // not a safepoint as obj null check happens earlier
<a name="5" id="anc5"></a><span class="line-modified">1783     __ load_klass(klass_RInfo, obj, tmp_load_klass);</span>
1784     if (k-&gt;is_loaded()) {
1785       // See if we get an immediate positive hit
1786 #ifdef _LP64
1787       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1788 #else
1789       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1790 #endif // _LP64
1791       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1792         __ jcc(Assembler::notEqual, *failure_target);
1793         // successful cast, fall through to profile or jump
1794       } else {
1795         // See if we get an immediate positive hit
1796         __ jcc(Assembler::equal, *success_target);
1797         // check for self
1798 #ifdef _LP64
1799         __ cmpptr(klass_RInfo, k_RInfo);
1800 #else
1801         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1802 #endif // _LP64
1803         __ jcc(Assembler::equal, *success_target);
1804 
1805         __ push(klass_RInfo);
1806 #ifdef _LP64
1807         __ push(k_RInfo);
1808 #else
1809         __ pushklass(k-&gt;constant_encoding());
1810 #endif // _LP64
1811         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1812         __ pop(klass_RInfo);
1813         __ pop(klass_RInfo);
1814         // result is a boolean
1815         __ cmpl(klass_RInfo, 0);
1816         __ jcc(Assembler::equal, *failure_target);
1817         // successful cast, fall through to profile or jump
1818       }
1819     } else {
1820       // perform the fast part of the checking logic
1821       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1822       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1823       __ push(klass_RInfo);
1824       __ push(k_RInfo);
1825       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1826       __ pop(klass_RInfo);
1827       __ pop(k_RInfo);
1828       // result is a boolean
1829       __ cmpl(k_RInfo, 0);
1830       __ jcc(Assembler::equal, *failure_target);
1831       // successful cast, fall through to profile or jump
1832     }
1833   }
1834   if (op-&gt;should_profile()) {
1835     Register mdo  = klass_RInfo, recv = k_RInfo;
1836     __ bind(profile_cast_success);
1837     __ mov_metadata(mdo, md-&gt;constant_encoding());
<a name="6" id="anc6"></a><span class="line-modified">1838     __ load_klass(recv, obj, tmp_load_klass);</span>
1839     type_profile_helper(mdo, md, data, recv, success);
1840     __ jmp(*success);
1841 
1842     __ bind(profile_cast_failure);
1843     __ mov_metadata(mdo, md-&gt;constant_encoding());
1844     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1845     __ subptr(counter_addr, DataLayout::counter_increment);
1846     __ jmp(*failure);
1847   }
1848   __ jmp(*success);
1849 }
1850 
1851 
1852 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
<a name="7" id="anc7"></a><span class="line-added">1853   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
1854   LIR_Code code = op-&gt;code();
1855   if (code == lir_store_check) {
1856     Register value = op-&gt;object()-&gt;as_register();
1857     Register array = op-&gt;array()-&gt;as_register();
1858     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1859     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1860     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1861 
1862     CodeStub* stub = op-&gt;stub();
1863 
1864     // check if it needs to be profiled
1865     ciMethodData* md = NULL;
1866     ciProfileData* data = NULL;
1867 
1868     if (op-&gt;should_profile()) {
1869       ciMethod* method = op-&gt;profiled_method();
1870       assert(method != NULL, &quot;Should have method&quot;);
1871       int bci = op-&gt;profiled_bci();
1872       md = method-&gt;method_data_or_null();
1873       assert(md != NULL, &quot;Sanity&quot;);
1874       data = md-&gt;bci_to_data(bci);
1875       assert(data != NULL,                &quot;need data for type check&quot;);
1876       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1877     }
1878     Label profile_cast_success, profile_cast_failure, done;
1879     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1880     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1881 
1882     __ cmpptr(value, (int32_t)NULL_WORD);
1883     if (op-&gt;should_profile()) {
1884       Label not_null;
1885       __ jccb(Assembler::notEqual, not_null);
1886       // Object is null; update MDO and exit
1887       Register mdo  = klass_RInfo;
1888       __ mov_metadata(mdo, md-&gt;constant_encoding());
1889       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1890       int header_bits = BitData::null_seen_byte_constant();
1891       __ orb(data_addr, header_bits);
1892       __ jmp(done);
1893       __ bind(not_null);
1894     } else {
1895       __ jcc(Assembler::equal, done);
1896     }
1897 
1898     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
<a name="8" id="anc8"></a><span class="line-modified">1899     __ load_klass(k_RInfo, array, tmp_load_klass);</span>
<span class="line-modified">1900     __ load_klass(klass_RInfo, value, tmp_load_klass);</span>
1901 
1902     // get instance klass (it&#39;s already uncompressed)
1903     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1904     // perform the fast part of the checking logic
1905     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1906     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1907     __ push(klass_RInfo);
1908     __ push(k_RInfo);
1909     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1910     __ pop(klass_RInfo);
1911     __ pop(k_RInfo);
1912     // result is a boolean
1913     __ cmpl(k_RInfo, 0);
1914     __ jcc(Assembler::equal, *failure_target);
1915     // fall through to the success case
1916 
1917     if (op-&gt;should_profile()) {
1918       Register mdo  = klass_RInfo, recv = k_RInfo;
1919       __ bind(profile_cast_success);
1920       __ mov_metadata(mdo, md-&gt;constant_encoding());
<a name="9" id="anc9"></a><span class="line-modified">1921       __ load_klass(recv, value, tmp_load_klass);</span>
1922       type_profile_helper(mdo, md, data, recv, &amp;done);
1923       __ jmpb(done);
1924 
1925       __ bind(profile_cast_failure);
1926       __ mov_metadata(mdo, md-&gt;constant_encoding());
1927       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1928       __ subptr(counter_addr, DataLayout::counter_increment);
1929       __ jmp(*stub-&gt;entry());
1930     }
1931 
1932     __ bind(done);
1933   } else
1934     if (code == lir_checkcast) {
1935       Register obj = op-&gt;object()-&gt;as_register();
1936       Register dst = op-&gt;result_opr()-&gt;as_register();
1937       Label success;
1938       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1939       __ bind(success);
1940       if (dst != obj) {
1941         __ mov(dst, obj);
1942       }
1943     } else
1944       if (code == lir_instanceof) {
1945         Register obj = op-&gt;object()-&gt;as_register();
1946         Register dst = op-&gt;result_opr()-&gt;as_register();
1947         Label success, failure, done;
1948         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1949         __ bind(failure);
1950         __ xorptr(dst, dst);
1951         __ jmpb(done);
1952         __ bind(success);
1953         __ movptr(dst, 1);
1954         __ bind(done);
1955       } else {
1956         ShouldNotReachHere();
1957       }
1958 
1959 }
1960 
1961 
1962 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1963   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1964     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1965     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1966     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1967     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1968     Register addr = op-&gt;addr()-&gt;as_register();
1969     __ lock();
1970     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1971 
1972   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1973     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1974     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1975     Register newval = op-&gt;new_value()-&gt;as_register();
1976     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
1977     assert(cmpval == rax, &quot;wrong register&quot;);
1978     assert(newval != NULL, &quot;new val must be register&quot;);
1979     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
1980     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
1981     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
1982 
1983     if ( op-&gt;code() == lir_cas_obj) {
1984 #ifdef _LP64
1985       if (UseCompressedOops) {
1986         __ encode_heap_oop(cmpval);
1987         __ mov(rscratch1, newval);
1988         __ encode_heap_oop(rscratch1);
1989         __ lock();
1990         // cmpval (rax) is implicitly used by this instruction
1991         __ cmpxchgl(rscratch1, Address(addr, 0));
1992       } else
1993 #endif
1994       {
1995         __ lock();
1996         __ cmpxchgptr(newval, Address(addr, 0));
1997       }
1998     } else {
1999       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2000       __ lock();
2001       __ cmpxchgl(newval, Address(addr, 0));
2002     }
2003 #ifdef _LP64
2004   } else if (op-&gt;code() == lir_cas_long) {
2005     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2006     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2007     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2008     assert(cmpval == rax, &quot;wrong register&quot;);
2009     assert(newval != NULL, &quot;new val must be register&quot;);
2010     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2011     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2012     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2013     __ lock();
2014     __ cmpxchgq(newval, Address(addr, 0));
2015 #endif // _LP64
2016   } else {
2017     Unimplemented();
2018   }
2019 }
2020 
2021 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2022   Assembler::Condition acond, ncond;
2023   switch (condition) {
2024     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2025     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2026     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2027     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2028     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2029     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2030     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2031     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2032     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2033                                 ShouldNotReachHere();
2034   }
2035 
2036   if (opr1-&gt;is_cpu_register()) {
2037     reg2reg(opr1, result);
2038   } else if (opr1-&gt;is_stack()) {
2039     stack2reg(opr1, result, result-&gt;type());
2040   } else if (opr1-&gt;is_constant()) {
2041     const2reg(opr1, result, lir_patch_none, NULL);
2042   } else {
2043     ShouldNotReachHere();
2044   }
2045 
2046   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2047     // optimized version that does not require a branch
2048     if (opr2-&gt;is_single_cpu()) {
2049       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2050       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2051     } else if (opr2-&gt;is_double_cpu()) {
2052       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2053       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2054       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2055       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2056     } else if (opr2-&gt;is_single_stack()) {
2057       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2058     } else if (opr2-&gt;is_double_stack()) {
2059       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2060       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2061     } else {
2062       ShouldNotReachHere();
2063     }
2064 
2065   } else {
2066     Label skip;
2067     __ jcc (acond, skip);
2068     if (opr2-&gt;is_cpu_register()) {
2069       reg2reg(opr2, result);
2070     } else if (opr2-&gt;is_stack()) {
2071       stack2reg(opr2, result, result-&gt;type());
2072     } else if (opr2-&gt;is_constant()) {
2073       const2reg(opr2, result, lir_patch_none, NULL);
2074     } else {
2075       ShouldNotReachHere();
2076     }
2077     __ bind(skip);
2078   }
2079 }
2080 
2081 
2082 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2083   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2084 
2085   if (left-&gt;is_single_cpu()) {
2086     assert(left == dest, &quot;left and dest must be equal&quot;);
2087     Register lreg = left-&gt;as_register();
2088 
2089     if (right-&gt;is_single_cpu()) {
2090       // cpu register - cpu register
2091       Register rreg = right-&gt;as_register();
2092       switch (code) {
2093         case lir_add: __ addl (lreg, rreg); break;
2094         case lir_sub: __ subl (lreg, rreg); break;
2095         case lir_mul: __ imull(lreg, rreg); break;
2096         default:      ShouldNotReachHere();
2097       }
2098 
2099     } else if (right-&gt;is_stack()) {
2100       // cpu register - stack
2101       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2102       switch (code) {
2103         case lir_add: __ addl(lreg, raddr); break;
2104         case lir_sub: __ subl(lreg, raddr); break;
2105         default:      ShouldNotReachHere();
2106       }
2107 
2108     } else if (right-&gt;is_constant()) {
2109       // cpu register - constant
2110       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2111       switch (code) {
2112         case lir_add: {
2113           __ incrementl(lreg, c);
2114           break;
2115         }
2116         case lir_sub: {
2117           __ decrementl(lreg, c);
2118           break;
2119         }
2120         default: ShouldNotReachHere();
2121       }
2122 
2123     } else {
2124       ShouldNotReachHere();
2125     }
2126 
2127   } else if (left-&gt;is_double_cpu()) {
2128     assert(left == dest, &quot;left and dest must be equal&quot;);
2129     Register lreg_lo = left-&gt;as_register_lo();
2130     Register lreg_hi = left-&gt;as_register_hi();
2131 
2132     if (right-&gt;is_double_cpu()) {
2133       // cpu register - cpu register
2134       Register rreg_lo = right-&gt;as_register_lo();
2135       Register rreg_hi = right-&gt;as_register_hi();
2136       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2137       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2138       switch (code) {
2139         case lir_add:
2140           __ addptr(lreg_lo, rreg_lo);
2141           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2142           break;
2143         case lir_sub:
2144           __ subptr(lreg_lo, rreg_lo);
2145           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2146           break;
2147         case lir_mul:
2148 #ifdef _LP64
2149           __ imulq(lreg_lo, rreg_lo);
2150 #else
2151           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2152           __ imull(lreg_hi, rreg_lo);
2153           __ imull(rreg_hi, lreg_lo);
2154           __ addl (rreg_hi, lreg_hi);
2155           __ mull (rreg_lo);
2156           __ addl (lreg_hi, rreg_hi);
2157 #endif // _LP64
2158           break;
2159         default:
2160           ShouldNotReachHere();
2161       }
2162 
2163     } else if (right-&gt;is_constant()) {
2164       // cpu register - constant
2165 #ifdef _LP64
2166       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2167       __ movptr(r10, (intptr_t) c);
2168       switch (code) {
2169         case lir_add:
2170           __ addptr(lreg_lo, r10);
2171           break;
2172         case lir_sub:
2173           __ subptr(lreg_lo, r10);
2174           break;
2175         default:
2176           ShouldNotReachHere();
2177       }
2178 #else
2179       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2180       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2181       switch (code) {
2182         case lir_add:
2183           __ addptr(lreg_lo, c_lo);
2184           __ adcl(lreg_hi, c_hi);
2185           break;
2186         case lir_sub:
2187           __ subptr(lreg_lo, c_lo);
2188           __ sbbl(lreg_hi, c_hi);
2189           break;
2190         default:
2191           ShouldNotReachHere();
2192       }
2193 #endif // _LP64
2194 
2195     } else {
2196       ShouldNotReachHere();
2197     }
2198 
2199   } else if (left-&gt;is_single_xmm()) {
2200     assert(left == dest, &quot;left and dest must be equal&quot;);
2201     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2202 
2203     if (right-&gt;is_single_xmm()) {
2204       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2205       switch (code) {
2206         case lir_add: __ addss(lreg, rreg);  break;
2207         case lir_sub: __ subss(lreg, rreg);  break;
2208         case lir_mul_strictfp: // fall through
2209         case lir_mul: __ mulss(lreg, rreg);  break;
2210         case lir_div_strictfp: // fall through
2211         case lir_div: __ divss(lreg, rreg);  break;
2212         default: ShouldNotReachHere();
2213       }
2214     } else {
2215       Address raddr;
2216       if (right-&gt;is_single_stack()) {
2217         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2218       } else if (right-&gt;is_constant()) {
2219         // hack for now
2220         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2221       } else {
2222         ShouldNotReachHere();
2223       }
2224       switch (code) {
2225         case lir_add: __ addss(lreg, raddr);  break;
2226         case lir_sub: __ subss(lreg, raddr);  break;
2227         case lir_mul_strictfp: // fall through
2228         case lir_mul: __ mulss(lreg, raddr);  break;
2229         case lir_div_strictfp: // fall through
2230         case lir_div: __ divss(lreg, raddr);  break;
2231         default: ShouldNotReachHere();
2232       }
2233     }
2234 
2235   } else if (left-&gt;is_double_xmm()) {
2236     assert(left == dest, &quot;left and dest must be equal&quot;);
2237 
2238     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2239     if (right-&gt;is_double_xmm()) {
2240       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2241       switch (code) {
2242         case lir_add: __ addsd(lreg, rreg);  break;
2243         case lir_sub: __ subsd(lreg, rreg);  break;
2244         case lir_mul_strictfp: // fall through
2245         case lir_mul: __ mulsd(lreg, rreg);  break;
2246         case lir_div_strictfp: // fall through
2247         case lir_div: __ divsd(lreg, rreg);  break;
2248         default: ShouldNotReachHere();
2249       }
2250     } else {
2251       Address raddr;
2252       if (right-&gt;is_double_stack()) {
2253         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2254       } else if (right-&gt;is_constant()) {
2255         // hack for now
2256         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2257       } else {
2258         ShouldNotReachHere();
2259       }
2260       switch (code) {
2261         case lir_add: __ addsd(lreg, raddr);  break;
2262         case lir_sub: __ subsd(lreg, raddr);  break;
2263         case lir_mul_strictfp: // fall through
2264         case lir_mul: __ mulsd(lreg, raddr);  break;
2265         case lir_div_strictfp: // fall through
2266         case lir_div: __ divsd(lreg, raddr);  break;
2267         default: ShouldNotReachHere();
2268       }
2269     }
2270 
2271 #ifndef _LP64
2272   } else if (left-&gt;is_single_fpu()) {
2273     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2274 
2275     if (right-&gt;is_single_fpu()) {
2276       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2277 
2278     } else {
2279       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2280       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2281 
2282       Address raddr;
2283       if (right-&gt;is_single_stack()) {
2284         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2285       } else if (right-&gt;is_constant()) {
2286         address const_addr = float_constant(right-&gt;as_jfloat());
2287         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2288         // hack for now
2289         raddr = __ as_Address(InternalAddress(const_addr));
2290       } else {
2291         ShouldNotReachHere();
2292       }
2293 
2294       switch (code) {
2295         case lir_add: __ fadd_s(raddr); break;
2296         case lir_sub: __ fsub_s(raddr); break;
2297         case lir_mul_strictfp: // fall through
2298         case lir_mul: __ fmul_s(raddr); break;
2299         case lir_div_strictfp: // fall through
2300         case lir_div: __ fdiv_s(raddr); break;
2301         default:      ShouldNotReachHere();
2302       }
2303     }
2304 
2305   } else if (left-&gt;is_double_fpu()) {
2306     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2307 
2308     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2309       // Double values require special handling for strictfp mul/div on x86
2310       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2311       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2312     }
2313 
2314     if (right-&gt;is_double_fpu()) {
2315       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2316 
2317     } else {
2318       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2319       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2320 
2321       Address raddr;
2322       if (right-&gt;is_double_stack()) {
2323         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2324       } else if (right-&gt;is_constant()) {
2325         // hack for now
2326         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2327       } else {
2328         ShouldNotReachHere();
2329       }
2330 
2331       switch (code) {
2332         case lir_add: __ fadd_d(raddr); break;
2333         case lir_sub: __ fsub_d(raddr); break;
2334         case lir_mul_strictfp: // fall through
2335         case lir_mul: __ fmul_d(raddr); break;
2336         case lir_div_strictfp: // fall through
2337         case lir_div: __ fdiv_d(raddr); break;
2338         default: ShouldNotReachHere();
2339       }
2340     }
2341 
2342     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2343       // Double values require special handling for strictfp mul/div on x86
2344       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2345       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2346     }
2347 #endif // !_LP64
2348 
2349   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2350     assert(left == dest, &quot;left and dest must be equal&quot;);
2351 
2352     Address laddr;
2353     if (left-&gt;is_single_stack()) {
2354       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2355     } else if (left-&gt;is_address()) {
2356       laddr = as_Address(left-&gt;as_address_ptr());
2357     } else {
2358       ShouldNotReachHere();
2359     }
2360 
2361     if (right-&gt;is_single_cpu()) {
2362       Register rreg = right-&gt;as_register();
2363       switch (code) {
2364         case lir_add: __ addl(laddr, rreg); break;
2365         case lir_sub: __ subl(laddr, rreg); break;
2366         default:      ShouldNotReachHere();
2367       }
2368     } else if (right-&gt;is_constant()) {
2369       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2370       switch (code) {
2371         case lir_add: {
2372           __ incrementl(laddr, c);
2373           break;
2374         }
2375         case lir_sub: {
2376           __ decrementl(laddr, c);
2377           break;
2378         }
2379         default: ShouldNotReachHere();
2380       }
2381     } else {
2382       ShouldNotReachHere();
2383     }
2384 
2385   } else {
2386     ShouldNotReachHere();
2387   }
2388 }
2389 
2390 #ifndef _LP64
2391 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2392   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2393   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2394   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2395 
2396   bool left_is_tos = (left_index == 0);
2397   bool dest_is_tos = (dest_index == 0);
2398   int non_tos_index = (left_is_tos ? right_index : left_index);
2399 
2400   switch (code) {
2401     case lir_add:
2402       if (pop_fpu_stack)       __ faddp(non_tos_index);
2403       else if (dest_is_tos)    __ fadd (non_tos_index);
2404       else                     __ fadda(non_tos_index);
2405       break;
2406 
2407     case lir_sub:
2408       if (left_is_tos) {
2409         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2410         else if (dest_is_tos)  __ fsub  (non_tos_index);
2411         else                   __ fsubra(non_tos_index);
2412       } else {
2413         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2414         else if (dest_is_tos)  __ fsubr (non_tos_index);
2415         else                   __ fsuba (non_tos_index);
2416       }
2417       break;
2418 
2419     case lir_mul_strictfp: // fall through
2420     case lir_mul:
2421       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2422       else if (dest_is_tos)    __ fmul (non_tos_index);
2423       else                     __ fmula(non_tos_index);
2424       break;
2425 
2426     case lir_div_strictfp: // fall through
2427     case lir_div:
2428       if (left_is_tos) {
2429         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2430         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2431         else                   __ fdivra(non_tos_index);
2432       } else {
2433         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2434         else if (dest_is_tos)  __ fdivr (non_tos_index);
2435         else                   __ fdiva (non_tos_index);
2436       }
2437       break;
2438 
2439     case lir_rem:
2440       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2441       __ fremr(noreg);
2442       break;
2443 
2444     default:
2445       ShouldNotReachHere();
2446   }
2447 }
2448 #endif // _LP64
2449 
2450 
2451 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2452   if (value-&gt;is_double_xmm()) {
2453     switch(code) {
2454       case lir_abs :
2455         {
2456 #ifdef _LP64
2457           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2458             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2459             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2460           } else
2461 #endif
2462           {
2463             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2464               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2465             }
2466             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2467             __ andpd(dest-&gt;as_xmm_double_reg(),
2468                      ExternalAddress((address)double_signmask_pool));
2469           }
2470         }
2471         break;
2472 
2473       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2474       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2475       default      : ShouldNotReachHere();
2476     }
2477 
2478 #ifndef _LP64
2479   } else if (value-&gt;is_double_fpu()) {
2480     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2481     switch(code) {
2482       case lir_abs   : __ fabs() ; break;
2483       case lir_sqrt  : __ fsqrt(); break;
2484       default      : ShouldNotReachHere();
2485     }
2486 #endif // !_LP64
2487   } else {
2488     Unimplemented();
2489   }
2490 }
2491 
2492 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2493   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2494   if (left-&gt;is_single_cpu()) {
2495     Register reg = left-&gt;as_register();
2496     if (right-&gt;is_constant()) {
2497       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2498       switch (code) {
2499         case lir_logic_and: __ andl (reg, val); break;
2500         case lir_logic_or:  __ orl  (reg, val); break;
2501         case lir_logic_xor: __ xorl (reg, val); break;
2502         default: ShouldNotReachHere();
2503       }
2504     } else if (right-&gt;is_stack()) {
2505       // added support for stack operands
2506       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2507       switch (code) {
2508         case lir_logic_and: __ andl (reg, raddr); break;
2509         case lir_logic_or:  __ orl  (reg, raddr); break;
2510         case lir_logic_xor: __ xorl (reg, raddr); break;
2511         default: ShouldNotReachHere();
2512       }
2513     } else {
2514       Register rright = right-&gt;as_register();
2515       switch (code) {
2516         case lir_logic_and: __ andptr (reg, rright); break;
2517         case lir_logic_or : __ orptr  (reg, rright); break;
2518         case lir_logic_xor: __ xorptr (reg, rright); break;
2519         default: ShouldNotReachHere();
2520       }
2521     }
2522     move_regs(reg, dst-&gt;as_register());
2523   } else {
2524     Register l_lo = left-&gt;as_register_lo();
2525     Register l_hi = left-&gt;as_register_hi();
2526     if (right-&gt;is_constant()) {
2527 #ifdef _LP64
2528       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2529       switch (code) {
2530         case lir_logic_and:
2531           __ andq(l_lo, rscratch1);
2532           break;
2533         case lir_logic_or:
2534           __ orq(l_lo, rscratch1);
2535           break;
2536         case lir_logic_xor:
2537           __ xorq(l_lo, rscratch1);
2538           break;
2539         default: ShouldNotReachHere();
2540       }
2541 #else
2542       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2543       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2544       switch (code) {
2545         case lir_logic_and:
2546           __ andl(l_lo, r_lo);
2547           __ andl(l_hi, r_hi);
2548           break;
2549         case lir_logic_or:
2550           __ orl(l_lo, r_lo);
2551           __ orl(l_hi, r_hi);
2552           break;
2553         case lir_logic_xor:
2554           __ xorl(l_lo, r_lo);
2555           __ xorl(l_hi, r_hi);
2556           break;
2557         default: ShouldNotReachHere();
2558       }
2559 #endif // _LP64
2560     } else {
2561 #ifdef _LP64
2562       Register r_lo;
2563       if (is_reference_type(right-&gt;type())) {
2564         r_lo = right-&gt;as_register();
2565       } else {
2566         r_lo = right-&gt;as_register_lo();
2567       }
2568 #else
2569       Register r_lo = right-&gt;as_register_lo();
2570       Register r_hi = right-&gt;as_register_hi();
2571       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2572 #endif
2573       switch (code) {
2574         case lir_logic_and:
2575           __ andptr(l_lo, r_lo);
2576           NOT_LP64(__ andptr(l_hi, r_hi);)
2577           break;
2578         case lir_logic_or:
2579           __ orptr(l_lo, r_lo);
2580           NOT_LP64(__ orptr(l_hi, r_hi);)
2581           break;
2582         case lir_logic_xor:
2583           __ xorptr(l_lo, r_lo);
2584           NOT_LP64(__ xorptr(l_hi, r_hi);)
2585           break;
2586         default: ShouldNotReachHere();
2587       }
2588     }
2589 
2590     Register dst_lo = dst-&gt;as_register_lo();
2591     Register dst_hi = dst-&gt;as_register_hi();
2592 
2593 #ifdef _LP64
2594     move_regs(l_lo, dst_lo);
2595 #else
2596     if (dst_lo == l_hi) {
2597       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2598       move_regs(l_hi, dst_hi);
2599       move_regs(l_lo, dst_lo);
2600     } else {
2601       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2602       move_regs(l_lo, dst_lo);
2603       move_regs(l_hi, dst_hi);
2604     }
2605 #endif // _LP64
2606   }
2607 }
2608 
2609 
2610 // we assume that rax, and rdx can be overwritten
2611 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2612 
2613   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2614   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2615   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2616 
2617   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2618   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2619 
2620   Register lreg = left-&gt;as_register();
2621   Register dreg = result-&gt;as_register();
2622 
2623   if (right-&gt;is_constant()) {
2624     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2625     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2626     if (code == lir_idiv) {
2627       assert(lreg == rax, &quot;must be rax,&quot;);
2628       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2629       __ cdql(); // sign extend into rdx:rax
2630       if (divisor == 2) {
2631         __ subl(lreg, rdx);
2632       } else {
2633         __ andl(rdx, divisor - 1);
2634         __ addl(lreg, rdx);
2635       }
2636       __ sarl(lreg, log2_jint(divisor));
2637       move_regs(lreg, dreg);
2638     } else if (code == lir_irem) {
2639       Label done;
2640       __ mov(dreg, lreg);
2641       __ andl(dreg, 0x80000000 | (divisor - 1));
2642       __ jcc(Assembler::positive, done);
2643       __ decrement(dreg);
2644       __ orl(dreg, ~(divisor - 1));
2645       __ increment(dreg);
2646       __ bind(done);
2647     } else {
2648       ShouldNotReachHere();
2649     }
2650   } else {
2651     Register rreg = right-&gt;as_register();
2652     assert(lreg == rax, &quot;left register must be rax,&quot;);
2653     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2654     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2655 
2656     move_regs(lreg, rax);
2657 
2658     int idivl_offset = __ corrected_idivl(rreg);
2659     if (ImplicitDiv0Checks) {
2660       add_debug_info_for_div0(idivl_offset, info);
2661     }
2662     if (code == lir_irem) {
2663       move_regs(rdx, dreg); // result is in rdx
2664     } else {
2665       move_regs(rax, dreg);
2666     }
2667   }
2668 }
2669 
2670 
2671 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2672   if (opr1-&gt;is_single_cpu()) {
2673     Register reg1 = opr1-&gt;as_register();
2674     if (opr2-&gt;is_single_cpu()) {
2675       // cpu register - cpu register
2676       if (is_reference_type(opr1-&gt;type())) {
2677         __ cmpoop(reg1, opr2-&gt;as_register());
2678       } else {
2679         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2680         __ cmpl(reg1, opr2-&gt;as_register());
2681       }
2682     } else if (opr2-&gt;is_stack()) {
2683       // cpu register - stack
2684       if (is_reference_type(opr1-&gt;type())) {
2685         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2686       } else {
2687         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2688       }
2689     } else if (opr2-&gt;is_constant()) {
2690       // cpu register - constant
2691       LIR_Const* c = opr2-&gt;as_constant_ptr();
2692       if (c-&gt;type() == T_INT) {
2693         __ cmpl(reg1, c-&gt;as_jint());
2694       } else if (c-&gt;type() == T_METADATA) {
2695         // All we need for now is a comparison with NULL for equality.
2696         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2697         Metadata* m = c-&gt;as_metadata();
2698         if (m == NULL) {
2699           __ cmpptr(reg1, (int32_t)0);
2700         } else {
2701           ShouldNotReachHere();
2702         }
2703       } else if (is_reference_type(c-&gt;type())) {
2704         // In 64bit oops are single register
2705         jobject o = c-&gt;as_jobject();
2706         if (o == NULL) {
2707           __ cmpptr(reg1, (int32_t)NULL_WORD);
2708         } else {
2709           __ cmpoop(reg1, o);
2710         }
2711       } else {
2712         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2713       }
2714       // cpu register - address
2715     } else if (opr2-&gt;is_address()) {
2716       if (op-&gt;info() != NULL) {
2717         add_debug_info_for_null_check_here(op-&gt;info());
2718       }
2719       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2720     } else {
2721       ShouldNotReachHere();
2722     }
2723 
2724   } else if(opr1-&gt;is_double_cpu()) {
2725     Register xlo = opr1-&gt;as_register_lo();
2726     Register xhi = opr1-&gt;as_register_hi();
2727     if (opr2-&gt;is_double_cpu()) {
2728 #ifdef _LP64
2729       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2730 #else
2731       // cpu register - cpu register
2732       Register ylo = opr2-&gt;as_register_lo();
2733       Register yhi = opr2-&gt;as_register_hi();
2734       __ subl(xlo, ylo);
2735       __ sbbl(xhi, yhi);
2736       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2737         __ orl(xhi, xlo);
2738       }
2739 #endif // _LP64
2740     } else if (opr2-&gt;is_constant()) {
2741       // cpu register - constant 0
2742       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2743 #ifdef _LP64
2744       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2745 #else
2746       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2747       __ orl(xhi, xlo);
2748 #endif // _LP64
2749     } else {
2750       ShouldNotReachHere();
2751     }
2752 
2753   } else if (opr1-&gt;is_single_xmm()) {
2754     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2755     if (opr2-&gt;is_single_xmm()) {
2756       // xmm register - xmm register
2757       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2758     } else if (opr2-&gt;is_stack()) {
2759       // xmm register - stack
2760       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2761     } else if (opr2-&gt;is_constant()) {
2762       // xmm register - constant
2763       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2764     } else if (opr2-&gt;is_address()) {
2765       // xmm register - address
2766       if (op-&gt;info() != NULL) {
2767         add_debug_info_for_null_check_here(op-&gt;info());
2768       }
2769       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2770     } else {
2771       ShouldNotReachHere();
2772     }
2773 
2774   } else if (opr1-&gt;is_double_xmm()) {
2775     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2776     if (opr2-&gt;is_double_xmm()) {
2777       // xmm register - xmm register
2778       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2779     } else if (opr2-&gt;is_stack()) {
2780       // xmm register - stack
2781       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2782     } else if (opr2-&gt;is_constant()) {
2783       // xmm register - constant
2784       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2785     } else if (opr2-&gt;is_address()) {
2786       // xmm register - address
2787       if (op-&gt;info() != NULL) {
2788         add_debug_info_for_null_check_here(op-&gt;info());
2789       }
2790       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2791     } else {
2792       ShouldNotReachHere();
2793     }
2794 
2795 #ifndef _LP64
2796   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2797     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2798     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2799     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2800 #endif // LP64
2801 
2802   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2803     LIR_Const* c = opr2-&gt;as_constant_ptr();
2804 #ifdef _LP64
2805     if (is_reference_type(c-&gt;type())) {
2806       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2807       __ movoop(rscratch1, c-&gt;as_jobject());
2808     }
2809 #endif // LP64
2810     if (op-&gt;info() != NULL) {
2811       add_debug_info_for_null_check_here(op-&gt;info());
2812     }
2813     // special case: address - constant
2814     LIR_Address* addr = opr1-&gt;as_address_ptr();
2815     if (c-&gt;type() == T_INT) {
2816       __ cmpl(as_Address(addr), c-&gt;as_jint());
2817     } else if (is_reference_type(c-&gt;type())) {
2818 #ifdef _LP64
2819       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2820       // better strategy by giving noreg as the temp for as_Address
2821       __ cmpoop(rscratch1, as_Address(addr, noreg));
2822 #else
2823       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2824 #endif // _LP64
2825     } else {
2826       ShouldNotReachHere();
2827     }
2828 
2829   } else {
2830     ShouldNotReachHere();
2831   }
2832 }
2833 
2834 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2835   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2836     if (left-&gt;is_single_xmm()) {
2837       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2838       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2839     } else if (left-&gt;is_double_xmm()) {
2840       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2841       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2842 
2843     } else {
2844 #ifdef _LP64
2845       ShouldNotReachHere();
2846 #else
2847       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2848       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2849 
2850       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2851       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2852                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2853 #endif // LP64
2854     }
2855   } else {
2856     assert(code == lir_cmp_l2i, &quot;check&quot;);
2857 #ifdef _LP64
2858     Label done;
2859     Register dest = dst-&gt;as_register();
2860     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2861     __ movl(dest, -1);
2862     __ jccb(Assembler::less, done);
2863     __ set_byte_if_not_zero(dest);
2864     __ movzbl(dest, dest);
2865     __ bind(done);
2866 #else
2867     __ lcmp2int(left-&gt;as_register_hi(),
2868                 left-&gt;as_register_lo(),
2869                 right-&gt;as_register_hi(),
2870                 right-&gt;as_register_lo());
2871     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2872 #endif // _LP64
2873   }
2874 }
2875 
2876 
2877 void LIR_Assembler::align_call(LIR_Code code) {
2878   // make sure that the displacement word of the call ends up word aligned
2879   int offset = __ offset();
2880   switch (code) {
2881   case lir_static_call:
2882   case lir_optvirtual_call:
2883   case lir_dynamic_call:
2884     offset += NativeCall::displacement_offset;
2885     break;
2886   case lir_icvirtual_call:
2887     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2888     break;
2889   case lir_virtual_call:  // currently, sparc-specific for niagara
2890   default: ShouldNotReachHere();
2891   }
2892   __ align(BytesPerWord, offset);
2893 }
2894 
2895 
2896 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2897   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2898          &quot;must be aligned&quot;);
2899   __ call(AddressLiteral(op-&gt;addr(), rtype));
2900   add_call_info(code_offset(), op-&gt;info());
2901 }
2902 
2903 
2904 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2905   __ ic_call(op-&gt;addr());
2906   add_call_info(code_offset(), op-&gt;info());
2907   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2908          &quot;must be aligned&quot;);
2909 }
2910 
2911 
2912 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2913 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2914   ShouldNotReachHere();
2915 }
2916 
2917 
2918 void LIR_Assembler::emit_static_call_stub() {
2919   address call_pc = __ pc();
2920   address stub = __ start_a_stub(call_stub_size());
2921   if (stub == NULL) {
2922     bailout(&quot;static call stub overflow&quot;);
2923     return;
2924   }
2925 
2926   int start = __ offset();
2927 
2928   // make sure that the displacement word of the call ends up word aligned
2929   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2930   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2931   __ mov_metadata(rbx, (Metadata*)NULL);
2932   // must be set to -1 at code generation time
2933   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2934   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2935   __ jump(RuntimeAddress(__ pc()));
2936 
2937   if (UseAOT) {
2938     // Trampoline to aot code
2939     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2940 #ifdef _LP64
2941     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2942 #else
2943     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2944 #endif
2945     __ jmp(rax);
2946   }
2947   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2948   __ end_a_stub();
2949 }
2950 
2951 
2952 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2953   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2954   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2955 
2956   // exception object is not added to oop map by LinearScan
2957   // (LinearScan assumes that no oops are in fixed registers)
2958   info-&gt;add_register_oop(exceptionOop);
2959   Runtime1::StubID unwind_id;
2960 
2961   // get current pc information
2962   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2963   int pc_for_athrow_offset = __ offset();
2964   InternalAddress pc_for_athrow(__ pc());
2965   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2966   add_call_info(pc_for_athrow_offset, info); // for exception handler
2967 
2968   __ verify_not_null_oop(rax);
2969   // search an exception handler (rax: exception oop, rdx: throwing pc)
2970   if (compilation()-&gt;has_fpu_code()) {
2971     unwind_id = Runtime1::handle_exception_id;
2972   } else {
2973     unwind_id = Runtime1::handle_exception_nofpu_id;
2974   }
2975   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2976 
2977   // enough room for two byte trap
2978   __ nop();
2979 }
2980 
2981 
2982 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2983   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2984 
2985   __ jmp(_unwind_handler_entry);
2986 }
2987 
2988 
2989 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2990 
2991   // optimized version for linear scan:
2992   // * count must be already in ECX (guaranteed by LinearScan)
2993   // * left and dest must be equal
2994   // * tmp must be unused
2995   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
2996   assert(left == dest, &quot;left and dest must be equal&quot;);
2997   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2998 
2999   if (left-&gt;is_single_cpu()) {
3000     Register value = left-&gt;as_register();
3001     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3002 
3003     switch (code) {
3004       case lir_shl:  __ shll(value); break;
3005       case lir_shr:  __ sarl(value); break;
3006       case lir_ushr: __ shrl(value); break;
3007       default: ShouldNotReachHere();
3008     }
3009   } else if (left-&gt;is_double_cpu()) {
3010     Register lo = left-&gt;as_register_lo();
3011     Register hi = left-&gt;as_register_hi();
3012     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3013 #ifdef _LP64
3014     switch (code) {
3015       case lir_shl:  __ shlptr(lo);        break;
3016       case lir_shr:  __ sarptr(lo);        break;
3017       case lir_ushr: __ shrptr(lo);        break;
3018       default: ShouldNotReachHere();
3019     }
3020 #else
3021 
3022     switch (code) {
3023       case lir_shl:  __ lshl(hi, lo);        break;
3024       case lir_shr:  __ lshr(hi, lo, true);  break;
3025       case lir_ushr: __ lshr(hi, lo, false); break;
3026       default: ShouldNotReachHere();
3027     }
3028 #endif // LP64
3029   } else {
3030     ShouldNotReachHere();
3031   }
3032 }
3033 
3034 
3035 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3036   if (dest-&gt;is_single_cpu()) {
3037     // first move left into dest so that left is not destroyed by the shift
3038     Register value = dest-&gt;as_register();
3039     count = count &amp; 0x1F; // Java spec
3040 
3041     move_regs(left-&gt;as_register(), value);
3042     switch (code) {
3043       case lir_shl:  __ shll(value, count); break;
3044       case lir_shr:  __ sarl(value, count); break;
3045       case lir_ushr: __ shrl(value, count); break;
3046       default: ShouldNotReachHere();
3047     }
3048   } else if (dest-&gt;is_double_cpu()) {
3049 #ifndef _LP64
3050     Unimplemented();
3051 #else
3052     // first move left into dest so that left is not destroyed by the shift
3053     Register value = dest-&gt;as_register_lo();
3054     count = count &amp; 0x1F; // Java spec
3055 
3056     move_regs(left-&gt;as_register_lo(), value);
3057     switch (code) {
3058       case lir_shl:  __ shlptr(value, count); break;
3059       case lir_shr:  __ sarptr(value, count); break;
3060       case lir_ushr: __ shrptr(value, count); break;
3061       default: ShouldNotReachHere();
3062     }
3063 #endif // _LP64
3064   } else {
3065     ShouldNotReachHere();
3066   }
3067 }
3068 
3069 
3070 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3071   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3072   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3073   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3074   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3075 }
3076 
3077 
3078 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3079   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3080   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3081   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3082   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3083 }
3084 
3085 
3086 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3087   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3088   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3089   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3090   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3091 }
3092 
3093 
3094 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3095   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3096   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3097   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3098   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3099 }
3100 
3101 
3102 // This code replaces a call to arraycopy; no exception may
3103 // be thrown in this code, they must be thrown in the System.arraycopy
3104 // activation frame; we could save some checks if this would not be the case
3105 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3106   ciArrayKlass* default_type = op-&gt;expected_type();
3107   Register src = op-&gt;src()-&gt;as_register();
3108   Register dst = op-&gt;dst()-&gt;as_register();
3109   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3110   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3111   Register length  = op-&gt;length()-&gt;as_register();
3112   Register tmp = op-&gt;tmp()-&gt;as_register();
<a name="10" id="anc10"></a><span class="line-added">3113   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
3114 
3115   __ resolve(ACCESS_READ, src);
3116   __ resolve(ACCESS_WRITE, dst);
3117 
3118   CodeStub* stub = op-&gt;stub();
3119   int flags = op-&gt;flags();
3120   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3121   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3122 
3123   // if we don&#39;t know anything, just go through the generic arraycopy
3124   if (default_type == NULL) {
3125     // save outgoing arguments on stack in case call to System.arraycopy is needed
3126     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3127     // for interpreter calling conventions. Now we have to do it in new style conventions.
3128     // For the moment until C1 gets the new register allocator I just force all the
3129     // args to the right place (except the register args) and then on the back side
3130     // reload the register args properly if we go slow path. Yuck
3131 
3132     // These are proper for the calling convention
3133     store_parameter(length, 2);
3134     store_parameter(dst_pos, 1);
3135     store_parameter(dst, 0);
3136 
3137     // these are just temporary placements until we need to reload
3138     store_parameter(src_pos, 3);
3139     store_parameter(src, 4);
3140     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3141 
3142     address copyfunc_addr = StubRoutines::generic_arraycopy();
3143     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3144 
3145     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3146 #ifdef _LP64
3147     // The arguments are in java calling convention so we can trivially shift them to C
3148     // convention
3149     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3150     __ mov(c_rarg0, j_rarg0);
3151     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3152     __ mov(c_rarg1, j_rarg1);
3153     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3154     __ mov(c_rarg2, j_rarg2);
3155     assert_different_registers(c_rarg3, j_rarg4);
3156     __ mov(c_rarg3, j_rarg3);
3157 #ifdef _WIN64
3158     // Allocate abi space for args but be sure to keep stack aligned
3159     __ subptr(rsp, 6*wordSize);
3160     store_parameter(j_rarg4, 4);
3161 #ifndef PRODUCT
3162     if (PrintC1Statistics) {
3163       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3164     }
3165 #endif
3166     __ call(RuntimeAddress(copyfunc_addr));
3167     __ addptr(rsp, 6*wordSize);
3168 #else
3169     __ mov(c_rarg4, j_rarg4);
3170 #ifndef PRODUCT
3171     if (PrintC1Statistics) {
3172       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3173     }
3174 #endif
3175     __ call(RuntimeAddress(copyfunc_addr));
3176 #endif // _WIN64
3177 #else
3178     __ push(length);
3179     __ push(dst_pos);
3180     __ push(dst);
3181     __ push(src_pos);
3182     __ push(src);
3183 
3184 #ifndef PRODUCT
3185     if (PrintC1Statistics) {
3186       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3187     }
3188 #endif
3189     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3190 
3191 #endif // _LP64
3192 
3193     __ cmpl(rax, 0);
3194     __ jcc(Assembler::equal, *stub-&gt;continuation());
3195 
3196     __ mov(tmp, rax);
3197     __ xorl(tmp, -1);
3198 
3199     // Reload values from the stack so they are where the stub
3200     // expects them.
3201     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3202     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3203     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3204     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3205     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3206 
3207     __ subl(length, tmp);
3208     __ addl(src_pos, tmp);
3209     __ addl(dst_pos, tmp);
3210     __ jmp(*stub-&gt;entry());
3211 
3212     __ bind(*stub-&gt;continuation());
3213     return;
3214   }
3215 
3216   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3217 
3218   int elem_size = type2aelembytes(basic_type);
3219   Address::ScaleFactor scale;
3220 
3221   switch (elem_size) {
3222     case 1 :
3223       scale = Address::times_1;
3224       break;
3225     case 2 :
3226       scale = Address::times_2;
3227       break;
3228     case 4 :
3229       scale = Address::times_4;
3230       break;
3231     case 8 :
3232       scale = Address::times_8;
3233       break;
3234     default:
3235       scale = Address::no_scale;
3236       ShouldNotReachHere();
3237   }
3238 
3239   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3240   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3241   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3242   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3243 
3244   // length and pos&#39;s are all sign extended at this point on 64bit
3245 
3246   // test for NULL
3247   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3248     __ testptr(src, src);
3249     __ jcc(Assembler::zero, *stub-&gt;entry());
3250   }
3251   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3252     __ testptr(dst, dst);
3253     __ jcc(Assembler::zero, *stub-&gt;entry());
3254   }
3255 
3256   // If the compiler was not able to prove that exact type of the source or the destination
3257   // of the arraycopy is an array type, check at runtime if the source or the destination is
3258   // an instance type.
3259   if (flags &amp; LIR_OpArrayCopy::type_check) {
3260     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<a name="11" id="anc11"></a><span class="line-modified">3261       __ load_klass(tmp, dst, tmp_load_klass);</span>
3262       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3263       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3264     }
3265 
3266     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<a name="12" id="anc12"></a><span class="line-modified">3267       __ load_klass(tmp, src, tmp_load_klass);</span>
3268       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3269       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3270     }
3271   }
3272 
3273   // check if negative
3274   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3275     __ testl(src_pos, src_pos);
3276     __ jcc(Assembler::less, *stub-&gt;entry());
3277   }
3278   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3279     __ testl(dst_pos, dst_pos);
3280     __ jcc(Assembler::less, *stub-&gt;entry());
3281   }
3282 
3283   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3284     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3285     __ cmpl(tmp, src_length_addr);
3286     __ jcc(Assembler::above, *stub-&gt;entry());
3287   }
3288   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3289     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3290     __ cmpl(tmp, dst_length_addr);
3291     __ jcc(Assembler::above, *stub-&gt;entry());
3292   }
3293 
3294   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3295     __ testl(length, length);
3296     __ jcc(Assembler::less, *stub-&gt;entry());
3297   }
3298 
3299 #ifdef _LP64
3300   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3301   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3302 #endif
3303 
3304   if (flags &amp; LIR_OpArrayCopy::type_check) {
3305     // We don&#39;t know the array types are compatible
3306     if (basic_type != T_OBJECT) {
3307       // Simple test for basic type arrays
3308       if (UseCompressedClassPointers) {
3309         __ movl(tmp, src_klass_addr);
3310         __ cmpl(tmp, dst_klass_addr);
3311       } else {
3312         __ movptr(tmp, src_klass_addr);
3313         __ cmpptr(tmp, dst_klass_addr);
3314       }
3315       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3316     } else {
3317       // For object arrays, if src is a sub class of dst then we can
3318       // safely do the copy.
3319       Label cont, slow;
3320 
3321       __ push(src);
3322       __ push(dst);
3323 
<a name="13" id="anc13"></a><span class="line-modified">3324       __ load_klass(src, src, tmp_load_klass);</span>
<span class="line-modified">3325       __ load_klass(dst, dst, tmp_load_klass);</span>
3326 
3327       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3328 
3329       __ push(src);
3330       __ push(dst);
3331       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3332       __ pop(dst);
3333       __ pop(src);
3334 
3335       __ cmpl(src, 0);
3336       __ jcc(Assembler::notEqual, cont);
3337 
3338       __ bind(slow);
3339       __ pop(dst);
3340       __ pop(src);
3341 
3342       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3343       if (copyfunc_addr != NULL) { // use stub if available
3344         // src is not a sub class of dst so we have to do a
3345         // per-element check.
3346 
3347         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3348         if ((flags &amp; mask) != mask) {
3349           // Check that at least both of them object arrays.
3350           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3351 
3352           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
<a name="14" id="anc14"></a><span class="line-modified">3353             __ load_klass(tmp, src, tmp_load_klass);</span>
3354           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
<a name="15" id="anc15"></a><span class="line-modified">3355             __ load_klass(tmp, dst, tmp_load_klass);</span>
3356           }
3357           int lh_offset = in_bytes(Klass::layout_helper_offset());
3358           Address klass_lh_addr(tmp, lh_offset);
3359           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3360           __ cmpl(klass_lh_addr, objArray_lh);
3361           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3362         }
3363 
3364        // Spill because stubs can use any register they like and it&#39;s
3365        // easier to restore just those that we care about.
3366        store_parameter(dst, 0);
3367        store_parameter(dst_pos, 1);
3368        store_parameter(length, 2);
3369        store_parameter(src_pos, 3);
3370        store_parameter(src, 4);
3371 
3372 #ifndef _LP64
3373         __ movptr(tmp, dst_klass_addr);
3374         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3375         __ push(tmp);
3376         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3377         __ push(tmp);
3378         __ push(length);
3379         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3380         __ push(tmp);
3381         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3382         __ push(tmp);
3383 
3384         __ call_VM_leaf(copyfunc_addr, 5);
3385 #else
3386         __ movl2ptr(length, length); //higher 32bits must be null
3387 
3388         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3389         assert_different_registers(c_rarg0, dst, dst_pos, length);
3390         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3391         assert_different_registers(c_rarg1, dst, length);
3392 
3393         __ mov(c_rarg2, length);
3394         assert_different_registers(c_rarg2, dst);
3395 
3396 #ifdef _WIN64
3397         // Allocate abi space for args but be sure to keep stack aligned
3398         __ subptr(rsp, 6*wordSize);
<a name="16" id="anc16"></a><span class="line-modified">3399         __ load_klass(c_rarg3, dst, tmp_load_klass);</span>
3400         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3401         store_parameter(c_rarg3, 4);
3402         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3403         __ call(RuntimeAddress(copyfunc_addr));
3404         __ addptr(rsp, 6*wordSize);
3405 #else
<a name="17" id="anc17"></a><span class="line-modified">3406         __ load_klass(c_rarg4, dst, tmp_load_klass);</span>
3407         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3408         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3409         __ call(RuntimeAddress(copyfunc_addr));
3410 #endif
3411 
3412 #endif
3413 
3414 #ifndef PRODUCT
3415         if (PrintC1Statistics) {
3416           Label failed;
3417           __ testl(rax, rax);
3418           __ jcc(Assembler::notZero, failed);
3419           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3420           __ bind(failed);
3421         }
3422 #endif
3423 
3424         __ testl(rax, rax);
3425         __ jcc(Assembler::zero, *stub-&gt;continuation());
3426 
3427 #ifndef PRODUCT
3428         if (PrintC1Statistics) {
3429           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3430         }
3431 #endif
3432 
3433         __ mov(tmp, rax);
3434 
3435         __ xorl(tmp, -1);
3436 
3437         // Restore previously spilled arguments
3438         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3439         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3440         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3441         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3442         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3443 
3444 
3445         __ subl(length, tmp);
3446         __ addl(src_pos, tmp);
3447         __ addl(dst_pos, tmp);
3448       }
3449 
3450       __ jmp(*stub-&gt;entry());
3451 
3452       __ bind(cont);
3453       __ pop(dst);
3454       __ pop(src);
3455     }
3456   }
3457 
3458 #ifdef ASSERT
3459   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3460     // Sanity check the known type with the incoming class.  For the
3461     // primitive case the types must match exactly with src.klass and
3462     // dst.klass each exactly matching the default type.  For the
3463     // object array case, if no type check is needed then either the
3464     // dst type is exactly the expected type and the src type is a
3465     // subtype which we can&#39;t check or src is the same array as dst
3466     // but not necessarily exactly of type default_type.
3467     Label known_ok, halt;
3468     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3469 #ifdef _LP64
3470     if (UseCompressedClassPointers) {
<a name="18" id="anc18"></a><span class="line-modified">3471       __ encode_klass_not_null(tmp, rscratch1);</span>
3472     }
3473 #endif
3474 
3475     if (basic_type != T_OBJECT) {
3476 
3477       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3478       else                   __ cmpptr(tmp, dst_klass_addr);
3479       __ jcc(Assembler::notEqual, halt);
3480       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3481       else                   __ cmpptr(tmp, src_klass_addr);
3482       __ jcc(Assembler::equal, known_ok);
3483     } else {
3484       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3485       else                   __ cmpptr(tmp, dst_klass_addr);
3486       __ jcc(Assembler::equal, known_ok);
3487       __ cmpptr(src, dst);
3488       __ jcc(Assembler::equal, known_ok);
3489     }
3490     __ bind(halt);
3491     __ stop(&quot;incorrect type information in arraycopy&quot;);
3492     __ bind(known_ok);
3493   }
3494 #endif
3495 
3496 #ifndef PRODUCT
3497   if (PrintC1Statistics) {
3498     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3499   }
3500 #endif
3501 
3502 #ifdef _LP64
3503   assert_different_registers(c_rarg0, dst, dst_pos, length);
3504   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3505   assert_different_registers(c_rarg1, length);
3506   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3507   __ mov(c_rarg2, length);
3508 
3509 #else
3510   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3511   store_parameter(tmp, 0);
3512   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3513   store_parameter(tmp, 1);
3514   store_parameter(length, 2);
3515 #endif // _LP64
3516 
3517   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3518   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3519   const char *name;
3520   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3521   __ call_VM_leaf(entry, 0);
3522 
3523   __ bind(*stub-&gt;continuation());
3524 }
3525 
3526 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3527   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3528   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3529   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3530   Register crc = op-&gt;crc()-&gt;as_register();
3531   Register val = op-&gt;val()-&gt;as_register();
3532   Register res = op-&gt;result_opr()-&gt;as_register();
3533 
3534   assert_different_registers(val, crc, res);
3535 
3536   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3537   __ notl(crc); // ~crc
3538   __ update_byte_crc32(crc, val, res);
3539   __ notl(crc); // ~crc
3540   __ mov(res, crc);
3541 }
3542 
3543 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3544   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3545   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3546   Register lock = op-&gt;lock_opr()-&gt;as_register();
3547   if (!UseFastLocking) {
3548     __ jmp(*op-&gt;stub()-&gt;entry());
3549   } else if (op-&gt;code() == lir_lock) {
3550     Register scratch = noreg;
3551     if (UseBiasedLocking) {
3552       scratch = op-&gt;scratch_opr()-&gt;as_register();
3553     }
3554     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3555     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3556     // add debug info for NullPointerException only if one is possible
3557     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3558     if (op-&gt;info() != NULL) {
3559       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3560     }
3561     // done
3562   } else if (op-&gt;code() == lir_unlock) {
3563     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3564     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3565   } else {
3566     Unimplemented();
3567   }
3568   __ bind(*op-&gt;stub()-&gt;continuation());
3569 }
3570 
3571 
3572 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3573   ciMethod* method = op-&gt;profiled_method();
3574   int bci          = op-&gt;profiled_bci();
3575   ciMethod* callee = op-&gt;profiled_callee();
<a name="19" id="anc19"></a><span class="line-added">3576   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
3577 
3578   // Update counter for all call types
3579   ciMethodData* md = method-&gt;method_data_or_null();
3580   assert(md != NULL, &quot;Sanity&quot;);
3581   ciProfileData* data = md-&gt;bci_to_data(bci);
3582   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3583   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3584   Register mdo  = op-&gt;mdo()-&gt;as_register();
3585   __ mov_metadata(mdo, md-&gt;constant_encoding());
3586   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3587   // Perform additional virtual call profiling for invokevirtual and
3588   // invokeinterface bytecodes
3589   if (op-&gt;should_profile_receiver_type()) {
3590     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3591     Register recv = op-&gt;recv()-&gt;as_register();
3592     assert_different_registers(mdo, recv);
3593     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3594     ciKlass* known_klass = op-&gt;known_holder();
3595     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3596       // We know the type that will be seen at this call site; we can
3597       // statically update the MethodData* rather than needing to do
3598       // dynamic tests on the receiver type
3599 
3600       // NOTE: we should probably put a lock around this search to
3601       // avoid collisions by concurrent compilations
3602       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3603       uint i;
3604       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3605         ciKlass* receiver = vc_data-&gt;receiver(i);
3606         if (known_klass-&gt;equals(receiver)) {
3607           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3608           __ addptr(data_addr, DataLayout::counter_increment);
3609           return;
3610         }
3611       }
3612 
3613       // Receiver type not found in profile data; select an empty slot
3614 
3615       // Note that this is less efficient than it should be because it
3616       // always does a write to the receiver part of the
3617       // VirtualCallData rather than just the first time
3618       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3619         ciKlass* receiver = vc_data-&gt;receiver(i);
3620         if (receiver == NULL) {
3621           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3622           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3623           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3624           __ addptr(data_addr, DataLayout::counter_increment);
3625           return;
3626         }
3627       }
3628     } else {
<a name="20" id="anc20"></a><span class="line-modified">3629       __ load_klass(recv, recv, tmp_load_klass);</span>
3630       Label update_done;
3631       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3632       // Receiver did not match any saved receiver and there is no empty row for it.
3633       // Increment total counter to indicate polymorphic case.
3634       __ addptr(counter_addr, DataLayout::counter_increment);
3635 
3636       __ bind(update_done);
3637     }
3638   } else {
3639     // Static call
3640     __ addptr(counter_addr, DataLayout::counter_increment);
3641   }
3642 }
3643 
3644 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3645   Register obj = op-&gt;obj()-&gt;as_register();
3646   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
<a name="21" id="anc21"></a><span class="line-added">3647   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
3648   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3649   ciKlass* exact_klass = op-&gt;exact_klass();
3650   intptr_t current_klass = op-&gt;current_klass();
3651   bool not_null = op-&gt;not_null();
3652   bool no_conflict = op-&gt;no_conflict();
3653 
3654   Label update, next, none;
3655 
3656   bool do_null = !not_null;
3657   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3658   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3659 
3660   assert(do_null || do_update, &quot;why are we here?&quot;);
3661   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3662 
3663   __ verify_oop(obj);
3664 
3665   if (tmp != obj) {
3666     __ mov(tmp, obj);
3667   }
3668   if (do_null) {
3669     __ testptr(tmp, tmp);
3670     __ jccb(Assembler::notZero, update);
3671     if (!TypeEntries::was_null_seen(current_klass)) {
3672       __ orptr(mdo_addr, TypeEntries::null_seen);
3673     }
3674     if (do_update) {
3675 #ifndef ASSERT
3676       __ jmpb(next);
3677     }
3678 #else
3679       __ jmp(next);
3680     }
3681   } else {
3682     __ testptr(tmp, tmp);
3683     __ jcc(Assembler::notZero, update);
3684     __ stop(&quot;unexpect null obj&quot;);
3685 #endif
3686   }
3687 
3688   __ bind(update);
3689 
3690   if (do_update) {
3691 #ifdef ASSERT
3692     if (exact_klass != NULL) {
3693       Label ok;
<a name="22" id="anc22"></a><span class="line-modified">3694       __ load_klass(tmp, tmp, tmp_load_klass);</span>
3695       __ push(tmp);
3696       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3697       __ cmpptr(tmp, Address(rsp, 0));
3698       __ jcc(Assembler::equal, ok);
3699       __ stop(&quot;exact klass and actual klass differ&quot;);
3700       __ bind(ok);
3701       __ pop(tmp);
3702     }
3703 #endif
3704     if (!no_conflict) {
3705       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3706         if (exact_klass != NULL) {
3707           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3708         } else {
<a name="23" id="anc23"></a><span class="line-modified">3709           __ load_klass(tmp, tmp, tmp_load_klass);</span>
3710         }
3711 
3712         __ xorptr(tmp, mdo_addr);
3713         __ testptr(tmp, TypeEntries::type_klass_mask);
3714         // klass seen before, nothing to do. The unknown bit may have been
3715         // set already but no need to check.
3716         __ jccb(Assembler::zero, next);
3717 
3718         __ testptr(tmp, TypeEntries::type_unknown);
3719         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3720 
3721         if (TypeEntries::is_type_none(current_klass)) {
3722           __ cmpptr(mdo_addr, 0);
3723           __ jccb(Assembler::equal, none);
3724           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3725           __ jccb(Assembler::equal, none);
3726           // There is a chance that the checks above (re-reading profiling
3727           // data from memory) fail if another thread has just set the
3728           // profiling to this obj&#39;s klass
3729           __ xorptr(tmp, mdo_addr);
3730           __ testptr(tmp, TypeEntries::type_klass_mask);
3731           __ jccb(Assembler::zero, next);
3732         }
3733       } else {
3734         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3735                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3736 
3737         __ movptr(tmp, mdo_addr);
3738         __ testptr(tmp, TypeEntries::type_unknown);
3739         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3740       }
3741 
3742       // different than before. Cannot keep accurate profile.
3743       __ orptr(mdo_addr, TypeEntries::type_unknown);
3744 
3745       if (TypeEntries::is_type_none(current_klass)) {
3746         __ jmpb(next);
3747 
3748         __ bind(none);
3749         // first time here. Set profile type.
3750         __ movptr(mdo_addr, tmp);
3751       }
3752     } else {
3753       // There&#39;s a single possible klass at this profile point
3754       assert(exact_klass != NULL, &quot;should be&quot;);
3755       if (TypeEntries::is_type_none(current_klass)) {
3756         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3757         __ xorptr(tmp, mdo_addr);
3758         __ testptr(tmp, TypeEntries::type_klass_mask);
3759 #ifdef ASSERT
3760         __ jcc(Assembler::zero, next);
3761 
3762         {
3763           Label ok;
3764           __ push(tmp);
3765           __ cmpptr(mdo_addr, 0);
3766           __ jcc(Assembler::equal, ok);
3767           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3768           __ jcc(Assembler::equal, ok);
3769           // may have been set by another thread
3770           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3771           __ xorptr(tmp, mdo_addr);
3772           __ testptr(tmp, TypeEntries::type_mask);
3773           __ jcc(Assembler::zero, ok);
3774 
3775           __ stop(&quot;unexpected profiling mismatch&quot;);
3776           __ bind(ok);
3777           __ pop(tmp);
3778         }
3779 #else
3780         __ jccb(Assembler::zero, next);
3781 #endif
3782         // first time here. Set profile type.
3783         __ movptr(mdo_addr, tmp);
3784       } else {
3785         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3786                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3787 
3788         __ movptr(tmp, mdo_addr);
3789         __ testptr(tmp, TypeEntries::type_unknown);
3790         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3791 
3792         __ orptr(mdo_addr, TypeEntries::type_unknown);
3793       }
3794     }
3795 
3796     __ bind(next);
3797   }
3798 }
3799 
3800 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3801   Unimplemented();
3802 }
3803 
3804 
3805 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3806   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3807 }
3808 
3809 
3810 void LIR_Assembler::align_backward_branch_target() {
3811   __ align(BytesPerWord);
3812 }
3813 
3814 
3815 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3816   if (left-&gt;is_single_cpu()) {
3817     __ negl(left-&gt;as_register());
3818     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3819 
3820   } else if (left-&gt;is_double_cpu()) {
3821     Register lo = left-&gt;as_register_lo();
3822 #ifdef _LP64
3823     Register dst = dest-&gt;as_register_lo();
3824     __ movptr(dst, lo);
3825     __ negptr(dst);
3826 #else
3827     Register hi = left-&gt;as_register_hi();
3828     __ lneg(hi, lo);
3829     if (dest-&gt;as_register_lo() == hi) {
3830       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3831       move_regs(hi, dest-&gt;as_register_hi());
3832       move_regs(lo, dest-&gt;as_register_lo());
3833     } else {
3834       move_regs(lo, dest-&gt;as_register_lo());
3835       move_regs(hi, dest-&gt;as_register_hi());
3836     }
3837 #endif // _LP64
3838 
3839   } else if (dest-&gt;is_single_xmm()) {
3840 #ifdef _LP64
3841     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3842       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3843       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3844       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3845     }
3846     else
3847 #endif
3848     {
3849       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3850       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3851         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3852       }
3853       __ xorps(dest-&gt;as_xmm_float_reg(),
3854                ExternalAddress((address)float_signflip_pool));
3855     }
3856   } else if (dest-&gt;is_double_xmm()) {
3857 #ifdef _LP64
3858     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3859       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3860       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3861       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3862     }
3863     else
3864 #endif
3865     {
3866       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3867       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3868         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3869       }
3870       __ xorpd(dest-&gt;as_xmm_double_reg(),
3871                ExternalAddress((address)double_signflip_pool));
3872     }
3873 #ifndef _LP64
3874   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3875     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3876     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3877     __ fchs();
3878 #endif // !_LP64
3879 
3880   } else {
3881     ShouldNotReachHere();
3882   }
3883 }
3884 
3885 
3886 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3887   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3888   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3889 
3890   PatchingStub* patch = NULL;
3891   if (patch_code != lir_patch_none) {
3892     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3893   }
3894 
3895   Register reg = dest-&gt;as_pointer_register();
3896   LIR_Address* addr = src-&gt;as_address_ptr();
3897   __ lea(reg, as_Address(addr));
3898 
3899   if (patch != NULL) {
3900     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3901   }
3902 }
3903 
3904 
3905 
3906 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3907   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3908   __ call(RuntimeAddress(dest));
3909   if (info != NULL) {
3910     add_call_info_here(info);
3911   }
3912 }
3913 
3914 
3915 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3916   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3917 
3918   if (info != NULL) {
3919     add_debug_info_for_null_check_here(info);
3920   }
3921 
3922   if (src-&gt;is_double_xmm()) {
3923     if (dest-&gt;is_double_cpu()) {
3924 #ifdef _LP64
3925       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3926 #else
3927       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3928       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3929       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3930 #endif // _LP64
3931     } else if (dest-&gt;is_double_stack()) {
3932       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3933     } else if (dest-&gt;is_address()) {
3934       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3935     } else {
3936       ShouldNotReachHere();
3937     }
3938 
3939   } else if (dest-&gt;is_double_xmm()) {
3940     if (src-&gt;is_double_stack()) {
3941       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3942     } else if (src-&gt;is_address()) {
3943       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3944     } else {
3945       ShouldNotReachHere();
3946     }
3947 
3948 #ifndef _LP64
3949   } else if (src-&gt;is_double_fpu()) {
3950     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3951     if (dest-&gt;is_double_stack()) {
3952       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3953     } else if (dest-&gt;is_address()) {
3954       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3955     } else {
3956       ShouldNotReachHere();
3957     }
3958 
3959   } else if (dest-&gt;is_double_fpu()) {
3960     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3961     if (src-&gt;is_double_stack()) {
3962       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3963     } else if (src-&gt;is_address()) {
3964       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3965     } else {
3966       ShouldNotReachHere();
3967     }
3968 #endif // !_LP64
3969 
3970   } else {
3971     ShouldNotReachHere();
3972   }
3973 }
3974 
3975 #ifdef ASSERT
3976 // emit run-time assertion
3977 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3978   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3979 
3980   if (op-&gt;in_opr1()-&gt;is_valid()) {
3981     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3982     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3983   } else {
3984     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3985     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3986   }
3987 
3988   Label ok;
3989   if (op-&gt;condition() != lir_cond_always) {
3990     Assembler::Condition acond = Assembler::zero;
3991     switch (op-&gt;condition()) {
3992       case lir_cond_equal:        acond = Assembler::equal;       break;
3993       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
3994       case lir_cond_less:         acond = Assembler::less;        break;
3995       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
3996       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
3997       case lir_cond_greater:      acond = Assembler::greater;     break;
3998       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
3999       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4000       default:                    ShouldNotReachHere();
4001     }
4002     __ jcc(acond, ok);
4003   }
4004   if (op-&gt;halt()) {
4005     const char* str = __ code_string(op-&gt;msg());
4006     __ stop(str);
4007   } else {
4008     breakpoint();
4009   }
4010   __ bind(ok);
4011 }
4012 #endif
4013 
4014 void LIR_Assembler::membar() {
4015   // QQQ sparc TSO uses this,
4016   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4017 }
4018 
4019 void LIR_Assembler::membar_acquire() {
4020   // No x86 machines currently require load fences
4021 }
4022 
4023 void LIR_Assembler::membar_release() {
4024   // No x86 machines currently require store fences
4025 }
4026 
4027 void LIR_Assembler::membar_loadload() {
4028   // no-op
4029   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4030 }
4031 
4032 void LIR_Assembler::membar_storestore() {
4033   // no-op
4034   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4035 }
4036 
4037 void LIR_Assembler::membar_loadstore() {
4038   // no-op
4039   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4040 }
4041 
4042 void LIR_Assembler::membar_storeload() {
4043   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4044 }
4045 
4046 void LIR_Assembler::on_spin_wait() {
4047   __ pause ();
4048 }
4049 
4050 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4051   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4052 #ifdef _LP64
4053   // __ get_thread(result_reg-&gt;as_register_lo());
4054   __ mov(result_reg-&gt;as_register(), r15_thread);
4055 #else
4056   __ get_thread(result_reg-&gt;as_register());
4057 #endif // _LP64
4058 }
4059 
4060 
4061 void LIR_Assembler::peephole(LIR_List*) {
4062   // do nothing for now
4063 }
4064 
4065 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4066   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4067 
4068   if (data-&gt;type() == T_INT) {
4069     if (code == lir_xadd) {
4070       __ lock();
4071       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4072     } else {
4073       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4074     }
4075   } else if (data-&gt;is_oop()) {
4076     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4077     Register obj = data-&gt;as_register();
4078 #ifdef _LP64
4079     if (UseCompressedOops) {
4080       __ encode_heap_oop(obj);
4081       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4082       __ decode_heap_oop(obj);
4083     } else {
4084       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4085     }
4086 #else
4087     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4088 #endif
4089   } else if (data-&gt;type() == T_LONG) {
4090 #ifdef _LP64
4091     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4092     if (code == lir_xadd) {
4093       __ lock();
4094       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4095     } else {
4096       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4097     }
4098 #else
4099     ShouldNotReachHere();
4100 #endif
4101   } else {
4102     ShouldNotReachHere();
4103   }
4104 }
4105 
4106 #undef __
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
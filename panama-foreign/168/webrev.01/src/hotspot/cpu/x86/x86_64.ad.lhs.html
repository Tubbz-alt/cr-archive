<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
<a name="1" id="anc1"></a><span class="line-modified">  360   return UseCompressedOops || UseCompressedClassPointers;</span>
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
  482 }
  483 
  484 // EMIT_RM()
  485 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  486   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  487   cbuf.insts()-&gt;emit_int8(c);
  488 }
  489 
  490 // EMIT_CC()
  491 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  492   unsigned char c = (unsigned char) (f1 | f2);
  493   cbuf.insts()-&gt;emit_int8(c);
  494 }
  495 
  496 // EMIT_OPCODE()
  497 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  498   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  499 }
  500 
  501 // EMIT_OPCODE() w/ relocation information
  502 void emit_opcode(CodeBuffer &amp;cbuf,
  503                  int code, relocInfo::relocType reloc, int offset, int format)
  504 {
  505   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  506   emit_opcode(cbuf, code);
  507 }
  508 
  509 // EMIT_D8()
  510 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  511   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  512 }
  513 
  514 // EMIT_D16()
  515 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  516   cbuf.insts()-&gt;emit_int16(d16);
  517 }
  518 
  519 // EMIT_D32()
  520 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  521   cbuf.insts()-&gt;emit_int32(d32);
  522 }
  523 
  524 // EMIT_D64()
  525 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  526   cbuf.insts()-&gt;emit_int64(d64);
  527 }
  528 
  529 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  530 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  531                     int d32,
  532                     relocInfo::relocType reloc,
  533                     int format)
  534 {
  535   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  536   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  537   cbuf.insts()-&gt;emit_int32(d32);
  538 }
  539 
  540 // emit 32 bit value and construct relocation entry from RelocationHolder
  541 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  542 #ifdef ASSERT
  543   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  544       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  545     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  546     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  547   }
  548 #endif
  549   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  550   cbuf.insts()-&gt;emit_int32(d32);
  551 }
  552 
  553 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  554   address next_ip = cbuf.insts_end() + 4;
  555   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  556                  external_word_Relocation::spec(addr),
  557                  RELOC_DISP32);
  558 }
  559 
  560 
  561 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  562 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  563   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  564   cbuf.insts()-&gt;emit_int64(d64);
  565 }
  566 
  567 // emit 64 bit value and construct relocation entry from RelocationHolder
  568 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  569 #ifdef ASSERT
  570   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  571       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  572     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  573     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  574   }
  575 #endif
  576   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  577   cbuf.insts()-&gt;emit_int64(d64);
  578 }
  579 
  580 // Access stack slot for load or store
  581 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  582 {
  583   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  584   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  585     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  586     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  587     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  588   } else {
  589     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d32(cbuf, disp);     // Displacement // R/M byte
  592   }
  593 }
  594 
  595    // rRegI ereg, memory mem) %{    // emit_reg_mem
  596 void encode_RegMem(CodeBuffer &amp;cbuf,
  597                    int reg,
  598                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  599 {
  600   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  601   int regenc = reg &amp; 7;
  602   int baseenc = base &amp; 7;
  603   int indexenc = index &amp; 7;
  604 
  605   // There is no index &amp; no scale, use form without SIB byte
  606   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  607     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  608     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  609       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  610     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  611       // If 8-bit displacement, mode 0x1
  612       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  613       emit_d8(cbuf, disp);
  614     } else {
  615       // If 32-bit displacement
  616       if (base == -1) { // Special flag for absolute address
  617         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  618         if (disp_reloc != relocInfo::none) {
  619           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  620         } else {
  621           emit_d32(cbuf, disp);
  622         }
  623       } else {
  624         // Normal base + offset
  625         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  626         if (disp_reloc != relocInfo::none) {
  627           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  628         } else {
  629           emit_d32(cbuf, disp);
  630         }
  631       }
  632     }
  633   } else {
  634     // Else, encode with the SIB byte
  635     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  636     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  637       // If no displacement
  638       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  639       emit_rm(cbuf, scale, indexenc, baseenc);
  640     } else {
  641       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  642         // If 8-bit displacement, mode 0x1
  643         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  644         emit_rm(cbuf, scale, indexenc, baseenc);
  645         emit_d8(cbuf, disp);
  646       } else {
  647         // If 32-bit displacement
  648         if (base == 0x04 ) {
  649           emit_rm(cbuf, 0x2, regenc, 0x4);
  650           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  651         } else {
  652           emit_rm(cbuf, 0x2, regenc, 0x4);
  653           emit_rm(cbuf, scale, indexenc, baseenc); // *
  654         }
  655         if (disp_reloc != relocInfo::none) {
  656           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  657         } else {
  658           emit_d32(cbuf, disp);
  659         }
  660       }
  661     }
  662   }
  663 }
  664 
  665 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  666 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  667   Label exit;
  668   __ jccb(Assembler::noParity, exit);
  669   __ pushf();
  670   //
  671   // comiss/ucomiss instructions set ZF,PF,CF flags and
  672   // zero OF,AF,SF for NaN values.
  673   // Fixup flags by zeroing ZF,PF so that compare of NaN
  674   // values returns &#39;less than&#39; result (CF is set).
  675   // Leave the rest of flags unchanged.
  676   //
  677   //    7 6 5 4 3 2 1 0
  678   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  679   //    0 0 1 0 1 0 1 1   (0x2B)
  680   //
  681   __ andq(Address(rsp, 0), 0xffffff2b);
  682   __ popf();
  683   __ bind(exit);
  684 }
  685 
  686 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  687   Label done;
  688   __ movl(dst, -1);
  689   __ jcc(Assembler::parity, done);
  690   __ jcc(Assembler::below, done);
  691   __ setb(Assembler::notEqual, dst);
  692   __ movzbl(dst, dst);
  693   __ bind(done);
  694 }
  695 
  696 // Math.min()    # Math.max()
  697 // --------------------------
  698 // ucomis[s/d]   #
  699 // ja   -&gt; b     # a
  700 // jp   -&gt; NaN   # NaN
  701 // jb   -&gt; a     # b
  702 // je            #
  703 // |-jz -&gt; a | b # a &amp; b
  704 // |    -&gt; a     #
  705 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  706                      XMMRegister a, XMMRegister b,
  707                      XMMRegister xmmt, Register rt,
  708                      bool min, bool single) {
  709 
  710   Label nan, zero, below, above, done;
  711 
  712   if (single)
  713     __ ucomiss(a, b);
  714   else
  715     __ ucomisd(a, b);
  716 
  717   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  718     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  719   else
  720     __ jccb(Assembler::above, done);
  721 
  722   __ jccb(Assembler::parity, nan);  // PF=1
  723   __ jccb(Assembler::below, below); // CF=1
  724 
  725   // equal
  726   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  727   if (single) {
  728     __ ucomiss(a, xmmt);
  729     __ jccb(Assembler::equal, zero);
  730 
  731     __ movflt(dst, a);
  732     __ jmp(done);
  733   }
  734   else {
  735     __ ucomisd(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movdbl(dst, a);
  739     __ jmp(done);
  740   }
  741 
  742   __ bind(zero);
  743   if (min)
  744     __ vpor(dst, a, b, Assembler::AVX_128bit);
  745   else
  746     __ vpand(dst, a, b, Assembler::AVX_128bit);
  747 
  748   __ jmp(done);
  749 
  750   __ bind(above);
  751   if (single)
  752     __ movflt(dst, min ? b : a);
  753   else
  754     __ movdbl(dst, min ? b : a);
  755 
  756   __ jmp(done);
  757 
  758   __ bind(nan);
  759   if (single) {
  760     __ movl(rt, 0x7fc00000); // Float.NaN
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
  781 int ConstantTable::calculate_table_base_offset() const {
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  837       if (framesize &gt; 0) {
  838         st-&gt;print(&quot;\n\t&quot;);
  839         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  840       }
  841     }
  842   }
  843 
  844   if (VerifyStackAtCalls) {
  845     st-&gt;print(&quot;\n\t&quot;);
  846     framesize -= wordSize;
  847     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  848 #ifdef ASSERT
  849     st-&gt;print(&quot;\n\t&quot;);
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  872 
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);
  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
  901 {
  902   return MachNode::size(ra_); // too many variables; just compute it
  903                               // the hard way
  904 }
  905 
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
  926 
  927   if (framesize) {
  928     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  929     st-&gt;print(&quot;\t&quot;);
  930   }
  931 
  932   st-&gt;print_cr(&quot;popq    rbp&quot;);
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  955   // Remove word for return adr already pushed
  956   // and RBP
  957   framesize -= 2*wordSize;
  958 
  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here
  960 
  961   if (framesize) {
  962     emit_opcode(cbuf, Assembler::REX_W);
  963     if (framesize &lt; 0x80) {
  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  966       emit_d8(cbuf, framesize);
  967     } else {
  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
  970       emit_d32(cbuf, framesize);
  971     }
  972   }
  973 
  974   // popq rbp
  975   emit_opcode(cbuf, 0x58 | RBP_enc);
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
  990 {
  991   return MachNode::size(ra_); // too many variables; just compute it
  992                               // the hard way
  993 }
  994 
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
 1015 {
 1016   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1017 
 1018   if (OptoReg::is_stack(reg)) return rc_stack;
 1019 
 1020   VMReg r = OptoReg::as_VMReg(reg);
 1021 
 1022   if (r-&gt;is_Register()) return rc_int;
 1023 
 1024   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1025   return rc_float;
 1026 }
 1027 
 1028 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1029 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1030                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1031 
 1032 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1033                      int stack_offset, int reg, uint ireg, outputStream* st);
 1034 
 1035 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1036                                       int dst_offset, uint ireg, outputStream* st) {
 1037   if (cbuf) {
 1038     MacroAssembler _masm(cbuf);
 1039     switch (ireg) {
 1040     case Op_VecS:
 1041       __ movq(Address(rsp, -8), rax);
 1042       __ movl(rax, Address(rsp, src_offset));
 1043       __ movl(Address(rsp, dst_offset), rax);
 1044       __ movq(rax, Address(rsp, -8));
 1045       break;
 1046     case Op_VecD:
 1047       __ pushq(Address(rsp, src_offset));
 1048       __ popq (Address(rsp, dst_offset));
 1049       break;
 1050     case Op_VecX:
 1051       __ pushq(Address(rsp, src_offset));
 1052       __ popq (Address(rsp, dst_offset));
 1053       __ pushq(Address(rsp, src_offset+8));
 1054       __ popq (Address(rsp, dst_offset+8));
 1055       break;
 1056     case Op_VecY:
 1057       __ vmovdqu(Address(rsp, -32), xmm0);
 1058       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1059       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1060       __ vmovdqu(xmm0, Address(rsp, -32));
 1061       break;
 1062     case Op_VecZ:
 1063       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1064       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1065       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1066       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1067       break;
 1068     default:
 1069       ShouldNotReachHere();
 1070     }
 1071 #ifndef PRODUCT
 1072   } else {
 1073     switch (ireg) {
 1074     case Op_VecS:
 1075       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1076                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1077                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1078                 &quot;movq    rax, [rsp - #8]&quot;,
 1079                 src_offset, dst_offset);
 1080       break;
 1081     case Op_VecD:
 1082       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1083                 &quot;popq    [rsp + #%d]&quot;,
 1084                 src_offset, dst_offset);
 1085       break;
 1086      case Op_VecX:
 1087       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1088                 &quot;popq    [rsp + #%d]\n\t&quot;
 1089                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1090                 &quot;popq    [rsp + #%d]&quot;,
 1091                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1092       break;
 1093     case Op_VecY:
 1094       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1095                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1096                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1097                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1098                 src_offset, dst_offset);
 1099       break;
 1100     case Op_VecZ:
 1101       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1102                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1103                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1104                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1105                 src_offset, dst_offset);
 1106       break;
 1107     default:
 1108       ShouldNotReachHere();
 1109     }
 1110 #endif
 1111   }
 1112 }
 1113 
 1114 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1115                                        PhaseRegAlloc* ra_,
 1116                                        bool do_size,
 1117                                        outputStream* st) const {
 1118   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1119   // Get registers to move
 1120   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1121   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1122   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1123   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1124 
 1125   enum RC src_second_rc = rc_class(src_second);
 1126   enum RC src_first_rc = rc_class(src_first);
 1127   enum RC dst_second_rc = rc_class(dst_second);
 1128   enum RC dst_first_rc = rc_class(dst_first);
 1129 
 1130   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1131          &quot;must move at least 1 register&quot; );
 1132 
 1133   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1134     // Self copy, no move
 1135     return 0;
 1136   }
 1137   if (bottom_type()-&gt;isa_vect() != NULL) {
 1138     uint ireg = ideal_reg();
 1139     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1140     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1141     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1142       // mem -&gt; mem
 1143       int src_offset = ra_-&gt;reg2offset(src_first);
 1144       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1145       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1146     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1147       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1148     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1149       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1150       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1151     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1152       int stack_offset = ra_-&gt;reg2offset(src_first);
 1153       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1154     } else {
 1155       ShouldNotReachHere();
 1156     }
 1157     return 0;
 1158   }
 1159   if (src_first_rc == rc_stack) {
 1160     // mem -&gt;
 1161     if (dst_first_rc == rc_stack) {
 1162       // mem -&gt; mem
 1163       assert(src_second != dst_first, &quot;overlap&quot;);
 1164       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1165           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1166         // 64-bit
 1167         int src_offset = ra_-&gt;reg2offset(src_first);
 1168         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1169         if (cbuf) {
 1170           MacroAssembler _masm(cbuf);
 1171           __ pushq(Address(rsp, src_offset));
 1172           __ popq (Address(rsp, dst_offset));
 1173 #ifndef PRODUCT
 1174         } else {
 1175           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1176                     &quot;popq    [rsp + #%d]&quot;,
 1177                      src_offset, dst_offset);
 1178 #endif
 1179         }
 1180       } else {
 1181         // 32-bit
 1182         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1183         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1184         // No pushl/popl, so:
 1185         int src_offset = ra_-&gt;reg2offset(src_first);
 1186         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1187         if (cbuf) {
 1188           MacroAssembler _masm(cbuf);
 1189           __ movq(Address(rsp, -8), rax);
 1190           __ movl(rax, Address(rsp, src_offset));
 1191           __ movl(Address(rsp, dst_offset), rax);
 1192           __ movq(rax, Address(rsp, -8));
 1193 #ifndef PRODUCT
 1194         } else {
 1195           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1196                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1197                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1198                     &quot;movq    rax, [rsp - #8]&quot;,
 1199                      src_offset, dst_offset);
 1200 #endif
 1201         }
 1202       }
 1203       return 0;
 1204     } else if (dst_first_rc == rc_int) {
 1205       // mem -&gt; gpr
 1206       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1207           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1208         // 64-bit
 1209         int offset = ra_-&gt;reg2offset(src_first);
 1210         if (cbuf) {
 1211           MacroAssembler _masm(cbuf);
 1212           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1213 #ifndef PRODUCT
 1214         } else {
 1215           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1216                      Matcher::regName[dst_first],
 1217                      offset);
 1218 #endif
 1219         }
 1220       } else {
 1221         // 32-bit
 1222         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1223         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1224         int offset = ra_-&gt;reg2offset(src_first);
 1225         if (cbuf) {
 1226           MacroAssembler _masm(cbuf);
 1227           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1228 #ifndef PRODUCT
 1229         } else {
 1230           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1231                      Matcher::regName[dst_first],
 1232                      offset);
 1233 #endif
 1234         }
 1235       }
 1236       return 0;
 1237     } else if (dst_first_rc == rc_float) {
 1238       // mem-&gt; xmm
 1239       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1240           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1241         // 64-bit
 1242         int offset = ra_-&gt;reg2offset(src_first);
 1243         if (cbuf) {
 1244           MacroAssembler _masm(cbuf);
 1245           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1246 #ifndef PRODUCT
 1247         } else {
 1248           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1249                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1250                      Matcher::regName[dst_first],
 1251                      offset);
 1252 #endif
 1253         }
 1254       } else {
 1255         // 32-bit
 1256         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1257         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1258         int offset = ra_-&gt;reg2offset(src_first);
 1259         if (cbuf) {
 1260           MacroAssembler _masm(cbuf);
 1261           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1262 #ifndef PRODUCT
 1263         } else {
 1264           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1265                      Matcher::regName[dst_first],
 1266                      offset);
 1267 #endif
 1268         }
 1269       }
 1270       return 0;
 1271     }
 1272   } else if (src_first_rc == rc_int) {
 1273     // gpr -&gt;
 1274     if (dst_first_rc == rc_stack) {
 1275       // gpr -&gt; mem
 1276       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1277           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1278         // 64-bit
 1279         int offset = ra_-&gt;reg2offset(dst_first);
 1280         if (cbuf) {
 1281           MacroAssembler _masm(cbuf);
 1282           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1283 #ifndef PRODUCT
 1284         } else {
 1285           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1286                      offset,
 1287                      Matcher::regName[src_first]);
 1288 #endif
 1289         }
 1290       } else {
 1291         // 32-bit
 1292         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1293         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1294         int offset = ra_-&gt;reg2offset(dst_first);
 1295         if (cbuf) {
 1296           MacroAssembler _masm(cbuf);
 1297           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1298 #ifndef PRODUCT
 1299         } else {
 1300           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1301                      offset,
 1302                      Matcher::regName[src_first]);
 1303 #endif
 1304         }
 1305       }
 1306       return 0;
 1307     } else if (dst_first_rc == rc_int) {
 1308       // gpr -&gt; gpr
 1309       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1310           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1311         // 64-bit
 1312         if (cbuf) {
 1313           MacroAssembler _masm(cbuf);
 1314           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1315                   as_Register(Matcher::_regEncode[src_first]));
 1316 #ifndef PRODUCT
 1317         } else {
 1318           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1319                      Matcher::regName[dst_first],
 1320                      Matcher::regName[src_first]);
 1321 #endif
 1322         }
 1323         return 0;
 1324       } else {
 1325         // 32-bit
 1326         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1327         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1328         if (cbuf) {
 1329           MacroAssembler _masm(cbuf);
 1330           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1331                   as_Register(Matcher::_regEncode[src_first]));
 1332 #ifndef PRODUCT
 1333         } else {
 1334           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1335                      Matcher::regName[dst_first],
 1336                      Matcher::regName[src_first]);
 1337 #endif
 1338         }
 1339         return 0;
 1340       }
 1341     } else if (dst_first_rc == rc_float) {
 1342       // gpr -&gt; xmm
 1343       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1344           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1345         // 64-bit
 1346         if (cbuf) {
 1347           MacroAssembler _masm(cbuf);
 1348           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1349 #ifndef PRODUCT
 1350         } else {
 1351           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1352                      Matcher::regName[dst_first],
 1353                      Matcher::regName[src_first]);
 1354 #endif
 1355         }
 1356       } else {
 1357         // 32-bit
 1358         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1359         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1360         if (cbuf) {
 1361           MacroAssembler _masm(cbuf);
 1362           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1363 #ifndef PRODUCT
 1364         } else {
 1365           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1366                      Matcher::regName[dst_first],
 1367                      Matcher::regName[src_first]);
 1368 #endif
 1369         }
 1370       }
 1371       return 0;
 1372     }
 1373   } else if (src_first_rc == rc_float) {
 1374     // xmm -&gt;
 1375     if (dst_first_rc == rc_stack) {
 1376       // xmm -&gt; mem
 1377       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1378           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1379         // 64-bit
 1380         int offset = ra_-&gt;reg2offset(dst_first);
 1381         if (cbuf) {
 1382           MacroAssembler _masm(cbuf);
 1383           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1384 #ifndef PRODUCT
 1385         } else {
 1386           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1387                      offset,
 1388                      Matcher::regName[src_first]);
 1389 #endif
 1390         }
 1391       } else {
 1392         // 32-bit
 1393         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1394         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1395         int offset = ra_-&gt;reg2offset(dst_first);
 1396         if (cbuf) {
 1397           MacroAssembler _masm(cbuf);
 1398           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1399 #ifndef PRODUCT
 1400         } else {
 1401           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1402                      offset,
 1403                      Matcher::regName[src_first]);
 1404 #endif
 1405         }
 1406       }
 1407       return 0;
 1408     } else if (dst_first_rc == rc_int) {
 1409       // xmm -&gt; gpr
 1410       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1411           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1412         // 64-bit
 1413         if (cbuf) {
 1414           MacroAssembler _masm(cbuf);
 1415           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1416 #ifndef PRODUCT
 1417         } else {
 1418           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1419                      Matcher::regName[dst_first],
 1420                      Matcher::regName[src_first]);
 1421 #endif
 1422         }
 1423       } else {
 1424         // 32-bit
 1425         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1426         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1427         if (cbuf) {
 1428           MacroAssembler _masm(cbuf);
 1429           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1430 #ifndef PRODUCT
 1431         } else {
 1432           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1433                      Matcher::regName[dst_first],
 1434                      Matcher::regName[src_first]);
 1435 #endif
 1436         }
 1437       }
 1438       return 0;
 1439     } else if (dst_first_rc == rc_float) {
 1440       // xmm -&gt; xmm
 1441       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1442           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1443         // 64-bit
 1444         if (cbuf) {
 1445           MacroAssembler _masm(cbuf);
 1446           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1447 #ifndef PRODUCT
 1448         } else {
 1449           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1450                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1451                      Matcher::regName[dst_first],
 1452                      Matcher::regName[src_first]);
 1453 #endif
 1454         }
 1455       } else {
 1456         // 32-bit
 1457         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1458         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1459         if (cbuf) {
 1460           MacroAssembler _masm(cbuf);
 1461           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1462 #ifndef PRODUCT
 1463         } else {
 1464           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1465                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1466                      Matcher::regName[dst_first],
 1467                      Matcher::regName[src_first]);
 1468 #endif
 1469         }
 1470       }
 1471       return 0;
 1472     }
 1473   }
 1474 
 1475   assert(0,&quot; foo &quot;);
 1476   Unimplemented();
 1477   return 0;
 1478 }
 1479 
 1480 #ifndef PRODUCT
 1481 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1482   implementation(NULL, ra_, false, st);
 1483 }
 1484 #endif
 1485 
 1486 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1487   implementation(&amp;cbuf, ra_, false, NULL);
 1488 }
 1489 
 1490 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1491   return MachNode::size(ra_);
 1492 }
 1493 
 1494 //=============================================================================
 1495 #ifndef PRODUCT
 1496 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1497 {
 1498   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1499   int reg = ra_-&gt;get_reg_first(this);
 1500   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1501             Matcher::regName[reg], offset);
 1502 }
 1503 #endif
 1504 
 1505 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1506 {
 1507   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1508   int reg = ra_-&gt;get_encode(this);
 1509   if (offset &gt;= 0x80) {
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 
 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
 1550   uint insts_size = cbuf.insts_size();
 1551   if (UseCompressedClassPointers) {
<a name="2" id="anc2"></a><span class="line-modified"> 1552     masm.load_klass(rscratch1, j_rarg0);</span>
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
 1573 {
 1574   return MachNode::size(ra_); // too many variables; just compute it
 1575                               // the hard way
 1576 }
 1577 
 1578 
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
 1599   offset -= br_size;
 1600 
 1601   // the short version of jmpConUCF2 contains multiple branches,
 1602   // making the reach slightly less
 1603   if (rule == jmpConUCF2_rule)
 1604     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1605   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1606 }
 1607 
 1608 const bool Matcher::isSimpleConstant64(jlong value) {
 1609   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1610   //return value == (int) value;  // Cf. storeImmL and immL32.
 1611 
 1612   // Probably always true, even if a temp register is required.
 1613   return true;
 1614 }
 1615 
 1616 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1617 const bool Matcher::init_array_count_is_in_bytes = false;
 1618 
 1619 // No additional cost for CMOVL.
 1620 const int Matcher::long_cmove_cost() { return 0; }
 1621 
 1622 // No CMOVF/CMOVD with SSE2
 1623 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1624 
 1625 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1626 const bool Matcher::require_postalloc_expand = false;
 1627 
 1628 // Do we need to mask the count passed to shift instructions or does
 1629 // the cpu only look at the lower 5/6 bits anyway?
 1630 const bool Matcher::need_masked_shift_count = false;
 1631 
 1632 bool Matcher::narrow_oop_use_complex_address() {
 1633   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1634   return (LogMinObjAlignmentInBytes &lt;= 3);
 1635 }
 1636 
 1637 bool Matcher::narrow_klass_use_complex_address() {
 1638   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1639   return (LogKlassAlignmentInBytes &lt;= 3);
 1640 }
 1641 
 1642 bool Matcher::const_oop_prefer_decode() {
 1643   // Prefer ConN+DecodeN over ConP.
 1644   return true;
 1645 }
 1646 
 1647 bool Matcher::const_klass_prefer_decode() {
 1648   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1649   //       or condisider the following:
 1650   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1651   //return CompressedKlassPointers::base() == NULL;
 1652   return true;
 1653 }
 1654 
 1655 // Is it better to copy float constants, or load them directly from
 1656 // memory?  Intel can load a float constant from a direct address,
 1657 // requiring no extra registers.  Most RISCs will have to materialize
 1658 // an address into a register first, so they would do better to copy
 1659 // the constant from stack.
 1660 const bool Matcher::rematerialize_float_constants = true; // XXX
 1661 
 1662 // If CPU can load and store mis-aligned doubles directly then no
 1663 // fixup is needed.  Else we split the double into 2 integer pieces
 1664 // and move it piece-by-piece.  Only happens when passing doubles into
 1665 // C code as the Java calling convention forces doubles to be aligned.
 1666 const bool Matcher::misaligned_doubles_ok = true;
 1667 
 1668 // No-op on amd64
 1669 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1670 
 1671 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1672 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1673 
 1674 // Are floats conerted to double when stored to stack during deoptimization?
 1675 // On x64 it is stored without convertion so we can use normal access.
 1676 bool Matcher::float_in_double() { return false; }
 1677 
 1678 // Do ints take an entire long register or just half?
 1679 const bool Matcher::int_in_long = true;
 1680 
 1681 // Return whether or not this register is ever used as an argument.
 1682 // This function is used on startup to build the trampoline stubs in
 1683 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1684 // call in the trampoline, and arguments in those registers not be
 1685 // available to the callee.
 1686 bool Matcher::can_be_java_arg(int reg)
 1687 {
 1688   return
 1689     reg ==  RDI_num || reg == RDI_H_num ||
 1690     reg ==  RSI_num || reg == RSI_H_num ||
 1691     reg ==  RDX_num || reg == RDX_H_num ||
 1692     reg ==  RCX_num || reg == RCX_H_num ||
 1693     reg ==   R8_num || reg ==  R8_H_num ||
 1694     reg ==   R9_num || reg ==  R9_H_num ||
 1695     reg ==  R12_num || reg == R12_H_num ||
 1696     reg == XMM0_num || reg == XMM0b_num ||
 1697     reg == XMM1_num || reg == XMM1b_num ||
 1698     reg == XMM2_num || reg == XMM2b_num ||
 1699     reg == XMM3_num || reg == XMM3b_num ||
 1700     reg == XMM4_num || reg == XMM4b_num ||
 1701     reg == XMM5_num || reg == XMM5b_num ||
 1702     reg == XMM6_num || reg == XMM6b_num ||
 1703     reg == XMM7_num || reg == XMM7b_num;
 1704 }
 1705 
 1706 bool Matcher::is_spillable_arg(int reg)
 1707 {
 1708   return can_be_java_arg(reg);
 1709 }
 1710 
 1711 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1712   // In 64 bit mode a code which use multiply when
 1713   // devisor is constant is faster than hardware
 1714   // DIV instruction (it uses MulHiL).
 1715   return false;
 1716 }
 1717 
 1718 // Register for DIVI projection of divmodI
 1719 RegMask Matcher::divI_proj_mask() {
 1720   return INT_RAX_REG_mask();
 1721 }
 1722 
 1723 // Register for MODI projection of divmodI
 1724 RegMask Matcher::modI_proj_mask() {
 1725   return INT_RDX_REG_mask();
 1726 }
 1727 
 1728 // Register for DIVL projection of divmodL
 1729 RegMask Matcher::divL_proj_mask() {
 1730   return LONG_RAX_REG_mask();
 1731 }
 1732 
 1733 // Register for MODL projection of divmodL
 1734 RegMask Matcher::modL_proj_mask() {
 1735   return LONG_RDX_REG_mask();
 1736 }
 1737 
 1738 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1739 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1740     return NO_REG_mask();
 1741 }
 1742 
 1743 %}
 1744 
 1745 //----------ENCODING BLOCK-----------------------------------------------------
 1746 // This block specifies the encoding classes used by the compiler to
 1747 // output byte streams.  Encoding classes are parameterized macros
 1748 // used by Machine Instruction Nodes in order to generate the bit
 1749 // encoding of the instruction.  Operands specify their base encoding
 1750 // interface with the interface keyword.  There are currently
 1751 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1752 // COND_INTER.  REG_INTER causes an operand to generate a function
 1753 // which returns its register number when queried.  CONST_INTER causes
 1754 // an operand to generate a function which returns the value of the
 1755 // constant when queried.  MEMORY_INTER causes an operand to generate
 1756 // four functions which return the Base Register, the Index Register,
 1757 // the Scale Value, and the Offset Value of the operand when queried.
 1758 // COND_INTER causes an operand to generate six functions which return
 1759 // the encoding code (ie - encoding bits for the instruction)
 1760 // associated with each basic boolean condition for a conditional
 1761 // instruction.
 1762 //
 1763 // Instructions specify two basic values for encoding.  Again, a
 1764 // function is available to check if the constant displacement is an
 1765 // oop. They use the ins_encode keyword to specify their encoding
 1766 // classes (which must be a sequence of enc_class names, and their
 1767 // parameters, specified in the encoding block), and they use the
 1768 // opcode keyword to specify, in order, their primary, secondary, and
 1769 // tertiary opcode.  Only the opcode sections which a particular
 1770 // instruction needs for encoding need to be specified.
 1771 encode %{
 1772   // Build emit functions for each basic byte or larger field in the
 1773   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1774   // from C++ code in the enc_class source block.  Emit functions will
 1775   // live in the main source block for now.  In future, we can
 1776   // generalize this by adding a syntax that specifies the sizes of
 1777   // fields in an order, so that the adlc can build the emit functions
 1778   // automagically
 1779 
 1780   // Emit primary opcode
 1781   enc_class OpcP
 1782   %{
 1783     emit_opcode(cbuf, $primary);
 1784   %}
 1785 
 1786   // Emit secondary opcode
 1787   enc_class OpcS
 1788   %{
 1789     emit_opcode(cbuf, $secondary);
 1790   %}
 1791 
 1792   // Emit tertiary opcode
 1793   enc_class OpcT
 1794   %{
 1795     emit_opcode(cbuf, $tertiary);
 1796   %}
 1797 
 1798   // Emit opcode directly
 1799   enc_class Opcode(immI d8)
 1800   %{
 1801     emit_opcode(cbuf, $d8$$constant);
 1802   %}
 1803 
 1804   // Emit size prefix
 1805   enc_class SizePrefix
 1806   %{
 1807     emit_opcode(cbuf, 0x66);
 1808   %}
 1809 
 1810   enc_class reg(rRegI reg)
 1811   %{
 1812     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1813   %}
 1814 
 1815   enc_class reg_reg(rRegI dst, rRegI src)
 1816   %{
 1817     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1818   %}
 1819 
 1820   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1821   %{
 1822     emit_opcode(cbuf, $opcode$$constant);
 1823     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1824   %}
 1825 
 1826   enc_class cdql_enc(no_rax_rdx_RegI div)
 1827   %{
 1828     // Full implementation of Java idiv and irem; checks for
 1829     // special case as described in JVM spec., p.243 &amp; p.271.
 1830     //
 1831     //         normal case                           special case
 1832     //
 1833     // input : rax: dividend                         min_int
 1834     //         reg: divisor                          -1
 1835     //
 1836     // output: rax: quotient  (= rax idiv reg)       min_int
 1837     //         rdx: remainder (= rax irem reg)       0
 1838     //
 1839     //  Code sequnce:
 1840     //
 1841     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1842     //    5:   75 07/08                jne    e &lt;normal&gt;
 1843     //    7:   33 d2                   xor    %edx,%edx
 1844     //  [div &gt;= 8 -&gt; offset + 1]
 1845     //  [REX_B]
 1846     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1847     //    c:   74 03/04                je     11 &lt;done&gt;
 1848     // 000000000000000e &lt;normal&gt;:
 1849     //    e:   99                      cltd
 1850     //  [div &gt;= 8 -&gt; offset + 1]
 1851     //  [REX_B]
 1852     //    f:   f7 f9                   idiv   $div
 1853     // 0000000000000011 &lt;done&gt;:
 1854 
 1855     // cmp    $0x80000000,%eax
 1856     emit_opcode(cbuf, 0x3d);
 1857     emit_d8(cbuf, 0x00);
 1858     emit_d8(cbuf, 0x00);
 1859     emit_d8(cbuf, 0x00);
 1860     emit_d8(cbuf, 0x80);
 1861 
 1862     // jne    e &lt;normal&gt;
 1863     emit_opcode(cbuf, 0x75);
 1864     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1865 
 1866     // xor    %edx,%edx
 1867     emit_opcode(cbuf, 0x33);
 1868     emit_d8(cbuf, 0xD2);
 1869 
 1870     // cmp    $0xffffffffffffffff,%ecx
 1871     if ($div$$reg &gt;= 8) {
 1872       emit_opcode(cbuf, Assembler::REX_B);
 1873     }
 1874     emit_opcode(cbuf, 0x83);
 1875     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1876     emit_d8(cbuf, 0xFF);
 1877 
 1878     // je     11 &lt;done&gt;
 1879     emit_opcode(cbuf, 0x74);
 1880     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1881 
 1882     // &lt;normal&gt;
 1883     // cltd
 1884     emit_opcode(cbuf, 0x99);
 1885 
 1886     // idivl (note: must be emitted by the user of this rule)
 1887     // &lt;done&gt;
 1888   %}
 1889 
 1890   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1891   %{
 1892     // Full implementation of Java ldiv and lrem; checks for
 1893     // special case as described in JVM spec., p.243 &amp; p.271.
 1894     //
 1895     //         normal case                           special case
 1896     //
 1897     // input : rax: dividend                         min_long
 1898     //         reg: divisor                          -1
 1899     //
 1900     // output: rax: quotient  (= rax idiv reg)       min_long
 1901     //         rdx: remainder (= rax irem reg)       0
 1902     //
 1903     //  Code sequnce:
 1904     //
 1905     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1906     //    7:   00 00 80
 1907     //    a:   48 39 d0                cmp    %rdx,%rax
 1908     //    d:   75 08                   jne    17 &lt;normal&gt;
 1909     //    f:   33 d2                   xor    %edx,%edx
 1910     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1911     //   15:   74 05                   je     1c &lt;done&gt;
 1912     // 0000000000000017 &lt;normal&gt;:
 1913     //   17:   48 99                   cqto
 1914     //   19:   48 f7 f9                idiv   $div
 1915     // 000000000000001c &lt;done&gt;:
 1916 
 1917     // mov    $0x8000000000000000,%rdx
 1918     emit_opcode(cbuf, Assembler::REX_W);
 1919     emit_opcode(cbuf, 0xBA);
 1920     emit_d8(cbuf, 0x00);
 1921     emit_d8(cbuf, 0x00);
 1922     emit_d8(cbuf, 0x00);
 1923     emit_d8(cbuf, 0x00);
 1924     emit_d8(cbuf, 0x00);
 1925     emit_d8(cbuf, 0x00);
 1926     emit_d8(cbuf, 0x00);
 1927     emit_d8(cbuf, 0x80);
 1928 
 1929     // cmp    %rdx,%rax
 1930     emit_opcode(cbuf, Assembler::REX_W);
 1931     emit_opcode(cbuf, 0x39);
 1932     emit_d8(cbuf, 0xD0);
 1933 
 1934     // jne    17 &lt;normal&gt;
 1935     emit_opcode(cbuf, 0x75);
 1936     emit_d8(cbuf, 0x08);
 1937 
 1938     // xor    %edx,%edx
 1939     emit_opcode(cbuf, 0x33);
 1940     emit_d8(cbuf, 0xD2);
 1941 
 1942     // cmp    $0xffffffffffffffff,$div
 1943     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1944     emit_opcode(cbuf, 0x83);
 1945     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1946     emit_d8(cbuf, 0xFF);
 1947 
 1948     // je     1e &lt;done&gt;
 1949     emit_opcode(cbuf, 0x74);
 1950     emit_d8(cbuf, 0x05);
 1951 
 1952     // &lt;normal&gt;
 1953     // cqto
 1954     emit_opcode(cbuf, Assembler::REX_W);
 1955     emit_opcode(cbuf, 0x99);
 1956 
 1957     // idivq (note: must be emitted by the user of this rule)
 1958     // &lt;done&gt;
 1959   %}
 1960 
 1961   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1962   enc_class OpcSE(immI imm)
 1963   %{
 1964     // Emit primary opcode and set sign-extend bit
 1965     // Check for 8-bit immediate, and set sign extend bit in opcode
 1966     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1967       emit_opcode(cbuf, $primary | 0x02);
 1968     } else {
 1969       // 32-bit immediate
 1970       emit_opcode(cbuf, $primary);
 1971     }
 1972   %}
 1973 
 1974   enc_class OpcSErm(rRegI dst, immI imm)
 1975   %{
 1976     // OpcSEr/m
 1977     int dstenc = $dst$$reg;
 1978     if (dstenc &gt;= 8) {
 1979       emit_opcode(cbuf, Assembler::REX_B);
 1980       dstenc -= 8;
 1981     }
 1982     // Emit primary opcode and set sign-extend bit
 1983     // Check for 8-bit immediate, and set sign extend bit in opcode
 1984     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1985       emit_opcode(cbuf, $primary | 0x02);
 1986     } else {
 1987       // 32-bit immediate
 1988       emit_opcode(cbuf, $primary);
 1989     }
 1990     // Emit r/m byte with secondary opcode, after primary opcode.
 1991     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1992   %}
 1993 
 1994   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1995   %{
 1996     // OpcSEr/m
 1997     int dstenc = $dst$$reg;
 1998     if (dstenc &lt; 8) {
 1999       emit_opcode(cbuf, Assembler::REX_W);
 2000     } else {
 2001       emit_opcode(cbuf, Assembler::REX_WB);
 2002       dstenc -= 8;
 2003     }
 2004     // Emit primary opcode and set sign-extend bit
 2005     // Check for 8-bit immediate, and set sign extend bit in opcode
 2006     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2007       emit_opcode(cbuf, $primary | 0x02);
 2008     } else {
 2009       // 32-bit immediate
 2010       emit_opcode(cbuf, $primary);
 2011     }
 2012     // Emit r/m byte with secondary opcode, after primary opcode.
 2013     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2014   %}
 2015 
 2016   enc_class Con8or32(immI imm)
 2017   %{
 2018     // Check for 8-bit immediate, and set sign extend bit in opcode
 2019     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2020       $$$emit8$imm$$constant;
 2021     } else {
 2022       // 32-bit immediate
 2023       $$$emit32$imm$$constant;
 2024     }
 2025   %}
 2026 
 2027   enc_class opc2_reg(rRegI dst)
 2028   %{
 2029     // BSWAP
 2030     emit_cc(cbuf, $secondary, $dst$$reg);
 2031   %}
 2032 
 2033   enc_class opc3_reg(rRegI dst)
 2034   %{
 2035     // BSWAP
 2036     emit_cc(cbuf, $tertiary, $dst$$reg);
 2037   %}
 2038 
 2039   enc_class reg_opc(rRegI div)
 2040   %{
 2041     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2042     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2043   %}
 2044 
 2045   enc_class enc_cmov(cmpOp cop)
 2046   %{
 2047     // CMOV
 2048     $$$emit8$primary;
 2049     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2050   %}
 2051 
 2052   enc_class enc_PartialSubtypeCheck()
 2053   %{
 2054     Register Rrdi = as_Register(RDI_enc); // result register
 2055     Register Rrax = as_Register(RAX_enc); // super class
 2056     Register Rrcx = as_Register(RCX_enc); // killed
 2057     Register Rrsi = as_Register(RSI_enc); // sub class
 2058     Label miss;
 2059     const bool set_cond_codes = true;
 2060 
 2061     MacroAssembler _masm(&amp;cbuf);
 2062     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2063                                      NULL, &amp;miss,
 2064                                      /*set_cond_codes:*/ true);
 2065     if ($primary) {
 2066       __ xorptr(Rrdi, Rrdi);
 2067     }
 2068     __ bind(miss);
 2069   %}
 2070 
 2071   enc_class clear_avx %{
 2072     debug_only(int off0 = cbuf.insts_size());
 2073     if (generate_vzeroupper(Compile::current())) {
 2074       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2075       // Clear upper bits of YMM registers when current compiled code uses
 2076       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2077       MacroAssembler _masm(&amp;cbuf);
 2078       __ vzeroupper();
 2079     }
 2080     debug_only(int off1 = cbuf.insts_size());
 2081     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2082   %}
 2083 
 2084   enc_class Java_To_Runtime(method meth) %{
 2085     // No relocation needed
 2086     MacroAssembler _masm(&amp;cbuf);
 2087     __ mov64(r10, (int64_t) $meth$$method);
 2088     __ call(r10);
 2089   %}
 2090 
 2091   enc_class Java_To_Interpreter(method meth)
 2092   %{
 2093     // CALL Java_To_Interpreter
 2094     // This is the instruction starting address for relocation info.
 2095     cbuf.set_insts_mark();
 2096     $$$emit8$primary;
 2097     // CALL directly to the runtime
 2098     emit_d32_reloc(cbuf,
 2099                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2100                    runtime_call_Relocation::spec(),
 2101                    RELOC_DISP32);
 2102   %}
 2103 
 2104   enc_class Java_Static_Call(method meth)
 2105   %{
 2106     // JAVA STATIC CALL
 2107     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2108     // determine who we intended to call.
 2109     cbuf.set_insts_mark();
 2110     $$$emit8$primary;
 2111 
 2112     if (!_method) {
 2113       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2114                      runtime_call_Relocation::spec(),
 2115                      RELOC_DISP32);
 2116     } else {
 2117       int method_index = resolved_method_index(cbuf);
 2118       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2119                                                   : static_call_Relocation::spec(method_index);
 2120       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2121                      rspec, RELOC_DISP32);
 2122       // Emit stubs for static call.
 2123       address mark = cbuf.insts_mark();
 2124       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2125       if (stub == NULL) {
 2126         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2127         return;
 2128       }
 2129 #if INCLUDE_AOT
 2130       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2131 #endif
 2132     }
 2133   %}
 2134 
 2135   enc_class Java_Dynamic_Call(method meth) %{
 2136     MacroAssembler _masm(&amp;cbuf);
 2137     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2138   %}
 2139 
 2140   enc_class Java_Compiled_Call(method meth)
 2141   %{
 2142     // JAVA COMPILED CALL
 2143     int disp = in_bytes(Method:: from_compiled_offset());
 2144 
 2145     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2146     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2147 
 2148     // callq *disp(%rax)
 2149     cbuf.set_insts_mark();
 2150     $$$emit8$primary;
 2151     if (disp &lt; 0x80) {
 2152       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2153       emit_d8(cbuf, disp); // Displacement
 2154     } else {
 2155       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2156       emit_d32(cbuf, disp); // Displacement
 2157     }
 2158   %}
 2159 
 2160   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2161   %{
 2162     // SAL, SAR, SHR
 2163     int dstenc = $dst$$reg;
 2164     if (dstenc &gt;= 8) {
 2165       emit_opcode(cbuf, Assembler::REX_B);
 2166       dstenc -= 8;
 2167     }
 2168     $$$emit8$primary;
 2169     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2170     $$$emit8$shift$$constant;
 2171   %}
 2172 
 2173   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2174   %{
 2175     // SAL, SAR, SHR
 2176     int dstenc = $dst$$reg;
 2177     if (dstenc &lt; 8) {
 2178       emit_opcode(cbuf, Assembler::REX_W);
 2179     } else {
 2180       emit_opcode(cbuf, Assembler::REX_WB);
 2181       dstenc -= 8;
 2182     }
 2183     $$$emit8$primary;
 2184     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2185     $$$emit8$shift$$constant;
 2186   %}
 2187 
 2188   enc_class load_immI(rRegI dst, immI src)
 2189   %{
 2190     int dstenc = $dst$$reg;
 2191     if (dstenc &gt;= 8) {
 2192       emit_opcode(cbuf, Assembler::REX_B);
 2193       dstenc -= 8;
 2194     }
 2195     emit_opcode(cbuf, 0xB8 | dstenc);
 2196     $$$emit32$src$$constant;
 2197   %}
 2198 
 2199   enc_class load_immL(rRegL dst, immL src)
 2200   %{
 2201     int dstenc = $dst$$reg;
 2202     if (dstenc &lt; 8) {
 2203       emit_opcode(cbuf, Assembler::REX_W);
 2204     } else {
 2205       emit_opcode(cbuf, Assembler::REX_WB);
 2206       dstenc -= 8;
 2207     }
 2208     emit_opcode(cbuf, 0xB8 | dstenc);
 2209     emit_d64(cbuf, $src$$constant);
 2210   %}
 2211 
 2212   enc_class load_immUL32(rRegL dst, immUL32 src)
 2213   %{
 2214     // same as load_immI, but this time we care about zeroes in the high word
 2215     int dstenc = $dst$$reg;
 2216     if (dstenc &gt;= 8) {
 2217       emit_opcode(cbuf, Assembler::REX_B);
 2218       dstenc -= 8;
 2219     }
 2220     emit_opcode(cbuf, 0xB8 | dstenc);
 2221     $$$emit32$src$$constant;
 2222   %}
 2223 
 2224   enc_class load_immL32(rRegL dst, immL32 src)
 2225   %{
 2226     int dstenc = $dst$$reg;
 2227     if (dstenc &lt; 8) {
 2228       emit_opcode(cbuf, Assembler::REX_W);
 2229     } else {
 2230       emit_opcode(cbuf, Assembler::REX_WB);
 2231       dstenc -= 8;
 2232     }
 2233     emit_opcode(cbuf, 0xC7);
 2234     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2235     $$$emit32$src$$constant;
 2236   %}
 2237 
 2238   enc_class load_immP31(rRegP dst, immP32 src)
 2239   %{
 2240     // same as load_immI, but this time we care about zeroes in the high word
 2241     int dstenc = $dst$$reg;
 2242     if (dstenc &gt;= 8) {
 2243       emit_opcode(cbuf, Assembler::REX_B);
 2244       dstenc -= 8;
 2245     }
 2246     emit_opcode(cbuf, 0xB8 | dstenc);
 2247     $$$emit32$src$$constant;
 2248   %}
 2249 
 2250   enc_class load_immP(rRegP dst, immP src)
 2251   %{
 2252     int dstenc = $dst$$reg;
 2253     if (dstenc &lt; 8) {
 2254       emit_opcode(cbuf, Assembler::REX_W);
 2255     } else {
 2256       emit_opcode(cbuf, Assembler::REX_WB);
 2257       dstenc -= 8;
 2258     }
 2259     emit_opcode(cbuf, 0xB8 | dstenc);
 2260     // This next line should be generated from ADLC
 2261     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2262       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2263     } else {
 2264       emit_d64(cbuf, $src$$constant);
 2265     }
 2266   %}
 2267 
 2268   enc_class Con32(immI src)
 2269   %{
 2270     // Output immediate
 2271     $$$emit32$src$$constant;
 2272   %}
 2273 
 2274   enc_class Con32F_as_bits(immF src)
 2275   %{
 2276     // Output Float immediate bits
 2277     jfloat jf = $src$$constant;
 2278     jint jf_as_bits = jint_cast(jf);
 2279     emit_d32(cbuf, jf_as_bits);
 2280   %}
 2281 
 2282   enc_class Con16(immI src)
 2283   %{
 2284     // Output immediate
 2285     $$$emit16$src$$constant;
 2286   %}
 2287 
 2288   // How is this different from Con32??? XXX
 2289   enc_class Con_d32(immI src)
 2290   %{
 2291     emit_d32(cbuf,$src$$constant);
 2292   %}
 2293 
 2294   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2295     // Output immediate memory reference
 2296     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2297     emit_d32(cbuf, 0x00);
 2298   %}
 2299 
 2300   enc_class lock_prefix()
 2301   %{
 2302     emit_opcode(cbuf, 0xF0); // lock
 2303   %}
 2304 
 2305   enc_class REX_mem(memory mem)
 2306   %{
 2307     if ($mem$$base &gt;= 8) {
 2308       if ($mem$$index &lt; 8) {
 2309         emit_opcode(cbuf, Assembler::REX_B);
 2310       } else {
 2311         emit_opcode(cbuf, Assembler::REX_XB);
 2312       }
 2313     } else {
 2314       if ($mem$$index &gt;= 8) {
 2315         emit_opcode(cbuf, Assembler::REX_X);
 2316       }
 2317     }
 2318   %}
 2319 
 2320   enc_class REX_mem_wide(memory mem)
 2321   %{
 2322     if ($mem$$base &gt;= 8) {
 2323       if ($mem$$index &lt; 8) {
 2324         emit_opcode(cbuf, Assembler::REX_WB);
 2325       } else {
 2326         emit_opcode(cbuf, Assembler::REX_WXB);
 2327       }
 2328     } else {
 2329       if ($mem$$index &lt; 8) {
 2330         emit_opcode(cbuf, Assembler::REX_W);
 2331       } else {
 2332         emit_opcode(cbuf, Assembler::REX_WX);
 2333       }
 2334     }
 2335   %}
 2336 
 2337   // for byte regs
 2338   enc_class REX_breg(rRegI reg)
 2339   %{
 2340     if ($reg$$reg &gt;= 4) {
 2341       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2342     }
 2343   %}
 2344 
 2345   // for byte regs
 2346   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2347   %{
 2348     if ($dst$$reg &lt; 8) {
 2349       if ($src$$reg &gt;= 4) {
 2350         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2351       }
 2352     } else {
 2353       if ($src$$reg &lt; 8) {
 2354         emit_opcode(cbuf, Assembler::REX_R);
 2355       } else {
 2356         emit_opcode(cbuf, Assembler::REX_RB);
 2357       }
 2358     }
 2359   %}
 2360 
 2361   // for byte regs
 2362   enc_class REX_breg_mem(rRegI reg, memory mem)
 2363   %{
 2364     if ($reg$$reg &lt; 8) {
 2365       if ($mem$$base &lt; 8) {
 2366         if ($mem$$index &gt;= 8) {
 2367           emit_opcode(cbuf, Assembler::REX_X);
 2368         } else if ($reg$$reg &gt;= 4) {
 2369           emit_opcode(cbuf, Assembler::REX);
 2370         }
 2371       } else {
 2372         if ($mem$$index &lt; 8) {
 2373           emit_opcode(cbuf, Assembler::REX_B);
 2374         } else {
 2375           emit_opcode(cbuf, Assembler::REX_XB);
 2376         }
 2377       }
 2378     } else {
 2379       if ($mem$$base &lt; 8) {
 2380         if ($mem$$index &lt; 8) {
 2381           emit_opcode(cbuf, Assembler::REX_R);
 2382         } else {
 2383           emit_opcode(cbuf, Assembler::REX_RX);
 2384         }
 2385       } else {
 2386         if ($mem$$index &lt; 8) {
 2387           emit_opcode(cbuf, Assembler::REX_RB);
 2388         } else {
 2389           emit_opcode(cbuf, Assembler::REX_RXB);
 2390         }
 2391       }
 2392     }
 2393   %}
 2394 
 2395   enc_class REX_reg(rRegI reg)
 2396   %{
 2397     if ($reg$$reg &gt;= 8) {
 2398       emit_opcode(cbuf, Assembler::REX_B);
 2399     }
 2400   %}
 2401 
 2402   enc_class REX_reg_wide(rRegI reg)
 2403   %{
 2404     if ($reg$$reg &lt; 8) {
 2405       emit_opcode(cbuf, Assembler::REX_W);
 2406     } else {
 2407       emit_opcode(cbuf, Assembler::REX_WB);
 2408     }
 2409   %}
 2410 
 2411   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2412   %{
 2413     if ($dst$$reg &lt; 8) {
 2414       if ($src$$reg &gt;= 8) {
 2415         emit_opcode(cbuf, Assembler::REX_B);
 2416       }
 2417     } else {
 2418       if ($src$$reg &lt; 8) {
 2419         emit_opcode(cbuf, Assembler::REX_R);
 2420       } else {
 2421         emit_opcode(cbuf, Assembler::REX_RB);
 2422       }
 2423     }
 2424   %}
 2425 
 2426   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2427   %{
 2428     if ($dst$$reg &lt; 8) {
 2429       if ($src$$reg &lt; 8) {
 2430         emit_opcode(cbuf, Assembler::REX_W);
 2431       } else {
 2432         emit_opcode(cbuf, Assembler::REX_WB);
 2433       }
 2434     } else {
 2435       if ($src$$reg &lt; 8) {
 2436         emit_opcode(cbuf, Assembler::REX_WR);
 2437       } else {
 2438         emit_opcode(cbuf, Assembler::REX_WRB);
 2439       }
 2440     }
 2441   %}
 2442 
 2443   enc_class REX_reg_mem(rRegI reg, memory mem)
 2444   %{
 2445     if ($reg$$reg &lt; 8) {
 2446       if ($mem$$base &lt; 8) {
 2447         if ($mem$$index &gt;= 8) {
 2448           emit_opcode(cbuf, Assembler::REX_X);
 2449         }
 2450       } else {
 2451         if ($mem$$index &lt; 8) {
 2452           emit_opcode(cbuf, Assembler::REX_B);
 2453         } else {
 2454           emit_opcode(cbuf, Assembler::REX_XB);
 2455         }
 2456       }
 2457     } else {
 2458       if ($mem$$base &lt; 8) {
 2459         if ($mem$$index &lt; 8) {
 2460           emit_opcode(cbuf, Assembler::REX_R);
 2461         } else {
 2462           emit_opcode(cbuf, Assembler::REX_RX);
 2463         }
 2464       } else {
 2465         if ($mem$$index &lt; 8) {
 2466           emit_opcode(cbuf, Assembler::REX_RB);
 2467         } else {
 2468           emit_opcode(cbuf, Assembler::REX_RXB);
 2469         }
 2470       }
 2471     }
 2472   %}
 2473 
 2474   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2475   %{
 2476     if ($reg$$reg &lt; 8) {
 2477       if ($mem$$base &lt; 8) {
 2478         if ($mem$$index &lt; 8) {
 2479           emit_opcode(cbuf, Assembler::REX_W);
 2480         } else {
 2481           emit_opcode(cbuf, Assembler::REX_WX);
 2482         }
 2483       } else {
 2484         if ($mem$$index &lt; 8) {
 2485           emit_opcode(cbuf, Assembler::REX_WB);
 2486         } else {
 2487           emit_opcode(cbuf, Assembler::REX_WXB);
 2488         }
 2489       }
 2490     } else {
 2491       if ($mem$$base &lt; 8) {
 2492         if ($mem$$index &lt; 8) {
 2493           emit_opcode(cbuf, Assembler::REX_WR);
 2494         } else {
 2495           emit_opcode(cbuf, Assembler::REX_WRX);
 2496         }
 2497       } else {
 2498         if ($mem$$index &lt; 8) {
 2499           emit_opcode(cbuf, Assembler::REX_WRB);
 2500         } else {
 2501           emit_opcode(cbuf, Assembler::REX_WRXB);
 2502         }
 2503       }
 2504     }
 2505   %}
 2506 
 2507   enc_class reg_mem(rRegI ereg, memory mem)
 2508   %{
 2509     // High registers handle in encode_RegMem
 2510     int reg = $ereg$$reg;
 2511     int base = $mem$$base;
 2512     int index = $mem$$index;
 2513     int scale = $mem$$scale;
 2514     int disp = $mem$$disp;
 2515     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2516 
 2517     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2518   %}
 2519 
 2520   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2521   %{
 2522     int rm_byte_opcode = $rm_opcode$$constant;
 2523 
 2524     // High registers handle in encode_RegMem
 2525     int base = $mem$$base;
 2526     int index = $mem$$index;
 2527     int scale = $mem$$scale;
 2528     int displace = $mem$$disp;
 2529 
 2530     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2531                                             // working with static
 2532                                             // globals
 2533     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2534                   disp_reloc);
 2535   %}
 2536 
 2537   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2538   %{
 2539     int reg_encoding = $dst$$reg;
 2540     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2541     int index        = 0x04;            // 0x04 indicates no index
 2542     int scale        = 0x00;            // 0x00 indicates no scale
 2543     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2544     relocInfo::relocType disp_reloc = relocInfo::none;
 2545     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2546                   disp_reloc);
 2547   %}
 2548 
 2549   enc_class neg_reg(rRegI dst)
 2550   %{
 2551     int dstenc = $dst$$reg;
 2552     if (dstenc &gt;= 8) {
 2553       emit_opcode(cbuf, Assembler::REX_B);
 2554       dstenc -= 8;
 2555     }
 2556     // NEG $dst
 2557     emit_opcode(cbuf, 0xF7);
 2558     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2559   %}
 2560 
 2561   enc_class neg_reg_wide(rRegI dst)
 2562   %{
 2563     int dstenc = $dst$$reg;
 2564     if (dstenc &lt; 8) {
 2565       emit_opcode(cbuf, Assembler::REX_W);
 2566     } else {
 2567       emit_opcode(cbuf, Assembler::REX_WB);
 2568       dstenc -= 8;
 2569     }
 2570     // NEG $dst
 2571     emit_opcode(cbuf, 0xF7);
 2572     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2573   %}
 2574 
 2575   enc_class setLT_reg(rRegI dst)
 2576   %{
 2577     int dstenc = $dst$$reg;
 2578     if (dstenc &gt;= 8) {
 2579       emit_opcode(cbuf, Assembler::REX_B);
 2580       dstenc -= 8;
 2581     } else if (dstenc &gt;= 4) {
 2582       emit_opcode(cbuf, Assembler::REX);
 2583     }
 2584     // SETLT $dst
 2585     emit_opcode(cbuf, 0x0F);
 2586     emit_opcode(cbuf, 0x9C);
 2587     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2588   %}
 2589 
 2590   enc_class setNZ_reg(rRegI dst)
 2591   %{
 2592     int dstenc = $dst$$reg;
 2593     if (dstenc &gt;= 8) {
 2594       emit_opcode(cbuf, Assembler::REX_B);
 2595       dstenc -= 8;
 2596     } else if (dstenc &gt;= 4) {
 2597       emit_opcode(cbuf, Assembler::REX);
 2598     }
 2599     // SETNZ $dst
 2600     emit_opcode(cbuf, 0x0F);
 2601     emit_opcode(cbuf, 0x95);
 2602     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2603   %}
 2604 
 2605 
 2606   // Compare the lonogs and set -1, 0, or 1 into dst
 2607   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2608   %{
 2609     int src1enc = $src1$$reg;
 2610     int src2enc = $src2$$reg;
 2611     int dstenc = $dst$$reg;
 2612 
 2613     // cmpq $src1, $src2
 2614     if (src1enc &lt; 8) {
 2615       if (src2enc &lt; 8) {
 2616         emit_opcode(cbuf, Assembler::REX_W);
 2617       } else {
 2618         emit_opcode(cbuf, Assembler::REX_WB);
 2619       }
 2620     } else {
 2621       if (src2enc &lt; 8) {
 2622         emit_opcode(cbuf, Assembler::REX_WR);
 2623       } else {
 2624         emit_opcode(cbuf, Assembler::REX_WRB);
 2625       }
 2626     }
 2627     emit_opcode(cbuf, 0x3B);
 2628     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2629 
 2630     // movl $dst, -1
 2631     if (dstenc &gt;= 8) {
 2632       emit_opcode(cbuf, Assembler::REX_B);
 2633     }
 2634     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2635     emit_d32(cbuf, -1);
 2636 
 2637     // jl,s done
 2638     emit_opcode(cbuf, 0x7C);
 2639     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2640 
 2641     // setne $dst
 2642     if (dstenc &gt;= 4) {
 2643       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2644     }
 2645     emit_opcode(cbuf, 0x0F);
 2646     emit_opcode(cbuf, 0x95);
 2647     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2648 
 2649     // movzbl $dst, $dst
 2650     if (dstenc &gt;= 4) {
 2651       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2652     }
 2653     emit_opcode(cbuf, 0x0F);
 2654     emit_opcode(cbuf, 0xB6);
 2655     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2656   %}
 2657 
 2658   enc_class Push_ResultXD(regD dst) %{
 2659     MacroAssembler _masm(&amp;cbuf);
 2660     __ fstp_d(Address(rsp, 0));
 2661     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2662     __ addptr(rsp, 8);
 2663   %}
 2664 
 2665   enc_class Push_SrcXD(regD src) %{
 2666     MacroAssembler _masm(&amp;cbuf);
 2667     __ subptr(rsp, 8);
 2668     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2669     __ fld_d(Address(rsp, 0));
 2670   %}
 2671 
 2672 
 2673   enc_class enc_rethrow()
 2674   %{
 2675     cbuf.set_insts_mark();
 2676     emit_opcode(cbuf, 0xE9); // jmp entry
 2677     emit_d32_reloc(cbuf,
 2678                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2679                    runtime_call_Relocation::spec(),
 2680                    RELOC_DISP32);
 2681   %}
 2682 
 2683 %}
 2684 
 2685 
 2686 
 2687 //----------FRAME--------------------------------------------------------------
 2688 // Definition of frame structure and management information.
 2689 //
 2690 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2691 //                             |   (to get allocators register number
 2692 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2693 //  r   CALLER     |        |
 2694 //  o     |        +--------+      pad to even-align allocators stack-slot
 2695 //  w     V        |  pad0  |        numbers; owned by CALLER
 2696 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2697 //  h     ^        |   in   |  5
 2698 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2699 //  |     |        |        |  3
 2700 //  |     |        +--------+
 2701 //  V     |        | old out|      Empty on Intel, window on Sparc
 2702 //        |    old |preserve|      Must be even aligned.
 2703 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2704 //        |        |   in   |  3   area for Intel ret address
 2705 //     Owned by    |preserve|      Empty on Sparc.
 2706 //       SELF      +--------+
 2707 //        |        |  pad2  |  2   pad to align old SP
 2708 //        |        +--------+  1
 2709 //        |        | locks  |  0
 2710 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2711 //        |        |  pad1  | 11   pad to align new SP
 2712 //        |        +--------+
 2713 //        |        |        | 10
 2714 //        |        | spills |  9   spills
 2715 //        V        |        |  8   (pad0 slot for callee)
 2716 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2717 //        ^        |  out   |  7
 2718 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2719 //     Owned by    +--------+
 2720 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2721 //        |    new |preserve|      Must be even-aligned.
 2722 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2723 //        |        |        |
 2724 //
 2725 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2726 //         known from SELF&#39;s arguments and the Java calling convention.
 2727 //         Region 6-7 is determined per call site.
 2728 // Note 2: If the calling convention leaves holes in the incoming argument
 2729 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2730 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2731 //         incoming area, as the Java calling convention is completely under
 2732 //         the control of the AD file.  Doubles can be sorted and packed to
 2733 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2734 //         varargs C calling conventions.
 2735 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2736 //         even aligned with pad0 as needed.
 2737 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2738 //         region 6-11 is even aligned; it may be padded out more so that
 2739 //         the region from SP to FP meets the minimum stack alignment.
 2740 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2741 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2742 //         SP meets the minimum alignment.
 2743 
 2744 frame
 2745 %{
 2746   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2747   stack_direction(TOWARDS_LOW);
 2748 
 2749   // These three registers define part of the calling convention
 2750   // between compiled code and the interpreter.
 2751   inline_cache_reg(RAX);                // Inline Cache Register
 2752   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2753                                         // calling interpreter
 2754 
 2755   // Optional: name the operand used by cisc-spilling to access
 2756   // [stack_pointer + offset]
 2757   cisc_spilling_operand_name(indOffset32);
 2758 
 2759   // Number of stack slots consumed by locking an object
 2760   sync_stack_slots(2);
 2761 
 2762   // Compiled code&#39;s Frame Pointer
 2763   frame_pointer(RSP);
 2764 
 2765   // Interpreter stores its frame pointer in a register which is
 2766   // stored to the stack by I2CAdaptors.
 2767   // I2CAdaptors convert from interpreted java to compiled java.
 2768   interpreter_frame_pointer(RBP);
 2769 
 2770   // Stack alignment requirement
 2771   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2772 
 2773   // Number of stack slots between incoming argument block and the start of
 2774   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2775   // EPILOG must remove this many slots.  amd64 needs two slots for
 2776   // return address.
 2777   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2778 
 2779   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2780   // for calls to C.  Supports the var-args backing area for register parms.
 2781   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2782 
 2783   // The after-PROLOG location of the return address.  Location of
 2784   // return address specifies a type (REG or STACK) and a number
 2785   // representing the register number (i.e. - use a register name) or
 2786   // stack slot.
 2787   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2788   // Otherwise, it is above the locks and verification slot and alignment word
 2789   return_addr(STACK - 2 +
 2790               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2791                         Compile::current()-&gt;fixed_slots()),
 2792                        stack_alignment_in_slots()));
 2793 
 2794   // Body of function which returns an integer array locating
 2795   // arguments either in registers or in stack slots.  Passed an array
 2796   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2797   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2798   // arguments for a CALLEE.  Incoming stack arguments are
 2799   // automatically biased by the preserve_stack_slots field above.
 2800 
 2801   calling_convention
 2802   %{
 2803     // No difference between ingoing/outgoing just pass false
 2804     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2805   %}
 2806 
 2807   c_calling_convention
 2808   %{
 2809     // This is obviously always outgoing
 2810     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2811   %}
 2812 
 2813   // Location of compiled Java return values.  Same as C for now.
 2814   return_value
 2815   %{
 2816     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2817            &quot;only return normal values&quot;);
 2818 
 2819     static const int lo[Op_RegL + 1] = {
 2820       0,
 2821       0,
 2822       RAX_num,  // Op_RegN
 2823       RAX_num,  // Op_RegI
 2824       RAX_num,  // Op_RegP
 2825       XMM0_num, // Op_RegF
 2826       XMM0_num, // Op_RegD
 2827       RAX_num   // Op_RegL
 2828     };
 2829     static const int hi[Op_RegL + 1] = {
 2830       0,
 2831       0,
 2832       OptoReg::Bad, // Op_RegN
 2833       OptoReg::Bad, // Op_RegI
 2834       RAX_H_num,    // Op_RegP
 2835       OptoReg::Bad, // Op_RegF
 2836       XMM0b_num,    // Op_RegD
 2837       RAX_H_num     // Op_RegL
 2838     };
 2839     // Excluded flags and vector registers.
 2840     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2841     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2842   %}
 2843 %}
 2844 
 2845 //----------ATTRIBUTES---------------------------------------------------------
 2846 //----------Operand Attributes-------------------------------------------------
 2847 op_attrib op_cost(0);        // Required cost attribute
 2848 
 2849 //----------Instruction Attributes---------------------------------------------
 2850 ins_attrib ins_cost(100);       // Required cost attribute
 2851 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2852 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2853                                 // a non-matching short branch variant
 2854                                 // of some long branch?
 2855 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2856                                 // be a power of 2) specifies the
 2857                                 // alignment that some part of the
 2858                                 // instruction (not necessarily the
 2859                                 // start) requires.  If &gt; 1, a
 2860                                 // compute_padding() function must be
 2861                                 // provided for the instruction
 2862 
 2863 //----------OPERANDS-----------------------------------------------------------
 2864 // Operand definitions must precede instruction definitions for correct parsing
 2865 // in the ADLC because operands constitute user defined types which are used in
 2866 // instruction definitions.
 2867 
 2868 //----------Simple Operands----------------------------------------------------
 2869 // Immediate Operands
 2870 // Integer Immediate
 2871 operand immI()
 2872 %{
 2873   match(ConI);
 2874 
 2875   op_cost(10);
 2876   format %{ %}
 2877   interface(CONST_INTER);
 2878 %}
 2879 
 2880 // Constant for test vs zero
 2881 operand immI0()
 2882 %{
 2883   predicate(n-&gt;get_int() == 0);
 2884   match(ConI);
 2885 
 2886   op_cost(0);
 2887   format %{ %}
 2888   interface(CONST_INTER);
 2889 %}
 2890 
 2891 // Constant for increment
 2892 operand immI1()
 2893 %{
 2894   predicate(n-&gt;get_int() == 1);
 2895   match(ConI);
 2896 
 2897   op_cost(0);
 2898   format %{ %}
 2899   interface(CONST_INTER);
 2900 %}
 2901 
 2902 // Constant for decrement
 2903 operand immI_M1()
 2904 %{
 2905   predicate(n-&gt;get_int() == -1);
 2906   match(ConI);
 2907 
 2908   op_cost(0);
 2909   format %{ %}
 2910   interface(CONST_INTER);
 2911 %}
 2912 
 2913 // Valid scale values for addressing modes
 2914 operand immI2()
 2915 %{
 2916   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2917   match(ConI);
 2918 
 2919   format %{ %}
 2920   interface(CONST_INTER);
 2921 %}
 2922 
 2923 operand immI8()
 2924 %{
 2925   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2926   match(ConI);
 2927 
 2928   op_cost(5);
 2929   format %{ %}
 2930   interface(CONST_INTER);
 2931 %}
 2932 
 2933 operand immU8()
 2934 %{
 2935   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2936   match(ConI);
 2937 
 2938   op_cost(5);
 2939   format %{ %}
 2940   interface(CONST_INTER);
 2941 %}
 2942 
 2943 operand immI16()
 2944 %{
 2945   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2946   match(ConI);
 2947 
 2948   op_cost(10);
 2949   format %{ %}
 2950   interface(CONST_INTER);
 2951 %}
 2952 
 2953 // Int Immediate non-negative
 2954 operand immU31()
 2955 %{
 2956   predicate(n-&gt;get_int() &gt;= 0);
 2957   match(ConI);
 2958 
 2959   op_cost(0);
 2960   format %{ %}
 2961   interface(CONST_INTER);
 2962 %}
 2963 
 2964 // Constant for long shifts
 2965 operand immI_32()
 2966 %{
 2967   predicate( n-&gt;get_int() == 32 );
 2968   match(ConI);
 2969 
 2970   op_cost(0);
 2971   format %{ %}
 2972   interface(CONST_INTER);
 2973 %}
 2974 
 2975 // Constant for long shifts
 2976 operand immI_64()
 2977 %{
 2978   predicate( n-&gt;get_int() == 64 );
 2979   match(ConI);
 2980 
 2981   op_cost(0);
 2982   format %{ %}
 2983   interface(CONST_INTER);
 2984 %}
 2985 
 2986 // Pointer Immediate
 2987 operand immP()
 2988 %{
 2989   match(ConP);
 2990 
 2991   op_cost(10);
 2992   format %{ %}
 2993   interface(CONST_INTER);
 2994 %}
 2995 
 2996 // NULL Pointer Immediate
 2997 operand immP0()
 2998 %{
 2999   predicate(n-&gt;get_ptr() == 0);
 3000   match(ConP);
 3001 
 3002   op_cost(5);
 3003   format %{ %}
 3004   interface(CONST_INTER);
 3005 %}
 3006 
 3007 // Pointer Immediate
 3008 operand immN() %{
 3009   match(ConN);
 3010 
 3011   op_cost(10);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 operand immNKlass() %{
 3017   match(ConNKlass);
 3018 
 3019   op_cost(10);
 3020   format %{ %}
 3021   interface(CONST_INTER);
 3022 %}
 3023 
 3024 // NULL Pointer Immediate
 3025 operand immN0() %{
 3026   predicate(n-&gt;get_narrowcon() == 0);
 3027   match(ConN);
 3028 
 3029   op_cost(5);
 3030   format %{ %}
 3031   interface(CONST_INTER);
 3032 %}
 3033 
 3034 operand immP31()
 3035 %{
 3036   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3037             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3038   match(ConP);
 3039 
 3040   op_cost(5);
 3041   format %{ %}
 3042   interface(CONST_INTER);
 3043 %}
 3044 
 3045 
 3046 // Long Immediate
 3047 operand immL()
 3048 %{
 3049   match(ConL);
 3050 
 3051   op_cost(20);
 3052   format %{ %}
 3053   interface(CONST_INTER);
 3054 %}
 3055 
 3056 // Long Immediate 8-bit
 3057 operand immL8()
 3058 %{
 3059   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3060   match(ConL);
 3061 
 3062   op_cost(5);
 3063   format %{ %}
 3064   interface(CONST_INTER);
 3065 %}
 3066 
 3067 // Long Immediate 32-bit unsigned
 3068 operand immUL32()
 3069 %{
 3070   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3071   match(ConL);
 3072 
 3073   op_cost(10);
 3074   format %{ %}
 3075   interface(CONST_INTER);
 3076 %}
 3077 
 3078 // Long Immediate 32-bit signed
 3079 operand immL32()
 3080 %{
 3081   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3082   match(ConL);
 3083 
 3084   op_cost(15);
 3085   format %{ %}
 3086   interface(CONST_INTER);
 3087 %}
 3088 
 3089 operand immL_Pow2()
 3090 %{
 3091   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3092   match(ConL);
 3093 
 3094   op_cost(15);
 3095   format %{ %}
 3096   interface(CONST_INTER);
 3097 %}
 3098 
 3099 operand immL_NotPow2()
 3100 %{
 3101   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3102   match(ConL);
 3103 
 3104   op_cost(15);
 3105   format %{ %}
 3106   interface(CONST_INTER);
 3107 %}
 3108 
 3109 // Long Immediate zero
 3110 operand immL0()
 3111 %{
 3112   predicate(n-&gt;get_long() == 0L);
 3113   match(ConL);
 3114 
 3115   op_cost(10);
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Constant for increment
 3121 operand immL1()
 3122 %{
 3123   predicate(n-&gt;get_long() == 1);
 3124   match(ConL);
 3125 
 3126   format %{ %}
 3127   interface(CONST_INTER);
 3128 %}
 3129 
 3130 // Constant for decrement
 3131 operand immL_M1()
 3132 %{
 3133   predicate(n-&gt;get_long() == -1);
 3134   match(ConL);
 3135 
 3136   format %{ %}
 3137   interface(CONST_INTER);
 3138 %}
 3139 
 3140 // Long Immediate: the value 10
 3141 operand immL10()
 3142 %{
 3143   predicate(n-&gt;get_long() == 10);
 3144   match(ConL);
 3145 
 3146   format %{ %}
 3147   interface(CONST_INTER);
 3148 %}
 3149 
 3150 // Long immediate from 0 to 127.
 3151 // Used for a shorter form of long mul by 10.
 3152 operand immL_127()
 3153 %{
 3154   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3155   match(ConL);
 3156 
 3157   op_cost(10);
 3158   format %{ %}
 3159   interface(CONST_INTER);
 3160 %}
 3161 
 3162 // Long Immediate: low 32-bit mask
 3163 operand immL_32bits()
 3164 %{
 3165   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3166   match(ConL);
 3167   op_cost(20);
 3168 
 3169   format %{ %}
 3170   interface(CONST_INTER);
 3171 %}
 3172 
 3173 // Float Immediate zero
 3174 operand immF0()
 3175 %{
 3176   predicate(jint_cast(n-&gt;getf()) == 0);
 3177   match(ConF);
 3178 
 3179   op_cost(5);
 3180   format %{ %}
 3181   interface(CONST_INTER);
 3182 %}
 3183 
 3184 // Float Immediate
 3185 operand immF()
 3186 %{
 3187   match(ConF);
 3188 
 3189   op_cost(15);
 3190   format %{ %}
 3191   interface(CONST_INTER);
 3192 %}
 3193 
 3194 // Double Immediate zero
 3195 operand immD0()
 3196 %{
 3197   predicate(jlong_cast(n-&gt;getd()) == 0);
 3198   match(ConD);
 3199 
 3200   op_cost(5);
 3201   format %{ %}
 3202   interface(CONST_INTER);
 3203 %}
 3204 
 3205 // Double Immediate
 3206 operand immD()
 3207 %{
 3208   match(ConD);
 3209 
 3210   op_cost(15);
 3211   format %{ %}
 3212   interface(CONST_INTER);
 3213 %}
 3214 
 3215 // Immediates for special shifts (sign extend)
 3216 
 3217 // Constants for increment
 3218 operand immI_16()
 3219 %{
 3220   predicate(n-&gt;get_int() == 16);
 3221   match(ConI);
 3222 
 3223   format %{ %}
 3224   interface(CONST_INTER);
 3225 %}
 3226 
 3227 operand immI_24()
 3228 %{
 3229   predicate(n-&gt;get_int() == 24);
 3230   match(ConI);
 3231 
 3232   format %{ %}
 3233   interface(CONST_INTER);
 3234 %}
 3235 
 3236 // Constant for byte-wide masking
 3237 operand immI_255()
 3238 %{
 3239   predicate(n-&gt;get_int() == 255);
 3240   match(ConI);
 3241 
 3242   format %{ %}
 3243   interface(CONST_INTER);
 3244 %}
 3245 
 3246 // Constant for short-wide masking
 3247 operand immI_65535()
 3248 %{
 3249   predicate(n-&gt;get_int() == 65535);
 3250   match(ConI);
 3251 
 3252   format %{ %}
 3253   interface(CONST_INTER);
 3254 %}
 3255 
 3256 // Constant for byte-wide masking
 3257 operand immL_255()
 3258 %{
 3259   predicate(n-&gt;get_long() == 255);
 3260   match(ConL);
 3261 
 3262   format %{ %}
 3263   interface(CONST_INTER);
 3264 %}
 3265 
 3266 // Constant for short-wide masking
 3267 operand immL_65535()
 3268 %{
 3269   predicate(n-&gt;get_long() == 65535);
 3270   match(ConL);
 3271 
 3272   format %{ %}
 3273   interface(CONST_INTER);
 3274 %}
 3275 
 3276 // Register Operands
 3277 // Integer Register
 3278 operand rRegI()
 3279 %{
 3280   constraint(ALLOC_IN_RC(int_reg));
 3281   match(RegI);
 3282 
 3283   match(rax_RegI);
 3284   match(rbx_RegI);
 3285   match(rcx_RegI);
 3286   match(rdx_RegI);
 3287   match(rdi_RegI);
 3288 
 3289   format %{ %}
 3290   interface(REG_INTER);
 3291 %}
 3292 
 3293 // Special Registers
 3294 operand rax_RegI()
 3295 %{
 3296   constraint(ALLOC_IN_RC(int_rax_reg));
 3297   match(RegI);
 3298   match(rRegI);
 3299 
 3300   format %{ &quot;RAX&quot; %}
 3301   interface(REG_INTER);
 3302 %}
 3303 
 3304 // Special Registers
 3305 operand rbx_RegI()
 3306 %{
 3307   constraint(ALLOC_IN_RC(int_rbx_reg));
 3308   match(RegI);
 3309   match(rRegI);
 3310 
 3311   format %{ &quot;RBX&quot; %}
 3312   interface(REG_INTER);
 3313 %}
 3314 
 3315 operand rcx_RegI()
 3316 %{
 3317   constraint(ALLOC_IN_RC(int_rcx_reg));
 3318   match(RegI);
 3319   match(rRegI);
 3320 
 3321   format %{ &quot;RCX&quot; %}
 3322   interface(REG_INTER);
 3323 %}
 3324 
 3325 operand rdx_RegI()
 3326 %{
 3327   constraint(ALLOC_IN_RC(int_rdx_reg));
 3328   match(RegI);
 3329   match(rRegI);
 3330 
 3331   format %{ &quot;RDX&quot; %}
 3332   interface(REG_INTER);
 3333 %}
 3334 
 3335 operand rdi_RegI()
 3336 %{
 3337   constraint(ALLOC_IN_RC(int_rdi_reg));
 3338   match(RegI);
 3339   match(rRegI);
 3340 
 3341   format %{ &quot;RDI&quot; %}
 3342   interface(REG_INTER);
 3343 %}
 3344 
 3345 operand no_rcx_RegI()
 3346 %{
 3347   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3348   match(RegI);
 3349   match(rax_RegI);
 3350   match(rbx_RegI);
 3351   match(rdx_RegI);
 3352   match(rdi_RegI);
 3353 
 3354   format %{ %}
 3355   interface(REG_INTER);
 3356 %}
 3357 
 3358 operand no_rax_rdx_RegI()
 3359 %{
 3360   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3361   match(RegI);
 3362   match(rbx_RegI);
 3363   match(rcx_RegI);
 3364   match(rdi_RegI);
 3365 
 3366   format %{ %}
 3367   interface(REG_INTER);
 3368 %}
 3369 
 3370 // Pointer Register
 3371 operand any_RegP()
 3372 %{
 3373   constraint(ALLOC_IN_RC(any_reg));
 3374   match(RegP);
 3375   match(rax_RegP);
 3376   match(rbx_RegP);
 3377   match(rdi_RegP);
 3378   match(rsi_RegP);
 3379   match(rbp_RegP);
 3380   match(r15_RegP);
 3381   match(rRegP);
 3382 
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 operand rRegP()
 3388 %{
 3389   constraint(ALLOC_IN_RC(ptr_reg));
 3390   match(RegP);
 3391   match(rax_RegP);
 3392   match(rbx_RegP);
 3393   match(rdi_RegP);
 3394   match(rsi_RegP);
 3395   match(rbp_RegP);  // See Q&amp;A below about
 3396   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 operand rRegN() %{
 3403   constraint(ALLOC_IN_RC(int_reg));
 3404   match(RegN);
 3405 
 3406   format %{ %}
 3407   interface(REG_INTER);
 3408 %}
 3409 
 3410 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3411 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3412 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3413 // The output of an instruction is controlled by the allocator, which respects
 3414 // register class masks, not match rules.  Unless an instruction mentions
 3415 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3416 // by the allocator as an input.
 3417 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3418 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3419 // result, RBP is not included in the output of the instruction either.
 3420 
 3421 operand no_rax_RegP()
 3422 %{
 3423   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3424   match(RegP);
 3425   match(rbx_RegP);
 3426   match(rsi_RegP);
 3427   match(rdi_RegP);
 3428 
 3429   format %{ %}
 3430   interface(REG_INTER);
 3431 %}
 3432 
 3433 // This operand is not allowed to use RBP even if
 3434 // RBP is not used to hold the frame pointer.
 3435 operand no_rbp_RegP()
 3436 %{
 3437   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3438   match(RegP);
 3439   match(rbx_RegP);
 3440   match(rsi_RegP);
 3441   match(rdi_RegP);
 3442 
 3443   format %{ %}
 3444   interface(REG_INTER);
 3445 %}
 3446 
 3447 operand no_rax_rbx_RegP()
 3448 %{
 3449   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3450   match(RegP);
 3451   match(rsi_RegP);
 3452   match(rdi_RegP);
 3453 
 3454   format %{ %}
 3455   interface(REG_INTER);
 3456 %}
 3457 
 3458 // Special Registers
 3459 // Return a pointer value
 3460 operand rax_RegP()
 3461 %{
 3462   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3463   match(RegP);
 3464   match(rRegP);
 3465 
 3466   format %{ %}
 3467   interface(REG_INTER);
 3468 %}
 3469 
 3470 // Special Registers
 3471 // Return a compressed pointer value
 3472 operand rax_RegN()
 3473 %{
 3474   constraint(ALLOC_IN_RC(int_rax_reg));
 3475   match(RegN);
 3476   match(rRegN);
 3477 
 3478   format %{ %}
 3479   interface(REG_INTER);
 3480 %}
 3481 
 3482 // Used in AtomicAdd
 3483 operand rbx_RegP()
 3484 %{
 3485   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3486   match(RegP);
 3487   match(rRegP);
 3488 
 3489   format %{ %}
 3490   interface(REG_INTER);
 3491 %}
 3492 
 3493 operand rsi_RegP()
 3494 %{
 3495   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3496   match(RegP);
 3497   match(rRegP);
 3498 
 3499   format %{ %}
 3500   interface(REG_INTER);
 3501 %}
 3502 
 3503 operand rbp_RegP()
 3504 %{
 3505   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3506   match(RegP);
 3507   match(rRegP);
 3508 
 3509   format %{ %}
 3510   interface(REG_INTER);
 3511 %}
 3512 
 3513 // Used in rep stosq
 3514 operand rdi_RegP()
 3515 %{
 3516   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3517   match(RegP);
 3518   match(rRegP);
 3519 
 3520   format %{ %}
 3521   interface(REG_INTER);
 3522 %}
 3523 
 3524 operand r15_RegP()
 3525 %{
 3526   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3527   match(RegP);
 3528   match(rRegP);
 3529 
 3530   format %{ %}
 3531   interface(REG_INTER);
 3532 %}
 3533 
 3534 operand rRegL()
 3535 %{
 3536   constraint(ALLOC_IN_RC(long_reg));
 3537   match(RegL);
 3538   match(rax_RegL);
 3539   match(rdx_RegL);
 3540 
 3541   format %{ %}
 3542   interface(REG_INTER);
 3543 %}
 3544 
 3545 // Special Registers
 3546 operand no_rax_rdx_RegL()
 3547 %{
 3548   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3549   match(RegL);
 3550   match(rRegL);
 3551 
 3552   format %{ %}
 3553   interface(REG_INTER);
 3554 %}
 3555 
 3556 operand no_rax_RegL()
 3557 %{
 3558   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3559   match(RegL);
 3560   match(rRegL);
 3561   match(rdx_RegL);
 3562 
 3563   format %{ %}
 3564   interface(REG_INTER);
 3565 %}
 3566 
 3567 operand no_rcx_RegL()
 3568 %{
 3569   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3570   match(RegL);
 3571   match(rRegL);
 3572 
 3573   format %{ %}
 3574   interface(REG_INTER);
 3575 %}
 3576 
 3577 operand rax_RegL()
 3578 %{
 3579   constraint(ALLOC_IN_RC(long_rax_reg));
 3580   match(RegL);
 3581   match(rRegL);
 3582 
 3583   format %{ &quot;RAX&quot; %}
 3584   interface(REG_INTER);
 3585 %}
 3586 
 3587 operand rcx_RegL()
 3588 %{
 3589   constraint(ALLOC_IN_RC(long_rcx_reg));
 3590   match(RegL);
 3591   match(rRegL);
 3592 
 3593   format %{ %}
 3594   interface(REG_INTER);
 3595 %}
 3596 
 3597 operand rdx_RegL()
 3598 %{
 3599   constraint(ALLOC_IN_RC(long_rdx_reg));
 3600   match(RegL);
 3601   match(rRegL);
 3602 
 3603   format %{ %}
 3604   interface(REG_INTER);
 3605 %}
 3606 
 3607 // Flags register, used as output of compare instructions
 3608 operand rFlagsReg()
 3609 %{
 3610   constraint(ALLOC_IN_RC(int_flags));
 3611   match(RegFlags);
 3612 
 3613   format %{ &quot;RFLAGS&quot; %}
 3614   interface(REG_INTER);
 3615 %}
 3616 
 3617 // Flags register, used as output of FLOATING POINT compare instructions
 3618 operand rFlagsRegU()
 3619 %{
 3620   constraint(ALLOC_IN_RC(int_flags));
 3621   match(RegFlags);
 3622 
 3623   format %{ &quot;RFLAGS_U&quot; %}
 3624   interface(REG_INTER);
 3625 %}
 3626 
 3627 operand rFlagsRegUCF() %{
 3628   constraint(ALLOC_IN_RC(int_flags));
 3629   match(RegFlags);
 3630   predicate(false);
 3631 
 3632   format %{ &quot;RFLAGS_U_CF&quot; %}
 3633   interface(REG_INTER);
 3634 %}
 3635 
 3636 // Float register operands
 3637 operand regF() %{
 3638    constraint(ALLOC_IN_RC(float_reg));
 3639    match(RegF);
 3640 
 3641    format %{ %}
 3642    interface(REG_INTER);
 3643 %}
 3644 
 3645 // Float register operands
 3646 operand legRegF() %{
 3647    constraint(ALLOC_IN_RC(float_reg_legacy));
 3648    match(RegF);
 3649 
 3650    format %{ %}
 3651    interface(REG_INTER);
 3652 %}
 3653 
 3654 // Float register operands
 3655 operand vlRegF() %{
 3656    constraint(ALLOC_IN_RC(float_reg_vl));
 3657    match(RegF);
 3658 
 3659    format %{ %}
 3660    interface(REG_INTER);
 3661 %}
 3662 
 3663 // Double register operands
 3664 operand regD() %{
 3665    constraint(ALLOC_IN_RC(double_reg));
 3666    match(RegD);
 3667 
 3668    format %{ %}
 3669    interface(REG_INTER);
 3670 %}
 3671 
 3672 // Double register operands
 3673 operand legRegD() %{
 3674    constraint(ALLOC_IN_RC(double_reg_legacy));
 3675    match(RegD);
 3676 
 3677    format %{ %}
 3678    interface(REG_INTER);
 3679 %}
 3680 
 3681 // Double register operands
 3682 operand vlRegD() %{
 3683    constraint(ALLOC_IN_RC(double_reg_vl));
 3684    match(RegD);
 3685 
 3686    format %{ %}
 3687    interface(REG_INTER);
 3688 %}
 3689 
 3690 //----------Memory Operands----------------------------------------------------
 3691 // Direct Memory Operand
 3692 // operand direct(immP addr)
 3693 // %{
 3694 //   match(addr);
 3695 
 3696 //   format %{ &quot;[$addr]&quot; %}
 3697 //   interface(MEMORY_INTER) %{
 3698 //     base(0xFFFFFFFF);
 3699 //     index(0x4);
 3700 //     scale(0x0);
 3701 //     disp($addr);
 3702 //   %}
 3703 // %}
 3704 
 3705 // Indirect Memory Operand
 3706 operand indirect(any_RegP reg)
 3707 %{
 3708   constraint(ALLOC_IN_RC(ptr_reg));
 3709   match(reg);
 3710 
 3711   format %{ &quot;[$reg]&quot; %}
 3712   interface(MEMORY_INTER) %{
 3713     base($reg);
 3714     index(0x4);
 3715     scale(0x0);
 3716     disp(0x0);
 3717   %}
 3718 %}
 3719 
 3720 // Indirect Memory Plus Short Offset Operand
 3721 operand indOffset8(any_RegP reg, immL8 off)
 3722 %{
 3723   constraint(ALLOC_IN_RC(ptr_reg));
 3724   match(AddP reg off);
 3725 
 3726   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3727   interface(MEMORY_INTER) %{
 3728     base($reg);
 3729     index(0x4);
 3730     scale(0x0);
 3731     disp($off);
 3732   %}
 3733 %}
 3734 
 3735 // Indirect Memory Plus Long Offset Operand
 3736 operand indOffset32(any_RegP reg, immL32 off)
 3737 %{
 3738   constraint(ALLOC_IN_RC(ptr_reg));
 3739   match(AddP reg off);
 3740 
 3741   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3742   interface(MEMORY_INTER) %{
 3743     base($reg);
 3744     index(0x4);
 3745     scale(0x0);
 3746     disp($off);
 3747   %}
 3748 %}
 3749 
 3750 // Indirect Memory Plus Index Register Plus Offset Operand
 3751 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3752 %{
 3753   constraint(ALLOC_IN_RC(ptr_reg));
 3754   match(AddP (AddP reg lreg) off);
 3755 
 3756   op_cost(10);
 3757   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3758   interface(MEMORY_INTER) %{
 3759     base($reg);
 3760     index($lreg);
 3761     scale(0x0);
 3762     disp($off);
 3763   %}
 3764 %}
 3765 
 3766 // Indirect Memory Plus Index Register Plus Offset Operand
 3767 operand indIndex(any_RegP reg, rRegL lreg)
 3768 %{
 3769   constraint(ALLOC_IN_RC(ptr_reg));
 3770   match(AddP reg lreg);
 3771 
 3772   op_cost(10);
 3773   format %{&quot;[$reg + $lreg]&quot; %}
 3774   interface(MEMORY_INTER) %{
 3775     base($reg);
 3776     index($lreg);
 3777     scale(0x0);
 3778     disp(0x0);
 3779   %}
 3780 %}
 3781 
 3782 // Indirect Memory Times Scale Plus Index Register
 3783 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3784 %{
 3785   constraint(ALLOC_IN_RC(ptr_reg));
 3786   match(AddP reg (LShiftL lreg scale));
 3787 
 3788   op_cost(10);
 3789   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3790   interface(MEMORY_INTER) %{
 3791     base($reg);
 3792     index($lreg);
 3793     scale($scale);
 3794     disp(0x0);
 3795   %}
 3796 %}
 3797 
 3798 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3799 %{
 3800   constraint(ALLOC_IN_RC(ptr_reg));
 3801   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3802   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3803 
 3804   op_cost(10);
 3805   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3806   interface(MEMORY_INTER) %{
 3807     base($reg);
 3808     index($idx);
 3809     scale($scale);
 3810     disp(0x0);
 3811   %}
 3812 %}
 3813 
 3814 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3815 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3816 %{
 3817   constraint(ALLOC_IN_RC(ptr_reg));
 3818   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3819 
 3820   op_cost(10);
 3821   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3822   interface(MEMORY_INTER) %{
 3823     base($reg);
 3824     index($lreg);
 3825     scale($scale);
 3826     disp($off);
 3827   %}
 3828 %}
 3829 
 3830 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3831 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3832 %{
 3833   constraint(ALLOC_IN_RC(ptr_reg));
 3834   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3835   match(AddP (AddP reg (ConvI2L idx)) off);
 3836 
 3837   op_cost(10);
 3838   format %{&quot;[$reg + $off + $idx]&quot; %}
 3839   interface(MEMORY_INTER) %{
 3840     base($reg);
 3841     index($idx);
 3842     scale(0x0);
 3843     disp($off);
 3844   %}
 3845 %}
 3846 
 3847 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3848 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3849 %{
 3850   constraint(ALLOC_IN_RC(ptr_reg));
 3851   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3852   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3853 
 3854   op_cost(10);
 3855   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3856   interface(MEMORY_INTER) %{
 3857     base($reg);
 3858     index($idx);
 3859     scale($scale);
 3860     disp($off);
 3861   %}
 3862 %}
 3863 
 3864 // Indirect Narrow Oop Plus Offset Operand
 3865 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3866 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3867 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3868   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3869   constraint(ALLOC_IN_RC(ptr_reg));
 3870   match(AddP (DecodeN reg) off);
 3871 
 3872   op_cost(10);
 3873   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3874   interface(MEMORY_INTER) %{
 3875     base(0xc); // R12
 3876     index($reg);
 3877     scale(0x3);
 3878     disp($off);
 3879   %}
 3880 %}
 3881 
 3882 // Indirect Memory Operand
 3883 operand indirectNarrow(rRegN reg)
 3884 %{
 3885   predicate(CompressedOops::shift() == 0);
 3886   constraint(ALLOC_IN_RC(ptr_reg));
 3887   match(DecodeN reg);
 3888 
 3889   format %{ &quot;[$reg]&quot; %}
 3890   interface(MEMORY_INTER) %{
 3891     base($reg);
 3892     index(0x4);
 3893     scale(0x0);
 3894     disp(0x0);
 3895   %}
 3896 %}
 3897 
 3898 // Indirect Memory Plus Short Offset Operand
 3899 operand indOffset8Narrow(rRegN reg, immL8 off)
 3900 %{
 3901   predicate(CompressedOops::shift() == 0);
 3902   constraint(ALLOC_IN_RC(ptr_reg));
 3903   match(AddP (DecodeN reg) off);
 3904 
 3905   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3906   interface(MEMORY_INTER) %{
 3907     base($reg);
 3908     index(0x4);
 3909     scale(0x0);
 3910     disp($off);
 3911   %}
 3912 %}
 3913 
 3914 // Indirect Memory Plus Long Offset Operand
 3915 operand indOffset32Narrow(rRegN reg, immL32 off)
 3916 %{
 3917   predicate(CompressedOops::shift() == 0);
 3918   constraint(ALLOC_IN_RC(ptr_reg));
 3919   match(AddP (DecodeN reg) off);
 3920 
 3921   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3922   interface(MEMORY_INTER) %{
 3923     base($reg);
 3924     index(0x4);
 3925     scale(0x0);
 3926     disp($off);
 3927   %}
 3928 %}
 3929 
 3930 // Indirect Memory Plus Index Register Plus Offset Operand
 3931 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3932 %{
 3933   predicate(CompressedOops::shift() == 0);
 3934   constraint(ALLOC_IN_RC(ptr_reg));
 3935   match(AddP (AddP (DecodeN reg) lreg) off);
 3936 
 3937   op_cost(10);
 3938   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3939   interface(MEMORY_INTER) %{
 3940     base($reg);
 3941     index($lreg);
 3942     scale(0x0);
 3943     disp($off);
 3944   %}
 3945 %}
 3946 
 3947 // Indirect Memory Plus Index Register Plus Offset Operand
 3948 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3949 %{
 3950   predicate(CompressedOops::shift() == 0);
 3951   constraint(ALLOC_IN_RC(ptr_reg));
 3952   match(AddP (DecodeN reg) lreg);
 3953 
 3954   op_cost(10);
 3955   format %{&quot;[$reg + $lreg]&quot; %}
 3956   interface(MEMORY_INTER) %{
 3957     base($reg);
 3958     index($lreg);
 3959     scale(0x0);
 3960     disp(0x0);
 3961   %}
 3962 %}
 3963 
 3964 // Indirect Memory Times Scale Plus Index Register
 3965 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3966 %{
 3967   predicate(CompressedOops::shift() == 0);
 3968   constraint(ALLOC_IN_RC(ptr_reg));
 3969   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3970 
 3971   op_cost(10);
 3972   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3973   interface(MEMORY_INTER) %{
 3974     base($reg);
 3975     index($lreg);
 3976     scale($scale);
 3977     disp(0x0);
 3978   %}
 3979 %}
 3980 
 3981 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3982 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3983 %{
 3984   predicate(CompressedOops::shift() == 0);
 3985   constraint(ALLOC_IN_RC(ptr_reg));
 3986   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3987 
 3988   op_cost(10);
 3989   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3990   interface(MEMORY_INTER) %{
 3991     base($reg);
 3992     index($lreg);
 3993     scale($scale);
 3994     disp($off);
 3995   %}
 3996 %}
 3997 
 3998 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 3999 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4000 %{
 4001   constraint(ALLOC_IN_RC(ptr_reg));
 4002   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4003   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4004 
 4005   op_cost(10);
 4006   format %{&quot;[$reg + $off + $idx]&quot; %}
 4007   interface(MEMORY_INTER) %{
 4008     base($reg);
 4009     index($idx);
 4010     scale(0x0);
 4011     disp($off);
 4012   %}
 4013 %}
 4014 
 4015 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4016 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4017 %{
 4018   constraint(ALLOC_IN_RC(ptr_reg));
 4019   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4020   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4021 
 4022   op_cost(10);
 4023   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4024   interface(MEMORY_INTER) %{
 4025     base($reg);
 4026     index($idx);
 4027     scale($scale);
 4028     disp($off);
 4029   %}
 4030 %}
 4031 
 4032 //----------Special Memory Operands--------------------------------------------
 4033 // Stack Slot Operand - This operand is used for loading and storing temporary
 4034 //                      values on the stack where a match requires a value to
 4035 //                      flow through memory.
 4036 operand stackSlotP(sRegP reg)
 4037 %{
 4038   constraint(ALLOC_IN_RC(stack_slots));
 4039   // No match rule because this operand is only generated in matching
 4040 
 4041   format %{ &quot;[$reg]&quot; %}
 4042   interface(MEMORY_INTER) %{
 4043     base(0x4);   // RSP
 4044     index(0x4);  // No Index
 4045     scale(0x0);  // No Scale
 4046     disp($reg);  // Stack Offset
 4047   %}
 4048 %}
 4049 
 4050 operand stackSlotI(sRegI reg)
 4051 %{
 4052   constraint(ALLOC_IN_RC(stack_slots));
 4053   // No match rule because this operand is only generated in matching
 4054 
 4055   format %{ &quot;[$reg]&quot; %}
 4056   interface(MEMORY_INTER) %{
 4057     base(0x4);   // RSP
 4058     index(0x4);  // No Index
 4059     scale(0x0);  // No Scale
 4060     disp($reg);  // Stack Offset
 4061   %}
 4062 %}
 4063 
 4064 operand stackSlotF(sRegF reg)
 4065 %{
 4066   constraint(ALLOC_IN_RC(stack_slots));
 4067   // No match rule because this operand is only generated in matching
 4068 
 4069   format %{ &quot;[$reg]&quot; %}
 4070   interface(MEMORY_INTER) %{
 4071     base(0x4);   // RSP
 4072     index(0x4);  // No Index
 4073     scale(0x0);  // No Scale
 4074     disp($reg);  // Stack Offset
 4075   %}
 4076 %}
 4077 
 4078 operand stackSlotD(sRegD reg)
 4079 %{
 4080   constraint(ALLOC_IN_RC(stack_slots));
 4081   // No match rule because this operand is only generated in matching
 4082 
 4083   format %{ &quot;[$reg]&quot; %}
 4084   interface(MEMORY_INTER) %{
 4085     base(0x4);   // RSP
 4086     index(0x4);  // No Index
 4087     scale(0x0);  // No Scale
 4088     disp($reg);  // Stack Offset
 4089   %}
 4090 %}
 4091 operand stackSlotL(sRegL reg)
 4092 %{
 4093   constraint(ALLOC_IN_RC(stack_slots));
 4094   // No match rule because this operand is only generated in matching
 4095 
 4096   format %{ &quot;[$reg]&quot; %}
 4097   interface(MEMORY_INTER) %{
 4098     base(0x4);   // RSP
 4099     index(0x4);  // No Index
 4100     scale(0x0);  // No Scale
 4101     disp($reg);  // Stack Offset
 4102   %}
 4103 %}
 4104 
 4105 //----------Conditional Branch Operands----------------------------------------
 4106 // Comparison Op  - This is the operation of the comparison, and is limited to
 4107 //                  the following set of codes:
 4108 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4109 //
 4110 // Other attributes of the comparison, such as unsignedness, are specified
 4111 // by the comparison instruction that sets a condition code flags register.
 4112 // That result is represented by a flags operand whose subtype is appropriate
 4113 // to the unsignedness (etc.) of the comparison.
 4114 //
 4115 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4116 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4117 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4118 
 4119 // Comparision Code
 4120 operand cmpOp()
 4121 %{
 4122   match(Bool);
 4123 
 4124   format %{ &quot;&quot; %}
 4125   interface(COND_INTER) %{
 4126     equal(0x4, &quot;e&quot;);
 4127     not_equal(0x5, &quot;ne&quot;);
 4128     less(0xC, &quot;l&quot;);
 4129     greater_equal(0xD, &quot;ge&quot;);
 4130     less_equal(0xE, &quot;le&quot;);
 4131     greater(0xF, &quot;g&quot;);
 4132     overflow(0x0, &quot;o&quot;);
 4133     no_overflow(0x1, &quot;no&quot;);
 4134   %}
 4135 %}
 4136 
 4137 // Comparison Code, unsigned compare.  Used by FP also, with
 4138 // C2 (unordered) turned into GT or LT already.  The other bits
 4139 // C0 and C3 are turned into Carry &amp; Zero flags.
 4140 operand cmpOpU()
 4141 %{
 4142   match(Bool);
 4143 
 4144   format %{ &quot;&quot; %}
 4145   interface(COND_INTER) %{
 4146     equal(0x4, &quot;e&quot;);
 4147     not_equal(0x5, &quot;ne&quot;);
 4148     less(0x2, &quot;b&quot;);
 4149     greater_equal(0x3, &quot;nb&quot;);
 4150     less_equal(0x6, &quot;be&quot;);
 4151     greater(0x7, &quot;nbe&quot;);
 4152     overflow(0x0, &quot;o&quot;);
 4153     no_overflow(0x1, &quot;no&quot;);
 4154   %}
 4155 %}
 4156 
 4157 
 4158 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4159 operand cmpOpUCF() %{
 4160   match(Bool);
 4161   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4162             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4163             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4164             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4165   format %{ &quot;&quot; %}
 4166   interface(COND_INTER) %{
 4167     equal(0x4, &quot;e&quot;);
 4168     not_equal(0x5, &quot;ne&quot;);
 4169     less(0x2, &quot;b&quot;);
 4170     greater_equal(0x3, &quot;nb&quot;);
 4171     less_equal(0x6, &quot;be&quot;);
 4172     greater(0x7, &quot;nbe&quot;);
 4173     overflow(0x0, &quot;o&quot;);
 4174     no_overflow(0x1, &quot;no&quot;);
 4175   %}
 4176 %}
 4177 
 4178 
 4179 // Floating comparisons that can be fixed up with extra conditional jumps
 4180 operand cmpOpUCF2() %{
 4181   match(Bool);
 4182   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4183             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4184   format %{ &quot;&quot; %}
 4185   interface(COND_INTER) %{
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 //----------OPERAND CLASSES----------------------------------------------------
 4198 // Operand Classes are groups of operands that are used as to simplify
 4199 // instruction definitions by not requiring the AD writer to specify separate
 4200 // instructions for every form of operand when the instruction accepts
 4201 // multiple operand types with the same basic encoding and format.  The classic
 4202 // case of this is memory operands.
 4203 
 4204 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4205                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4206                indCompressedOopOffset,
 4207                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4208                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4209                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4210 
 4211 //----------PIPELINE-----------------------------------------------------------
 4212 // Rules which define the behavior of the target architectures pipeline.
 4213 pipeline %{
 4214 
 4215 //----------ATTRIBUTES---------------------------------------------------------
 4216 attributes %{
 4217   variable_size_instructions;        // Fixed size instructions
 4218   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4219   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4220   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4221   instruction_fetch_units = 1;       // of 16 bytes
 4222 
 4223   // List of nop instructions
 4224   nops( MachNop );
 4225 %}
 4226 
 4227 //----------RESOURCES----------------------------------------------------------
 4228 // Resources are the functional units available to the machine
 4229 
 4230 // Generic P2/P3 pipeline
 4231 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4232 // 3 instructions decoded per cycle.
 4233 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4234 // 3 ALU op, only ALU0 handles mul instructions.
 4235 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4236            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4237            BR, FPU,
 4238            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4239 
 4240 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4241 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4242 
 4243 // Generic P2/P3 pipeline
 4244 pipe_desc(S0, S1, S2, S3, S4, S5);
 4245 
 4246 //----------PIPELINE CLASSES---------------------------------------------------
 4247 // Pipeline Classes describe the stages in which input and output are
 4248 // referenced by the hardware pipeline.
 4249 
 4250 // Naming convention: ialu or fpu
 4251 // Then: _reg
 4252 // Then: _reg if there is a 2nd register
 4253 // Then: _long if it&#39;s a pair of instructions implementing a long
 4254 // Then: _fat if it requires the big decoder
 4255 //   Or: _mem if it requires the big decoder and a memory unit.
 4256 
 4257 // Integer ALU reg operation
 4258 pipe_class ialu_reg(rRegI dst)
 4259 %{
 4260     single_instruction;
 4261     dst    : S4(write);
 4262     dst    : S3(read);
 4263     DECODE : S0;        // any decoder
 4264     ALU    : S3;        // any alu
 4265 %}
 4266 
 4267 // Long ALU reg operation
 4268 pipe_class ialu_reg_long(rRegL dst)
 4269 %{
 4270     instruction_count(2);
 4271     dst    : S4(write);
 4272     dst    : S3(read);
 4273     DECODE : S0(2);     // any 2 decoders
 4274     ALU    : S3(2);     // both alus
 4275 %}
 4276 
 4277 // Integer ALU reg operation using big decoder
 4278 pipe_class ialu_reg_fat(rRegI dst)
 4279 %{
 4280     single_instruction;
 4281     dst    : S4(write);
 4282     dst    : S3(read);
 4283     D0     : S0;        // big decoder only
 4284     ALU    : S3;        // any alu
 4285 %}
 4286 
 4287 // Long ALU reg operation using big decoder
 4288 pipe_class ialu_reg_long_fat(rRegL dst)
 4289 %{
 4290     instruction_count(2);
 4291     dst    : S4(write);
 4292     dst    : S3(read);
 4293     D0     : S0(2);     // big decoder only; twice
 4294     ALU    : S3(2);     // any 2 alus
 4295 %}
 4296 
 4297 // Integer ALU reg-reg operation
 4298 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4299 %{
 4300     single_instruction;
 4301     dst    : S4(write);
 4302     src    : S3(read);
 4303     DECODE : S0;        // any decoder
 4304     ALU    : S3;        // any alu
 4305 %}
 4306 
 4307 // Long ALU reg-reg operation
 4308 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4309 %{
 4310     instruction_count(2);
 4311     dst    : S4(write);
 4312     src    : S3(read);
 4313     DECODE : S0(2);     // any 2 decoders
 4314     ALU    : S3(2);     // both alus
 4315 %}
 4316 
 4317 // Integer ALU reg-reg operation
 4318 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4319 %{
 4320     single_instruction;
 4321     dst    : S4(write);
 4322     src    : S3(read);
 4323     D0     : S0;        // big decoder only
 4324     ALU    : S3;        // any alu
 4325 %}
 4326 
 4327 // Long ALU reg-reg operation
 4328 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4329 %{
 4330     instruction_count(2);
 4331     dst    : S4(write);
 4332     src    : S3(read);
 4333     D0     : S0(2);     // big decoder only; twice
 4334     ALU    : S3(2);     // both alus
 4335 %}
 4336 
 4337 // Integer ALU reg-mem operation
 4338 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4339 %{
 4340     single_instruction;
 4341     dst    : S5(write);
 4342     mem    : S3(read);
 4343     D0     : S0;        // big decoder only
 4344     ALU    : S4;        // any alu
 4345     MEM    : S3;        // any mem
 4346 %}
 4347 
 4348 // Integer mem operation (prefetch)
 4349 pipe_class ialu_mem(memory mem)
 4350 %{
 4351     single_instruction;
 4352     mem    : S3(read);
 4353     D0     : S0;        // big decoder only
 4354     MEM    : S3;        // any mem
 4355 %}
 4356 
 4357 // Integer Store to Memory
 4358 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4359 %{
 4360     single_instruction;
 4361     mem    : S3(read);
 4362     src    : S5(read);
 4363     D0     : S0;        // big decoder only
 4364     ALU    : S4;        // any alu
 4365     MEM    : S3;
 4366 %}
 4367 
 4368 // // Long Store to Memory
 4369 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4370 // %{
 4371 //     instruction_count(2);
 4372 //     mem    : S3(read);
 4373 //     src    : S5(read);
 4374 //     D0     : S0(2);          // big decoder only; twice
 4375 //     ALU    : S4(2);     // any 2 alus
 4376 //     MEM    : S3(2);  // Both mems
 4377 // %}
 4378 
 4379 // Integer Store to Memory
 4380 pipe_class ialu_mem_imm(memory mem)
 4381 %{
 4382     single_instruction;
 4383     mem    : S3(read);
 4384     D0     : S0;        // big decoder only
 4385     ALU    : S4;        // any alu
 4386     MEM    : S3;
 4387 %}
 4388 
 4389 // Integer ALU0 reg-reg operation
 4390 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4391 %{
 4392     single_instruction;
 4393     dst    : S4(write);
 4394     src    : S3(read);
 4395     D0     : S0;        // Big decoder only
 4396     ALU0   : S3;        // only alu0
 4397 %}
 4398 
 4399 // Integer ALU0 reg-mem operation
 4400 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4401 %{
 4402     single_instruction;
 4403     dst    : S5(write);
 4404     mem    : S3(read);
 4405     D0     : S0;        // big decoder only
 4406     ALU0   : S4;        // ALU0 only
 4407     MEM    : S3;        // any mem
 4408 %}
 4409 
 4410 // Integer ALU reg-reg operation
 4411 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4412 %{
 4413     single_instruction;
 4414     cr     : S4(write);
 4415     src1   : S3(read);
 4416     src2   : S3(read);
 4417     DECODE : S0;        // any decoder
 4418     ALU    : S3;        // any alu
 4419 %}
 4420 
 4421 // Integer ALU reg-imm operation
 4422 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4423 %{
 4424     single_instruction;
 4425     cr     : S4(write);
 4426     src1   : S3(read);
 4427     DECODE : S0;        // any decoder
 4428     ALU    : S3;        // any alu
 4429 %}
 4430 
 4431 // Integer ALU reg-mem operation
 4432 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4433 %{
 4434     single_instruction;
 4435     cr     : S4(write);
 4436     src1   : S3(read);
 4437     src2   : S3(read);
 4438     D0     : S0;        // big decoder only
 4439     ALU    : S4;        // any alu
 4440     MEM    : S3;
 4441 %}
 4442 
 4443 // Conditional move reg-reg
 4444 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4445 %{
 4446     instruction_count(4);
 4447     y      : S4(read);
 4448     q      : S3(read);
 4449     p      : S3(read);
 4450     DECODE : S0(4);     // any decoder
 4451 %}
 4452 
 4453 // Conditional move reg-reg
 4454 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4455 %{
 4456     single_instruction;
 4457     dst    : S4(write);
 4458     src    : S3(read);
 4459     cr     : S3(read);
 4460     DECODE : S0;        // any decoder
 4461 %}
 4462 
 4463 // Conditional move reg-mem
 4464 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4465 %{
 4466     single_instruction;
 4467     dst    : S4(write);
 4468     src    : S3(read);
 4469     cr     : S3(read);
 4470     DECODE : S0;        // any decoder
 4471     MEM    : S3;
 4472 %}
 4473 
 4474 // Conditional move reg-reg long
 4475 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4476 %{
 4477     single_instruction;
 4478     dst    : S4(write);
 4479     src    : S3(read);
 4480     cr     : S3(read);
 4481     DECODE : S0(2);     // any 2 decoders
 4482 %}
 4483 
 4484 // XXX
 4485 // // Conditional move double reg-reg
 4486 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4487 // %{
 4488 //     single_instruction;
 4489 //     dst    : S4(write);
 4490 //     src    : S3(read);
 4491 //     cr     : S3(read);
 4492 //     DECODE : S0;     // any decoder
 4493 // %}
 4494 
 4495 // Float reg-reg operation
 4496 pipe_class fpu_reg(regD dst)
 4497 %{
 4498     instruction_count(2);
 4499     dst    : S3(read);
 4500     DECODE : S0(2);     // any 2 decoders
 4501     FPU    : S3;
 4502 %}
 4503 
 4504 // Float reg-reg operation
 4505 pipe_class fpu_reg_reg(regD dst, regD src)
 4506 %{
 4507     instruction_count(2);
 4508     dst    : S4(write);
 4509     src    : S3(read);
 4510     DECODE : S0(2);     // any 2 decoders
 4511     FPU    : S3;
 4512 %}
 4513 
 4514 // Float reg-reg operation
 4515 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4516 %{
 4517     instruction_count(3);
 4518     dst    : S4(write);
 4519     src1   : S3(read);
 4520     src2   : S3(read);
 4521     DECODE : S0(3);     // any 3 decoders
 4522     FPU    : S3(2);
 4523 %}
 4524 
 4525 // Float reg-reg operation
 4526 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4527 %{
 4528     instruction_count(4);
 4529     dst    : S4(write);
 4530     src1   : S3(read);
 4531     src2   : S3(read);
 4532     src3   : S3(read);
 4533     DECODE : S0(4);     // any 3 decoders
 4534     FPU    : S3(2);
 4535 %}
 4536 
 4537 // Float reg-reg operation
 4538 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4539 %{
 4540     instruction_count(4);
 4541     dst    : S4(write);
 4542     src1   : S3(read);
 4543     src2   : S3(read);
 4544     src3   : S3(read);
 4545     DECODE : S1(3);     // any 3 decoders
 4546     D0     : S0;        // Big decoder only
 4547     FPU    : S3(2);
 4548     MEM    : S3;
 4549 %}
 4550 
 4551 // Float reg-mem operation
 4552 pipe_class fpu_reg_mem(regD dst, memory mem)
 4553 %{
 4554     instruction_count(2);
 4555     dst    : S5(write);
 4556     mem    : S3(read);
 4557     D0     : S0;        // big decoder only
 4558     DECODE : S1;        // any decoder for FPU POP
 4559     FPU    : S4;
 4560     MEM    : S3;        // any mem
 4561 %}
 4562 
 4563 // Float reg-mem operation
 4564 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4565 %{
 4566     instruction_count(3);
 4567     dst    : S5(write);
 4568     src1   : S3(read);
 4569     mem    : S3(read);
 4570     D0     : S0;        // big decoder only
 4571     DECODE : S1(2);     // any decoder for FPU POP
 4572     FPU    : S4;
 4573     MEM    : S3;        // any mem
 4574 %}
 4575 
 4576 // Float mem-reg operation
 4577 pipe_class fpu_mem_reg(memory mem, regD src)
 4578 %{
 4579     instruction_count(2);
 4580     src    : S5(read);
 4581     mem    : S3(read);
 4582     DECODE : S0;        // any decoder for FPU PUSH
 4583     D0     : S1;        // big decoder only
 4584     FPU    : S4;
 4585     MEM    : S3;        // any mem
 4586 %}
 4587 
 4588 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4589 %{
 4590     instruction_count(3);
 4591     src1   : S3(read);
 4592     src2   : S3(read);
 4593     mem    : S3(read);
 4594     DECODE : S0(2);     // any decoder for FPU PUSH
 4595     D0     : S1;        // big decoder only
 4596     FPU    : S4;
 4597     MEM    : S3;        // any mem
 4598 %}
 4599 
 4600 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4601 %{
 4602     instruction_count(3);
 4603     src1   : S3(read);
 4604     src2   : S3(read);
 4605     mem    : S4(read);
 4606     DECODE : S0;        // any decoder for FPU PUSH
 4607     D0     : S0(2);     // big decoder only
 4608     FPU    : S4;
 4609     MEM    : S3(2);     // any mem
 4610 %}
 4611 
 4612 pipe_class fpu_mem_mem(memory dst, memory src1)
 4613 %{
 4614     instruction_count(2);
 4615     src1   : S3(read);
 4616     dst    : S4(read);
 4617     D0     : S0(2);     // big decoder only
 4618     MEM    : S3(2);     // any mem
 4619 %}
 4620 
 4621 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4622 %{
 4623     instruction_count(3);
 4624     src1   : S3(read);
 4625     src2   : S3(read);
 4626     dst    : S4(read);
 4627     D0     : S0(3);     // big decoder only
 4628     FPU    : S4;
 4629     MEM    : S3(3);     // any mem
 4630 %}
 4631 
 4632 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4633 %{
 4634     instruction_count(3);
 4635     src1   : S4(read);
 4636     mem    : S4(read);
 4637     DECODE : S0;        // any decoder for FPU PUSH
 4638     D0     : S0(2);     // big decoder only
 4639     FPU    : S4;
 4640     MEM    : S3(2);     // any mem
 4641 %}
 4642 
 4643 // Float load constant
 4644 pipe_class fpu_reg_con(regD dst)
 4645 %{
 4646     instruction_count(2);
 4647     dst    : S5(write);
 4648     D0     : S0;        // big decoder only for the load
 4649     DECODE : S1;        // any decoder for FPU POP
 4650     FPU    : S4;
 4651     MEM    : S3;        // any mem
 4652 %}
 4653 
 4654 // Float load constant
 4655 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4656 %{
 4657     instruction_count(3);
 4658     dst    : S5(write);
 4659     src    : S3(read);
 4660     D0     : S0;        // big decoder only for the load
 4661     DECODE : S1(2);     // any decoder for FPU POP
 4662     FPU    : S4;
 4663     MEM    : S3;        // any mem
 4664 %}
 4665 
 4666 // UnConditional branch
 4667 pipe_class pipe_jmp(label labl)
 4668 %{
 4669     single_instruction;
 4670     BR   : S3;
 4671 %}
 4672 
 4673 // Conditional branch
 4674 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4675 %{
 4676     single_instruction;
 4677     cr    : S1(read);
 4678     BR    : S3;
 4679 %}
 4680 
 4681 // Allocation idiom
 4682 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4683 %{
 4684     instruction_count(1); force_serialization;
 4685     fixed_latency(6);
 4686     heap_ptr : S3(read);
 4687     DECODE   : S0(3);
 4688     D0       : S2;
 4689     MEM      : S3;
 4690     ALU      : S3(2);
 4691     dst      : S5(write);
 4692     BR       : S5;
 4693 %}
 4694 
 4695 // Generic big/slow expanded idiom
 4696 pipe_class pipe_slow()
 4697 %{
 4698     instruction_count(10); multiple_bundles; force_serialization;
 4699     fixed_latency(100);
 4700     D0  : S0(2);
 4701     MEM : S3(2);
 4702 %}
 4703 
 4704 // The real do-nothing guy
 4705 pipe_class empty()
 4706 %{
 4707     instruction_count(0);
 4708 %}
 4709 
 4710 // Define the class for the Nop node
 4711 define
 4712 %{
 4713    MachNop = empty;
 4714 %}
 4715 
 4716 %}
 4717 
 4718 //----------INSTRUCTIONS-------------------------------------------------------
 4719 //
 4720 // match      -- States which machine-independent subtree may be replaced
 4721 //               by this instruction.
 4722 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4723 //               selection to identify a minimum cost tree of machine
 4724 //               instructions that matches a tree of machine-independent
 4725 //               instructions.
 4726 // format     -- A string providing the disassembly for this instruction.
 4727 //               The value of an instruction&#39;s operand may be inserted
 4728 //               by referring to it with a &#39;$&#39; prefix.
 4729 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4730 //               to within an encode class as $primary, $secondary, and $tertiary
 4731 //               rrspectively.  The primary opcode is commonly used to
 4732 //               indicate the type of machine instruction, while secondary
 4733 //               and tertiary are often used for prefix options or addressing
 4734 //               modes.
 4735 // ins_encode -- A list of encode classes with parameters. The encode class
 4736 //               name must have been defined in an &#39;enc_class&#39; specification
 4737 //               in the encode section of the architecture description.
 4738 
 4739 
 4740 //----------Load/Store/Move Instructions---------------------------------------
 4741 //----------Load Instructions--------------------------------------------------
 4742 
 4743 // Load Byte (8 bit signed)
 4744 instruct loadB(rRegI dst, memory mem)
 4745 %{
 4746   match(Set dst (LoadB mem));
 4747 
 4748   ins_cost(125);
 4749   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4750 
 4751   ins_encode %{
 4752     __ movsbl($dst$$Register, $mem$$Address);
 4753   %}
 4754 
 4755   ins_pipe(ialu_reg_mem);
 4756 %}
 4757 
 4758 // Load Byte (8 bit signed) into Long Register
 4759 instruct loadB2L(rRegL dst, memory mem)
 4760 %{
 4761   match(Set dst (ConvI2L (LoadB mem)));
 4762 
 4763   ins_cost(125);
 4764   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4765 
 4766   ins_encode %{
 4767     __ movsbq($dst$$Register, $mem$$Address);
 4768   %}
 4769 
 4770   ins_pipe(ialu_reg_mem);
 4771 %}
 4772 
 4773 // Load Unsigned Byte (8 bit UNsigned)
 4774 instruct loadUB(rRegI dst, memory mem)
 4775 %{
 4776   match(Set dst (LoadUB mem));
 4777 
 4778   ins_cost(125);
 4779   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4780 
 4781   ins_encode %{
 4782     __ movzbl($dst$$Register, $mem$$Address);
 4783   %}
 4784 
 4785   ins_pipe(ialu_reg_mem);
 4786 %}
 4787 
 4788 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4789 instruct loadUB2L(rRegL dst, memory mem)
 4790 %{
 4791   match(Set dst (ConvI2L (LoadUB mem)));
 4792 
 4793   ins_cost(125);
 4794   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4795 
 4796   ins_encode %{
 4797     __ movzbq($dst$$Register, $mem$$Address);
 4798   %}
 4799 
 4800   ins_pipe(ialu_reg_mem);
 4801 %}
 4802 
 4803 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4804 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4805   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4806   effect(KILL cr);
 4807 
 4808   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4809             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4810   ins_encode %{
 4811     Register Rdst = $dst$$Register;
 4812     __ movzbq(Rdst, $mem$$Address);
 4813     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4814   %}
 4815   ins_pipe(ialu_reg_mem);
 4816 %}
 4817 
 4818 // Load Short (16 bit signed)
 4819 instruct loadS(rRegI dst, memory mem)
 4820 %{
 4821   match(Set dst (LoadS mem));
 4822 
 4823   ins_cost(125);
 4824   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4825 
 4826   ins_encode %{
 4827     __ movswl($dst$$Register, $mem$$Address);
 4828   %}
 4829 
 4830   ins_pipe(ialu_reg_mem);
 4831 %}
 4832 
 4833 // Load Short (16 bit signed) to Byte (8 bit signed)
 4834 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4835   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4836 
 4837   ins_cost(125);
 4838   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4839   ins_encode %{
 4840     __ movsbl($dst$$Register, $mem$$Address);
 4841   %}
 4842   ins_pipe(ialu_reg_mem);
 4843 %}
 4844 
 4845 // Load Short (16 bit signed) into Long Register
 4846 instruct loadS2L(rRegL dst, memory mem)
 4847 %{
 4848   match(Set dst (ConvI2L (LoadS mem)));
 4849 
 4850   ins_cost(125);
 4851   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4852 
 4853   ins_encode %{
 4854     __ movswq($dst$$Register, $mem$$Address);
 4855   %}
 4856 
 4857   ins_pipe(ialu_reg_mem);
 4858 %}
 4859 
 4860 // Load Unsigned Short/Char (16 bit UNsigned)
 4861 instruct loadUS(rRegI dst, memory mem)
 4862 %{
 4863   match(Set dst (LoadUS mem));
 4864 
 4865   ins_cost(125);
 4866   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4867 
 4868   ins_encode %{
 4869     __ movzwl($dst$$Register, $mem$$Address);
 4870   %}
 4871 
 4872   ins_pipe(ialu_reg_mem);
 4873 %}
 4874 
 4875 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4876 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4877   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4878 
 4879   ins_cost(125);
 4880   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4881   ins_encode %{
 4882     __ movsbl($dst$$Register, $mem$$Address);
 4883   %}
 4884   ins_pipe(ialu_reg_mem);
 4885 %}
 4886 
 4887 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4888 instruct loadUS2L(rRegL dst, memory mem)
 4889 %{
 4890   match(Set dst (ConvI2L (LoadUS mem)));
 4891 
 4892   ins_cost(125);
 4893   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4894 
 4895   ins_encode %{
 4896     __ movzwq($dst$$Register, $mem$$Address);
 4897   %}
 4898 
 4899   ins_pipe(ialu_reg_mem);
 4900 %}
 4901 
 4902 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4903 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4904   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4905 
 4906   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4907   ins_encode %{
 4908     __ movzbq($dst$$Register, $mem$$Address);
 4909   %}
 4910   ins_pipe(ialu_reg_mem);
 4911 %}
 4912 
 4913 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4914 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4915   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4916   effect(KILL cr);
 4917 
 4918   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4919             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4920   ins_encode %{
 4921     Register Rdst = $dst$$Register;
 4922     __ movzwq(Rdst, $mem$$Address);
 4923     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4924   %}
 4925   ins_pipe(ialu_reg_mem);
 4926 %}
 4927 
 4928 // Load Integer
 4929 instruct loadI(rRegI dst, memory mem)
 4930 %{
 4931   match(Set dst (LoadI mem));
 4932 
 4933   ins_cost(125);
 4934   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4935 
 4936   ins_encode %{
 4937     __ movl($dst$$Register, $mem$$Address);
 4938   %}
 4939 
 4940   ins_pipe(ialu_reg_mem);
 4941 %}
 4942 
 4943 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4944 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4945   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4946 
 4947   ins_cost(125);
 4948   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4949   ins_encode %{
 4950     __ movsbl($dst$$Register, $mem$$Address);
 4951   %}
 4952   ins_pipe(ialu_reg_mem);
 4953 %}
 4954 
 4955 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4956 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4957   match(Set dst (AndI (LoadI mem) mask));
 4958 
 4959   ins_cost(125);
 4960   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4961   ins_encode %{
 4962     __ movzbl($dst$$Register, $mem$$Address);
 4963   %}
 4964   ins_pipe(ialu_reg_mem);
 4965 %}
 4966 
 4967 // Load Integer (32 bit signed) to Short (16 bit signed)
 4968 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4969   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4970 
 4971   ins_cost(125);
 4972   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4973   ins_encode %{
 4974     __ movswl($dst$$Register, $mem$$Address);
 4975   %}
 4976   ins_pipe(ialu_reg_mem);
 4977 %}
 4978 
 4979 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4980 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4981   match(Set dst (AndI (LoadI mem) mask));
 4982 
 4983   ins_cost(125);
 4984   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4985   ins_encode %{
 4986     __ movzwl($dst$$Register, $mem$$Address);
 4987   %}
 4988   ins_pipe(ialu_reg_mem);
 4989 %}
 4990 
 4991 // Load Integer into Long Register
 4992 instruct loadI2L(rRegL dst, memory mem)
 4993 %{
 4994   match(Set dst (ConvI2L (LoadI mem)));
 4995 
 4996   ins_cost(125);
 4997   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 4998 
 4999   ins_encode %{
 5000     __ movslq($dst$$Register, $mem$$Address);
 5001   %}
 5002 
 5003   ins_pipe(ialu_reg_mem);
 5004 %}
 5005 
 5006 // Load Integer with mask 0xFF into Long Register
 5007 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5008   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5009 
 5010   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5011   ins_encode %{
 5012     __ movzbq($dst$$Register, $mem$$Address);
 5013   %}
 5014   ins_pipe(ialu_reg_mem);
 5015 %}
 5016 
 5017 // Load Integer with mask 0xFFFF into Long Register
 5018 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5019   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5020 
 5021   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5022   ins_encode %{
 5023     __ movzwq($dst$$Register, $mem$$Address);
 5024   %}
 5025   ins_pipe(ialu_reg_mem);
 5026 %}
 5027 
 5028 // Load Integer with a 31-bit mask into Long Register
 5029 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5030   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5031   effect(KILL cr);
 5032 
 5033   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5034             &quot;andl    $dst, $mask&quot; %}
 5035   ins_encode %{
 5036     Register Rdst = $dst$$Register;
 5037     __ movl(Rdst, $mem$$Address);
 5038     __ andl(Rdst, $mask$$constant);
 5039   %}
 5040   ins_pipe(ialu_reg_mem);
 5041 %}
 5042 
 5043 // Load Unsigned Integer into Long Register
 5044 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5045 %{
 5046   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5047 
 5048   ins_cost(125);
 5049   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5050 
 5051   ins_encode %{
 5052     __ movl($dst$$Register, $mem$$Address);
 5053   %}
 5054 
 5055   ins_pipe(ialu_reg_mem);
 5056 %}
 5057 
 5058 // Load Long
 5059 instruct loadL(rRegL dst, memory mem)
 5060 %{
 5061   match(Set dst (LoadL mem));
 5062 
 5063   ins_cost(125);
 5064   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5065 
 5066   ins_encode %{
 5067     __ movq($dst$$Register, $mem$$Address);
 5068   %}
 5069 
 5070   ins_pipe(ialu_reg_mem); // XXX
 5071 %}
 5072 
 5073 // Load Range
 5074 instruct loadRange(rRegI dst, memory mem)
 5075 %{
 5076   match(Set dst (LoadRange mem));
 5077 
 5078   ins_cost(125); // XXX
 5079   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5080   opcode(0x8B);
 5081   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5082   ins_pipe(ialu_reg_mem);
 5083 %}
 5084 
 5085 // Load Pointer
 5086 instruct loadP(rRegP dst, memory mem)
 5087 %{
 5088   match(Set dst (LoadP mem));
 5089   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5090 
 5091   ins_cost(125); // XXX
 5092   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5093   opcode(0x8B);
 5094   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5095   ins_pipe(ialu_reg_mem); // XXX
 5096 %}
 5097 
 5098 // Load Compressed Pointer
 5099 instruct loadN(rRegN dst, memory mem)
 5100 %{
 5101    match(Set dst (LoadN mem));
 5102 
 5103    ins_cost(125); // XXX
 5104    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5105    ins_encode %{
 5106      __ movl($dst$$Register, $mem$$Address);
 5107    %}
 5108    ins_pipe(ialu_reg_mem); // XXX
 5109 %}
 5110 
 5111 
 5112 // Load Klass Pointer
 5113 instruct loadKlass(rRegP dst, memory mem)
 5114 %{
 5115   match(Set dst (LoadKlass mem));
 5116 
 5117   ins_cost(125); // XXX
 5118   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5119   opcode(0x8B);
 5120   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5121   ins_pipe(ialu_reg_mem); // XXX
 5122 %}
 5123 
 5124 // Load narrow Klass Pointer
 5125 instruct loadNKlass(rRegN dst, memory mem)
 5126 %{
 5127   match(Set dst (LoadNKlass mem));
 5128 
 5129   ins_cost(125); // XXX
 5130   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5131   ins_encode %{
 5132     __ movl($dst$$Register, $mem$$Address);
 5133   %}
 5134   ins_pipe(ialu_reg_mem); // XXX
 5135 %}
 5136 
 5137 // Load Float
 5138 instruct loadF(regF dst, memory mem)
 5139 %{
 5140   match(Set dst (LoadF mem));
 5141 
 5142   ins_cost(145); // XXX
 5143   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5144   ins_encode %{
 5145     __ movflt($dst$$XMMRegister, $mem$$Address);
 5146   %}
 5147   ins_pipe(pipe_slow); // XXX
 5148 %}
 5149 
 5150 // Load Float
 5151 instruct MoveF2VL(vlRegF dst, regF src) %{
 5152   match(Set dst src);
 5153   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5154   ins_encode %{
 5155     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5156   %}
 5157   ins_pipe( fpu_reg_reg );
 5158 %}
 5159 
 5160 // Load Float
 5161 instruct MoveF2LEG(legRegF dst, regF src) %{
 5162   match(Set dst src);
 5163   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5164   ins_encode %{
 5165     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5166   %}
 5167   ins_pipe( fpu_reg_reg );
 5168 %}
 5169 
 5170 // Load Float
 5171 instruct MoveVL2F(regF dst, vlRegF src) %{
 5172   match(Set dst src);
 5173   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5174   ins_encode %{
 5175     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5176   %}
 5177   ins_pipe( fpu_reg_reg );
 5178 %}
 5179 
 5180 // Load Float
 5181 instruct MoveLEG2F(regF dst, legRegF src) %{
 5182   match(Set dst src);
 5183   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5184   ins_encode %{
 5185     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5186   %}
 5187   ins_pipe( fpu_reg_reg );
 5188 %}
 5189 
 5190 // Load Double
 5191 instruct loadD_partial(regD dst, memory mem)
 5192 %{
 5193   predicate(!UseXmmLoadAndClearUpper);
 5194   match(Set dst (LoadD mem));
 5195 
 5196   ins_cost(145); // XXX
 5197   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5198   ins_encode %{
 5199     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5200   %}
 5201   ins_pipe(pipe_slow); // XXX
 5202 %}
 5203 
 5204 instruct loadD(regD dst, memory mem)
 5205 %{
 5206   predicate(UseXmmLoadAndClearUpper);
 5207   match(Set dst (LoadD mem));
 5208 
 5209   ins_cost(145); // XXX
 5210   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5211   ins_encode %{
 5212     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5213   %}
 5214   ins_pipe(pipe_slow); // XXX
 5215 %}
 5216 
 5217 // Load Double
 5218 instruct MoveD2VL(vlRegD dst, regD src) %{
 5219   match(Set dst src);
 5220   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5221   ins_encode %{
 5222     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5223   %}
 5224   ins_pipe( fpu_reg_reg );
 5225 %}
 5226 
 5227 // Load Double
 5228 instruct MoveD2LEG(legRegD dst, regD src) %{
 5229   match(Set dst src);
 5230   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5231   ins_encode %{
 5232     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5233   %}
 5234   ins_pipe( fpu_reg_reg );
 5235 %}
 5236 
 5237 // Load Double
 5238 instruct MoveVL2D(regD dst, vlRegD src) %{
 5239   match(Set dst src);
 5240   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5241   ins_encode %{
 5242     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5243   %}
 5244   ins_pipe( fpu_reg_reg );
 5245 %}
 5246 
 5247 // Load Double
 5248 instruct MoveLEG2D(regD dst, legRegD src) %{
 5249   match(Set dst src);
 5250   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5251   ins_encode %{
 5252     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5253   %}
 5254   ins_pipe( fpu_reg_reg );
 5255 %}
 5256 
 5257 // Following pseudo code describes the algorithm for max[FD]:
 5258 // Min algorithm is on similar lines
 5259 //  btmp = (b &lt; +0.0) ? a : b
 5260 //  atmp = (b &lt; +0.0) ? b : a
 5261 //  Tmp  = Max_Float(atmp , btmp)
 5262 //  Res  = (atmp == NaN) ? atmp : Tmp
 5263 
 5264 // max = java.lang.Math.max(float a, float b)
 5265 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5266   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5267   match(Set dst (MaxF a b));
 5268   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5269   format %{
 5270      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5271      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5272      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5273      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5274      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5275   %}
 5276   ins_encode %{
 5277     int vector_len = Assembler::AVX_128bit;
 5278     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5279     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5280     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5281     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5282     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5283  %}
 5284   ins_pipe( pipe_slow );
 5285 %}
 5286 
 5287 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5288   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5289   match(Set dst (MaxF a b));
 5290   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5291 
 5292   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5293   ins_encode %{
 5294     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5295                     false /*min*/, true /*single*/);
 5296   %}
 5297   ins_pipe( pipe_slow );
 5298 %}
 5299 
 5300 // max = java.lang.Math.max(double a, double b)
 5301 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5302   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5303   match(Set dst (MaxD a b));
 5304   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5305   format %{
 5306      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5307      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5308      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5309      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5310      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5311   %}
 5312   ins_encode %{
 5313     int vector_len = Assembler::AVX_128bit;
 5314     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5315     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5316     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5317     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5318     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5319   %}
 5320   ins_pipe( pipe_slow );
 5321 %}
 5322 
 5323 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5324   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5325   match(Set dst (MaxD a b));
 5326   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5327 
 5328   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5329   ins_encode %{
 5330     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5331                     false /*min*/, false /*single*/);
 5332   %}
 5333   ins_pipe( pipe_slow );
 5334 %}
 5335 
 5336 // min = java.lang.Math.min(float a, float b)
 5337 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5338   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5339   match(Set dst (MinF a b));
 5340   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5341   format %{
 5342      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5343      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5344      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5345      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5346      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5347   %}
 5348   ins_encode %{
 5349     int vector_len = Assembler::AVX_128bit;
 5350     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5351     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5352     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5353     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5354     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5355   %}
 5356   ins_pipe( pipe_slow );
 5357 %}
 5358 
 5359 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5360   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5361   match(Set dst (MinF a b));
 5362   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5363 
 5364   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5365   ins_encode %{
 5366     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5367                     true /*min*/, true /*single*/);
 5368   %}
 5369   ins_pipe( pipe_slow );
 5370 %}
 5371 
 5372 // min = java.lang.Math.min(double a, double b)
 5373 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5374   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5375   match(Set dst (MinD a b));
 5376   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5377   format %{
 5378      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5379      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5380      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5381      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5382      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5383   %}
 5384   ins_encode %{
 5385     int vector_len = Assembler::AVX_128bit;
 5386     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5387     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5388     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5389     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5390     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5391   %}
 5392   ins_pipe( pipe_slow );
 5393 %}
 5394 
 5395 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5396   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5397   match(Set dst (MinD a b));
 5398   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5399 
 5400   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5401   ins_encode %{
 5402     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5403                     true /*min*/, false /*single*/);
 5404   %}
 5405   ins_pipe( pipe_slow );
 5406 %}
 5407 
 5408 // Load Effective Address
 5409 instruct leaP8(rRegP dst, indOffset8 mem)
 5410 %{
 5411   match(Set dst mem);
 5412 
 5413   ins_cost(110); // XXX
 5414   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5415   opcode(0x8D);
 5416   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5417   ins_pipe(ialu_reg_reg_fat);
 5418 %}
 5419 
 5420 instruct leaP32(rRegP dst, indOffset32 mem)
 5421 %{
 5422   match(Set dst mem);
 5423 
 5424   ins_cost(110);
 5425   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5426   opcode(0x8D);
 5427   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5428   ins_pipe(ialu_reg_reg_fat);
 5429 %}
 5430 
 5431 // instruct leaPIdx(rRegP dst, indIndex mem)
 5432 // %{
 5433 //   match(Set dst mem);
 5434 
 5435 //   ins_cost(110);
 5436 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5437 //   opcode(0x8D);
 5438 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5439 //   ins_pipe(ialu_reg_reg_fat);
 5440 // %}
 5441 
 5442 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5443 %{
 5444   match(Set dst mem);
 5445 
 5446   ins_cost(110);
 5447   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5448   opcode(0x8D);
 5449   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5450   ins_pipe(ialu_reg_reg_fat);
 5451 %}
 5452 
 5453 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5454 %{
 5455   match(Set dst mem);
 5456 
 5457   ins_cost(110);
 5458   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5459   opcode(0x8D);
 5460   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5461   ins_pipe(ialu_reg_reg_fat);
 5462 %}
 5463 
 5464 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5465 %{
 5466   match(Set dst mem);
 5467 
 5468   ins_cost(110);
 5469   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5470   opcode(0x8D);
 5471   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5472   ins_pipe(ialu_reg_reg_fat);
 5473 %}
 5474 
 5475 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5476 %{
 5477   match(Set dst mem);
 5478 
 5479   ins_cost(110);
 5480   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5481   opcode(0x8D);
 5482   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5483   ins_pipe(ialu_reg_reg_fat);
 5484 %}
 5485 
 5486 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5487 %{
 5488   match(Set dst mem);
 5489 
 5490   ins_cost(110);
 5491   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5492   opcode(0x8D);
 5493   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5494   ins_pipe(ialu_reg_reg_fat);
 5495 %}
 5496 
 5497 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5498 %{
 5499   match(Set dst mem);
 5500 
 5501   ins_cost(110);
 5502   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5503   opcode(0x8D);
 5504   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5505   ins_pipe(ialu_reg_reg_fat);
 5506 %}
 5507 
 5508 // Load Effective Address which uses Narrow (32-bits) oop
 5509 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5510 %{
 5511   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5512   match(Set dst mem);
 5513 
 5514   ins_cost(110);
 5515   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5516   opcode(0x8D);
 5517   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5518   ins_pipe(ialu_reg_reg_fat);
 5519 %}
 5520 
 5521 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5522 %{
 5523   predicate(CompressedOops::shift() == 0);
 5524   match(Set dst mem);
 5525 
 5526   ins_cost(110); // XXX
 5527   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5528   opcode(0x8D);
 5529   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5530   ins_pipe(ialu_reg_reg_fat);
 5531 %}
 5532 
 5533 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5534 %{
 5535   predicate(CompressedOops::shift() == 0);
 5536   match(Set dst mem);
 5537 
 5538   ins_cost(110);
 5539   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5540   opcode(0x8D);
 5541   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5542   ins_pipe(ialu_reg_reg_fat);
 5543 %}
 5544 
 5545 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5546 %{
 5547   predicate(CompressedOops::shift() == 0);
 5548   match(Set dst mem);
 5549 
 5550   ins_cost(110);
 5551   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5552   opcode(0x8D);
 5553   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5554   ins_pipe(ialu_reg_reg_fat);
 5555 %}
 5556 
 5557 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5558 %{
 5559   predicate(CompressedOops::shift() == 0);
 5560   match(Set dst mem);
 5561 
 5562   ins_cost(110);
 5563   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5564   opcode(0x8D);
 5565   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5566   ins_pipe(ialu_reg_reg_fat);
 5567 %}
 5568 
 5569 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5570 %{
 5571   predicate(CompressedOops::shift() == 0);
 5572   match(Set dst mem);
 5573 
 5574   ins_cost(110);
 5575   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5576   opcode(0x8D);
 5577   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5578   ins_pipe(ialu_reg_reg_fat);
 5579 %}
 5580 
 5581 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5582 %{
 5583   predicate(CompressedOops::shift() == 0);
 5584   match(Set dst mem);
 5585 
 5586   ins_cost(110);
 5587   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5588   opcode(0x8D);
 5589   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5590   ins_pipe(ialu_reg_reg_fat);
 5591 %}
 5592 
 5593 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5594 %{
 5595   predicate(CompressedOops::shift() == 0);
 5596   match(Set dst mem);
 5597 
 5598   ins_cost(110);
 5599   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5600   opcode(0x8D);
 5601   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5602   ins_pipe(ialu_reg_reg_fat);
 5603 %}
 5604 
 5605 instruct loadConI(rRegI dst, immI src)
 5606 %{
 5607   match(Set dst src);
 5608 
 5609   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5610   ins_encode(load_immI(dst, src));
 5611   ins_pipe(ialu_reg_fat); // XXX
 5612 %}
 5613 
 5614 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5615 %{
 5616   match(Set dst src);
 5617   effect(KILL cr);
 5618 
 5619   ins_cost(50);
 5620   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5621   opcode(0x33); /* + rd */
 5622   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5623   ins_pipe(ialu_reg);
 5624 %}
 5625 
 5626 instruct loadConL(rRegL dst, immL src)
 5627 %{
 5628   match(Set dst src);
 5629 
 5630   ins_cost(150);
 5631   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5632   ins_encode(load_immL(dst, src));
 5633   ins_pipe(ialu_reg);
 5634 %}
 5635 
 5636 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5637 %{
 5638   match(Set dst src);
 5639   effect(KILL cr);
 5640 
 5641   ins_cost(50);
 5642   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5643   opcode(0x33); /* + rd */
 5644   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5645   ins_pipe(ialu_reg); // XXX
 5646 %}
 5647 
 5648 instruct loadConUL32(rRegL dst, immUL32 src)
 5649 %{
 5650   match(Set dst src);
 5651 
 5652   ins_cost(60);
 5653   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5654   ins_encode(load_immUL32(dst, src));
 5655   ins_pipe(ialu_reg);
 5656 %}
 5657 
 5658 instruct loadConL32(rRegL dst, immL32 src)
 5659 %{
 5660   match(Set dst src);
 5661 
 5662   ins_cost(70);
 5663   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5664   ins_encode(load_immL32(dst, src));
 5665   ins_pipe(ialu_reg);
 5666 %}
 5667 
 5668 instruct loadConP(rRegP dst, immP con) %{
 5669   match(Set dst con);
 5670 
 5671   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5672   ins_encode(load_immP(dst, con));
 5673   ins_pipe(ialu_reg_fat); // XXX
 5674 %}
 5675 
 5676 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5677 %{
 5678   match(Set dst src);
 5679   effect(KILL cr);
 5680 
 5681   ins_cost(50);
 5682   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5683   opcode(0x33); /* + rd */
 5684   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5685   ins_pipe(ialu_reg);
 5686 %}
 5687 
 5688 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5689 %{
 5690   match(Set dst src);
 5691   effect(KILL cr);
 5692 
 5693   ins_cost(60);
 5694   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5695   ins_encode(load_immP31(dst, src));
 5696   ins_pipe(ialu_reg);
 5697 %}
 5698 
 5699 instruct loadConF(regF dst, immF con) %{
 5700   match(Set dst con);
 5701   ins_cost(125);
 5702   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5703   ins_encode %{
 5704     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5705   %}
 5706   ins_pipe(pipe_slow);
 5707 %}
 5708 
 5709 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5710   match(Set dst src);
 5711   effect(KILL cr);
 5712   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5713   ins_encode %{
 5714     __ xorq($dst$$Register, $dst$$Register);
 5715   %}
 5716   ins_pipe(ialu_reg);
 5717 %}
 5718 
 5719 instruct loadConN(rRegN dst, immN src) %{
 5720   match(Set dst src);
 5721 
 5722   ins_cost(125);
 5723   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5724   ins_encode %{
 5725     address con = (address)$src$$constant;
 5726     if (con == NULL) {
 5727       ShouldNotReachHere();
 5728     } else {
 5729       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5730     }
 5731   %}
 5732   ins_pipe(ialu_reg_fat); // XXX
 5733 %}
 5734 
 5735 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5736   match(Set dst src);
 5737 
 5738   ins_cost(125);
 5739   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5740   ins_encode %{
 5741     address con = (address)$src$$constant;
 5742     if (con == NULL) {
 5743       ShouldNotReachHere();
 5744     } else {
 5745       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5746     }
 5747   %}
 5748   ins_pipe(ialu_reg_fat); // XXX
 5749 %}
 5750 
 5751 instruct loadConF0(regF dst, immF0 src)
 5752 %{
 5753   match(Set dst src);
 5754   ins_cost(100);
 5755 
 5756   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5757   ins_encode %{
 5758     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5759   %}
 5760   ins_pipe(pipe_slow);
 5761 %}
 5762 
 5763 // Use the same format since predicate() can not be used here.
 5764 instruct loadConD(regD dst, immD con) %{
 5765   match(Set dst con);
 5766   ins_cost(125);
 5767   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5768   ins_encode %{
 5769     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5770   %}
 5771   ins_pipe(pipe_slow);
 5772 %}
 5773 
 5774 instruct loadConD0(regD dst, immD0 src)
 5775 %{
 5776   match(Set dst src);
 5777   ins_cost(100);
 5778 
 5779   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5780   ins_encode %{
 5781     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5782   %}
 5783   ins_pipe(pipe_slow);
 5784 %}
 5785 
 5786 instruct loadSSI(rRegI dst, stackSlotI src)
 5787 %{
 5788   match(Set dst src);
 5789 
 5790   ins_cost(125);
 5791   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5792   opcode(0x8B);
 5793   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5794   ins_pipe(ialu_reg_mem);
 5795 %}
 5796 
 5797 instruct loadSSL(rRegL dst, stackSlotL src)
 5798 %{
 5799   match(Set dst src);
 5800 
 5801   ins_cost(125);
 5802   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5803   opcode(0x8B);
 5804   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5805   ins_pipe(ialu_reg_mem);
 5806 %}
 5807 
 5808 instruct loadSSP(rRegP dst, stackSlotP src)
 5809 %{
 5810   match(Set dst src);
 5811 
 5812   ins_cost(125);
 5813   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5814   opcode(0x8B);
 5815   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5816   ins_pipe(ialu_reg_mem);
 5817 %}
 5818 
 5819 instruct loadSSF(regF dst, stackSlotF src)
 5820 %{
 5821   match(Set dst src);
 5822 
 5823   ins_cost(125);
 5824   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5825   ins_encode %{
 5826     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5827   %}
 5828   ins_pipe(pipe_slow); // XXX
 5829 %}
 5830 
 5831 // Use the same format since predicate() can not be used here.
 5832 instruct loadSSD(regD dst, stackSlotD src)
 5833 %{
 5834   match(Set dst src);
 5835 
 5836   ins_cost(125);
 5837   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5838   ins_encode  %{
 5839     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5840   %}
 5841   ins_pipe(pipe_slow); // XXX
 5842 %}
 5843 
 5844 // Prefetch instructions for allocation.
 5845 // Must be safe to execute with invalid address (cannot fault).
 5846 
 5847 instruct prefetchAlloc( memory mem ) %{
 5848   predicate(AllocatePrefetchInstr==3);
 5849   match(PrefetchAllocation mem);
 5850   ins_cost(125);
 5851 
 5852   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5853   ins_encode %{
 5854     __ prefetchw($mem$$Address);
 5855   %}
 5856   ins_pipe(ialu_mem);
 5857 %}
 5858 
 5859 instruct prefetchAllocNTA( memory mem ) %{
 5860   predicate(AllocatePrefetchInstr==0);
 5861   match(PrefetchAllocation mem);
 5862   ins_cost(125);
 5863 
 5864   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5865   ins_encode %{
 5866     __ prefetchnta($mem$$Address);
 5867   %}
 5868   ins_pipe(ialu_mem);
 5869 %}
 5870 
 5871 instruct prefetchAllocT0( memory mem ) %{
 5872   predicate(AllocatePrefetchInstr==1);
 5873   match(PrefetchAllocation mem);
 5874   ins_cost(125);
 5875 
 5876   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5877   ins_encode %{
 5878     __ prefetcht0($mem$$Address);
 5879   %}
 5880   ins_pipe(ialu_mem);
 5881 %}
 5882 
 5883 instruct prefetchAllocT2( memory mem ) %{
 5884   predicate(AllocatePrefetchInstr==2);
 5885   match(PrefetchAllocation mem);
 5886   ins_cost(125);
 5887 
 5888   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5889   ins_encode %{
 5890     __ prefetcht2($mem$$Address);
 5891   %}
 5892   ins_pipe(ialu_mem);
 5893 %}
 5894 
 5895 //----------Store Instructions-------------------------------------------------
 5896 
 5897 // Store Byte
 5898 instruct storeB(memory mem, rRegI src)
 5899 %{
 5900   match(Set mem (StoreB mem src));
 5901 
 5902   ins_cost(125); // XXX
 5903   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5904   opcode(0x88);
 5905   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5906   ins_pipe(ialu_mem_reg);
 5907 %}
 5908 
 5909 // Store Char/Short
 5910 instruct storeC(memory mem, rRegI src)
 5911 %{
 5912   match(Set mem (StoreC mem src));
 5913 
 5914   ins_cost(125); // XXX
 5915   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5916   opcode(0x89);
 5917   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5918   ins_pipe(ialu_mem_reg);
 5919 %}
 5920 
 5921 // Store Integer
 5922 instruct storeI(memory mem, rRegI src)
 5923 %{
 5924   match(Set mem (StoreI mem src));
 5925 
 5926   ins_cost(125); // XXX
 5927   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5928   opcode(0x89);
 5929   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5930   ins_pipe(ialu_mem_reg);
 5931 %}
 5932 
 5933 // Store Long
 5934 instruct storeL(memory mem, rRegL src)
 5935 %{
 5936   match(Set mem (StoreL mem src));
 5937 
 5938   ins_cost(125); // XXX
 5939   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5940   opcode(0x89);
 5941   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5942   ins_pipe(ialu_mem_reg); // XXX
 5943 %}
 5944 
 5945 // Store Pointer
 5946 instruct storeP(memory mem, any_RegP src)
 5947 %{
 5948   match(Set mem (StoreP mem src));
 5949 
 5950   ins_cost(125); // XXX
 5951   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5952   opcode(0x89);
 5953   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5954   ins_pipe(ialu_mem_reg);
 5955 %}
 5956 
 5957 instruct storeImmP0(memory mem, immP0 zero)
 5958 %{
<a name="3" id="anc3"></a><span class="line-modified"> 5959   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 5960   match(Set mem (StoreP mem zero));
 5961 
 5962   ins_cost(125); // XXX
 5963   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5964   ins_encode %{
 5965     __ movq($mem$$Address, r12);
 5966   %}
 5967   ins_pipe(ialu_mem_reg);
 5968 %}
 5969 
 5970 // Store NULL Pointer, mark word, or other simple pointer constant.
 5971 instruct storeImmP(memory mem, immP31 src)
 5972 %{
 5973   match(Set mem (StoreP mem src));
 5974 
 5975   ins_cost(150); // XXX
 5976   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5977   opcode(0xC7); /* C7 /0 */
 5978   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5979   ins_pipe(ialu_mem_imm);
 5980 %}
 5981 
 5982 // Store Compressed Pointer
 5983 instruct storeN(memory mem, rRegN src)
 5984 %{
 5985   match(Set mem (StoreN mem src));
 5986 
 5987   ins_cost(125); // XXX
 5988   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5989   ins_encode %{
 5990     __ movl($mem$$Address, $src$$Register);
 5991   %}
 5992   ins_pipe(ialu_mem_reg);
 5993 %}
 5994 
 5995 instruct storeNKlass(memory mem, rRegN src)
 5996 %{
 5997   match(Set mem (StoreNKlass mem src));
 5998 
 5999   ins_cost(125); // XXX
 6000   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6001   ins_encode %{
 6002     __ movl($mem$$Address, $src$$Register);
 6003   %}
 6004   ins_pipe(ialu_mem_reg);
 6005 %}
 6006 
 6007 instruct storeImmN0(memory mem, immN0 zero)
 6008 %{
<a name="4" id="anc4"></a><span class="line-modified"> 6009   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);</span>
 6010   match(Set mem (StoreN mem zero));
 6011 
 6012   ins_cost(125); // XXX
 6013   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6014   ins_encode %{
 6015     __ movl($mem$$Address, r12);
 6016   %}
 6017   ins_pipe(ialu_mem_reg);
 6018 %}
 6019 
 6020 instruct storeImmN(memory mem, immN src)
 6021 %{
 6022   match(Set mem (StoreN mem src));
 6023 
 6024   ins_cost(150); // XXX
 6025   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6026   ins_encode %{
 6027     address con = (address)$src$$constant;
 6028     if (con == NULL) {
 6029       __ movl($mem$$Address, (int32_t)0);
 6030     } else {
 6031       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6032     }
 6033   %}
 6034   ins_pipe(ialu_mem_imm);
 6035 %}
 6036 
 6037 instruct storeImmNKlass(memory mem, immNKlass src)
 6038 %{
 6039   match(Set mem (StoreNKlass mem src));
 6040 
 6041   ins_cost(150); // XXX
 6042   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6043   ins_encode %{
 6044     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6045   %}
 6046   ins_pipe(ialu_mem_imm);
 6047 %}
 6048 
 6049 // Store Integer Immediate
 6050 instruct storeImmI0(memory mem, immI0 zero)
 6051 %{
<a name="5" id="anc5"></a><span class="line-modified"> 6052   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6053   match(Set mem (StoreI mem zero));
 6054 
 6055   ins_cost(125); // XXX
 6056   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6057   ins_encode %{
 6058     __ movl($mem$$Address, r12);
 6059   %}
 6060   ins_pipe(ialu_mem_reg);
 6061 %}
 6062 
 6063 instruct storeImmI(memory mem, immI src)
 6064 %{
 6065   match(Set mem (StoreI mem src));
 6066 
 6067   ins_cost(150);
 6068   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6069   opcode(0xC7); /* C7 /0 */
 6070   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6071   ins_pipe(ialu_mem_imm);
 6072 %}
 6073 
 6074 // Store Long Immediate
 6075 instruct storeImmL0(memory mem, immL0 zero)
 6076 %{
<a name="6" id="anc6"></a><span class="line-modified"> 6077   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6078   match(Set mem (StoreL mem zero));
 6079 
 6080   ins_cost(125); // XXX
 6081   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6082   ins_encode %{
 6083     __ movq($mem$$Address, r12);
 6084   %}
 6085   ins_pipe(ialu_mem_reg);
 6086 %}
 6087 
 6088 instruct storeImmL(memory mem, immL32 src)
 6089 %{
 6090   match(Set mem (StoreL mem src));
 6091 
 6092   ins_cost(150);
 6093   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6094   opcode(0xC7); /* C7 /0 */
 6095   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6096   ins_pipe(ialu_mem_imm);
 6097 %}
 6098 
 6099 // Store Short/Char Immediate
 6100 instruct storeImmC0(memory mem, immI0 zero)
 6101 %{
<a name="7" id="anc7"></a><span class="line-modified"> 6102   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6103   match(Set mem (StoreC mem zero));
 6104 
 6105   ins_cost(125); // XXX
 6106   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6107   ins_encode %{
 6108     __ movw($mem$$Address, r12);
 6109   %}
 6110   ins_pipe(ialu_mem_reg);
 6111 %}
 6112 
 6113 instruct storeImmI16(memory mem, immI16 src)
 6114 %{
 6115   predicate(UseStoreImmI16);
 6116   match(Set mem (StoreC mem src));
 6117 
 6118   ins_cost(150);
 6119   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6120   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6121   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6122   ins_pipe(ialu_mem_imm);
 6123 %}
 6124 
 6125 // Store Byte Immediate
 6126 instruct storeImmB0(memory mem, immI0 zero)
 6127 %{
<a name="8" id="anc8"></a><span class="line-modified"> 6128   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6129   match(Set mem (StoreB mem zero));
 6130 
 6131   ins_cost(125); // XXX
 6132   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6133   ins_encode %{
 6134     __ movb($mem$$Address, r12);
 6135   %}
 6136   ins_pipe(ialu_mem_reg);
 6137 %}
 6138 
 6139 instruct storeImmB(memory mem, immI8 src)
 6140 %{
 6141   match(Set mem (StoreB mem src));
 6142 
 6143   ins_cost(150); // XXX
 6144   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6145   opcode(0xC6); /* C6 /0 */
 6146   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6147   ins_pipe(ialu_mem_imm);
 6148 %}
 6149 
 6150 // Store CMS card-mark Immediate
 6151 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6152 %{
<a name="9" id="anc9"></a><span class="line-modified"> 6153   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6154   match(Set mem (StoreCM mem zero));
 6155 
 6156   ins_cost(125); // XXX
 6157   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6158   ins_encode %{
 6159     __ movb($mem$$Address, r12);
 6160   %}
 6161   ins_pipe(ialu_mem_reg);
 6162 %}
 6163 
 6164 instruct storeImmCM0(memory mem, immI0 src)
 6165 %{
 6166   match(Set mem (StoreCM mem src));
 6167 
 6168   ins_cost(150); // XXX
 6169   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6170   opcode(0xC6); /* C6 /0 */
 6171   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6172   ins_pipe(ialu_mem_imm);
 6173 %}
 6174 
 6175 // Store Float
 6176 instruct storeF(memory mem, regF src)
 6177 %{
 6178   match(Set mem (StoreF mem src));
 6179 
 6180   ins_cost(95); // XXX
 6181   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6182   ins_encode %{
 6183     __ movflt($mem$$Address, $src$$XMMRegister);
 6184   %}
 6185   ins_pipe(pipe_slow); // XXX
 6186 %}
 6187 
 6188 // Store immediate Float value (it is faster than store from XMM register)
 6189 instruct storeF0(memory mem, immF0 zero)
 6190 %{
<a name="10" id="anc10"></a><span class="line-modified"> 6191   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6192   match(Set mem (StoreF mem zero));
 6193 
 6194   ins_cost(25); // XXX
 6195   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6196   ins_encode %{
 6197     __ movl($mem$$Address, r12);
 6198   %}
 6199   ins_pipe(ialu_mem_reg);
 6200 %}
 6201 
 6202 instruct storeF_imm(memory mem, immF src)
 6203 %{
 6204   match(Set mem (StoreF mem src));
 6205 
 6206   ins_cost(50);
 6207   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6208   opcode(0xC7); /* C7 /0 */
 6209   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6210   ins_pipe(ialu_mem_imm);
 6211 %}
 6212 
 6213 // Store Double
 6214 instruct storeD(memory mem, regD src)
 6215 %{
 6216   match(Set mem (StoreD mem src));
 6217 
 6218   ins_cost(95); // XXX
 6219   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6220   ins_encode %{
 6221     __ movdbl($mem$$Address, $src$$XMMRegister);
 6222   %}
 6223   ins_pipe(pipe_slow); // XXX
 6224 %}
 6225 
 6226 // Store immediate double 0.0 (it is faster than store from XMM register)
 6227 instruct storeD0_imm(memory mem, immD0 src)
 6228 %{
 6229   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6230   match(Set mem (StoreD mem src));
 6231 
 6232   ins_cost(50);
 6233   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6234   opcode(0xC7); /* C7 /0 */
 6235   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6236   ins_pipe(ialu_mem_imm);
 6237 %}
 6238 
 6239 instruct storeD0(memory mem, immD0 zero)
 6240 %{
<a name="11" id="anc11"></a><span class="line-modified"> 6241   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
 6242   match(Set mem (StoreD mem zero));
 6243 
 6244   ins_cost(25); // XXX
 6245   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6246   ins_encode %{
 6247     __ movq($mem$$Address, r12);
 6248   %}
 6249   ins_pipe(ialu_mem_reg);
 6250 %}
 6251 
 6252 instruct storeSSI(stackSlotI dst, rRegI src)
 6253 %{
 6254   match(Set dst src);
 6255 
 6256   ins_cost(100);
 6257   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6258   opcode(0x89);
 6259   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6260   ins_pipe( ialu_mem_reg );
 6261 %}
 6262 
 6263 instruct storeSSL(stackSlotL dst, rRegL src)
 6264 %{
 6265   match(Set dst src);
 6266 
 6267   ins_cost(100);
 6268   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6269   opcode(0x89);
 6270   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6271   ins_pipe(ialu_mem_reg);
 6272 %}
 6273 
 6274 instruct storeSSP(stackSlotP dst, rRegP src)
 6275 %{
 6276   match(Set dst src);
 6277 
 6278   ins_cost(100);
 6279   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6280   opcode(0x89);
 6281   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6282   ins_pipe(ialu_mem_reg);
 6283 %}
 6284 
 6285 instruct storeSSF(stackSlotF dst, regF src)
 6286 %{
 6287   match(Set dst src);
 6288 
 6289   ins_cost(95); // XXX
 6290   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6291   ins_encode %{
 6292     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6293   %}
 6294   ins_pipe(pipe_slow); // XXX
 6295 %}
 6296 
 6297 instruct storeSSD(stackSlotD dst, regD src)
 6298 %{
 6299   match(Set dst src);
 6300 
 6301   ins_cost(95); // XXX
 6302   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6303   ins_encode %{
 6304     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6305   %}
 6306   ins_pipe(pipe_slow); // XXX
 6307 %}
 6308 
 6309 instruct cacheWB(indirect addr)
 6310 %{
 6311   predicate(VM_Version::supports_data_cache_line_flush());
 6312   match(CacheWB addr);
 6313 
 6314   ins_cost(100);
 6315   format %{&quot;cache wb $addr&quot; %}
 6316   ins_encode %{
 6317     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6318     assert($addr$$disp == 0, &quot;should be&quot;);
 6319     __ cache_wb(Address($addr$$base$$Register, 0));
 6320   %}
 6321   ins_pipe(pipe_slow); // XXX
 6322 %}
 6323 
 6324 instruct cacheWBPreSync()
 6325 %{
 6326   predicate(VM_Version::supports_data_cache_line_flush());
 6327   match(CacheWBPreSync);
 6328 
 6329   ins_cost(100);
 6330   format %{&quot;cache wb presync&quot; %}
 6331   ins_encode %{
 6332     __ cache_wbsync(true);
 6333   %}
 6334   ins_pipe(pipe_slow); // XXX
 6335 %}
 6336 
 6337 instruct cacheWBPostSync()
 6338 %{
 6339   predicate(VM_Version::supports_data_cache_line_flush());
 6340   match(CacheWBPostSync);
 6341 
 6342   ins_cost(100);
 6343   format %{&quot;cache wb postsync&quot; %}
 6344   ins_encode %{
 6345     __ cache_wbsync(false);
 6346   %}
 6347   ins_pipe(pipe_slow); // XXX
 6348 %}
 6349 
 6350 //----------BSWAP Instructions-------------------------------------------------
 6351 instruct bytes_reverse_int(rRegI dst) %{
 6352   match(Set dst (ReverseBytesI dst));
 6353 
 6354   format %{ &quot;bswapl  $dst&quot; %}
 6355   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6356   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6357   ins_pipe( ialu_reg );
 6358 %}
 6359 
 6360 instruct bytes_reverse_long(rRegL dst) %{
 6361   match(Set dst (ReverseBytesL dst));
 6362 
 6363   format %{ &quot;bswapq  $dst&quot; %}
 6364   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6365   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6366   ins_pipe( ialu_reg);
 6367 %}
 6368 
 6369 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6370   match(Set dst (ReverseBytesUS dst));
 6371   effect(KILL cr);
 6372 
 6373   format %{ &quot;bswapl  $dst\n\t&quot;
 6374             &quot;shrl    $dst,16\n\t&quot; %}
 6375   ins_encode %{
 6376     __ bswapl($dst$$Register);
 6377     __ shrl($dst$$Register, 16);
 6378   %}
 6379   ins_pipe( ialu_reg );
 6380 %}
 6381 
 6382 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6383   match(Set dst (ReverseBytesS dst));
 6384   effect(KILL cr);
 6385 
 6386   format %{ &quot;bswapl  $dst\n\t&quot;
 6387             &quot;sar     $dst,16\n\t&quot; %}
 6388   ins_encode %{
 6389     __ bswapl($dst$$Register);
 6390     __ sarl($dst$$Register, 16);
 6391   %}
 6392   ins_pipe( ialu_reg );
 6393 %}
 6394 
 6395 //---------- Zeros Count Instructions ------------------------------------------
 6396 
 6397 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6398   predicate(UseCountLeadingZerosInstruction);
 6399   match(Set dst (CountLeadingZerosI src));
 6400   effect(KILL cr);
 6401 
 6402   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6403   ins_encode %{
 6404     __ lzcntl($dst$$Register, $src$$Register);
 6405   %}
 6406   ins_pipe(ialu_reg);
 6407 %}
 6408 
 6409 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6410   predicate(!UseCountLeadingZerosInstruction);
 6411   match(Set dst (CountLeadingZerosI src));
 6412   effect(KILL cr);
 6413 
 6414   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6415             &quot;jnz     skip\n\t&quot;
 6416             &quot;movl    $dst, -1\n&quot;
 6417       &quot;skip:\n\t&quot;
 6418             &quot;negl    $dst\n\t&quot;
 6419             &quot;addl    $dst, 31&quot; %}
 6420   ins_encode %{
 6421     Register Rdst = $dst$$Register;
 6422     Register Rsrc = $src$$Register;
 6423     Label skip;
 6424     __ bsrl(Rdst, Rsrc);
 6425     __ jccb(Assembler::notZero, skip);
 6426     __ movl(Rdst, -1);
 6427     __ bind(skip);
 6428     __ negl(Rdst);
 6429     __ addl(Rdst, BitsPerInt - 1);
 6430   %}
 6431   ins_pipe(ialu_reg);
 6432 %}
 6433 
 6434 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6435   predicate(UseCountLeadingZerosInstruction);
 6436   match(Set dst (CountLeadingZerosL src));
 6437   effect(KILL cr);
 6438 
 6439   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6440   ins_encode %{
 6441     __ lzcntq($dst$$Register, $src$$Register);
 6442   %}
 6443   ins_pipe(ialu_reg);
 6444 %}
 6445 
 6446 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6447   predicate(!UseCountLeadingZerosInstruction);
 6448   match(Set dst (CountLeadingZerosL src));
 6449   effect(KILL cr);
 6450 
 6451   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6452             &quot;jnz     skip\n\t&quot;
 6453             &quot;movl    $dst, -1\n&quot;
 6454       &quot;skip:\n\t&quot;
 6455             &quot;negl    $dst\n\t&quot;
 6456             &quot;addl    $dst, 63&quot; %}
 6457   ins_encode %{
 6458     Register Rdst = $dst$$Register;
 6459     Register Rsrc = $src$$Register;
 6460     Label skip;
 6461     __ bsrq(Rdst, Rsrc);
 6462     __ jccb(Assembler::notZero, skip);
 6463     __ movl(Rdst, -1);
 6464     __ bind(skip);
 6465     __ negl(Rdst);
 6466     __ addl(Rdst, BitsPerLong - 1);
 6467   %}
 6468   ins_pipe(ialu_reg);
 6469 %}
 6470 
 6471 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6472   predicate(UseCountTrailingZerosInstruction);
 6473   match(Set dst (CountTrailingZerosI src));
 6474   effect(KILL cr);
 6475 
 6476   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6477   ins_encode %{
 6478     __ tzcntl($dst$$Register, $src$$Register);
 6479   %}
 6480   ins_pipe(ialu_reg);
 6481 %}
 6482 
 6483 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6484   predicate(!UseCountTrailingZerosInstruction);
 6485   match(Set dst (CountTrailingZerosI src));
 6486   effect(KILL cr);
 6487 
 6488   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6489             &quot;jnz     done\n\t&quot;
 6490             &quot;movl    $dst, 32\n&quot;
 6491       &quot;done:&quot; %}
 6492   ins_encode %{
 6493     Register Rdst = $dst$$Register;
 6494     Label done;
 6495     __ bsfl(Rdst, $src$$Register);
 6496     __ jccb(Assembler::notZero, done);
 6497     __ movl(Rdst, BitsPerInt);
 6498     __ bind(done);
 6499   %}
 6500   ins_pipe(ialu_reg);
 6501 %}
 6502 
 6503 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6504   predicate(UseCountTrailingZerosInstruction);
 6505   match(Set dst (CountTrailingZerosL src));
 6506   effect(KILL cr);
 6507 
 6508   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6509   ins_encode %{
 6510     __ tzcntq($dst$$Register, $src$$Register);
 6511   %}
 6512   ins_pipe(ialu_reg);
 6513 %}
 6514 
 6515 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6516   predicate(!UseCountTrailingZerosInstruction);
 6517   match(Set dst (CountTrailingZerosL src));
 6518   effect(KILL cr);
 6519 
 6520   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6521             &quot;jnz     done\n\t&quot;
 6522             &quot;movl    $dst, 64\n&quot;
 6523       &quot;done:&quot; %}
 6524   ins_encode %{
 6525     Register Rdst = $dst$$Register;
 6526     Label done;
 6527     __ bsfq(Rdst, $src$$Register);
 6528     __ jccb(Assembler::notZero, done);
 6529     __ movl(Rdst, BitsPerLong);
 6530     __ bind(done);
 6531   %}
 6532   ins_pipe(ialu_reg);
 6533 %}
 6534 
 6535 
 6536 //---------- Population Count Instructions -------------------------------------
 6537 
 6538 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6539   predicate(UsePopCountInstruction);
 6540   match(Set dst (PopCountI src));
 6541   effect(KILL cr);
 6542 
 6543   format %{ &quot;popcnt  $dst, $src&quot; %}
 6544   ins_encode %{
 6545     __ popcntl($dst$$Register, $src$$Register);
 6546   %}
 6547   ins_pipe(ialu_reg);
 6548 %}
 6549 
 6550 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6551   predicate(UsePopCountInstruction);
 6552   match(Set dst (PopCountI (LoadI mem)));
 6553   effect(KILL cr);
 6554 
 6555   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6556   ins_encode %{
 6557     __ popcntl($dst$$Register, $mem$$Address);
 6558   %}
 6559   ins_pipe(ialu_reg);
 6560 %}
 6561 
 6562 // Note: Long.bitCount(long) returns an int.
 6563 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6564   predicate(UsePopCountInstruction);
 6565   match(Set dst (PopCountL src));
 6566   effect(KILL cr);
 6567 
 6568   format %{ &quot;popcnt  $dst, $src&quot; %}
 6569   ins_encode %{
 6570     __ popcntq($dst$$Register, $src$$Register);
 6571   %}
 6572   ins_pipe(ialu_reg);
 6573 %}
 6574 
 6575 // Note: Long.bitCount(long) returns an int.
 6576 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6577   predicate(UsePopCountInstruction);
 6578   match(Set dst (PopCountL (LoadL mem)));
 6579   effect(KILL cr);
 6580 
 6581   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6582   ins_encode %{
 6583     __ popcntq($dst$$Register, $mem$$Address);
 6584   %}
 6585   ins_pipe(ialu_reg);
 6586 %}
 6587 
 6588 
 6589 //----------MemBar Instructions-----------------------------------------------
 6590 // Memory barrier flavors
 6591 
 6592 instruct membar_acquire()
 6593 %{
 6594   match(MemBarAcquire);
 6595   match(LoadFence);
 6596   ins_cost(0);
 6597 
 6598   size(0);
 6599   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6600   ins_encode();
 6601   ins_pipe(empty);
 6602 %}
 6603 
 6604 instruct membar_acquire_lock()
 6605 %{
 6606   match(MemBarAcquireLock);
 6607   ins_cost(0);
 6608 
 6609   size(0);
 6610   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6611   ins_encode();
 6612   ins_pipe(empty);
 6613 %}
 6614 
 6615 instruct membar_release()
 6616 %{
 6617   match(MemBarRelease);
 6618   match(StoreFence);
 6619   ins_cost(0);
 6620 
 6621   size(0);
 6622   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6623   ins_encode();
 6624   ins_pipe(empty);
 6625 %}
 6626 
 6627 instruct membar_release_lock()
 6628 %{
 6629   match(MemBarReleaseLock);
 6630   ins_cost(0);
 6631 
 6632   size(0);
 6633   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6634   ins_encode();
 6635   ins_pipe(empty);
 6636 %}
 6637 
 6638 instruct membar_volatile(rFlagsReg cr) %{
 6639   match(MemBarVolatile);
 6640   effect(KILL cr);
 6641   ins_cost(400);
 6642 
 6643   format %{
 6644     $$template
 6645     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6646   %}
 6647   ins_encode %{
 6648     __ membar(Assembler::StoreLoad);
 6649   %}
 6650   ins_pipe(pipe_slow);
 6651 %}
 6652 
 6653 instruct unnecessary_membar_volatile()
 6654 %{
 6655   match(MemBarVolatile);
 6656   predicate(Matcher::post_store_load_barrier(n));
 6657   ins_cost(0);
 6658 
 6659   size(0);
 6660   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6661   ins_encode();
 6662   ins_pipe(empty);
 6663 %}
 6664 
 6665 instruct membar_storestore() %{
 6666   match(MemBarStoreStore);
 6667   ins_cost(0);
 6668 
 6669   size(0);
 6670   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 //----------Move Instructions--------------------------------------------------
 6676 
 6677 instruct castX2P(rRegP dst, rRegL src)
 6678 %{
 6679   match(Set dst (CastX2P src));
 6680 
 6681   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6682   ins_encode %{
 6683     if ($dst$$reg != $src$$reg) {
 6684       __ movptr($dst$$Register, $src$$Register);
 6685     }
 6686   %}
 6687   ins_pipe(ialu_reg_reg); // XXX
 6688 %}
 6689 
 6690 instruct castP2X(rRegL dst, rRegP src)
 6691 %{
 6692   match(Set dst (CastP2X src));
 6693 
 6694   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6695   ins_encode %{
 6696     if ($dst$$reg != $src$$reg) {
 6697       __ movptr($dst$$Register, $src$$Register);
 6698     }
 6699   %}
 6700   ins_pipe(ialu_reg_reg); // XXX
 6701 %}
 6702 
 6703 // Convert oop into int for vectors alignment masking
 6704 instruct convP2I(rRegI dst, rRegP src)
 6705 %{
 6706   match(Set dst (ConvL2I (CastP2X src)));
 6707 
 6708   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6709   ins_encode %{
 6710     __ movl($dst$$Register, $src$$Register);
 6711   %}
 6712   ins_pipe(ialu_reg_reg); // XXX
 6713 %}
 6714 
 6715 // Convert compressed oop into int for vectors alignment masking
 6716 // in case of 32bit oops (heap &lt; 4Gb).
 6717 instruct convN2I(rRegI dst, rRegN src)
 6718 %{
 6719   predicate(CompressedOops::shift() == 0);
 6720   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6721 
 6722   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6723   ins_encode %{
 6724     __ movl($dst$$Register, $src$$Register);
 6725   %}
 6726   ins_pipe(ialu_reg_reg); // XXX
 6727 %}
 6728 
 6729 // Convert oop pointer into compressed form
 6730 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6731   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6732   match(Set dst (EncodeP src));
 6733   effect(KILL cr);
 6734   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6735   ins_encode %{
 6736     Register s = $src$$Register;
 6737     Register d = $dst$$Register;
 6738     if (s != d) {
 6739       __ movq(d, s);
 6740     }
 6741     __ encode_heap_oop(d);
 6742   %}
 6743   ins_pipe(ialu_reg_long);
 6744 %}
 6745 
 6746 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6747   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6748   match(Set dst (EncodeP src));
 6749   effect(KILL cr);
 6750   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6751   ins_encode %{
 6752     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6753   %}
 6754   ins_pipe(ialu_reg_long);
 6755 %}
 6756 
 6757 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6758   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6759             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6760   match(Set dst (DecodeN src));
 6761   effect(KILL cr);
 6762   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6763   ins_encode %{
 6764     Register s = $src$$Register;
 6765     Register d = $dst$$Register;
 6766     if (s != d) {
 6767       __ movq(d, s);
 6768     }
 6769     __ decode_heap_oop(d);
 6770   %}
 6771   ins_pipe(ialu_reg_long);
 6772 %}
 6773 
 6774 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6775   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6776             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6777   match(Set dst (DecodeN src));
 6778   effect(KILL cr);
 6779   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6780   ins_encode %{
 6781     Register s = $src$$Register;
 6782     Register d = $dst$$Register;
 6783     if (s != d) {
 6784       __ decode_heap_oop_not_null(d, s);
 6785     } else {
 6786       __ decode_heap_oop_not_null(d);
 6787     }
 6788   %}
 6789   ins_pipe(ialu_reg_long);
 6790 %}
 6791 
 6792 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6793   match(Set dst (EncodePKlass src));
<a name="12" id="anc12"></a><span class="line-modified"> 6794   effect(KILL cr);</span>
<span class="line-modified"> 6795   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}</span>
 6796   ins_encode %{
<a name="13" id="anc13"></a><span class="line-modified"> 6797     __ encode_klass_not_null($dst$$Register, $src$$Register);</span>
 6798   %}
 6799   ins_pipe(ialu_reg_long);
 6800 %}
 6801 
 6802 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6803   match(Set dst (DecodeNKlass src));
<a name="14" id="anc14"></a><span class="line-modified"> 6804   effect(KILL cr);</span>
<span class="line-modified"> 6805   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}</span>
 6806   ins_encode %{
<a name="15" id="anc15"></a><span class="line-modified"> 6807     Register s = $src$$Register;</span>
<span class="line-removed"> 6808     Register d = $dst$$Register;</span>
<span class="line-removed"> 6809     if (s != d) {</span>
<span class="line-removed"> 6810       __ decode_klass_not_null(d, s);</span>
<span class="line-removed"> 6811     } else {</span>
<span class="line-removed"> 6812       __ decode_klass_not_null(d);</span>
<span class="line-removed"> 6813     }</span>
 6814   %}
 6815   ins_pipe(ialu_reg_long);
 6816 %}
 6817 
<a name="16" id="anc16"></a><span class="line-removed"> 6818 </span>
 6819 //----------Conditional Move---------------------------------------------------
 6820 // Jump
 6821 // dummy instruction for generating temp registers
 6822 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6823   match(Jump (LShiftL switch_val shift));
 6824   ins_cost(350);
 6825   predicate(false);
 6826   effect(TEMP dest);
 6827 
 6828   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6829             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6830   ins_encode %{
 6831     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6832     // to do that and the compiler is using that register as one it can allocate.
 6833     // So we build it all by hand.
 6834     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6835     // ArrayAddress dispatch(table, index);
 6836     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6837     __ lea($dest$$Register, $constantaddress);
 6838     __ jmp(dispatch);
 6839   %}
 6840   ins_pipe(pipe_jmp);
 6841 %}
 6842 
 6843 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6844   match(Jump (AddL (LShiftL switch_val shift) offset));
 6845   ins_cost(350);
 6846   effect(TEMP dest);
 6847 
 6848   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6849             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6850   ins_encode %{
 6851     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6852     // to do that and the compiler is using that register as one it can allocate.
 6853     // So we build it all by hand.
 6854     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6855     // ArrayAddress dispatch(table, index);
 6856     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6857     __ lea($dest$$Register, $constantaddress);
 6858     __ jmp(dispatch);
 6859   %}
 6860   ins_pipe(pipe_jmp);
 6861 %}
 6862 
 6863 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6864   match(Jump switch_val);
 6865   ins_cost(350);
 6866   effect(TEMP dest);
 6867 
 6868   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6869             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6870   ins_encode %{
 6871     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6872     // to do that and the compiler is using that register as one it can allocate.
 6873     // So we build it all by hand.
 6874     // Address index(noreg, switch_reg, Address::times_1);
 6875     // ArrayAddress dispatch(table, index);
 6876     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6877     __ lea($dest$$Register, $constantaddress);
 6878     __ jmp(dispatch);
 6879   %}
 6880   ins_pipe(pipe_jmp);
 6881 %}
 6882 
 6883 // Conditional move
 6884 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6885 %{
 6886   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6887 
 6888   ins_cost(200); // XXX
 6889   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6890   opcode(0x0F, 0x40);
 6891   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6892   ins_pipe(pipe_cmov_reg);
 6893 %}
 6894 
 6895 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6896   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6897 
 6898   ins_cost(200); // XXX
 6899   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6900   opcode(0x0F, 0x40);
 6901   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6902   ins_pipe(pipe_cmov_reg);
 6903 %}
 6904 
 6905 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6906   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6907   ins_cost(200);
 6908   expand %{
 6909     cmovI_regU(cop, cr, dst, src);
 6910   %}
 6911 %}
 6912 
 6913 // Conditional move
 6914 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6915   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6916 
 6917   ins_cost(250); // XXX
 6918   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6919   opcode(0x0F, 0x40);
 6920   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6921   ins_pipe(pipe_cmov_mem);
 6922 %}
 6923 
 6924 // Conditional move
 6925 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6926 %{
 6927   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6928 
 6929   ins_cost(250); // XXX
 6930   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6931   opcode(0x0F, 0x40);
 6932   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6933   ins_pipe(pipe_cmov_mem);
 6934 %}
 6935 
 6936 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6937   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6938   ins_cost(250);
 6939   expand %{
 6940     cmovI_memU(cop, cr, dst, src);
 6941   %}
 6942 %}
 6943 
 6944 // Conditional move
 6945 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6946 %{
 6947   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6948 
 6949   ins_cost(200); // XXX
 6950   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6951   opcode(0x0F, 0x40);
 6952   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6953   ins_pipe(pipe_cmov_reg);
 6954 %}
 6955 
 6956 // Conditional move
 6957 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6958 %{
 6959   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6960 
 6961   ins_cost(200); // XXX
 6962   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6963   opcode(0x0F, 0x40);
 6964   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6965   ins_pipe(pipe_cmov_reg);
 6966 %}
 6967 
 6968 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 6969   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6970   ins_cost(200);
 6971   expand %{
 6972     cmovN_regU(cop, cr, dst, src);
 6973   %}
 6974 %}
 6975 
 6976 // Conditional move
 6977 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 6978 %{
 6979   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6980 
 6981   ins_cost(200); // XXX
 6982   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 6983   opcode(0x0F, 0x40);
 6984   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6985   ins_pipe(pipe_cmov_reg);  // XXX
 6986 %}
 6987 
 6988 // Conditional move
 6989 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 6990 %{
 6991   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6992 
 6993   ins_cost(200); // XXX
 6994   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 6995   opcode(0x0F, 0x40);
 6996   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6997   ins_pipe(pipe_cmov_reg); // XXX
 6998 %}
 6999 
 7000 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7001   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7002   ins_cost(200);
 7003   expand %{
 7004     cmovP_regU(cop, cr, dst, src);
 7005   %}
 7006 %}
 7007 
 7008 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7009 // correctly meets the two pointer arguments; one is an incoming
 7010 // register but the other is a memory operand.  ALSO appears to
 7011 // be buggy with implicit null checks.
 7012 //
 7013 //// Conditional move
 7014 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7015 //%{
 7016 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7017 //  ins_cost(250);
 7018 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7019 //  opcode(0x0F,0x40);
 7020 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7021 //  ins_pipe( pipe_cmov_mem );
 7022 //%}
 7023 //
 7024 //// Conditional move
 7025 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7026 //%{
 7027 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7028 //  ins_cost(250);
 7029 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7030 //  opcode(0x0F,0x40);
 7031 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7032 //  ins_pipe( pipe_cmov_mem );
 7033 //%}
 7034 
 7035 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7036 %{
 7037   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7038 
 7039   ins_cost(200); // XXX
 7040   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7041   opcode(0x0F, 0x40);
 7042   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7043   ins_pipe(pipe_cmov_reg);  // XXX
 7044 %}
 7045 
 7046 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7047 %{
 7048   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7049 
 7050   ins_cost(200); // XXX
 7051   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7052   opcode(0x0F, 0x40);
 7053   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7054   ins_pipe(pipe_cmov_mem);  // XXX
 7055 %}
 7056 
 7057 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7058 %{
 7059   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7060 
 7061   ins_cost(200); // XXX
 7062   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7063   opcode(0x0F, 0x40);
 7064   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7065   ins_pipe(pipe_cmov_reg); // XXX
 7066 %}
 7067 
 7068 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7069   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7070   ins_cost(200);
 7071   expand %{
 7072     cmovL_regU(cop, cr, dst, src);
 7073   %}
 7074 %}
 7075 
 7076 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7077 %{
 7078   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7079 
 7080   ins_cost(200); // XXX
 7081   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7082   opcode(0x0F, 0x40);
 7083   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7084   ins_pipe(pipe_cmov_mem); // XXX
 7085 %}
 7086 
 7087 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7088   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7089   ins_cost(200);
 7090   expand %{
 7091     cmovL_memU(cop, cr, dst, src);
 7092   %}
 7093 %}
 7094 
 7095 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7096 %{
 7097   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7098 
 7099   ins_cost(200); // XXX
 7100   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7101             &quot;movss     $dst, $src\n&quot;
 7102     &quot;skip:&quot; %}
 7103   ins_encode %{
 7104     Label Lskip;
 7105     // Invert sense of branch from sense of CMOV
 7106     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7107     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7108     __ bind(Lskip);
 7109   %}
 7110   ins_pipe(pipe_slow);
 7111 %}
 7112 
 7113 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7114 // %{
 7115 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7116 
 7117 //   ins_cost(200); // XXX
 7118 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7119 //             &quot;movss     $dst, $src\n&quot;
 7120 //     &quot;skip:&quot; %}
 7121 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7122 //   ins_pipe(pipe_slow);
 7123 // %}
 7124 
 7125 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7126 %{
 7127   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7128 
 7129   ins_cost(200); // XXX
 7130   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7131             &quot;movss     $dst, $src\n&quot;
 7132     &quot;skip:&quot; %}
 7133   ins_encode %{
 7134     Label Lskip;
 7135     // Invert sense of branch from sense of CMOV
 7136     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7137     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7138     __ bind(Lskip);
 7139   %}
 7140   ins_pipe(pipe_slow);
 7141 %}
 7142 
 7143 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7144   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7145   ins_cost(200);
 7146   expand %{
 7147     cmovF_regU(cop, cr, dst, src);
 7148   %}
 7149 %}
 7150 
 7151 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7152 %{
 7153   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7154 
 7155   ins_cost(200); // XXX
 7156   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7157             &quot;movsd     $dst, $src\n&quot;
 7158     &quot;skip:&quot; %}
 7159   ins_encode %{
 7160     Label Lskip;
 7161     // Invert sense of branch from sense of CMOV
 7162     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7163     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7164     __ bind(Lskip);
 7165   %}
 7166   ins_pipe(pipe_slow);
 7167 %}
 7168 
 7169 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7170 %{
 7171   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7172 
 7173   ins_cost(200); // XXX
 7174   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7175             &quot;movsd     $dst, $src\n&quot;
 7176     &quot;skip:&quot; %}
 7177   ins_encode %{
 7178     Label Lskip;
 7179     // Invert sense of branch from sense of CMOV
 7180     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7181     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7182     __ bind(Lskip);
 7183   %}
 7184   ins_pipe(pipe_slow);
 7185 %}
 7186 
 7187 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7188   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7189   ins_cost(200);
 7190   expand %{
 7191     cmovD_regU(cop, cr, dst, src);
 7192   %}
 7193 %}
 7194 
 7195 //----------Arithmetic Instructions--------------------------------------------
 7196 //----------Addition Instructions----------------------------------------------
 7197 
 7198 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7199 %{
 7200   match(Set dst (AddI dst src));
 7201   effect(KILL cr);
 7202 
 7203   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7204   opcode(0x03);
 7205   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7206   ins_pipe(ialu_reg_reg);
 7207 %}
 7208 
 7209 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7210 %{
 7211   match(Set dst (AddI dst src));
 7212   effect(KILL cr);
 7213 
 7214   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7215   opcode(0x81, 0x00); /* /0 id */
 7216   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7217   ins_pipe( ialu_reg );
 7218 %}
 7219 
 7220 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7221 %{
 7222   match(Set dst (AddI dst (LoadI src)));
 7223   effect(KILL cr);
 7224 
 7225   ins_cost(125); // XXX
 7226   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7227   opcode(0x03);
 7228   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7229   ins_pipe(ialu_reg_mem);
 7230 %}
 7231 
 7232 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7233 %{
 7234   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7235   effect(KILL cr);
 7236 
 7237   ins_cost(150); // XXX
 7238   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7239   opcode(0x01); /* Opcode 01 /r */
 7240   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7241   ins_pipe(ialu_mem_reg);
 7242 %}
 7243 
 7244 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7245 %{
 7246   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7247   effect(KILL cr);
 7248 
 7249   ins_cost(125); // XXX
 7250   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7251   opcode(0x81); /* Opcode 81 /0 id */
 7252   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7253   ins_pipe(ialu_mem_imm);
 7254 %}
 7255 
 7256 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7257 %{
 7258   predicate(UseIncDec);
 7259   match(Set dst (AddI dst src));
 7260   effect(KILL cr);
 7261 
 7262   format %{ &quot;incl    $dst\t# int&quot; %}
 7263   opcode(0xFF, 0x00); // FF /0
 7264   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7265   ins_pipe(ialu_reg);
 7266 %}
 7267 
 7268 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7269 %{
 7270   predicate(UseIncDec);
 7271   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7272   effect(KILL cr);
 7273 
 7274   ins_cost(125); // XXX
 7275   format %{ &quot;incl    $dst\t# int&quot; %}
 7276   opcode(0xFF); /* Opcode FF /0 */
 7277   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7278   ins_pipe(ialu_mem_imm);
 7279 %}
 7280 
 7281 // XXX why does that use AddI
 7282 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7283 %{
 7284   predicate(UseIncDec);
 7285   match(Set dst (AddI dst src));
 7286   effect(KILL cr);
 7287 
 7288   format %{ &quot;decl    $dst\t# int&quot; %}
 7289   opcode(0xFF, 0x01); // FF /1
 7290   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7291   ins_pipe(ialu_reg);
 7292 %}
 7293 
 7294 // XXX why does that use AddI
 7295 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7296 %{
 7297   predicate(UseIncDec);
 7298   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7299   effect(KILL cr);
 7300 
 7301   ins_cost(125); // XXX
 7302   format %{ &quot;decl    $dst\t# int&quot; %}
 7303   opcode(0xFF); /* Opcode FF /1 */
 7304   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7305   ins_pipe(ialu_mem_imm);
 7306 %}
 7307 
 7308 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7309 %{
 7310   match(Set dst (AddI src0 src1));
 7311 
 7312   ins_cost(110);
 7313   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7314   opcode(0x8D); /* 0x8D /r */
 7315   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7316   ins_pipe(ialu_reg_reg);
 7317 %}
 7318 
 7319 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7320 %{
 7321   match(Set dst (AddL dst src));
 7322   effect(KILL cr);
 7323 
 7324   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7325   opcode(0x03);
 7326   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7327   ins_pipe(ialu_reg_reg);
 7328 %}
 7329 
 7330 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7331 %{
 7332   match(Set dst (AddL dst src));
 7333   effect(KILL cr);
 7334 
 7335   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7336   opcode(0x81, 0x00); /* /0 id */
 7337   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7338   ins_pipe( ialu_reg );
 7339 %}
 7340 
 7341 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7342 %{
 7343   match(Set dst (AddL dst (LoadL src)));
 7344   effect(KILL cr);
 7345 
 7346   ins_cost(125); // XXX
 7347   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7348   opcode(0x03);
 7349   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7350   ins_pipe(ialu_reg_mem);
 7351 %}
 7352 
 7353 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7354 %{
 7355   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7356   effect(KILL cr);
 7357 
 7358   ins_cost(150); // XXX
 7359   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7360   opcode(0x01); /* Opcode 01 /r */
 7361   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7362   ins_pipe(ialu_mem_reg);
 7363 %}
 7364 
 7365 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7366 %{
 7367   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7368   effect(KILL cr);
 7369 
 7370   ins_cost(125); // XXX
 7371   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7372   opcode(0x81); /* Opcode 81 /0 id */
 7373   ins_encode(REX_mem_wide(dst),
 7374              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7375   ins_pipe(ialu_mem_imm);
 7376 %}
 7377 
 7378 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7379 %{
 7380   predicate(UseIncDec);
 7381   match(Set dst (AddL dst src));
 7382   effect(KILL cr);
 7383 
 7384   format %{ &quot;incq    $dst\t# long&quot; %}
 7385   opcode(0xFF, 0x00); // FF /0
 7386   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7387   ins_pipe(ialu_reg);
 7388 %}
 7389 
 7390 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7391 %{
 7392   predicate(UseIncDec);
 7393   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7394   effect(KILL cr);
 7395 
 7396   ins_cost(125); // XXX
 7397   format %{ &quot;incq    $dst\t# long&quot; %}
 7398   opcode(0xFF); /* Opcode FF /0 */
 7399   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7400   ins_pipe(ialu_mem_imm);
 7401 %}
 7402 
 7403 // XXX why does that use AddL
 7404 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7405 %{
 7406   predicate(UseIncDec);
 7407   match(Set dst (AddL dst src));
 7408   effect(KILL cr);
 7409 
 7410   format %{ &quot;decq    $dst\t# long&quot; %}
 7411   opcode(0xFF, 0x01); // FF /1
 7412   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7413   ins_pipe(ialu_reg);
 7414 %}
 7415 
 7416 // XXX why does that use AddL
 7417 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7418 %{
 7419   predicate(UseIncDec);
 7420   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7421   effect(KILL cr);
 7422 
 7423   ins_cost(125); // XXX
 7424   format %{ &quot;decq    $dst\t# long&quot; %}
 7425   opcode(0xFF); /* Opcode FF /1 */
 7426   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7427   ins_pipe(ialu_mem_imm);
 7428 %}
 7429 
 7430 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7431 %{
 7432   match(Set dst (AddL src0 src1));
 7433 
 7434   ins_cost(110);
 7435   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7436   opcode(0x8D); /* 0x8D /r */
 7437   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7438   ins_pipe(ialu_reg_reg);
 7439 %}
 7440 
 7441 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7442 %{
 7443   match(Set dst (AddP dst src));
 7444   effect(KILL cr);
 7445 
 7446   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7447   opcode(0x03);
 7448   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7449   ins_pipe(ialu_reg_reg);
 7450 %}
 7451 
 7452 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7453 %{
 7454   match(Set dst (AddP dst src));
 7455   effect(KILL cr);
 7456 
 7457   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7458   opcode(0x81, 0x00); /* /0 id */
 7459   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7460   ins_pipe( ialu_reg );
 7461 %}
 7462 
 7463 // XXX addP mem ops ????
 7464 
 7465 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7466 %{
 7467   match(Set dst (AddP src0 src1));
 7468 
 7469   ins_cost(110);
 7470   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7471   opcode(0x8D); /* 0x8D /r */
 7472   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7473   ins_pipe(ialu_reg_reg);
 7474 %}
 7475 
 7476 instruct checkCastPP(rRegP dst)
 7477 %{
 7478   match(Set dst (CheckCastPP dst));
 7479 
 7480   size(0);
 7481   format %{ &quot;# checkcastPP of $dst&quot; %}
 7482   ins_encode(/* empty encoding */);
 7483   ins_pipe(empty);
 7484 %}
 7485 
 7486 instruct castPP(rRegP dst)
 7487 %{
 7488   match(Set dst (CastPP dst));
 7489 
 7490   size(0);
 7491   format %{ &quot;# castPP of $dst&quot; %}
 7492   ins_encode(/* empty encoding */);
 7493   ins_pipe(empty);
 7494 %}
 7495 
 7496 instruct castII(rRegI dst)
 7497 %{
 7498   match(Set dst (CastII dst));
 7499 
 7500   size(0);
 7501   format %{ &quot;# castII of $dst&quot; %}
 7502   ins_encode(/* empty encoding */);
 7503   ins_cost(0);
 7504   ins_pipe(empty);
 7505 %}
 7506 
 7507 // LoadP-locked same as a regular LoadP when used with compare-swap
 7508 instruct loadPLocked(rRegP dst, memory mem)
 7509 %{
 7510   match(Set dst (LoadPLocked mem));
 7511 
 7512   ins_cost(125); // XXX
 7513   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7514   opcode(0x8B);
 7515   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7516   ins_pipe(ialu_reg_mem); // XXX
 7517 %}
 7518 
 7519 // Conditional-store of the updated heap-top.
 7520 // Used during allocation of the shared heap.
 7521 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7522 
 7523 instruct storePConditional(memory heap_top_ptr,
 7524                            rax_RegP oldval, rRegP newval,
 7525                            rFlagsReg cr)
 7526 %{
 7527   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7528   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7529 
 7530   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7531             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7532   opcode(0x0F, 0xB1);
 7533   ins_encode(lock_prefix,
 7534              REX_reg_mem_wide(newval, heap_top_ptr),
 7535              OpcP, OpcS,
 7536              reg_mem(newval, heap_top_ptr));
 7537   ins_pipe(pipe_cmpxchg);
 7538 %}
 7539 
 7540 // Conditional-store of an int value.
 7541 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7542 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7543 %{
 7544   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7545   effect(KILL oldval);
 7546 
 7547   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7548   opcode(0x0F, 0xB1);
 7549   ins_encode(lock_prefix,
 7550              REX_reg_mem(newval, mem),
 7551              OpcP, OpcS,
 7552              reg_mem(newval, mem));
 7553   ins_pipe(pipe_cmpxchg);
 7554 %}
 7555 
 7556 // Conditional-store of a long value.
 7557 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7558 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7559 %{
 7560   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7561   effect(KILL oldval);
 7562 
 7563   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7564   opcode(0x0F, 0xB1);
 7565   ins_encode(lock_prefix,
 7566              REX_reg_mem_wide(newval, mem),
 7567              OpcP, OpcS,
 7568              reg_mem(newval, mem));
 7569   ins_pipe(pipe_cmpxchg);
 7570 %}
 7571 
 7572 
 7573 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7574 instruct compareAndSwapP(rRegI res,
 7575                          memory mem_ptr,
 7576                          rax_RegP oldval, rRegP newval,
 7577                          rFlagsReg cr)
 7578 %{
 7579   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7580   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7581   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7582   effect(KILL cr, KILL oldval);
 7583 
 7584   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7585             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7586             &quot;sete    $res\n\t&quot;
 7587             &quot;movzbl  $res, $res&quot; %}
 7588   opcode(0x0F, 0xB1);
 7589   ins_encode(lock_prefix,
 7590              REX_reg_mem_wide(newval, mem_ptr),
 7591              OpcP, OpcS,
 7592              reg_mem(newval, mem_ptr),
 7593              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7594              REX_reg_breg(res, res), // movzbl
 7595              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7596   ins_pipe( pipe_cmpxchg );
 7597 %}
 7598 
 7599 instruct compareAndSwapL(rRegI res,
 7600                          memory mem_ptr,
 7601                          rax_RegL oldval, rRegL newval,
 7602                          rFlagsReg cr)
 7603 %{
 7604   predicate(VM_Version::supports_cx8());
 7605   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7606   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7607   effect(KILL cr, KILL oldval);
 7608 
 7609   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7610             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7611             &quot;sete    $res\n\t&quot;
 7612             &quot;movzbl  $res, $res&quot; %}
 7613   opcode(0x0F, 0xB1);
 7614   ins_encode(lock_prefix,
 7615              REX_reg_mem_wide(newval, mem_ptr),
 7616              OpcP, OpcS,
 7617              reg_mem(newval, mem_ptr),
 7618              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7619              REX_reg_breg(res, res), // movzbl
 7620              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7621   ins_pipe( pipe_cmpxchg );
 7622 %}
 7623 
 7624 instruct compareAndSwapI(rRegI res,
 7625                          memory mem_ptr,
 7626                          rax_RegI oldval, rRegI newval,
 7627                          rFlagsReg cr)
 7628 %{
 7629   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7630   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7631   effect(KILL cr, KILL oldval);
 7632 
 7633   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7634             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7635             &quot;sete    $res\n\t&quot;
 7636             &quot;movzbl  $res, $res&quot; %}
 7637   opcode(0x0F, 0xB1);
 7638   ins_encode(lock_prefix,
 7639              REX_reg_mem(newval, mem_ptr),
 7640              OpcP, OpcS,
 7641              reg_mem(newval, mem_ptr),
 7642              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7643              REX_reg_breg(res, res), // movzbl
 7644              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7645   ins_pipe( pipe_cmpxchg );
 7646 %}
 7647 
 7648 instruct compareAndSwapB(rRegI res,
 7649                          memory mem_ptr,
 7650                          rax_RegI oldval, rRegI newval,
 7651                          rFlagsReg cr)
 7652 %{
 7653   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7654   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7655   effect(KILL cr, KILL oldval);
 7656 
 7657   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7658             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7659             &quot;sete    $res\n\t&quot;
 7660             &quot;movzbl  $res, $res&quot; %}
 7661   opcode(0x0F, 0xB0);
 7662   ins_encode(lock_prefix,
 7663              REX_breg_mem(newval, mem_ptr),
 7664              OpcP, OpcS,
 7665              reg_mem(newval, mem_ptr),
 7666              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7667              REX_reg_breg(res, res), // movzbl
 7668              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7669   ins_pipe( pipe_cmpxchg );
 7670 %}
 7671 
 7672 instruct compareAndSwapS(rRegI res,
 7673                          memory mem_ptr,
 7674                          rax_RegI oldval, rRegI newval,
 7675                          rFlagsReg cr)
 7676 %{
 7677   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7678   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7679   effect(KILL cr, KILL oldval);
 7680 
 7681   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7682             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7683             &quot;sete    $res\n\t&quot;
 7684             &quot;movzbl  $res, $res&quot; %}
 7685   opcode(0x0F, 0xB1);
 7686   ins_encode(lock_prefix,
 7687              SizePrefix,
 7688              REX_reg_mem(newval, mem_ptr),
 7689              OpcP, OpcS,
 7690              reg_mem(newval, mem_ptr),
 7691              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7692              REX_reg_breg(res, res), // movzbl
 7693              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7694   ins_pipe( pipe_cmpxchg );
 7695 %}
 7696 
 7697 instruct compareAndSwapN(rRegI res,
 7698                           memory mem_ptr,
 7699                           rax_RegN oldval, rRegN newval,
 7700                           rFlagsReg cr) %{
 7701   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7702   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7703   effect(KILL cr, KILL oldval);
 7704 
 7705   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7706             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7707             &quot;sete    $res\n\t&quot;
 7708             &quot;movzbl  $res, $res&quot; %}
 7709   opcode(0x0F, 0xB1);
 7710   ins_encode(lock_prefix,
 7711              REX_reg_mem(newval, mem_ptr),
 7712              OpcP, OpcS,
 7713              reg_mem(newval, mem_ptr),
 7714              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7715              REX_reg_breg(res, res), // movzbl
 7716              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7717   ins_pipe( pipe_cmpxchg );
 7718 %}
 7719 
 7720 instruct compareAndExchangeB(
 7721                          memory mem_ptr,
 7722                          rax_RegI oldval, rRegI newval,
 7723                          rFlagsReg cr)
 7724 %{
 7725   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7726   effect(KILL cr);
 7727 
 7728   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7729             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7730   opcode(0x0F, 0xB0);
 7731   ins_encode(lock_prefix,
 7732              REX_breg_mem(newval, mem_ptr),
 7733              OpcP, OpcS,
 7734              reg_mem(newval, mem_ptr) // lock cmpxchg
 7735              );
 7736   ins_pipe( pipe_cmpxchg );
 7737 %}
 7738 
 7739 instruct compareAndExchangeS(
 7740                          memory mem_ptr,
 7741                          rax_RegI oldval, rRegI newval,
 7742                          rFlagsReg cr)
 7743 %{
 7744   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7745   effect(KILL cr);
 7746 
 7747   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7748             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7749   opcode(0x0F, 0xB1);
 7750   ins_encode(lock_prefix,
 7751              SizePrefix,
 7752              REX_reg_mem(newval, mem_ptr),
 7753              OpcP, OpcS,
 7754              reg_mem(newval, mem_ptr) // lock cmpxchg
 7755              );
 7756   ins_pipe( pipe_cmpxchg );
 7757 %}
 7758 
 7759 instruct compareAndExchangeI(
 7760                          memory mem_ptr,
 7761                          rax_RegI oldval, rRegI newval,
 7762                          rFlagsReg cr)
 7763 %{
 7764   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7765   effect(KILL cr);
 7766 
 7767   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7768             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7769   opcode(0x0F, 0xB1);
 7770   ins_encode(lock_prefix,
 7771              REX_reg_mem(newval, mem_ptr),
 7772              OpcP, OpcS,
 7773              reg_mem(newval, mem_ptr) // lock cmpxchg
 7774              );
 7775   ins_pipe( pipe_cmpxchg );
 7776 %}
 7777 
 7778 instruct compareAndExchangeL(
 7779                          memory mem_ptr,
 7780                          rax_RegL oldval, rRegL newval,
 7781                          rFlagsReg cr)
 7782 %{
 7783   predicate(VM_Version::supports_cx8());
 7784   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7785   effect(KILL cr);
 7786 
 7787   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7788             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7789   opcode(0x0F, 0xB1);
 7790   ins_encode(lock_prefix,
 7791              REX_reg_mem_wide(newval, mem_ptr),
 7792              OpcP, OpcS,
 7793              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7794             );
 7795   ins_pipe( pipe_cmpxchg );
 7796 %}
 7797 
 7798 instruct compareAndExchangeN(
 7799                           memory mem_ptr,
 7800                           rax_RegN oldval, rRegN newval,
 7801                           rFlagsReg cr) %{
 7802   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7803   effect(KILL cr);
 7804 
 7805   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7806             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7807   opcode(0x0F, 0xB1);
 7808   ins_encode(lock_prefix,
 7809              REX_reg_mem(newval, mem_ptr),
 7810              OpcP, OpcS,
 7811              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7812           );
 7813   ins_pipe( pipe_cmpxchg );
 7814 %}
 7815 
 7816 instruct compareAndExchangeP(
 7817                          memory mem_ptr,
 7818                          rax_RegP oldval, rRegP newval,
 7819                          rFlagsReg cr)
 7820 %{
 7821   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7822   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7823   effect(KILL cr);
 7824 
 7825   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7826             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7827   opcode(0x0F, 0xB1);
 7828   ins_encode(lock_prefix,
 7829              REX_reg_mem_wide(newval, mem_ptr),
 7830              OpcP, OpcS,
 7831              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7832           );
 7833   ins_pipe( pipe_cmpxchg );
 7834 %}
 7835 
 7836 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7837   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7838   match(Set dummy (GetAndAddB mem add));
 7839   effect(KILL cr);
 7840   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7841   ins_encode %{
 7842     __ lock();
 7843     __ addb($mem$$Address, $add$$constant);
 7844   %}
 7845   ins_pipe( pipe_cmpxchg );
 7846 %}
 7847 
 7848 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7849   match(Set newval (GetAndAddB mem newval));
 7850   effect(KILL cr);
 7851   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7852   ins_encode %{
 7853     __ lock();
 7854     __ xaddb($mem$$Address, $newval$$Register);
 7855   %}
 7856   ins_pipe( pipe_cmpxchg );
 7857 %}
 7858 
 7859 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7860   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7861   match(Set dummy (GetAndAddS mem add));
 7862   effect(KILL cr);
 7863   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7864   ins_encode %{
 7865     __ lock();
 7866     __ addw($mem$$Address, $add$$constant);
 7867   %}
 7868   ins_pipe( pipe_cmpxchg );
 7869 %}
 7870 
 7871 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7872   match(Set newval (GetAndAddS mem newval));
 7873   effect(KILL cr);
 7874   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7875   ins_encode %{
 7876     __ lock();
 7877     __ xaddw($mem$$Address, $newval$$Register);
 7878   %}
 7879   ins_pipe( pipe_cmpxchg );
 7880 %}
 7881 
 7882 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7883   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7884   match(Set dummy (GetAndAddI mem add));
 7885   effect(KILL cr);
 7886   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7887   ins_encode %{
 7888     __ lock();
 7889     __ addl($mem$$Address, $add$$constant);
 7890   %}
 7891   ins_pipe( pipe_cmpxchg );
 7892 %}
 7893 
 7894 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7895   match(Set newval (GetAndAddI mem newval));
 7896   effect(KILL cr);
 7897   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7898   ins_encode %{
 7899     __ lock();
 7900     __ xaddl($mem$$Address, $newval$$Register);
 7901   %}
 7902   ins_pipe( pipe_cmpxchg );
 7903 %}
 7904 
 7905 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7906   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7907   match(Set dummy (GetAndAddL mem add));
 7908   effect(KILL cr);
 7909   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7910   ins_encode %{
 7911     __ lock();
 7912     __ addq($mem$$Address, $add$$constant);
 7913   %}
 7914   ins_pipe( pipe_cmpxchg );
 7915 %}
 7916 
 7917 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7918   match(Set newval (GetAndAddL mem newval));
 7919   effect(KILL cr);
 7920   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7921   ins_encode %{
 7922     __ lock();
 7923     __ xaddq($mem$$Address, $newval$$Register);
 7924   %}
 7925   ins_pipe( pipe_cmpxchg );
 7926 %}
 7927 
 7928 instruct xchgB( memory mem, rRegI newval) %{
 7929   match(Set newval (GetAndSetB mem newval));
 7930   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7931   ins_encode %{
 7932     __ xchgb($newval$$Register, $mem$$Address);
 7933   %}
 7934   ins_pipe( pipe_cmpxchg );
 7935 %}
 7936 
 7937 instruct xchgS( memory mem, rRegI newval) %{
 7938   match(Set newval (GetAndSetS mem newval));
 7939   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7940   ins_encode %{
 7941     __ xchgw($newval$$Register, $mem$$Address);
 7942   %}
 7943   ins_pipe( pipe_cmpxchg );
 7944 %}
 7945 
 7946 instruct xchgI( memory mem, rRegI newval) %{
 7947   match(Set newval (GetAndSetI mem newval));
 7948   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7949   ins_encode %{
 7950     __ xchgl($newval$$Register, $mem$$Address);
 7951   %}
 7952   ins_pipe( pipe_cmpxchg );
 7953 %}
 7954 
 7955 instruct xchgL( memory mem, rRegL newval) %{
 7956   match(Set newval (GetAndSetL mem newval));
 7957   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7958   ins_encode %{
 7959     __ xchgq($newval$$Register, $mem$$Address);
 7960   %}
 7961   ins_pipe( pipe_cmpxchg );
 7962 %}
 7963 
 7964 instruct xchgP( memory mem, rRegP newval) %{
 7965   match(Set newval (GetAndSetP mem newval));
 7966   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7967   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 7968   ins_encode %{
 7969     __ xchgq($newval$$Register, $mem$$Address);
 7970   %}
 7971   ins_pipe( pipe_cmpxchg );
 7972 %}
 7973 
 7974 instruct xchgN( memory mem, rRegN newval) %{
 7975   match(Set newval (GetAndSetN mem newval));
 7976   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 7977   ins_encode %{
 7978     __ xchgl($newval$$Register, $mem$$Address);
 7979   %}
 7980   ins_pipe( pipe_cmpxchg );
 7981 %}
 7982 
 7983 //----------Abs Instructions-------------------------------------------
 7984 
 7985 // Integer Absolute Instructions
 7986 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 7987 %{
 7988   match(Set dst (AbsI src));
 7989   effect(TEMP dst, TEMP tmp, KILL cr);
 7990   format %{ &quot;movl $tmp, $src\n\t&quot;
 7991             &quot;sarl $tmp, 31\n\t&quot;
 7992             &quot;movl $dst, $src\n\t&quot;
 7993             &quot;xorl $dst, $tmp\n\t&quot;
 7994             &quot;subl $dst, $tmp\n&quot;
 7995           %}
 7996   ins_encode %{
 7997     __ movl($tmp$$Register, $src$$Register);
 7998     __ sarl($tmp$$Register, 31);
 7999     __ movl($dst$$Register, $src$$Register);
 8000     __ xorl($dst$$Register, $tmp$$Register);
 8001     __ subl($dst$$Register, $tmp$$Register);
 8002   %}
 8003 
 8004   ins_pipe(ialu_reg_reg);
 8005 %}
 8006 
 8007 // Long Absolute Instructions
 8008 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8009 %{
 8010   match(Set dst (AbsL src));
 8011   effect(TEMP dst, TEMP tmp, KILL cr);
 8012   format %{ &quot;movq $tmp, $src\n\t&quot;
 8013             &quot;sarq $tmp, 63\n\t&quot;
 8014             &quot;movq $dst, $src\n\t&quot;
 8015             &quot;xorq $dst, $tmp\n\t&quot;
 8016             &quot;subq $dst, $tmp\n&quot;
 8017           %}
 8018   ins_encode %{
 8019     __ movq($tmp$$Register, $src$$Register);
 8020     __ sarq($tmp$$Register, 63);
 8021     __ movq($dst$$Register, $src$$Register);
 8022     __ xorq($dst$$Register, $tmp$$Register);
 8023     __ subq($dst$$Register, $tmp$$Register);
 8024   %}
 8025 
 8026   ins_pipe(ialu_reg_reg);
 8027 %}
 8028 
 8029 //----------Subtraction Instructions-------------------------------------------
 8030 
 8031 // Integer Subtraction Instructions
 8032 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8033 %{
 8034   match(Set dst (SubI dst src));
 8035   effect(KILL cr);
 8036 
 8037   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8038   opcode(0x2B);
 8039   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8040   ins_pipe(ialu_reg_reg);
 8041 %}
 8042 
 8043 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8044 %{
 8045   match(Set dst (SubI dst src));
 8046   effect(KILL cr);
 8047 
 8048   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8049   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8050   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8051   ins_pipe(ialu_reg);
 8052 %}
 8053 
 8054 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8055 %{
 8056   match(Set dst (SubI dst (LoadI src)));
 8057   effect(KILL cr);
 8058 
 8059   ins_cost(125);
 8060   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8061   opcode(0x2B);
 8062   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8063   ins_pipe(ialu_reg_mem);
 8064 %}
 8065 
 8066 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8067 %{
 8068   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8069   effect(KILL cr);
 8070 
 8071   ins_cost(150);
 8072   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8073   opcode(0x29); /* Opcode 29 /r */
 8074   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8075   ins_pipe(ialu_mem_reg);
 8076 %}
 8077 
 8078 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8079 %{
 8080   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8081   effect(KILL cr);
 8082 
 8083   ins_cost(125); // XXX
 8084   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8085   opcode(0x81); /* Opcode 81 /5 id */
 8086   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8087   ins_pipe(ialu_mem_imm);
 8088 %}
 8089 
 8090 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8091 %{
 8092   match(Set dst (SubL dst src));
 8093   effect(KILL cr);
 8094 
 8095   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8096   opcode(0x2B);
 8097   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8098   ins_pipe(ialu_reg_reg);
 8099 %}
 8100 
 8101 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8102 %{
 8103   match(Set dst (SubL dst src));
 8104   effect(KILL cr);
 8105 
 8106   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8107   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8108   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8109   ins_pipe(ialu_reg);
 8110 %}
 8111 
 8112 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8113 %{
 8114   match(Set dst (SubL dst (LoadL src)));
 8115   effect(KILL cr);
 8116 
 8117   ins_cost(125);
 8118   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8119   opcode(0x2B);
 8120   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8121   ins_pipe(ialu_reg_mem);
 8122 %}
 8123 
 8124 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8125 %{
 8126   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8127   effect(KILL cr);
 8128 
 8129   ins_cost(150);
 8130   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8131   opcode(0x29); /* Opcode 29 /r */
 8132   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8133   ins_pipe(ialu_mem_reg);
 8134 %}
 8135 
 8136 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8137 %{
 8138   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8139   effect(KILL cr);
 8140 
 8141   ins_cost(125); // XXX
 8142   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8143   opcode(0x81); /* Opcode 81 /5 id */
 8144   ins_encode(REX_mem_wide(dst),
 8145              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8146   ins_pipe(ialu_mem_imm);
 8147 %}
 8148 
 8149 // Subtract from a pointer
 8150 // XXX hmpf???
 8151 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8152 %{
 8153   match(Set dst (AddP dst (SubI zero src)));
 8154   effect(KILL cr);
 8155 
 8156   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8157   opcode(0x2B);
 8158   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8159   ins_pipe(ialu_reg_reg);
 8160 %}
 8161 
 8162 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8163 %{
 8164   match(Set dst (SubI zero dst));
 8165   effect(KILL cr);
 8166 
 8167   format %{ &quot;negl    $dst\t# int&quot; %}
 8168   opcode(0xF7, 0x03);  // Opcode F7 /3
 8169   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8170   ins_pipe(ialu_reg);
 8171 %}
 8172 
 8173 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8174 %{
 8175   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8176   effect(KILL cr);
 8177 
 8178   format %{ &quot;negl    $dst\t# int&quot; %}
 8179   opcode(0xF7, 0x03);  // Opcode F7 /3
 8180   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8181   ins_pipe(ialu_reg);
 8182 %}
 8183 
 8184 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8185 %{
 8186   match(Set dst (SubL zero dst));
 8187   effect(KILL cr);
 8188 
 8189   format %{ &quot;negq    $dst\t# long&quot; %}
 8190   opcode(0xF7, 0x03);  // Opcode F7 /3
 8191   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8192   ins_pipe(ialu_reg);
 8193 %}
 8194 
 8195 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8196 %{
 8197   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8198   effect(KILL cr);
 8199 
 8200   format %{ &quot;negq    $dst\t# long&quot; %}
 8201   opcode(0xF7, 0x03);  // Opcode F7 /3
 8202   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8203   ins_pipe(ialu_reg);
 8204 %}
 8205 
 8206 //----------Multiplication/Division Instructions-------------------------------
 8207 // Integer Multiplication Instructions
 8208 // Multiply Register
 8209 
 8210 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8211 %{
 8212   match(Set dst (MulI dst src));
 8213   effect(KILL cr);
 8214 
 8215   ins_cost(300);
 8216   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8217   opcode(0x0F, 0xAF);
 8218   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8219   ins_pipe(ialu_reg_reg_alu0);
 8220 %}
 8221 
 8222 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8223 %{
 8224   match(Set dst (MulI src imm));
 8225   effect(KILL cr);
 8226 
 8227   ins_cost(300);
 8228   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8229   opcode(0x69); /* 69 /r id */
 8230   ins_encode(REX_reg_reg(dst, src),
 8231              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8232   ins_pipe(ialu_reg_reg_alu0);
 8233 %}
 8234 
 8235 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8236 %{
 8237   match(Set dst (MulI dst (LoadI src)));
 8238   effect(KILL cr);
 8239 
 8240   ins_cost(350);
 8241   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8242   opcode(0x0F, 0xAF);
 8243   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8244   ins_pipe(ialu_reg_mem_alu0);
 8245 %}
 8246 
 8247 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8248 %{
 8249   match(Set dst (MulI (LoadI src) imm));
 8250   effect(KILL cr);
 8251 
 8252   ins_cost(300);
 8253   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8254   opcode(0x69); /* 69 /r id */
 8255   ins_encode(REX_reg_mem(dst, src),
 8256              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8257   ins_pipe(ialu_reg_mem_alu0);
 8258 %}
 8259 
 8260 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8261 %{
 8262   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8263   effect(KILL cr, KILL src2);
 8264 
 8265   expand %{ mulI_rReg(dst, src1, cr);
 8266            mulI_rReg(src2, src3, cr);
 8267            addI_rReg(dst, src2, cr); %}
 8268 %}
 8269 
 8270 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8271 %{
 8272   match(Set dst (MulL dst src));
 8273   effect(KILL cr);
 8274 
 8275   ins_cost(300);
 8276   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8277   opcode(0x0F, 0xAF);
 8278   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8279   ins_pipe(ialu_reg_reg_alu0);
 8280 %}
 8281 
 8282 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8283 %{
 8284   match(Set dst (MulL src imm));
 8285   effect(KILL cr);
 8286 
 8287   ins_cost(300);
 8288   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8289   opcode(0x69); /* 69 /r id */
 8290   ins_encode(REX_reg_reg_wide(dst, src),
 8291              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8292   ins_pipe(ialu_reg_reg_alu0);
 8293 %}
 8294 
 8295 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8296 %{
 8297   match(Set dst (MulL dst (LoadL src)));
 8298   effect(KILL cr);
 8299 
 8300   ins_cost(350);
 8301   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8302   opcode(0x0F, 0xAF);
 8303   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8304   ins_pipe(ialu_reg_mem_alu0);
 8305 %}
 8306 
 8307 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8308 %{
 8309   match(Set dst (MulL (LoadL src) imm));
 8310   effect(KILL cr);
 8311 
 8312   ins_cost(300);
 8313   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8314   opcode(0x69); /* 69 /r id */
 8315   ins_encode(REX_reg_mem_wide(dst, src),
 8316              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8317   ins_pipe(ialu_reg_mem_alu0);
 8318 %}
 8319 
 8320 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8321 %{
 8322   match(Set dst (MulHiL src rax));
 8323   effect(USE_KILL rax, KILL cr);
 8324 
 8325   ins_cost(300);
 8326   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8327   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8328   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8329   ins_pipe(ialu_reg_reg_alu0);
 8330 %}
 8331 
 8332 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8333                    rFlagsReg cr)
 8334 %{
 8335   match(Set rax (DivI rax div));
 8336   effect(KILL rdx, KILL cr);
 8337 
 8338   ins_cost(30*100+10*100); // XXX
 8339   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8340             &quot;jne,s   normal\n\t&quot;
 8341             &quot;xorl    rdx, rdx\n\t&quot;
 8342             &quot;cmpl    $div, -1\n\t&quot;
 8343             &quot;je,s    done\n&quot;
 8344     &quot;normal: cdql\n\t&quot;
 8345             &quot;idivl   $div\n&quot;
 8346     &quot;done:&quot;        %}
 8347   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8348   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8349   ins_pipe(ialu_reg_reg_alu0);
 8350 %}
 8351 
 8352 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8353                    rFlagsReg cr)
 8354 %{
 8355   match(Set rax (DivL rax div));
 8356   effect(KILL rdx, KILL cr);
 8357 
 8358   ins_cost(30*100+10*100); // XXX
 8359   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8360             &quot;cmpq    rax, rdx\n\t&quot;
 8361             &quot;jne,s   normal\n\t&quot;
 8362             &quot;xorl    rdx, rdx\n\t&quot;
 8363             &quot;cmpq    $div, -1\n\t&quot;
 8364             &quot;je,s    done\n&quot;
 8365     &quot;normal: cdqq\n\t&quot;
 8366             &quot;idivq   $div\n&quot;
 8367     &quot;done:&quot;        %}
 8368   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8369   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8370   ins_pipe(ialu_reg_reg_alu0);
 8371 %}
 8372 
 8373 // Integer DIVMOD with Register, both quotient and mod results
 8374 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8375                              rFlagsReg cr)
 8376 %{
 8377   match(DivModI rax div);
 8378   effect(KILL cr);
 8379 
 8380   ins_cost(30*100+10*100); // XXX
 8381   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8382             &quot;jne,s   normal\n\t&quot;
 8383             &quot;xorl    rdx, rdx\n\t&quot;
 8384             &quot;cmpl    $div, -1\n\t&quot;
 8385             &quot;je,s    done\n&quot;
 8386     &quot;normal: cdql\n\t&quot;
 8387             &quot;idivl   $div\n&quot;
 8388     &quot;done:&quot;        %}
 8389   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8390   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8391   ins_pipe(pipe_slow);
 8392 %}
 8393 
 8394 // Long DIVMOD with Register, both quotient and mod results
 8395 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8396                              rFlagsReg cr)
 8397 %{
 8398   match(DivModL rax div);
 8399   effect(KILL cr);
 8400 
 8401   ins_cost(30*100+10*100); // XXX
 8402   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8403             &quot;cmpq    rax, rdx\n\t&quot;
 8404             &quot;jne,s   normal\n\t&quot;
 8405             &quot;xorl    rdx, rdx\n\t&quot;
 8406             &quot;cmpq    $div, -1\n\t&quot;
 8407             &quot;je,s    done\n&quot;
 8408     &quot;normal: cdqq\n\t&quot;
 8409             &quot;idivq   $div\n&quot;
 8410     &quot;done:&quot;        %}
 8411   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8412   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8413   ins_pipe(pipe_slow);
 8414 %}
 8415 
 8416 //----------- DivL-By-Constant-Expansions--------------------------------------
 8417 // DivI cases are handled by the compiler
 8418 
 8419 // Magic constant, reciprocal of 10
 8420 instruct loadConL_0x6666666666666667(rRegL dst)
 8421 %{
 8422   effect(DEF dst);
 8423 
 8424   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8425   ins_encode(load_immL(dst, 0x6666666666666667));
 8426   ins_pipe(ialu_reg);
 8427 %}
 8428 
 8429 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8430 %{
 8431   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8432 
 8433   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8434   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8435   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8436   ins_pipe(ialu_reg_reg_alu0);
 8437 %}
 8438 
 8439 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8440 %{
 8441   effect(USE_DEF dst, KILL cr);
 8442 
 8443   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8444   opcode(0xC1, 0x7); /* C1 /7 ib */
 8445   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8446   ins_pipe(ialu_reg);
 8447 %}
 8448 
 8449 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8450 %{
 8451   effect(USE_DEF dst, KILL cr);
 8452 
 8453   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8454   opcode(0xC1, 0x7); /* C1 /7 ib */
 8455   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8456   ins_pipe(ialu_reg);
 8457 %}
 8458 
 8459 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8460 %{
 8461   match(Set dst (DivL src div));
 8462 
 8463   ins_cost((5+8)*100);
 8464   expand %{
 8465     rax_RegL rax;                     // Killed temp
 8466     rFlagsReg cr;                     // Killed
 8467     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8468     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8469     sarL_rReg_63(src, cr);            // sarq  src, 63
 8470     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8471     subL_rReg(dst, src, cr);          // subl  rdx, src
 8472   %}
 8473 %}
 8474 
 8475 //-----------------------------------------------------------------------------
 8476 
 8477 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8478                    rFlagsReg cr)
 8479 %{
 8480   match(Set rdx (ModI rax div));
 8481   effect(KILL rax, KILL cr);
 8482 
 8483   ins_cost(300); // XXX
 8484   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8485             &quot;jne,s   normal\n\t&quot;
 8486             &quot;xorl    rdx, rdx\n\t&quot;
 8487             &quot;cmpl    $div, -1\n\t&quot;
 8488             &quot;je,s    done\n&quot;
 8489     &quot;normal: cdql\n\t&quot;
 8490             &quot;idivl   $div\n&quot;
 8491     &quot;done:&quot;        %}
 8492   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8493   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8494   ins_pipe(ialu_reg_reg_alu0);
 8495 %}
 8496 
 8497 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8498                    rFlagsReg cr)
 8499 %{
 8500   match(Set rdx (ModL rax div));
 8501   effect(KILL rax, KILL cr);
 8502 
 8503   ins_cost(300); // XXX
 8504   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8505             &quot;cmpq    rax, rdx\n\t&quot;
 8506             &quot;jne,s   normal\n\t&quot;
 8507             &quot;xorl    rdx, rdx\n\t&quot;
 8508             &quot;cmpq    $div, -1\n\t&quot;
 8509             &quot;je,s    done\n&quot;
 8510     &quot;normal: cdqq\n\t&quot;
 8511             &quot;idivq   $div\n&quot;
 8512     &quot;done:&quot;        %}
 8513   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8514   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8515   ins_pipe(ialu_reg_reg_alu0);
 8516 %}
 8517 
 8518 // Integer Shift Instructions
 8519 // Shift Left by one
 8520 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8521 %{
 8522   match(Set dst (LShiftI dst shift));
 8523   effect(KILL cr);
 8524 
 8525   format %{ &quot;sall    $dst, $shift&quot; %}
 8526   opcode(0xD1, 0x4); /* D1 /4 */
 8527   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8528   ins_pipe(ialu_reg);
 8529 %}
 8530 
 8531 // Shift Left by one
 8532 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8533 %{
 8534   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8535   effect(KILL cr);
 8536 
 8537   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8538   opcode(0xD1, 0x4); /* D1 /4 */
 8539   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8540   ins_pipe(ialu_mem_imm);
 8541 %}
 8542 
 8543 // Shift Left by 8-bit immediate
 8544 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8545 %{
 8546   match(Set dst (LShiftI dst shift));
 8547   effect(KILL cr);
 8548 
 8549   format %{ &quot;sall    $dst, $shift&quot; %}
 8550   opcode(0xC1, 0x4); /* C1 /4 ib */
 8551   ins_encode(reg_opc_imm(dst, shift));
 8552   ins_pipe(ialu_reg);
 8553 %}
 8554 
 8555 // Shift Left by 8-bit immediate
 8556 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8557 %{
 8558   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8559   effect(KILL cr);
 8560 
 8561   format %{ &quot;sall    $dst, $shift&quot; %}
 8562   opcode(0xC1, 0x4); /* C1 /4 ib */
 8563   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8564   ins_pipe(ialu_mem_imm);
 8565 %}
 8566 
 8567 // Shift Left by variable
 8568 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8569 %{
 8570   match(Set dst (LShiftI dst shift));
 8571   effect(KILL cr);
 8572 
 8573   format %{ &quot;sall    $dst, $shift&quot; %}
 8574   opcode(0xD3, 0x4); /* D3 /4 */
 8575   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8576   ins_pipe(ialu_reg_reg);
 8577 %}
 8578 
 8579 // Shift Left by variable
 8580 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8581 %{
 8582   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8583   effect(KILL cr);
 8584 
 8585   format %{ &quot;sall    $dst, $shift&quot; %}
 8586   opcode(0xD3, 0x4); /* D3 /4 */
 8587   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8588   ins_pipe(ialu_mem_reg);
 8589 %}
 8590 
 8591 // Arithmetic shift right by one
 8592 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8593 %{
 8594   match(Set dst (RShiftI dst shift));
 8595   effect(KILL cr);
 8596 
 8597   format %{ &quot;sarl    $dst, $shift&quot; %}
 8598   opcode(0xD1, 0x7); /* D1 /7 */
 8599   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8600   ins_pipe(ialu_reg);
 8601 %}
 8602 
 8603 // Arithmetic shift right by one
 8604 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8605 %{
 8606   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8607   effect(KILL cr);
 8608 
 8609   format %{ &quot;sarl    $dst, $shift&quot; %}
 8610   opcode(0xD1, 0x7); /* D1 /7 */
 8611   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8612   ins_pipe(ialu_mem_imm);
 8613 %}
 8614 
 8615 // Arithmetic Shift Right by 8-bit immediate
 8616 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8617 %{
 8618   match(Set dst (RShiftI dst shift));
 8619   effect(KILL cr);
 8620 
 8621   format %{ &quot;sarl    $dst, $shift&quot; %}
 8622   opcode(0xC1, 0x7); /* C1 /7 ib */
 8623   ins_encode(reg_opc_imm(dst, shift));
 8624   ins_pipe(ialu_mem_imm);
 8625 %}
 8626 
 8627 // Arithmetic Shift Right by 8-bit immediate
 8628 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8629 %{
 8630   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8631   effect(KILL cr);
 8632 
 8633   format %{ &quot;sarl    $dst, $shift&quot; %}
 8634   opcode(0xC1, 0x7); /* C1 /7 ib */
 8635   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8636   ins_pipe(ialu_mem_imm);
 8637 %}
 8638 
 8639 // Arithmetic Shift Right by variable
 8640 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8641 %{
 8642   match(Set dst (RShiftI dst shift));
 8643   effect(KILL cr);
 8644 
 8645   format %{ &quot;sarl    $dst, $shift&quot; %}
 8646   opcode(0xD3, 0x7); /* D3 /7 */
 8647   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8648   ins_pipe(ialu_reg_reg);
 8649 %}
 8650 
 8651 // Arithmetic Shift Right by variable
 8652 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8653 %{
 8654   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8655   effect(KILL cr);
 8656 
 8657   format %{ &quot;sarl    $dst, $shift&quot; %}
 8658   opcode(0xD3, 0x7); /* D3 /7 */
 8659   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8660   ins_pipe(ialu_mem_reg);
 8661 %}
 8662 
 8663 // Logical shift right by one
 8664 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8665 %{
 8666   match(Set dst (URShiftI dst shift));
 8667   effect(KILL cr);
 8668 
 8669   format %{ &quot;shrl    $dst, $shift&quot; %}
 8670   opcode(0xD1, 0x5); /* D1 /5 */
 8671   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8672   ins_pipe(ialu_reg);
 8673 %}
 8674 
 8675 // Logical shift right by one
 8676 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8677 %{
 8678   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8679   effect(KILL cr);
 8680 
 8681   format %{ &quot;shrl    $dst, $shift&quot; %}
 8682   opcode(0xD1, 0x5); /* D1 /5 */
 8683   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8684   ins_pipe(ialu_mem_imm);
 8685 %}
 8686 
 8687 // Logical Shift Right by 8-bit immediate
 8688 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8689 %{
 8690   match(Set dst (URShiftI dst shift));
 8691   effect(KILL cr);
 8692 
 8693   format %{ &quot;shrl    $dst, $shift&quot; %}
 8694   opcode(0xC1, 0x5); /* C1 /5 ib */
 8695   ins_encode(reg_opc_imm(dst, shift));
 8696   ins_pipe(ialu_reg);
 8697 %}
 8698 
 8699 // Logical Shift Right by 8-bit immediate
 8700 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8701 %{
 8702   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8703   effect(KILL cr);
 8704 
 8705   format %{ &quot;shrl    $dst, $shift&quot; %}
 8706   opcode(0xC1, 0x5); /* C1 /5 ib */
 8707   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8708   ins_pipe(ialu_mem_imm);
 8709 %}
 8710 
 8711 // Logical Shift Right by variable
 8712 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8713 %{
 8714   match(Set dst (URShiftI dst shift));
 8715   effect(KILL cr);
 8716 
 8717   format %{ &quot;shrl    $dst, $shift&quot; %}
 8718   opcode(0xD3, 0x5); /* D3 /5 */
 8719   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8720   ins_pipe(ialu_reg_reg);
 8721 %}
 8722 
 8723 // Logical Shift Right by variable
 8724 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8725 %{
 8726   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8727   effect(KILL cr);
 8728 
 8729   format %{ &quot;shrl    $dst, $shift&quot; %}
 8730   opcode(0xD3, 0x5); /* D3 /5 */
 8731   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8732   ins_pipe(ialu_mem_reg);
 8733 %}
 8734 
 8735 // Long Shift Instructions
 8736 // Shift Left by one
 8737 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8738 %{
 8739   match(Set dst (LShiftL dst shift));
 8740   effect(KILL cr);
 8741 
 8742   format %{ &quot;salq    $dst, $shift&quot; %}
 8743   opcode(0xD1, 0x4); /* D1 /4 */
 8744   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8745   ins_pipe(ialu_reg);
 8746 %}
 8747 
 8748 // Shift Left by one
 8749 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8750 %{
 8751   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8752   effect(KILL cr);
 8753 
 8754   format %{ &quot;salq    $dst, $shift&quot; %}
 8755   opcode(0xD1, 0x4); /* D1 /4 */
 8756   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8757   ins_pipe(ialu_mem_imm);
 8758 %}
 8759 
 8760 // Shift Left by 8-bit immediate
 8761 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8762 %{
 8763   match(Set dst (LShiftL dst shift));
 8764   effect(KILL cr);
 8765 
 8766   format %{ &quot;salq    $dst, $shift&quot; %}
 8767   opcode(0xC1, 0x4); /* C1 /4 ib */
 8768   ins_encode(reg_opc_imm_wide(dst, shift));
 8769   ins_pipe(ialu_reg);
 8770 %}
 8771 
 8772 // Shift Left by 8-bit immediate
 8773 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8774 %{
 8775   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8776   effect(KILL cr);
 8777 
 8778   format %{ &quot;salq    $dst, $shift&quot; %}
 8779   opcode(0xC1, 0x4); /* C1 /4 ib */
 8780   ins_encode(REX_mem_wide(dst), OpcP,
 8781              RM_opc_mem(secondary, dst), Con8or32(shift));
 8782   ins_pipe(ialu_mem_imm);
 8783 %}
 8784 
 8785 // Shift Left by variable
 8786 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8787 %{
 8788   match(Set dst (LShiftL dst shift));
 8789   effect(KILL cr);
 8790 
 8791   format %{ &quot;salq    $dst, $shift&quot; %}
 8792   opcode(0xD3, 0x4); /* D3 /4 */
 8793   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8794   ins_pipe(ialu_reg_reg);
 8795 %}
 8796 
 8797 // Shift Left by variable
 8798 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8799 %{
 8800   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8801   effect(KILL cr);
 8802 
 8803   format %{ &quot;salq    $dst, $shift&quot; %}
 8804   opcode(0xD3, 0x4); /* D3 /4 */
 8805   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8806   ins_pipe(ialu_mem_reg);
 8807 %}
 8808 
 8809 // Arithmetic shift right by one
 8810 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8811 %{
 8812   match(Set dst (RShiftL dst shift));
 8813   effect(KILL cr);
 8814 
 8815   format %{ &quot;sarq    $dst, $shift&quot; %}
 8816   opcode(0xD1, 0x7); /* D1 /7 */
 8817   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8818   ins_pipe(ialu_reg);
 8819 %}
 8820 
 8821 // Arithmetic shift right by one
 8822 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8823 %{
 8824   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8825   effect(KILL cr);
 8826 
 8827   format %{ &quot;sarq    $dst, $shift&quot; %}
 8828   opcode(0xD1, 0x7); /* D1 /7 */
 8829   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8830   ins_pipe(ialu_mem_imm);
 8831 %}
 8832 
 8833 // Arithmetic Shift Right by 8-bit immediate
 8834 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8835 %{
 8836   match(Set dst (RShiftL dst shift));
 8837   effect(KILL cr);
 8838 
 8839   format %{ &quot;sarq    $dst, $shift&quot; %}
 8840   opcode(0xC1, 0x7); /* C1 /7 ib */
 8841   ins_encode(reg_opc_imm_wide(dst, shift));
 8842   ins_pipe(ialu_mem_imm);
 8843 %}
 8844 
 8845 // Arithmetic Shift Right by 8-bit immediate
 8846 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8847 %{
 8848   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8849   effect(KILL cr);
 8850 
 8851   format %{ &quot;sarq    $dst, $shift&quot; %}
 8852   opcode(0xC1, 0x7); /* C1 /7 ib */
 8853   ins_encode(REX_mem_wide(dst), OpcP,
 8854              RM_opc_mem(secondary, dst), Con8or32(shift));
 8855   ins_pipe(ialu_mem_imm);
 8856 %}
 8857 
 8858 // Arithmetic Shift Right by variable
 8859 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8860 %{
 8861   match(Set dst (RShiftL dst shift));
 8862   effect(KILL cr);
 8863 
 8864   format %{ &quot;sarq    $dst, $shift&quot; %}
 8865   opcode(0xD3, 0x7); /* D3 /7 */
 8866   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8867   ins_pipe(ialu_reg_reg);
 8868 %}
 8869 
 8870 // Arithmetic Shift Right by variable
 8871 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8872 %{
 8873   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8874   effect(KILL cr);
 8875 
 8876   format %{ &quot;sarq    $dst, $shift&quot; %}
 8877   opcode(0xD3, 0x7); /* D3 /7 */
 8878   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8879   ins_pipe(ialu_mem_reg);
 8880 %}
 8881 
 8882 // Logical shift right by one
 8883 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8884 %{
 8885   match(Set dst (URShiftL dst shift));
 8886   effect(KILL cr);
 8887 
 8888   format %{ &quot;shrq    $dst, $shift&quot; %}
 8889   opcode(0xD1, 0x5); /* D1 /5 */
 8890   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8891   ins_pipe(ialu_reg);
 8892 %}
 8893 
 8894 // Logical shift right by one
 8895 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8896 %{
 8897   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8898   effect(KILL cr);
 8899 
 8900   format %{ &quot;shrq    $dst, $shift&quot; %}
 8901   opcode(0xD1, 0x5); /* D1 /5 */
 8902   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8903   ins_pipe(ialu_mem_imm);
 8904 %}
 8905 
 8906 // Logical Shift Right by 8-bit immediate
 8907 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8908 %{
 8909   match(Set dst (URShiftL dst shift));
 8910   effect(KILL cr);
 8911 
 8912   format %{ &quot;shrq    $dst, $shift&quot; %}
 8913   opcode(0xC1, 0x5); /* C1 /5 ib */
 8914   ins_encode(reg_opc_imm_wide(dst, shift));
 8915   ins_pipe(ialu_reg);
 8916 %}
 8917 
 8918 
 8919 // Logical Shift Right by 8-bit immediate
 8920 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8921 %{
 8922   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8923   effect(KILL cr);
 8924 
 8925   format %{ &quot;shrq    $dst, $shift&quot; %}
 8926   opcode(0xC1, 0x5); /* C1 /5 ib */
 8927   ins_encode(REX_mem_wide(dst), OpcP,
 8928              RM_opc_mem(secondary, dst), Con8or32(shift));
 8929   ins_pipe(ialu_mem_imm);
 8930 %}
 8931 
 8932 // Logical Shift Right by variable
 8933 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8934 %{
 8935   match(Set dst (URShiftL dst shift));
 8936   effect(KILL cr);
 8937 
 8938   format %{ &quot;shrq    $dst, $shift&quot; %}
 8939   opcode(0xD3, 0x5); /* D3 /5 */
 8940   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8941   ins_pipe(ialu_reg_reg);
 8942 %}
 8943 
 8944 // Logical Shift Right by variable
 8945 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8946 %{
 8947   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8948   effect(KILL cr);
 8949 
 8950   format %{ &quot;shrq    $dst, $shift&quot; %}
 8951   opcode(0xD3, 0x5); /* D3 /5 */
 8952   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8953   ins_pipe(ialu_mem_reg);
 8954 %}
 8955 
 8956 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8957 // This idiom is used by the compiler for the i2b bytecode.
 8958 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 8959 %{
 8960   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8961 
 8962   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 8963   opcode(0x0F, 0xBE);
 8964   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8965   ins_pipe(ialu_reg_reg);
 8966 %}
 8967 
 8968 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8969 // This idiom is used by the compiler the i2s bytecode.
 8970 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 8971 %{
 8972   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8973 
 8974   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 8975   opcode(0x0F, 0xBF);
 8976   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8977   ins_pipe(ialu_reg_reg);
 8978 %}
 8979 
 8980 // ROL/ROR instructions
 8981 
 8982 // ROL expand
 8983 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 8984   effect(KILL cr, USE_DEF dst);
 8985 
 8986   format %{ &quot;roll    $dst&quot; %}
 8987   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 8988   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8989   ins_pipe(ialu_reg);
 8990 %}
 8991 
 8992 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 8993   effect(USE_DEF dst, USE shift, KILL cr);
 8994 
 8995   format %{ &quot;roll    $dst, $shift&quot; %}
 8996   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 8997   ins_encode( reg_opc_imm(dst, shift) );
 8998   ins_pipe(ialu_reg);
 8999 %}
 9000 
 9001 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9002 %{
 9003   effect(USE_DEF dst, USE shift, KILL cr);
 9004 
 9005   format %{ &quot;roll    $dst, $shift&quot; %}
 9006   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9007   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9008   ins_pipe(ialu_reg_reg);
 9009 %}
 9010 // end of ROL expand
 9011 
 9012 // Rotate Left by one
 9013 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9014 %{
 9015   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9016 
 9017   expand %{
 9018     rolI_rReg_imm1(dst, cr);
 9019   %}
 9020 %}
 9021 
 9022 // Rotate Left by 8-bit immediate
 9023 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9024 %{
 9025   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9026   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9027 
 9028   expand %{
 9029     rolI_rReg_imm8(dst, lshift, cr);
 9030   %}
 9031 %}
 9032 
 9033 // Rotate Left by variable
 9034 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9035 %{
 9036   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9037 
 9038   expand %{
 9039     rolI_rReg_CL(dst, shift, cr);
 9040   %}
 9041 %}
 9042 
 9043 // Rotate Left by variable
 9044 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9045 %{
 9046   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9047 
 9048   expand %{
 9049     rolI_rReg_CL(dst, shift, cr);
 9050   %}
 9051 %}
 9052 
 9053 // ROR expand
 9054 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9055 %{
 9056   effect(USE_DEF dst, KILL cr);
 9057 
 9058   format %{ &quot;rorl    $dst&quot; %}
 9059   opcode(0xD1, 0x1); /* D1 /1 */
 9060   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9061   ins_pipe(ialu_reg);
 9062 %}
 9063 
 9064 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9065 %{
 9066   effect(USE_DEF dst, USE shift, KILL cr);
 9067 
 9068   format %{ &quot;rorl    $dst, $shift&quot; %}
 9069   opcode(0xC1, 0x1); /* C1 /1 ib */
 9070   ins_encode(reg_opc_imm(dst, shift));
 9071   ins_pipe(ialu_reg);
 9072 %}
 9073 
 9074 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9075 %{
 9076   effect(USE_DEF dst, USE shift, KILL cr);
 9077 
 9078   format %{ &quot;rorl    $dst, $shift&quot; %}
 9079   opcode(0xD3, 0x1); /* D3 /1 */
 9080   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9081   ins_pipe(ialu_reg_reg);
 9082 %}
 9083 // end of ROR expand
 9084 
 9085 // Rotate Right by one
 9086 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9087 %{
 9088   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9089 
 9090   expand %{
 9091     rorI_rReg_imm1(dst, cr);
 9092   %}
 9093 %}
 9094 
 9095 // Rotate Right by 8-bit immediate
 9096 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9097 %{
 9098   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9099   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9100 
 9101   expand %{
 9102     rorI_rReg_imm8(dst, rshift, cr);
 9103   %}
 9104 %}
 9105 
 9106 // Rotate Right by variable
 9107 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9108 %{
 9109   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9110 
 9111   expand %{
 9112     rorI_rReg_CL(dst, shift, cr);
 9113   %}
 9114 %}
 9115 
 9116 // Rotate Right by variable
 9117 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9118 %{
 9119   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9120 
 9121   expand %{
 9122     rorI_rReg_CL(dst, shift, cr);
 9123   %}
 9124 %}
 9125 
 9126 // for long rotate
 9127 // ROL expand
 9128 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9129   effect(USE_DEF dst, KILL cr);
 9130 
 9131   format %{ &quot;rolq    $dst&quot; %}
 9132   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9133   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9134   ins_pipe(ialu_reg);
 9135 %}
 9136 
 9137 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9138   effect(USE_DEF dst, USE shift, KILL cr);
 9139 
 9140   format %{ &quot;rolq    $dst, $shift&quot; %}
 9141   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9142   ins_encode( reg_opc_imm_wide(dst, shift) );
 9143   ins_pipe(ialu_reg);
 9144 %}
 9145 
 9146 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9147 %{
 9148   effect(USE_DEF dst, USE shift, KILL cr);
 9149 
 9150   format %{ &quot;rolq    $dst, $shift&quot; %}
 9151   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9152   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9153   ins_pipe(ialu_reg_reg);
 9154 %}
 9155 // end of ROL expand
 9156 
 9157 // Rotate Left by one
 9158 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9159 %{
 9160   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9161 
 9162   expand %{
 9163     rolL_rReg_imm1(dst, cr);
 9164   %}
 9165 %}
 9166 
 9167 // Rotate Left by 8-bit immediate
 9168 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9169 %{
 9170   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9171   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9172 
 9173   expand %{
 9174     rolL_rReg_imm8(dst, lshift, cr);
 9175   %}
 9176 %}
 9177 
 9178 // Rotate Left by variable
 9179 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9180 %{
 9181   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9182 
 9183   expand %{
 9184     rolL_rReg_CL(dst, shift, cr);
 9185   %}
 9186 %}
 9187 
 9188 // Rotate Left by variable
 9189 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9190 %{
 9191   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9192 
 9193   expand %{
 9194     rolL_rReg_CL(dst, shift, cr);
 9195   %}
 9196 %}
 9197 
 9198 // ROR expand
 9199 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9200 %{
 9201   effect(USE_DEF dst, KILL cr);
 9202 
 9203   format %{ &quot;rorq    $dst&quot; %}
 9204   opcode(0xD1, 0x1); /* D1 /1 */
 9205   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9206   ins_pipe(ialu_reg);
 9207 %}
 9208 
 9209 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9210 %{
 9211   effect(USE_DEF dst, USE shift, KILL cr);
 9212 
 9213   format %{ &quot;rorq    $dst, $shift&quot; %}
 9214   opcode(0xC1, 0x1); /* C1 /1 ib */
 9215   ins_encode(reg_opc_imm_wide(dst, shift));
 9216   ins_pipe(ialu_reg);
 9217 %}
 9218 
 9219 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9220 %{
 9221   effect(USE_DEF dst, USE shift, KILL cr);
 9222 
 9223   format %{ &quot;rorq    $dst, $shift&quot; %}
 9224   opcode(0xD3, 0x1); /* D3 /1 */
 9225   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9226   ins_pipe(ialu_reg_reg);
 9227 %}
 9228 // end of ROR expand
 9229 
 9230 // Rotate Right by one
 9231 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9232 %{
 9233   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9234 
 9235   expand %{
 9236     rorL_rReg_imm1(dst, cr);
 9237   %}
 9238 %}
 9239 
 9240 // Rotate Right by 8-bit immediate
 9241 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9242 %{
 9243   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9244   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9245 
 9246   expand %{
 9247     rorL_rReg_imm8(dst, rshift, cr);
 9248   %}
 9249 %}
 9250 
 9251 // Rotate Right by variable
 9252 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9253 %{
 9254   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9255 
 9256   expand %{
 9257     rorL_rReg_CL(dst, shift, cr);
 9258   %}
 9259 %}
 9260 
 9261 // Rotate Right by variable
 9262 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9263 %{
 9264   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9265 
 9266   expand %{
 9267     rorL_rReg_CL(dst, shift, cr);
 9268   %}
 9269 %}
 9270 
 9271 // Logical Instructions
 9272 
 9273 // Integer Logical Instructions
 9274 
 9275 // And Instructions
 9276 // And Register with Register
 9277 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9278 %{
 9279   match(Set dst (AndI dst src));
 9280   effect(KILL cr);
 9281 
 9282   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9283   opcode(0x23);
 9284   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9285   ins_pipe(ialu_reg_reg);
 9286 %}
 9287 
 9288 // And Register with Immediate 255
 9289 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9290 %{
 9291   match(Set dst (AndI dst src));
 9292 
 9293   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9294   opcode(0x0F, 0xB6);
 9295   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9296   ins_pipe(ialu_reg);
 9297 %}
 9298 
 9299 // And Register with Immediate 255 and promote to long
 9300 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9301 %{
 9302   match(Set dst (ConvI2L (AndI src mask)));
 9303 
 9304   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9305   opcode(0x0F, 0xB6);
 9306   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9307   ins_pipe(ialu_reg);
 9308 %}
 9309 
 9310 // And Register with Immediate 65535
 9311 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9312 %{
 9313   match(Set dst (AndI dst src));
 9314 
 9315   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9316   opcode(0x0F, 0xB7);
 9317   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9318   ins_pipe(ialu_reg);
 9319 %}
 9320 
 9321 // And Register with Immediate 65535 and promote to long
 9322 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9323 %{
 9324   match(Set dst (ConvI2L (AndI src mask)));
 9325 
 9326   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9327   opcode(0x0F, 0xB7);
 9328   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9329   ins_pipe(ialu_reg);
 9330 %}
 9331 
 9332 // And Register with Immediate
 9333 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9334 %{
 9335   match(Set dst (AndI dst src));
 9336   effect(KILL cr);
 9337 
 9338   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9339   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9340   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9341   ins_pipe(ialu_reg);
 9342 %}
 9343 
 9344 // And Register with Memory
 9345 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9346 %{
 9347   match(Set dst (AndI dst (LoadI src)));
 9348   effect(KILL cr);
 9349 
 9350   ins_cost(125);
 9351   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9352   opcode(0x23);
 9353   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9354   ins_pipe(ialu_reg_mem);
 9355 %}
 9356 
 9357 // And Memory with Register
 9358 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9359 %{
 9360   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9361   effect(KILL cr);
 9362 
 9363   ins_cost(150);
 9364   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9365   opcode(0x20);
 9366   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9367   ins_pipe(ialu_mem_reg);
 9368 %}
 9369 
 9370 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9371 %{
 9372   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9373   effect(KILL cr);
 9374 
 9375   ins_cost(150);
 9376   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9377   opcode(0x21); /* Opcode 21 /r */
 9378   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9379   ins_pipe(ialu_mem_reg);
 9380 %}
 9381 
 9382 // And Memory with Immediate
 9383 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9384 %{
 9385   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9386   effect(KILL cr);
 9387 
 9388   ins_cost(125);
 9389   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9390   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9391   ins_encode(REX_mem(dst), OpcSE(src),
 9392              RM_opc_mem(secondary, dst), Con8or32(src));
 9393   ins_pipe(ialu_mem_imm);
 9394 %}
 9395 
 9396 // BMI1 instructions
 9397 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9398   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9399   predicate(UseBMI1Instructions);
 9400   effect(KILL cr);
 9401 
 9402   ins_cost(125);
 9403   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9404 
 9405   ins_encode %{
 9406     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9407   %}
 9408   ins_pipe(ialu_reg_mem);
 9409 %}
 9410 
 9411 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9412   match(Set dst (AndI (XorI src1 minus_1) src2));
 9413   predicate(UseBMI1Instructions);
 9414   effect(KILL cr);
 9415 
 9416   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9417 
 9418   ins_encode %{
 9419     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9420   %}
 9421   ins_pipe(ialu_reg);
 9422 %}
 9423 
 9424 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9425   match(Set dst (AndI (SubI imm_zero src) src));
 9426   predicate(UseBMI1Instructions);
 9427   effect(KILL cr);
 9428 
 9429   format %{ &quot;blsil  $dst, $src&quot; %}
 9430 
 9431   ins_encode %{
 9432     __ blsil($dst$$Register, $src$$Register);
 9433   %}
 9434   ins_pipe(ialu_reg);
 9435 %}
 9436 
 9437 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9438   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9439   predicate(UseBMI1Instructions);
 9440   effect(KILL cr);
 9441 
 9442   ins_cost(125);
 9443   format %{ &quot;blsil  $dst, $src&quot; %}
 9444 
 9445   ins_encode %{
 9446     __ blsil($dst$$Register, $src$$Address);
 9447   %}
 9448   ins_pipe(ialu_reg_mem);
 9449 %}
 9450 
 9451 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9452 %{
 9453   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9454   predicate(UseBMI1Instructions);
 9455   effect(KILL cr);
 9456 
 9457   ins_cost(125);
 9458   format %{ &quot;blsmskl $dst, $src&quot; %}
 9459 
 9460   ins_encode %{
 9461     __ blsmskl($dst$$Register, $src$$Address);
 9462   %}
 9463   ins_pipe(ialu_reg_mem);
 9464 %}
 9465 
 9466 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9467 %{
 9468   match(Set dst (XorI (AddI src minus_1) src));
 9469   predicate(UseBMI1Instructions);
 9470   effect(KILL cr);
 9471 
 9472   format %{ &quot;blsmskl $dst, $src&quot; %}
 9473 
 9474   ins_encode %{
 9475     __ blsmskl($dst$$Register, $src$$Register);
 9476   %}
 9477 
 9478   ins_pipe(ialu_reg);
 9479 %}
 9480 
 9481 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9482 %{
 9483   match(Set dst (AndI (AddI src minus_1) src) );
 9484   predicate(UseBMI1Instructions);
 9485   effect(KILL cr);
 9486 
 9487   format %{ &quot;blsrl  $dst, $src&quot; %}
 9488 
 9489   ins_encode %{
 9490     __ blsrl($dst$$Register, $src$$Register);
 9491   %}
 9492 
 9493   ins_pipe(ialu_reg_mem);
 9494 %}
 9495 
 9496 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9497 %{
 9498   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9499   predicate(UseBMI1Instructions);
 9500   effect(KILL cr);
 9501 
 9502   ins_cost(125);
 9503   format %{ &quot;blsrl  $dst, $src&quot; %}
 9504 
 9505   ins_encode %{
 9506     __ blsrl($dst$$Register, $src$$Address);
 9507   %}
 9508 
 9509   ins_pipe(ialu_reg);
 9510 %}
 9511 
 9512 // Or Instructions
 9513 // Or Register with Register
 9514 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9515 %{
 9516   match(Set dst (OrI dst src));
 9517   effect(KILL cr);
 9518 
 9519   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9520   opcode(0x0B);
 9521   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9522   ins_pipe(ialu_reg_reg);
 9523 %}
 9524 
 9525 // Or Register with Immediate
 9526 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9527 %{
 9528   match(Set dst (OrI dst src));
 9529   effect(KILL cr);
 9530 
 9531   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9532   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9533   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9534   ins_pipe(ialu_reg);
 9535 %}
 9536 
 9537 // Or Register with Memory
 9538 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9539 %{
 9540   match(Set dst (OrI dst (LoadI src)));
 9541   effect(KILL cr);
 9542 
 9543   ins_cost(125);
 9544   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9545   opcode(0x0B);
 9546   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9547   ins_pipe(ialu_reg_mem);
 9548 %}
 9549 
 9550 // Or Memory with Register
 9551 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9552 %{
 9553   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9554   effect(KILL cr);
 9555 
 9556   ins_cost(150);
 9557   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9558   opcode(0x08);
 9559   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9560   ins_pipe(ialu_mem_reg);
 9561 %}
 9562 
 9563 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9564 %{
 9565   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9566   effect(KILL cr);
 9567 
 9568   ins_cost(150);
 9569   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9570   opcode(0x09); /* Opcode 09 /r */
 9571   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9572   ins_pipe(ialu_mem_reg);
 9573 %}
 9574 
 9575 // Or Memory with Immediate
 9576 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9577 %{
 9578   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9579   effect(KILL cr);
 9580 
 9581   ins_cost(125);
 9582   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9583   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9584   ins_encode(REX_mem(dst), OpcSE(src),
 9585              RM_opc_mem(secondary, dst), Con8or32(src));
 9586   ins_pipe(ialu_mem_imm);
 9587 %}
 9588 
 9589 // Xor Instructions
 9590 // Xor Register with Register
 9591 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9592 %{
 9593   match(Set dst (XorI dst src));
 9594   effect(KILL cr);
 9595 
 9596   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9597   opcode(0x33);
 9598   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9599   ins_pipe(ialu_reg_reg);
 9600 %}
 9601 
 9602 // Xor Register with Immediate -1
 9603 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9604   match(Set dst (XorI dst imm));
 9605 
 9606   format %{ &quot;not    $dst&quot; %}
 9607   ins_encode %{
 9608      __ notl($dst$$Register);
 9609   %}
 9610   ins_pipe(ialu_reg);
 9611 %}
 9612 
 9613 // Xor Register with Immediate
 9614 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9615 %{
 9616   match(Set dst (XorI dst src));
 9617   effect(KILL cr);
 9618 
 9619   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9620   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9621   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9622   ins_pipe(ialu_reg);
 9623 %}
 9624 
 9625 // Xor Register with Memory
 9626 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9627 %{
 9628   match(Set dst (XorI dst (LoadI src)));
 9629   effect(KILL cr);
 9630 
 9631   ins_cost(125);
 9632   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9633   opcode(0x33);
 9634   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9635   ins_pipe(ialu_reg_mem);
 9636 %}
 9637 
 9638 // Xor Memory with Register
 9639 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9640 %{
 9641   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9642   effect(KILL cr);
 9643 
 9644   ins_cost(150);
 9645   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9646   opcode(0x30);
 9647   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9648   ins_pipe(ialu_mem_reg);
 9649 %}
 9650 
 9651 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9652 %{
 9653   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9654   effect(KILL cr);
 9655 
 9656   ins_cost(150);
 9657   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9658   opcode(0x31); /* Opcode 31 /r */
 9659   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9660   ins_pipe(ialu_mem_reg);
 9661 %}
 9662 
 9663 // Xor Memory with Immediate
 9664 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9665 %{
 9666   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9667   effect(KILL cr);
 9668 
 9669   ins_cost(125);
 9670   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9671   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9672   ins_encode(REX_mem(dst), OpcSE(src),
 9673              RM_opc_mem(secondary, dst), Con8or32(src));
 9674   ins_pipe(ialu_mem_imm);
 9675 %}
 9676 
 9677 
 9678 // Long Logical Instructions
 9679 
 9680 // And Instructions
 9681 // And Register with Register
 9682 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9683 %{
 9684   match(Set dst (AndL dst src));
 9685   effect(KILL cr);
 9686 
 9687   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9688   opcode(0x23);
 9689   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9690   ins_pipe(ialu_reg_reg);
 9691 %}
 9692 
 9693 // And Register with Immediate 255
 9694 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9695 %{
 9696   match(Set dst (AndL dst src));
 9697 
 9698   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9699   opcode(0x0F, 0xB6);
 9700   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9701   ins_pipe(ialu_reg);
 9702 %}
 9703 
 9704 // And Register with Immediate 65535
 9705 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9706 %{
 9707   match(Set dst (AndL dst src));
 9708 
 9709   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9710   opcode(0x0F, 0xB7);
 9711   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9712   ins_pipe(ialu_reg);
 9713 %}
 9714 
 9715 // And Register with Immediate
 9716 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9717 %{
 9718   match(Set dst (AndL dst src));
 9719   effect(KILL cr);
 9720 
 9721   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9722   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9723   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9724   ins_pipe(ialu_reg);
 9725 %}
 9726 
 9727 // And Register with Memory
 9728 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9729 %{
 9730   match(Set dst (AndL dst (LoadL src)));
 9731   effect(KILL cr);
 9732 
 9733   ins_cost(125);
 9734   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9735   opcode(0x23);
 9736   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9737   ins_pipe(ialu_reg_mem);
 9738 %}
 9739 
 9740 // And Memory with Register
 9741 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9742 %{
 9743   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9744   effect(KILL cr);
 9745 
 9746   ins_cost(150);
 9747   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9748   opcode(0x21); /* Opcode 21 /r */
 9749   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9750   ins_pipe(ialu_mem_reg);
 9751 %}
 9752 
 9753 // And Memory with Immediate
 9754 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9755 %{
 9756   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9757   effect(KILL cr);
 9758 
 9759   ins_cost(125);
 9760   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9761   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9762   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9763              RM_opc_mem(secondary, dst), Con8or32(src));
 9764   ins_pipe(ialu_mem_imm);
 9765 %}
 9766 
 9767 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9768 %{
 9769   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9770   // because AND/OR works well enough for 8/32-bit values.
 9771   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9772 
 9773   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9774   effect(KILL cr);
 9775 
 9776   ins_cost(125);
 9777   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9778   ins_encode %{
 9779     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9780   %}
 9781   ins_pipe(ialu_mem_imm);
 9782 %}
 9783 
 9784 // BMI1 instructions
 9785 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9786   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9787   predicate(UseBMI1Instructions);
 9788   effect(KILL cr);
 9789 
 9790   ins_cost(125);
 9791   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9792 
 9793   ins_encode %{
 9794     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9795   %}
 9796   ins_pipe(ialu_reg_mem);
 9797 %}
 9798 
 9799 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9800   match(Set dst (AndL (XorL src1 minus_1) src2));
 9801   predicate(UseBMI1Instructions);
 9802   effect(KILL cr);
 9803 
 9804   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9805 
 9806   ins_encode %{
 9807   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9808   %}
 9809   ins_pipe(ialu_reg_mem);
 9810 %}
 9811 
 9812 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9813   match(Set dst (AndL (SubL imm_zero src) src));
 9814   predicate(UseBMI1Instructions);
 9815   effect(KILL cr);
 9816 
 9817   format %{ &quot;blsiq  $dst, $src&quot; %}
 9818 
 9819   ins_encode %{
 9820     __ blsiq($dst$$Register, $src$$Register);
 9821   %}
 9822   ins_pipe(ialu_reg);
 9823 %}
 9824 
 9825 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9826   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9827   predicate(UseBMI1Instructions);
 9828   effect(KILL cr);
 9829 
 9830   ins_cost(125);
 9831   format %{ &quot;blsiq  $dst, $src&quot; %}
 9832 
 9833   ins_encode %{
 9834     __ blsiq($dst$$Register, $src$$Address);
 9835   %}
 9836   ins_pipe(ialu_reg_mem);
 9837 %}
 9838 
 9839 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9840 %{
 9841   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9842   predicate(UseBMI1Instructions);
 9843   effect(KILL cr);
 9844 
 9845   ins_cost(125);
 9846   format %{ &quot;blsmskq $dst, $src&quot; %}
 9847 
 9848   ins_encode %{
 9849     __ blsmskq($dst$$Register, $src$$Address);
 9850   %}
 9851   ins_pipe(ialu_reg_mem);
 9852 %}
 9853 
 9854 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9855 %{
 9856   match(Set dst (XorL (AddL src minus_1) src));
 9857   predicate(UseBMI1Instructions);
 9858   effect(KILL cr);
 9859 
 9860   format %{ &quot;blsmskq $dst, $src&quot; %}
 9861 
 9862   ins_encode %{
 9863     __ blsmskq($dst$$Register, $src$$Register);
 9864   %}
 9865 
 9866   ins_pipe(ialu_reg);
 9867 %}
 9868 
 9869 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9870 %{
 9871   match(Set dst (AndL (AddL src minus_1) src) );
 9872   predicate(UseBMI1Instructions);
 9873   effect(KILL cr);
 9874 
 9875   format %{ &quot;blsrq  $dst, $src&quot; %}
 9876 
 9877   ins_encode %{
 9878     __ blsrq($dst$$Register, $src$$Register);
 9879   %}
 9880 
 9881   ins_pipe(ialu_reg);
 9882 %}
 9883 
 9884 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9885 %{
 9886   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9887   predicate(UseBMI1Instructions);
 9888   effect(KILL cr);
 9889 
 9890   ins_cost(125);
 9891   format %{ &quot;blsrq  $dst, $src&quot; %}
 9892 
 9893   ins_encode %{
 9894     __ blsrq($dst$$Register, $src$$Address);
 9895   %}
 9896 
 9897   ins_pipe(ialu_reg);
 9898 %}
 9899 
 9900 // Or Instructions
 9901 // Or Register with Register
 9902 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9903 %{
 9904   match(Set dst (OrL dst src));
 9905   effect(KILL cr);
 9906 
 9907   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9908   opcode(0x0B);
 9909   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9910   ins_pipe(ialu_reg_reg);
 9911 %}
 9912 
 9913 // Use any_RegP to match R15 (TLS register) without spilling.
 9914 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9915   match(Set dst (OrL dst (CastP2X src)));
 9916   effect(KILL cr);
 9917 
 9918   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9919   opcode(0x0B);
 9920   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9921   ins_pipe(ialu_reg_reg);
 9922 %}
 9923 
 9924 
 9925 // Or Register with Immediate
 9926 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9927 %{
 9928   match(Set dst (OrL dst src));
 9929   effect(KILL cr);
 9930 
 9931   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9932   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9933   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9934   ins_pipe(ialu_reg);
 9935 %}
 9936 
 9937 // Or Register with Memory
 9938 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9939 %{
 9940   match(Set dst (OrL dst (LoadL src)));
 9941   effect(KILL cr);
 9942 
 9943   ins_cost(125);
 9944   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9945   opcode(0x0B);
 9946   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9947   ins_pipe(ialu_reg_mem);
 9948 %}
 9949 
 9950 // Or Memory with Register
 9951 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9952 %{
 9953   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9954   effect(KILL cr);
 9955 
 9956   ins_cost(150);
 9957   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9958   opcode(0x09); /* Opcode 09 /r */
 9959   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9960   ins_pipe(ialu_mem_reg);
 9961 %}
 9962 
 9963 // Or Memory with Immediate
 9964 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9965 %{
 9966   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9967   effect(KILL cr);
 9968 
 9969   ins_cost(125);
 9970   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9971   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9972   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9973              RM_opc_mem(secondary, dst), Con8or32(src));
 9974   ins_pipe(ialu_mem_imm);
 9975 %}
 9976 
 9977 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9978 %{
 9979   // con should be a pure 64-bit power of 2 immediate
 9980   // because AND/OR works well enough for 8/32-bit values.
 9981   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9982 
 9983   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9984   effect(KILL cr);
 9985 
 9986   ins_cost(125);
 9987   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9988   ins_encode %{
 9989     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
 9990   %}
 9991   ins_pipe(ialu_mem_imm);
 9992 %}
 9993 
 9994 // Xor Instructions
 9995 // Xor Register with Register
 9996 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9997 %{
 9998   match(Set dst (XorL dst src));
 9999   effect(KILL cr);
10000 
10001   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10002   opcode(0x33);
10003   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10004   ins_pipe(ialu_reg_reg);
10005 %}
10006 
10007 // Xor Register with Immediate -1
10008 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10009   match(Set dst (XorL dst imm));
10010 
10011   format %{ &quot;notq   $dst&quot; %}
10012   ins_encode %{
10013      __ notq($dst$$Register);
10014   %}
10015   ins_pipe(ialu_reg);
10016 %}
10017 
10018 // Xor Register with Immediate
10019 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10020 %{
10021   match(Set dst (XorL dst src));
10022   effect(KILL cr);
10023 
10024   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10025   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10026   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10027   ins_pipe(ialu_reg);
10028 %}
10029 
10030 // Xor Register with Memory
10031 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10032 %{
10033   match(Set dst (XorL dst (LoadL src)));
10034   effect(KILL cr);
10035 
10036   ins_cost(125);
10037   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10038   opcode(0x33);
10039   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10040   ins_pipe(ialu_reg_mem);
10041 %}
10042 
10043 // Xor Memory with Register
10044 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10045 %{
10046   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10047   effect(KILL cr);
10048 
10049   ins_cost(150);
10050   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10051   opcode(0x31); /* Opcode 31 /r */
10052   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10053   ins_pipe(ialu_mem_reg);
10054 %}
10055 
10056 // Xor Memory with Immediate
10057 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10058 %{
10059   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10060   effect(KILL cr);
10061 
10062   ins_cost(125);
10063   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10064   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10065   ins_encode(REX_mem_wide(dst), OpcSE(src),
10066              RM_opc_mem(secondary, dst), Con8or32(src));
10067   ins_pipe(ialu_mem_imm);
10068 %}
10069 
10070 // Convert Int to Boolean
10071 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10072 %{
10073   match(Set dst (Conv2B src));
10074   effect(KILL cr);
10075 
10076   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10077             &quot;setnz   $dst\n\t&quot;
10078             &quot;movzbl  $dst, $dst&quot; %}
10079   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10080              setNZ_reg(dst),
10081              REX_reg_breg(dst, dst), // movzbl
10082              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10083   ins_pipe(pipe_slow); // XXX
10084 %}
10085 
10086 // Convert Pointer to Boolean
10087 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10088 %{
10089   match(Set dst (Conv2B src));
10090   effect(KILL cr);
10091 
10092   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10093             &quot;setnz   $dst\n\t&quot;
10094             &quot;movzbl  $dst, $dst&quot; %}
10095   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10096              setNZ_reg(dst),
10097              REX_reg_breg(dst, dst), // movzbl
10098              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10099   ins_pipe(pipe_slow); // XXX
10100 %}
10101 
10102 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10103 %{
10104   match(Set dst (CmpLTMask p q));
10105   effect(KILL cr);
10106 
10107   ins_cost(400);
10108   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10109             &quot;setlt   $dst\n\t&quot;
10110             &quot;movzbl  $dst, $dst\n\t&quot;
10111             &quot;negl    $dst&quot; %}
10112   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10113              setLT_reg(dst),
10114              REX_reg_breg(dst, dst), // movzbl
10115              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10116              neg_reg(dst));
10117   ins_pipe(pipe_slow);
10118 %}
10119 
10120 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10121 %{
10122   match(Set dst (CmpLTMask dst zero));
10123   effect(KILL cr);
10124 
10125   ins_cost(100);
10126   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10127   ins_encode %{
10128   __ sarl($dst$$Register, 31);
10129   %}
10130   ins_pipe(ialu_reg);
10131 %}
10132 
10133 /* Better to save a register than avoid a branch */
10134 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10135 %{
10136   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10137   effect(KILL cr);
10138   ins_cost(300);
10139   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10140             &quot;jge     done\n\t&quot;
10141             &quot;addl    $p,$y\n&quot;
10142             &quot;done:   &quot; %}
10143   ins_encode %{
10144     Register Rp = $p$$Register;
10145     Register Rq = $q$$Register;
10146     Register Ry = $y$$Register;
10147     Label done;
10148     __ subl(Rp, Rq);
10149     __ jccb(Assembler::greaterEqual, done);
10150     __ addl(Rp, Ry);
10151     __ bind(done);
10152   %}
10153   ins_pipe(pipe_cmplt);
10154 %}
10155 
10156 /* Better to save a register than avoid a branch */
10157 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10158 %{
10159   match(Set y (AndI (CmpLTMask p q) y));
10160   effect(KILL cr);
10161 
10162   ins_cost(300);
10163 
10164   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10165             &quot;jlt     done\n\t&quot;
10166             &quot;xorl    $y, $y\n&quot;
10167             &quot;done:   &quot; %}
10168   ins_encode %{
10169     Register Rp = $p$$Register;
10170     Register Rq = $q$$Register;
10171     Register Ry = $y$$Register;
10172     Label done;
10173     __ cmpl(Rp, Rq);
10174     __ jccb(Assembler::less, done);
10175     __ xorl(Ry, Ry);
10176     __ bind(done);
10177   %}
10178   ins_pipe(pipe_cmplt);
10179 %}
10180 
10181 
10182 //---------- FP Instructions------------------------------------------------
10183 
10184 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10185 %{
10186   match(Set cr (CmpF src1 src2));
10187 
10188   ins_cost(145);
10189   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10190             &quot;jnp,s   exit\n\t&quot;
10191             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10192             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10193             &quot;popfq\n&quot;
10194     &quot;exit:&quot; %}
10195   ins_encode %{
10196     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10197     emit_cmpfp_fixup(_masm);
10198   %}
10199   ins_pipe(pipe_slow);
10200 %}
10201 
10202 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10203   match(Set cr (CmpF src1 src2));
10204 
10205   ins_cost(100);
10206   format %{ &quot;ucomiss $src1, $src2&quot; %}
10207   ins_encode %{
10208     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10209   %}
10210   ins_pipe(pipe_slow);
10211 %}
10212 
10213 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10214 %{
10215   match(Set cr (CmpF src1 (LoadF src2)));
10216 
10217   ins_cost(145);
10218   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10219             &quot;jnp,s   exit\n\t&quot;
10220             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10221             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10222             &quot;popfq\n&quot;
10223     &quot;exit:&quot; %}
10224   ins_encode %{
10225     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10226     emit_cmpfp_fixup(_masm);
10227   %}
10228   ins_pipe(pipe_slow);
10229 %}
10230 
10231 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10232   match(Set cr (CmpF src1 (LoadF src2)));
10233 
10234   ins_cost(100);
10235   format %{ &quot;ucomiss $src1, $src2&quot; %}
10236   ins_encode %{
10237     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10238   %}
10239   ins_pipe(pipe_slow);
10240 %}
10241 
10242 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10243   match(Set cr (CmpF src con));
10244 
10245   ins_cost(145);
10246   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10247             &quot;jnp,s   exit\n\t&quot;
10248             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10249             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10250             &quot;popfq\n&quot;
10251     &quot;exit:&quot; %}
10252   ins_encode %{
10253     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10254     emit_cmpfp_fixup(_masm);
10255   %}
10256   ins_pipe(pipe_slow);
10257 %}
10258 
10259 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10260   match(Set cr (CmpF src con));
10261   ins_cost(100);
10262   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10263   ins_encode %{
10264     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10265   %}
10266   ins_pipe(pipe_slow);
10267 %}
10268 
10269 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10270 %{
10271   match(Set cr (CmpD src1 src2));
10272 
10273   ins_cost(145);
10274   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10275             &quot;jnp,s   exit\n\t&quot;
10276             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10277             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10278             &quot;popfq\n&quot;
10279     &quot;exit:&quot; %}
10280   ins_encode %{
10281     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10282     emit_cmpfp_fixup(_masm);
10283   %}
10284   ins_pipe(pipe_slow);
10285 %}
10286 
10287 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10288   match(Set cr (CmpD src1 src2));
10289 
10290   ins_cost(100);
10291   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10292   ins_encode %{
10293     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10294   %}
10295   ins_pipe(pipe_slow);
10296 %}
10297 
10298 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10299 %{
10300   match(Set cr (CmpD src1 (LoadD src2)));
10301 
10302   ins_cost(145);
10303   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10304             &quot;jnp,s   exit\n\t&quot;
10305             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10306             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10307             &quot;popfq\n&quot;
10308     &quot;exit:&quot; %}
10309   ins_encode %{
10310     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10311     emit_cmpfp_fixup(_masm);
10312   %}
10313   ins_pipe(pipe_slow);
10314 %}
10315 
10316 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10317   match(Set cr (CmpD src1 (LoadD src2)));
10318 
10319   ins_cost(100);
10320   format %{ &quot;ucomisd $src1, $src2&quot; %}
10321   ins_encode %{
10322     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10323   %}
10324   ins_pipe(pipe_slow);
10325 %}
10326 
10327 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10328   match(Set cr (CmpD src con));
10329 
10330   ins_cost(145);
10331   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10332             &quot;jnp,s   exit\n\t&quot;
10333             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10334             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10335             &quot;popfq\n&quot;
10336     &quot;exit:&quot; %}
10337   ins_encode %{
10338     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10339     emit_cmpfp_fixup(_masm);
10340   %}
10341   ins_pipe(pipe_slow);
10342 %}
10343 
10344 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10345   match(Set cr (CmpD src con));
10346   ins_cost(100);
10347   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10348   ins_encode %{
10349     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10350   %}
10351   ins_pipe(pipe_slow);
10352 %}
10353 
10354 // Compare into -1,0,1
10355 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10356 %{
10357   match(Set dst (CmpF3 src1 src2));
10358   effect(KILL cr);
10359 
10360   ins_cost(275);
10361   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10362             &quot;movl    $dst, #-1\n\t&quot;
10363             &quot;jp,s    done\n\t&quot;
10364             &quot;jb,s    done\n\t&quot;
10365             &quot;setne   $dst\n\t&quot;
10366             &quot;movzbl  $dst, $dst\n&quot;
10367     &quot;done:&quot; %}
10368   ins_encode %{
10369     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10370     emit_cmpfp3(_masm, $dst$$Register);
10371   %}
10372   ins_pipe(pipe_slow);
10373 %}
10374 
10375 // Compare into -1,0,1
10376 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10377 %{
10378   match(Set dst (CmpF3 src1 (LoadF src2)));
10379   effect(KILL cr);
10380 
10381   ins_cost(275);
10382   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10383             &quot;movl    $dst, #-1\n\t&quot;
10384             &quot;jp,s    done\n\t&quot;
10385             &quot;jb,s    done\n\t&quot;
10386             &quot;setne   $dst\n\t&quot;
10387             &quot;movzbl  $dst, $dst\n&quot;
10388     &quot;done:&quot; %}
10389   ins_encode %{
10390     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10391     emit_cmpfp3(_masm, $dst$$Register);
10392   %}
10393   ins_pipe(pipe_slow);
10394 %}
10395 
10396 // Compare into -1,0,1
10397 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10398   match(Set dst (CmpF3 src con));
10399   effect(KILL cr);
10400 
10401   ins_cost(275);
10402   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10403             &quot;movl    $dst, #-1\n\t&quot;
10404             &quot;jp,s    done\n\t&quot;
10405             &quot;jb,s    done\n\t&quot;
10406             &quot;setne   $dst\n\t&quot;
10407             &quot;movzbl  $dst, $dst\n&quot;
10408     &quot;done:&quot; %}
10409   ins_encode %{
10410     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10411     emit_cmpfp3(_masm, $dst$$Register);
10412   %}
10413   ins_pipe(pipe_slow);
10414 %}
10415 
10416 // Compare into -1,0,1
10417 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10418 %{
10419   match(Set dst (CmpD3 src1 src2));
10420   effect(KILL cr);
10421 
10422   ins_cost(275);
10423   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10424             &quot;movl    $dst, #-1\n\t&quot;
10425             &quot;jp,s    done\n\t&quot;
10426             &quot;jb,s    done\n\t&quot;
10427             &quot;setne   $dst\n\t&quot;
10428             &quot;movzbl  $dst, $dst\n&quot;
10429     &quot;done:&quot; %}
10430   ins_encode %{
10431     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10432     emit_cmpfp3(_masm, $dst$$Register);
10433   %}
10434   ins_pipe(pipe_slow);
10435 %}
10436 
10437 // Compare into -1,0,1
10438 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10439 %{
10440   match(Set dst (CmpD3 src1 (LoadD src2)));
10441   effect(KILL cr);
10442 
10443   ins_cost(275);
10444   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10445             &quot;movl    $dst, #-1\n\t&quot;
10446             &quot;jp,s    done\n\t&quot;
10447             &quot;jb,s    done\n\t&quot;
10448             &quot;setne   $dst\n\t&quot;
10449             &quot;movzbl  $dst, $dst\n&quot;
10450     &quot;done:&quot; %}
10451   ins_encode %{
10452     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10453     emit_cmpfp3(_masm, $dst$$Register);
10454   %}
10455   ins_pipe(pipe_slow);
10456 %}
10457 
10458 // Compare into -1,0,1
10459 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10460   match(Set dst (CmpD3 src con));
10461   effect(KILL cr);
10462 
10463   ins_cost(275);
10464   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10465             &quot;movl    $dst, #-1\n\t&quot;
10466             &quot;jp,s    done\n\t&quot;
10467             &quot;jb,s    done\n\t&quot;
10468             &quot;setne   $dst\n\t&quot;
10469             &quot;movzbl  $dst, $dst\n&quot;
10470     &quot;done:&quot; %}
10471   ins_encode %{
10472     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10473     emit_cmpfp3(_masm, $dst$$Register);
10474   %}
10475   ins_pipe(pipe_slow);
10476 %}
10477 
10478 //----------Arithmetic Conversion Instructions---------------------------------
10479 
10480 instruct convF2D_reg_reg(regD dst, regF src)
10481 %{
10482   match(Set dst (ConvF2D src));
10483 
10484   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10485   ins_encode %{
10486     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10487   %}
10488   ins_pipe(pipe_slow); // XXX
10489 %}
10490 
10491 instruct convF2D_reg_mem(regD dst, memory src)
10492 %{
10493   match(Set dst (ConvF2D (LoadF src)));
10494 
10495   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10496   ins_encode %{
10497     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10498   %}
10499   ins_pipe(pipe_slow); // XXX
10500 %}
10501 
10502 instruct convD2F_reg_reg(regF dst, regD src)
10503 %{
10504   match(Set dst (ConvD2F src));
10505 
10506   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10507   ins_encode %{
10508     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10509   %}
10510   ins_pipe(pipe_slow); // XXX
10511 %}
10512 
10513 instruct convD2F_reg_mem(regF dst, memory src)
10514 %{
10515   match(Set dst (ConvD2F (LoadD src)));
10516 
10517   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10518   ins_encode %{
10519     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10520   %}
10521   ins_pipe(pipe_slow); // XXX
10522 %}
10523 
10524 // XXX do mem variants
10525 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10526 %{
10527   match(Set dst (ConvF2I src));
10528   effect(KILL cr);
10529   format %{ &quot;convert_f2i $dst,$src&quot; %}
10530   ins_encode %{
10531     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10532   %}
10533   ins_pipe(pipe_slow);
10534 %}
10535 
10536 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10537 %{
10538   match(Set dst (ConvF2L src));
10539   effect(KILL cr);
10540   format %{ &quot;convert_f2l $dst,$src&quot;%}
10541   ins_encode %{
10542     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10543   %}
10544   ins_pipe(pipe_slow);
10545 %}
10546 
10547 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10548 %{
10549   match(Set dst (ConvD2I src));
10550   effect(KILL cr);
10551   format %{ &quot;convert_d2i $dst,$src&quot;%}
10552   ins_encode %{
10553     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10554   %}
10555   ins_pipe(pipe_slow);
10556 %}
10557 
10558 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10559 %{
10560   match(Set dst (ConvD2L src));
10561   effect(KILL cr);
10562   format %{ &quot;convert_d2l $dst,$src&quot;%}
10563   ins_encode %{
10564     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10565   %}
10566   ins_pipe(pipe_slow);
10567 %}
10568 
10569 instruct convI2F_reg_reg(regF dst, rRegI src)
10570 %{
10571   predicate(!UseXmmI2F);
10572   match(Set dst (ConvI2F src));
10573 
10574   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10575   ins_encode %{
10576     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10577   %}
10578   ins_pipe(pipe_slow); // XXX
10579 %}
10580 
10581 instruct convI2F_reg_mem(regF dst, memory src)
10582 %{
10583   match(Set dst (ConvI2F (LoadI src)));
10584 
10585   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10586   ins_encode %{
10587     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10588   %}
10589   ins_pipe(pipe_slow); // XXX
10590 %}
10591 
10592 instruct convI2D_reg_reg(regD dst, rRegI src)
10593 %{
10594   predicate(!UseXmmI2D);
10595   match(Set dst (ConvI2D src));
10596 
10597   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10598   ins_encode %{
10599     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10600   %}
10601   ins_pipe(pipe_slow); // XXX
10602 %}
10603 
10604 instruct convI2D_reg_mem(regD dst, memory src)
10605 %{
10606   match(Set dst (ConvI2D (LoadI src)));
10607 
10608   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10609   ins_encode %{
10610     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10611   %}
10612   ins_pipe(pipe_slow); // XXX
10613 %}
10614 
10615 instruct convXI2F_reg(regF dst, rRegI src)
10616 %{
10617   predicate(UseXmmI2F);
10618   match(Set dst (ConvI2F src));
10619 
10620   format %{ &quot;movdl $dst, $src\n\t&quot;
10621             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10622   ins_encode %{
10623     __ movdl($dst$$XMMRegister, $src$$Register);
10624     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10625   %}
10626   ins_pipe(pipe_slow); // XXX
10627 %}
10628 
10629 instruct convXI2D_reg(regD dst, rRegI src)
10630 %{
10631   predicate(UseXmmI2D);
10632   match(Set dst (ConvI2D src));
10633 
10634   format %{ &quot;movdl $dst, $src\n\t&quot;
10635             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10636   ins_encode %{
10637     __ movdl($dst$$XMMRegister, $src$$Register);
10638     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10639   %}
10640   ins_pipe(pipe_slow); // XXX
10641 %}
10642 
10643 instruct convL2F_reg_reg(regF dst, rRegL src)
10644 %{
10645   match(Set dst (ConvL2F src));
10646 
10647   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10648   ins_encode %{
10649     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10650   %}
10651   ins_pipe(pipe_slow); // XXX
10652 %}
10653 
10654 instruct convL2F_reg_mem(regF dst, memory src)
10655 %{
10656   match(Set dst (ConvL2F (LoadL src)));
10657 
10658   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10659   ins_encode %{
10660     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10661   %}
10662   ins_pipe(pipe_slow); // XXX
10663 %}
10664 
10665 instruct convL2D_reg_reg(regD dst, rRegL src)
10666 %{
10667   match(Set dst (ConvL2D src));
10668 
10669   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10670   ins_encode %{
10671     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10672   %}
10673   ins_pipe(pipe_slow); // XXX
10674 %}
10675 
10676 instruct convL2D_reg_mem(regD dst, memory src)
10677 %{
10678   match(Set dst (ConvL2D (LoadL src)));
10679 
10680   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10681   ins_encode %{
10682     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10683   %}
10684   ins_pipe(pipe_slow); // XXX
10685 %}
10686 
10687 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10688 %{
10689   match(Set dst (ConvI2L src));
10690 
10691   ins_cost(125);
10692   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10693   ins_encode %{
10694     __ movslq($dst$$Register, $src$$Register);
10695   %}
10696   ins_pipe(ialu_reg_reg);
10697 %}
10698 
10699 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10700 // %{
10701 //   match(Set dst (ConvI2L src));
10702 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10703 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10704 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10705 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10706 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10707 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10708 
10709 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10710 //   ins_encode(enc_copy(dst, src));
10711 // //   opcode(0x63); // needs REX.W
10712 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10713 //   ins_pipe(ialu_reg_reg);
10714 // %}
10715 
10716 // Zero-extend convert int to long
10717 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10718 %{
10719   match(Set dst (AndL (ConvI2L src) mask));
10720 
10721   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10722   ins_encode %{
10723     if ($dst$$reg != $src$$reg) {
10724       __ movl($dst$$Register, $src$$Register);
10725     }
10726   %}
10727   ins_pipe(ialu_reg_reg);
10728 %}
10729 
10730 // Zero-extend convert int to long
10731 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10732 %{
10733   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10734 
10735   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10736   ins_encode %{
10737     __ movl($dst$$Register, $src$$Address);
10738   %}
10739   ins_pipe(ialu_reg_mem);
10740 %}
10741 
10742 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10743 %{
10744   match(Set dst (AndL src mask));
10745 
10746   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10747   ins_encode %{
10748     __ movl($dst$$Register, $src$$Register);
10749   %}
10750   ins_pipe(ialu_reg_reg);
10751 %}
10752 
10753 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10754 %{
10755   match(Set dst (ConvL2I src));
10756 
10757   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10758   ins_encode %{
10759     __ movl($dst$$Register, $src$$Register);
10760   %}
10761   ins_pipe(ialu_reg_reg);
10762 %}
10763 
10764 
10765 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10766   match(Set dst (MoveF2I src));
10767   effect(DEF dst, USE src);
10768 
10769   ins_cost(125);
10770   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10771   ins_encode %{
10772     __ movl($dst$$Register, Address(rsp, $src$$disp));
10773   %}
10774   ins_pipe(ialu_reg_mem);
10775 %}
10776 
10777 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10778   match(Set dst (MoveI2F src));
10779   effect(DEF dst, USE src);
10780 
10781   ins_cost(125);
10782   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10783   ins_encode %{
10784     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10785   %}
10786   ins_pipe(pipe_slow);
10787 %}
10788 
10789 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10790   match(Set dst (MoveD2L src));
10791   effect(DEF dst, USE src);
10792 
10793   ins_cost(125);
10794   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10795   ins_encode %{
10796     __ movq($dst$$Register, Address(rsp, $src$$disp));
10797   %}
10798   ins_pipe(ialu_reg_mem);
10799 %}
10800 
10801 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10802   predicate(!UseXmmLoadAndClearUpper);
10803   match(Set dst (MoveL2D src));
10804   effect(DEF dst, USE src);
10805 
10806   ins_cost(125);
10807   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10808   ins_encode %{
10809     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10810   %}
10811   ins_pipe(pipe_slow);
10812 %}
10813 
10814 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10815   predicate(UseXmmLoadAndClearUpper);
10816   match(Set dst (MoveL2D src));
10817   effect(DEF dst, USE src);
10818 
10819   ins_cost(125);
10820   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10821   ins_encode %{
10822     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10823   %}
10824   ins_pipe(pipe_slow);
10825 %}
10826 
10827 
10828 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10829   match(Set dst (MoveF2I src));
10830   effect(DEF dst, USE src);
10831 
10832   ins_cost(95); // XXX
10833   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10834   ins_encode %{
10835     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10836   %}
10837   ins_pipe(pipe_slow);
10838 %}
10839 
10840 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10841   match(Set dst (MoveI2F src));
10842   effect(DEF dst, USE src);
10843 
10844   ins_cost(100);
10845   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10846   ins_encode %{
10847     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10848   %}
10849   ins_pipe( ialu_mem_reg );
10850 %}
10851 
10852 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10853   match(Set dst (MoveD2L src));
10854   effect(DEF dst, USE src);
10855 
10856   ins_cost(95); // XXX
10857   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10858   ins_encode %{
10859     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10860   %}
10861   ins_pipe(pipe_slow);
10862 %}
10863 
10864 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10865   match(Set dst (MoveL2D src));
10866   effect(DEF dst, USE src);
10867 
10868   ins_cost(100);
10869   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10870   ins_encode %{
10871     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10872   %}
10873   ins_pipe(ialu_mem_reg);
10874 %}
10875 
10876 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10877   match(Set dst (MoveF2I src));
10878   effect(DEF dst, USE src);
10879   ins_cost(85);
10880   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10881   ins_encode %{
10882     __ movdl($dst$$Register, $src$$XMMRegister);
10883   %}
10884   ins_pipe( pipe_slow );
10885 %}
10886 
10887 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10888   match(Set dst (MoveD2L src));
10889   effect(DEF dst, USE src);
10890   ins_cost(85);
10891   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10892   ins_encode %{
10893     __ movdq($dst$$Register, $src$$XMMRegister);
10894   %}
10895   ins_pipe( pipe_slow );
10896 %}
10897 
10898 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10899   match(Set dst (MoveI2F src));
10900   effect(DEF dst, USE src);
10901   ins_cost(100);
10902   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10903   ins_encode %{
10904     __ movdl($dst$$XMMRegister, $src$$Register);
10905   %}
10906   ins_pipe( pipe_slow );
10907 %}
10908 
10909 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10910   match(Set dst (MoveL2D src));
10911   effect(DEF dst, USE src);
10912   ins_cost(100);
10913   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10914   ins_encode %{
10915      __ movdq($dst$$XMMRegister, $src$$Register);
10916   %}
10917   ins_pipe( pipe_slow );
10918 %}
10919 
10920 
10921 // =======================================================================
10922 // fast clearing of an array
10923 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10924                   Universe dummy, rFlagsReg cr)
10925 %{
10926   predicate(!((ClearArrayNode*)n)-&gt;is_large());
10927   match(Set dummy (ClearArray cnt base));
10928   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10929 
10930   format %{ $$template
10931     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10932     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10933     $$emit$$&quot;jg      LARGE\n\t&quot;
10934     $$emit$$&quot;dec     rcx\n\t&quot;
10935     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10936     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10937     $$emit$$&quot;dec     rcx\n\t&quot;
10938     $$emit$$&quot;jge     LOOP\n\t&quot;
10939     $$emit$$&quot;jmp     DONE\n\t&quot;
10940     $$emit$$&quot;# LARGE:\n\t&quot;
10941     if (UseFastStosb) {
10942        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10943        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10944     } else if (UseXMMForObjInit) {
10945        $$emit$$&quot;mov     rdi,rax\n\t&quot;
10946        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10947        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10948        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10949        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10950        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
10951        $$emit$$&quot;add     0x40,rax\n\t&quot;
10952        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10953        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10954        $$emit$$&quot;jge     L_loop\n\t&quot;
10955        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10956        $$emit$$&quot;jl      L_tail\n\t&quot;
10957        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
10958        $$emit$$&quot;add     0x20,rax\n\t&quot;
10959        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10960        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10961        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10962        $$emit$$&quot;jle     L_end\n\t&quot;
10963        $$emit$$&quot;dec     rcx\n\t&quot;
10964        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10965        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10966        $$emit$$&quot;add     0x8,rax\n\t&quot;
10967        $$emit$$&quot;dec     rcx\n\t&quot;
10968        $$emit$$&quot;jge     L_sloop\n\t&quot;
10969        $$emit$$&quot;# L_end:\n\t&quot;
10970     } else {
10971        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10972     }
10973     $$emit$$&quot;# DONE&quot;
10974   %}
10975   ins_encode %{
10976     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
10977                  $tmp$$XMMRegister, false);
10978   %}
10979   ins_pipe(pipe_slow);
10980 %}
10981 
10982 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,
10983                         Universe dummy, rFlagsReg cr)
10984 %{
10985   predicate(((ClearArrayNode*)n)-&gt;is_large());
10986   match(Set dummy (ClearArray cnt base));
10987   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);
10988 
10989   format %{ $$template
10990     if (UseFastStosb) {
10991        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
10992        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10993        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10994     } else if (UseXMMForObjInit) {
10995        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;
10996        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;
10997        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10998        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
10999        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11000        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;
11001        $$emit$$&quot;add     0x40,rax\n\t&quot;
11002        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11003        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11004        $$emit$$&quot;jge     L_loop\n\t&quot;
11005        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11006        $$emit$$&quot;jl      L_tail\n\t&quot;
11007        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;
11008        $$emit$$&quot;add     0x20,rax\n\t&quot;
11009        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11010        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11011        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11012        $$emit$$&quot;jle     L_end\n\t&quot;
11013        $$emit$$&quot;dec     rcx\n\t&quot;
11014        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11015        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11016        $$emit$$&quot;add     0x8,rax\n\t&quot;
11017        $$emit$$&quot;dec     rcx\n\t&quot;
11018        $$emit$$&quot;jge     L_sloop\n\t&quot;
11019        $$emit$$&quot;# L_end:\n\t&quot;
11020     } else {
11021        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;
11022        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11023     }
11024   %}
11025   ins_encode %{
11026     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,
11027                  $tmp$$XMMRegister, true);
11028   %}
11029   ins_pipe(pipe_slow);
11030 %}
11031 
11032 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11033                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11034 %{
11035   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11036   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11037   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11038 
11039   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11040   ins_encode %{
11041     __ string_compare($str1$$Register, $str2$$Register,
11042                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11043                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11044   %}
11045   ins_pipe( pipe_slow );
11046 %}
11047 
11048 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11049                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11050 %{
11051   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11052   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11053   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11054 
11055   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11056   ins_encode %{
11057     __ string_compare($str1$$Register, $str2$$Register,
11058                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11059                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11060   %}
11061   ins_pipe( pipe_slow );
11062 %}
11063 
11064 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11065                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11066 %{
11067   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11068   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11069   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11070 
11071   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11072   ins_encode %{
11073     __ string_compare($str1$$Register, $str2$$Register,
11074                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11075                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11076   %}
11077   ins_pipe( pipe_slow );
11078 %}
11079 
11080 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11081                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11082 %{
11083   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11084   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11085   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11086 
11087   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11088   ins_encode %{
11089     __ string_compare($str2$$Register, $str1$$Register,
11090                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11091                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11092   %}
11093   ins_pipe( pipe_slow );
11094 %}
11095 
11096 // fast search of substring with known size.
11097 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11098                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11099 %{
11100   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11101   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11102   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11103 
11104   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11105   ins_encode %{
11106     int icnt2 = (int)$int_cnt2$$constant;
11107     if (icnt2 &gt;= 16) {
11108       // IndexOf for constant substrings with size &gt;= 16 elements
11109       // which don&#39;t need to be loaded through stack.
11110       __ string_indexofC8($str1$$Register, $str2$$Register,
11111                           $cnt1$$Register, $cnt2$$Register,
11112                           icnt2, $result$$Register,
11113                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11114     } else {
11115       // Small strings are loaded through stack if they cross page boundary.
11116       __ string_indexof($str1$$Register, $str2$$Register,
11117                         $cnt1$$Register, $cnt2$$Register,
11118                         icnt2, $result$$Register,
11119                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11120     }
11121   %}
11122   ins_pipe( pipe_slow );
11123 %}
11124 
11125 // fast search of substring with known size.
11126 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11127                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11128 %{
11129   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11130   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11131   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11132 
11133   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11134   ins_encode %{
11135     int icnt2 = (int)$int_cnt2$$constant;
11136     if (icnt2 &gt;= 8) {
11137       // IndexOf for constant substrings with size &gt;= 8 elements
11138       // which don&#39;t need to be loaded through stack.
11139       __ string_indexofC8($str1$$Register, $str2$$Register,
11140                           $cnt1$$Register, $cnt2$$Register,
11141                           icnt2, $result$$Register,
11142                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11143     } else {
11144       // Small strings are loaded through stack if they cross page boundary.
11145       __ string_indexof($str1$$Register, $str2$$Register,
11146                         $cnt1$$Register, $cnt2$$Register,
11147                         icnt2, $result$$Register,
11148                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11149     }
11150   %}
11151   ins_pipe( pipe_slow );
11152 %}
11153 
11154 // fast search of substring with known size.
11155 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11156                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11157 %{
11158   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11159   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11160   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11161 
11162   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11163   ins_encode %{
11164     int icnt2 = (int)$int_cnt2$$constant;
11165     if (icnt2 &gt;= 8) {
11166       // IndexOf for constant substrings with size &gt;= 8 elements
11167       // which don&#39;t need to be loaded through stack.
11168       __ string_indexofC8($str1$$Register, $str2$$Register,
11169                           $cnt1$$Register, $cnt2$$Register,
11170                           icnt2, $result$$Register,
11171                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11172     } else {
11173       // Small strings are loaded through stack if they cross page boundary.
11174       __ string_indexof($str1$$Register, $str2$$Register,
11175                         $cnt1$$Register, $cnt2$$Register,
11176                         icnt2, $result$$Register,
11177                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11178     }
11179   %}
11180   ins_pipe( pipe_slow );
11181 %}
11182 
11183 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11184                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11185 %{
11186   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11187   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11188   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11189 
11190   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11191   ins_encode %{
11192     __ string_indexof($str1$$Register, $str2$$Register,
11193                       $cnt1$$Register, $cnt2$$Register,
11194                       (-1), $result$$Register,
11195                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11196   %}
11197   ins_pipe( pipe_slow );
11198 %}
11199 
11200 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11201                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11202 %{
11203   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11204   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11205   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11206 
11207   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11208   ins_encode %{
11209     __ string_indexof($str1$$Register, $str2$$Register,
11210                       $cnt1$$Register, $cnt2$$Register,
11211                       (-1), $result$$Register,
11212                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11213   %}
11214   ins_pipe( pipe_slow );
11215 %}
11216 
11217 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11218                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11219 %{
11220   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11221   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11222   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11223 
11224   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11225   ins_encode %{
11226     __ string_indexof($str1$$Register, $str2$$Register,
11227                       $cnt1$$Register, $cnt2$$Register,
11228                       (-1), $result$$Register,
11229                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11230   %}
11231   ins_pipe( pipe_slow );
11232 %}
11233 
11234 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11235                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11236 %{
11237   predicate(UseSSE42Intrinsics);
11238   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11239   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11240   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11241   ins_encode %{
11242     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11243                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11244   %}
11245   ins_pipe( pipe_slow );
11246 %}
11247 
11248 // fast string equals
11249 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11250                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11251 %{
11252   match(Set result (StrEquals (Binary str1 str2) cnt));
11253   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11254 
11255   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11256   ins_encode %{
11257     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11258                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11259                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11260   %}
11261   ins_pipe( pipe_slow );
11262 %}
11263 
11264 // fast array equals
11265 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11266                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11267 %{
11268   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11269   match(Set result (AryEq ary1 ary2));
11270   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11271 
11272   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11273   ins_encode %{
11274     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11275                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11276                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11277   %}
11278   ins_pipe( pipe_slow );
11279 %}
11280 
11281 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11282                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11283 %{
11284   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11285   match(Set result (AryEq ary1 ary2));
11286   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11287 
11288   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11289   ins_encode %{
11290     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11291                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11292                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11293   %}
11294   ins_pipe( pipe_slow );
11295 %}
11296 
11297 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11298                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11299 %{
11300   match(Set result (HasNegatives ary1 len));
11301   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11302 
11303   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11304   ins_encode %{
11305     __ has_negatives($ary1$$Register, $len$$Register,
11306                      $result$$Register, $tmp3$$Register,
11307                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11308   %}
11309   ins_pipe( pipe_slow );
11310 %}
11311 
11312 // fast char[] to byte[] compression
11313 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11314                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11315   match(Set result (StrCompressedCopy src (Binary dst len)));
11316   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11317 
11318   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11319   ins_encode %{
11320     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11321                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11322                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11323   %}
11324   ins_pipe( pipe_slow );
11325 %}
11326 
11327 // fast byte[] to char[] inflation
11328 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11329                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11330   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11331   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11332 
11333   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11334   ins_encode %{
11335     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11336                           $tmp1$$XMMRegister, $tmp2$$Register);
11337   %}
11338   ins_pipe( pipe_slow );
11339 %}
11340 
11341 // encode char[] to byte[] in ISO_8859_1
11342 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11343                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11344                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11345   match(Set result (EncodeISOArray src (Binary dst len)));
11346   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11347 
11348   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11349   ins_encode %{
11350     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11351                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11352                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11353   %}
11354   ins_pipe( pipe_slow );
11355 %}
11356 
11357 //----------Overflow Math Instructions-----------------------------------------
11358 
11359 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11360 %{
11361   match(Set cr (OverflowAddI op1 op2));
11362   effect(DEF cr, USE_KILL op1, USE op2);
11363 
11364   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11365 
11366   ins_encode %{
11367     __ addl($op1$$Register, $op2$$Register);
11368   %}
11369   ins_pipe(ialu_reg_reg);
11370 %}
11371 
11372 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11373 %{
11374   match(Set cr (OverflowAddI op1 op2));
11375   effect(DEF cr, USE_KILL op1, USE op2);
11376 
11377   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11378 
11379   ins_encode %{
11380     __ addl($op1$$Register, $op2$$constant);
11381   %}
11382   ins_pipe(ialu_reg_reg);
11383 %}
11384 
11385 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11386 %{
11387   match(Set cr (OverflowAddL op1 op2));
11388   effect(DEF cr, USE_KILL op1, USE op2);
11389 
11390   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11391   ins_encode %{
11392     __ addq($op1$$Register, $op2$$Register);
11393   %}
11394   ins_pipe(ialu_reg_reg);
11395 %}
11396 
11397 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11398 %{
11399   match(Set cr (OverflowAddL op1 op2));
11400   effect(DEF cr, USE_KILL op1, USE op2);
11401 
11402   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11403   ins_encode %{
11404     __ addq($op1$$Register, $op2$$constant);
11405   %}
11406   ins_pipe(ialu_reg_reg);
11407 %}
11408 
11409 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11410 %{
11411   match(Set cr (OverflowSubI op1 op2));
11412 
11413   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11414   ins_encode %{
11415     __ cmpl($op1$$Register, $op2$$Register);
11416   %}
11417   ins_pipe(ialu_reg_reg);
11418 %}
11419 
11420 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11421 %{
11422   match(Set cr (OverflowSubI op1 op2));
11423 
11424   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11425   ins_encode %{
11426     __ cmpl($op1$$Register, $op2$$constant);
11427   %}
11428   ins_pipe(ialu_reg_reg);
11429 %}
11430 
11431 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11432 %{
11433   match(Set cr (OverflowSubL op1 op2));
11434 
11435   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11436   ins_encode %{
11437     __ cmpq($op1$$Register, $op2$$Register);
11438   %}
11439   ins_pipe(ialu_reg_reg);
11440 %}
11441 
11442 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11443 %{
11444   match(Set cr (OverflowSubL op1 op2));
11445 
11446   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11447   ins_encode %{
11448     __ cmpq($op1$$Register, $op2$$constant);
11449   %}
11450   ins_pipe(ialu_reg_reg);
11451 %}
11452 
11453 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11454 %{
11455   match(Set cr (OverflowSubI zero op2));
11456   effect(DEF cr, USE_KILL op2);
11457 
11458   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11459   ins_encode %{
11460     __ negl($op2$$Register);
11461   %}
11462   ins_pipe(ialu_reg_reg);
11463 %}
11464 
11465 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11466 %{
11467   match(Set cr (OverflowSubL zero op2));
11468   effect(DEF cr, USE_KILL op2);
11469 
11470   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11471   ins_encode %{
11472     __ negq($op2$$Register);
11473   %}
11474   ins_pipe(ialu_reg_reg);
11475 %}
11476 
11477 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11478 %{
11479   match(Set cr (OverflowMulI op1 op2));
11480   effect(DEF cr, USE_KILL op1, USE op2);
11481 
11482   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11483   ins_encode %{
11484     __ imull($op1$$Register, $op2$$Register);
11485   %}
11486   ins_pipe(ialu_reg_reg_alu0);
11487 %}
11488 
11489 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11490 %{
11491   match(Set cr (OverflowMulI op1 op2));
11492   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11493 
11494   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11495   ins_encode %{
11496     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11497   %}
11498   ins_pipe(ialu_reg_reg_alu0);
11499 %}
11500 
11501 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11502 %{
11503   match(Set cr (OverflowMulL op1 op2));
11504   effect(DEF cr, USE_KILL op1, USE op2);
11505 
11506   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11507   ins_encode %{
11508     __ imulq($op1$$Register, $op2$$Register);
11509   %}
11510   ins_pipe(ialu_reg_reg_alu0);
11511 %}
11512 
11513 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11514 %{
11515   match(Set cr (OverflowMulL op1 op2));
11516   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11517 
11518   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11519   ins_encode %{
11520     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11521   %}
11522   ins_pipe(ialu_reg_reg_alu0);
11523 %}
11524 
11525 
11526 //----------Control Flow Instructions------------------------------------------
11527 // Signed compare Instructions
11528 
11529 // XXX more variants!!
11530 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11531 %{
11532   match(Set cr (CmpI op1 op2));
11533   effect(DEF cr, USE op1, USE op2);
11534 
11535   format %{ &quot;cmpl    $op1, $op2&quot; %}
11536   opcode(0x3B);  /* Opcode 3B /r */
11537   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11538   ins_pipe(ialu_cr_reg_reg);
11539 %}
11540 
11541 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11542 %{
11543   match(Set cr (CmpI op1 op2));
11544 
11545   format %{ &quot;cmpl    $op1, $op2&quot; %}
11546   opcode(0x81, 0x07); /* Opcode 81 /7 */
11547   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11548   ins_pipe(ialu_cr_reg_imm);
11549 %}
11550 
11551 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11552 %{
11553   match(Set cr (CmpI op1 (LoadI op2)));
11554 
11555   ins_cost(500); // XXX
11556   format %{ &quot;cmpl    $op1, $op2&quot; %}
11557   opcode(0x3B); /* Opcode 3B /r */
11558   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11559   ins_pipe(ialu_cr_reg_mem);
11560 %}
11561 
11562 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11563 %{
11564   match(Set cr (CmpI src zero));
11565 
11566   format %{ &quot;testl   $src, $src&quot; %}
11567   opcode(0x85);
11568   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11569   ins_pipe(ialu_cr_reg_imm);
11570 %}
11571 
11572 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11573 %{
11574   match(Set cr (CmpI (AndI src con) zero));
11575 
11576   format %{ &quot;testl   $src, $con&quot; %}
11577   opcode(0xF7, 0x00);
11578   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11579   ins_pipe(ialu_cr_reg_imm);
11580 %}
11581 
11582 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11583 %{
11584   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11585 
11586   format %{ &quot;testl   $src, $mem&quot; %}
11587   opcode(0x85);
11588   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11589   ins_pipe(ialu_cr_reg_mem);
11590 %}
11591 
11592 // Unsigned compare Instructions; really, same as signed except they
11593 // produce an rFlagsRegU instead of rFlagsReg.
11594 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11595 %{
11596   match(Set cr (CmpU op1 op2));
11597 
11598   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11599   opcode(0x3B); /* Opcode 3B /r */
11600   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11601   ins_pipe(ialu_cr_reg_reg);
11602 %}
11603 
11604 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11605 %{
11606   match(Set cr (CmpU op1 op2));
11607 
11608   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11609   opcode(0x81,0x07); /* Opcode 81 /7 */
11610   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11611   ins_pipe(ialu_cr_reg_imm);
11612 %}
11613 
11614 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11615 %{
11616   match(Set cr (CmpU op1 (LoadI op2)));
11617 
11618   ins_cost(500); // XXX
11619   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11620   opcode(0x3B); /* Opcode 3B /r */
11621   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11622   ins_pipe(ialu_cr_reg_mem);
11623 %}
11624 
11625 // // // Cisc-spilled version of cmpU_rReg
11626 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11627 // //%{
11628 // //  match(Set cr (CmpU (LoadI op1) op2));
11629 // //
11630 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11631 // //  ins_cost(500);
11632 // //  opcode(0x39);  /* Opcode 39 /r */
11633 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11634 // //%}
11635 
11636 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11637 %{
11638   match(Set cr (CmpU src zero));
11639 
11640   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11641   opcode(0x85);
11642   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11643   ins_pipe(ialu_cr_reg_imm);
11644 %}
11645 
11646 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11647 %{
11648   match(Set cr (CmpP op1 op2));
11649 
11650   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11651   opcode(0x3B); /* Opcode 3B /r */
11652   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11653   ins_pipe(ialu_cr_reg_reg);
11654 %}
11655 
11656 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11657 %{
11658   match(Set cr (CmpP op1 (LoadP op2)));
11659   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11660 
11661   ins_cost(500); // XXX
11662   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11663   opcode(0x3B); /* Opcode 3B /r */
11664   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11665   ins_pipe(ialu_cr_reg_mem);
11666 %}
11667 
11668 // // // Cisc-spilled version of cmpP_rReg
11669 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11670 // //%{
11671 // //  match(Set cr (CmpP (LoadP op1) op2));
11672 // //
11673 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11674 // //  ins_cost(500);
11675 // //  opcode(0x39);  /* Opcode 39 /r */
11676 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11677 // //%}
11678 
11679 // XXX this is generalized by compP_rReg_mem???
11680 // Compare raw pointer (used in out-of-heap check).
11681 // Only works because non-oop pointers must be raw pointers
11682 // and raw pointers have no anti-dependencies.
11683 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11684 %{
11685   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11686             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11687   match(Set cr (CmpP op1 (LoadP op2)));
11688 
11689   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11690   opcode(0x3B); /* Opcode 3B /r */
11691   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11692   ins_pipe(ialu_cr_reg_mem);
11693 %}
11694 
11695 // This will generate a signed flags result. This should be OK since
11696 // any compare to a zero should be eq/neq.
11697 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11698 %{
11699   match(Set cr (CmpP src zero));
11700 
11701   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11702   opcode(0x85);
11703   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11704   ins_pipe(ialu_cr_reg_imm);
11705 %}
11706 
11707 // This will generate a signed flags result. This should be OK since
11708 // any compare to a zero should be eq/neq.
11709 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11710 %{
11711   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11712             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11713   match(Set cr (CmpP (LoadP op) zero));
11714 
11715   ins_cost(500); // XXX
11716   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11717   opcode(0xF7); /* Opcode F7 /0 */
11718   ins_encode(REX_mem_wide(op),
11719              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11720   ins_pipe(ialu_cr_reg_imm);
11721 %}
11722 
11723 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11724 %{
11725   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
<a name="17" id="anc17"></a><span class="line-removed">11726             (CompressedKlassPointers::base() == NULL) &amp;&amp;</span>
11727             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11728   match(Set cr (CmpP (LoadP mem) zero));
11729 
11730   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11731   ins_encode %{
11732     __ cmpq(r12, $mem$$Address);
11733   %}
11734   ins_pipe(ialu_cr_reg_mem);
11735 %}
11736 
11737 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11738 %{
11739   match(Set cr (CmpN op1 op2));
11740 
11741   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11742   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11743   ins_pipe(ialu_cr_reg_reg);
11744 %}
11745 
11746 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11747 %{
11748   match(Set cr (CmpN src (LoadN mem)));
11749 
11750   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11751   ins_encode %{
11752     __ cmpl($src$$Register, $mem$$Address);
11753   %}
11754   ins_pipe(ialu_cr_reg_mem);
11755 %}
11756 
11757 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11758   match(Set cr (CmpN op1 op2));
11759 
11760   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11761   ins_encode %{
11762     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11763   %}
11764   ins_pipe(ialu_cr_reg_imm);
11765 %}
11766 
11767 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11768 %{
11769   match(Set cr (CmpN src (LoadN mem)));
11770 
11771   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11772   ins_encode %{
11773     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11774   %}
11775   ins_pipe(ialu_cr_reg_mem);
11776 %}
11777 
11778 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11779   match(Set cr (CmpN op1 op2));
11780 
11781   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11782   ins_encode %{
11783     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11784   %}
11785   ins_pipe(ialu_cr_reg_imm);
11786 %}
11787 
11788 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11789 %{
11790   match(Set cr (CmpN src (LoadNKlass mem)));
11791 
11792   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11793   ins_encode %{
11794     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11795   %}
11796   ins_pipe(ialu_cr_reg_mem);
11797 %}
11798 
11799 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11800   match(Set cr (CmpN src zero));
11801 
11802   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11803   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11804   ins_pipe(ialu_cr_reg_imm);
11805 %}
11806 
11807 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11808 %{
11809   predicate(CompressedOops::base() != NULL);
11810   match(Set cr (CmpN (LoadN mem) zero));
11811 
11812   ins_cost(500); // XXX
11813   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11814   ins_encode %{
11815     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11816   %}
11817   ins_pipe(ialu_cr_reg_mem);
11818 %}
11819 
11820 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11821 %{
<a name="18" id="anc18"></a><span class="line-modified">11822   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));</span>
11823   match(Set cr (CmpN (LoadN mem) zero));
11824 
11825   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11826   ins_encode %{
11827     __ cmpl(r12, $mem$$Address);
11828   %}
11829   ins_pipe(ialu_cr_reg_mem);
11830 %}
11831 
11832 // Yanked all unsigned pointer compare operations.
11833 // Pointer compares are done with CmpP which is already unsigned.
11834 
11835 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11836 %{
11837   match(Set cr (CmpL op1 op2));
11838 
11839   format %{ &quot;cmpq    $op1, $op2&quot; %}
11840   opcode(0x3B);  /* Opcode 3B /r */
11841   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11842   ins_pipe(ialu_cr_reg_reg);
11843 %}
11844 
11845 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11846 %{
11847   match(Set cr (CmpL op1 op2));
11848 
11849   format %{ &quot;cmpq    $op1, $op2&quot; %}
11850   opcode(0x81, 0x07); /* Opcode 81 /7 */
11851   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11852   ins_pipe(ialu_cr_reg_imm);
11853 %}
11854 
11855 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11856 %{
11857   match(Set cr (CmpL op1 (LoadL op2)));
11858 
11859   format %{ &quot;cmpq    $op1, $op2&quot; %}
11860   opcode(0x3B); /* Opcode 3B /r */
11861   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11862   ins_pipe(ialu_cr_reg_mem);
11863 %}
11864 
11865 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11866 %{
11867   match(Set cr (CmpL src zero));
11868 
11869   format %{ &quot;testq   $src, $src&quot; %}
11870   opcode(0x85);
11871   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11872   ins_pipe(ialu_cr_reg_imm);
11873 %}
11874 
11875 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11876 %{
11877   match(Set cr (CmpL (AndL src con) zero));
11878 
11879   format %{ &quot;testq   $src, $con\t# long&quot; %}
11880   opcode(0xF7, 0x00);
11881   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11882   ins_pipe(ialu_cr_reg_imm);
11883 %}
11884 
11885 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11886 %{
11887   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11888 
11889   format %{ &quot;testq   $src, $mem&quot; %}
11890   opcode(0x85);
11891   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11892   ins_pipe(ialu_cr_reg_mem);
11893 %}
11894 
11895 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11896 %{
11897   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11898 
11899   format %{ &quot;testq   $src, $mem&quot; %}
11900   opcode(0x85);
11901   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11902   ins_pipe(ialu_cr_reg_mem);
11903 %}
11904 
11905 // Manifest a CmpL result in an integer register.  Very painful.
11906 // This is the test to avoid.
11907 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11908 %{
11909   match(Set dst (CmpL3 src1 src2));
11910   effect(KILL flags);
11911 
11912   ins_cost(275); // XXX
11913   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11914             &quot;movl    $dst, -1\n\t&quot;
11915             &quot;jl,s    done\n\t&quot;
11916             &quot;setne   $dst\n\t&quot;
11917             &quot;movzbl  $dst, $dst\n\t&quot;
11918     &quot;done:&quot; %}
11919   ins_encode(cmpl3_flag(src1, src2, dst));
11920   ins_pipe(pipe_slow);
11921 %}
11922 
11923 // Unsigned long compare Instructions; really, same as signed long except they
11924 // produce an rFlagsRegU instead of rFlagsReg.
11925 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11926 %{
11927   match(Set cr (CmpUL op1 op2));
11928 
11929   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11930   opcode(0x3B);  /* Opcode 3B /r */
11931   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11932   ins_pipe(ialu_cr_reg_reg);
11933 %}
11934 
11935 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11936 %{
11937   match(Set cr (CmpUL op1 op2));
11938 
11939   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11940   opcode(0x81, 0x07); /* Opcode 81 /7 */
11941   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11942   ins_pipe(ialu_cr_reg_imm);
11943 %}
11944 
11945 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11946 %{
11947   match(Set cr (CmpUL op1 (LoadL op2)));
11948 
11949   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11950   opcode(0x3B); /* Opcode 3B /r */
11951   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11952   ins_pipe(ialu_cr_reg_mem);
11953 %}
11954 
11955 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11956 %{
11957   match(Set cr (CmpUL src zero));
11958 
11959   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
11960   opcode(0x85);
11961   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11962   ins_pipe(ialu_cr_reg_imm);
11963 %}
11964 
11965 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
11966 %{
11967   match(Set cr (CmpI (LoadB mem) imm));
11968 
11969   ins_cost(125);
11970   format %{ &quot;cmpb    $mem, $imm&quot; %}
11971   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
11972   ins_pipe(ialu_cr_reg_mem);
11973 %}
11974 
11975 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
11976 %{
11977   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
11978 
11979   ins_cost(125);
11980   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
11981   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11982   ins_pipe(ialu_cr_reg_mem);
11983 %}
11984 
11985 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
11986 %{
11987   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
11988 
11989   ins_cost(125);
11990   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
11991   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11992   ins_pipe(ialu_cr_reg_mem);
11993 %}
11994 
11995 //----------Max and Min--------------------------------------------------------
11996 // Min Instructions
11997 
11998 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11999 %{
12000   effect(USE_DEF dst, USE src, USE cr);
12001 
12002   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12003   opcode(0x0F, 0x4F);
12004   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12005   ins_pipe(pipe_cmov_reg);
12006 %}
12007 
12008 
12009 instruct minI_rReg(rRegI dst, rRegI src)
12010 %{
12011   match(Set dst (MinI dst src));
12012 
12013   ins_cost(200);
12014   expand %{
12015     rFlagsReg cr;
12016     compI_rReg(cr, dst, src);
12017     cmovI_reg_g(dst, src, cr);
12018   %}
12019 %}
12020 
12021 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12022 %{
12023   effect(USE_DEF dst, USE src, USE cr);
12024 
12025   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12026   opcode(0x0F, 0x4C);
12027   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12028   ins_pipe(pipe_cmov_reg);
12029 %}
12030 
12031 
12032 instruct maxI_rReg(rRegI dst, rRegI src)
12033 %{
12034   match(Set dst (MaxI dst src));
12035 
12036   ins_cost(200);
12037   expand %{
12038     rFlagsReg cr;
12039     compI_rReg(cr, dst, src);
12040     cmovI_reg_l(dst, src, cr);
12041   %}
12042 %}
12043 
12044 // ============================================================================
12045 // Branch Instructions
12046 
12047 // Jump Direct - Label defines a relative address from JMP+1
12048 instruct jmpDir(label labl)
12049 %{
12050   match(Goto);
12051   effect(USE labl);
12052 
12053   ins_cost(300);
12054   format %{ &quot;jmp     $labl&quot; %}
12055   size(5);
12056   ins_encode %{
12057     Label* L = $labl$$label;
12058     __ jmp(*L, false); // Always long jump
12059   %}
12060   ins_pipe(pipe_jmp);
12061 %}
12062 
12063 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12064 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12065 %{
12066   match(If cop cr);
12067   effect(USE labl);
12068 
12069   ins_cost(300);
12070   format %{ &quot;j$cop     $labl&quot; %}
12071   size(6);
12072   ins_encode %{
12073     Label* L = $labl$$label;
12074     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12075   %}
12076   ins_pipe(pipe_jcc);
12077 %}
12078 
12079 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12080 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12081 %{
12082   predicate(!n-&gt;has_vector_mask_set());
12083   match(CountedLoopEnd cop cr);
12084   effect(USE labl);
12085 
12086   ins_cost(300);
12087   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12088   size(6);
12089   ins_encode %{
12090     Label* L = $labl$$label;
12091     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12092   %}
12093   ins_pipe(pipe_jcc);
12094 %}
12095 
12096 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12097 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12098   predicate(!n-&gt;has_vector_mask_set());
12099   match(CountedLoopEnd cop cmp);
12100   effect(USE labl);
12101 
12102   ins_cost(300);
12103   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12104   size(6);
12105   ins_encode %{
12106     Label* L = $labl$$label;
12107     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12108   %}
12109   ins_pipe(pipe_jcc);
12110 %}
12111 
12112 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12113   predicate(!n-&gt;has_vector_mask_set());
12114   match(CountedLoopEnd cop cmp);
12115   effect(USE labl);
12116 
12117   ins_cost(200);
12118   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12119   size(6);
12120   ins_encode %{
12121     Label* L = $labl$$label;
12122     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12123   %}
12124   ins_pipe(pipe_jcc);
12125 %}
12126 
12127 // mask version
12128 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12129 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12130 %{
12131   predicate(n-&gt;has_vector_mask_set());
12132   match(CountedLoopEnd cop cr);
12133   effect(USE labl);
12134 
12135   ins_cost(400);
12136   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12137             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12138   size(10);
12139   ins_encode %{
12140     Label* L = $labl$$label;
12141     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12142     __ restorevectmask();
12143   %}
12144   ins_pipe(pipe_jcc);
12145 %}
12146 
12147 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12148 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12149   predicate(n-&gt;has_vector_mask_set());
12150   match(CountedLoopEnd cop cmp);
12151   effect(USE labl);
12152 
12153   ins_cost(400);
12154   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12155             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12156   size(10);
12157   ins_encode %{
12158     Label* L = $labl$$label;
12159     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12160     __ restorevectmask();
12161   %}
12162   ins_pipe(pipe_jcc);
12163 %}
12164 
12165 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12166   predicate(n-&gt;has_vector_mask_set());
12167   match(CountedLoopEnd cop cmp);
12168   effect(USE labl);
12169 
12170   ins_cost(300);
12171   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12172             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12173   size(10);
12174   ins_encode %{
12175     Label* L = $labl$$label;
12176     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12177     __ restorevectmask();
12178   %}
12179   ins_pipe(pipe_jcc);
12180 %}
12181 
12182 // Jump Direct Conditional - using unsigned comparison
12183 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12184   match(If cop cmp);
12185   effect(USE labl);
12186 
12187   ins_cost(300);
12188   format %{ &quot;j$cop,u   $labl&quot; %}
12189   size(6);
12190   ins_encode %{
12191     Label* L = $labl$$label;
12192     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12193   %}
12194   ins_pipe(pipe_jcc);
12195 %}
12196 
12197 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12198   match(If cop cmp);
12199   effect(USE labl);
12200 
12201   ins_cost(200);
12202   format %{ &quot;j$cop,u   $labl&quot; %}
12203   size(6);
12204   ins_encode %{
12205     Label* L = $labl$$label;
12206     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12207   %}
12208   ins_pipe(pipe_jcc);
12209 %}
12210 
12211 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12212   match(If cop cmp);
12213   effect(USE labl);
12214 
12215   ins_cost(200);
12216   format %{ $$template
12217     if ($cop$$cmpcode == Assembler::notEqual) {
12218       $$emit$$&quot;jp,u    $labl\n\t&quot;
12219       $$emit$$&quot;j$cop,u   $labl&quot;
12220     } else {
12221       $$emit$$&quot;jp,u    done\n\t&quot;
12222       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12223       $$emit$$&quot;done:&quot;
12224     }
12225   %}
12226   ins_encode %{
12227     Label* l = $labl$$label;
12228     if ($cop$$cmpcode == Assembler::notEqual) {
12229       __ jcc(Assembler::parity, *l, false);
12230       __ jcc(Assembler::notEqual, *l, false);
12231     } else if ($cop$$cmpcode == Assembler::equal) {
12232       Label done;
12233       __ jccb(Assembler::parity, done);
12234       __ jcc(Assembler::equal, *l, false);
12235       __ bind(done);
12236     } else {
12237        ShouldNotReachHere();
12238     }
12239   %}
12240   ins_pipe(pipe_jcc);
12241 %}
12242 
12243 // ============================================================================
12244 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12245 // superklass array for an instance of the superklass.  Set a hidden
12246 // internal cache on a hit (cache is checked with exposed code in
12247 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12248 // encoding ALSO sets flags.
12249 
12250 instruct partialSubtypeCheck(rdi_RegP result,
12251                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12252                              rFlagsReg cr)
12253 %{
12254   match(Set result (PartialSubtypeCheck sub super));
12255   effect(KILL rcx, KILL cr);
12256 
12257   ins_cost(1100);  // slightly larger than the next version
12258   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12259             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12260             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12261             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12262             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12263             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12264             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12265     &quot;miss:\t&quot; %}
12266 
12267   opcode(0x1); // Force a XOR of RDI
12268   ins_encode(enc_PartialSubtypeCheck());
12269   ins_pipe(pipe_slow);
12270 %}
12271 
12272 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12273                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12274                                      immP0 zero,
12275                                      rdi_RegP result)
12276 %{
12277   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12278   effect(KILL rcx, KILL result);
12279 
12280   ins_cost(1000);
12281   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12282             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12283             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12284             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12285             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12286             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12287     &quot;miss:\t&quot; %}
12288 
12289   opcode(0x0); // No need to XOR RDI
12290   ins_encode(enc_PartialSubtypeCheck());
12291   ins_pipe(pipe_slow);
12292 %}
12293 
12294 // ============================================================================
12295 // Branch Instructions -- short offset versions
12296 //
12297 // These instructions are used to replace jumps of a long offset (the default
12298 // match) with jumps of a shorter offset.  These instructions are all tagged
12299 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12300 // match rules in general matching.  Instead, the ADLC generates a conversion
12301 // method in the MachNode which can be used to do in-place replacement of the
12302 // long variant with the shorter variant.  The compiler will determine if a
12303 // branch can be taken by the is_short_branch_offset() predicate in the machine
12304 // specific code section of the file.
12305 
12306 // Jump Direct - Label defines a relative address from JMP+1
12307 instruct jmpDir_short(label labl) %{
12308   match(Goto);
12309   effect(USE labl);
12310 
12311   ins_cost(300);
12312   format %{ &quot;jmp,s   $labl&quot; %}
12313   size(2);
12314   ins_encode %{
12315     Label* L = $labl$$label;
12316     __ jmpb(*L);
12317   %}
12318   ins_pipe(pipe_jmp);
12319   ins_short_branch(1);
12320 %}
12321 
12322 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12323 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12324   match(If cop cr);
12325   effect(USE labl);
12326 
12327   ins_cost(300);
12328   format %{ &quot;j$cop,s   $labl&quot; %}
12329   size(2);
12330   ins_encode %{
12331     Label* L = $labl$$label;
12332     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12333   %}
12334   ins_pipe(pipe_jcc);
12335   ins_short_branch(1);
12336 %}
12337 
12338 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12339 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12340   match(CountedLoopEnd cop cr);
12341   effect(USE labl);
12342 
12343   ins_cost(300);
12344   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12345   size(2);
12346   ins_encode %{
12347     Label* L = $labl$$label;
12348     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12349   %}
12350   ins_pipe(pipe_jcc);
12351   ins_short_branch(1);
12352 %}
12353 
12354 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12355 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12356   match(CountedLoopEnd cop cmp);
12357   effect(USE labl);
12358 
12359   ins_cost(300);
12360   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12361   size(2);
12362   ins_encode %{
12363     Label* L = $labl$$label;
12364     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12365   %}
12366   ins_pipe(pipe_jcc);
12367   ins_short_branch(1);
12368 %}
12369 
12370 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12371   match(CountedLoopEnd cop cmp);
12372   effect(USE labl);
12373 
12374   ins_cost(300);
12375   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12376   size(2);
12377   ins_encode %{
12378     Label* L = $labl$$label;
12379     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12380   %}
12381   ins_pipe(pipe_jcc);
12382   ins_short_branch(1);
12383 %}
12384 
12385 // Jump Direct Conditional - using unsigned comparison
12386 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12387   match(If cop cmp);
12388   effect(USE labl);
12389 
12390   ins_cost(300);
12391   format %{ &quot;j$cop,us  $labl&quot; %}
12392   size(2);
12393   ins_encode %{
12394     Label* L = $labl$$label;
12395     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12396   %}
12397   ins_pipe(pipe_jcc);
12398   ins_short_branch(1);
12399 %}
12400 
12401 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12402   match(If cop cmp);
12403   effect(USE labl);
12404 
12405   ins_cost(300);
12406   format %{ &quot;j$cop,us  $labl&quot; %}
12407   size(2);
12408   ins_encode %{
12409     Label* L = $labl$$label;
12410     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12411   %}
12412   ins_pipe(pipe_jcc);
12413   ins_short_branch(1);
12414 %}
12415 
12416 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12417   match(If cop cmp);
12418   effect(USE labl);
12419 
12420   ins_cost(300);
12421   format %{ $$template
12422     if ($cop$$cmpcode == Assembler::notEqual) {
12423       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12424       $$emit$$&quot;j$cop,u,s  $labl&quot;
12425     } else {
12426       $$emit$$&quot;jp,u,s  done\n\t&quot;
12427       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12428       $$emit$$&quot;done:&quot;
12429     }
12430   %}
12431   size(4);
12432   ins_encode %{
12433     Label* l = $labl$$label;
12434     if ($cop$$cmpcode == Assembler::notEqual) {
12435       __ jccb(Assembler::parity, *l);
12436       __ jccb(Assembler::notEqual, *l);
12437     } else if ($cop$$cmpcode == Assembler::equal) {
12438       Label done;
12439       __ jccb(Assembler::parity, done);
12440       __ jccb(Assembler::equal, *l);
12441       __ bind(done);
12442     } else {
12443        ShouldNotReachHere();
12444     }
12445   %}
12446   ins_pipe(pipe_jcc);
12447   ins_short_branch(1);
12448 %}
12449 
12450 // ============================================================================
12451 // inlined locking and unlocking
12452 
12453 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12454   predicate(Compile::current()-&gt;use_rtm());
12455   match(Set cr (FastLock object box));
12456   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12457   ins_cost(300);
12458   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12459   ins_encode %{
12460     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12461                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12462                  _counters, _rtm_counters, _stack_rtm_counters,
12463                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12464                  true, ra_-&gt;C-&gt;profile_rtm());
12465   %}
12466   ins_pipe(pipe_slow);
12467 %}
12468 
<a name="19" id="anc19"></a><span class="line-modified">12469 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{</span>
12470   predicate(!Compile::current()-&gt;use_rtm());
12471   match(Set cr (FastLock object box));
<a name="20" id="anc20"></a><span class="line-modified">12472   effect(TEMP tmp, TEMP scr, USE_KILL box);</span>
12473   ins_cost(300);
12474   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12475   ins_encode %{
12476     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
<a name="21" id="anc21"></a><span class="line-modified">12477                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);</span>
12478   %}
12479   ins_pipe(pipe_slow);
12480 %}
12481 
12482 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12483   match(Set cr (FastUnlock object box));
12484   effect(TEMP tmp, USE_KILL box);
12485   ins_cost(300);
12486   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12487   ins_encode %{
12488     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12489   %}
12490   ins_pipe(pipe_slow);
12491 %}
12492 
12493 
12494 // ============================================================================
12495 // Safepoint Instructions
12496 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12497 %{
12498   match(SafePoint poll);
12499   effect(KILL cr, USE poll);
12500 
12501   format %{ &quot;testl   rax, [$poll]\t&quot;
12502             &quot;# Safepoint: poll for GC&quot; %}
12503   ins_cost(125);
12504   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12505   ins_encode %{
12506     __ relocate(relocInfo::poll_type);
12507     address pre_pc = __ pc();
12508     __ testl(rax, Address($poll$$Register, 0));
12509     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12510   %}
12511   ins_pipe(ialu_reg_mem);
12512 %}
12513 
12514 // ============================================================================
12515 // Procedure Call/Return Instructions
12516 // Call Java Static Instruction
12517 // Note: If this code changes, the corresponding ret_addr_offset() and
12518 //       compute_padding() functions will have to be adjusted.
12519 instruct CallStaticJavaDirect(method meth) %{
12520   match(CallStaticJava);
12521   effect(USE meth);
12522 
12523   ins_cost(300);
12524   format %{ &quot;call,static &quot; %}
12525   opcode(0xE8); /* E8 cd */
12526   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12527   ins_pipe(pipe_slow);
12528   ins_alignment(4);
12529 %}
12530 
12531 // Call Java Dynamic Instruction
12532 // Note: If this code changes, the corresponding ret_addr_offset() and
12533 //       compute_padding() functions will have to be adjusted.
12534 instruct CallDynamicJavaDirect(method meth)
12535 %{
12536   match(CallDynamicJava);
12537   effect(USE meth);
12538 
12539   ins_cost(300);
12540   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12541             &quot;call,dynamic &quot; %}
12542   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12543   ins_pipe(pipe_slow);
12544   ins_alignment(4);
12545 %}
12546 
12547 // Call Runtime Instruction
12548 instruct CallRuntimeDirect(method meth)
12549 %{
12550   match(CallRuntime);
12551   effect(USE meth);
12552 
12553   ins_cost(300);
12554   format %{ &quot;call,runtime &quot; %}
12555   ins_encode(clear_avx, Java_To_Runtime(meth));
12556   ins_pipe(pipe_slow);
12557 %}
12558 
12559 // Call runtime without safepoint
12560 instruct CallLeafDirect(method meth)
12561 %{
12562   match(CallLeaf);
12563   effect(USE meth);
12564 
12565   ins_cost(300);
12566   format %{ &quot;call_leaf,runtime &quot; %}
12567   ins_encode(clear_avx, Java_To_Runtime(meth));
12568   ins_pipe(pipe_slow);
12569 %}
12570 
12571 // Call runtime without safepoint
12572 instruct CallLeafNoFPDirect(method meth)
12573 %{
12574   match(CallLeafNoFP);
12575   effect(USE meth);
12576 
12577   ins_cost(300);
12578   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12579   ins_encode(clear_avx, Java_To_Runtime(meth));
12580   ins_pipe(pipe_slow);
12581 %}
12582 
12583 // Return Instruction
12584 // Remove the return address &amp; jump to it.
12585 // Notice: We always emit a nop after a ret to make sure there is room
12586 // for safepoint patching
12587 instruct Ret()
12588 %{
12589   match(Return);
12590 
12591   format %{ &quot;ret&quot; %}
12592   opcode(0xC3);
12593   ins_encode(OpcP);
12594   ins_pipe(pipe_jmp);
12595 %}
12596 
12597 // Tail Call; Jump from runtime stub to Java code.
12598 // Also known as an &#39;interprocedural jump&#39;.
12599 // Target of jump will eventually return to caller.
12600 // TailJump below removes the return address.
12601 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12602 %{
12603   match(TailCall jump_target method_oop);
12604 
12605   ins_cost(300);
12606   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12607   opcode(0xFF, 0x4); /* Opcode FF /4 */
12608   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12609   ins_pipe(pipe_jmp);
12610 %}
12611 
12612 // Tail Jump; remove the return address; jump to target.
12613 // TailCall above leaves the return address around.
12614 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12615 %{
12616   match(TailJump jump_target ex_oop);
12617 
12618   ins_cost(300);
12619   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12620             &quot;jmp     $jump_target&quot; %}
12621   opcode(0xFF, 0x4); /* Opcode FF /4 */
12622   ins_encode(Opcode(0x5a), // popq rdx
12623              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12624   ins_pipe(pipe_jmp);
12625 %}
12626 
12627 // Create exception oop: created by stack-crawling runtime code.
12628 // Created exception is now available to this handler, and is setup
12629 // just prior to jumping to this handler.  No code emitted.
12630 instruct CreateException(rax_RegP ex_oop)
12631 %{
12632   match(Set ex_oop (CreateEx));
12633 
12634   size(0);
12635   // use the following format syntax
12636   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12637   ins_encode();
12638   ins_pipe(empty);
12639 %}
12640 
12641 // Rethrow exception:
12642 // The exception oop will come in the first argument position.
12643 // Then JUMP (not call) to the rethrow stub code.
12644 instruct RethrowException()
12645 %{
12646   match(Rethrow);
12647 
12648   // use the following format syntax
12649   format %{ &quot;jmp     rethrow_stub&quot; %}
12650   ins_encode(enc_rethrow);
12651   ins_pipe(pipe_jmp);
12652 %}
12653 
12654 // ============================================================================
12655 // This name is KNOWN by the ADLC and cannot be changed.
12656 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12657 // for this guy.
12658 instruct tlsLoadP(r15_RegP dst) %{
12659   match(Set dst (ThreadLocal));
12660   effect(DEF dst);
12661 
12662   size(0);
12663   format %{ &quot;# TLS is in R15&quot; %}
12664   ins_encode( /*empty encoding*/ );
12665   ins_pipe(ialu_reg_reg);
12666 %}
12667 
12668 
12669 //----------PEEPHOLE RULES-----------------------------------------------------
12670 // These must follow all instruction definitions as they use the names
12671 // defined in the instructions definitions.
12672 //
12673 // peepmatch ( root_instr_name [preceding_instruction]* );
12674 //
12675 // peepconstraint %{
12676 // (instruction_number.operand_name relational_op instruction_number.operand_name
12677 //  [, ...] );
12678 // // instruction numbers are zero-based using left to right order in peepmatch
12679 //
12680 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12681 // // provide an instruction_number.operand_name for each operand that appears
12682 // // in the replacement instruction&#39;s match rule
12683 //
12684 // ---------VM FLAGS---------------------------------------------------------
12685 //
12686 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12687 //
12688 // Each peephole rule is given an identifying number starting with zero and
12689 // increasing by one in the order seen by the parser.  An individual peephole
12690 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12691 // on the command-line.
12692 //
12693 // ---------CURRENT LIMITATIONS----------------------------------------------
12694 //
12695 // Only match adjacent instructions in same basic block
12696 // Only equality constraints
12697 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12698 // Only one replacement instruction
12699 //
12700 // ---------EXAMPLE----------------------------------------------------------
12701 //
12702 // // pertinent parts of existing instructions in architecture description
12703 // instruct movI(rRegI dst, rRegI src)
12704 // %{
12705 //   match(Set dst (CopyI src));
12706 // %}
12707 //
12708 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12709 // %{
12710 //   match(Set dst (AddI dst src));
12711 //   effect(KILL cr);
12712 // %}
12713 //
12714 // // Change (inc mov) to lea
12715 // peephole %{
12716 //   // increment preceeded by register-register move
12717 //   peepmatch ( incI_rReg movI );
12718 //   // require that the destination register of the increment
12719 //   // match the destination register of the move
12720 //   peepconstraint ( 0.dst == 1.dst );
12721 //   // construct a replacement instruction that sets
12722 //   // the destination to ( move&#39;s source register + one )
12723 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12724 // %}
12725 //
12726 
12727 // Implementation no longer uses movX instructions since
12728 // machine-independent system no longer uses CopyX nodes.
12729 //
12730 // peephole
12731 // %{
12732 //   peepmatch (incI_rReg movI);
12733 //   peepconstraint (0.dst == 1.dst);
12734 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12735 // %}
12736 
12737 // peephole
12738 // %{
12739 //   peepmatch (decI_rReg movI);
12740 //   peepconstraint (0.dst == 1.dst);
12741 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12742 // %}
12743 
12744 // peephole
12745 // %{
12746 //   peepmatch (addI_rReg_imm movI);
12747 //   peepconstraint (0.dst == 1.dst);
12748 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12749 // %}
12750 
12751 // peephole
12752 // %{
12753 //   peepmatch (incL_rReg movL);
12754 //   peepconstraint (0.dst == 1.dst);
12755 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12756 // %}
12757 
12758 // peephole
12759 // %{
12760 //   peepmatch (decL_rReg movL);
12761 //   peepconstraint (0.dst == 1.dst);
12762 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12763 // %}
12764 
12765 // peephole
12766 // %{
12767 //   peepmatch (addL_rReg_imm movL);
12768 //   peepconstraint (0.dst == 1.dst);
12769 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12770 // %}
12771 
12772 // peephole
12773 // %{
12774 //   peepmatch (addP_rReg_imm movP);
12775 //   peepconstraint (0.dst == 1.dst);
12776 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12777 // %}
12778 
12779 // // Change load of spilled value to only a spill
12780 // instruct storeI(memory mem, rRegI src)
12781 // %{
12782 //   match(Set mem (StoreI mem src));
12783 // %}
12784 //
12785 // instruct loadI(rRegI dst, memory mem)
12786 // %{
12787 //   match(Set dst (LoadI mem));
12788 // %}
12789 //
12790 
12791 peephole
12792 %{
12793   peepmatch (loadI storeI);
12794   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12795   peepreplace (storeI(1.mem 1.mem 1.src));
12796 %}
12797 
12798 peephole
12799 %{
12800   peepmatch (loadL storeL);
12801   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12802   peepreplace (storeL(1.mem 1.mem 1.src));
12803 %}
12804 
12805 //----------SMARTSPILL RULES---------------------------------------------------
12806 // These must follow all instruction definitions as they use the names
12807 // defined in the instructions definitions.
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
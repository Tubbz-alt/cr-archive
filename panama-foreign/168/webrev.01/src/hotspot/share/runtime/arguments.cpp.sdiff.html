<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/arguments.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/whitebox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/arguments.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 508 // This table ensures that the handling of options will update automatically when the JDK
 509 // version is incremented, but the source code needs to be cleanup up manually:
 510 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 511 //   variable should be removed, as well as users of the variable.
 512 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 513 //   &quot;Obsolete Flags&quot; section of the table.
 514 // - All expired options should be removed from the table.
 515 static SpecialFlag const special_jvm_flags[] = {
 516   // -------------- Deprecated Flags --------------
 517   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 518   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
 519   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 520   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 521   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 522   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
 523   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 524   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 525   { &quot;PrintVMQWaitTime&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 526   { &quot;UseNewFieldLayout&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 527   { &quot;ForceNUMA&quot;,                    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },








 528 
 529   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 530   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 531   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 532   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 533 
 534   // -------------- Obsolete Flags - sorted by expired_in --------------
 535   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 536   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 537   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 538   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 539   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 540   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 541   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 542   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 543   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 544   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 545   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 546   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 547   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
</pre>
<hr />
<pre>
1649   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1650   NOT_LP64(ShouldNotReachHere(); return 0);
1651 }
1652 
1653 void Arguments::set_use_compressed_oops() {
1654 #ifndef ZERO
1655 #ifdef _LP64
1656   // MaxHeapSize is not set up properly at this point, but
1657   // the only value that can override MaxHeapSize if we are
1658   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1659   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1660 
1661   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1662     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1663       FLAG_SET_ERGO(UseCompressedOops, true);
1664     }
1665   } else {
1666     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1667       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1668       FLAG_SET_DEFAULT(UseCompressedOops, false);
<span class="line-modified">1669       FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>


1670     }
1671   }
1672 #endif // _LP64
1673 #endif // ZERO
1674 }
1675 
1676 
1677 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1678 // set_use_compressed_oops().
1679 void Arguments::set_use_compressed_klass_ptrs() {
1680 #ifndef ZERO
1681 #ifdef _LP64
<span class="line-modified">1682   // UseCompressedOops must be on for UseCompressedClassPointers to be on.</span>
<span class="line-modified">1683   if (!UseCompressedOops) {</span>






1684     if (UseCompressedClassPointers) {
1685       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1686     }
1687     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1688   } else {
1689     // Turn on UseCompressedClassPointers too
1690     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1691       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1692     }
1693     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1694     if (UseCompressedClassPointers) {
1695       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1696         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1697         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1698       }
1699     }
1700   }
1701 #endif // _LP64
1702 #endif // !ZERO
1703 }
</pre>
<hr />
<pre>
1792   // then set it as fraction of the size of physical memory,
1793   // respecting the maximum and minimum sizes of the heap.
1794   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1795     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1796     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1797     if (reasonable_min &lt; MaxHeapSize) {
1798       // Small physical memory, so use a minimum fraction of it for the heap
1799       reasonable_max = reasonable_min;
1800     } else {
1801       // Not-small physical memory, so require a heap at least
1802       // as large as MaxHeapSize
1803       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1804     }
1805 
1806     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1807       // Limit the heap size to ErgoHeapSizeLimit
1808       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1809     }
1810 
1811 #ifdef _LP64
<span class="line-modified">1812     if (UseCompressedOops) {</span>
<span class="line-removed">1813       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="line-removed">1814       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
<span class="line-removed">1815 </span>
1816       // HeapBaseMinAddress can be greater than default but not less than.
1817       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1818         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1819           // matches compressed oops printing flags
1820           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1821                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1822                                      DefaultHeapBaseMinAddress,
1823                                      DefaultHeapBaseMinAddress/G,
1824                                      HeapBaseMinAddress);
1825           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1826         }
1827       }




1828 
1829       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1830         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1831         // but it should be not less than default MaxHeapSize.
1832         max_coop_heap -= HeapBaseMinAddress;
1833       }
1834 
1835       // If user specified flags prioritizing os physical
1836       // memory limits, then disable compressed oops if
1837       // limits exceed max_coop_heap and UseCompressedOops
1838       // was not specified.
1839       if (reasonable_max &gt; max_coop_heap) {
1840         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1841           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1842             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1843             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1844             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1845           FLAG_SET_ERGO(UseCompressedOops, false);
<span class="line-modified">1846           FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>


1847         } else {
1848           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1849         }
1850       }
1851     }
1852 #endif // _LP64
1853 
1854     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1855 
1856     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1857       // An initial heap size was specified on the command line,
1858       // so be sure that the maximum size is consistent.  Done
1859       // after call to limit_by_allocatable_memory because that
1860       // method might reduce the allocation size.
1861       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1862     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1863       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1864     }
1865 
1866     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
</pre>
<hr />
<pre>
3483     // steal a white space character and set it to NULL
3484     *wrt++ = &#39;\0&#39;;
3485     // We now have a complete token
3486 
3487     JavaVMOption option;
3488     option.optionString = opt_hd;
3489     option.extraInfo = NULL;
3490 
3491     options-&gt;append(option);                // Fill in option
3492 
3493     rd++;  // Advance to next character
3494   }
3495 
3496   // Fill out JavaVMInitArgs structure.
3497   jint status = vm_args-&gt;set_args(options);
3498 
3499   delete options;
3500   return status;
3501 }
3502 
<span class="line-modified">3503 void Arguments::set_shared_spaces_flags() {</span>
3504   if (DumpSharedSpaces) {
3505     if (RequireSharedSpaces) {
3506       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3507     }
3508     UseSharedSpaces = false;
3509   }








3510 }
3511 
3512 #if INCLUDE_CDS
3513 // Sharing support
3514 // Construct the path to the archive
3515 char* Arguments::get_default_shared_archive_path() {
3516   char *default_archive_path;
3517   char jvm_path[JVM_MAXPATHLEN];
3518   os::jvm_path(jvm_path, sizeof(jvm_path));
3519   char *end = strrchr(jvm_path, *os::file_separator());
3520   if (end != NULL) *end = &#39;\0&#39;;
3521   size_t jvm_path_len = strlen(jvm_path);
3522   size_t file_sep_len = strlen(os::file_separator());
3523   const size_t len = jvm_path_len + file_sep_len + 20;
3524   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">3525   jio_snprintf(default_archive_path, len, &quot;%s%sclasses.jsa&quot;,</span>

3526                jvm_path, os::file_separator());
3527   return default_archive_path;
3528 }
3529 
3530 int Arguments::num_archives(const char* archive_path) {
3531   if (archive_path == NULL) {
3532     return 0;
3533   }
3534   int npaths = 1;
3535   char* p = (char*)archive_path;
3536   while (*p != &#39;\0&#39;) {
3537     if (*p == os::path_separator()[0]) {
3538       npaths++;
3539     }
3540     p++;
3541   }
3542   return npaths;
3543 }
3544 
3545 void Arguments::extract_shared_archive_paths(const char* archive_path,
</pre>
<hr />
<pre>
3950     }
3951 #endif
3952   }
3953 
3954   if (PrintVMOptions) {
3955     print_options(cur_java_tool_options_args);
3956     print_options(cur_cmd_args);
3957     print_options(cur_java_options_args);
3958   }
3959 
3960   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
3961   jint result = parse_vm_init_args(cur_vm_options_args,
3962                                    cur_java_tool_options_args,
3963                                    cur_java_options_args,
3964                                    cur_cmd_args);
3965 
3966   if (result != JNI_OK) {
3967     return result;
3968   }
3969 
<span class="line-removed">3970 #if INCLUDE_CDS</span>
<span class="line-removed">3971   // Initialize shared archive paths which could include both base and dynamic archive paths</span>
<span class="line-removed">3972   if (!init_shared_archive_paths()) {</span>
<span class="line-removed">3973     return JNI_ENOMEM;</span>
<span class="line-removed">3974   }</span>
<span class="line-removed">3975 #endif</span>
<span class="line-removed">3976 </span>
3977   // Delay warning until here so that we&#39;ve had a chance to process
3978   // the -XX:-PrintWarnings flag
3979   if (needs_hotspotrc_warning) {
3980     warning(&quot;%s file is present but has been ignored.  &quot;
3981             &quot;Run with -XX:Flags=%s to load the file.&quot;,
3982             hotspotrc, hotspotrc);
3983   }
3984 
3985   if (needs_module_property_warning) {
3986     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
3987             &quot; names that are reserved for internal use.&quot;);
3988   }
3989 
3990 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
3991   UNSUPPORTED_OPTION(UseLargePages);
3992 #endif
3993 
3994 #if defined(AIX)
3995   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
3996   UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);
</pre>
<hr />
<pre>
4044 
4045 #ifndef TIERED
4046   if (FLAG_IS_CMDLINE(CompilationMode)) {
4047     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);
4048   }
4049 #endif
4050 
4051   return JNI_OK;
4052 }
4053 
4054 jint Arguments::apply_ergo() {
4055   // Set flags based on ergonomics.
4056   jint result = set_ergonomics_flags();
4057   if (result != JNI_OK) return result;
4058 
4059   // Set heap size based on available physical memory
4060   set_heap_size();
4061 
4062   GCConfig::arguments()-&gt;initialize();
4063 
<span class="line-modified">4064   set_shared_spaces_flags();</span>

4065 
4066   // Initialize Metaspace flags and alignments
4067   Metaspace::ergo_initialize();
4068 
4069   // Set compiler flags after GC is selected and GC specific
4070   // flags (LoopStripMiningIter) are set.
4071   CompilerConfig::ergo_initialize();
4072 
4073   // Set bytecode rewriting flags
4074   set_bytecode_flags();
4075 
4076   // Set flags if aggressive optimization flags are enabled
4077   jint code = set_aggressive_opts_flags();
4078   if (code != JNI_OK) {
4079     return code;
4080   }
4081 
4082   // Turn off biased locking for locking debug mode flags,
4083   // which are subtly different from each other but neither works with
4084   // biased locking
</pre>
</td>
<td>
<hr />
<pre>
 508 // This table ensures that the handling of options will update automatically when the JDK
 509 // version is incremented, but the source code needs to be cleanup up manually:
 510 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; or &quot;expired&quot; options, the associated &quot;globals&quot;
 511 //   variable should be removed, as well as users of the variable.
 512 // - As &quot;deprecated&quot; options age into &quot;obsolete&quot; options, move the entry into the
 513 //   &quot;Obsolete Flags&quot; section of the table.
 514 // - All expired options should be removed from the table.
 515 static SpecialFlag const special_jvm_flags[] = {
 516   // -------------- Deprecated Flags --------------
 517   // --- Non-alias flags - sorted by obsolete_in then expired_in:
 518   { &quot;MaxGCMinorPauseMillis&quot;,        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },
 519   { &quot;MaxRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 520   { &quot;MinRAMFraction&quot;,               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 521   { &quot;InitialRAMFraction&quot;,           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },
 522   { &quot;UseMembar&quot;,                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },
 523   { &quot;AllowRedefinitionToAddDeleteMethods&quot;, JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 524   { &quot;FlightRecorder&quot;,               JDK_Version::jdk(13), JDK_Version::undefined(), JDK_Version::undefined() },
 525   { &quot;PrintVMQWaitTime&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 526   { &quot;UseNewFieldLayout&quot;,            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
 527   { &quot;ForceNUMA&quot;,                    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },
<span class="line-added"> 528   { &quot;UseBiasedLocking&quot;,             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 529   { &quot;BiasedLockingStartupDelay&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 530   { &quot;PrintBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 531   { &quot;BiasedLockingBulkRebiasThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 532   { &quot;BiasedLockingBulkRevokeThreshold&quot;,    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 533   { &quot;BiasedLockingDecayTime&quot;,              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 534   { &quot;UseOptoBiasInlining&quot;,                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
<span class="line-added"> 535   { &quot;PrintPreciseBiasedLockingStatistics&quot;, JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },</span>
 536 
 537   // --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:
 538   { &quot;DefaultMaxRAMFraction&quot;,        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },
 539   { &quot;CreateMinidumpOnCrash&quot;,        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },
 540   { &quot;TLABStats&quot;,                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },
 541 
 542   // -------------- Obsolete Flags - sorted by expired_in --------------
 543   { &quot;PermSize&quot;,                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 544   { &quot;MaxPermSize&quot;,                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },
 545   { &quot;SharedReadWriteSize&quot;,           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 546   { &quot;SharedReadOnlySize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 547   { &quot;SharedMiscDataSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 548   { &quot;SharedMiscCodeSize&quot;,            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },
 549   { &quot;BindGCTaskThreadsToCPUs&quot;,       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 550   { &quot;UseGCTaskAffinity&quot;,             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 551   { &quot;GCTaskTimeStampEntries&quot;,        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },
 552   { &quot;G1RSetScanBlockSize&quot;,           JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 553   { &quot;UseParallelOldGC&quot;,              JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 554   { &quot;CompactFields&quot;,                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 555   { &quot;FieldsAllocationStyle&quot;,         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
</pre>
<hr />
<pre>
1657   LP64_ONLY(return OopEncodingHeapMax - displacement_due_to_null_page);
1658   NOT_LP64(ShouldNotReachHere(); return 0);
1659 }
1660 
1661 void Arguments::set_use_compressed_oops() {
1662 #ifndef ZERO
1663 #ifdef _LP64
1664   // MaxHeapSize is not set up properly at this point, but
1665   // the only value that can override MaxHeapSize if we are
1666   // to use UseCompressedOops are InitialHeapSize and MinHeapSize.
1667   size_t max_heap_size = MAX3(MaxHeapSize, InitialHeapSize, MinHeapSize);
1668 
1669   if (max_heap_size &lt;= max_heap_for_compressed_oops()) {
1670     if (FLAG_IS_DEFAULT(UseCompressedOops)) {
1671       FLAG_SET_ERGO(UseCompressedOops, true);
1672     }
1673   } else {
1674     if (UseCompressedOops &amp;&amp; !FLAG_IS_DEFAULT(UseCompressedOops)) {
1675       warning(&quot;Max heap size too large for Compressed Oops&quot;);
1676       FLAG_SET_DEFAULT(UseCompressedOops, false);
<span class="line-modified">1677       if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="line-added">1678         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);</span>
<span class="line-added">1679       }</span>
1680     }
1681   }
1682 #endif // _LP64
1683 #endif // ZERO
1684 }
1685 
1686 
1687 // NOTE: set_use_compressed_klass_ptrs() must be called after calling
1688 // set_use_compressed_oops().
1689 void Arguments::set_use_compressed_klass_ptrs() {
1690 #ifndef ZERO
1691 #ifdef _LP64
<span class="line-modified">1692   // On some architectures, the use of UseCompressedClassPointers implies the use of</span>
<span class="line-modified">1693   // UseCompressedOops. The reason is that the rheap_base register of said platforms</span>
<span class="line-added">1694   // is reused to perform some optimized spilling, in order to use rheap_base as a</span>
<span class="line-added">1695   // temp register. But by treating it as any other temp register, spilling can typically</span>
<span class="line-added">1696   // be completely avoided instead. So it is better not to perform this trick. And by</span>
<span class="line-added">1697   // not having that reliance, large heaps, or heaps not supporting compressed oops,</span>
<span class="line-added">1698   // can still use compressed class pointers.</span>
<span class="line-added">1699   if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS &amp;&amp; !UseCompressedOops) {</span>
1700     if (UseCompressedClassPointers) {
1701       warning(&quot;UseCompressedClassPointers requires UseCompressedOops&quot;);
1702     }
1703     FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1704   } else {
1705     // Turn on UseCompressedClassPointers too
1706     if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {
1707       FLAG_SET_ERGO(UseCompressedClassPointers, true);
1708     }
1709     // Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.
1710     if (UseCompressedClassPointers) {
1711       if (CompressedClassSpaceSize &gt; KlassEncodingMetaspaceMax) {
1712         warning(&quot;CompressedClassSpaceSize is too large for UseCompressedClassPointers&quot;);
1713         FLAG_SET_DEFAULT(UseCompressedClassPointers, false);
1714       }
1715     }
1716   }
1717 #endif // _LP64
1718 #endif // !ZERO
1719 }
</pre>
<hr />
<pre>
1808   // then set it as fraction of the size of physical memory,
1809   // respecting the maximum and minimum sizes of the heap.
1810   if (FLAG_IS_DEFAULT(MaxHeapSize)) {
1811     julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) / 100);
1812     const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) / 100);
1813     if (reasonable_min &lt; MaxHeapSize) {
1814       // Small physical memory, so use a minimum fraction of it for the heap
1815       reasonable_max = reasonable_min;
1816     } else {
1817       // Not-small physical memory, so require a heap at least
1818       // as large as MaxHeapSize
1819       reasonable_max = MAX2(reasonable_max, (julong)MaxHeapSize);
1820     }
1821 
1822     if (!FLAG_IS_DEFAULT(ErgoHeapSizeLimit) &amp;&amp; ErgoHeapSizeLimit != 0) {
1823       // Limit the heap size to ErgoHeapSizeLimit
1824       reasonable_max = MIN2(reasonable_max, (julong)ErgoHeapSizeLimit);
1825     }
1826 
1827 #ifdef _LP64
<span class="line-modified">1828     if (UseCompressedOops || UseCompressedClassPointers) {</span>



1829       // HeapBaseMinAddress can be greater than default but not less than.
1830       if (!FLAG_IS_DEFAULT(HeapBaseMinAddress)) {
1831         if (HeapBaseMinAddress &lt; DefaultHeapBaseMinAddress) {
1832           // matches compressed oops printing flags
1833           log_debug(gc, heap, coops)(&quot;HeapBaseMinAddress must be at least &quot; SIZE_FORMAT
1834                                      &quot; (&quot; SIZE_FORMAT &quot;G) which is greater than value given &quot; SIZE_FORMAT,
1835                                      DefaultHeapBaseMinAddress,
1836                                      DefaultHeapBaseMinAddress/G,
1837                                      HeapBaseMinAddress);
1838           FLAG_SET_ERGO(HeapBaseMinAddress, DefaultHeapBaseMinAddress);
1839         }
1840       }
<span class="line-added">1841     }</span>
<span class="line-added">1842     if (UseCompressedOops) {</span>
<span class="line-added">1843       // Limit the heap size to the maximum possible when using compressed oops</span>
<span class="line-added">1844       julong max_coop_heap = (julong)max_heap_for_compressed_oops();</span>
1845 
1846       if (HeapBaseMinAddress + MaxHeapSize &lt; max_coop_heap) {
1847         // Heap should be above HeapBaseMinAddress to get zero based compressed oops
1848         // but it should be not less than default MaxHeapSize.
1849         max_coop_heap -= HeapBaseMinAddress;
1850       }
1851 
1852       // If user specified flags prioritizing os physical
1853       // memory limits, then disable compressed oops if
1854       // limits exceed max_coop_heap and UseCompressedOops
1855       // was not specified.
1856       if (reasonable_max &gt; max_coop_heap) {
1857         if (FLAG_IS_ERGO(UseCompressedOops) &amp;&amp; override_coop_limit) {
1858           log_info(cds)(&quot;UseCompressedOops and UseCompressedClassPointers have been disabled due to&quot;
1859             &quot; max heap &quot; SIZE_FORMAT &quot; &gt; compressed oop heap &quot; SIZE_FORMAT &quot;. &quot;
1860             &quot;Please check the setting of MaxRAMPercentage %5.2f.&quot;
1861             ,(size_t)reasonable_max, (size_t)max_coop_heap, MaxRAMPercentage);
1862           FLAG_SET_ERGO(UseCompressedOops, false);
<span class="line-modified">1863           if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {</span>
<span class="line-added">1864             FLAG_SET_ERGO(UseCompressedClassPointers, false);</span>
<span class="line-added">1865           }</span>
1866         } else {
1867           reasonable_max = MIN2(reasonable_max, max_coop_heap);
1868         }
1869       }
1870     }
1871 #endif // _LP64
1872 
1873     reasonable_max = limit_by_allocatable_memory(reasonable_max);
1874 
1875     if (!FLAG_IS_DEFAULT(InitialHeapSize)) {
1876       // An initial heap size was specified on the command line,
1877       // so be sure that the maximum size is consistent.  Done
1878       // after call to limit_by_allocatable_memory because that
1879       // method might reduce the allocation size.
1880       reasonable_max = MAX2(reasonable_max, (julong)InitialHeapSize);
1881     } else if (!FLAG_IS_DEFAULT(MinHeapSize)) {
1882       reasonable_max = MAX2(reasonable_max, (julong)MinHeapSize);
1883     }
1884 
1885     log_trace(gc, heap)(&quot;  Maximum heap size &quot; SIZE_FORMAT, (size_t) reasonable_max);
</pre>
<hr />
<pre>
3502     // steal a white space character and set it to NULL
3503     *wrt++ = &#39;\0&#39;;
3504     // We now have a complete token
3505 
3506     JavaVMOption option;
3507     option.optionString = opt_hd;
3508     option.extraInfo = NULL;
3509 
3510     options-&gt;append(option);                // Fill in option
3511 
3512     rd++;  // Advance to next character
3513   }
3514 
3515   // Fill out JavaVMInitArgs structure.
3516   jint status = vm_args-&gt;set_args(options);
3517 
3518   delete options;
3519   return status;
3520 }
3521 
<span class="line-modified">3522 jint Arguments::set_shared_spaces_flags_and_archive_paths() {</span>
3523   if (DumpSharedSpaces) {
3524     if (RequireSharedSpaces) {
3525       warning(&quot;Cannot dump shared archive while using shared archive&quot;);
3526     }
3527     UseSharedSpaces = false;
3528   }
<span class="line-added">3529 #if INCLUDE_CDS</span>
<span class="line-added">3530   // Initialize shared archive paths which could include both base and dynamic archive paths</span>
<span class="line-added">3531   // This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.</span>
<span class="line-added">3532   if (!init_shared_archive_paths()) {</span>
<span class="line-added">3533     return JNI_ENOMEM;</span>
<span class="line-added">3534   }</span>
<span class="line-added">3535 #endif  // INCLUDE_CDS</span>
<span class="line-added">3536   return JNI_OK;</span>
3537 }
3538 
3539 #if INCLUDE_CDS
3540 // Sharing support
3541 // Construct the path to the archive
3542 char* Arguments::get_default_shared_archive_path() {
3543   char *default_archive_path;
3544   char jvm_path[JVM_MAXPATHLEN];
3545   os::jvm_path(jvm_path, sizeof(jvm_path));
3546   char *end = strrchr(jvm_path, *os::file_separator());
3547   if (end != NULL) *end = &#39;\0&#39;;
3548   size_t jvm_path_len = strlen(jvm_path);
3549   size_t file_sep_len = strlen(os::file_separator());
3550   const size_t len = jvm_path_len + file_sep_len + 20;
3551   default_archive_path = NEW_C_HEAP_ARRAY(char, len, mtArguments);
<span class="line-modified">3552   jio_snprintf(default_archive_path, len,</span>
<span class="line-added">3553                UseCompressedOops ? &quot;%s%sclasses.jsa&quot;: &quot;%s%sclasses_nocoops.jsa&quot;,</span>
3554                jvm_path, os::file_separator());
3555   return default_archive_path;
3556 }
3557 
3558 int Arguments::num_archives(const char* archive_path) {
3559   if (archive_path == NULL) {
3560     return 0;
3561   }
3562   int npaths = 1;
3563   char* p = (char*)archive_path;
3564   while (*p != &#39;\0&#39;) {
3565     if (*p == os::path_separator()[0]) {
3566       npaths++;
3567     }
3568     p++;
3569   }
3570   return npaths;
3571 }
3572 
3573 void Arguments::extract_shared_archive_paths(const char* archive_path,
</pre>
<hr />
<pre>
3978     }
3979 #endif
3980   }
3981 
3982   if (PrintVMOptions) {
3983     print_options(cur_java_tool_options_args);
3984     print_options(cur_cmd_args);
3985     print_options(cur_java_options_args);
3986   }
3987 
3988   // Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS
3989   jint result = parse_vm_init_args(cur_vm_options_args,
3990                                    cur_java_tool_options_args,
3991                                    cur_java_options_args,
3992                                    cur_cmd_args);
3993 
3994   if (result != JNI_OK) {
3995     return result;
3996   }
3997 







3998   // Delay warning until here so that we&#39;ve had a chance to process
3999   // the -XX:-PrintWarnings flag
4000   if (needs_hotspotrc_warning) {
4001     warning(&quot;%s file is present but has been ignored.  &quot;
4002             &quot;Run with -XX:Flags=%s to load the file.&quot;,
4003             hotspotrc, hotspotrc);
4004   }
4005 
4006   if (needs_module_property_warning) {
4007     warning(&quot;Ignoring system property options whose names match the &#39;-Djdk.module.*&#39;.&quot;
4008             &quot; names that are reserved for internal use.&quot;);
4009   }
4010 
4011 #if defined(_ALLBSD_SOURCE) || defined(AIX)  // UseLargePages is not yet supported on BSD and AIX.
4012   UNSUPPORTED_OPTION(UseLargePages);
4013 #endif
4014 
4015 #if defined(AIX)
4016   UNSUPPORTED_OPTION_NULL(AllocateHeapAt);
4017   UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);
</pre>
<hr />
<pre>
4065 
4066 #ifndef TIERED
4067   if (FLAG_IS_CMDLINE(CompilationMode)) {
4068     warning(&quot;CompilationMode has no effect in non-tiered VMs&quot;);
4069   }
4070 #endif
4071 
4072   return JNI_OK;
4073 }
4074 
4075 jint Arguments::apply_ergo() {
4076   // Set flags based on ergonomics.
4077   jint result = set_ergonomics_flags();
4078   if (result != JNI_OK) return result;
4079 
4080   // Set heap size based on available physical memory
4081   set_heap_size();
4082 
4083   GCConfig::arguments()-&gt;initialize();
4084 
<span class="line-modified">4085   result = set_shared_spaces_flags_and_archive_paths();</span>
<span class="line-added">4086   if (result != JNI_OK) return result;</span>
4087 
4088   // Initialize Metaspace flags and alignments
4089   Metaspace::ergo_initialize();
4090 
4091   // Set compiler flags after GC is selected and GC specific
4092   // flags (LoopStripMiningIter) are set.
4093   CompilerConfig::ergo_initialize();
4094 
4095   // Set bytecode rewriting flags
4096   set_bytecode_flags();
4097 
4098   // Set flags if aggressive optimization flags are enabled
4099   jint code = set_aggressive_opts_flags();
4100   if (code != JNI_OK) {
4101     return code;
4102   }
4103 
4104   // Turn off biased locking for locking debug mode flags,
4105   // which are subtly different from each other but neither works with
4106   // biased locking
</pre>
</td>
</tr>
</table>
<center><a href="../prims/whitebox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arguments.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
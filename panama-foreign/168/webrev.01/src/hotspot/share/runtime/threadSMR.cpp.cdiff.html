<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/threadSMR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/threadSMR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,10 ***</span>
<span class="line-new-header">--- 39,13 ---</span>
  #include &quot;utilities/ostream.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
  #include &quot;utilities/resourceHash.hpp&quot;
  #include &quot;utilities/vmError.hpp&quot;
  
<span class="line-added">+ // List of exiting threads</span>
<span class="line-added">+ ThreadsSMRSupport::Holder* ThreadsSMRSupport::_exiting_threads = NULL;</span>
<span class="line-added">+ </span>
  // The &#39;_cnt&#39;, &#39;_max&#39; and &#39;_times&quot; fields are enabled via
  // -XX:+EnableThreadSMRStatistics:
  
  // # of parallel threads in _delete_lock-&gt;wait().
  // Impl note: Hard to imagine &gt; 64K waiting threads so this could be 16-bit,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 921,14 ***</span>
<span class="line-new-header">--- 924,18 ---</span>
      log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::release_stable_list notified %s&quot;, os::current_thread_id(), log_str);
    }
  }
  
  void ThreadsSMRSupport::remove_thread(JavaThread *thread) {
<span class="line-added">+ </span>
<span class="line-added">+   ThreadsSMRSupport::add_exiting_thread(thread);</span>
<span class="line-added">+ </span>
    if (ThreadIdTable::is_initialized()) {
      jlong tid = SharedRuntime::get_java_tid(thread);
      ThreadIdTable::remove_thread(tid);
    }
<span class="line-added">+ </span>
    ThreadsList *new_list = ThreadsList::remove_thread(ThreadsSMRSupport::get_java_thread_list(), thread);
    if (EnableThreadSMRStatistics) {
      ThreadsSMRSupport::inc_java_thread_list_alloc_cnt();
      // This list is smaller so no need to check for a &quot;longest&quot; update.
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 989,10 ***</span>
<span class="line-new-header">--- 996,11 ---</span>
  
        if (!is_a_protected_JavaThread(thread)) {
          // This is the common case.
          ThreadsSMRSupport::clear_delete_notify();
          ThreadsSMRSupport::delete_lock()-&gt;unlock();
<span class="line-added">+         ThreadsSMRSupport::remove_exiting_thread(thread);</span>
          break;
        }
        if (!has_logged_once) {
          has_logged_once = true;
          log_debug(thread, smr)(&quot;tid=&quot; UINTX_FORMAT &quot;: ThreadsSMRSupport::wait_until_not_protected: thread=&quot; INTPTR_FORMAT &quot; is not deleted.&quot;, os::current_thread_id(), p2i(thread));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,5 ***</span>
<span class="line-new-header">--- 1186,49 ---</span>
        st-&gt;cr();
      }
      cnt++;
    }
  }
<span class="line-added">+ </span>
<span class="line-added">+ void ThreadsSMRSupport::add_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">+   assert(thread == JavaThread::current(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(Threads_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(!contains_exiting_thread(thread), &quot;invariant&quot;);</span>
<span class="line-added">+   Holder* h = new Holder(thread, _exiting_threads);</span>
<span class="line-added">+   _exiting_threads = h;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ThreadsSMRSupport::remove_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">+   assert(thread == JavaThread::current(), &quot;invariant&quot;);</span>
<span class="line-added">+   assert(Threads_lock-&gt;owned_by_self(), &quot;invariant&quot;);</span>
<span class="line-added">+   // If a thread fails to initialize fully it can be deleted immediately</span>
<span class="line-added">+   // so we won&#39;t remove it from the ThreadsList and so never add it to the</span>
<span class="line-added">+   // exiting thread list - so we can&#39;t assert(contains_exiting_thread(p)) here.</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (Holder* current = _exiting_threads, **prev_next = &amp;_exiting_threads;</span>
<span class="line-added">+        current != NULL;</span>
<span class="line-added">+        prev_next = &amp;current-&gt;_next, current = current-&gt;_next) {</span>
<span class="line-added">+     if (current-&gt;_thread == thread) {</span>
<span class="line-added">+       *prev_next = current-&gt;_next;</span>
<span class="line-added">+       delete current;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+ bool ThreadsSMRSupport::contains_exiting_thread(JavaThread* thread) {</span>
<span class="line-added">+   for (Holder* current = _exiting_threads; current != NULL; current = current-&gt;_next) {</span>
<span class="line-added">+     if (current-&gt;_thread == thread) {</span>
<span class="line-added">+       return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ void ThreadsSMRSupport::exiting_threads_oops_do(OopClosure* f) {</span>
<span class="line-added">+   assert_locked_or_safepoint(Threads_lock);</span>
<span class="line-added">+   for (Holder* current = _exiting_threads; current != NULL; current = current-&gt;_next) {</span>
<span class="line-added">+     f-&gt;do_oop((oop*) &amp;current-&gt;_thread-&gt;_threadObj);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="thread.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="threadSMR.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
299   void add_class(Klass* k, bool publicize = true);
300   void remove_class(Klass* k);
301   bool contains_klass(Klass* k);
302   void record_dependency(const Klass* to);
303   PackageEntryTable* packages() { return _packages; }
304   ModuleEntry* unnamed_module() { return _unnamed_module; }
305   ModuleEntryTable* modules();
306   bool modules_defined() { return (_modules != NULL); }
307 
308   // Offsets
309   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }
310   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }
311 
312   // Loaded class dictionary
313   Dictionary* dictionary() const { return _dictionary; }
314 
315   void add_to_deallocate_list(Metadata* m);
316 
317   static ClassLoaderData* class_loader_data(oop loader);
318   static ClassLoaderData* class_loader_data_or_null(oop loader);
<span class="line-removed">319   static ClassLoaderData* has_class_mirror_holder_cld(Handle loader);</span>
320 
321   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
322   // Also works if unloading.
323   Klass* class_loader_klass() const { return _class_loader_klass; }
324 
325   // Returns the class loader&#39;s explict name as specified during
326   // construction or the class loader&#39;s qualified class name.
327   // Works during unloading.
328   const char* loader_name() const;
329   // Returns the explicitly specified class loader name or NULL.
330   Symbol* name() const { return _name; }
331 
332   // Obtain the class loader&#39;s _name_and_id, works during unloading.
333   const char* loader_name_and_id() const;
334   Symbol* name_and_id() const { return _name_and_id; }
335 
336   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
337 };
338 
339 #endif // SHARE_CLASSFILE_CLASSLOADERDATA_HPP
</pre>
</td>
<td>
<hr />
<pre>
299   void add_class(Klass* k, bool publicize = true);
300   void remove_class(Klass* k);
301   bool contains_klass(Klass* k);
302   void record_dependency(const Klass* to);
303   PackageEntryTable* packages() { return _packages; }
304   ModuleEntry* unnamed_module() { return _unnamed_module; }
305   ModuleEntryTable* modules();
306   bool modules_defined() { return (_modules != NULL); }
307 
308   // Offsets
309   static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }
310   static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }
311 
312   // Loaded class dictionary
313   Dictionary* dictionary() const { return _dictionary; }
314 
315   void add_to_deallocate_list(Metadata* m);
316 
317   static ClassLoaderData* class_loader_data(oop loader);
318   static ClassLoaderData* class_loader_data_or_null(oop loader);

319 
320   // Returns Klass* of associated class loader, or NULL if associated loader is &#39;bootstrap&#39;.
321   // Also works if unloading.
322   Klass* class_loader_klass() const { return _class_loader_klass; }
323 
324   // Returns the class loader&#39;s explict name as specified during
325   // construction or the class loader&#39;s qualified class name.
326   // Works during unloading.
327   const char* loader_name() const;
328   // Returns the explicitly specified class loader name or NULL.
329   Symbol* name() const { return _name; }
330 
331   // Obtain the class loader&#39;s _name_and_id, works during unloading.
332   const char* loader_name_and_id() const;
333   Symbol* name_and_id() const { return _name_and_id; }
334 
335   JFR_ONLY(DEFINE_TRACE_ID_METHODS;)
336 };
337 
338 #endif // SHARE_CLASSFILE_CLASSLOADERDATA_HPP
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderDataGraph.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
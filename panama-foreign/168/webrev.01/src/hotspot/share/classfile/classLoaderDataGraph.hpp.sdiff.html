<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classLoaderDataGraph.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderStats.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classLoaderDataGraph.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40   friend class ClassLoaderDataGraphIterator;
 41   friend class VMStructs;
 42  private:
 43   // All CLDs (except the null CLD) can be reached by walking _head-&gt;_next-&gt;...
 44   static ClassLoaderData* volatile _head;
 45   static ClassLoaderData* _unloading;
 46 
 47   // Set if there&#39;s anything to purge in the deallocate lists or previous versions
 48   // during a safepoint after class unloading in a full GC.
 49   static bool _should_clean_deallocate_lists;
 50   static bool _safepoint_cleanup_needed;
 51 
 52   // OOM has been seen in metaspace allocation. Used to prevent some
 53   // allocations until class unloading
 54   static bool _metaspace_oom;
 55 
 56   static volatile size_t  _num_instance_classes;
 57   static volatile size_t  _num_array_classes;
 58 
 59   static ClassLoaderData* add_to_graph(Handle class_loader, bool has_class_mirror_holder);
<span class="line-removed"> 60   static ClassLoaderData* add(Handle class_loader, bool has_class_mirror_holder);</span>
 61 
 62  public:
 63   static ClassLoaderData* find_or_create(Handle class_loader);

 64   static void clean_module_and_package_info();
 65   static void purge();
 66   static void clear_claimed_marks();
 67   static void clear_claimed_marks(int claim);
 68   // Iteration through CLDG inside a safepoint; GC support
 69   static void cld_do(CLDClosure* cl);
 70   static void cld_unloading_do(CLDClosure* cl);
 71   static void roots_cld_do(CLDClosure* strong, CLDClosure* weak);
 72   static void always_strong_cld_do(CLDClosure* cl);
 73   // Iteration through CLDG not by GC.
 74   static void loaded_cld_do(CLDClosure* cl);
 75   // klass do
 76   // Walking classes through the ClassLoaderDataGraph include array classes.  It also includes
 77   // classes that are allocated but not loaded, classes that have errors, and scratch classes
 78   // for redefinition.  These classes are removed during the next class unloading.
 79   // Walking the ClassLoaderDataGraph also includes hidden and unsafe anonymous classes.
 80   static void classes_do(KlassClosure* klass_closure);
 81   static void classes_do(void f(Klass* const));
 82   static void methods_do(void f(Method*));
 83   static void modules_do(void f(ModuleEntry*));
</pre>
</td>
<td>
<hr />
<pre>
 40   friend class ClassLoaderDataGraphIterator;
 41   friend class VMStructs;
 42  private:
 43   // All CLDs (except the null CLD) can be reached by walking _head-&gt;_next-&gt;...
 44   static ClassLoaderData* volatile _head;
 45   static ClassLoaderData* _unloading;
 46 
 47   // Set if there&#39;s anything to purge in the deallocate lists or previous versions
 48   // during a safepoint after class unloading in a full GC.
 49   static bool _should_clean_deallocate_lists;
 50   static bool _safepoint_cleanup_needed;
 51 
 52   // OOM has been seen in metaspace allocation. Used to prevent some
 53   // allocations until class unloading
 54   static bool _metaspace_oom;
 55 
 56   static volatile size_t  _num_instance_classes;
 57   static volatile size_t  _num_array_classes;
 58 
 59   static ClassLoaderData* add_to_graph(Handle class_loader, bool has_class_mirror_holder);

 60 
 61  public:
 62   static ClassLoaderData* find_or_create(Handle class_loader);
<span class="line-added"> 63   static ClassLoaderData* add(Handle class_loader, bool has_class_mirror_holder);</span>
 64   static void clean_module_and_package_info();
 65   static void purge();
 66   static void clear_claimed_marks();
 67   static void clear_claimed_marks(int claim);
 68   // Iteration through CLDG inside a safepoint; GC support
 69   static void cld_do(CLDClosure* cl);
 70   static void cld_unloading_do(CLDClosure* cl);
 71   static void roots_cld_do(CLDClosure* strong, CLDClosure* weak);
 72   static void always_strong_cld_do(CLDClosure* cl);
 73   // Iteration through CLDG not by GC.
 74   static void loaded_cld_do(CLDClosure* cl);
 75   // klass do
 76   // Walking classes through the ClassLoaderDataGraph include array classes.  It also includes
 77   // classes that are allocated but not loaded, classes that have errors, and scratch classes
 78   // for redefinition.  These classes are removed during the next class unloading.
 79   // Walking the ClassLoaderDataGraph also includes hidden and unsafe anonymous classes.
 80   static void classes_do(KlassClosure* klass_closure);
 81   static void classes_do(void f(Klass* const));
 82   static void methods_do(void f(Method*));
 83   static void modules_do(void f(ModuleEntry*));
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderStats.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
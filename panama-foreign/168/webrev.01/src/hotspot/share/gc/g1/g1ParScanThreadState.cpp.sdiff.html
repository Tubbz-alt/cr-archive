<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 29 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 31 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 32 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 33 #include &quot;gc/g1/g1Trace.hpp&quot;
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/prefetch.inline.hpp&quot;
 39 
 40 G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,
 41                                            G1RedirtyCardsQueueSet* rdcqs,
 42                                            uint worker_id,
 43                                            size_t young_cset_length,
 44                                            size_t optional_cset_length)
 45   : _g1h(g1h),
<span class="line-modified"> 46     _refs(g1h-&gt;task_queue(worker_id)),</span>
 47     _rdcq(rdcqs),
 48     _ct(g1h-&gt;card_table()),
 49     _closures(NULL),
 50     _plab_allocator(NULL),
 51     _age_table(false),
 52     _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
 53     _scanner(g1h, this),
 54     _worker_id(worker_id),
 55     _last_enqueued_card(SIZE_MAX),
 56     _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
 57     _stack_trim_lower_threshold(GCDrainStackTargetSize),
 58     _trim_ticks(),
 59     _surviving_young_words_base(NULL),
 60     _surviving_young_words(NULL),
 61     _surviving_words_length(young_cset_length + 1),
 62     _old_gen_is_full(false),
 63     _num_optional_regions(optional_cset_length),
 64     _numa(g1h-&gt;numa()),
 65     _obj_alloc_stat(NULL)
 66 {
</pre>
<hr />
<pre>
102   return sum;
103 }
104 
105 G1ParScanThreadState::~G1ParScanThreadState() {
106   delete _plab_allocator;
107   delete _closures;
108   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
109   delete[] _oops_into_optional_regions;
110   FREE_C_HEAP_ARRAY(size_t, _obj_alloc_stat);
111 }
112 
113 size_t G1ParScanThreadState::lab_waste_words() const {
114   return _plab_allocator-&gt;waste();
115 }
116 
117 size_t G1ParScanThreadState::lab_undo_waste_words() const {
118   return _plab_allocator-&gt;undo_waste();
119 }
120 
121 #ifdef ASSERT
<span class="line-modified">122 bool G1ParScanThreadState::verify_ref(narrowOop* ref) const {</span>
<span class="line-modified">123   assert(ref != NULL, &quot;invariant&quot;);</span>
124   assert(UseCompressedOops, &quot;sanity&quot;);
<span class="line-modified">125   assert(!has_partial_array_mask(ref), &quot;ref=&quot; PTR_FORMAT, p2i(ref));</span>
<span class="line-removed">126   oop p = RawAccess&lt;&gt;::oop_load(ref);</span>
127   assert(_g1h-&gt;is_in_g1_reserved(p),
<span class="line-modified">128          &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-removed">129   return true;</span>
130 }
131 
<span class="line-modified">132 bool G1ParScanThreadState::verify_ref(oop* ref) const {</span>
<span class="line-modified">133   assert(ref != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">134   if (has_partial_array_mask(ref)) {</span>
<span class="line-modified">135     // Must be in the collection set--it&#39;s already been copied.</span>
<span class="line-modified">136     oop p = clear_partial_array_mask(ref);</span>
<span class="line-modified">137     assert(_g1h-&gt;is_in_cset(p),</span>
<span class="line-modified">138            &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-modified">139   } else {</span>
<span class="line-modified">140     oop p = RawAccess&lt;&gt;::oop_load(ref);</span>
<span class="line-modified">141     assert(_g1h-&gt;is_in_g1_reserved(p),</span>
<span class="line-modified">142            &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-removed">143   }</span>
<span class="line-removed">144   return true;</span>
145 }
146 
<span class="line-modified">147 bool G1ParScanThreadState::verify_task(StarTask ref) const {</span>
<span class="line-modified">148   if (ref.is_narrow()) {</span>
<span class="line-modified">149     return verify_ref((narrowOop*) ref);</span>




150   } else {
<span class="line-modified">151     return verify_ref((oop*) ref);</span>
152   }
153 }
154 #endif // ASSERT
155 
156 void G1ParScanThreadState::trim_queue() {
<span class="line-removed">157   StarTask ref;</span>
158   do {
159     // Fully drain the queue.
160     trim_queue_to_threshold(0);
<span class="line-modified">161   } while (!_refs-&gt;is_empty());</span>
162 }
163 
164 HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,
165                                                       size_t word_sz,
166                                                       bool previous_plab_refill_failed,
167                                                       uint node_index) {
168 
169   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: %s region attr&quot;, dest-&gt;get_type_str());
170 
171   // Right now we only have two types of regions (young / old) so
172   // let&#39;s keep the logic here simple. We can generalize it when necessary.
173   if (dest-&gt;is_young()) {
174     bool plab_refill_in_old_failed = false;
175     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(G1HeapRegionAttr::Old,
176                                                         word_sz,
177                                                         &amp;plab_refill_in_old_failed,
178                                                         node_index);
179     // Make sure that we won&#39;t attempt to copy any other objects out
180     // of a survivor region (given that apparently we cannot allocate
181     // any new ones) to avoid coming into this slow path again and again.
</pre>
<hr />
<pre>
313     if (G1StringDedup::is_enabled()) {
314       const bool is_from_young = region_attr.is_young();
315       const bool is_to_young = dest_attr.is_young();
316       assert(is_from_young == from_region-&gt;is_young(),
317              &quot;sanity&quot;);
318       assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
319              &quot;sanity&quot;);
320       G1StringDedup::enqueue_from_evacuation(is_from_young,
321                                              is_to_young,
322                                              _worker_id,
323                                              obj);
324     }
325 
326     _surviving_young_words[young_index] += word_sz;
327 
328     if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
329       // We keep track of the next start index in the length field of
330       // the to-space object. The actual length can be found in the
331       // length field of the from-space object.
332       arrayOop(obj)-&gt;set_length(0);
<span class="line-modified">333       oop* old_p = set_partial_array_mask(old);</span>
<span class="line-removed">334       do_oop_partial_array(old_p);</span>
335     } else {
336       G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());
337       obj-&gt;oop_iterate_backwards(&amp;_scanner);
338     }
339     return obj;
340   } else {
341     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);
342     return forward_ptr;
343   }
344 }
345 
346 G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
347   assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
348   if (_states[worker_id] == NULL) {
349     _states[worker_id] =
350       new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);
351   }
352   return _states[worker_id];
353 }
354 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 26 #include &quot;gc/g1/g1Allocator.inline.hpp&quot;
 27 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
 28 #include &quot;gc/g1/g1CollectionSet.hpp&quot;
 29 #include &quot;gc/g1/g1OopClosures.inline.hpp&quot;
 30 #include &quot;gc/g1/g1ParScanThreadState.inline.hpp&quot;
 31 #include &quot;gc/g1/g1RootClosures.hpp&quot;
 32 #include &quot;gc/g1/g1StringDedup.hpp&quot;
 33 #include &quot;gc/g1/g1Trace.hpp&quot;
 34 #include &quot;gc/shared/taskqueue.inline.hpp&quot;
 35 #include &quot;memory/allocation.inline.hpp&quot;
 36 #include &quot;oops/access.inline.hpp&quot;
 37 #include &quot;oops/oop.inline.hpp&quot;
 38 #include &quot;runtime/prefetch.inline.hpp&quot;
 39 
 40 G1ParScanThreadState::G1ParScanThreadState(G1CollectedHeap* g1h,
 41                                            G1RedirtyCardsQueueSet* rdcqs,
 42                                            uint worker_id,
 43                                            size_t young_cset_length,
 44                                            size_t optional_cset_length)
 45   : _g1h(g1h),
<span class="line-modified"> 46     _task_queue(g1h-&gt;task_queue(worker_id)),</span>
 47     _rdcq(rdcqs),
 48     _ct(g1h-&gt;card_table()),
 49     _closures(NULL),
 50     _plab_allocator(NULL),
 51     _age_table(false),
 52     _tenuring_threshold(g1h-&gt;policy()-&gt;tenuring_threshold()),
 53     _scanner(g1h, this),
 54     _worker_id(worker_id),
 55     _last_enqueued_card(SIZE_MAX),
 56     _stack_trim_upper_threshold(GCDrainStackTargetSize * 2 + 1),
 57     _stack_trim_lower_threshold(GCDrainStackTargetSize),
 58     _trim_ticks(),
 59     _surviving_young_words_base(NULL),
 60     _surviving_young_words(NULL),
 61     _surviving_words_length(young_cset_length + 1),
 62     _old_gen_is_full(false),
 63     _num_optional_regions(optional_cset_length),
 64     _numa(g1h-&gt;numa()),
 65     _obj_alloc_stat(NULL)
 66 {
</pre>
<hr />
<pre>
102   return sum;
103 }
104 
105 G1ParScanThreadState::~G1ParScanThreadState() {
106   delete _plab_allocator;
107   delete _closures;
108   FREE_C_HEAP_ARRAY(size_t, _surviving_young_words_base);
109   delete[] _oops_into_optional_regions;
110   FREE_C_HEAP_ARRAY(size_t, _obj_alloc_stat);
111 }
112 
113 size_t G1ParScanThreadState::lab_waste_words() const {
114   return _plab_allocator-&gt;waste();
115 }
116 
117 size_t G1ParScanThreadState::lab_undo_waste_words() const {
118   return _plab_allocator-&gt;undo_waste();
119 }
120 
121 #ifdef ASSERT
<span class="line-modified">122 void G1ParScanThreadState::verify_task(narrowOop* task) const {</span>
<span class="line-modified">123   assert(task != NULL, &quot;invariant&quot;);</span>
124   assert(UseCompressedOops, &quot;sanity&quot;);
<span class="line-modified">125   oop p = RawAccess&lt;&gt;::oop_load(task);</span>

126   assert(_g1h-&gt;is_in_g1_reserved(p),
<span class="line-modified">127          &quot;task=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(task), p2i(p));</span>

128 }
129 
<span class="line-modified">130 void G1ParScanThreadState::verify_task(oop* task) const {</span>
<span class="line-modified">131   assert(task != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">132   oop p = RawAccess&lt;&gt;::oop_load(task);</span>
<span class="line-modified">133   assert(_g1h-&gt;is_in_g1_reserved(p),</span>
<span class="line-modified">134          &quot;task=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(task), p2i(p));</span>
<span class="line-modified">135 }</span>
<span class="line-modified">136 </span>
<span class="line-modified">137 void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {</span>
<span class="line-modified">138   // Must be in the collection set--it&#39;s already been copied.</span>
<span class="line-modified">139   oop p = task.to_source_array();</span>
<span class="line-modified">140   assert(_g1h-&gt;is_in_cset(p), &quot;p=&quot; PTR_FORMAT, p2i(p));</span>


141 }
142 
<span class="line-modified">143 void G1ParScanThreadState::verify_task(ScannerTask task) const {</span>
<span class="line-modified">144   if (task.is_narrow_oop_ptr()) {</span>
<span class="line-modified">145     verify_task(task.to_narrow_oop_ptr());</span>
<span class="line-added">146   } else if (task.is_oop_ptr()) {</span>
<span class="line-added">147     verify_task(task.to_oop_ptr());</span>
<span class="line-added">148   } else if (task.is_partial_array_task()) {</span>
<span class="line-added">149     verify_task(task.to_partial_array_task());</span>
150   } else {
<span class="line-modified">151     ShouldNotReachHere();</span>
152   }
153 }
154 #endif // ASSERT
155 
156 void G1ParScanThreadState::trim_queue() {

157   do {
158     // Fully drain the queue.
159     trim_queue_to_threshold(0);
<span class="line-modified">160   } while (!_task_queue-&gt;is_empty());</span>
161 }
162 
163 HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,
164                                                       size_t word_sz,
165                                                       bool previous_plab_refill_failed,
166                                                       uint node_index) {
167 
168   assert(dest-&gt;is_in_cset_or_humongous(), &quot;Unexpected dest: %s region attr&quot;, dest-&gt;get_type_str());
169 
170   // Right now we only have two types of regions (young / old) so
171   // let&#39;s keep the logic here simple. We can generalize it when necessary.
172   if (dest-&gt;is_young()) {
173     bool plab_refill_in_old_failed = false;
174     HeapWord* const obj_ptr = _plab_allocator-&gt;allocate(G1HeapRegionAttr::Old,
175                                                         word_sz,
176                                                         &amp;plab_refill_in_old_failed,
177                                                         node_index);
178     // Make sure that we won&#39;t attempt to copy any other objects out
179     // of a survivor region (given that apparently we cannot allocate
180     // any new ones) to avoid coming into this slow path again and again.
</pre>
<hr />
<pre>
312     if (G1StringDedup::is_enabled()) {
313       const bool is_from_young = region_attr.is_young();
314       const bool is_to_young = dest_attr.is_young();
315       assert(is_from_young == from_region-&gt;is_young(),
316              &quot;sanity&quot;);
317       assert(is_to_young == _g1h-&gt;heap_region_containing(obj)-&gt;is_young(),
318              &quot;sanity&quot;);
319       G1StringDedup::enqueue_from_evacuation(is_from_young,
320                                              is_to_young,
321                                              _worker_id,
322                                              obj);
323     }
324 
325     _surviving_young_words[young_index] += word_sz;
326 
327     if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
328       // We keep track of the next start index in the length field of
329       // the to-space object. The actual length can be found in the
330       // length field of the from-space object.
331       arrayOop(obj)-&gt;set_length(0);
<span class="line-modified">332       do_partial_array(PartialArrayScanTask(old));</span>

333     } else {
334       G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());
335       obj-&gt;oop_iterate_backwards(&amp;_scanner);
336     }
337     return obj;
338   } else {
339     _plab_allocator-&gt;undo_allocation(dest_attr, obj_ptr, word_sz, node_index);
340     return forward_ptr;
341   }
342 }
343 
344 G1ParScanThreadState* G1ParScanThreadStateSet::state_for_worker(uint worker_id) {
345   assert(worker_id &lt; _n_workers, &quot;out of bounds access&quot;);
346   if (_states[worker_id] == NULL) {
347     _states[worker_id] =
348       new G1ParScanThreadState(_g1h, _rdcqs, worker_id, _young_cset_length, _optional_cset_length);
349   }
350   return _states[worker_id];
351 }
352 
</pre>
</td>
</tr>
</table>
<center><a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
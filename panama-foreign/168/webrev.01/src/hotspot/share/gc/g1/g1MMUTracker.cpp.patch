diff a/src/hotspot/share/gc/g1/g1MMUTracker.cpp b/src/hotspot/share/gc/g1/g1MMUTracker.cpp
--- a/src/hotspot/share/gc/g1/g1MMUTracker.cpp
+++ b/src/hotspot/share/gc/g1/g1MMUTracker.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -105,12 +105,16 @@
 
   // Current entry needs to be added before calculating the value
   double slice_time = calculate_gc_time(end);
   G1MMUTracer::report_mmu(_time_slice, slice_time, _max_gc_time);
 
-  if (slice_time >= _max_gc_time) {
-    log_info(gc, mmu)("MMU target violated: %.1lfms (%.1lfms/%.1lfms)", slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);
+  if (slice_time < _max_gc_time) {
+    log_debug(gc, mmu)("MMU: %.1lfms (%.1lfms/%.1lfms)",
+                       slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);
+  } else {
+    log_info(gc, mmu)("MMU target violated: %.1lfms (%.1lfms/%.1lfms)",
+                      slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);
   }
 }
 
 double G1MMUTrackerQueue::when_sec(double current_time, double pause_time) {
   // if the pause is over the maximum, just assume that it's the maximum

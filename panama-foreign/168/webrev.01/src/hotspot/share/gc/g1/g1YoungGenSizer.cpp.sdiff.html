<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1YoungGenSizer.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1RootProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1YoungGenSizer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 85 void G1YoungGenSizer::recalculate_min_max_young_length(uint number_of_heap_regions, uint* min_young_length, uint* max_young_length) {
 86   assert(number_of_heap_regions &gt; 0, &quot;Heap must be initialized&quot;);
 87 
 88   switch (_sizer_kind) {
 89     case SizerDefaults:
 90       *min_young_length = calculate_default_min_length(number_of_heap_regions);
 91       *max_young_length = calculate_default_max_length(number_of_heap_regions);
 92       break;
 93     case SizerNewSizeOnly:
 94       *max_young_length = calculate_default_max_length(number_of_heap_regions);
 95       *max_young_length = MAX2(*min_young_length, *max_young_length);
 96       break;
 97     case SizerMaxNewSizeOnly:
 98       *min_young_length = calculate_default_min_length(number_of_heap_regions);
 99       *min_young_length = MIN2(*min_young_length, *max_young_length);
100       break;
101     case SizerMaxAndNewSize:
102       // Do nothing. Values set on the command line, don&#39;t update them at runtime.
103       break;
104     case SizerNewRatio:
<span class="line-modified">105       *min_young_length = number_of_heap_regions / (NewRatio + 1);</span>
106       *max_young_length = *min_young_length;
107       break;
108     default:
109       ShouldNotReachHere();
110   }
111 
112   assert(*min_young_length &lt;= *max_young_length, &quot;Invalid min/max young gen size values&quot;);
113 }
114 
115 void G1YoungGenSizer::adjust_max_new_size(uint number_of_heap_regions) {
116 
117   // We need to pass the desired values because recalculation may not update these
118   // values in some cases.
119   uint temp = _min_desired_young_length;
120   uint result = _max_desired_young_length;
121   recalculate_min_max_young_length(number_of_heap_regions, &amp;temp, &amp;result);
122 
123   size_t max_young_size = result * HeapRegion::GrainBytes;
124   if (max_young_size != MaxNewSize) {
125     FLAG_SET_ERGO(MaxNewSize, max_young_size);
</pre>
</td>
<td>
<hr />
<pre>
 85 void G1YoungGenSizer::recalculate_min_max_young_length(uint number_of_heap_regions, uint* min_young_length, uint* max_young_length) {
 86   assert(number_of_heap_regions &gt; 0, &quot;Heap must be initialized&quot;);
 87 
 88   switch (_sizer_kind) {
 89     case SizerDefaults:
 90       *min_young_length = calculate_default_min_length(number_of_heap_regions);
 91       *max_young_length = calculate_default_max_length(number_of_heap_regions);
 92       break;
 93     case SizerNewSizeOnly:
 94       *max_young_length = calculate_default_max_length(number_of_heap_regions);
 95       *max_young_length = MAX2(*min_young_length, *max_young_length);
 96       break;
 97     case SizerMaxNewSizeOnly:
 98       *min_young_length = calculate_default_min_length(number_of_heap_regions);
 99       *min_young_length = MIN2(*min_young_length, *max_young_length);
100       break;
101     case SizerMaxAndNewSize:
102       // Do nothing. Values set on the command line, don&#39;t update them at runtime.
103       break;
104     case SizerNewRatio:
<span class="line-modified">105       *min_young_length = MAX2((uint)(number_of_heap_regions / (NewRatio + 1)), 1u);</span>
106       *max_young_length = *min_young_length;
107       break;
108     default:
109       ShouldNotReachHere();
110   }
111 
112   assert(*min_young_length &lt;= *max_young_length, &quot;Invalid min/max young gen size values&quot;);
113 }
114 
115 void G1YoungGenSizer::adjust_max_new_size(uint number_of_heap_regions) {
116 
117   // We need to pass the desired values because recalculation may not update these
118   // values in some cases.
119   uint temp = _min_desired_young_length;
120   uint result = _max_desired_young_length;
121   recalculate_min_max_young_length(number_of_heap_regions, &amp;temp, &amp;result);
122 
123   size_t max_young_size = result * HeapRegion::GrainBytes;
124   if (max_young_size != MaxNewSize) {
125     FLAG_SET_ERGO(MaxNewSize, max_young_size);
</pre>
</td>
</tr>
</table>
<center><a href="g1RootProcessor.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="heapRegionManager.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
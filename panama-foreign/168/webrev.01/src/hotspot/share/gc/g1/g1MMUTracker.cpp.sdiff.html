<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/g1/g1MMUTracker.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1MMUTracker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 90     //     (this might allow less GC time than what&#39;s allowed)
 91 
 92     // In the case where ScavengeALot is true, such overflow is not
 93     // uncommon; in such cases, we can, without much loss of precision
 94     // or performance (we are GC&#39;ing most of the time anyway!),
 95     // simply overwrite the oldest entry in the tracker.
 96 
 97     _head_index = trim_index(_head_index + 1);
 98     assert(_head_index == _tail_index, &quot;Because we have a full circular buffer&quot;);
 99     _tail_index = trim_index(_tail_index + 1);
100   } else {
101     _head_index = trim_index(_head_index + 1);
102     ++_no_entries;
103   }
104   _array[_head_index] = G1MMUTrackerQueueElem(start, end);
105 
106   // Current entry needs to be added before calculating the value
107   double slice_time = calculate_gc_time(end);
108   G1MMUTracer::report_mmu(_time_slice, slice_time, _max_gc_time);
109 
<span class="line-modified">110   if (slice_time &gt;= _max_gc_time) {</span>
<span class="line-modified">111     log_info(gc, mmu)(&quot;MMU target violated: %.1lfms (%.1lfms/%.1lfms)&quot;, slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);</span>




112   }
113 }
114 
115 double G1MMUTrackerQueue::when_sec(double current_time, double pause_time) {
116   // if the pause is over the maximum, just assume that it&#39;s the maximum
117   double adjusted_pause_time =
118     (pause_time &gt; max_gc_time()) ? max_gc_time() : pause_time;
119   double earliest_end = current_time + adjusted_pause_time;
120   double limit = earliest_end - _time_slice;
121   double gc_time = calculate_gc_time(earliest_end);
122   double diff = gc_time + adjusted_pause_time - max_gc_time();
123   if (is_double_leq_0(diff))
124     return 0.0;
125 
126   int index = _tail_index;
127   while ( 1 ) {
128     G1MMUTrackerQueueElem *elem = &amp;_array[index];
129     if (elem-&gt;end_time() &gt; limit) {
130       if (elem-&gt;start_time() &gt; limit)
131         diff -= elem-&gt;duration();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 90     //     (this might allow less GC time than what&#39;s allowed)
 91 
 92     // In the case where ScavengeALot is true, such overflow is not
 93     // uncommon; in such cases, we can, without much loss of precision
 94     // or performance (we are GC&#39;ing most of the time anyway!),
 95     // simply overwrite the oldest entry in the tracker.
 96 
 97     _head_index = trim_index(_head_index + 1);
 98     assert(_head_index == _tail_index, &quot;Because we have a full circular buffer&quot;);
 99     _tail_index = trim_index(_tail_index + 1);
100   } else {
101     _head_index = trim_index(_head_index + 1);
102     ++_no_entries;
103   }
104   _array[_head_index] = G1MMUTrackerQueueElem(start, end);
105 
106   // Current entry needs to be added before calculating the value
107   double slice_time = calculate_gc_time(end);
108   G1MMUTracer::report_mmu(_time_slice, slice_time, _max_gc_time);
109 
<span class="line-modified">110   if (slice_time &lt; _max_gc_time) {</span>
<span class="line-modified">111     log_debug(gc, mmu)(&quot;MMU: %.1lfms (%.1lfms/%.1lfms)&quot;,</span>
<span class="line-added">112                        slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);</span>
<span class="line-added">113   } else {</span>
<span class="line-added">114     log_info(gc, mmu)(&quot;MMU target violated: %.1lfms (%.1lfms/%.1lfms)&quot;,</span>
<span class="line-added">115                       slice_time * 1000.0, _max_gc_time * 1000.0, _time_slice * 1000);</span>
116   }
117 }
118 
119 double G1MMUTrackerQueue::when_sec(double current_time, double pause_time) {
120   // if the pause is over the maximum, just assume that it&#39;s the maximum
121   double adjusted_pause_time =
122     (pause_time &gt; max_gc_time()) ? max_gc_time() : pause_time;
123   double earliest_end = current_time + adjusted_pause_time;
124   double limit = earliest_end - _time_slice;
125   double gc_time = calculate_gc_time(earliest_end);
126   double diff = gc_time + adjusted_pause_time - max_gc_time();
127   if (is_double_leq_0(diff))
128     return 0.0;
129 
130   int index = _tail_index;
131   while ( 1 ) {
132     G1MMUTrackerQueueElem *elem = &amp;_array[index];
133     if (elem-&gt;end_time() &gt; limit) {
134       if (elem-&gt;start_time() &gt; limit)
135         diff -= elem-&gt;duration();
</pre>
</td>
</tr>
</table>
<center><a href="g1GCPhaseTimes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1OopClosures.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
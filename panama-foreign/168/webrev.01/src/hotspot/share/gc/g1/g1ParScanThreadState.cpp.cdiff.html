<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="g1OopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/g1/g1ParScanThreadState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,11 ***</span>
                                             G1RedirtyCardsQueueSet* rdcqs,
                                             uint worker_id,
                                             size_t young_cset_length,
                                             size_t optional_cset_length)
    : _g1h(g1h),
<span class="line-modified">!     _refs(g1h-&gt;task_queue(worker_id)),</span>
      _rdcq(rdcqs),
      _ct(g1h-&gt;card_table()),
      _closures(NULL),
      _plab_allocator(NULL),
      _age_table(false),
<span class="line-new-header">--- 41,11 ---</span>
                                             G1RedirtyCardsQueueSet* rdcqs,
                                             uint worker_id,
                                             size_t young_cset_length,
                                             size_t optional_cset_length)
    : _g1h(g1h),
<span class="line-modified">!     _task_queue(g1h-&gt;task_queue(worker_id)),</span>
      _rdcq(rdcqs),
      _ct(g1h-&gt;card_table()),
      _closures(NULL),
      _plab_allocator(NULL),
      _age_table(false),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,50 ***</span>
  size_t G1ParScanThreadState::lab_undo_waste_words() const {
    return _plab_allocator-&gt;undo_waste();
  }
  
  #ifdef ASSERT
<span class="line-modified">! bool G1ParScanThreadState::verify_ref(narrowOop* ref) const {</span>
<span class="line-modified">!   assert(ref != NULL, &quot;invariant&quot;);</span>
    assert(UseCompressedOops, &quot;sanity&quot;);
<span class="line-modified">!   assert(!has_partial_array_mask(ref), &quot;ref=&quot; PTR_FORMAT, p2i(ref));</span>
<span class="line-removed">-   oop p = RawAccess&lt;&gt;::oop_load(ref);</span>
    assert(_g1h-&gt;is_in_g1_reserved(p),
<span class="line-modified">!          &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! bool G1ParScanThreadState::verify_ref(oop* ref) const {</span>
<span class="line-modified">!   assert(ref != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   if (has_partial_array_mask(ref)) {</span>
<span class="line-modified">!     // Must be in the collection set--it&#39;s already been copied.</span>
<span class="line-modified">!     oop p = clear_partial_array_mask(ref);</span>
<span class="line-modified">!     assert(_g1h-&gt;is_in_cset(p),</span>
<span class="line-modified">!            &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     oop p = RawAccess&lt;&gt;::oop_load(ref);</span>
<span class="line-modified">!     assert(_g1h-&gt;is_in_g1_reserved(p),</span>
<span class="line-modified">!            &quot;ref=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(ref), p2i(p));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return true;</span>
  }
  
<span class="line-modified">! bool G1ParScanThreadState::verify_task(StarTask ref) const {</span>
<span class="line-modified">!   if (ref.is_narrow()) {</span>
<span class="line-modified">!     return verify_ref((narrowOop*) ref);</span>
    } else {
<span class="line-modified">!     return verify_ref((oop*) ref);</span>
    }
  }
  #endif // ASSERT
  
  void G1ParScanThreadState::trim_queue() {
<span class="line-removed">-   StarTask ref;</span>
    do {
      // Fully drain the queue.
      trim_queue_to_threshold(0);
<span class="line-modified">!   } while (!_refs-&gt;is_empty());</span>
  }
  
  HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,
                                                        size_t word_sz,
                                                        bool previous_plab_refill_failed,
<span class="line-new-header">--- 117,49 ---</span>
  size_t G1ParScanThreadState::lab_undo_waste_words() const {
    return _plab_allocator-&gt;undo_waste();
  }
  
  #ifdef ASSERT
<span class="line-modified">! void G1ParScanThreadState::verify_task(narrowOop* task) const {</span>
<span class="line-modified">!   assert(task != NULL, &quot;invariant&quot;);</span>
    assert(UseCompressedOops, &quot;sanity&quot;);
<span class="line-modified">!   oop p = RawAccess&lt;&gt;::oop_load(task);</span>
    assert(_g1h-&gt;is_in_g1_reserved(p),
<span class="line-modified">!          &quot;task=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(task), p2i(p));</span>
  }
  
<span class="line-modified">! void G1ParScanThreadState::verify_task(oop* task) const {</span>
<span class="line-modified">!   assert(task != NULL, &quot;invariant&quot;);</span>
<span class="line-modified">!   oop p = RawAccess&lt;&gt;::oop_load(task);</span>
<span class="line-modified">!   assert(_g1h-&gt;is_in_g1_reserved(p),</span>
<span class="line-modified">!          &quot;task=&quot; PTR_FORMAT &quot; p=&quot; PTR_FORMAT, p2i(task), p2i(p));</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {</span>
<span class="line-modified">!   // Must be in the collection set--it&#39;s already been copied.</span>
<span class="line-modified">!   oop p = task.to_source_array();</span>
<span class="line-modified">!   assert(_g1h-&gt;is_in_cset(p), &quot;p=&quot; PTR_FORMAT, p2i(p));</span>
  }
  
<span class="line-modified">! void G1ParScanThreadState::verify_task(ScannerTask task) const {</span>
<span class="line-modified">!   if (task.is_narrow_oop_ptr()) {</span>
<span class="line-modified">!     verify_task(task.to_narrow_oop_ptr());</span>
<span class="line-added">+   } else if (task.is_oop_ptr()) {</span>
<span class="line-added">+     verify_task(task.to_oop_ptr());</span>
<span class="line-added">+   } else if (task.is_partial_array_task()) {</span>
<span class="line-added">+     verify_task(task.to_partial_array_task());</span>
    } else {
<span class="line-modified">!     ShouldNotReachHere();</span>
    }
  }
  #endif // ASSERT
  
  void G1ParScanThreadState::trim_queue() {
    do {
      // Fully drain the queue.
      trim_queue_to_threshold(0);
<span class="line-modified">!   } while (!_task_queue-&gt;is_empty());</span>
  }
  
  HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,
                                                        size_t word_sz,
                                                        bool previous_plab_refill_failed,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,12 ***</span>
      if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
        // We keep track of the next start index in the length field of
        // the to-space object. The actual length can be found in the
        // length field of the from-space object.
        arrayOop(obj)-&gt;set_length(0);
<span class="line-modified">!       oop* old_p = set_partial_array_mask(old);</span>
<span class="line-removed">-       do_oop_partial_array(old_p);</span>
      } else {
        G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());
        obj-&gt;oop_iterate_backwards(&amp;_scanner);
      }
      return obj;
<span class="line-new-header">--- 327,11 ---</span>
      if (obj-&gt;is_objArray() &amp;&amp; arrayOop(obj)-&gt;length() &gt;= ParGCArrayScanChunk) {
        // We keep track of the next start index in the length field of
        // the to-space object. The actual length can be found in the
        // length field of the from-space object.
        arrayOop(obj)-&gt;set_length(0);
<span class="line-modified">!       do_partial_array(PartialArrayScanTask(old));</span>
      } else {
        G1ScanInYoungSetter x(&amp;_scanner, dest_attr.is_young());
        obj-&gt;oop_iterate_backwards(&amp;_scanner);
      }
      return obj;
</pre>
<center><a href="g1OopClosures.inline.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="g1ParScanThreadState.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp b/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp
--- a/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp
+++ b/src/hotspot/share/gc/g1/g1ParScanThreadState.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -41,11 +41,11 @@
                                            G1RedirtyCardsQueueSet* rdcqs,
                                            uint worker_id,
                                            size_t young_cset_length,
                                            size_t optional_cset_length)
   : _g1h(g1h),
-    _refs(g1h->task_queue(worker_id)),
+    _task_queue(g1h->task_queue(worker_id)),
     _rdcq(rdcqs),
     _ct(g1h->card_table()),
     _closures(NULL),
     _plab_allocator(NULL),
     _age_table(false),
@@ -117,50 +117,49 @@
 size_t G1ParScanThreadState::lab_undo_waste_words() const {
   return _plab_allocator->undo_waste();
 }
 
 #ifdef ASSERT
-bool G1ParScanThreadState::verify_ref(narrowOop* ref) const {
-  assert(ref != NULL, "invariant");
+void G1ParScanThreadState::verify_task(narrowOop* task) const {
+  assert(task != NULL, "invariant");
   assert(UseCompressedOops, "sanity");
-  assert(!has_partial_array_mask(ref), "ref=" PTR_FORMAT, p2i(ref));
-  oop p = RawAccess<>::oop_load(ref);
+  oop p = RawAccess<>::oop_load(task);
   assert(_g1h->is_in_g1_reserved(p),
-         "ref=" PTR_FORMAT " p=" PTR_FORMAT, p2i(ref), p2i(p));
-  return true;
+         "task=" PTR_FORMAT " p=" PTR_FORMAT, p2i(task), p2i(p));
 }
 
-bool G1ParScanThreadState::verify_ref(oop* ref) const {
-  assert(ref != NULL, "invariant");
-  if (has_partial_array_mask(ref)) {
-    // Must be in the collection set--it's already been copied.
-    oop p = clear_partial_array_mask(ref);
-    assert(_g1h->is_in_cset(p),
-           "ref=" PTR_FORMAT " p=" PTR_FORMAT, p2i(ref), p2i(p));
-  } else {
-    oop p = RawAccess<>::oop_load(ref);
-    assert(_g1h->is_in_g1_reserved(p),
-           "ref=" PTR_FORMAT " p=" PTR_FORMAT, p2i(ref), p2i(p));
-  }
-  return true;
+void G1ParScanThreadState::verify_task(oop* task) const {
+  assert(task != NULL, "invariant");
+  oop p = RawAccess<>::oop_load(task);
+  assert(_g1h->is_in_g1_reserved(p),
+         "task=" PTR_FORMAT " p=" PTR_FORMAT, p2i(task), p2i(p));
+}
+
+void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {
+  // Must be in the collection set--it's already been copied.
+  oop p = task.to_source_array();
+  assert(_g1h->is_in_cset(p), "p=" PTR_FORMAT, p2i(p));
 }
 
-bool G1ParScanThreadState::verify_task(StarTask ref) const {
-  if (ref.is_narrow()) {
-    return verify_ref((narrowOop*) ref);
+void G1ParScanThreadState::verify_task(ScannerTask task) const {
+  if (task.is_narrow_oop_ptr()) {
+    verify_task(task.to_narrow_oop_ptr());
+  } else if (task.is_oop_ptr()) {
+    verify_task(task.to_oop_ptr());
+  } else if (task.is_partial_array_task()) {
+    verify_task(task.to_partial_array_task());
   } else {
-    return verify_ref((oop*) ref);
+    ShouldNotReachHere();
   }
 }
 #endif // ASSERT
 
 void G1ParScanThreadState::trim_queue() {
-  StarTask ref;
   do {
     // Fully drain the queue.
     trim_queue_to_threshold(0);
-  } while (!_refs->is_empty());
+  } while (!_task_queue->is_empty());
 }
 
 HeapWord* G1ParScanThreadState::allocate_in_next_plab(G1HeapRegionAttr* dest,
                                                       size_t word_sz,
                                                       bool previous_plab_refill_failed,
@@ -328,12 +327,11 @@
     if (obj->is_objArray() && arrayOop(obj)->length() >= ParGCArrayScanChunk) {
       // We keep track of the next start index in the length field of
       // the to-space object. The actual length can be found in the
       // length field of the from-space object.
       arrayOop(obj)->set_length(0);
-      oop* old_p = set_partial_array_mask(old);
-      do_oop_partial_array(old_p);
+      do_partial_array(PartialArrayScanTask(old));
     } else {
       G1ScanInYoungSetter x(&_scanner, dest_attr.is_young());
       obj->oop_iterate_backwards(&_scanner);
     }
     return obj;

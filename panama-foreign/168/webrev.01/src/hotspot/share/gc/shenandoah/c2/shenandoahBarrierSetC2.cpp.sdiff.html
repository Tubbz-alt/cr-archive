<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../shared/taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahBarrierSetC2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;
<span class="line-removed">  30 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;</span>
  31 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  33 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  34 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;

  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/idealKit.hpp&quot;
  39 #include &quot;opto/macro.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
  44 
  45 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  46   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  47 }
  48 
  49 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
  50   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),
  51     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {
  52 }
  53 
  54 int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {
</pre>
<hr />
<pre>
 464 
 465   // create result type (range)
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
<span class="line-modified"> 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(const Type* value_type) {</span>
 485   const Type **fields = TypeTuple::fields(2);
<span class="line-modified"> 486   fields[TypeFunc::Parms+0] = value_type;           // original field value</span>
 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
<span class="line-modified"> 493   fields[TypeFunc::Parms+0] = value_type;</span>
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
</pre>
<hr />
<pre>
1042       }
1043     }
1044   }
1045 }
1046 #endif
1047 
1048 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1049   if (is_shenandoah_wb_pre_call(n)) {
1050     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1051     if (n-&gt;req() &gt; cnt) {
1052       Node* addp = n-&gt;in(cnt);
1053       if (has_only_shenandoah_wb_pre_uses(addp)) {
1054         n-&gt;del_req(cnt);
1055         if (can_reshape) {
1056           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1057         }
1058         return n;
1059       }
1060     }
1061   }
<span class="line-modified">1062   if (can_reshape &amp;&amp;</span>
<span class="line-modified">1063       n-&gt;Opcode() == Op_If &amp;&amp;</span>
<span class="line-modified">1064       ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;</span>
<span class="line-modified">1065       n-&gt;in(0) != NULL) {</span>



























1066     Node* dom = n-&gt;in(0);
1067     Node* prev_dom = n;
1068     int op = n-&gt;Opcode();
1069     int dist = 16;
1070     // Search up the dominator tree for another heap stable test
1071     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1072            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?
1073            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1074       if (dist &lt; 0) return NULL;
1075 
1076       dist--;
1077       prev_dom = dom;
1078       dom = IfNode::up_one_dom(dom);
1079       if (!dom) return NULL;
1080     }
1081 
1082     // Check that we did not follow a loop back to ourselves
1083     if (n == dom) {
1084       return NULL;
1085     }
</pre>
</td>
<td>
<hr />
<pre>
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
  28 #include &quot;gc/shenandoah/shenandoahForwarding.hpp&quot;
  29 #include &quot;gc/shenandoah/shenandoahHeap.hpp&quot;

  30 #include &quot;gc/shenandoah/shenandoahRuntime.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahThreadLocalData.hpp&quot;
  32 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  33 #include &quot;gc/shenandoah/c2/shenandoahSupport.hpp&quot;
<span class="line-added">  34 #include &quot;gc/shenandoah/heuristics/shenandoahHeuristics.hpp&quot;</span>
  35 #include &quot;opto/arraycopynode.hpp&quot;
  36 #include &quot;opto/escape.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
  38 #include &quot;opto/idealKit.hpp&quot;
  39 #include &quot;opto/macro.hpp&quot;
  40 #include &quot;opto/movenode.hpp&quot;
  41 #include &quot;opto/narrowptrnode.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
  44 
  45 ShenandoahBarrierSetC2* ShenandoahBarrierSetC2::bsc2() {
  46   return reinterpret_cast&lt;ShenandoahBarrierSetC2*&gt;(BarrierSet::barrier_set()-&gt;barrier_set_c2());
  47 }
  48 
  49 ShenandoahBarrierSetC2State::ShenandoahBarrierSetC2State(Arena* comp_arena)
  50   : _enqueue_barriers(new (comp_arena) GrowableArray&lt;ShenandoahEnqueueBarrierNode*&gt;(comp_arena, 8,  0, NULL)),
  51     _load_reference_barriers(new (comp_arena) GrowableArray&lt;ShenandoahLoadReferenceBarrierNode*&gt;(comp_arena, 8,  0, NULL)) {
  52 }
  53 
  54 int ShenandoahBarrierSetC2State::enqueue_barriers_count() const {
</pre>
<hr />
<pre>
 464 
 465   // create result type (range)
 466   fields = TypeTuple::fields(0);
 467   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 468 
 469   return TypeFunc::make(domain, range);
 470 }
 471 
 472 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_clone_barrier_Type() {
 473   const Type **fields = TypeTuple::fields(1);
 474   fields[TypeFunc::Parms+0] = TypeOopPtr::NOTNULL; // src oop
 475   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 476 
 477   // create result type (range)
 478   fields = TypeTuple::fields(0);
 479   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 480 
 481   return TypeFunc::make(domain, range);
 482 }
 483 
<span class="line-modified"> 484 const TypeFunc* ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type() {</span>
 485   const Type **fields = TypeTuple::fields(2);
<span class="line-modified"> 486   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // original field value</span>
 487   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // original load address
 488 
 489   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 490 
 491   // create result type (range)
 492   fields = TypeTuple::fields(1);
<span class="line-modified"> 493   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;</span>
 494   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 495 
 496   return TypeFunc::make(domain, range);
 497 }
 498 
 499 Node* ShenandoahBarrierSetC2::store_at_resolved(C2Access&amp; access, C2AccessValue&amp; val) const {
 500   DecoratorSet decorators = access.decorators();
 501 
 502   const TypePtr* adr_type = access.addr().type();
 503   Node* adr = access.addr().node();
 504 
 505   bool anonymous = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
 506   bool on_heap = (decorators &amp; IN_HEAP) != 0;
 507 
 508   if (!access.is_oop() || (!on_heap &amp;&amp; !anonymous)) {
 509     return BarrierSetC2::store_at_resolved(access, val);
 510   }
 511 
 512   if (access.is_parse_access()) {
 513     C2ParseAccess&amp; parse_access = static_cast&lt;C2ParseAccess&amp;&gt;(access);
</pre>
<hr />
<pre>
1042       }
1043     }
1044   }
1045 }
1046 #endif
1047 
1048 Node* ShenandoahBarrierSetC2::ideal_node(PhaseGVN* phase, Node* n, bool can_reshape) const {
1049   if (is_shenandoah_wb_pre_call(n)) {
1050     uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_entry_Type()-&gt;domain()-&gt;cnt();
1051     if (n-&gt;req() &gt; cnt) {
1052       Node* addp = n-&gt;in(cnt);
1053       if (has_only_shenandoah_wb_pre_uses(addp)) {
1054         n-&gt;del_req(cnt);
1055         if (can_reshape) {
1056           phase-&gt;is_IterGVN()-&gt;_worklist.push(addp);
1057         }
1058         return n;
1059       }
1060     }
1061   }
<span class="line-modified">1062   if (n-&gt;Opcode() == Op_CmpP) {</span>
<span class="line-modified">1063     Node* in1 = n-&gt;in(1);</span>
<span class="line-modified">1064     Node* in2 = n-&gt;in(2);</span>
<span class="line-modified">1065     if (in1-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">1066       in2 = step_over_gc_barrier(in2);</span>
<span class="line-added">1067     }</span>
<span class="line-added">1068     if (in2-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">1069       in1 = step_over_gc_barrier(in1);</span>
<span class="line-added">1070     }</span>
<span class="line-added">1071     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-added">1072     if (in1 != n-&gt;in(1)) {</span>
<span class="line-added">1073       if (igvn != NULL) {</span>
<span class="line-added">1074         n-&gt;set_req_X(1, in1, igvn);</span>
<span class="line-added">1075       } else {</span>
<span class="line-added">1076         n-&gt;set_req(1, in1);</span>
<span class="line-added">1077       }</span>
<span class="line-added">1078       assert(in2 == n-&gt;in(2), &quot;only one change&quot;);</span>
<span class="line-added">1079       return n;</span>
<span class="line-added">1080     }</span>
<span class="line-added">1081     if (in2 != n-&gt;in(2)) {</span>
<span class="line-added">1082       if (igvn != NULL) {</span>
<span class="line-added">1083         n-&gt;set_req_X(2, in2, igvn);</span>
<span class="line-added">1084       } else {</span>
<span class="line-added">1085         n-&gt;set_req(2, in2);</span>
<span class="line-added">1086       }</span>
<span class="line-added">1087       return n;</span>
<span class="line-added">1088     }</span>
<span class="line-added">1089   } else if (can_reshape &amp;&amp;</span>
<span class="line-added">1090              n-&gt;Opcode() == Op_If &amp;&amp;</span>
<span class="line-added">1091              ShenandoahBarrierC2Support::is_heap_stable_test(n) &amp;&amp;</span>
<span class="line-added">1092              n-&gt;in(0) != NULL) {</span>
1093     Node* dom = n-&gt;in(0);
1094     Node* prev_dom = n;
1095     int op = n-&gt;Opcode();
1096     int dist = 16;
1097     // Search up the dominator tree for another heap stable test
1098     while (dom-&gt;Opcode() != op    ||  // Not same opcode?
1099            !ShenandoahBarrierC2Support::is_heap_stable_test(dom) ||  // Not same input 1?
1100            prev_dom-&gt;in(0) != dom) {  // One path of test does not dominate?
1101       if (dist &lt; 0) return NULL;
1102 
1103       dist--;
1104       prev_dom = dom;
1105       dom = IfNode::up_one_dom(dom);
1106       if (!dom) return NULL;
1107     }
1108 
1109     // Check that we did not follow a loop back to ourselves
1110     if (n == dom) {
1111       return NULL;
1112     }
</pre>
</td>
</tr>
</table>
<center><a href="../../shared/taskqueue.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/c2/shenandoahSupport.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 862 
 863 void ShenandoahBarrierC2Support::test_gc_state(Node*&amp; ctrl, Node* raw_mem, Node*&amp; test_fail_ctrl,
 864                                                PhaseIdealLoop* phase, int flags) {
 865   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 866   Node* old_ctrl = ctrl;
 867 
 868   Node* thread          = new ThreadLocalNode();
 869   Node* gc_state_offset = igvn.MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 870   Node* gc_state_addr   = new AddPNode(phase-&gt;C-&gt;top(), thread, gc_state_offset);
 871   Node* gc_state        = new LoadBNode(old_ctrl, raw_mem, gc_state_addr,
 872                                         DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 873                                         TypeInt::BYTE, MemNode::unordered);
 874   Node* gc_state_and    = new AndINode(gc_state, igvn.intcon(flags));
 875   Node* gc_state_cmp    = new CmpINode(gc_state_and, igvn.zerocon(T_INT));
 876   Node* gc_state_bool   = new BoolNode(gc_state_cmp, BoolTest::ne);
 877 
 878   IfNode* gc_state_iff  = new IfNode(old_ctrl, gc_state_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 879   ctrl                  = new IfTrueNode(gc_state_iff);
 880   test_fail_ctrl        = new IfFalseNode(gc_state_iff);
 881 
<span class="line-modified"> 882   IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
 883   phase-&gt;register_control(gc_state_iff,   loop, old_ctrl);
 884   phase-&gt;register_control(ctrl,           loop, gc_state_iff);
 885   phase-&gt;register_control(test_fail_ctrl, loop, gc_state_iff);
 886 
 887   phase-&gt;register_new_node(thread,        old_ctrl);
 888   phase-&gt;register_new_node(gc_state_addr, old_ctrl);
 889   phase-&gt;register_new_node(gc_state,      old_ctrl);
 890   phase-&gt;register_new_node(gc_state_and,  old_ctrl);
 891   phase-&gt;register_new_node(gc_state_cmp,  old_ctrl);
 892   phase-&gt;register_new_node(gc_state_bool, old_ctrl);
 893 
 894   phase-&gt;set_ctrl(gc_state_offset, phase-&gt;C-&gt;root());
 895 
 896   assert(is_gc_state_test(gc_state_iff, flags), &quot;Should match the shape&quot;);
 897 }
 898 
 899 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {
 900   Node* old_ctrl = ctrl;
 901   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 902 
 903   const Type* val_t = igvn.type(val);
 904   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 905     Node* null_cmp   = new CmpPNode(val, igvn.zerocon(T_OBJECT));
 906     Node* null_test  = new BoolNode(null_cmp, BoolTest::ne);
 907 
 908     IfNode* null_iff = new IfNode(old_ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 909     ctrl             = new IfTrueNode(null_iff);
 910     null_ctrl        = new IfFalseNode(null_iff);
 911 
 912     IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 913     phase-&gt;register_control(null_iff,  loop, old_ctrl);
 914     phase-&gt;register_control(ctrl,      loop, null_iff);
 915     phase-&gt;register_control(null_ctrl, loop, null_iff);
 916 
 917     phase-&gt;register_new_node(null_cmp,  old_ctrl);
 918     phase-&gt;register_new_node(null_test, old_ctrl);
 919   }
 920 }
 921 






































































 922 void ShenandoahBarrierC2Support::test_in_cset(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {
 923   Node* old_ctrl = ctrl;
 924   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 925 
 926   Node* raw_val        = new CastP2XNode(old_ctrl, val);
 927   Node* cset_idx       = new URShiftXNode(raw_val, igvn.intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
 928   Node* cset_addr      = igvn.makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
 929   Node* cset_load_addr = new AddPNode(phase-&gt;C-&gt;top(), cset_addr, cset_idx);
 930   Node* cset_load      = new LoadBNode(old_ctrl, raw_mem, cset_load_addr,
 931                                        DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 932                                        TypeInt::BYTE, MemNode::unordered);
 933   Node* cset_cmp       = new CmpINode(cset_load, igvn.zerocon(T_INT));
 934   Node* cset_bool      = new BoolNode(cset_cmp, BoolTest::ne);
 935 
 936   IfNode* cset_iff     = new IfNode(old_ctrl, cset_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 937   ctrl                 = new IfTrueNode(cset_iff);
 938   not_cset_ctrl        = new IfFalseNode(cset_iff);
 939 
 940   IdealLoopTree *loop = phase-&gt;get_loop(old_ctrl);
 941   phase-&gt;register_control(cset_iff,      loop, old_ctrl);
</pre>
<hr />
<pre>
 953 }
 954 
 955 void ShenandoahBarrierC2Support::call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {
 956   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
 957   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr();
 958 
 959   // The slow path stub consumes and produces raw memory in addition
 960   // to the existing memory edges
 961   Node* base = find_bottom_mem(ctrl, phase);
 962   MergeMemNode* mm = MergeMemNode::make(base);
 963   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
 964   phase-&gt;register_new_node(mm, ctrl);
 965 
 966   address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?
 967           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :
 968           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);
 969 
 970   address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)
 971                                : target;
 972   const char* name = is_native ? &quot;load_reference_barrier_native&quot; : &quot;load_reference_barrier&quot;;
<span class="line-modified"> 973   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(obj_type), calladdr, name, TypeRawPtr::BOTTOM);</span>
 974 
 975   call-&gt;init_req(TypeFunc::Control, ctrl);
 976   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
 977   call-&gt;init_req(TypeFunc::Memory, mm);
 978   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
 979   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
 980   call-&gt;init_req(TypeFunc::Parms, val);
 981   call-&gt;init_req(TypeFunc::Parms+1, load_addr);
 982   phase-&gt;register_control(call, loop, ctrl);
 983   ctrl = new ProjNode(call, TypeFunc::Control);
 984   phase-&gt;register_control(ctrl, loop, call);
 985   result_mem = new ProjNode(call, TypeFunc::Memory);
 986   phase-&gt;register_new_node(result_mem, call);
 987   val = new ProjNode(call, TypeFunc::Parms);
 988   phase-&gt;register_new_node(val, call);


 989 }
 990 
 991 void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {
 992   Node* ctrl = phase-&gt;get_ctrl(barrier);
 993   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
 994 
 995   // Update the control of all nodes that should be after the
 996   // barrier control flow
 997   uses.clear();
 998   // Every node that is control dependent on the barrier&#39;s input
 999   // control will be after the expanded barrier. The raw memory (if
1000   // its memory is control dependent on the barrier&#39;s input control)
1001   // must stay above the barrier.
1002   uses_to_ignore.clear();
1003   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
1004     uses_to_ignore.push(init_raw_mem);
1005   }
1006   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
1007     Node *n = uses_to_ignore.at(next);
1008     for (uint i = 0; i &lt; n-&gt;req(); i++) {
</pre>
<hr />
<pre>
1074     Node* ctrl = phase-&gt;get_ctrl(barrier);
1075     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1076     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1077       // Expanding a barrier here will break loop strip mining
1078       // verification. Transform the loop so the loop nest doesn&#39;t
1079       // appear as strip mined.
1080       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1081       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1082     }
1083   }
1084 
1085   Node_Stack stack(0);
1086   Node_List clones;
1087   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1088     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1089     if (lrb-&gt;is_redundant()) {
1090       continue;
1091     }
1092 
1093     Node* ctrl = phase-&gt;get_ctrl(lrb);

















































































































1094     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {
1095       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();
1096       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
1097         // The rethrow call may have too many projections to be
1098         // properly handled here. Given there&#39;s no reason for a
1099         // barrier to depend on the call, move it above the call
1100         stack.push(lrb, 0);
1101         do {
1102           Node* n = stack.node();
1103           uint idx = stack.index();
1104           if (idx &lt; n-&gt;req()) {
1105             Node* in = n-&gt;in(idx);
1106             stack.set_index(idx+1);
1107             if (in != NULL) {
1108               if (phase-&gt;has_ctrl(in)) {
1109                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1110 #ifdef ASSERT
1111                   for (uint i = 0; i &lt; stack.size(); i++) {
1112                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1113                   }
</pre>
<hr />
<pre>
1214       // verification. Transform the loop so the loop nest doesn&#39;t
1215       // appear as strip mined.
1216       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1217       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1218     }
1219   }
1220 
1221   // Expand load-reference-barriers
1222   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1223   Unique_Node_List uses_to_ignore;
1224   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1225     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1226     if (lrb-&gt;is_redundant()) {
1227       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1228       continue;
1229     }
1230     uint last = phase-&gt;C-&gt;unique();
1231     Node* ctrl = phase-&gt;get_ctrl(lrb);
1232     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1233 

1234     Node* orig_ctrl = ctrl;
1235 
1236     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1237     Node* init_raw_mem = raw_mem;
1238     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1239 
<span class="line-modified">1240     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>

















1241 
1242     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1243     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1244 
<span class="line-modified">1245     enum { _heap_stable = 1, _not_cset, _evac_path, PATH_LIMIT };</span>
1246     Node* region = new RegionNode(PATH_LIMIT);
<span class="line-modified">1247     Node* val_phi = new PhiNode(region, val-&gt;bottom_type()-&gt;is_oopptr());</span>
1248     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1249 
1250     // Stable path.
<span class="line-removed">1251     Node* heap_stable_ctrl = NULL;</span>
1252     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);
1253     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1254 
1255     // Heap stable case
1256     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
<span class="line-modified">1257     val_phi-&gt;init_req(_heap_stable, val);</span>
1258     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1259 














1260     // Test for in-cset.
1261     // Wires !in_cset(obj) to slot 2 of region and phis
1262     Node* not_cset_ctrl = NULL;
<span class="line-modified">1263     test_in_cset(ctrl, not_cset_ctrl, val, raw_mem, phase);</span>
1264     if (not_cset_ctrl != NULL) {

1265       region-&gt;init_req(_not_cset, not_cset_ctrl);
<span class="line-modified">1266       val_phi-&gt;init_req(_not_cset, val);</span>
1267       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);
1268     }
1269 












1270     // Call lrb-stub and wire up that path in slots 4
1271     Node* result_mem = NULL;
1272 

1273     Node* addr;
1274     if (ShenandoahSelfFixing) {
1275       VectorSet visited(Thread::current()-&gt;resource_area());
1276       addr = get_load_addr(phase, visited, lrb);
1277     } else {
1278       addr = phase-&gt;igvn().zerocon(T_OBJECT);
1279     }
1280     if (addr-&gt;Opcode() == Op_AddP) {
1281       Node* orig_base = addr-&gt;in(AddPNode::Base);
1282       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);
1283       phase-&gt;register_new_node(base, ctrl);
1284       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {
1285         // Field access
1286         addr = addr-&gt;clone();
1287         addr-&gt;set_req(AddPNode::Base, base);
1288         addr-&gt;set_req(AddPNode::Address, base);
1289         phase-&gt;register_new_node(addr, ctrl);
1290       } else {
1291         Node* addr2 = addr-&gt;in(AddPNode::Address);
1292         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;
1293               addr2-&gt;in(AddPNode::Base) == orig_base) {
1294           addr2 = addr2-&gt;clone();
1295           addr2-&gt;set_req(AddPNode::Base, base);
1296           addr2-&gt;set_req(AddPNode::Address, base);
1297           phase-&gt;register_new_node(addr2, ctrl);
1298           addr = addr-&gt;clone();
1299           addr-&gt;set_req(AddPNode::Base, base);
1300           addr-&gt;set_req(AddPNode::Address, addr2);
1301           phase-&gt;register_new_node(addr, ctrl);
1302         }
1303       }
1304     }
<span class="line-modified">1305     call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
1306     region-&gt;init_req(_evac_path, ctrl);
<span class="line-modified">1307     val_phi-&gt;init_req(_evac_path, val);</span>
1308     raw_mem_phi-&gt;init_req(_evac_path, result_mem);
1309 
1310     phase-&gt;register_control(region, loop, heap_stable_iff);
1311     Node* out_val = val_phi;
1312     phase-&gt;register_new_node(val_phi, region);
1313     phase-&gt;register_new_node(raw_mem_phi, region);
1314 
1315     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);
1316 
1317     ctrl = orig_ctrl;
1318 














1319     phase-&gt;igvn().replace_node(lrb, out_val);
1320 
1321     follow_barrier_uses(out_val, ctrl, uses, phase);
1322 
1323     for(uint next = 0; next &lt; uses.size(); next++ ) {
1324       Node *n = uses.at(next);
1325       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);
1326       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1327       phase-&gt;set_ctrl(n, region);
1328       follow_barrier_uses(n, ctrl, uses, phase);
1329     }
1330 
1331     // The slow path call produces memory: hook the raw memory phi
1332     // from the expanded load reference barrier with the rest of the graph
1333     // which may require adding memory phis at every post dominated
1334     // region and at enclosing loop heads. Use the memory state
1335     // collected in memory_nodes to fix the memory graph. Update that
1336     // memory state as we go.
1337     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);
1338   }
</pre>
<hr />
<pre>
2926 }
2927 
2928 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {
2929   Unique_Node_List visited;
2930   Node_Stack stack(0);
2931   stack.push(this, 0);
2932 
2933   // Check if the barrier is actually useful: go over nodes looking for useful uses
2934   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk
2935   // until we ran out of nodes, and then declare the barrier redundant.
2936   while (stack.size() &gt; 0) {
2937     Node* n = stack.node();
2938     if (visited.member(n)) {
2939       stack.pop();
2940       continue;
2941     }
2942     visited.push(n);
2943     bool visit_users = false;
2944     switch (n-&gt;Opcode()) {
2945       case Op_CallStaticJava:
<span class="line-removed">2946         // Uncommon traps don&#39;t need barriers, values are handled during deoptimization. It also affects</span>
<span class="line-removed">2947         // optimizing null-checks into implicit null-checks.</span>
<span class="line-removed">2948         if (n-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0) {</span>
<span class="line-removed">2949           break;</span>
<span class="line-removed">2950         }</span>
2951       case Op_CallDynamicJava:
2952       case Op_CallLeaf:
2953       case Op_CallLeafNoFP:
2954       case Op_CompareAndSwapL:
2955       case Op_CompareAndSwapI:
2956       case Op_CompareAndSwapB:
2957       case Op_CompareAndSwapS:
2958       case Op_CompareAndSwapN:
2959       case Op_CompareAndSwapP:
2960       case Op_CompareAndExchangeL:
2961       case Op_CompareAndExchangeI:
2962       case Op_CompareAndExchangeB:
2963       case Op_CompareAndExchangeS:
2964       case Op_CompareAndExchangeN:
2965       case Op_CompareAndExchangeP:
2966       case Op_WeakCompareAndSwapL:
2967       case Op_WeakCompareAndSwapI:
2968       case Op_WeakCompareAndSwapB:
2969       case Op_WeakCompareAndSwapS:
2970       case Op_WeakCompareAndSwapN:
</pre>
<hr />
<pre>
3072         // Default to have excess barriers, rather than miss some.
3073         return false;
3074 #endif
3075       }
3076     }
3077 
3078     stack.pop();
3079     if (visit_users) {
3080       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3081         Node* user = n-&gt;fast_out(i);
3082         if (user != NULL) {
3083           stack.push(user, 0);
3084         }
3085       }
3086     }
3087   }
3088 
3089   // No need for barrier found.
3090   return true;
3091 }























</pre>
</td>
<td>
<hr />
<pre>
 862 
 863 void ShenandoahBarrierC2Support::test_gc_state(Node*&amp; ctrl, Node* raw_mem, Node*&amp; test_fail_ctrl,
 864                                                PhaseIdealLoop* phase, int flags) {
 865   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 866   Node* old_ctrl = ctrl;
 867 
 868   Node* thread          = new ThreadLocalNode();
 869   Node* gc_state_offset = igvn.MakeConX(in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
 870   Node* gc_state_addr   = new AddPNode(phase-&gt;C-&gt;top(), thread, gc_state_offset);
 871   Node* gc_state        = new LoadBNode(old_ctrl, raw_mem, gc_state_addr,
 872                                         DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
 873                                         TypeInt::BYTE, MemNode::unordered);
 874   Node* gc_state_and    = new AndINode(gc_state, igvn.intcon(flags));
 875   Node* gc_state_cmp    = new CmpINode(gc_state_and, igvn.zerocon(T_INT));
 876   Node* gc_state_bool   = new BoolNode(gc_state_cmp, BoolTest::ne);
 877 
 878   IfNode* gc_state_iff  = new IfNode(old_ctrl, gc_state_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
 879   ctrl                  = new IfTrueNode(gc_state_iff);
 880   test_fail_ctrl        = new IfFalseNode(gc_state_iff);
 881 
<span class="line-modified"> 882   IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);</span>
 883   phase-&gt;register_control(gc_state_iff,   loop, old_ctrl);
 884   phase-&gt;register_control(ctrl,           loop, gc_state_iff);
 885   phase-&gt;register_control(test_fail_ctrl, loop, gc_state_iff);
 886 
 887   phase-&gt;register_new_node(thread,        old_ctrl);
 888   phase-&gt;register_new_node(gc_state_addr, old_ctrl);
 889   phase-&gt;register_new_node(gc_state,      old_ctrl);
 890   phase-&gt;register_new_node(gc_state_and,  old_ctrl);
 891   phase-&gt;register_new_node(gc_state_cmp,  old_ctrl);
 892   phase-&gt;register_new_node(gc_state_bool, old_ctrl);
 893 
 894   phase-&gt;set_ctrl(gc_state_offset, phase-&gt;C-&gt;root());
 895 
 896   assert(is_gc_state_test(gc_state_iff, flags), &quot;Should match the shape&quot;);
 897 }
 898 
 899 void ShenandoahBarrierC2Support::test_null(Node*&amp; ctrl, Node* val, Node*&amp; null_ctrl, PhaseIdealLoop* phase) {
 900   Node* old_ctrl = ctrl;
 901   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 902 
 903   const Type* val_t = igvn.type(val);
 904   if (val_t-&gt;meet(TypePtr::NULL_PTR) == val_t) {
 905     Node* null_cmp   = new CmpPNode(val, igvn.zerocon(T_OBJECT));
 906     Node* null_test  = new BoolNode(null_cmp, BoolTest::ne);
 907 
 908     IfNode* null_iff = new IfNode(old_ctrl, null_test, PROB_LIKELY(0.999), COUNT_UNKNOWN);
 909     ctrl             = new IfTrueNode(null_iff);
 910     null_ctrl        = new IfFalseNode(null_iff);
 911 
 912     IdealLoopTree* loop = phase-&gt;get_loop(old_ctrl);
 913     phase-&gt;register_control(null_iff,  loop, old_ctrl);
 914     phase-&gt;register_control(ctrl,      loop, null_iff);
 915     phase-&gt;register_control(null_ctrl, loop, null_iff);
 916 
 917     phase-&gt;register_new_node(null_cmp,  old_ctrl);
 918     phase-&gt;register_new_node(null_test, old_ctrl);
 919   }
 920 }
 921 
<span class="line-added"> 922 Node* ShenandoahBarrierC2Support::clone_null_check(Node*&amp; c, Node* val, Node* unc_ctrl, PhaseIdealLoop* phase) {</span>
<span class="line-added"> 923   IdealLoopTree *loop = phase-&gt;get_loop(c);</span>
<span class="line-added"> 924   Node* iff = unc_ctrl-&gt;in(0);</span>
<span class="line-added"> 925   assert(iff-&gt;is_If(), &quot;broken&quot;);</span>
<span class="line-added"> 926   Node* new_iff = iff-&gt;clone();</span>
<span class="line-added"> 927   new_iff-&gt;set_req(0, c);</span>
<span class="line-added"> 928   phase-&gt;register_control(new_iff, loop, c);</span>
<span class="line-added"> 929   Node* iffalse = new IfFalseNode(new_iff-&gt;as_If());</span>
<span class="line-added"> 930   phase-&gt;register_control(iffalse, loop, new_iff);</span>
<span class="line-added"> 931   Node* iftrue = new IfTrueNode(new_iff-&gt;as_If());</span>
<span class="line-added"> 932   phase-&gt;register_control(iftrue, loop, new_iff);</span>
<span class="line-added"> 933   c = iftrue;</span>
<span class="line-added"> 934   const Type *t = phase-&gt;igvn().type(val);</span>
<span class="line-added"> 935   assert(val-&gt;Opcode() == Op_CastPP, &quot;expect cast to non null here&quot;);</span>
<span class="line-added"> 936   Node* uncasted_val = val-&gt;in(1);</span>
<span class="line-added"> 937   val = new CastPPNode(uncasted_val, t);</span>
<span class="line-added"> 938   val-&gt;init_req(0, c);</span>
<span class="line-added"> 939   phase-&gt;register_new_node(val, c);</span>
<span class="line-added"> 940   return val;</span>
<span class="line-added"> 941 }</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943 void ShenandoahBarrierC2Support::fix_null_check(Node* unc, Node* unc_ctrl, Node* new_unc_ctrl,</span>
<span class="line-added"> 944                                                 Unique_Node_List&amp; uses, PhaseIdealLoop* phase) {</span>
<span class="line-added"> 945   IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added"> 946   Node* proj = iff-&gt;proj_out(0);</span>
<span class="line-added"> 947   assert(proj != unc_ctrl, &quot;bad projection&quot;);</span>
<span class="line-added"> 948   Node* use = proj-&gt;unique_ctrl_out();</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950   assert(use == unc || use-&gt;is_Region(), &quot;what else?&quot;);</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952   uses.clear();</span>
<span class="line-added"> 953   if (use == unc) {</span>
<span class="line-added"> 954     phase-&gt;set_idom(use, new_unc_ctrl, phase-&gt;dom_depth(use));</span>
<span class="line-added"> 955     for (uint i = 1; i &lt; unc-&gt;req(); i++) {</span>
<span class="line-added"> 956       Node* n = unc-&gt;in(i);</span>
<span class="line-added"> 957       if (phase-&gt;has_ctrl(n) &amp;&amp; phase-&gt;get_ctrl(n) == proj) {</span>
<span class="line-added"> 958         uses.push(n);</span>
<span class="line-added"> 959       }</span>
<span class="line-added"> 960     }</span>
<span class="line-added"> 961   } else {</span>
<span class="line-added"> 962     assert(use-&gt;is_Region(), &quot;what else?&quot;);</span>
<span class="line-added"> 963     uint idx = 1;</span>
<span class="line-added"> 964     for (; use-&gt;in(idx) != proj; idx++);</span>
<span class="line-added"> 965     for (DUIterator_Fast imax, i = use-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added"> 966       Node* u = use-&gt;fast_out(i);</span>
<span class="line-added"> 967       if (u-&gt;is_Phi() &amp;&amp; phase-&gt;get_ctrl(u-&gt;in(idx)) == proj) {</span>
<span class="line-added"> 968         uses.push(u-&gt;in(idx));</span>
<span class="line-added"> 969       }</span>
<span class="line-added"> 970     }</span>
<span class="line-added"> 971   }</span>
<span class="line-added"> 972   for(uint next = 0; next &lt; uses.size(); next++ ) {</span>
<span class="line-added"> 973     Node *n = uses.at(next);</span>
<span class="line-added"> 974     assert(phase-&gt;get_ctrl(n) == proj, &quot;bad control&quot;);</span>
<span class="line-added"> 975     phase-&gt;set_ctrl_and_loop(n, new_unc_ctrl);</span>
<span class="line-added"> 976     if (n-&gt;in(0) == proj) {</span>
<span class="line-added"> 977       phase-&gt;igvn().replace_input_of(n, 0, new_unc_ctrl);</span>
<span class="line-added"> 978     }</span>
<span class="line-added"> 979     for (uint i = 0; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added"> 980       Node* m = n-&gt;in(i);</span>
<span class="line-added"> 981       if (m != NULL &amp;&amp; phase-&gt;has_ctrl(m) &amp;&amp; phase-&gt;get_ctrl(m) == proj) {</span>
<span class="line-added"> 982         uses.push(m);</span>
<span class="line-added"> 983       }</span>
<span class="line-added"> 984     }</span>
<span class="line-added"> 985   }</span>
<span class="line-added"> 986 </span>
<span class="line-added"> 987   phase-&gt;igvn().rehash_node_delayed(use);</span>
<span class="line-added"> 988   int nb = use-&gt;replace_edge(proj, new_unc_ctrl);</span>
<span class="line-added"> 989   assert(nb == 1, &quot;only use expected&quot;);</span>
<span class="line-added"> 990 }</span>
<span class="line-added"> 991 </span>
 992 void ShenandoahBarrierC2Support::test_in_cset(Node*&amp; ctrl, Node*&amp; not_cset_ctrl, Node* val, Node* raw_mem, PhaseIdealLoop* phase) {
 993   Node* old_ctrl = ctrl;
 994   PhaseIterGVN&amp; igvn = phase-&gt;igvn();
 995 
 996   Node* raw_val        = new CastP2XNode(old_ctrl, val);
 997   Node* cset_idx       = new URShiftXNode(raw_val, igvn.intcon(ShenandoahHeapRegion::region_size_bytes_shift_jint()));
 998   Node* cset_addr      = igvn.makecon(TypeRawPtr::make(ShenandoahHeap::in_cset_fast_test_addr()));
 999   Node* cset_load_addr = new AddPNode(phase-&gt;C-&gt;top(), cset_addr, cset_idx);
1000   Node* cset_load      = new LoadBNode(old_ctrl, raw_mem, cset_load_addr,
1001                                        DEBUG_ONLY(phase-&gt;C-&gt;get_adr_type(Compile::AliasIdxRaw)) NOT_DEBUG(NULL),
1002                                        TypeInt::BYTE, MemNode::unordered);
1003   Node* cset_cmp       = new CmpINode(cset_load, igvn.zerocon(T_INT));
1004   Node* cset_bool      = new BoolNode(cset_cmp, BoolTest::ne);
1005 
1006   IfNode* cset_iff     = new IfNode(old_ctrl, cset_bool, PROB_UNLIKELY(0.999), COUNT_UNKNOWN);
1007   ctrl                 = new IfTrueNode(cset_iff);
1008   not_cset_ctrl        = new IfFalseNode(cset_iff);
1009 
1010   IdealLoopTree *loop = phase-&gt;get_loop(old_ctrl);
1011   phase-&gt;register_control(cset_iff,      loop, old_ctrl);
</pre>
<hr />
<pre>
1023 }
1024 
1025 void ShenandoahBarrierC2Support::call_lrb_stub(Node*&amp; ctrl, Node*&amp; val, Node* load_addr, Node*&amp; result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {
1026   IdealLoopTree*loop = phase-&gt;get_loop(ctrl);
1027   const TypePtr* obj_type = phase-&gt;igvn().type(val)-&gt;is_oopptr();
1028 
1029   // The slow path stub consumes and produces raw memory in addition
1030   // to the existing memory edges
1031   Node* base = find_bottom_mem(ctrl, phase);
1032   MergeMemNode* mm = MergeMemNode::make(base);
1033   mm-&gt;set_memory_at(Compile::AliasIdxRaw, raw_mem);
1034   phase-&gt;register_new_node(mm, ctrl);
1035 
1036   address target = LP64_ONLY(UseCompressedOops) NOT_LP64(false) ?
1037           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow) :
1038           CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier);
1039 
1040   address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)
1041                                : target;
1042   const char* name = is_native ? &quot;load_reference_barrier_native&quot; : &quot;load_reference_barrier&quot;;
<span class="line-modified">1043   Node* call = new CallLeafNode(ShenandoahBarrierSetC2::shenandoah_load_reference_barrier_Type(), calladdr, name, TypeRawPtr::BOTTOM);</span>
1044 
1045   call-&gt;init_req(TypeFunc::Control, ctrl);
1046   call-&gt;init_req(TypeFunc::I_O, phase-&gt;C-&gt;top());
1047   call-&gt;init_req(TypeFunc::Memory, mm);
1048   call-&gt;init_req(TypeFunc::FramePtr, phase-&gt;C-&gt;top());
1049   call-&gt;init_req(TypeFunc::ReturnAdr, phase-&gt;C-&gt;top());
1050   call-&gt;init_req(TypeFunc::Parms, val);
1051   call-&gt;init_req(TypeFunc::Parms+1, load_addr);
1052   phase-&gt;register_control(call, loop, ctrl);
1053   ctrl = new ProjNode(call, TypeFunc::Control);
1054   phase-&gt;register_control(ctrl, loop, call);
1055   result_mem = new ProjNode(call, TypeFunc::Memory);
1056   phase-&gt;register_new_node(result_mem, call);
1057   val = new ProjNode(call, TypeFunc::Parms);
1058   phase-&gt;register_new_node(val, call);
<span class="line-added">1059   val = new CheckCastPPNode(ctrl, val, obj_type);</span>
<span class="line-added">1060   phase-&gt;register_new_node(val, ctrl);</span>
1061 }
1062 
1063 void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer&amp; fixer, Unique_Node_List&amp; uses, Unique_Node_List&amp; uses_to_ignore, uint last, PhaseIdealLoop* phase) {
1064   Node* ctrl = phase-&gt;get_ctrl(barrier);
1065   Node* init_raw_mem = fixer.find_mem(ctrl, barrier);
1066 
1067   // Update the control of all nodes that should be after the
1068   // barrier control flow
1069   uses.clear();
1070   // Every node that is control dependent on the barrier&#39;s input
1071   // control will be after the expanded barrier. The raw memory (if
1072   // its memory is control dependent on the barrier&#39;s input control)
1073   // must stay above the barrier.
1074   uses_to_ignore.clear();
1075   if (phase-&gt;has_ctrl(init_raw_mem) &amp;&amp; phase-&gt;get_ctrl(init_raw_mem) == ctrl &amp;&amp; !init_raw_mem-&gt;is_Phi()) {
1076     uses_to_ignore.push(init_raw_mem);
1077   }
1078   for (uint next = 0; next &lt; uses_to_ignore.size(); next++) {
1079     Node *n = uses_to_ignore.at(next);
1080     for (uint i = 0; i &lt; n-&gt;req(); i++) {
</pre>
<hr />
<pre>
1146     Node* ctrl = phase-&gt;get_ctrl(barrier);
1147     IdealLoopTree* loop = phase-&gt;get_loop(ctrl);
1148     if (loop-&gt;_head-&gt;is_OuterStripMinedLoop()) {
1149       // Expanding a barrier here will break loop strip mining
1150       // verification. Transform the loop so the loop nest doesn&#39;t
1151       // appear as strip mined.
1152       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1153       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1154     }
1155   }
1156 
1157   Node_Stack stack(0);
1158   Node_List clones;
1159   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1160     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1161     if (lrb-&gt;is_redundant()) {
1162       continue;
1163     }
1164 
1165     Node* ctrl = phase-&gt;get_ctrl(lrb);
<span class="line-added">1166     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);</span>
<span class="line-added">1167 </span>
<span class="line-added">1168     CallStaticJavaNode* unc = NULL;</span>
<span class="line-added">1169     Node* unc_ctrl = NULL;</span>
<span class="line-added">1170     Node* uncasted_val = val;</span>
<span class="line-added">1171 </span>
<span class="line-added">1172     for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1173       Node* u = lrb-&gt;fast_out(i);</span>
<span class="line-added">1174       if (u-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-added">1175           u-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-added">1176           phase-&gt;is_dominator(u-&gt;in(0), ctrl)) {</span>
<span class="line-added">1177         const Type* u_t = phase-&gt;igvn().type(u);</span>
<span class="line-added">1178 </span>
<span class="line-added">1179         if (u_t-&gt;meet(TypePtr::NULL_PTR) != u_t &amp;&amp;</span>
<span class="line-added">1180             u-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-added">1181             u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-added">1182             u-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-added">1183             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-added">1184             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-added">1185             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-added">1186             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val &amp;&amp;</span>
<span class="line-added">1187             u-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">1188           IdealLoopTree* loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-added">1189           IdealLoopTree* unc_loop = phase-&gt;get_loop(u-&gt;in(0));</span>
<span class="line-added">1190 </span>
<span class="line-added">1191           if (!unc_loop-&gt;is_member(loop)) {</span>
<span class="line-added">1192             continue;</span>
<span class="line-added">1193           }</span>
<span class="line-added">1194 </span>
<span class="line-added">1195           Node* branch = no_branches(ctrl, u-&gt;in(0), false, phase);</span>
<span class="line-added">1196           assert(branch == NULL || branch == NodeSentinel, &quot;was not looking for a branch&quot;);</span>
<span class="line-added">1197           if (branch == NodeSentinel) {</span>
<span class="line-added">1198             continue;</span>
<span class="line-added">1199           }</span>
<span class="line-added">1200 </span>
<span class="line-added">1201           phase-&gt;igvn().replace_input_of(u, 1, val);</span>
<span class="line-added">1202           phase-&gt;igvn().replace_input_of(lrb, ShenandoahLoadReferenceBarrierNode::ValueIn, u);</span>
<span class="line-added">1203           phase-&gt;set_ctrl(u, u-&gt;in(0));</span>
<span class="line-added">1204           phase-&gt;set_ctrl(lrb, u-&gt;in(0));</span>
<span class="line-added">1205           unc = u-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-added">1206           unc_ctrl = u-&gt;in(0);</span>
<span class="line-added">1207           val = u;</span>
<span class="line-added">1208 </span>
<span class="line-added">1209           for (DUIterator_Fast jmax, j = val-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added">1210             Node* u = val-&gt;fast_out(j);</span>
<span class="line-added">1211             if (u == lrb) continue;</span>
<span class="line-added">1212             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1213             int nb = u-&gt;replace_edge(val, lrb);</span>
<span class="line-added">1214             --j; jmax -= nb;</span>
<span class="line-added">1215           }</span>
<span class="line-added">1216 </span>
<span class="line-added">1217           RegionNode* r = new RegionNode(3);</span>
<span class="line-added">1218           IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1219 </span>
<span class="line-added">1220           Node* ctrl_use = unc_ctrl-&gt;unique_ctrl_out();</span>
<span class="line-added">1221           Node* unc_ctrl_clone = unc_ctrl-&gt;clone();</span>
<span class="line-added">1222           phase-&gt;register_control(unc_ctrl_clone, loop, iff);</span>
<span class="line-added">1223           Node* c = unc_ctrl_clone;</span>
<span class="line-added">1224           Node* new_cast = clone_null_check(c, val, unc_ctrl_clone, phase);</span>
<span class="line-added">1225           r-&gt;init_req(1, new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If()-&gt;proj_out(0));</span>
<span class="line-added">1226 </span>
<span class="line-added">1227           phase-&gt;igvn().replace_input_of(unc_ctrl, 0, c-&gt;in(0));</span>
<span class="line-added">1228           phase-&gt;set_idom(unc_ctrl, c-&gt;in(0), phase-&gt;dom_depth(unc_ctrl));</span>
<span class="line-added">1229           phase-&gt;lazy_replace(c, unc_ctrl);</span>
<span class="line-added">1230           c = NULL;;</span>
<span class="line-added">1231           phase-&gt;igvn().replace_input_of(val, 0, unc_ctrl_clone);</span>
<span class="line-added">1232           phase-&gt;set_ctrl(val, unc_ctrl_clone);</span>
<span class="line-added">1233 </span>
<span class="line-added">1234           IfNode* new_iff = new_cast-&gt;in(0)-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1235           fix_null_check(unc, unc_ctrl_clone, r, uses, phase);</span>
<span class="line-added">1236           Node* iff_proj = iff-&gt;proj_out(0);</span>
<span class="line-added">1237           r-&gt;init_req(2, iff_proj);</span>
<span class="line-added">1238           phase-&gt;register_control(r, phase-&gt;ltree_root(), iff);</span>
<span class="line-added">1239 </span>
<span class="line-added">1240           Node* new_bol = new_iff-&gt;in(1)-&gt;clone();</span>
<span class="line-added">1241           Node* new_cmp = new_bol-&gt;in(1)-&gt;clone();</span>
<span class="line-added">1242           assert(new_cmp-&gt;Opcode() == Op_CmpP, &quot;broken&quot;);</span>
<span class="line-added">1243           assert(new_cmp-&gt;in(1) == val-&gt;in(1), &quot;broken&quot;);</span>
<span class="line-added">1244           new_bol-&gt;set_req(1, new_cmp);</span>
<span class="line-added">1245           new_cmp-&gt;set_req(1, lrb);</span>
<span class="line-added">1246           phase-&gt;register_new_node(new_bol, new_iff-&gt;in(0));</span>
<span class="line-added">1247           phase-&gt;register_new_node(new_cmp, new_iff-&gt;in(0));</span>
<span class="line-added">1248           phase-&gt;igvn().replace_input_of(new_iff, 1, new_bol);</span>
<span class="line-added">1249           phase-&gt;igvn().replace_input_of(new_cast, 1, lrb);</span>
<span class="line-added">1250 </span>
<span class="line-added">1251           for (DUIterator_Fast imax, i = lrb-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1252             Node* u = lrb-&gt;fast_out(i);</span>
<span class="line-added">1253             if (u == new_cast || u == new_cmp) {</span>
<span class="line-added">1254               continue;</span>
<span class="line-added">1255             }</span>
<span class="line-added">1256             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1257             int nb = u-&gt;replace_edge(lrb, new_cast);</span>
<span class="line-added">1258             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-added">1259             --i; imax -= nb;</span>
<span class="line-added">1260           }</span>
<span class="line-added">1261 </span>
<span class="line-added">1262           for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1263             Node* u = val-&gt;fast_out(i);</span>
<span class="line-added">1264             if (u == lrb) {</span>
<span class="line-added">1265               continue;</span>
<span class="line-added">1266             }</span>
<span class="line-added">1267             phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1268             int nb = u-&gt;replace_edge(val, new_cast);</span>
<span class="line-added">1269             assert(nb &gt; 0, &quot;no update?&quot;);</span>
<span class="line-added">1270             --i; imax -= nb;</span>
<span class="line-added">1271           }</span>
<span class="line-added">1272 </span>
<span class="line-added">1273           ctrl = unc_ctrl_clone;</span>
<span class="line-added">1274           phase-&gt;set_ctrl_and_loop(lrb, ctrl);</span>
<span class="line-added">1275           break;</span>
<span class="line-added">1276         }</span>
<span class="line-added">1277       }</span>
<span class="line-added">1278     }</span>
1279     if ((ctrl-&gt;is_Proj() &amp;&amp; ctrl-&gt;in(0)-&gt;is_CallJava()) || ctrl-&gt;is_CallJava()) {
1280       CallNode* call = ctrl-&gt;is_Proj() ? ctrl-&gt;in(0)-&gt;as_CallJava() : ctrl-&gt;as_CallJava();
1281       if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
1282         // The rethrow call may have too many projections to be
1283         // properly handled here. Given there&#39;s no reason for a
1284         // barrier to depend on the call, move it above the call
1285         stack.push(lrb, 0);
1286         do {
1287           Node* n = stack.node();
1288           uint idx = stack.index();
1289           if (idx &lt; n-&gt;req()) {
1290             Node* in = n-&gt;in(idx);
1291             stack.set_index(idx+1);
1292             if (in != NULL) {
1293               if (phase-&gt;has_ctrl(in)) {
1294                 if (phase-&gt;is_dominator(call, phase-&gt;get_ctrl(in))) {
1295 #ifdef ASSERT
1296                   for (uint i = 0; i &lt; stack.size(); i++) {
1297                     assert(stack.node_at(i) != in, &quot;node shouldn&#39;t have been seen yet&quot;);
1298                   }
</pre>
<hr />
<pre>
1399       // verification. Transform the loop so the loop nest doesn&#39;t
1400       // appear as strip mined.
1401       OuterStripMinedLoopNode* outer = loop-&gt;_head-&gt;as_OuterStripMinedLoop();
1402       hide_strip_mined_loop(outer, outer-&gt;unique_ctrl_out()-&gt;as_CountedLoop(), phase);
1403     }
1404   }
1405 
1406   // Expand load-reference-barriers
1407   MemoryGraphFixer fixer(Compile::AliasIdxRaw, true, phase);
1408   Unique_Node_List uses_to_ignore;
1409   for (int i = state-&gt;load_reference_barriers_count() - 1; i &gt;= 0; i--) {
1410     ShenandoahLoadReferenceBarrierNode* lrb = state-&gt;load_reference_barrier(i);
1411     if (lrb-&gt;is_redundant()) {
1412       phase-&gt;igvn().replace_node(lrb, lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn));
1413       continue;
1414     }
1415     uint last = phase-&gt;C-&gt;unique();
1416     Node* ctrl = phase-&gt;get_ctrl(lrb);
1417     Node* val = lrb-&gt;in(ShenandoahLoadReferenceBarrierNode::ValueIn);
1418 
<span class="line-added">1419 </span>
1420     Node* orig_ctrl = ctrl;
1421 
1422     Node* raw_mem = fixer.find_mem(ctrl, lrb);
1423     Node* init_raw_mem = raw_mem;
1424     Node* raw_mem_for_ctrl = fixer.find_mem(ctrl, NULL);
1425 
<span class="line-modified">1426     IdealLoopTree *loop = phase-&gt;get_loop(ctrl);</span>
<span class="line-added">1427     CallStaticJavaNode* unc = lrb-&gt;pin_and_expand_null_check(phase-&gt;igvn());</span>
<span class="line-added">1428     Node* unc_ctrl = NULL;</span>
<span class="line-added">1429     if (unc != NULL) {</span>
<span class="line-added">1430       if (val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control) != ctrl) {</span>
<span class="line-added">1431         unc = NULL;</span>
<span class="line-added">1432       } else {</span>
<span class="line-added">1433         unc_ctrl = val-&gt;in(ShenandoahLoadReferenceBarrierNode::Control);</span>
<span class="line-added">1434       }</span>
<span class="line-added">1435     }</span>
<span class="line-added">1436 </span>
<span class="line-added">1437     Node* uncasted_val = val;</span>
<span class="line-added">1438     if (unc != NULL) {</span>
<span class="line-added">1439       uncasted_val = val-&gt;in(1);</span>
<span class="line-added">1440     }</span>
<span class="line-added">1441 </span>
<span class="line-added">1442     Node* heap_stable_ctrl = NULL;</span>
<span class="line-added">1443     Node* null_ctrl = NULL;</span>
1444 
1445     assert(val-&gt;bottom_type()-&gt;make_oopptr(), &quot;need oop&quot;);
1446     assert(val-&gt;bottom_type()-&gt;make_oopptr()-&gt;const_oop() == NULL, &quot;expect non-constant&quot;);
1447 
<span class="line-modified">1448     enum { _heap_stable = 1, _not_cset, _evac_path, _null_path, PATH_LIMIT };</span>
1449     Node* region = new RegionNode(PATH_LIMIT);
<span class="line-modified">1450     Node* val_phi = new PhiNode(region, uncasted_val-&gt;bottom_type()-&gt;is_oopptr());</span>
1451     Node* raw_mem_phi = PhiNode::make(region, raw_mem, Type::MEMORY, TypeRawPtr::BOTTOM);
1452 
1453     // Stable path.

1454     test_gc_state(ctrl, raw_mem, heap_stable_ctrl, phase, ShenandoahHeap::HAS_FORWARDED);
1455     IfNode* heap_stable_iff = heap_stable_ctrl-&gt;in(0)-&gt;as_If();
1456 
1457     // Heap stable case
1458     region-&gt;init_req(_heap_stable, heap_stable_ctrl);
<span class="line-modified">1459     val_phi-&gt;init_req(_heap_stable, uncasted_val);</span>
1460     raw_mem_phi-&gt;init_req(_heap_stable, raw_mem);
1461 
<span class="line-added">1462     Node* reg2_ctrl = NULL;</span>
<span class="line-added">1463     // Null case</span>
<span class="line-added">1464     test_null(ctrl, val, null_ctrl, phase);</span>
<span class="line-added">1465     if (null_ctrl != NULL) {</span>
<span class="line-added">1466       reg2_ctrl = null_ctrl-&gt;in(0);</span>
<span class="line-added">1467       region-&gt;init_req(_null_path, null_ctrl);</span>
<span class="line-added">1468       val_phi-&gt;init_req(_null_path, uncasted_val);</span>
<span class="line-added">1469       raw_mem_phi-&gt;init_req(_null_path, raw_mem);</span>
<span class="line-added">1470     } else {</span>
<span class="line-added">1471       region-&gt;del_req(_null_path);</span>
<span class="line-added">1472       val_phi-&gt;del_req(_null_path);</span>
<span class="line-added">1473       raw_mem_phi-&gt;del_req(_null_path);</span>
<span class="line-added">1474     }</span>
<span class="line-added">1475 </span>
1476     // Test for in-cset.
1477     // Wires !in_cset(obj) to slot 2 of region and phis
1478     Node* not_cset_ctrl = NULL;
<span class="line-modified">1479     test_in_cset(ctrl, not_cset_ctrl, uncasted_val, raw_mem, phase);</span>
1480     if (not_cset_ctrl != NULL) {
<span class="line-added">1481       if (reg2_ctrl == NULL) reg2_ctrl = not_cset_ctrl-&gt;in(0);</span>
1482       region-&gt;init_req(_not_cset, not_cset_ctrl);
<span class="line-modified">1483       val_phi-&gt;init_req(_not_cset, uncasted_val);</span>
1484       raw_mem_phi-&gt;init_req(_not_cset, raw_mem);
1485     }
1486 
<span class="line-added">1487     // Resolve object when orig-value is in cset.</span>
<span class="line-added">1488     // Make the unconditional resolve for fwdptr.</span>
<span class="line-added">1489     Node* new_val = uncasted_val;</span>
<span class="line-added">1490     if (unc_ctrl != NULL) {</span>
<span class="line-added">1491       // Clone the null check in this branch to allow implicit null check</span>
<span class="line-added">1492       new_val = clone_null_check(ctrl, val, unc_ctrl, phase);</span>
<span class="line-added">1493       fix_null_check(unc, unc_ctrl, ctrl-&gt;in(0)-&gt;as_If()-&gt;proj_out(0), uses, phase);</span>
<span class="line-added">1494 </span>
<span class="line-added">1495       IfNode* iff = unc_ctrl-&gt;in(0)-&gt;as_If();</span>
<span class="line-added">1496       phase-&gt;igvn().replace_input_of(iff, 1, phase-&gt;igvn().intcon(1));</span>
<span class="line-added">1497     }</span>
<span class="line-added">1498 </span>
1499     // Call lrb-stub and wire up that path in slots 4
1500     Node* result_mem = NULL;
1501 
<span class="line-added">1502     Node* fwd = new_val;</span>
1503     Node* addr;
1504     if (ShenandoahSelfFixing) {
1505       VectorSet visited(Thread::current()-&gt;resource_area());
1506       addr = get_load_addr(phase, visited, lrb);
1507     } else {
1508       addr = phase-&gt;igvn().zerocon(T_OBJECT);
1509     }
1510     if (addr-&gt;Opcode() == Op_AddP) {
1511       Node* orig_base = addr-&gt;in(AddPNode::Base);
1512       Node* base = new CheckCastPPNode(ctrl, orig_base, orig_base-&gt;bottom_type(), true);
1513       phase-&gt;register_new_node(base, ctrl);
1514       if (addr-&gt;in(AddPNode::Base) == addr-&gt;in((AddPNode::Address))) {
1515         // Field access
1516         addr = addr-&gt;clone();
1517         addr-&gt;set_req(AddPNode::Base, base);
1518         addr-&gt;set_req(AddPNode::Address, base);
1519         phase-&gt;register_new_node(addr, ctrl);
1520       } else {
1521         Node* addr2 = addr-&gt;in(AddPNode::Address);
1522         if (addr2-&gt;Opcode() == Op_AddP &amp;&amp; addr2-&gt;in(AddPNode::Base) == addr2-&gt;in(AddPNode::Address) &amp;&amp;
1523               addr2-&gt;in(AddPNode::Base) == orig_base) {
1524           addr2 = addr2-&gt;clone();
1525           addr2-&gt;set_req(AddPNode::Base, base);
1526           addr2-&gt;set_req(AddPNode::Address, base);
1527           phase-&gt;register_new_node(addr2, ctrl);
1528           addr = addr-&gt;clone();
1529           addr-&gt;set_req(AddPNode::Base, base);
1530           addr-&gt;set_req(AddPNode::Address, addr2);
1531           phase-&gt;register_new_node(addr, ctrl);
1532         }
1533       }
1534     }
<span class="line-modified">1535     call_lrb_stub(ctrl, fwd, addr, result_mem, raw_mem, lrb-&gt;is_native(), phase);</span>
1536     region-&gt;init_req(_evac_path, ctrl);
<span class="line-modified">1537     val_phi-&gt;init_req(_evac_path, fwd);</span>
1538     raw_mem_phi-&gt;init_req(_evac_path, result_mem);
1539 
1540     phase-&gt;register_control(region, loop, heap_stable_iff);
1541     Node* out_val = val_phi;
1542     phase-&gt;register_new_node(val_phi, region);
1543     phase-&gt;register_new_node(raw_mem_phi, region);
1544 
1545     fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);
1546 
1547     ctrl = orig_ctrl;
1548 
<span class="line-added">1549     if (unc != NULL) {</span>
<span class="line-added">1550       for (DUIterator_Fast imax, i = val-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">1551         Node* u = val-&gt;fast_out(i);</span>
<span class="line-added">1552         Node* c = phase-&gt;ctrl_or_self(u);</span>
<span class="line-added">1553         if (u != lrb &amp;&amp; (c != ctrl || is_dominator_same_ctrl(c, lrb, u, phase))) {</span>
<span class="line-added">1554           phase-&gt;igvn().rehash_node_delayed(u);</span>
<span class="line-added">1555           int nb = u-&gt;replace_edge(val, out_val);</span>
<span class="line-added">1556           --i, imax -= nb;</span>
<span class="line-added">1557         }</span>
<span class="line-added">1558       }</span>
<span class="line-added">1559       if (val-&gt;outcnt() == 0) {</span>
<span class="line-added">1560         phase-&gt;igvn()._worklist.push(val);</span>
<span class="line-added">1561       }</span>
<span class="line-added">1562     }</span>
1563     phase-&gt;igvn().replace_node(lrb, out_val);
1564 
1565     follow_barrier_uses(out_val, ctrl, uses, phase);
1566 
1567     for(uint next = 0; next &lt; uses.size(); next++ ) {
1568       Node *n = uses.at(next);
1569       assert(phase-&gt;get_ctrl(n) == ctrl, &quot;bad control&quot;);
1570       assert(n != init_raw_mem, &quot;should leave input raw mem above the barrier&quot;);
1571       phase-&gt;set_ctrl(n, region);
1572       follow_barrier_uses(n, ctrl, uses, phase);
1573     }
1574 
1575     // The slow path call produces memory: hook the raw memory phi
1576     // from the expanded load reference barrier with the rest of the graph
1577     // which may require adding memory phis at every post dominated
1578     // region and at enclosing loop heads. Use the memory state
1579     // collected in memory_nodes to fix the memory graph. Update that
1580     // memory state as we go.
1581     fixer.fix_mem(ctrl, region, init_raw_mem, raw_mem_for_ctrl, raw_mem_phi, uses);
1582   }
</pre>
<hr />
<pre>
3170 }
3171 
3172 bool ShenandoahLoadReferenceBarrierNode::is_redundant() {
3173   Unique_Node_List visited;
3174   Node_Stack stack(0);
3175   stack.push(this, 0);
3176 
3177   // Check if the barrier is actually useful: go over nodes looking for useful uses
3178   // (e.g. memory accesses). Stop once we detected a required use. Otherwise, walk
3179   // until we ran out of nodes, and then declare the barrier redundant.
3180   while (stack.size() &gt; 0) {
3181     Node* n = stack.node();
3182     if (visited.member(n)) {
3183       stack.pop();
3184       continue;
3185     }
3186     visited.push(n);
3187     bool visit_users = false;
3188     switch (n-&gt;Opcode()) {
3189       case Op_CallStaticJava:





3190       case Op_CallDynamicJava:
3191       case Op_CallLeaf:
3192       case Op_CallLeafNoFP:
3193       case Op_CompareAndSwapL:
3194       case Op_CompareAndSwapI:
3195       case Op_CompareAndSwapB:
3196       case Op_CompareAndSwapS:
3197       case Op_CompareAndSwapN:
3198       case Op_CompareAndSwapP:
3199       case Op_CompareAndExchangeL:
3200       case Op_CompareAndExchangeI:
3201       case Op_CompareAndExchangeB:
3202       case Op_CompareAndExchangeS:
3203       case Op_CompareAndExchangeN:
3204       case Op_CompareAndExchangeP:
3205       case Op_WeakCompareAndSwapL:
3206       case Op_WeakCompareAndSwapI:
3207       case Op_WeakCompareAndSwapB:
3208       case Op_WeakCompareAndSwapS:
3209       case Op_WeakCompareAndSwapN:
</pre>
<hr />
<pre>
3311         // Default to have excess barriers, rather than miss some.
3312         return false;
3313 #endif
3314       }
3315     }
3316 
3317     stack.pop();
3318     if (visit_users) {
3319       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
3320         Node* user = n-&gt;fast_out(i);
3321         if (user != NULL) {
3322           stack.push(user, 0);
3323         }
3324       }
3325     }
3326   }
3327 
3328   // No need for barrier found.
3329   return true;
3330 }
<span class="line-added">3331 </span>
<span class="line-added">3332 CallStaticJavaNode* ShenandoahLoadReferenceBarrierNode::pin_and_expand_null_check(PhaseIterGVN&amp; igvn) {</span>
<span class="line-added">3333   Node* val = in(ValueIn);</span>
<span class="line-added">3334 </span>
<span class="line-added">3335   const Type* val_t = igvn.type(val);</span>
<span class="line-added">3336 </span>
<span class="line-added">3337   if (val_t-&gt;meet(TypePtr::NULL_PTR) != val_t &amp;&amp;</span>
<span class="line-added">3338       val-&gt;Opcode() == Op_CastPP &amp;&amp;</span>
<span class="line-added">3339       val-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-added">3340       val-&gt;in(0)-&gt;Opcode() == Op_IfTrue &amp;&amp;</span>
<span class="line-added">3341       val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none) &amp;&amp;</span>
<span class="line-added">3342       val-&gt;in(0)-&gt;in(0)-&gt;is_If() &amp;&amp;</span>
<span class="line-added">3343       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;Opcode() == Op_Bool &amp;&amp;</span>
<span class="line-added">3344       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;</span>
<span class="line-added">3345       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;Opcode() == Op_CmpP &amp;&amp;</span>
<span class="line-added">3346       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1) &amp;&amp;</span>
<span class="line-added">3347       val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(2)-&gt;bottom_type() == TypePtr::NULL_PTR) {</span>
<span class="line-added">3348     assert(val-&gt;in(0)-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;in(1) == val-&gt;in(1), &quot;&quot;);</span>
<span class="line-added">3349     CallStaticJavaNode* unc = val-&gt;in(0)-&gt;as_Proj()-&gt;is_uncommon_trap_if_pattern(Deoptimization::Reason_none);</span>
<span class="line-added">3350     return unc;</span>
<span class="line-added">3351   }</span>
<span class="line-added">3352   return NULL;</span>
<span class="line-added">3353 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahBarrierSetC2.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="shenandoahSupport.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
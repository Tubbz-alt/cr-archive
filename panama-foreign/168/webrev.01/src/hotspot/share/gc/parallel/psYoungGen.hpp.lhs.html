<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/parallel/psYoungGen.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2001, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 26 #define SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
 27 
 28 #include &quot;gc/parallel/mutableSpace.hpp&quot;
 29 #include &quot;gc/parallel/objectStartArray.hpp&quot;
 30 #include &quot;gc/parallel/psGenerationCounters.hpp&quot;
 31 #include &quot;gc/parallel/psVirtualspace.hpp&quot;
 32 #include &quot;gc/parallel/spaceCounters.hpp&quot;
 33 
 34 class PSYoungGen : public CHeapObj&lt;mtGC&gt; {
 35   friend class VMStructs;
 36   friend class ParallelScavengeHeap;
 37   friend class AdjoiningGenerations;
 38 
 39  private:
 40   MemRegion       _reserved;
 41   PSVirtualSpace* _virtual_space;
 42 
 43   // Spaces
 44   MutableSpace* _eden_space;
 45   MutableSpace* _from_space;
 46   MutableSpace* _to_space;
 47 
 48   // Sizing information, in bytes, set in constructor
<a name="1" id="anc1"></a><span class="line-removed"> 49   const size_t _init_gen_size;</span>
 50   const size_t _min_gen_size;
 51   const size_t _max_gen_size;
 52 
 53   // Performance counters
 54   PSGenerationCounters* _gen_counters;
 55   SpaceCounters*        _eden_counters;
 56   SpaceCounters*        _from_counters;
 57   SpaceCounters*        _to_counters;
 58 
 59   // Initialize the space boundaries
 60   void compute_initial_space_boundaries();
 61 
 62   // Space boundary helper
 63   void set_space_boundaries(size_t eden_size, size_t survivor_size);
 64 
 65   bool resize_generation(size_t eden_size, size_t survivor_size);
 66   void resize_spaces(size_t eden_size, size_t survivor_size);
 67 
 68   // Adjust the spaces to be consistent with the virtual space.
 69   void post_resize();
 70 
 71   // Given a desired shrinkage in the size of the young generation,
 72   // return the actual size available for shrinkage.
 73   size_t limit_gen_shrink(size_t desired_change);
 74   // returns the number of bytes available from the current size
 75   // down to the minimum generation size.
 76   size_t available_to_min_gen();
 77   // Return the number of bytes available for shrinkage considering
 78   // the location the live data in the generation.
 79   size_t available_to_live();
 80 
<a name="2" id="anc2"></a><span class="line-modified"> 81   void initialize(ReservedSpace rs, size_t alignment);</span>
 82   void initialize_work();
<a name="3" id="anc3"></a><span class="line-modified"> 83   void initialize_virtual_space(ReservedSpace rs, size_t alignment);</span>
 84 
 85  public:
 86   // Initialize the generation.
 87   PSYoungGen(ReservedSpace rs,
 88              size_t initial_byte_size,
 89              size_t minimum_byte_size,
 90              size_t maximum_byte_size);
 91 
 92   MemRegion reserved() const { return _reserved; }
 93 
 94   bool is_in(const void* p) const {
 95     return _virtual_space-&gt;contains((void *)p);
 96   }
 97 
 98   bool is_in_reserved(const void* p) const {
 99     return reserved().contains((void *)p);
100   }
101 
102   MutableSpace*   eden_space() const    { return _eden_space; }
103   MutableSpace*   from_space() const    { return _from_space; }
104   MutableSpace*   to_space() const      { return _to_space; }
105   PSVirtualSpace* virtual_space() const { return _virtual_space; }
106 
<a name="4" id="anc4"></a><span class="line-removed">107   // For Adaptive size policy</span>
<span class="line-removed">108   size_t min_gen_size() { return _min_gen_size; }</span>
<span class="line-removed">109 </span>
110   // Called during/after GC
111   void swap_spaces();
112 
113   // Resize generation using suggested free space size and survivor size
114   // NOTE:  &quot;eden_size&quot; and &quot;survivor_size&quot; are suggestions only. Current
115   //        heap layout (particularly, live objects in from space) might
116   //        not allow us to use these values.
117   void resize(size_t eden_size, size_t survivor_size);
118 
119   // Size info
120   size_t capacity_in_bytes() const;
121   size_t used_in_bytes() const;
122   size_t free_in_bytes() const;
123 
124   size_t capacity_in_words() const;
125   size_t used_in_words() const;
126   size_t free_in_words() const;
127 
<a name="5" id="anc5"></a><span class="line-modified">128   // The max this generation can grow to</span>
<span class="line-modified">129   size_t max_size() const { return _reserved.byte_size(); }</span>
<span class="line-removed">130 </span>
<span class="line-removed">131   // The max this generation can grow to</span>
<span class="line-removed">132   size_t gen_size_limit() const { return _max_gen_size; }</span>
133 
134   bool is_maximal_no_gc() const {
135     return true;  // Never expands except at a GC
136   }
137 
138   // Allocation
139   HeapWord* allocate(size_t word_size) {
140     HeapWord* result = eden_space()-&gt;cas_allocate(word_size);
141     return result;
142   }
143 
144   HeapWord* volatile* top_addr() const   { return eden_space()-&gt;top_addr(); }
145   HeapWord** end_addr() const   { return eden_space()-&gt;end_addr(); }
146 
147   // Iteration.
148   void oop_iterate(OopIterateClosure* cl);
149   void object_iterate(ObjectClosure* cl);
150 
151   void reset_survivors_after_shrink();
152 
153   // Performance Counter support
154   void update_counters();
155 
156   // Debugging - do not use for time critical operations
157   void print() const;
158   virtual void print_on(outputStream* st) const;
159   const char* name() const { return &quot;PSYoungGen&quot;; }
160 
161   void verify();
162 
163   // Space boundary invariant checker
164   void space_invariants() PRODUCT_RETURN;
165 
166   // Helper for mangling survivor spaces.
167   void mangle_survivors(MutableSpace* s1,
168                         MemRegion s1MR,
169                         MutableSpace* s2,
170                         MemRegion s2MR) PRODUCT_RETURN;
171 
172   void record_spaces_top() PRODUCT_RETURN;
173 };
174 
175 #endif // SHARE_GC_PARALLEL_PSYOUNGGEN_HPP
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
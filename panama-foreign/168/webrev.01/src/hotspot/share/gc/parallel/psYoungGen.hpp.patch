diff a/src/hotspot/share/gc/parallel/psYoungGen.hpp b/src/hotspot/share/gc/parallel/psYoungGen.hpp
--- a/src/hotspot/share/gc/parallel/psYoungGen.hpp
+++ b/src/hotspot/share/gc/parallel/psYoungGen.hpp
@@ -44,11 +44,10 @@
   MutableSpace* _eden_space;
   MutableSpace* _from_space;
   MutableSpace* _to_space;
 
   // Sizing information, in bytes, set in constructor
-  const size_t _init_gen_size;
   const size_t _min_gen_size;
   const size_t _max_gen_size;
 
   // Performance counters
   PSGenerationCounters* _gen_counters;
@@ -76,13 +75,13 @@
   size_t available_to_min_gen();
   // Return the number of bytes available for shrinkage considering
   // the location the live data in the generation.
   size_t available_to_live();
 
-  void initialize(ReservedSpace rs, size_t alignment);
+  void initialize(ReservedSpace rs, size_t inital_size, size_t alignment);
   void initialize_work();
-  void initialize_virtual_space(ReservedSpace rs, size_t alignment);
+  void initialize_virtual_space(ReservedSpace rs, size_t initial_size, size_t alignment);
 
  public:
   // Initialize the generation.
   PSYoungGen(ReservedSpace rs,
              size_t initial_byte_size,
@@ -102,13 +101,10 @@
   MutableSpace*   eden_space() const    { return _eden_space; }
   MutableSpace*   from_space() const    { return _from_space; }
   MutableSpace*   to_space() const      { return _to_space; }
   PSVirtualSpace* virtual_space() const { return _virtual_space; }
 
-  // For Adaptive size policy
-  size_t min_gen_size() { return _min_gen_size; }
-
   // Called during/after GC
   void swap_spaces();
 
   // Resize generation using suggested free space size and survivor size
   // NOTE:  "eden_size" and "survivor_size" are suggestions only. Current
@@ -123,15 +119,12 @@
 
   size_t capacity_in_words() const;
   size_t used_in_words() const;
   size_t free_in_words() const;
 
-  // The max this generation can grow to
-  size_t max_size() const { return _reserved.byte_size(); }
-
-  // The max this generation can grow to
-  size_t gen_size_limit() const { return _max_gen_size; }
+  size_t min_gen_size() const { return _min_gen_size; }
+  size_t max_gen_size() const { return _max_gen_size; }
 
   bool is_maximal_no_gc() const {
     return true;  // Never expands except at a GC
   }
 

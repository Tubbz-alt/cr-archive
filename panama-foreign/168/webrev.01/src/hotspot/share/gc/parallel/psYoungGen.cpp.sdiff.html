<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psYoungGen.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="psScavenge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psYoungGen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(ReservedSpace rs, size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),
<span class="line-removed"> 44   _init_gen_size(initial_size),</span>
 45   _min_gen_size(min_size),
 46   _max_gen_size(max_size),
 47   _gen_counters(NULL),
 48   _eden_counters(NULL),
 49   _from_counters(NULL),
 50   _to_counters(NULL)
 51 {
<span class="line-modified"> 52   initialize(rs, GenAlignment);</span>
 53 }
 54 
<span class="line-modified"> 55 void PSYoungGen::initialize_virtual_space(ReservedSpace rs, size_t alignment) {</span>
<span class="line-modified"> 56   assert(_init_gen_size != 0, &quot;Should have a finite size&quot;);</span>


 57   _virtual_space = new PSVirtualSpace(rs, alignment);
<span class="line-modified"> 58   if (!virtual_space()-&gt;expand_by(_init_gen_size)) {</span>
<span class="line-modified"> 59     vm_exit_during_initialization(&quot;Could not reserve enough space for &quot;</span>
<span class="line-removed"> 60                                   &quot;object heap&quot;);</span>
 61   }
 62 }
 63 
<span class="line-modified"> 64 void PSYoungGen::initialize(ReservedSpace rs, size_t alignment) {</span>
<span class="line-modified"> 65   initialize_virtual_space(rs, alignment);</span>
 66   initialize_work();
 67 }
 68 
 69 void PSYoungGen::initialize_work() {
 70 
 71   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 72                         (HeapWord*)virtual_space()-&gt;high_boundary());

 73 
 74   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 75                 (HeapWord*)virtual_space()-&gt;high());
 76   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 77 
 78   if (ZapUnusedHeapArea) {
 79     // Mangle newly committed space immediately because it
 80     // can be done here more simply that after the new
 81     // spaces have been computed.
 82     SpaceMangler::mangle_region(cmr);
 83   }
 84 
 85   if (UseNUMA) {
 86     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 87   } else {
 88     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 89   }
 90   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 91   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 92 
 93   // Generation Counters - generation 0, 3 subspaces
<span class="line-modified"> 94   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, _min_gen_size,</span>
<span class="line-modified"> 95                                            _max_gen_size, _virtual_space);</span>
 96 
 97   // Compute maximum space sizes for performance counters
 98   size_t alignment = SpaceAlignment;
 99   size_t size = virtual_space()-&gt;reserved_size();
100 
101   size_t max_survivor_size;
102   size_t max_eden_size;
103 
104   if (UseAdaptiveSizePolicy) {
105     max_survivor_size = size / MinSurvivorRatio;
106 
107     // round the survivor space size down to the nearest alignment
108     // and make sure its size is greater than 0.
109     max_survivor_size = align_down(max_survivor_size, alignment);
110     max_survivor_size = MAX2(max_survivor_size, alignment);
111 
112     // set the maximum size of eden to be the size of the young gen
113     // less two times the minimum survivor size. The minimum survivor
114     // size for UseAdaptiveSizePolicy is one alignment.
115     max_eden_size = size - 2 * alignment;
</pre>
<hr />
<pre>
241   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
242 
243   virtual_space()-&gt;verify();
244 }
245 #endif
246 
247 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
248   // Resize the generation if needed. If the generation resize
249   // reports false, do not attempt to resize the spaces.
250   if (resize_generation(eden_size, survivor_size)) {
251     // Then we lay out the spaces inside the generation
252     resize_spaces(eden_size, survivor_size);
253 
254     space_invariants();
255 
256     log_trace(gc, ergo)(&quot;Young generation size: &quot;
257                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
258                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
259                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
260                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
<span class="line-modified">261                         _max_gen_size, min_gen_size());</span>
262   }
263 }
264 
265 
266 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
267   const size_t alignment = virtual_space()-&gt;alignment();
268   size_t orig_size = virtual_space()-&gt;committed_size();
269   bool size_changed = false;
270 
271   // There used to be this guarantee there.
<span class="line-modified">272   // guarantee ((eden_size + 2*survivor_size)  &lt;= _max_gen_size, &quot;incorrect input arguments&quot;);</span>
273   // Code below forces this requirement.  In addition the desired eden
274   // size and desired survivor sizes are desired goals and may
275   // exceed the total generation size.
276 
<span class="line-modified">277   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_size(), &quot;just checking&quot;);</span>
278 
279   // Adjust new generation size
280   const size_t eden_plus_survivors =
281           align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">282   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_size());</span>
<span class="line-modified">283   assert(desired_size &lt;= max_size(), &quot;just checking&quot;);</span>
284 
285   if (desired_size &gt; orig_size) {
286     // Grow the generation
287     size_t change = desired_size - orig_size;
288     assert(change % alignment == 0, &quot;just checking&quot;);
289     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
290     if (!virtual_space()-&gt;expand_by(change)) {
291       return false; // Error if we fail to resize!
292     }
293     if (ZapUnusedHeapArea) {
294       // Mangle newly committed space immediately because it
295       // can be done here more simply that after the new
296       // spaces have been computed.
297       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
298       MemRegion mangle_region(prev_high, new_high);
299       SpaceMangler::mangle_region(mangle_region);
300     }
301     size_changed = true;
302   } else if (desired_size &lt; orig_size) {
303     size_t desired_change = orig_size - desired_size;
304     assert(desired_change % alignment == 0, &quot;just checking&quot;);
305 
306     desired_change = limit_gen_shrink(desired_change);
307 
308     if (desired_change &gt; 0) {
309       virtual_space()-&gt;shrink_by(desired_change);
310       reset_survivors_after_shrink();
311 
312       size_changed = true;
313     }
314   } else {
<span class="line-modified">315     if (orig_size == gen_size_limit()) {</span>
316       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
317     } else if (orig_size == min_gen_size()) {
318       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
319     }
320   }
321 
322   if (size_changed) {
323     post_resize();
324     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
325                   orig_size/K, virtual_space()-&gt;committed_size()/K);
326   }
327 
328   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
<span class="line-modified">329             virtual_space()-&gt;committed_size() == max_size(), &quot;Sanity&quot;);</span>
330 
331   return true;
332 }
333 
334 #ifndef PRODUCT
335 // In the numa case eden is not mangled so a survivor space
336 // moving into a region previously occupied by a survivor
337 // may find an unmangled region.  Also in the PS case eden
338 // to-space and from-space may not touch (i.e., there may be
339 // gaps between them due to movement while resizing the
340 // spaces).  Those gaps must be mangled.
341 void PSYoungGen::mangle_survivors(MutableSpace* s1,
342                                   MemRegion s1MR,
343                                   MutableSpace* s2,
344                                   MemRegion s2MR) {
345   // Check eden and gap between eden and from-space, in deciding
346   // what to mangle in from-space.  Check the gap between from-space
347   // and to-space when deciding what to mangle.
348   //
349   //      +--------+   +----+    +---+
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/parallel/mutableNUMASpace.hpp&quot;
 27 #include &quot;gc/parallel/parallelScavengeHeap.hpp&quot;
 28 #include &quot;gc/parallel/psScavenge.hpp&quot;
 29 #include &quot;gc/parallel/psYoungGen.hpp&quot;
 30 #include &quot;gc/shared/gcUtil.hpp&quot;
 31 #include &quot;gc/shared/genArguments.hpp&quot;
 32 #include &quot;gc/shared/spaceDecorator.inline.hpp&quot;
 33 #include &quot;logging/log.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;runtime/java.hpp&quot;
 36 #include &quot;utilities/align.hpp&quot;
 37 
 38 PSYoungGen::PSYoungGen(ReservedSpace rs, size_t initial_size, size_t min_size, size_t max_size) :
 39   _reserved(),
 40   _virtual_space(NULL),
 41   _eden_space(NULL),
 42   _from_space(NULL),
 43   _to_space(NULL),

 44   _min_gen_size(min_size),
 45   _max_gen_size(max_size),
 46   _gen_counters(NULL),
 47   _eden_counters(NULL),
 48   _from_counters(NULL),
 49   _to_counters(NULL)
 50 {
<span class="line-modified"> 51   initialize(rs, initial_size, GenAlignment);</span>
 52 }
 53 
<span class="line-modified"> 54 void PSYoungGen::initialize_virtual_space(ReservedSpace rs,</span>
<span class="line-modified"> 55                                           size_t initial_size,</span>
<span class="line-added"> 56                                           size_t alignment) {</span>
<span class="line-added"> 57   assert(initial_size != 0, &quot;Should have a finite size&quot;);</span>
 58   _virtual_space = new PSVirtualSpace(rs, alignment);
<span class="line-modified"> 59   if (!virtual_space()-&gt;expand_by(initial_size)) {</span>
<span class="line-modified"> 60     vm_exit_during_initialization(&quot;Could not reserve enough space for object heap&quot;);</span>

 61   }
 62 }
 63 
<span class="line-modified"> 64 void PSYoungGen::initialize(ReservedSpace rs, size_t initial_size, size_t alignment) {</span>
<span class="line-modified"> 65   initialize_virtual_space(rs, initial_size, alignment);</span>
 66   initialize_work();
 67 }
 68 
 69 void PSYoungGen::initialize_work() {
 70 
 71   _reserved = MemRegion((HeapWord*)virtual_space()-&gt;low_boundary(),
 72                         (HeapWord*)virtual_space()-&gt;high_boundary());
<span class="line-added"> 73   assert(_reserved.byte_size() == max_gen_size(), &quot;invariant&quot;);</span>
 74 
 75   MemRegion cmr((HeapWord*)virtual_space()-&gt;low(),
 76                 (HeapWord*)virtual_space()-&gt;high());
 77   ParallelScavengeHeap::heap()-&gt;card_table()-&gt;resize_covered_region(cmr);
 78 
 79   if (ZapUnusedHeapArea) {
 80     // Mangle newly committed space immediately because it
 81     // can be done here more simply that after the new
 82     // spaces have been computed.
 83     SpaceMangler::mangle_region(cmr);
 84   }
 85 
 86   if (UseNUMA) {
 87     _eden_space = new MutableNUMASpace(virtual_space()-&gt;alignment());
 88   } else {
 89     _eden_space = new MutableSpace(virtual_space()-&gt;alignment());
 90   }
 91   _from_space = new MutableSpace(virtual_space()-&gt;alignment());
 92   _to_space   = new MutableSpace(virtual_space()-&gt;alignment());
 93 
 94   // Generation Counters - generation 0, 3 subspaces
<span class="line-modified"> 95   _gen_counters = new PSGenerationCounters(&quot;new&quot;, 0, 3, min_gen_size(),</span>
<span class="line-modified"> 96                                            max_gen_size(), virtual_space());</span>
 97 
 98   // Compute maximum space sizes for performance counters
 99   size_t alignment = SpaceAlignment;
100   size_t size = virtual_space()-&gt;reserved_size();
101 
102   size_t max_survivor_size;
103   size_t max_eden_size;
104 
105   if (UseAdaptiveSizePolicy) {
106     max_survivor_size = size / MinSurvivorRatio;
107 
108     // round the survivor space size down to the nearest alignment
109     // and make sure its size is greater than 0.
110     max_survivor_size = align_down(max_survivor_size, alignment);
111     max_survivor_size = MAX2(max_survivor_size, alignment);
112 
113     // set the maximum size of eden to be the size of the young gen
114     // less two times the minimum survivor size. The minimum survivor
115     // size for UseAdaptiveSizePolicy is one alignment.
116     max_eden_size = size - 2 * alignment;
</pre>
<hr />
<pre>
242   assert(to_top &lt;= virtual_space()-&gt;high(), &quot;to top&quot;);
243 
244   virtual_space()-&gt;verify();
245 }
246 #endif
247 
248 void PSYoungGen::resize(size_t eden_size, size_t survivor_size) {
249   // Resize the generation if needed. If the generation resize
250   // reports false, do not attempt to resize the spaces.
251   if (resize_generation(eden_size, survivor_size)) {
252     // Then we lay out the spaces inside the generation
253     resize_spaces(eden_size, survivor_size);
254 
255     space_invariants();
256 
257     log_trace(gc, ergo)(&quot;Young generation size: &quot;
258                         &quot;desired eden: &quot; SIZE_FORMAT &quot; survivor: &quot; SIZE_FORMAT
259                         &quot; used: &quot; SIZE_FORMAT &quot; capacity: &quot; SIZE_FORMAT
260                         &quot; gen limits: &quot; SIZE_FORMAT &quot; / &quot; SIZE_FORMAT,
261                         eden_size, survivor_size, used_in_bytes(), capacity_in_bytes(),
<span class="line-modified">262                         max_gen_size(), min_gen_size());</span>
263   }
264 }
265 
266 
267 bool PSYoungGen::resize_generation(size_t eden_size, size_t survivor_size) {
268   const size_t alignment = virtual_space()-&gt;alignment();
269   size_t orig_size = virtual_space()-&gt;committed_size();
270   bool size_changed = false;
271 
272   // There used to be this guarantee there.
<span class="line-modified">273   // guarantee ((eden_size + 2*survivor_size)  &lt;= max_gen_size(), &quot;incorrect input arguments&quot;);</span>
274   // Code below forces this requirement.  In addition the desired eden
275   // size and desired survivor sizes are desired goals and may
276   // exceed the total generation size.
277 
<span class="line-modified">278   assert(min_gen_size() &lt;= orig_size &amp;&amp; orig_size &lt;= max_gen_size(), &quot;just checking&quot;);</span>
279 
280   // Adjust new generation size
281   const size_t eden_plus_survivors =
282           align_up(eden_size + 2 * survivor_size, alignment);
<span class="line-modified">283   size_t desired_size = clamp(eden_plus_survivors, min_gen_size(), max_gen_size());</span>
<span class="line-modified">284   assert(desired_size &lt;= max_gen_size(), &quot;just checking&quot;);</span>
285 
286   if (desired_size &gt; orig_size) {
287     // Grow the generation
288     size_t change = desired_size - orig_size;
289     assert(change % alignment == 0, &quot;just checking&quot;);
290     HeapWord* prev_high = (HeapWord*) virtual_space()-&gt;high();
291     if (!virtual_space()-&gt;expand_by(change)) {
292       return false; // Error if we fail to resize!
293     }
294     if (ZapUnusedHeapArea) {
295       // Mangle newly committed space immediately because it
296       // can be done here more simply that after the new
297       // spaces have been computed.
298       HeapWord* new_high = (HeapWord*) virtual_space()-&gt;high();
299       MemRegion mangle_region(prev_high, new_high);
300       SpaceMangler::mangle_region(mangle_region);
301     }
302     size_changed = true;
303   } else if (desired_size &lt; orig_size) {
304     size_t desired_change = orig_size - desired_size;
305     assert(desired_change % alignment == 0, &quot;just checking&quot;);
306 
307     desired_change = limit_gen_shrink(desired_change);
308 
309     if (desired_change &gt; 0) {
310       virtual_space()-&gt;shrink_by(desired_change);
311       reset_survivors_after_shrink();
312 
313       size_changed = true;
314     }
315   } else {
<span class="line-modified">316     if (orig_size == max_gen_size()) {</span>
317       log_trace(gc)(&quot;PSYoung generation size at maximum: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
318     } else if (orig_size == min_gen_size()) {
319       log_trace(gc)(&quot;PSYoung generation size at minium: &quot; SIZE_FORMAT &quot;K&quot;, orig_size/K);
320     }
321   }
322 
323   if (size_changed) {
324     post_resize();
325     log_trace(gc)(&quot;PSYoung generation size changed: &quot; SIZE_FORMAT &quot;K-&gt;&quot; SIZE_FORMAT &quot;K&quot;,
326                   orig_size/K, virtual_space()-&gt;committed_size()/K);
327   }
328 
329   guarantee(eden_plus_survivors &lt;= virtual_space()-&gt;committed_size() ||
<span class="line-modified">330             virtual_space()-&gt;committed_size() == max_gen_size(), &quot;Sanity&quot;);</span>
331 
332   return true;
333 }
334 
335 #ifndef PRODUCT
336 // In the numa case eden is not mangled so a survivor space
337 // moving into a region previously occupied by a survivor
338 // may find an unmangled region.  Also in the PS case eden
339 // to-space and from-space may not touch (i.e., there may be
340 // gaps between them due to movement while resizing the
341 // spaces).  Those gaps must be mangled.
342 void PSYoungGen::mangle_survivors(MutableSpace* s1,
343                                   MemRegion s1MR,
344                                   MutableSpace* s2,
345                                   MemRegion s2MR) {
346   // Check eden and gap between eden and from-space, in deciding
347   // what to mangle in from-space.  Check the gap between from-space
348   // and to-space when deciding what to mangle.
349   //
350   //      +--------+   +----+    +---+
</pre>
</td>
</tr>
</table>
<center><a href="psScavenge.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="psYoungGen.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
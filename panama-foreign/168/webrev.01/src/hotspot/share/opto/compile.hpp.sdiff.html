<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 300   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 301   int                   _loop_opts_cnt;         // loop opts round
 302   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry
 303 
 304   // Compilation environment.
 305   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 306   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 307   ciEnv*                _env;                   // CI interface
 308   DirectiveSet*         _directive;             // Compiler directive
 309   CompileLog*           _log;                   // from CompilerThread
 310   const char*           _failure_reason;        // for record_failure/failing pattern
 311   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 312   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 313   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 314   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 315   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 316   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 317   ConnectionGraph*      _congraph;
 318 #ifndef PRODUCT
 319   IdealGraphPrinter*    _printer;


 320 #endif
 321 
 322 
 323   // Node management
 324   uint                  _unique;                // Counter for unique Node indices
 325   VectorSet             _dead_node_list;        // Set of dead nodes
 326   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 327                                                 // So use this to keep count and make the call O(1).
 328   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 329 
 330   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 331   Arena                 _node_arena;            // Arena for new-space Nodes
 332   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 333   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 334   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 335 
 336   Node*                 _immutable_memory;      // Initial memory state
 337 
 338   Node*                 _recent_alloc_obj;
 339   Node*                 _recent_alloc_ctl;
</pre>
<hr />
<pre>
 612 
 613   Ticks _latest_stage_start_counter;
 614 
 615   void begin_method() {
 616 #ifndef PRODUCT
 617     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 618       _printer-&gt;begin_method();
 619     }
 620 #endif
 621     C-&gt;_latest_stage_start_counter.stamp();
 622   }
 623 
 624   bool should_print(int level = 1) {
 625 #ifndef PRODUCT
 626     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 627 #else
 628     return false;
 629 #endif
 630   }
 631 
<span class="line-modified"> 632   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {</span>
<span class="line-removed"> 633     EventCompilerPhase event;</span>
<span class="line-removed"> 634     if (event.should_commit()) {</span>
<span class="line-removed"> 635       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);</span>
<span class="line-removed"> 636     }</span>
 637 
 638 #ifndef PRODUCT
<span class="line-modified"> 639     if (should_print(level)) {</span>
<span class="line-modified"> 640       char output[1024];</span>
<span class="line-modified"> 641       if (idx != 0) {</span>
<span class="line-modified"> 642         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
<span class="line-removed"> 643       } else {</span>
<span class="line-removed"> 644         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
<span class="line-removed"> 645       }</span>
<span class="line-removed"> 646       _printer-&gt;print_method(output, level);</span>
<span class="line-removed"> 647     }</span>
 648 #endif
<span class="line-removed"> 649     C-&gt;_latest_stage_start_counter.stamp();</span>
<span class="line-removed"> 650   }</span>
 651 
<span class="line-modified"> 652   void end_method(int level = 1) {</span>
<span class="line-removed"> 653     EventCompilerPhase event;</span>
<span class="line-removed"> 654     if (event.should_commit()) {</span>
<span class="line-removed"> 655       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);</span>
<span class="line-removed"> 656     }</span>
<span class="line-removed"> 657 </span>
<span class="line-removed"> 658 #ifndef PRODUCT</span>
<span class="line-removed"> 659     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {</span>
<span class="line-removed"> 660       _printer-&gt;end_method();</span>
<span class="line-removed"> 661     }</span>
<span class="line-removed"> 662 #endif</span>
<span class="line-removed"> 663   }</span>
 664 
 665   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 666   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 667   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 668   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 669   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 670   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 671   ConnectionGraph* congraph()                   { return _congraph;}
 672   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 673   void add_macro_node(Node * n) {
 674     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 675     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 676     _macro_nodes-&gt;append(n);
 677   }
 678   void remove_macro_node(Node * n) {
 679     // this function may be called twice for a node so check
 680     // that the node is in the array before attempting to remove it
 681     if (_macro_nodes-&gt;contains(n))
 682       _macro_nodes-&gt;remove(n);
 683     // remove from _predicate_opaqs list also if it is there
</pre>
</td>
<td>
<hr />
<pre>
 300   RTMState              _rtm_state;             // State of Restricted Transactional Memory usage
 301   int                   _loop_opts_cnt;         // loop opts round
 302   bool                  _clinit_barrier_on_entry; // True if clinit barrier is needed on nmethod entry
 303 
 304   // Compilation environment.
 305   Arena                 _comp_arena;            // Arena with lifetime equivalent to Compile
 306   void*                 _barrier_set_state;     // Potential GC barrier state for Compile
 307   ciEnv*                _env;                   // CI interface
 308   DirectiveSet*         _directive;             // Compiler directive
 309   CompileLog*           _log;                   // from CompilerThread
 310   const char*           _failure_reason;        // for record_failure/failing pattern
 311   GrowableArray&lt;CallGenerator*&gt;* _intrinsics;   // List of intrinsics.
 312   GrowableArray&lt;Node*&gt;* _macro_nodes;           // List of nodes which need to be expanded before matching.
 313   GrowableArray&lt;Node*&gt;* _predicate_opaqs;       // List of Opaque1 nodes for the loop predicates.
 314   GrowableArray&lt;Node*&gt;* _expensive_nodes;       // List of nodes that are expensive to compute and that we&#39;d better not let the GVN freely common
 315   GrowableArray&lt;Node*&gt;* _range_check_casts;     // List of CastII nodes with a range check dependency
 316   GrowableArray&lt;Node*&gt;* _opaque4_nodes;         // List of Opaque4 nodes that have a default value
 317   ConnectionGraph*      _congraph;
 318 #ifndef PRODUCT
 319   IdealGraphPrinter*    _printer;
<span class="line-added"> 320   static IdealGraphPrinter* _debug_file_printer;</span>
<span class="line-added"> 321   static IdealGraphPrinter* _debug_network_printer;</span>
 322 #endif
 323 
 324 
 325   // Node management
 326   uint                  _unique;                // Counter for unique Node indices
 327   VectorSet             _dead_node_list;        // Set of dead nodes
 328   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 329                                                 // So use this to keep count and make the call O(1).
 330   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 331 
 332   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 333   Arena                 _node_arena;            // Arena for new-space Nodes
 334   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 335   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 336   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 337 
 338   Node*                 _immutable_memory;      // Initial memory state
 339 
 340   Node*                 _recent_alloc_obj;
 341   Node*                 _recent_alloc_ctl;
</pre>
<hr />
<pre>
 614 
 615   Ticks _latest_stage_start_counter;
 616 
 617   void begin_method() {
 618 #ifndef PRODUCT
 619     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 620       _printer-&gt;begin_method();
 621     }
 622 #endif
 623     C-&gt;_latest_stage_start_counter.stamp();
 624   }
 625 
 626   bool should_print(int level = 1) {
 627 #ifndef PRODUCT
 628     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 629 #else
 630     return false;
 631 #endif
 632   }
 633 
<span class="line-modified"> 634   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0);</span>




 635 
 636 #ifndef PRODUCT
<span class="line-modified"> 637   void igv_print_method_to_file(const char* phase_name = &quot;Debug&quot;, bool append = false);</span>
<span class="line-modified"> 638   void igv_print_method_to_network(const char* phase_name = &quot;Debug&quot;);</span>
<span class="line-modified"> 639   static IdealGraphPrinter* debug_file_printer() { return _debug_file_printer; }</span>
<span class="line-modified"> 640   static IdealGraphPrinter* debug_network_printer() { return _debug_network_printer; }</span>





 641 #endif


 642 
<span class="line-modified"> 643   void end_method(int level = 1);</span>











 644 
 645   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 646   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 647   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 648   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 649   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 650   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 651   ConnectionGraph* congraph()                   { return _congraph;}
 652   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 653   void add_macro_node(Node * n) {
 654     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 655     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 656     _macro_nodes-&gt;append(n);
 657   }
 658   void remove_macro_node(Node * n) {
 659     // this function may be called twice for a node so check
 660     // that the node is in the array before attempting to remove it
 661     if (_macro_nodes-&gt;contains(n))
 662       _macro_nodes-&gt;remove(n);
 663     // remove from _predicate_opaqs list also if it is there
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
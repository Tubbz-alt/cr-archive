<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/idealGraphPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/idealGraphPrinter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 75 int IdealGraphPrinter::_file_count = 0;
 76 
 77 IdealGraphPrinter *IdealGraphPrinter::printer() {
 78   if (!PrintIdealGraph) {
 79     return NULL;
 80   }
 81 
 82   JavaThread *thread = JavaThread::current();
 83   if (!thread-&gt;is_Compiler_thread()) return NULL;
 84 
 85   CompilerThread *compiler_thread = (CompilerThread *)thread;
 86   if (compiler_thread-&gt;ideal_graph_printer() == NULL) {
 87     IdealGraphPrinter *printer = new IdealGraphPrinter();
 88     compiler_thread-&gt;set_ideal_graph_printer(printer);
 89   }
 90 
 91   return compiler_thread-&gt;ideal_graph_printer();
 92 }
 93 
 94 void IdealGraphPrinter::clean_up() {
<span class="line-modified"> 95   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *p = jtiwh.next(); ) {</span>
 96     if (p-&gt;is_Compiler_thread()) {
<span class="line-modified"> 97       CompilerThread *c = (CompilerThread *)p;</span>
<span class="line-modified"> 98       IdealGraphPrinter *printer = c-&gt;ideal_graph_printer();</span>
 99       if (printer) {
100         delete printer;
101       }
102       c-&gt;set_ideal_graph_printer(NULL);
103     }
104   }








105 }
106 
<span class="line-modified">107 // Constructor, either file or network output</span>
108 IdealGraphPrinter::IdealGraphPrinter() {


109 
















110   // By default dump both ins and outs since dead or unreachable code
111   // needs to appear in the graph.  There are also some special cases
112   // in the mach where kill projections have no users but should
113   // appear in the dump.
114   _traverse_outs = true;
115   _should_send_method = true;
116   _output = NULL;
117   buffer[0] = 0;
118   _depth = 0;
119   _current_method = NULL;
<span class="line-modified">120   assert(!_current_method, &quot;current method must be initialized to NULL&quot;);</span>
<span class="line-modified">121   _stream = NULL;</span>
<span class="line-modified">122 </span>
<span class="line-modified">123   if (PrintIdealGraphFile != NULL) {</span>
<span class="line-removed">124     ThreadCritical tc;</span>
<span class="line-removed">125     // User wants all output to go to files</span>
<span class="line-removed">126     if (_file_count != 0) {</span>
<span class="line-removed">127       ResourceMark rm;</span>
<span class="line-removed">128       stringStream st;</span>
<span class="line-removed">129       const char* dot = strrchr(PrintIdealGraphFile, &#39;.&#39;);</span>
<span class="line-removed">130       if (dot) {</span>
<span class="line-removed">131         st.write(PrintIdealGraphFile, dot - PrintIdealGraphFile);</span>
<span class="line-removed">132         st.print(&quot;%d%s&quot;, _file_count, dot);</span>
<span class="line-removed">133       } else {</span>
<span class="line-removed">134         st.print(&quot;%s%d&quot;, PrintIdealGraphFile, _file_count);</span>
<span class="line-removed">135       }</span>
<span class="line-removed">136       fileStream *stream = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string());</span>
<span class="line-removed">137       _output = stream;</span>
<span class="line-removed">138     } else {</span>
<span class="line-removed">139       fileStream *stream = new (ResourceObj::C_HEAP, mtCompiler) fileStream(PrintIdealGraphFile);</span>
<span class="line-removed">140       _output = stream;</span>
<span class="line-removed">141     }</span>
<span class="line-removed">142     _file_count++;</span>
143   } else {
<span class="line-modified">144     _stream = new (ResourceObj::C_HEAP, mtCompiler) networkStream();</span>
<span class="line-removed">145 </span>
<span class="line-removed">146     // Try to connect to visualizer</span>
<span class="line-removed">147     if (_stream-&gt;connect(PrintIdealGraphAddress, PrintIdealGraphPort)) {</span>
<span class="line-removed">148       char c = 0;</span>
<span class="line-removed">149       _stream-&gt;read(&amp;c, 1);</span>
<span class="line-removed">150       if (c != &#39;y&#39;) {</span>
<span class="line-removed">151         tty-&gt;print_cr(&quot;Client available, but does not want to receive data!&quot;);</span>
<span class="line-removed">152         _stream-&gt;close();</span>
<span class="line-removed">153         delete _stream;</span>
<span class="line-removed">154         _stream = NULL;</span>
<span class="line-removed">155         return;</span>
<span class="line-removed">156       }</span>
<span class="line-removed">157       _output = _stream;</span>
<span class="line-removed">158     } else {</span>
<span class="line-removed">159       // It would be nice if we could shut down cleanly but it should</span>
<span class="line-removed">160       // be an error if we can&#39;t connect to the visualizer.</span>
<span class="line-removed">161       fatal(&quot;Couldn&#39;t connect to visualizer at %s:&quot; INTX_FORMAT,</span>
<span class="line-removed">162             PrintIdealGraphAddress, PrintIdealGraphPort);</span>
<span class="line-removed">163     }</span>
164   }
<span class="line-removed">165 </span>
166   _xml = new (ResourceObj::C_HEAP, mtCompiler) xmlStream(_output);
<span class="line-modified">167 </span>
<span class="line-modified">168   head(TOP_ELEMENT);</span>

169 }
170 
171 // Destructor, close file or network stream
172 IdealGraphPrinter::~IdealGraphPrinter() {
<span class="line-removed">173 </span>
174   tail(TOP_ELEMENT);
175 
176   // tty-&gt;print_cr(&quot;Walk time: %d&quot;, (int)_walk_time.milliseconds());
177   // tty-&gt;print_cr(&quot;Output time: %d&quot;, (int)_output_time.milliseconds());
178   // tty-&gt;print_cr(&quot;Build blocks time: %d&quot;, (int)_build_blocks_time.milliseconds());
179 
180   if(_xml) {
181     delete _xml;
182     _xml = NULL;
183   }
184 
<span class="line-modified">185   if (_stream) {</span>
<span class="line-modified">186     delete _stream;</span>
<span class="line-modified">187     if (_stream == _output) {</span>
188       _output = NULL;
189     }
<span class="line-modified">190     _stream = NULL;</span>
191   }
192 
193   if (_output) {
194     delete _output;
195     _output = NULL;
196   }
197 }
198 
199 void IdealGraphPrinter::begin_elem(const char *s) {
200   _xml-&gt;begin_elem(&quot;%s&quot;, s);
201 }
202 
203 void IdealGraphPrinter::end_elem() {
204   _xml-&gt;end_elem();
205 }
206 
207 void IdealGraphPrinter::begin_head(const char *s) {
208   _xml-&gt;begin_head(&quot;%s&quot;, s);
209 }
210 
</pre>
<hr />
<pre>
268   head(BYTECODES_ELEMENT);
269   _xml-&gt;print_cr(&quot;&lt;![CDATA[&quot;);
270   method-&gt;print_codes_on(_xml);
271   _xml-&gt;print_cr(&quot;]]&gt;&quot;);
272   tail(BYTECODES_ELEMENT);
273 
274   if (tree != NULL &amp;&amp; tree-&gt;subtrees().length() &gt; 0) {
275     head(INLINE_ELEMENT);
276     GrowableArray&lt;InlineTree *&gt; subtrees = tree-&gt;subtrees();
277     for (int i = 0; i &lt; subtrees.length(); i++) {
278       print_inline_tree(subtrees.at(i));
279     }
280     tail(INLINE_ELEMENT);
281   }
282 
283   tail(METHOD_ELEMENT);
284   _xml-&gt;flush();
285 }
286 
287 void IdealGraphPrinter::print_inline_tree(InlineTree *tree) {
<span class="line-modified">288 </span>
<span class="line-modified">289   if (tree == NULL) return;</span>
<span class="line-modified">290 </span>
<span class="line-removed">291   ciMethod *method = tree-&gt;method();</span>
<span class="line-removed">292   print_method(tree-&gt;method(), tree-&gt;caller_bci(), tree);</span>
<span class="line-removed">293 </span>
294 }
295 
296 void IdealGraphPrinter::print_inlining() {
297 
298   // Print inline tree
299   if (_should_send_method) {
300     InlineTree *inlineTree = C-&gt;ilt();
301     if (inlineTree != NULL) {
302       print_inline_tree(inlineTree);
303     } else {
304       // print this method only
305     }
306   }
307 }
308 
309 // Has to be called whenever a method is compiled
310 void IdealGraphPrinter::begin_method() {
311 
312   ciMethod *method = C-&gt;method();
313   assert(_output, &quot;output stream must exist!&quot;);
</pre>
<hr />
<pre>
325   print_prop(METHOD_NAME_PROPERTY, strStream.as_string());
326 
327   if (method-&gt;flags().is_public()) {
328     print_prop(METHOD_IS_PUBLIC_PROPERTY, TRUE_VALUE);
329   }
330 
331   if (method-&gt;flags().is_static()) {
332     print_prop(METHOD_IS_STATIC_PROPERTY, TRUE_VALUE);
333   }
334 
335   tail(PROPERTIES_ELEMENT);
336 
337   _should_send_method = true;
338   this-&gt;_current_method = method;
339 
340   _xml-&gt;flush();
341 }
342 
343 // Has to be called whenever a method has finished compilation
344 void IdealGraphPrinter::end_method() {
<span class="line-removed">345 </span>
<span class="line-removed">346   nmethod* method = (nmethod*)this-&gt;_current_method-&gt;code();</span>
<span class="line-removed">347 </span>
348   tail(GROUP_ELEMENT);
349   _current_method = NULL;
350   _xml-&gt;flush();
351 }
352 
353 bool IdealGraphPrinter::traverse_outs() {
354   return _traverse_outs;
355 }
356 
357 void IdealGraphPrinter::set_traverse_outs(bool b) {
358   _traverse_outs = b;
359 }
360 
361 void IdealGraphPrinter::visit_node(Node *n, bool edges, VectorSet* temp_set) {
362 
363   if (edges) {
364 
365     // Output edge
366     node_idx_t dest_id = n-&gt;_idx;
367     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
</pre>
<hr />
<pre>
698       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
699         begin_elem(NODE_ELEMENT);
700         print_attr(NODE_ID_PROPERTY, block-&gt;get_node(s)-&gt;_idx);
701         end_elem();
702       }
703       tail(NODES_ELEMENT);
704 
705       tail(BLOCK_ELEMENT);
706     }
707     tail(CONTROL_FLOW_ELEMENT);
708   }
709   tail(GRAPH_ELEMENT);
710   _xml-&gt;flush();
711 }
712 
713 // Should method be printed?
714 bool IdealGraphPrinter::should_print(int level) {
715   return C-&gt;directive()-&gt;IGVPrintLevelOption &gt;= level;
716 }
717 























































718 extern const char *NodeClassNames[];
719 
720 #endif
</pre>
</td>
<td>
<hr />
<pre>
 75 int IdealGraphPrinter::_file_count = 0;
 76 
 77 IdealGraphPrinter *IdealGraphPrinter::printer() {
 78   if (!PrintIdealGraph) {
 79     return NULL;
 80   }
 81 
 82   JavaThread *thread = JavaThread::current();
 83   if (!thread-&gt;is_Compiler_thread()) return NULL;
 84 
 85   CompilerThread *compiler_thread = (CompilerThread *)thread;
 86   if (compiler_thread-&gt;ideal_graph_printer() == NULL) {
 87     IdealGraphPrinter *printer = new IdealGraphPrinter();
 88     compiler_thread-&gt;set_ideal_graph_printer(printer);
 89   }
 90 
 91   return compiler_thread-&gt;ideal_graph_printer();
 92 }
 93 
 94 void IdealGraphPrinter::clean_up() {
<span class="line-modified"> 95   for (JavaThreadIteratorWithHandle jtiwh; JavaThread* p = jtiwh.next(); ) {</span>
 96     if (p-&gt;is_Compiler_thread()) {
<span class="line-modified"> 97       CompilerThread* c = (CompilerThread*)p;</span>
<span class="line-modified"> 98       IdealGraphPrinter* printer = c-&gt;ideal_graph_printer();</span>
 99       if (printer) {
100         delete printer;
101       }
102       c-&gt;set_ideal_graph_printer(NULL);
103     }
104   }
<span class="line-added">105   IdealGraphPrinter* debug_file_printer = Compile::debug_file_printer();</span>
<span class="line-added">106   if (debug_file_printer != NULL) {</span>
<span class="line-added">107     delete debug_file_printer;</span>
<span class="line-added">108   }</span>
<span class="line-added">109   IdealGraphPrinter* debug_network_printer = Compile::debug_network_printer();</span>
<span class="line-added">110   if (debug_network_printer != NULL) {</span>
<span class="line-added">111     delete debug_network_printer;</span>
<span class="line-added">112   }</span>
113 }
114 
<span class="line-modified">115 // Either print methods to file specified with PrintIdealGraphFile or otherwise over the network to the IGV</span>
116 IdealGraphPrinter::IdealGraphPrinter() {
<span class="line-added">117   init(PrintIdealGraphFile, true, false);</span>
<span class="line-added">118 }</span>
119 
<span class="line-added">120 // Either print methods to the specified file &#39;file_name&#39; or if NULL over the network to the IGV. If &#39;append&#39;</span>
<span class="line-added">121 // is set, the next phase is directly appended to the specified file &#39;file_name&#39;. This is useful when doing</span>
<span class="line-added">122 // replay compilation with a tool like rr that cannot alter the current program state but only the file.</span>
<span class="line-added">123 IdealGraphPrinter::IdealGraphPrinter(Compile* compile, const char* file_name, bool append) {</span>
<span class="line-added">124   assert(!append || (append &amp;&amp; file_name != NULL), &quot;can only use append flag when printing to file&quot;);</span>
<span class="line-added">125   init(file_name, false, append);</span>
<span class="line-added">126   C = compile;</span>
<span class="line-added">127   if (append) {</span>
<span class="line-added">128     // When directly appending the next graph, we only need to set _current_method and not set up a new method</span>
<span class="line-added">129     _current_method = C-&gt;method();</span>
<span class="line-added">130   } else {</span>
<span class="line-added">131     begin_method();</span>
<span class="line-added">132   }</span>
<span class="line-added">133 }</span>
<span class="line-added">134 </span>
<span class="line-added">135 void IdealGraphPrinter::init(const char* file_name, bool use_multiple_files, bool append) {</span>
136   // By default dump both ins and outs since dead or unreachable code
137   // needs to appear in the graph.  There are also some special cases
138   // in the mach where kill projections have no users but should
139   // appear in the dump.
140   _traverse_outs = true;
141   _should_send_method = true;
142   _output = NULL;
143   buffer[0] = 0;
144   _depth = 0;
145   _current_method = NULL;
<span class="line-modified">146   _network_stream = NULL;</span>
<span class="line-modified">147 </span>
<span class="line-modified">148   if (file_name != NULL) {</span>
<span class="line-modified">149     init_file_stream(file_name, use_multiple_files, append);</span>



















150   } else {
<span class="line-modified">151     init_network_stream();</span>



















152   }

153   _xml = new (ResourceObj::C_HEAP, mtCompiler) xmlStream(_output);
<span class="line-modified">154   if (!append) {</span>
<span class="line-modified">155     head(TOP_ELEMENT);</span>
<span class="line-added">156   }</span>
157 }
158 
159 // Destructor, close file or network stream
160 IdealGraphPrinter::~IdealGraphPrinter() {

161   tail(TOP_ELEMENT);
162 
163   // tty-&gt;print_cr(&quot;Walk time: %d&quot;, (int)_walk_time.milliseconds());
164   // tty-&gt;print_cr(&quot;Output time: %d&quot;, (int)_output_time.milliseconds());
165   // tty-&gt;print_cr(&quot;Build blocks time: %d&quot;, (int)_build_blocks_time.milliseconds());
166 
167   if(_xml) {
168     delete _xml;
169     _xml = NULL;
170   }
171 
<span class="line-modified">172   if (_network_stream) {</span>
<span class="line-modified">173     delete _network_stream;</span>
<span class="line-modified">174     if (_network_stream == _output) {</span>
175       _output = NULL;
176     }
<span class="line-modified">177     _network_stream = NULL;</span>
178   }
179 
180   if (_output) {
181     delete _output;
182     _output = NULL;
183   }
184 }
185 
186 void IdealGraphPrinter::begin_elem(const char *s) {
187   _xml-&gt;begin_elem(&quot;%s&quot;, s);
188 }
189 
190 void IdealGraphPrinter::end_elem() {
191   _xml-&gt;end_elem();
192 }
193 
194 void IdealGraphPrinter::begin_head(const char *s) {
195   _xml-&gt;begin_head(&quot;%s&quot;, s);
196 }
197 
</pre>
<hr />
<pre>
255   head(BYTECODES_ELEMENT);
256   _xml-&gt;print_cr(&quot;&lt;![CDATA[&quot;);
257   method-&gt;print_codes_on(_xml);
258   _xml-&gt;print_cr(&quot;]]&gt;&quot;);
259   tail(BYTECODES_ELEMENT);
260 
261   if (tree != NULL &amp;&amp; tree-&gt;subtrees().length() &gt; 0) {
262     head(INLINE_ELEMENT);
263     GrowableArray&lt;InlineTree *&gt; subtrees = tree-&gt;subtrees();
264     for (int i = 0; i &lt; subtrees.length(); i++) {
265       print_inline_tree(subtrees.at(i));
266     }
267     tail(INLINE_ELEMENT);
268   }
269 
270   tail(METHOD_ELEMENT);
271   _xml-&gt;flush();
272 }
273 
274 void IdealGraphPrinter::print_inline_tree(InlineTree *tree) {
<span class="line-modified">275   if (tree != NULL) {</span>
<span class="line-modified">276     print_method(tree-&gt;method(), tree-&gt;caller_bci(), tree);</span>
<span class="line-modified">277   }</span>



278 }
279 
280 void IdealGraphPrinter::print_inlining() {
281 
282   // Print inline tree
283   if (_should_send_method) {
284     InlineTree *inlineTree = C-&gt;ilt();
285     if (inlineTree != NULL) {
286       print_inline_tree(inlineTree);
287     } else {
288       // print this method only
289     }
290   }
291 }
292 
293 // Has to be called whenever a method is compiled
294 void IdealGraphPrinter::begin_method() {
295 
296   ciMethod *method = C-&gt;method();
297   assert(_output, &quot;output stream must exist!&quot;);
</pre>
<hr />
<pre>
309   print_prop(METHOD_NAME_PROPERTY, strStream.as_string());
310 
311   if (method-&gt;flags().is_public()) {
312     print_prop(METHOD_IS_PUBLIC_PROPERTY, TRUE_VALUE);
313   }
314 
315   if (method-&gt;flags().is_static()) {
316     print_prop(METHOD_IS_STATIC_PROPERTY, TRUE_VALUE);
317   }
318 
319   tail(PROPERTIES_ELEMENT);
320 
321   _should_send_method = true;
322   this-&gt;_current_method = method;
323 
324   _xml-&gt;flush();
325 }
326 
327 // Has to be called whenever a method has finished compilation
328 void IdealGraphPrinter::end_method() {



329   tail(GROUP_ELEMENT);
330   _current_method = NULL;
331   _xml-&gt;flush();
332 }
333 
334 bool IdealGraphPrinter::traverse_outs() {
335   return _traverse_outs;
336 }
337 
338 void IdealGraphPrinter::set_traverse_outs(bool b) {
339   _traverse_outs = b;
340 }
341 
342 void IdealGraphPrinter::visit_node(Node *n, bool edges, VectorSet* temp_set) {
343 
344   if (edges) {
345 
346     // Output edge
347     node_idx_t dest_id = n-&gt;_idx;
348     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
</pre>
<hr />
<pre>
679       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
680         begin_elem(NODE_ELEMENT);
681         print_attr(NODE_ID_PROPERTY, block-&gt;get_node(s)-&gt;_idx);
682         end_elem();
683       }
684       tail(NODES_ELEMENT);
685 
686       tail(BLOCK_ELEMENT);
687     }
688     tail(CONTROL_FLOW_ELEMENT);
689   }
690   tail(GRAPH_ELEMENT);
691   _xml-&gt;flush();
692 }
693 
694 // Should method be printed?
695 bool IdealGraphPrinter::should_print(int level) {
696   return C-&gt;directive()-&gt;IGVPrintLevelOption &gt;= level;
697 }
698 
<span class="line-added">699 void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {</span>
<span class="line-added">700   ThreadCritical tc;</span>
<span class="line-added">701   if (use_multiple_files &amp;&amp; _file_count != 0) {</span>
<span class="line-added">702     assert(!append, &quot;append should only be used for debugging with a single file&quot;);</span>
<span class="line-added">703     ResourceMark rm;</span>
<span class="line-added">704     stringStream st;</span>
<span class="line-added">705     const char* dot = strrchr(file_name, &#39;.&#39;);</span>
<span class="line-added">706     if (dot) {</span>
<span class="line-added">707       st.write(file_name, dot - file_name);</span>
<span class="line-added">708       st.print(&quot;%d%s&quot;, _file_count, dot);</span>
<span class="line-added">709     } else {</span>
<span class="line-added">710       st.print(&quot;%s%d&quot;, file_name, _file_count);</span>
<span class="line-added">711     }</span>
<span class="line-added">712     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string(), &quot;w&quot;);</span>
<span class="line-added">713   } else {</span>
<span class="line-added">714     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, append ? &quot;a&quot; : &quot;w&quot;);</span>
<span class="line-added">715   }</span>
<span class="line-added">716   if (use_multiple_files) {</span>
<span class="line-added">717     assert(!append, &quot;append should only be used for debugging with a single file&quot;);</span>
<span class="line-added">718     _file_count++;</span>
<span class="line-added">719   }</span>
<span class="line-added">720 }</span>
<span class="line-added">721 </span>
<span class="line-added">722 void IdealGraphPrinter::init_network_stream() {</span>
<span class="line-added">723   _network_stream = new (ResourceObj::C_HEAP, mtCompiler) networkStream();</span>
<span class="line-added">724   // Try to connect to visualizer</span>
<span class="line-added">725   if (_network_stream-&gt;connect(PrintIdealGraphAddress, PrintIdealGraphPort)) {</span>
<span class="line-added">726     char c = 0;</span>
<span class="line-added">727     _network_stream-&gt;read(&amp;c, 1);</span>
<span class="line-added">728     if (c != &#39;y&#39;) {</span>
<span class="line-added">729       tty-&gt;print_cr(&quot;Client available, but does not want to receive data!&quot;);</span>
<span class="line-added">730       _network_stream-&gt;close();</span>
<span class="line-added">731       delete _network_stream;</span>
<span class="line-added">732       _network_stream = NULL;</span>
<span class="line-added">733       return;</span>
<span class="line-added">734     }</span>
<span class="line-added">735     _output = _network_stream;</span>
<span class="line-added">736   } else {</span>
<span class="line-added">737     // It would be nice if we could shut down cleanly but it should</span>
<span class="line-added">738     // be an error if we can&#39;t connect to the visualizer.</span>
<span class="line-added">739     fatal(&quot;Couldn&#39;t connect to visualizer at %s:&quot; INTX_FORMAT,</span>
<span class="line-added">740           PrintIdealGraphAddress, PrintIdealGraphPort);</span>
<span class="line-added">741   }</span>
<span class="line-added">742 }</span>
<span class="line-added">743 </span>
<span class="line-added">744 void IdealGraphPrinter::update_compiled_method(ciMethod* current_method) {</span>
<span class="line-added">745   assert(C != NULL, &quot;must already be set&quot;);</span>
<span class="line-added">746   if (current_method != _current_method) {</span>
<span class="line-added">747     // If a different method, end the old and begin with the new one.</span>
<span class="line-added">748     end_method();</span>
<span class="line-added">749     _current_method = NULL;</span>
<span class="line-added">750     begin_method();</span>
<span class="line-added">751   }</span>
<span class="line-added">752 }</span>
<span class="line-added">753 </span>
754 extern const char *NodeClassNames[];
755 
756 #endif
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c2_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;

  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callGenerator.hpp&quot;
  43 #include &quot;opto/callnode.hpp&quot;
  44 #include &quot;opto/castnode.hpp&quot;
  45 #include &quot;opto/cfgnode.hpp&quot;
  46 #include &quot;opto/chaitin.hpp&quot;
  47 #include &quot;opto/compile.hpp&quot;
  48 #include &quot;opto/connode.hpp&quot;
  49 #include &quot;opto/convertnode.hpp&quot;
  50 #include &quot;opto/divnode.hpp&quot;
  51 #include &quot;opto/escape.hpp&quot;
  52 #include &quot;opto/idealGraphPrinter.hpp&quot;
  53 #include &quot;opto/loopnode.hpp&quot;
  54 #include &quot;opto/machnode.hpp&quot;
  55 #include &quot;opto/macro.hpp&quot;
  56 #include &quot;opto/matcher.hpp&quot;
  57 #include &quot;opto/mathexactnode.hpp&quot;
</pre>
<hr />
<pre>
4528     if (g &lt; t) {
4529       g = t;
4530 #ifndef PRODUCT
4531       if (is_debug()) {
4532         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4533       }
4534 #endif
4535     }
4536   }
4537   return g;
4538 }
4539 
4540 void CloneMap::dump(node_idx_t key) const {
4541   uint64_t val = value(key);
4542   if (val != 0) {
4543     NodeCloneInfo ni(val);
4544     ni.dump();
4545   }
4546 }
4547 
<span class="line-removed">4548 </span>
4549 // Move Allocate nodes to the start of the list
4550 void Compile::sort_macro_nodes() {
4551   int count = macro_count();
4552   int allocates = 0;
4553   for (int i = 0; i &lt; count; i++) {
4554     Node* n = macro_node(i);
4555     if (n-&gt;is_Allocate()) {
4556       if (i != allocates) {
4557         Node* tmp = macro_node(allocates);
4558         _macro_nodes-&gt;at_put(allocates, n);
4559         _macro_nodes-&gt;at_put(i, tmp);
4560       }
4561       allocates++;
4562     }
4563   }
4564 }













































































































</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
<span class="line-added">  38 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;opto/addnode.hpp&quot;
  41 #include &quot;opto/block.hpp&quot;
  42 #include &quot;opto/c2compiler.hpp&quot;
  43 #include &quot;opto/callGenerator.hpp&quot;
  44 #include &quot;opto/callnode.hpp&quot;
  45 #include &quot;opto/castnode.hpp&quot;
  46 #include &quot;opto/cfgnode.hpp&quot;
  47 #include &quot;opto/chaitin.hpp&quot;
  48 #include &quot;opto/compile.hpp&quot;
  49 #include &quot;opto/connode.hpp&quot;
  50 #include &quot;opto/convertnode.hpp&quot;
  51 #include &quot;opto/divnode.hpp&quot;
  52 #include &quot;opto/escape.hpp&quot;
  53 #include &quot;opto/idealGraphPrinter.hpp&quot;
  54 #include &quot;opto/loopnode.hpp&quot;
  55 #include &quot;opto/machnode.hpp&quot;
  56 #include &quot;opto/macro.hpp&quot;
  57 #include &quot;opto/matcher.hpp&quot;
  58 #include &quot;opto/mathexactnode.hpp&quot;
</pre>
<hr />
<pre>
4529     if (g &lt; t) {
4530       g = t;
4531 #ifndef PRODUCT
4532       if (is_debug()) {
4533         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4534       }
4535 #endif
4536     }
4537   }
4538   return g;
4539 }
4540 
4541 void CloneMap::dump(node_idx_t key) const {
4542   uint64_t val = value(key);
4543   if (val != 0) {
4544     NodeCloneInfo ni(val);
4545     ni.dump();
4546   }
4547 }
4548 

4549 // Move Allocate nodes to the start of the list
4550 void Compile::sort_macro_nodes() {
4551   int count = macro_count();
4552   int allocates = 0;
4553   for (int i = 0; i &lt; count; i++) {
4554     Node* n = macro_node(i);
4555     if (n-&gt;is_Allocate()) {
4556       if (i != allocates) {
4557         Node* tmp = macro_node(allocates);
4558         _macro_nodes-&gt;at_put(allocates, n);
4559         _macro_nodes-&gt;at_put(i, tmp);
4560       }
4561       allocates++;
4562     }
4563   }
4564 }
<span class="line-added">4565 </span>
<span class="line-added">4566 void Compile::print_method(CompilerPhaseType cpt, int level, int idx) {</span>
<span class="line-added">4567   EventCompilerPhase event;</span>
<span class="line-added">4568   if (event.should_commit()) {</span>
<span class="line-added">4569     CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);</span>
<span class="line-added">4570   }</span>
<span class="line-added">4571 </span>
<span class="line-added">4572 #ifndef PRODUCT</span>
<span class="line-added">4573   if (should_print(level)) {</span>
<span class="line-added">4574     char output[1024];</span>
<span class="line-added">4575     if (idx != 0) {</span>
<span class="line-added">4576       jio_snprintf(output, sizeof(output), &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);</span>
<span class="line-added">4577     } else {</span>
<span class="line-added">4578       jio_snprintf(output, sizeof(output), &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));</span>
<span class="line-added">4579     }</span>
<span class="line-added">4580     _printer-&gt;print_method(output, level);</span>
<span class="line-added">4581   }</span>
<span class="line-added">4582 #endif</span>
<span class="line-added">4583   C-&gt;_latest_stage_start_counter.stamp();</span>
<span class="line-added">4584 }</span>
<span class="line-added">4585 </span>
<span class="line-added">4586 void Compile::end_method(int level) {</span>
<span class="line-added">4587   EventCompilerPhase event;</span>
<span class="line-added">4588   if (event.should_commit()) {</span>
<span class="line-added">4589     CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);</span>
<span class="line-added">4590   }</span>
<span class="line-added">4591 </span>
<span class="line-added">4592 #ifndef PRODUCT</span>
<span class="line-added">4593   if (_printer &amp;&amp; _printer-&gt;should_print(level)) {</span>
<span class="line-added">4594     _printer-&gt;end_method();</span>
<span class="line-added">4595   }</span>
<span class="line-added">4596 #endif</span>
<span class="line-added">4597 }</span>
<span class="line-added">4598 </span>
<span class="line-added">4599 </span>
<span class="line-added">4600 #ifndef PRODUCT</span>
<span class="line-added">4601 IdealGraphPrinter* Compile::_debug_file_printer = NULL;</span>
<span class="line-added">4602 IdealGraphPrinter* Compile::_debug_network_printer = NULL;</span>
<span class="line-added">4603 </span>
<span class="line-added">4604 // Called from debugger. Prints method to the default file with the default phase name.</span>
<span class="line-added">4605 // This works regardless of any Ideal Graph Visualizer flags set or not.</span>
<span class="line-added">4606 void igv_print() {</span>
<span class="line-added">4607   Compile::current()-&gt;igv_print_method_to_file();</span>
<span class="line-added">4608 }</span>
<span class="line-added">4609 </span>
<span class="line-added">4610 // Same as igv_print() above but with a specified phase name.</span>
<span class="line-added">4611 void igv_print(const char* phase_name) {</span>
<span class="line-added">4612   Compile::current()-&gt;igv_print_method_to_file(phase_name);</span>
<span class="line-added">4613 }</span>
<span class="line-added">4614 </span>
<span class="line-added">4615 // Called from debugger. Prints method with the default phase name to the default network or the one specified with</span>
<span class="line-added">4616 // the network flags for the Ideal Graph Visualizer, or to the default file depending on the &#39;network&#39; argument.</span>
<span class="line-added">4617 // This works regardless of any Ideal Graph Visualizer flags set or not.</span>
<span class="line-added">4618 void igv_print(bool network) {</span>
<span class="line-added">4619   if (network) {</span>
<span class="line-added">4620     Compile::current()-&gt;igv_print_method_to_network();</span>
<span class="line-added">4621   } else {</span>
<span class="line-added">4622     Compile::current()-&gt;igv_print_method_to_file();</span>
<span class="line-added">4623   }</span>
<span class="line-added">4624 }</span>
<span class="line-added">4625 </span>
<span class="line-added">4626 // Same as igv_print(bool network) above but with a specified phase name.</span>
<span class="line-added">4627 void igv_print(bool network, const char* phase_name) {</span>
<span class="line-added">4628   if (network) {</span>
<span class="line-added">4629     Compile::current()-&gt;igv_print_method_to_network(phase_name);</span>
<span class="line-added">4630   } else {</span>
<span class="line-added">4631     Compile::current()-&gt;igv_print_method_to_file(phase_name);</span>
<span class="line-added">4632   }</span>
<span class="line-added">4633 }</span>
<span class="line-added">4634 </span>
<span class="line-added">4635 // Called from debugger. Normal write to the default _printer. Only works if Ideal Graph Visualizer printing flags are set.</span>
<span class="line-added">4636 void igv_print_default() {</span>
<span class="line-added">4637   Compile::current()-&gt;print_method(PHASE_DEBUG, 0, 0);</span>
<span class="line-added">4638 }</span>
<span class="line-added">4639 </span>
<span class="line-added">4640 // Called from debugger, especially when replaying a trace in which the program state cannot be altered like with rr replay.</span>
<span class="line-added">4641 // A method is appended to an existing default file with the default phase name. This means that igv_append() must follow</span>
<span class="line-added">4642 // an earlier igv_print(*) call which sets up the file. This works regardless of any Ideal Graph Visualizer flags set or not.</span>
<span class="line-added">4643 void igv_append() {</span>
<span class="line-added">4644   Compile::current()-&gt;igv_print_method_to_file(&quot;Debug&quot;, true);</span>
<span class="line-added">4645 }</span>
<span class="line-added">4646 </span>
<span class="line-added">4647 // Same as igv_append() above but with a specified phase name.</span>
<span class="line-added">4648 void igv_append(const char* phase_name) {</span>
<span class="line-added">4649   Compile::current()-&gt;igv_print_method_to_file(phase_name, true);</span>
<span class="line-added">4650 }</span>
<span class="line-added">4651 </span>
<span class="line-added">4652 void Compile::igv_print_method_to_file(const char* phase_name, bool append) {</span>
<span class="line-added">4653   const char* file_name = &quot;custom_debug.xml&quot;;</span>
<span class="line-added">4654   if (_debug_file_printer == NULL) {</span>
<span class="line-added">4655     _debug_file_printer = new IdealGraphPrinter(C, file_name, append);</span>
<span class="line-added">4656   } else {</span>
<span class="line-added">4657     _debug_file_printer-&gt;update_compiled_method(C-&gt;method());</span>
<span class="line-added">4658   }</span>
<span class="line-added">4659   tty-&gt;print_cr(&quot;Method %s to %s&quot;, append ? &quot;appended&quot; : &quot;printed&quot;, file_name);</span>
<span class="line-added">4660   _debug_file_printer-&gt;print_method(phase_name, 0);</span>
<span class="line-added">4661 }</span>
<span class="line-added">4662 </span>
<span class="line-added">4663 void Compile::igv_print_method_to_network(const char* phase_name) {</span>
<span class="line-added">4664   if (_debug_network_printer == NULL) {</span>
<span class="line-added">4665     _debug_network_printer = new IdealGraphPrinter(C);</span>
<span class="line-added">4666   } else {</span>
<span class="line-added">4667     _debug_network_printer-&gt;update_compiled_method(C-&gt;method());</span>
<span class="line-added">4668   }</span>
<span class="line-added">4669   tty-&gt;print_cr(&quot;Method printed over network stream to IGV&quot;);</span>
<span class="line-added">4670   _debug_network_printer-&gt;print_method(phase_name, 0);</span>
<span class="line-added">4671 }</span>
<span class="line-added">4672 #endif</span>
<span class="line-added">4673 </span>
</pre>
</td>
</tr>
</table>
<center><a href="c2_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
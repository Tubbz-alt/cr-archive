<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/bsd/attachListener_bsd.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aix/attachListener_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/attachListener_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/bsd/attachListener_bsd.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 49 // connection.
 50 //
 51 // As the socket is a UNIX domain socket it means that only clients on the
 52 // local machine can connect. In addition there are two other aspects to
 53 // the security:
 54 // 1. The well known file that the socket is bound to has permission 400
 55 // 2. When a client connect, the SO_PEERCRED socket option is used to
 56 //    obtain the credentials of client. We check that the effective uid
 57 //    of the client matches this process.
 58 
 59 // forward reference
 60 class BsdAttachOperation;
 61 
 62 class BsdAttachListener: AllStatic {
 63  private:
 64   // the path to which we bind the UNIX domain socket
 65   static char _path[UNIX_PATH_MAX];
 66   static bool _has_path;
 67 
 68   // the file descriptor for the listening socket
<span class="line-modified"> 69   static int _listener;</span>
 70 
 71   static bool _atexit_registered;
 72 
 73   // reads a request from the given connected socket
 74   static BsdAttachOperation* read_request(int s);
 75 
 76  public:
 77   enum {
 78     ATTACH_PROTOCOL_VER = 1                     // protocol version
 79   };
 80   enum {
 81     ATTACH_ERROR_BADVERSION     = 101           // error codes
 82   };
 83 
 84   static void set_path(char* path) {
 85     if (path == NULL) {
 86       _path[0] = &#39;\0&#39;;
 87       _has_path = false;
 88     } else {
 89       strncpy(_path, path, UNIX_PATH_MAX);
</pre>
<hr />
<pre>
109 
110 class BsdAttachOperation: public AttachOperation {
111  private:
112   // the connection to the client
113   int _socket;
114 
115  public:
116   void complete(jint res, bufferedStream* st);
117 
118   void set_socket(int s)                                { _socket = s; }
119   int socket() const                                    { return _socket; }
120 
121   BsdAttachOperation(char* name) : AttachOperation(name) {
122     set_socket(-1);
123   }
124 };
125 
126 // statics
127 char BsdAttachListener::_path[UNIX_PATH_MAX];
128 bool BsdAttachListener::_has_path;
<span class="line-modified">129 int BsdAttachListener::_listener = -1;</span>
130 bool BsdAttachListener::_atexit_registered = false;
131 
132 // Supporting class to help split a buffer into individual components
133 class ArgumentIterator : public StackObj {
134  private:
135   char* _pos;
136   char* _end;
137  public:
138   ArgumentIterator(char* arg_buffer, size_t arg_size) {
139     _pos = arg_buffer;
140     _end = _pos + arg_size - 1;
141   }
142   char* next() {
143     if (*_pos == &#39;\0&#39;) {
144       // advance the iterator if possible (null arguments)
145       if (_pos &lt; _end) {
146         _pos += 1;
147       }
148       return NULL;
149     }
</pre>
<hr />
<pre>
485 
486   int ret_code = BsdAttachListener::init();
487 
488   // were we externally suspended while we were waiting?
489   thread-&gt;check_and_wait_while_suspended();
490 
491   return ret_code;
492 }
493 
494 bool AttachListener::check_socket_file() {
495   int ret;
496   struct stat st;
497   ret = stat(BsdAttachListener::path(), &amp;st);
498   if (ret == -1) { // need to restart attach listener.
499     log_debug(attach)(&quot;Socket file %s does not exist - Restart Attach Listener&quot;,
500                       BsdAttachListener::path());
501 
502     listener_cleanup();
503 
504     // wait to terminate current attach listener instance...
<span class="line-modified">505 </span>
<span class="line-modified">506     while (AttachListener::transit_state(AL_INITIALIZING,</span>
<span class="line-modified">507 </span>
<span class="line-modified">508                                          AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {</span>
<span class="line-modified">509       os::naked_yield();</span>


510     }
511     return is_init_trigger();
512   }
513   return false;
514 }
515 
516 // Attach Listener is started lazily except in the case when
517 // +ReduseSignalUsage is used
518 bool AttachListener::init_at_startup() {
519   if (ReduceSignalUsage) {
520     return true;
521   } else {
522     return false;
523   }
524 }
525 
526 // If the file .attach_pid&lt;pid&gt; exists in the working directory
527 // or /tmp then this is the trigger to start the attach mechanism
528 bool AttachListener::is_init_trigger() {
529   if (init_at_startup() || is_initialized()) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 49 // connection.
 50 //
 51 // As the socket is a UNIX domain socket it means that only clients on the
 52 // local machine can connect. In addition there are two other aspects to
 53 // the security:
 54 // 1. The well known file that the socket is bound to has permission 400
 55 // 2. When a client connect, the SO_PEERCRED socket option is used to
 56 //    obtain the credentials of client. We check that the effective uid
 57 //    of the client matches this process.
 58 
 59 // forward reference
 60 class BsdAttachOperation;
 61 
 62 class BsdAttachListener: AllStatic {
 63  private:
 64   // the path to which we bind the UNIX domain socket
 65   static char _path[UNIX_PATH_MAX];
 66   static bool _has_path;
 67 
 68   // the file descriptor for the listening socket
<span class="line-modified"> 69   static volatile int _listener;</span>
 70 
 71   static bool _atexit_registered;
 72 
 73   // reads a request from the given connected socket
 74   static BsdAttachOperation* read_request(int s);
 75 
 76  public:
 77   enum {
 78     ATTACH_PROTOCOL_VER = 1                     // protocol version
 79   };
 80   enum {
 81     ATTACH_ERROR_BADVERSION     = 101           // error codes
 82   };
 83 
 84   static void set_path(char* path) {
 85     if (path == NULL) {
 86       _path[0] = &#39;\0&#39;;
 87       _has_path = false;
 88     } else {
 89       strncpy(_path, path, UNIX_PATH_MAX);
</pre>
<hr />
<pre>
109 
110 class BsdAttachOperation: public AttachOperation {
111  private:
112   // the connection to the client
113   int _socket;
114 
115  public:
116   void complete(jint res, bufferedStream* st);
117 
118   void set_socket(int s)                                { _socket = s; }
119   int socket() const                                    { return _socket; }
120 
121   BsdAttachOperation(char* name) : AttachOperation(name) {
122     set_socket(-1);
123   }
124 };
125 
126 // statics
127 char BsdAttachListener::_path[UNIX_PATH_MAX];
128 bool BsdAttachListener::_has_path;
<span class="line-modified">129 volatile int BsdAttachListener::_listener = -1;</span>
130 bool BsdAttachListener::_atexit_registered = false;
131 
132 // Supporting class to help split a buffer into individual components
133 class ArgumentIterator : public StackObj {
134  private:
135   char* _pos;
136   char* _end;
137  public:
138   ArgumentIterator(char* arg_buffer, size_t arg_size) {
139     _pos = arg_buffer;
140     _end = _pos + arg_size - 1;
141   }
142   char* next() {
143     if (*_pos == &#39;\0&#39;) {
144       // advance the iterator if possible (null arguments)
145       if (_pos &lt; _end) {
146         _pos += 1;
147       }
148       return NULL;
149     }
</pre>
<hr />
<pre>
485 
486   int ret_code = BsdAttachListener::init();
487 
488   // were we externally suspended while we were waiting?
489   thread-&gt;check_and_wait_while_suspended();
490 
491   return ret_code;
492 }
493 
494 bool AttachListener::check_socket_file() {
495   int ret;
496   struct stat st;
497   ret = stat(BsdAttachListener::path(), &amp;st);
498   if (ret == -1) { // need to restart attach listener.
499     log_debug(attach)(&quot;Socket file %s does not exist - Restart Attach Listener&quot;,
500                       BsdAttachListener::path());
501 
502     listener_cleanup();
503 
504     // wait to terminate current attach listener instance...
<span class="line-modified">505     {</span>
<span class="line-modified">506       // avoid deadlock if AttachListener thread is blocked at safepoint</span>
<span class="line-modified">507       ThreadBlockInVM tbivm(JavaThread::current());</span>
<span class="line-modified">508       while (AttachListener::transit_state(AL_INITIALIZING,</span>
<span class="line-modified">509                                            AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {</span>
<span class="line-added">510         os::naked_yield();</span>
<span class="line-added">511       }</span>
512     }
513     return is_init_trigger();
514   }
515   return false;
516 }
517 
518 // Attach Listener is started lazily except in the case when
519 // +ReduseSignalUsage is used
520 bool AttachListener::init_at_startup() {
521   if (ReduceSignalUsage) {
522     return true;
523   } else {
524     return false;
525   }
526 }
527 
528 // If the file .attach_pid&lt;pid&gt; exists in the working directory
529 // or /tmp then this is the trigger to start the attach mechanism
530 bool AttachListener::is_init_trigger() {
531   if (init_at_startup() || is_initialized()) {
</pre>
</td>
</tr>
</table>
<center><a href="../aix/attachListener_aix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../linux/attachListener_linux.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
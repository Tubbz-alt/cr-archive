<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/jar/JarFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../lang/invoke/StringConcatFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JavaUtilJarAccessImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/jar/JarFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 486      *         the versioned entry name or {@code null} if not found
 487      *
 488      * @throws IllegalStateException
 489      *         may be thrown if the jar file has been closed
 490      *
 491      * @see java.util.zip.ZipEntry
 492      *
 493      * @implSpec
 494      * &lt;div class=&quot;block&quot;&gt;
 495      * This implementation may return a versioned entry for the requested name
 496      * even if there is not a corresponding base entry.  This can occur
 497      * if there is a private or package-private versioned entry that matches.
 498      * If a subclass overrides this method, assure that the override method
 499      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 500      * &lt;/div&gt;
 501      */
 502     public ZipEntry getEntry(String name) {
 503         if (isMultiRelease()) {
 504             JarEntry je = getVersionedEntry(name, null);
 505             if (je == null) {
<span class="line-modified"> 506                 je = getEntry0(name);</span>
 507             }
 508             return je;
 509         } else {
<span class="line-modified"> 510             return getEntry0(name);</span>
 511         }
 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
<span class="line-modified"> 522         return JUZFA.entries(this, JarFileEntry::new);</span>
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
 532      * @since 1.8
 533      */
 534     public Stream&lt;JarEntry&gt; stream() {
<span class="line-modified"> 535         return JUZFA.stream(this, JarFileEntry::new);</span>
 536     }
 537 
 538     /**
 539      * Returns a {@code Stream} of the versioned jar file entries.
 540      *
 541      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured to
 542      * be processed as such, then an entry in the stream is the latest versioned entry
 543      * associated with the corresponding base entry name. The maximum version of the
 544      * latest versioned entry is the version returned by {@link #getVersion()}.
 545      * The returned stream may include an entry that only exists as a versioned entry.
 546      *
 547      * If the jar file is not a multi-release jar file or the {@code JarFile} is not
 548      * configured for processing a multi-release jar file, this method returns the
 549      * same stream that {@link #stream()} returns.
 550      *
 551      * @return stream of versioned entries
 552      * @since 10
 553      */
 554     public Stream&lt;JarEntry&gt; versionedStream() {
 555 
 556         if (isMultiRelease()) {
 557             return JUZFA.entryNameStream(this).map(this::getBasename)
 558                                               .filter(Objects::nonNull)
 559                                               .distinct()
 560                                               .map(this::getJarEntry)
 561                                               .filter(Objects::nonNull);
 562         }
 563         return stream();
 564     }
 565 
<span class="line-modified"> 566     /*</span>
<span class="line-modified"> 567      * Invokes {@ZipFile}&#39;s getEntry to Return a {@code JarFileEntry} for the</span>
<span class="line-removed"> 568      * given entry name or {@code null} if not found.</span>
 569      */
<span class="line-modified"> 570     private JarFileEntry getEntry0(String name) {</span>
<span class="line-modified"> 571         // Not using a lambda/method reference here to optimize startup time</span>
<span class="line-removed"> 572         Function&lt;String, JarEntry&gt; newJarFileEntryFn = new Function&lt;&gt;() {</span>
<span class="line-removed"> 573             @Override</span>
<span class="line-removed"> 574             public JarEntry apply(String name) {</span>
<span class="line-removed"> 575                 return new JarFileEntry(name);</span>
<span class="line-removed"> 576             }</span>
<span class="line-removed"> 577         };</span>
<span class="line-removed"> 578         return (JarFileEntry)JUZFA.getEntry(this, name, newJarFileEntryFn);</span>
 579     }
 580 
 581     private String getBasename(String name) {
 582         if (name.startsWith(META_INF_VERSIONS)) {
 583             int off = META_INF_VERSIONS.length();
 584             int index = name.indexOf(&#39;/&#39;, off);
 585             try {
 586                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 587                 // and any entry with version &gt; &#39;version&#39;
 588                 if (index == -1 || index == (name.length() - 1) ||
 589                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 590                     return null;
 591                 }
 592             } catch (NumberFormatException x) {
 593                 return null; // remove malformed entries silently
 594             }
 595             // map to its base name
 596             return name.substring(index + 1);
 597         }
 598         return name;
 599     }
 600 
 601     private JarEntry getVersionedEntry(String name, JarEntry defaultEntry) {
 602         if (!name.startsWith(META_INF)) {
 603             int[] versions = JUZFA.getMetaInfVersions(this);
 604             if (BASE_VERSION_FEATURE &lt; versionFeature &amp;&amp; versions.length &gt; 0) {
 605                 // search for versioned entry
 606                 for (int i = versions.length - 1; i &gt;= 0; i--) {
 607                     int version = versions[i];
 608                     // skip versions above versionFeature
 609                     if (version &gt; versionFeature) {
 610                         continue;
 611                     }
 612                     // skip versions below base version
 613                     if (version &lt; BASE_VERSION_FEATURE) {
 614                         break;
 615                     }
<span class="line-modified"> 616                     JarFileEntry vje = getEntry0(META_INF_VERSIONS + version + &quot;/&quot; + name);</span>

 617                     if (vje != null) {
 618                         return vje.withBasename(name);
 619                     }
 620                 }
 621             }
 622         }
 623         return defaultEntry;
 624     }
 625 
 626     // placeholder for now
 627     String getRealName(JarEntry entry) {
 628         return entry.getRealName();
 629     }
 630 
 631     private class JarFileEntry extends JarEntry {
 632         private String basename;
 633 
 634         JarFileEntry(String name) {
 635             super(name);
 636             this.basename = name;
</pre>
<hr />
<pre>
 698 
 699         // changes the basename, returns &quot;this&quot;
 700         JarFileEntry withBasename(String name) {
 701             basename = name;
 702             return this;
 703         }
 704     }
 705 
 706     /*
 707      * Ensures that the JarVerifier has been created if one is
 708      * necessary (i.e., the jar appears to be signed.) This is done as
 709      * a quick check to avoid processing of the manifest for unsigned
 710      * jars.
 711      */
 712     private void maybeInstantiateVerifier() throws IOException {
 713         if (jv != null) {
 714             return;
 715         }
 716 
 717         if (verify) {
<span class="line-modified"> 718             String[] names = JUZFA.getMetaInfEntryNames(this);</span>
<span class="line-modified"> 719             if (names != null) {</span>
<span class="line-modified"> 720                 for (String nameLower : names) {</span>
<span class="line-modified"> 721                     String name = nameLower.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified"> 722                     if (name.endsWith(&quot;.DSA&quot;) ||</span>
<span class="line-modified"> 723                         name.endsWith(&quot;.RSA&quot;) ||</span>
<span class="line-modified"> 724                         name.endsWith(&quot;.EC&quot;) ||</span>
<span class="line-modified"> 725                         name.endsWith(&quot;.SF&quot;)) {</span>
<span class="line-removed"> 726                         // Assume since we found a signature-related file</span>
<span class="line-removed"> 727                         // that the jar is signed and that we therefore</span>
<span class="line-removed"> 728                         // need a JarVerifier and Manifest</span>
<span class="line-removed"> 729                         getManifest();</span>
<span class="line-removed"> 730                         return;</span>
<span class="line-removed"> 731                     }</span>
<span class="line-removed"> 732                 }</span>
 733             }
 734             // No signature-related files; don&#39;t instantiate a
 735             // verifier
 736             verify = false;
 737         }
 738     }
 739 
 740     /*
 741      * Initializes the verifier object by reading all the manifest
 742      * entries and passing them to the verifier.
 743      */
 744     private void initializeVerifier() {
 745         ManifestEntryVerifier mev = null;
 746 
 747         // Verify &quot;META-INF/&quot; entries...
 748         try {
<span class="line-modified"> 749             String[] names = JUZFA.getMetaInfEntryNames(this);</span>
<span class="line-modified"> 750             if (names != null) {</span>
<span class="line-modified"> 751                 for (String name : names) {</span>
<span class="line-modified"> 752                     String uname = name.toUpperCase(Locale.ENGLISH);</span>
<span class="line-modified"> 753                     if (MANIFEST_NAME.equals(uname)</span>
<span class="line-modified"> 754                             || SignatureFileVerifier.isBlockOrSF(uname)) {</span>
<span class="line-modified"> 755                         JarEntry e = getJarEntry(name);</span>
<span class="line-modified"> 756                         if (e == null) {</span>
<span class="line-modified"> 757                             throw new JarException(&quot;corrupted jar file&quot;);</span>
<span class="line-modified"> 758                         }</span>
<span class="line-modified"> 759                         if (mev == null) {</span>
<span class="line-modified"> 760                             mev = new ManifestEntryVerifier</span>
<span class="line-modified"> 761                                 (getManifestFromReference());</span>
<span class="line-modified"> 762                         }</span>
<span class="line-modified"> 763                         byte[] b = getBytes(e);</span>
<span class="line-removed"> 764                         if (b != null &amp;&amp; b.length &gt; 0) {</span>
<span class="line-removed"> 765                             jv.beginEntry(e, mev);</span>
<span class="line-removed"> 766                             jv.update(b.length, b, 0, b.length, mev);</span>
<span class="line-removed"> 767                             jv.update(-1, null, 0, 0, mev);</span>
<span class="line-removed"> 768                         }</span>
<span class="line-removed"> 769                     }</span>
 770                 }
 771             }
<span class="line-modified"> 772         } catch (IOException ex) {</span>
 773             // if we had an error parsing any blocks, just
 774             // treat the jar file as being unsigned
 775             jv = null;
 776             verify = false;
 777             if (JarVerifier.debug != null) {
 778                 JarVerifier.debug.println(&quot;jarfile parsing error!&quot;);
 779                 ex.printStackTrace();
 780             }
 781         }
 782 
 783         // if after initializing the verifier we have nothing
 784         // signed, we null it out.
 785 
 786         if (jv != null) {
 787 
 788             jv.doneWithMeta();
 789             if (JarVerifier.debug != null) {
 790                 JarVerifier.debug.println(&quot;done with meta!&quot;);
 791             }
 792 
</pre>
<hr />
<pre>
 918         MULTIRELEASE_LASTOCC[(int)&#39;I&#39; - 32] = 5;
 919         MULTIRELEASE_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 920         MULTIRELEASE_LASTOCC[(int)&#39;L&#39; - 32] = 9;
 921         MULTIRELEASE_LASTOCC[(int)&#39;A&#39; - 32] = 11;
 922         MULTIRELEASE_LASTOCC[(int)&#39;S&#39; - 32] = 12;
 923         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 924         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 925         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 926         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 927         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 928         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 929         for (int i = 0; i &lt; 17; i++) {
 930             MULTIRELEASE_OPTOSFT[i] = 19;
 931         }
 932         MULTIRELEASE_OPTOSFT[17] = 6;
 933         MULTIRELEASE_OPTOSFT[18] = 1;
 934     }
 935 
 936     private JarEntry getManEntry() {
 937         if (manEntry == null) {
<span class="line-modified"> 938             // First look up manifest entry using standard name</span>
<span class="line-modified"> 939             JarEntry manEntry = getEntry0(MANIFEST_NAME);</span>
<span class="line-modified"> 940             if (manEntry == null) {</span>
<span class="line-modified"> 941                 // If not found, then iterate through all the &quot;META-INF/&quot;</span>
<span class="line-modified"> 942                 // entries to find a match.</span>
<span class="line-removed"> 943                 String[] names = JUZFA.getMetaInfEntryNames(this);</span>
<span class="line-removed"> 944                 if (names != null) {</span>
<span class="line-removed"> 945                     for (String name : names) {</span>
<span class="line-removed"> 946                         if (MANIFEST_NAME.equals(name.toUpperCase(Locale.ENGLISH))) {</span>
<span class="line-removed"> 947                             manEntry = getEntry0(name);</span>
<span class="line-removed"> 948                             break;</span>
<span class="line-removed"> 949                         }</span>
<span class="line-removed"> 950                     }</span>
<span class="line-removed"> 951                 }</span>
 952             }
<span class="line-removed"> 953             this.manEntry = manEntry;</span>
 954         }
 955         return manEntry;
 956     }
 957 
 958    /**
 959     * Returns {@code true} iff this JAR file has a manifest with the
 960     * Class-Path attribute
 961     */
 962     boolean hasClassPathAttribute() throws IOException {
 963         checkForSpecialAttributes();
 964         return hasClassPathAttribute;
 965     }
 966 
 967     /**
 968      * Returns true if the pattern {@code src} is found in {@code b}.
 969      * The {@code lastOcc} array is the precomputed bad character shifts.
 970      * Since there are no repeated substring in our search strings,
 971      * the good suffix shifts can be replaced with a comparison.
 972      */
 973     private int match(byte[] src, byte[] b, byte[] lastOcc, byte[] optoSft) {
</pre>
<hr />
<pre>
1099             if (c.getCodeSigners() == null) {
1100                 includeUnsigned = true;
1101                 break;
1102             }
1103         }
1104         if (includeUnsigned) {
1105             return unsignedEntryNames();
1106         } else {
1107             return Collections.emptyEnumeration();
1108         }
1109     }
1110 
1111     /**
1112      * Returns an enumeration of the zip file entries
1113      * excluding internal JAR mechanism entries and including
1114      * signed entries missing from the ZIP directory.
1115      */
1116     Enumeration&lt;JarEntry&gt; entries2() {
1117         ensureInitialization();
1118         if (jv != null) {
<span class="line-modified">1119             return jv.entries2(this, JUZFA.entries(JarFile.this,</span>
<span class="line-removed">1120                                                    JarFileEntry::new));</span>
1121         }
1122 
1123         // screen out entries which are never signed
<span class="line-modified">1124         final var unfilteredEntries = JUZFA.entries(JarFile.this, JarFileEntry::new);</span>
1125 
1126         return new Enumeration&lt;&gt;() {
1127 
1128             JarEntry entry;
1129 
1130             public boolean hasMoreElements() {
1131                 if (entry != null) {
1132                     return true;
1133                 }
1134                 while (unfilteredEntries.hasMoreElements()) {
1135                     JarEntry je = unfilteredEntries.nextElement();
1136                     if (JarVerifier.isSigningRelated(je.getName())) {
1137                         continue;
1138                     }
1139                     entry = je;
1140                     return true;
1141                 }
1142                 return false;
1143             }
1144 
</pre>
<hr />
<pre>
1196                     return true;
1197                 }
1198                 return false;
1199             }
1200 
1201             public String nextElement() {
1202                 if (hasMoreElements()) {
1203                     String value = name;
1204                     name = null;
1205                     return value;
1206                 }
1207                 throw new NoSuchElementException();
1208             }
1209         };
1210     }
1211 
1212     CodeSource getCodeSource(URL url, String name) {
1213         ensureInitialization();
1214         if (jv != null) {
1215             if (jv.eagerValidation) {
<span class="line-modified">1216                 CodeSource cs = null;</span>
1217                 JarEntry je = getJarEntry(name);
1218                 if (je != null) {
1219                     cs = jv.getCodeSource(url, this, je);
1220                 } else {
1221                     cs = jv.getCodeSource(url, name);
1222                 }
1223                 return cs;
1224             } else {
1225                 return jv.getCodeSource(url, name);
1226             }
1227         }
1228 
1229         return JarVerifier.getUnsignedCS(url);
1230     }
1231 
1232     void setEagerValidation(boolean eager) {
1233         try {
1234             maybeInstantiateVerifier();
1235         } catch (IOException e) {
1236             throw new RuntimeException(e);
</pre>
</td>
<td>
<hr />
<pre>
 486      *         the versioned entry name or {@code null} if not found
 487      *
 488      * @throws IllegalStateException
 489      *         may be thrown if the jar file has been closed
 490      *
 491      * @see java.util.zip.ZipEntry
 492      *
 493      * @implSpec
 494      * &lt;div class=&quot;block&quot;&gt;
 495      * This implementation may return a versioned entry for the requested name
 496      * even if there is not a corresponding base entry.  This can occur
 497      * if there is a private or package-private versioned entry that matches.
 498      * If a subclass overrides this method, assure that the override method
 499      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 500      * &lt;/div&gt;
 501      */
 502     public ZipEntry getEntry(String name) {
 503         if (isMultiRelease()) {
 504             JarEntry je = getVersionedEntry(name, null);
 505             if (je == null) {
<span class="line-modified"> 506                 je = (JarEntry)super.getEntry(name);</span>
 507             }
 508             return je;
 509         } else {
<span class="line-modified"> 510             return super.getEntry(name);</span>
 511         }
 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
<span class="line-modified"> 522         return JUZFA.entries(this);</span>
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
 532      * @since 1.8
 533      */
 534     public Stream&lt;JarEntry&gt; stream() {
<span class="line-modified"> 535         return JUZFA.stream(this);</span>
 536     }
 537 
 538     /**
 539      * Returns a {@code Stream} of the versioned jar file entries.
 540      *
 541      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured to
 542      * be processed as such, then an entry in the stream is the latest versioned entry
 543      * associated with the corresponding base entry name. The maximum version of the
 544      * latest versioned entry is the version returned by {@link #getVersion()}.
 545      * The returned stream may include an entry that only exists as a versioned entry.
 546      *
 547      * If the jar file is not a multi-release jar file or the {@code JarFile} is not
 548      * configured for processing a multi-release jar file, this method returns the
 549      * same stream that {@link #stream()} returns.
 550      *
 551      * @return stream of versioned entries
 552      * @since 10
 553      */
 554     public Stream&lt;JarEntry&gt; versionedStream() {
 555 
 556         if (isMultiRelease()) {
 557             return JUZFA.entryNameStream(this).map(this::getBasename)
 558                                               .filter(Objects::nonNull)
 559                                               .distinct()
 560                                               .map(this::getJarEntry)
 561                                               .filter(Objects::nonNull);
 562         }
 563         return stream();
 564     }
 565 
<span class="line-modified"> 566     /**</span>
<span class="line-modified"> 567      * Creates a ZipEntry suitable for the given ZipFile.</span>

 568      */
<span class="line-modified"> 569     JarEntry entryFor(String name) {</span>
<span class="line-modified"> 570         return new JarFileEntry(name);</span>







 571     }
 572 
 573     private String getBasename(String name) {
 574         if (name.startsWith(META_INF_VERSIONS)) {
 575             int off = META_INF_VERSIONS.length();
 576             int index = name.indexOf(&#39;/&#39;, off);
 577             try {
 578                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 579                 // and any entry with version &gt; &#39;version&#39;
 580                 if (index == -1 || index == (name.length() - 1) ||
 581                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 582                     return null;
 583                 }
 584             } catch (NumberFormatException x) {
 585                 return null; // remove malformed entries silently
 586             }
 587             // map to its base name
 588             return name.substring(index + 1);
 589         }
 590         return name;
 591     }
 592 
 593     private JarEntry getVersionedEntry(String name, JarEntry defaultEntry) {
 594         if (!name.startsWith(META_INF)) {
 595             int[] versions = JUZFA.getMetaInfVersions(this);
 596             if (BASE_VERSION_FEATURE &lt; versionFeature &amp;&amp; versions.length &gt; 0) {
 597                 // search for versioned entry
 598                 for (int i = versions.length - 1; i &gt;= 0; i--) {
 599                     int version = versions[i];
 600                     // skip versions above versionFeature
 601                     if (version &gt; versionFeature) {
 602                         continue;
 603                     }
 604                     // skip versions below base version
 605                     if (version &lt; BASE_VERSION_FEATURE) {
 606                         break;
 607                     }
<span class="line-modified"> 608                     JarFileEntry vje = (JarFileEntry)super.getEntry(</span>
<span class="line-added"> 609                             META_INF_VERSIONS + version + &quot;/&quot; + name);</span>
 610                     if (vje != null) {
 611                         return vje.withBasename(name);
 612                     }
 613                 }
 614             }
 615         }
 616         return defaultEntry;
 617     }
 618 
 619     // placeholder for now
 620     String getRealName(JarEntry entry) {
 621         return entry.getRealName();
 622     }
 623 
 624     private class JarFileEntry extends JarEntry {
 625         private String basename;
 626 
 627         JarFileEntry(String name) {
 628             super(name);
 629             this.basename = name;
</pre>
<hr />
<pre>
 691 
 692         // changes the basename, returns &quot;this&quot;
 693         JarFileEntry withBasename(String name) {
 694             basename = name;
 695             return this;
 696         }
 697     }
 698 
 699     /*
 700      * Ensures that the JarVerifier has been created if one is
 701      * necessary (i.e., the jar appears to be signed.) This is done as
 702      * a quick check to avoid processing of the manifest for unsigned
 703      * jars.
 704      */
 705     private void maybeInstantiateVerifier() throws IOException {
 706         if (jv != null) {
 707             return;
 708         }
 709 
 710         if (verify) {
<span class="line-modified"> 711             // Gets the manifest name, but only if there are</span>
<span class="line-modified"> 712             // signature-related files. If so we can assume</span>
<span class="line-modified"> 713             // that the jar is signed and that we therefore</span>
<span class="line-modified"> 714             // need a JarVerifier and Manifest</span>
<span class="line-modified"> 715             String name = JUZFA.getManifestName(this, true);</span>
<span class="line-modified"> 716             if (name != null) {</span>
<span class="line-modified"> 717                 getManifest();</span>
<span class="line-modified"> 718                 return;</span>







 719             }
 720             // No signature-related files; don&#39;t instantiate a
 721             // verifier
 722             verify = false;
 723         }
 724     }
 725 
 726     /*
 727      * Initializes the verifier object by reading all the manifest
 728      * entries and passing them to the verifier.
 729      */
 730     private void initializeVerifier() {
 731         ManifestEntryVerifier mev = null;
 732 
 733         // Verify &quot;META-INF/&quot; entries...
 734         try {
<span class="line-modified"> 735             List&lt;String&gt; names = JUZFA.getManifestAndSignatureRelatedFiles(this);</span>
<span class="line-modified"> 736             for (String name : names) {</span>
<span class="line-modified"> 737                 JarEntry e = getJarEntry(name);</span>
<span class="line-modified"> 738                 if (e == null) {</span>
<span class="line-modified"> 739                     throw new JarException(&quot;corrupted jar file&quot;);</span>
<span class="line-modified"> 740                 }</span>
<span class="line-modified"> 741                 if (mev == null) {</span>
<span class="line-modified"> 742                     mev = new ManifestEntryVerifier</span>
<span class="line-modified"> 743                         (getManifestFromReference());</span>
<span class="line-modified"> 744                 }</span>
<span class="line-modified"> 745                 byte[] b = getBytes(e);</span>
<span class="line-modified"> 746                 if (b != null &amp;&amp; b.length &gt; 0) {</span>
<span class="line-modified"> 747                     jv.beginEntry(e, mev);</span>
<span class="line-modified"> 748                     jv.update(b.length, b, 0, b.length, mev);</span>
<span class="line-modified"> 749                     jv.update(-1, null, 0, 0, mev);</span>






 750                 }
 751             }
<span class="line-modified"> 752         } catch (IOException | IllegalArgumentException ex) {</span>
 753             // if we had an error parsing any blocks, just
 754             // treat the jar file as being unsigned
 755             jv = null;
 756             verify = false;
 757             if (JarVerifier.debug != null) {
 758                 JarVerifier.debug.println(&quot;jarfile parsing error!&quot;);
 759                 ex.printStackTrace();
 760             }
 761         }
 762 
 763         // if after initializing the verifier we have nothing
 764         // signed, we null it out.
 765 
 766         if (jv != null) {
 767 
 768             jv.doneWithMeta();
 769             if (JarVerifier.debug != null) {
 770                 JarVerifier.debug.println(&quot;done with meta!&quot;);
 771             }
 772 
</pre>
<hr />
<pre>
 898         MULTIRELEASE_LASTOCC[(int)&#39;I&#39; - 32] = 5;
 899         MULTIRELEASE_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 900         MULTIRELEASE_LASTOCC[(int)&#39;L&#39; - 32] = 9;
 901         MULTIRELEASE_LASTOCC[(int)&#39;A&#39; - 32] = 11;
 902         MULTIRELEASE_LASTOCC[(int)&#39;S&#39; - 32] = 12;
 903         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 904         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 905         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 906         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 907         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 908         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 909         for (int i = 0; i &lt; 17; i++) {
 910             MULTIRELEASE_OPTOSFT[i] = 19;
 911         }
 912         MULTIRELEASE_OPTOSFT[17] = 6;
 913         MULTIRELEASE_OPTOSFT[18] = 1;
 914     }
 915 
 916     private JarEntry getManEntry() {
 917         if (manEntry == null) {
<span class="line-modified"> 918             // The manifest entry position is resolved during</span>
<span class="line-modified"> 919             // initialization</span>
<span class="line-modified"> 920             String name = JUZFA.getManifestName(this, false);</span>
<span class="line-modified"> 921             if (name != null) {</span>
<span class="line-modified"> 922                 this.manEntry = (JarEntry)super.getEntry(name);</span>









 923             }

 924         }
 925         return manEntry;
 926     }
 927 
 928    /**
 929     * Returns {@code true} iff this JAR file has a manifest with the
 930     * Class-Path attribute
 931     */
 932     boolean hasClassPathAttribute() throws IOException {
 933         checkForSpecialAttributes();
 934         return hasClassPathAttribute;
 935     }
 936 
 937     /**
 938      * Returns true if the pattern {@code src} is found in {@code b}.
 939      * The {@code lastOcc} array is the precomputed bad character shifts.
 940      * Since there are no repeated substring in our search strings,
 941      * the good suffix shifts can be replaced with a comparison.
 942      */
 943     private int match(byte[] src, byte[] b, byte[] lastOcc, byte[] optoSft) {
</pre>
<hr />
<pre>
1069             if (c.getCodeSigners() == null) {
1070                 includeUnsigned = true;
1071                 break;
1072             }
1073         }
1074         if (includeUnsigned) {
1075             return unsignedEntryNames();
1076         } else {
1077             return Collections.emptyEnumeration();
1078         }
1079     }
1080 
1081     /**
1082      * Returns an enumeration of the zip file entries
1083      * excluding internal JAR mechanism entries and including
1084      * signed entries missing from the ZIP directory.
1085      */
1086     Enumeration&lt;JarEntry&gt; entries2() {
1087         ensureInitialization();
1088         if (jv != null) {
<span class="line-modified">1089             return jv.entries2(this, JUZFA.entries(JarFile.this));</span>

1090         }
1091 
1092         // screen out entries which are never signed
<span class="line-modified">1093         final var unfilteredEntries = JUZFA.entries(JarFile.this);</span>
1094 
1095         return new Enumeration&lt;&gt;() {
1096 
1097             JarEntry entry;
1098 
1099             public boolean hasMoreElements() {
1100                 if (entry != null) {
1101                     return true;
1102                 }
1103                 while (unfilteredEntries.hasMoreElements()) {
1104                     JarEntry je = unfilteredEntries.nextElement();
1105                     if (JarVerifier.isSigningRelated(je.getName())) {
1106                         continue;
1107                     }
1108                     entry = je;
1109                     return true;
1110                 }
1111                 return false;
1112             }
1113 
</pre>
<hr />
<pre>
1165                     return true;
1166                 }
1167                 return false;
1168             }
1169 
1170             public String nextElement() {
1171                 if (hasMoreElements()) {
1172                     String value = name;
1173                     name = null;
1174                     return value;
1175                 }
1176                 throw new NoSuchElementException();
1177             }
1178         };
1179     }
1180 
1181     CodeSource getCodeSource(URL url, String name) {
1182         ensureInitialization();
1183         if (jv != null) {
1184             if (jv.eagerValidation) {
<span class="line-modified">1185                 CodeSource cs;</span>
1186                 JarEntry je = getJarEntry(name);
1187                 if (je != null) {
1188                     cs = jv.getCodeSource(url, this, je);
1189                 } else {
1190                     cs = jv.getCodeSource(url, name);
1191                 }
1192                 return cs;
1193             } else {
1194                 return jv.getCodeSource(url, name);
1195             }
1196         }
1197 
1198         return JarVerifier.getUnsignedCS(url);
1199     }
1200 
1201     void setEagerValidation(boolean eager) {
1202         try {
1203             maybeInstantiateVerifier();
1204         } catch (IOException e) {
1205             throw new RuntimeException(e);
</pre>
</td>
</tr>
</table>
<center><a href="../../lang/invoke/StringConcatFactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="JavaUtilJarAccessImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
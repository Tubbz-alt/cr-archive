<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../regex/Grapheme.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilJarAccess.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,31 ***</span>
  import java.util.Collections;
  import java.util.Deque;
  import java.util.Enumeration;
  import java.util.HashMap;
  import java.util.Iterator;
  import java.util.Objects;
  import java.util.NoSuchElementException;
  import java.util.Set;
  import java.util.Spliterator;
  import java.util.Spliterators;
  import java.util.TreeSet;
  import java.util.WeakHashMap;
  import java.util.function.Consumer;
<span class="line-removed">- import java.util.function.Function;</span>
  import java.util.function.IntFunction;
  import java.util.jar.JarEntry;
  import java.util.jar.JarFile;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  import jdk.internal.access.JavaUtilZipFileAccess;
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.misc.VM;
  import jdk.internal.perf.PerfCounter;
  import jdk.internal.ref.CleanerFactory;
  import jdk.internal.vm.annotation.Stable;
  import sun.nio.cs.UTF_8;
  
  import static java.util.zip.ZipConstants64.*;
  import static java.util.zip.ZipUtils.*;
  
  /**
<span class="line-new-header">--- 43,34 ---</span>
  import java.util.Collections;
  import java.util.Deque;
  import java.util.Enumeration;
  import java.util.HashMap;
  import java.util.Iterator;
<span class="line-added">+ import java.util.List;</span>
<span class="line-added">+ import java.util.Locale;</span>
  import java.util.Objects;
  import java.util.NoSuchElementException;
  import java.util.Set;
  import java.util.Spliterator;
  import java.util.Spliterators;
  import java.util.TreeSet;
  import java.util.WeakHashMap;
  import java.util.function.Consumer;
  import java.util.function.IntFunction;
  import java.util.jar.JarEntry;
  import java.util.jar.JarFile;
  import java.util.stream.Stream;
  import java.util.stream.StreamSupport;
  import jdk.internal.access.JavaUtilZipFileAccess;
<span class="line-added">+ import jdk.internal.access.JavaUtilJarAccess;</span>
  import jdk.internal.access.SharedSecrets;
  import jdk.internal.misc.VM;
  import jdk.internal.perf.PerfCounter;
  import jdk.internal.ref.CleanerFactory;
  import jdk.internal.vm.annotation.Stable;
  import sun.nio.cs.UTF_8;
<span class="line-added">+ import sun.security.util.SignatureFileVerifier;</span>
  
  import static java.util.zip.ZipConstants64.*;
  import static java.util.zip.ZipUtils.*;
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,31 ***</span>
       * @param name the name of the entry
       * @return the zip file entry, or null if not found
       * @throws IllegalStateException if the zip file has been closed
       */
      public ZipEntry getEntry(String name) {
<span class="line-removed">-         return getEntry(name, ZipEntry::new);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /*</span>
<span class="line-removed">-      * Returns the zip file entry for the specified name, or null</span>
<span class="line-removed">-      * if not found.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @param name the name of the entry</span>
<span class="line-removed">-      * @param func the function that creates the returned entry</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * @return the zip file entry, or null if not found</span>
<span class="line-removed">-      * @throws IllegalStateException if the zip file has been closed</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {</span>
          Objects.requireNonNull(name, &quot;name&quot;);
          ZipEntry entry = null;
          synchronized (this) {
              ensureOpen();
              int pos = res.zsrc.getEntryPos(name, true);
              if (pos != -1) {
<span class="line-modified">!                 entry = getZipEntry(name, pos, func);</span>
              }
          }
          return entry;
      }
  
<span class="line-new-header">--- 319,17 ---</span>
       * @param name the name of the entry
       * @return the zip file entry, or null if not found
       * @throws IllegalStateException if the zip file has been closed
       */
      public ZipEntry getEntry(String name) {
          Objects.requireNonNull(name, &quot;name&quot;);
          ZipEntry entry = null;
          synchronized (this) {
              ensureOpen();
              int pos = res.zsrc.getEntryPos(name, true);
              if (pos != -1) {
<span class="line-modified">!                 entry = getZipEntry(name, pos);</span>
              }
          }
          return entry;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,15 ***</span>
      private class ZipEntryIterator&lt;T extends ZipEntry&gt;
              implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
  
          private int i = 0;
          private final int entryCount;
<span class="line-removed">-         private final Function&lt;String, T&gt; gen;</span>
  
<span class="line-modified">!         public ZipEntryIterator(int entryCount, Function&lt;String, T&gt; gen) {</span>
              this.entryCount = entryCount;
<span class="line-removed">-             this.gen = gen;</span>
          }
  
          @Override
          public boolean hasMoreElements() {
              return hasNext();
<span class="line-new-header">--- 471,13 ---</span>
      private class ZipEntryIterator&lt;T extends ZipEntry&gt;
              implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
  
          private int i = 0;
          private final int entryCount;
  
<span class="line-modified">!         public ZipEntryIterator(int entryCount) {</span>
              this.entryCount = entryCount;
          }
  
          @Override
          public boolean hasMoreElements() {
              return hasNext();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,11 ***</span>
                  ensureOpen();
                  if (!hasNext()) {
                      throw new NoSuchElementException();
                  }
                  // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified">!                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
              }
          }
  
          @Override
          public Iterator&lt;T&gt; asIterator() {
<span class="line-new-header">--- 500,11 ---</span>
                  ensureOpen();
                  if (!hasNext()) {
                      throw new NoSuchElementException();
                  }
                  // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified">!                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));</span>
              }
          }
  
          @Override
          public Iterator&lt;T&gt; asIterator() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,18 ***</span>
       * @throws IllegalStateException if the zip file has been closed
       */
      public Enumeration&lt;? extends ZipEntry&gt; entries() {
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);</span>
          }
      }
  
<span class="line-modified">!     private Enumeration&lt;JarEntry&gt; entries(Function&lt;String, JarEntry&gt; func) {</span>
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total, func);</span>
          }
      }
  
      private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
          private int index;
<span class="line-new-header">--- 518,18 ---</span>
       * @throws IllegalStateException if the zip file has been closed
       */
      public Enumeration&lt;? extends ZipEntry&gt; entries() {
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total);</span>
          }
      }
  
<span class="line-modified">!     private Enumeration&lt;JarEntry&gt; jarEntries() {</span>
          synchronized (this) {
              ensureOpen();
<span class="line-modified">!             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total);</span>
          }
      }
  
      private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
          private int index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
       */
      public Stream&lt;? extends ZipEntry&gt; stream() {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; getZipEntry(null, pos, ZipEntry::new)), false);</span>
         }
      }
  
      private String getEntryName(int pos) {
          byte[] cen = res.zsrc.cen;
<span class="line-new-header">--- 572,11 ---</span>
       */
      public Stream&lt;? extends ZipEntry&gt; stream() {
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; getZipEntry(null, pos)), false);</span>
         }
      }
  
      private String getEntryName(int pos) {
          byte[] cen = res.zsrc.cen;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 620,29 ***</span>
       * Returns an ordered {@code Stream} over the zip file entries.
       *
       * Entries appear in the {@code Stream} in the order they appear in
       * the central directory of the jar file.
       *
<span class="line-removed">-      * @param func the function that creates the returned entry</span>
       * @return an ordered {@code Stream} of entries in this zip file
       * @throws IllegalStateException if the zip file has been closed
       * @since 10
       */
<span class="line-modified">!     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {</span>
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; (JarEntry)getZipEntry(null, pos, func)), false);</span>
          }
      }
  
      private String lastEntryName;
      private int lastEntryPos;
  
      /* Check ensureOpen() before invoking this method */
<span class="line-modified">!     private ZipEntry getZipEntry(String name, int pos,</span>
<span class="line-removed">-                                  Function&lt;String, ? extends ZipEntry&gt; func) {</span>
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
          int elen = CENEXT(cen, pos);
          int clen = CENCOM(cen, pos);
  
<span class="line-new-header">--- 607,27 ---</span>
       * Returns an ordered {@code Stream} over the zip file entries.
       *
       * Entries appear in the {@code Stream} in the order they appear in
       * the central directory of the jar file.
       *
       * @return an ordered {@code Stream} of entries in this zip file
       * @throws IllegalStateException if the zip file has been closed
       * @since 10
       */
<span class="line-modified">!     private Stream&lt;JarEntry&gt; jarStream() {</span>
          synchronized (this) {
              ensureOpen();
              return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified">!                 pos -&gt; (JarEntry)getZipEntry(null, pos)), false);</span>
          }
      }
  
      private String lastEntryName;
      private int lastEntryPos;
  
      /* Check ensureOpen() before invoking this method */
<span class="line-modified">!     private ZipEntry getZipEntry(String name, int pos) {</span>
          byte[] cen = res.zsrc.cen;
          int nlen = CENNAM(cen, pos);
          int elen = CENEXT(cen, pos);
          int clen = CENCOM(cen, pos);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 658,11 ***</span>
              }
          } else {
              // invoked from iterator, use the entry name stored in cen
              name = zc.toString(cen, pos + CENHDR, nlen);
          }
<span class="line-modified">!         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);</span>
          e.flag = CENFLG(cen, pos);
          e.xdostime = CENTIM(cen, pos);
          e.crc = CENCRC(cen, pos);
          e.size = CENLEN(cen, pos);
          e.csize = CENSIZ(cen, pos);
<span class="line-new-header">--- 643,16 ---</span>
              }
          } else {
              // invoked from iterator, use the entry name stored in cen
              name = zc.toString(cen, pos + CENHDR, nlen);
          }
<span class="line-modified">!         ZipEntry e;</span>
<span class="line-added">+         if (this instanceof JarFile) {</span>
<span class="line-added">+             e = Source.JUJA.entryFor((JarFile)this, name);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             e = new ZipEntry(name);</span>
<span class="line-added">+         }</span>
          e.flag = CENFLG(cen, pos);
          e.xdostime = CENTIM(cen, pos);
          e.crc = CENCRC(cen, pos);
          e.size = CENLEN(cen, pos);
          e.csize = CENSIZ(cen, pos);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1008,35 ***</span>
          }
  
      }
  
      /**
<span class="line-modified">!      * Returns the names of all non-directory entries that begin with</span>
<span class="line-modified">!      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via</span>
<span class="line-modified">!      * SharedSecrets, as an optimization when looking up manifest and</span>
<span class="line-removed">-      * signature file entries. Returns null if no entries were found.</span>
       */
<span class="line-modified">!     private String[] getMetaInfEntryNames() {</span>
          synchronized (this) {
              ensureOpen();
              Source zsrc = res.zsrc;
<span class="line-modified">!             if (zsrc.metanames == null) {</span>
<span class="line-modified">!                 return null;</span>
              }
<span class="line-modified">!             String[] names = new String[zsrc.metanames.length];</span>
<span class="line-modified">!             byte[] cen = zsrc.cen;</span>
<span class="line-modified">!             for (int i = 0; i &lt; names.length; i++) {</span>
<span class="line-modified">!                 int pos = zsrc.metanames[i];</span>
<span class="line-modified">!                 // This will only be invoked on JarFile, which is guaranteed</span>
<span class="line-modified">!                 // to use (or be compatible with) UTF-8 encoding.</span>
<span class="line-modified">!                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),</span>
<span class="line-removed">-                                       UTF_8.INSTANCE);</span>
              }
<span class="line-modified">!             return names;</span>
          }
      }
  
      /**
       * Returns the versions for which there exists a non-directory
       * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
       * This method is used in JarFile, via SharedSecrets, as an
       * optimization when looking up potentially versioned entries.
<span class="line-new-header">--- 998,55 ---</span>
          }
  
      }
  
      /**
<span class="line-modified">!      * Returns the names of the META-INF/MANIFEST.MF entry - if exists -</span>
<span class="line-modified">!      * and any signature-related files under META-INF. This method is used in</span>
<span class="line-modified">!      * JarFile, via SharedSecrets, as an optimization.</span>
       */
<span class="line-modified">!     private List&lt;String&gt; getManifestAndSignatureRelatedFiles() {</span>
          synchronized (this) {
              ensureOpen();
              Source zsrc = res.zsrc;
<span class="line-modified">!             int[] metanames = zsrc.signatureMetaNames;</span>
<span class="line-modified">!             List&lt;String&gt; files = null;</span>
<span class="line-added">+             if (zsrc.manifestPos &gt;= 0) {</span>
<span class="line-added">+                 files = new ArrayList&lt;&gt;();</span>
<span class="line-added">+                 files.add(getEntryName(zsrc.manifestPos));</span>
              }
<span class="line-modified">!             if (metanames != null) {</span>
<span class="line-modified">!                 if (files == null) {</span>
<span class="line-modified">!                     files = new ArrayList&lt;&gt;();</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!                 for (int i = 0; i &lt; metanames.length; i++) {</span>
<span class="line-modified">!                     files.add(getEntryName(metanames[i]));</span>
<span class="line-modified">!                 }</span>
              }
<span class="line-modified">!             return files == null ? List.of() : files;</span>
          }
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns the name of the META-INF/MANIFEST.MF entry, ignoring</span>
<span class="line-added">+      * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the</span>
<span class="line-added">+      * manifest if there is also at least one signature-related file.</span>
<span class="line-added">+      * This method is used in JarFile, via SharedSecrets, as an optimization</span>
<span class="line-added">+      * when looking up the manifest file.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private String getManifestName(boolean onlyIfSignatureRelatedFiles) {</span>
<span class="line-added">+         synchronized (this) {</span>
<span class="line-added">+             ensureOpen();</span>
<span class="line-added">+             Source zsrc = res.zsrc;</span>
<span class="line-added">+             int pos = zsrc.manifestPos;</span>
<span class="line-added">+             if (pos &gt;= 0 &amp;&amp; (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {</span>
<span class="line-added">+                 return getEntryName(pos);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return null;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns the versions for which there exists a non-directory
       * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
       * This method is used in JarFile, via SharedSecrets, as an
       * optimization when looking up potentially versioned entries.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,31 ***</span>
                  @Override
                  public boolean startsWithLocHeader(ZipFile zip) {
                      return zip.res.zsrc.startsWithLoc;
                  }
                  @Override
<span class="line-modified">!                 public String[] getMetaInfEntryNames(JarFile jar) {</span>
<span class="line-modified">!                     return ((ZipFile)jar).getMetaInfEntryNames();</span>
                  }
                  @Override
<span class="line-modified">!                 public int[] getMetaInfVersions(JarFile jar) {</span>
<span class="line-modified">!                     return ((ZipFile)jar).getMetaInfVersions();</span>
                  }
                  @Override
<span class="line-modified">!                 public JarEntry getEntry(ZipFile zip, String name,</span>
<span class="line-modified">!                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">-                     return (JarEntry)zip.getEntry(name, func);</span>
                  }
                  @Override
<span class="line-modified">!                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,</span>
<span class="line-modified">!                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">-                     return zip.entries(func);</span>
                  }
                  @Override
<span class="line-modified">!                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,</span>
<span class="line-modified">!                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">-                     return zip.stream(func);</span>
                  }
                  @Override
                  public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
                      return zip.entryNameStream();
                  }
<span class="line-new-header">--- 1067,28 ---</span>
                  @Override
                  public boolean startsWithLocHeader(ZipFile zip) {
                      return zip.res.zsrc.startsWithLoc;
                  }
                  @Override
<span class="line-modified">!                 public List&lt;String&gt; getManifestAndSignatureRelatedFiles(JarFile jar) {</span>
<span class="line-modified">!                     return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();</span>
                  }
                  @Override
<span class="line-modified">!                 public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {</span>
<span class="line-modified">!                     return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);</span>
                  }
                  @Override
<span class="line-modified">!                 public int[] getMetaInfVersions(JarFile jar) {</span>
<span class="line-modified">!                     return ((ZipFile)jar).getMetaInfVersions();</span>
                  }
                  @Override
<span class="line-modified">!                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip) {</span>
<span class="line-modified">!                     return zip.jarEntries();</span>
                  }
                  @Override
<span class="line-modified">!                 public Stream&lt;JarEntry&gt; stream(ZipFile zip) {</span>
<span class="line-modified">!                     return zip.jarStream();</span>
                  }
                  @Override
                  public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
                      return zip.entryNameStream();
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1089,10 ***</span>
<span class="line-new-header">--- 1096,13 ---</span>
          );
          isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
      }
  
      private static class Source {
<span class="line-added">+         // While this is only used from ZipFile, defining it there would cause</span>
<span class="line-added">+         // a bootstrap cycle that would leave this initialized as null</span>
<span class="line-added">+         private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();</span>
          // &quot;META-INF/&quot;.length()
          private static final int META_INF_LENGTH = 9;
          private static final int[] EMPTY_META_VERSIONS = new int[0];
  
          private final Key key;               // the key in files
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1103,11 ***</span>
          private RandomAccessFile zfile;      // zfile of the underlying zip file
          private byte[] cen;                  // CEN &amp; ENDHDR
          private long locpos;                 // position of first LOC header (usually 0)
          private byte[] comment;              // zip file comment
                                               // list of meta entries in META-INF dir
<span class="line-modified">!         private int[] metanames;</span>
          private int[] metaVersions;          // list of unique versions found in META-INF/versions/
          private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
  
          // A Hashmap for all entries.
          //
<span class="line-new-header">--- 1113,12 ---</span>
          private RandomAccessFile zfile;      // zfile of the underlying zip file
          private byte[] cen;                  // CEN &amp; ENDHDR
          private long locpos;                 // position of first LOC header (usually 0)
          private byte[] comment;              // zip file comment
                                               // list of meta entries in META-INF dir
<span class="line-modified">!         private int   manifestPos = -1;      // position of the META-INF/MANIFEST.MF, if exists</span>
<span class="line-added">+         private int[] signatureMetaNames;    // positions of signature related entries, if such exist</span>
          private int[] metaVersions;          // list of unique versions found in META-INF/versions/
          private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
  
          // A Hashmap for all entries.
          //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1252,11 ***</span>
              zfile.close();
              zfile = null;
              cen = null;
              entries = null;
              table = null;
<span class="line-modified">!             metanames = null;</span>
              metaVersions = EMPTY_META_VERSIONS;
          }
  
          private static final int BUF_SIZE = 8192;
          private final int readFullyAt(byte[] buf, int off, int len, long pos)
<span class="line-new-header">--- 1263,12 ---</span>
              zfile.close();
              zfile = null;
              cen = null;
              entries = null;
              table = null;
<span class="line-modified">!             manifestPos = -1;</span>
<span class="line-added">+             signatureMetaNames = null;</span>
              metaVersions = EMPTY_META_VERSIONS;
          }
  
          private static final int BUF_SIZE = 8192;
          private final int readFullyAt(byte[] buf, int off, int len, long pos)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1436,11 ***</span>
              int idx = 0;
              int hash;
              int next;
  
              // list for all meta entries
<span class="line-modified">!             ArrayList&lt;Integer&gt; metanamesList = null;</span>
              // Set of all version numbers seen in META-INF/versions/
              Set&lt;Integer&gt; metaVersionsSet = null;
  
              // Iterate through the entries in the central directory
              int i = 0;
<span class="line-new-header">--- 1448,11 ---</span>
              int idx = 0;
              int hash;
              int next;
  
              // list for all meta entries
<span class="line-modified">!             ArrayList&lt;Integer&gt; signatureNames = null;</span>
              // Set of all version numbers seen in META-INF/versions/
              Set&lt;Integer&gt; metaVersionsSet = null;
  
              // Iterate through the entries in the central directory
              int i = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1474,35 ***</span>
                  next = table[hsh];
                  table[hsh] = idx;
                  idx = addEntry(idx, hash, next, pos);
                  // Adds name to metanames.
                  if (isMetaName(cen, entryPos, nlen)) {
<span class="line-modified">!                     if (metanamesList == null)</span>
<span class="line-modified">!                         metanamesList = new ArrayList&lt;&gt;(4);</span>
<span class="line-modified">!                     metanamesList.add(pos);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     // If this is a versioned entry, parse the version</span>
<span class="line-modified">!                     // and store it for later. This optimizes lookup</span>
<span class="line-modified">!                     // performance in multi-release jar files</span>
<span class="line-modified">!                     int version = getMetaVersion(cen,</span>
<span class="line-modified">!                         entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);</span>
<span class="line-modified">!                     if (version &gt; 0) {</span>
<span class="line-modified">!                         if (metaVersionsSet == null)</span>
<span class="line-modified">!                             metaVersionsSet = new TreeSet&lt;&gt;();</span>
<span class="line-modified">!                         metaVersionsSet.add(version);</span>
                      }
                  }
                  // skip ext and comment
                  pos = entryPos + nlen + elen + clen;
                  entryPos = pos + CENHDR;
                  i++;
              }
              total = i;
<span class="line-modified">!             if (metanamesList != null) {</span>
<span class="line-modified">!                 metanames = new int[metanamesList.size()];</span>
<span class="line-modified">!                 for (int j = 0, len = metanames.length; j &lt; len; j++) {</span>
<span class="line-modified">!                     metanames[j] = metanamesList.get(j);</span>
                  }
              }
              if (metaVersionsSet != null) {
                  metaVersions = new int[metaVersionsSet.size()];
                  int c = 0;
<span class="line-new-header">--- 1486,44 ---</span>
                  next = table[hsh];
                  table[hsh] = idx;
                  idx = addEntry(idx, hash, next, pos);
                  // Adds name to metanames.
                  if (isMetaName(cen, entryPos, nlen)) {
<span class="line-modified">!                     // nlen is at least META_INF_LENGTH</span>
<span class="line-modified">!                     if (isManifestName(cen, entryPos + META_INF_LENGTH,</span>
<span class="line-modified">!                             nlen - META_INF_LENGTH)) {</span>
<span class="line-modified">!                         manifestPos = pos;</span>
<span class="line-modified">!                     } else {</span>
<span class="line-modified">!                         if (isSignatureRelated(cen, entryPos, nlen)) {</span>
<span class="line-modified">!                             if (signatureNames == null)</span>
<span class="line-modified">!                                 signatureNames = new ArrayList&lt;&gt;(4);</span>
<span class="line-modified">!                             signatureNames.add(pos);</span>
<span class="line-modified">!                         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         // If this is a versioned entry, parse the version</span>
<span class="line-modified">!                         // and store it for later. This optimizes lookup</span>
<span class="line-added">+                         // performance in multi-release jar files</span>
<span class="line-added">+                         int version = getMetaVersion(cen,</span>
<span class="line-added">+                             entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);</span>
<span class="line-added">+                         if (version &gt; 0) {</span>
<span class="line-added">+                             if (metaVersionsSet == null)</span>
<span class="line-added">+                                 metaVersionsSet = new TreeSet&lt;&gt;();</span>
<span class="line-added">+                             metaVersionsSet.add(version);</span>
<span class="line-added">+                         }</span>
                      }
                  }
                  // skip ext and comment
                  pos = entryPos + nlen + elen + clen;
                  entryPos = pos + CENHDR;
                  i++;
              }
              total = i;
<span class="line-modified">!             if (signatureNames != null) {</span>
<span class="line-modified">!                 int len = signatureNames.size();</span>
<span class="line-modified">!                 signatureMetaNames = new int[len];</span>
<span class="line-modified">!                 for (int j = 0; j &lt; len; j++) {</span>
<span class="line-added">+                     signatureMetaNames[j] = signatureNames.get(j);</span>
                  }
              }
              if (metaVersionsSet != null) {
                  metaVersions = new int[metaVersionsSet.size()];
                  int c = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1578,11 ***</span>
          /**
           * Returns true if the bytes represent a non-directory name
           * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
           */
          private static boolean isMetaName(byte[] name, int off, int len) {
<span class="line-modified">!             // Use the &quot;oldest ASCII trick in the book&quot;</span>
              return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
                  &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
                  &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
                  &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
                  &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
<span class="line-new-header">--- 1599,12 ---</span>
          /**
           * Returns true if the bytes represent a non-directory name
           * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
           */
          private static boolean isMetaName(byte[] name, int off, int len) {
<span class="line-modified">!             // Use the &quot;oldest ASCII trick in the book&quot;:</span>
<span class="line-added">+             // ch | 0x20 == Character.toLowerCase(ch)</span>
              return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
                  &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
                  &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
                  &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
                  &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1592,10 ***</span>
<span class="line-new-header">--- 1614,56 ---</span>
                  &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
                  &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
                  &amp;&amp; (name[off]         ) == &#39;/&#39;;
          }
  
<span class="line-added">+         /*</span>
<span class="line-added">+          * Check if the bytes represents a name equals to MANIFEST.MF</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static boolean isManifestName(byte[] name, int off, int len) {</span>
<span class="line-added">+             return (len == 11 // &quot;MANIFEST.MF&quot;.length()</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++]       ) == &#39;.&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;</span>
<span class="line-added">+                     &amp;&amp; (name[off]   | 0x20) == &#39;f&#39;);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         private static boolean isSignatureRelated(byte[] name, int off, int len) {</span>
<span class="line-added">+             // Only called when isMetaName(name, off, len) is true, which means</span>
<span class="line-added">+             // len is at least META_INF_LENGTH</span>
<span class="line-added">+             // assert isMetaName(name, off, len)</span>
<span class="line-added">+             boolean signatureRelated = false;</span>
<span class="line-added">+             if (name[off + len - 3] == &#39;.&#39;) {</span>
<span class="line-added">+                 // Check if entry ends with .EC and .SF</span>
<span class="line-added">+                 int b1 = name[off + len - 2] | 0x20;</span>
<span class="line-added">+                 int b2 = name[off + len - 1] | 0x20;</span>
<span class="line-added">+                 if ((b1 == &#39;e&#39; &amp;&amp; b2 == &#39;c&#39;) || (b1 == &#39;s&#39; &amp;&amp; b2 == &#39;f&#39;)) {</span>
<span class="line-added">+                     signatureRelated = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else if (name[off + len - 4] == &#39;.&#39;) {</span>
<span class="line-added">+                 // Check if entry ends with .DSA and .RSA</span>
<span class="line-added">+                 int b1 = name[off + len - 3] | 0x20;</span>
<span class="line-added">+                 int b2 = name[off + len - 2] | 0x20;</span>
<span class="line-added">+                 int b3 = name[off + len - 1] | 0x20;</span>
<span class="line-added">+                 if ((b1 == &#39;r&#39; || b1 == &#39;d&#39;) &amp;&amp; b2 == &#39;s&#39; &amp;&amp; b3 == &#39;a&#39;) {</span>
<span class="line-added">+                     signatureRelated = true;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // Above logic must match SignatureFileVerifier.isBlockOrSF</span>
<span class="line-added">+             assert(signatureRelated == SignatureFileVerifier</span>
<span class="line-added">+                 .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)</span>
<span class="line-added">+                     .toUpperCase(Locale.ENGLISH)));</span>
<span class="line-added">+             return signatureRelated;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          /*
           * If the bytes represents a non-directory name beginning
           * with &quot;versions/&quot;, continuing with a positive integer,
           * followed by a &#39;/&#39;, then return that integer value.
           * Otherwise, return 0
</pre>
<center><a href="../regex/Grapheme.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilJarAccess.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/jar/JarFile.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 127,17 ***</span>
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
      /**
       * Concatenation strategy to use. See {@link Strategy} for possible options.
       * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
       */
<span class="line-modified">!     private static Strategy STRATEGY;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Default strategy to use for concatenation.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final Strategy DEFAULT_STRATEGY = Strategy.MH_INLINE_SIZED_EXACT;</span>
  
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
      private enum Strategy {
          /**
<span class="line-new-header">--- 127,14 ---</span>
      private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
  
      /**
       * Concatenation strategy to use. See {@link Strategy} for possible options.
       * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
<span class="line-added">+      *</span>
<span class="line-added">+      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
       */
<span class="line-modified">!     private static final Strategy STRATEGY;</span>
  
      private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
  
      private enum Strategy {
          /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,46 ***</span>
       * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
       * checks, etc.
       */
      private static final boolean DEBUG;
  
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed">-      * code, at the expense of contaminating the profiles.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final boolean CACHE_ENABLE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /**</span>
<span class="line-removed">-      * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed">- </span>
      static {
<span class="line-removed">-         // In case we need to double-back onto the StringConcatFactory during this</span>
<span class="line-removed">-         // static initialization, make sure we have the reasonable defaults to complete</span>
<span class="line-removed">-         // the static initialization properly. After that, actual users would use</span>
<span class="line-removed">-         // the proper values we have read from the properties.</span>
<span class="line-removed">-         STRATEGY = DEFAULT_STRATEGY;</span>
<span class="line-removed">-         // CACHE_ENABLE = false; // implied</span>
<span class="line-removed">-         // CACHE = null;         // implied</span>
<span class="line-removed">-         // DEBUG = false;        // implied</span>
<span class="line-removed">-         // DUMPER = null;        // implied</span>
<span class="line-removed">- </span>
          final String strategy =
                  VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified">!         CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-modified">!                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
          DEBUG = Boolean.parseBoolean(
                  VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
<span class="line-removed">-         final String dumpPath =</span>
<span class="line-removed">-                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);</span>
<span class="line-removed">-         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed">-         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
      }
  
      /**
       * Cache key is a composite of:
       *   - class name, that lets to disambiguate stubs, to avoid excess sharing
<span class="line-new-header">--- 177,17 ---</span>
       * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
       * checks, etc.
       */
      private static final boolean DEBUG;
  
      static {
          final String strategy =
                  VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified">!         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-modified">! </span>
          DEBUG = Boolean.parseBoolean(
                  VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
      }
  
      /**
       * Cache key is a composite of:
       *   - class name, that lets to disambiguate stubs, to avoid excess sharing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,11 ***</span>
              return result;
          }
      }
  
      /**
<span class="line-modified">!      * Parses the recipe string, and produces the traversable collection of</span>
       * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
       * strategies. Notably, this class parses out the constants from the recipe
       * and from other static arguments.
       */
      private static final class Recipe {
<span class="line-new-header">--- 226,11 ---</span>
              return result;
          }
      }
  
      /**
<span class="line-modified">!      * Parses the recipe string, and produces a traversable collection of</span>
       * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
       * strategies. Notably, this class parses out the constants from the recipe
       * and from other static arguments.
       */
      private static final class Recipe {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,25 ***</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
<span class="line-removed">-         String className = getClassName(lookup.lookupClass());</span>
          MethodType mt = adaptType(concatType);
          Recipe rec = new Recipe(recipe, constants);
<span class="line-modified">! </span>
<span class="line-removed">-         MethodHandle mh;</span>
<span class="line-removed">-         if (CACHE_ENABLE) {</span>
<span class="line-removed">-             Key key = new Key(className, mt, rec);</span>
<span class="line-removed">-             mh = CACHE.get(key);</span>
<span class="line-removed">-             if (mh == null) {</span>
<span class="line-removed">-                 mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed">-                 CACHE.put(key, mh);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-             mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed">-         }</span>
          return new ConstantCallSite(mh.asType(concatType));
      }
  
      /**
       * Adapt method type to an API we are going to use.
<span class="line-new-header">--- 634,13 ---</span>
                      concatType.parameterSlotCount() +
                      &quot;, can only accept &quot; +
                      MAX_INDY_CONCAT_ARG_SLOTS);
          }
  
          MethodType mt = adaptType(concatType);
          Recipe rec = new Recipe(recipe, constants);
<span class="line-modified">!         MethodHandle mh = generate(lookup, mt, rec);</span>
          return new ConstantCallSite(mh.asType(concatType));
      }
  
      /**
       * Adapt method type to an API we are going to use.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,50 ***</span>
          return (ptypes != null)
                  ? MethodType.methodType(args.returnType(), ptypes)
                  : args;
      }
  
<span class="line-modified">!     private static String getClassName(Class&lt;?&gt; hostClass) throws StringConcatException {</span>
<span class="line-removed">-         /*</span>
<span class="line-removed">-           The generated class is in the same package as the host class as</span>
<span class="line-removed">-           it&#39;s the implementation of the string concatenation for the host class.</span>
<span class="line-removed">- </span>
<span class="line-removed">-           When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed">-          */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         switch (STRATEGY) {</span>
<span class="line-removed">-             case BC_SB:</span>
<span class="line-removed">-             case BC_SB_SIZED:</span>
<span class="line-removed">-             case BC_SB_SIZED_EXACT: {</span>
<span class="line-removed">-                 if (CACHE_ENABLE) {</span>
<span class="line-removed">-                     String pkgName = hostClass.getPackageName();</span>
<span class="line-removed">-                     return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed">-                 } else {</span>
<span class="line-removed">-                     String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed">-                                                        : hostClass.getName();</span>
<span class="line-removed">-                     return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             case MH_SB_SIZED:</span>
<span class="line-removed">-             case MH_SB_SIZED_EXACT:</span>
<span class="line-removed">-             case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed">-                 // MethodHandle strategies do not need a class name.</span>
<span class="line-removed">-                 return &quot;&quot;;</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private static MethodHandle generate(Lookup lookup, String className, MethodType mt, Recipe recipe) throws StringConcatException {</span>
          try {
              switch (STRATEGY) {
                  case BC_SB:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.DEFAULT);</span>
                  case BC_SB_SIZED:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED);</span>
                  case BC_SB_SIZED_EXACT:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED_EXACT);</span>
                  case MH_SB_SIZED:
                      return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
                  case MH_SB_SIZED_EXACT:
                      return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
                  case MH_INLINE_SIZED_EXACT:
<span class="line-new-header">--- 668,22 ---</span>
          return (ptypes != null)
                  ? MethodType.methodType(args.returnType(), ptypes)
                  : args;
      }
  
<span class="line-modified">!     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>
          try {
<span class="line-added">+             if (STRATEGY == null) {</span>
<span class="line-added">+                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-added">+             }</span>
              switch (STRATEGY) {
                  case BC_SB:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
                  case BC_SB_SIZED:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
                  case BC_SB_SIZED_EXACT:
<span class="line-modified">!                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
                  case MH_SB_SIZED:
                      return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
                  case MH_SB_SIZED_EXACT:
                      return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
                  case MH_INLINE_SIZED_EXACT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,15 ***</span>
       */
      private static final class BytecodeStringBuilderStrategy {
          static final int CLASSFILE_VERSION = 52;
          static final String METHOD_NAME = &quot;concat&quot;;
  
          private BytecodeStringBuilderStrategy() {
              // no instantiation
          }
  
<span class="line-modified">!         private static MethodHandle generate(Lookup lookup, String className, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
              ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
  
              cw.visit(CLASSFILE_VERSION,
                      ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
                      className,
<span class="line-new-header">--- 762,49 ---</span>
       */
      private static final class BytecodeStringBuilderStrategy {
          static final int CLASSFILE_VERSION = 52;
          static final String METHOD_NAME = &quot;concat&quot;;
  
<span class="line-added">+         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-added">+          * code, at the expense of contaminating the profiles.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static final boolean CACHE_ENABLE;</span>
<span class="line-added">+ </span>
<span class="line-added">+         /**</span>
<span class="line-added">+          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-added">+ </span>
<span class="line-added">+         static {</span>
<span class="line-added">+             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-added">+                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-added">+             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-added">+ </span>
<span class="line-added">+             final String dumpPath =</span>
<span class="line-added">+                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private BytecodeStringBuilderStrategy() {
              // no instantiation
          }
  
<span class="line-modified">!         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-added">+             String className = getClassName(lookup.lookupClass());</span>
<span class="line-added">+             Key key = null;</span>
<span class="line-added">+             if (CACHE_ENABLE) {</span>
<span class="line-added">+                 key = new Key(className, args, recipe);</span>
<span class="line-added">+                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-added">+                 if (mh != null) {</span>
<span class="line-added">+                     return mh;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
  
              cw.visit(CLASSFILE_VERSION,
                      ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
                      className,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1128,17 ***</span>
  
              byte[] classBytes = cw.toByteArray();
              try {
                  Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
                  dumpIfEnabled(className, classBytes);
<span class="line-modified">!                 return lookup.findStatic(innerClass, METHOD_NAME, args);</span>
              } catch (Exception e) {
                  dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
                  throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
              }
          }
  
          private static void dumpIfEnabled(String name, byte[] bytes) {
              if (DUMPER != null) {
                  DUMPER.dumpClass(name, bytes);
              }
          }
<span class="line-new-header">--- 1090,39 ---</span>
  
              byte[] classBytes = cw.toByteArray();
              try {
                  Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
                  dumpIfEnabled(className, classBytes);
<span class="line-modified">!                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-added">+                 if (CACHE_ENABLE) {</span>
<span class="line-added">+                     CACHE.put(key, mh);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return mh;</span>
              } catch (Exception e) {
                  dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
                  throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
              }
          }
  
<span class="line-added">+         /**</span>
<span class="line-added">+          * The generated class is in the same package as the host class as</span>
<span class="line-added">+          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-added">+          * class.</span>
<span class="line-added">+          *</span>
<span class="line-added">+          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-added">+             if (CACHE_ENABLE) {</span>
<span class="line-added">+                 String pkgName = hostClass.getPackageName();</span>
<span class="line-added">+                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-added">+                         : hostClass.getName();</span>
<span class="line-added">+                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          private static void dumpIfEnabled(String name, byte[] bytes) {
              if (DUMPER != null) {
                  DUMPER.dumpClass(name, bytes);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1705,11 ***</span>
          }
  
          private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
              return MethodHandles.insertArguments(
                      MethodHandles.insertArguments(
<span class="line-modified">!                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>
          }
  
          private static MethodHandle mixer(Class&lt;?&gt; cl) {
              return MIXERS.computeIfAbsent(cl, MIX);
          }
<span class="line-new-header">--- 1689,11 ---</span>
          }
  
          private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
              return MethodHandles.insertArguments(
                      MethodHandles.insertArguments(
<span class="line-modified">!                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
          }
  
          private static MethodHandle mixer(Class&lt;?&gt; cl) {
              return MIXERS.computeIfAbsent(cl, MIX);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1750,11 ***</span>
              PREPENDERS = new ConcurrentHashMap&lt;&gt;();
              MIXERS = new ConcurrentHashMap&lt;&gt;();
  
              SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
              NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-modified">!             NEW_ARRAY  = JLA.stringConcatHelper( &quot;newArray&quot;, methodType(byte[].class, long.class));</span>
          }
      }
  
      /**
       * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
<span class="line-new-header">--- 1734,11 ---</span>
              PREPENDERS = new ConcurrentHashMap&lt;&gt;();
              MIXERS = new ConcurrentHashMap&lt;&gt;();
  
              SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
              NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-modified">!             NEW_ARRAY  = JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
          }
      }
  
      /**
       * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
</pre>
<center><a href="MethodHandles.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/jar/JarFile.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/zip/ZipFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../regex/Grapheme.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilJarAccess.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/zip/ZipFile.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;


  48 import java.util.Objects;
  49 import java.util.NoSuchElementException;
  50 import java.util.Set;
  51 import java.util.Spliterator;
  52 import java.util.Spliterators;
  53 import java.util.TreeSet;
  54 import java.util.WeakHashMap;
  55 import java.util.function.Consumer;
<span class="line-removed">  56 import java.util.function.Function;</span>
  57 import java.util.function.IntFunction;
  58 import java.util.jar.JarEntry;
  59 import java.util.jar.JarFile;
  60 import java.util.stream.Stream;
  61 import java.util.stream.StreamSupport;
  62 import jdk.internal.access.JavaUtilZipFileAccess;

  63 import jdk.internal.access.SharedSecrets;
  64 import jdk.internal.misc.VM;
  65 import jdk.internal.perf.PerfCounter;
  66 import jdk.internal.ref.CleanerFactory;
  67 import jdk.internal.vm.annotation.Stable;
  68 import sun.nio.cs.UTF_8;

  69 
  70 import static java.util.zip.ZipConstants64.*;
  71 import static java.util.zip.ZipUtils.*;
  72 
  73 /**
  74  * This class is used to read entries from a zip file.
  75  *
  76  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  77  * or method in this class will cause a {@link NullPointerException} to be
  78  * thrown.
  79  *
  80  * @apiNote
  81  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  82  * should be called explicitly or by try-with-resources. Subclasses are responsible
  83  * for the cleanup of resources acquired by the subclass. Subclasses that override
  84  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  85  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  86  * {@code finalize} method.
  87  *
  88  * @author      David Connelly
</pre>
<hr />
<pre>
 301      */
 302     public String getComment() {
 303         synchronized (this) {
 304             ensureOpen();
 305             if (res.zsrc.comment == null) {
 306                 return null;
 307             }
 308             return res.zsrc.zc.toString(res.zsrc.comment);
 309         }
 310     }
 311 
 312     /**
 313      * Returns the zip file entry for the specified name, or null
 314      * if not found.
 315      *
 316      * @param name the name of the entry
 317      * @return the zip file entry, or null if not found
 318      * @throws IllegalStateException if the zip file has been closed
 319      */
 320     public ZipEntry getEntry(String name) {
<span class="line-removed"> 321         return getEntry(name, ZipEntry::new);</span>
<span class="line-removed"> 322     }</span>
<span class="line-removed"> 323 </span>
<span class="line-removed"> 324     /*</span>
<span class="line-removed"> 325      * Returns the zip file entry for the specified name, or null</span>
<span class="line-removed"> 326      * if not found.</span>
<span class="line-removed"> 327      *</span>
<span class="line-removed"> 328      * @param name the name of the entry</span>
<span class="line-removed"> 329      * @param func the function that creates the returned entry</span>
<span class="line-removed"> 330      *</span>
<span class="line-removed"> 331      * @return the zip file entry, or null if not found</span>
<span class="line-removed"> 332      * @throws IllegalStateException if the zip file has been closed</span>
<span class="line-removed"> 333      */</span>
<span class="line-removed"> 334     private ZipEntry getEntry(String name, Function&lt;String, ? extends ZipEntry&gt; func) {</span>
 335         Objects.requireNonNull(name, &quot;name&quot;);
 336         ZipEntry entry = null;
 337         synchronized (this) {
 338             ensureOpen();
 339             int pos = res.zsrc.getEntryPos(name, true);
 340             if (pos != -1) {
<span class="line-modified"> 341                 entry = getZipEntry(name, pos, func);</span>
 342             }
 343         }
 344         return entry;
 345     }
 346 
 347     /**
 348      * Returns an input stream for reading the contents of the specified
 349      * zip file entry.
 350      * &lt;p&gt;
 351      * Closing this ZIP file will, in turn, close all input streams that
 352      * have been returned by invocations of this method.
 353      *
 354      * @param entry the zip file entry
 355      * @return the input stream for reading the contents of the specified
 356      * zip file entry.
 357      * @throws ZipException if a ZIP format error has occurred
 358      * @throws IOException if an I/O error has occurred
 359      * @throws IllegalStateException if the zip file has been closed
 360      */
 361     public InputStream getInputStream(ZipEntry entry) throws IOException {
</pre>
<hr />
<pre>
 467                 return 0;
 468             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 469             return (avail &gt; (long) Integer.MAX_VALUE ?
 470                     Integer.MAX_VALUE : (int) avail);
 471         }
 472     }
 473 
 474     /**
 475      * Returns the path name of the ZIP file.
 476      * @return the path name of the ZIP file
 477      */
 478     public String getName() {
 479         return name;
 480     }
 481 
 482     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 483             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 484 
 485         private int i = 0;
 486         private final int entryCount;
<span class="line-removed"> 487         private final Function&lt;String, T&gt; gen;</span>
 488 
<span class="line-modified"> 489         public ZipEntryIterator(int entryCount, Function&lt;String, T&gt; gen) {</span>
 490             this.entryCount = entryCount;
<span class="line-removed"> 491             this.gen = gen;</span>
 492         }
 493 
 494         @Override
 495         public boolean hasMoreElements() {
 496             return hasNext();
 497         }
 498 
 499         @Override
 500         public boolean hasNext() {
 501             return i &lt; entryCount;
 502         }
 503 
 504         @Override
 505         public T nextElement() {
 506             return next();
 507         }
 508 
 509         @Override
 510         @SuppressWarnings(&quot;unchecked&quot;)
 511         public T next() {
 512             synchronized (ZipFile.this) {
 513                 ensureOpen();
 514                 if (!hasNext()) {
 515                     throw new NoSuchElementException();
 516                 }
 517                 // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified"> 518                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3), gen);</span>
 519             }
 520         }
 521 
 522         @Override
 523         public Iterator&lt;T&gt; asIterator() {
 524             return this;
 525         }
 526     }
 527 
 528     /**
 529      * Returns an enumeration of the ZIP file entries.
 530      * @return an enumeration of the ZIP file entries
 531      * @throws IllegalStateException if the zip file has been closed
 532      */
 533     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 534         synchronized (this) {
 535             ensureOpen();
<span class="line-modified"> 536             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total, ZipEntry::new);</span>
 537         }
 538     }
 539 
<span class="line-modified"> 540     private Enumeration&lt;JarEntry&gt; entries(Function&lt;String, JarEntry&gt; func) {</span>
 541         synchronized (this) {
 542             ensureOpen();
<span class="line-modified"> 543             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total, func);</span>
 544         }
 545     }
 546 
 547     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 548         private int index;
 549         private final int fence;
 550         private final IntFunction&lt;T&gt; gen;
 551 
 552         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 553             super((long)fence,
 554                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 555                   Spliterator.NONNULL);
 556             this.index = index;
 557             this.fence = fence;
 558             this.gen = gen;
 559         }
 560 
 561         @Override
 562         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 563             if (action == null)
</pre>
<hr />
<pre>
 570                 return true;
 571             }
 572             return false;
 573         }
 574     }
 575 
 576     /**
 577      * Returns an ordered {@code Stream} over the ZIP file entries.
 578      *
 579      * Entries appear in the {@code Stream} in the order they appear in
 580      * the central directory of the ZIP file.
 581      *
 582      * @return an ordered {@code Stream} of entries in this ZIP file
 583      * @throws IllegalStateException if the zip file has been closed
 584      * @since 1.8
 585      */
 586     public Stream&lt;? extends ZipEntry&gt; stream() {
 587         synchronized (this) {
 588             ensureOpen();
 589             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 590                 pos -&gt; getZipEntry(null, pos, ZipEntry::new)), false);</span>
 591        }
 592     }
 593 
 594     private String getEntryName(int pos) {
 595         byte[] cen = res.zsrc.cen;
 596         int nlen = CENNAM(cen, pos);
 597         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 598         return zc.toString(cen, pos + CENHDR, nlen);
 599     }
 600 
 601     /*
 602      * Returns an ordered {@code Stream} over the zip file entry names.
 603      *
 604      * Entry names appear in the {@code Stream} in the order they appear in
 605      * the central directory of the ZIP file.
 606      *
 607      * @return an ordered {@code Stream} of entry names in this zip file
 608      * @throws IllegalStateException if the zip file has been closed
 609      * @since 10
 610      */
 611     private Stream&lt;String&gt; entryNameStream() {
 612         synchronized (this) {
 613             ensureOpen();
 614             return StreamSupport.stream(
 615                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 616         }
 617     }
 618 
 619     /*
 620      * Returns an ordered {@code Stream} over the zip file entries.
 621      *
 622      * Entries appear in the {@code Stream} in the order they appear in
 623      * the central directory of the jar file.
 624      *
<span class="line-removed"> 625      * @param func the function that creates the returned entry</span>
 626      * @return an ordered {@code Stream} of entries in this zip file
 627      * @throws IllegalStateException if the zip file has been closed
 628      * @since 10
 629      */
<span class="line-modified"> 630     private Stream&lt;JarEntry&gt; stream(Function&lt;String, JarEntry&gt; func) {</span>
 631         synchronized (this) {
 632             ensureOpen();
 633             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 634                 pos -&gt; (JarEntry)getZipEntry(null, pos, func)), false);</span>
 635         }
 636     }
 637 
 638     private String lastEntryName;
 639     private int lastEntryPos;
 640 
 641     /* Check ensureOpen() before invoking this method */
<span class="line-modified"> 642     private ZipEntry getZipEntry(String name, int pos,</span>
<span class="line-removed"> 643                                  Function&lt;String, ? extends ZipEntry&gt; func) {</span>
 644         byte[] cen = res.zsrc.cen;
 645         int nlen = CENNAM(cen, pos);
 646         int elen = CENEXT(cen, pos);
 647         int clen = CENCOM(cen, pos);
 648 
 649         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 650         if (name != null) {
 651             // only need to check for mismatch of trailing slash
 652             if (nlen &gt; 0 &amp;&amp;
 653                 !name.isEmpty() &amp;&amp;
 654                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;
 655                 !name.endsWith(&quot;/&quot;))
 656             {
 657                 name += &#39;/&#39;;
 658             }
 659         } else {
 660             // invoked from iterator, use the entry name stored in cen
 661             name = zc.toString(cen, pos + CENHDR, nlen);
 662         }
<span class="line-modified"> 663         ZipEntry e = func.apply(name);    //ZipEntry e = new ZipEntry(name);</span>





 664         e.flag = CENFLG(cen, pos);
 665         e.xdostime = CENTIM(cen, pos);
 666         e.crc = CENCRC(cen, pos);
 667         e.size = CENLEN(cen, pos);
 668         e.csize = CENSIZ(cen, pos);
 669         e.method = CENHOW(cen, pos);
 670         if (elen != 0) {
 671             int start = pos + CENHDR + nlen;
 672             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 673         }
 674         if (clen != 0) {
 675             int start = pos + CENHDR + nlen + elen;
 676             e.comment = zc.toString(cen, start, clen);
 677         }
 678         lastEntryName = e.name;
 679         lastEntryPos = pos;
 680         return e;
 681     }
 682 
 683     /**
</pre>
<hr />
<pre>
 993         }
 994 
 995         public long size() {
 996             return size;
 997         }
 998 
 999         public void close() {
1000             if (closeRequested) {
1001                 return;
1002             }
1003             closeRequested = true;
1004             rem = 0;
1005             synchronized (res.istreams) {
1006                 res.istreams.remove(this);
1007             }
1008         }
1009 
1010     }
1011 
1012     /**
<span class="line-modified">1013      * Returns the names of all non-directory entries that begin with</span>
<span class="line-modified">1014      * &quot;META-INF/&quot; (case ignored). This method is used in JarFile, via</span>
<span class="line-modified">1015      * SharedSecrets, as an optimization when looking up manifest and</span>
<span class="line-removed">1016      * signature file entries. Returns null if no entries were found.</span>
1017      */
<span class="line-modified">1018     private String[] getMetaInfEntryNames() {</span>
1019         synchronized (this) {
1020             ensureOpen();
1021             Source zsrc = res.zsrc;
<span class="line-modified">1022             if (zsrc.metanames == null) {</span>
<span class="line-modified">1023                 return null;</span>



1024             }
<span class="line-modified">1025             String[] names = new String[zsrc.metanames.length];</span>
<span class="line-modified">1026             byte[] cen = zsrc.cen;</span>
<span class="line-modified">1027             for (int i = 0; i &lt; names.length; i++) {</span>
<span class="line-modified">1028                 int pos = zsrc.metanames[i];</span>
<span class="line-modified">1029                 // This will only be invoked on JarFile, which is guaranteed</span>
<span class="line-modified">1030                 // to use (or be compatible with) UTF-8 encoding.</span>
<span class="line-modified">1031                 names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),</span>
<span class="line-removed">1032                                       UTF_8.INSTANCE);</span>
1033             }
<span class="line-modified">1034             return names;</span>
1035         }
1036     }
1037 



















1038     /**
1039      * Returns the versions for which there exists a non-directory
1040      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1041      * This method is used in JarFile, via SharedSecrets, as an
1042      * optimization when looking up potentially versioned entries.
1043      * Returns an empty array if no versioned entries exist.
1044      */
1045     private int[] getMetaInfVersions() {
1046         synchronized (this) {
1047             ensureOpen();
1048             return res.zsrc.metaVersions;
1049         }
1050     }
1051 
1052     private static boolean isWindows;
1053 
1054     static {
1055         SharedSecrets.setJavaUtilZipFileAccess(
1056             new JavaUtilZipFileAccess() {
1057                 @Override
1058                 public boolean startsWithLocHeader(ZipFile zip) {
1059                     return zip.res.zsrc.startsWithLoc;
1060                 }
1061                 @Override
<span class="line-modified">1062                 public String[] getMetaInfEntryNames(JarFile jar) {</span>
<span class="line-modified">1063                     return ((ZipFile)jar).getMetaInfEntryNames();</span>
1064                 }
1065                 @Override
<span class="line-modified">1066                 public int[] getMetaInfVersions(JarFile jar) {</span>
<span class="line-modified">1067                     return ((ZipFile)jar).getMetaInfVersions();</span>
1068                 }
1069                 @Override
<span class="line-modified">1070                 public JarEntry getEntry(ZipFile zip, String name,</span>
<span class="line-modified">1071                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">1072                     return (JarEntry)zip.getEntry(name, func);</span>
1073                 }
1074                 @Override
<span class="line-modified">1075                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip,</span>
<span class="line-modified">1076                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">1077                     return zip.entries(func);</span>
1078                 }
1079                 @Override
<span class="line-modified">1080                 public Stream&lt;JarEntry&gt; stream(ZipFile zip,</span>
<span class="line-modified">1081                     Function&lt;String, JarEntry&gt; func) {</span>
<span class="line-removed">1082                     return zip.stream(func);</span>
1083                 }
1084                 @Override
1085                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1086                     return zip.entryNameStream();
1087                 }
1088              }
1089         );
1090         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1091     }
1092 
1093     private static class Source {



1094         // &quot;META-INF/&quot;.length()
1095         private static final int META_INF_LENGTH = 9;
1096         private static final int[] EMPTY_META_VERSIONS = new int[0];
1097 
1098         private final Key key;               // the key in files
1099         private final @Stable ZipCoder zc;   // zip coder used to decode/encode
1100 
1101         private int refs = 1;
1102 
1103         private RandomAccessFile zfile;      // zfile of the underlying zip file
1104         private byte[] cen;                  // CEN &amp; ENDHDR
1105         private long locpos;                 // position of first LOC header (usually 0)
1106         private byte[] comment;              // zip file comment
1107                                              // list of meta entries in META-INF dir
<span class="line-modified">1108         private int[] metanames;</span>

1109         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1110         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1111 
1112         // A Hashmap for all entries.
1113         //
1114         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1115         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1116         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1117         // entry name and its offset {@code pos} in the central directory hdeader.
1118         //
1119         // private static class Entry {
1120         //     int hash;       // 32 bit hashcode on name
1121         //     int next;       // hash chain: index into entries
1122         //     int pos;        // Offset of central directory file header
1123         // }
1124         // private Entry[] entries;             // array of hashed cen entry
1125         //
1126         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1127         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1128         // referred by their index of their positions in the {@code entries}.
</pre>
<hr />
<pre>
1237             }
1238             try {
1239                 initCEN(-1);
1240                 byte[] buf = new byte[4];
1241                 readFullyAt(buf, 0, 4, 0);
1242                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1243             } catch (IOException x) {
1244                 try {
1245                     this.zfile.close();
1246                 } catch (IOException xx) {}
1247                 throw x;
1248             }
1249         }
1250 
1251         private void close() throws IOException {
1252             zfile.close();
1253             zfile = null;
1254             cen = null;
1255             entries = null;
1256             table = null;
<span class="line-modified">1257             metanames = null;</span>

1258             metaVersions = EMPTY_META_VERSIONS;
1259         }
1260 
1261         private static final int BUF_SIZE = 8192;
1262         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1263             throws IOException
1264         {
1265             synchronized (zfile) {
1266                 zfile.seek(pos);
1267                 int N = len;
1268                 while (N &gt; 0) {
1269                     int n = Math.min(BUF_SIZE, N);
1270                     zfile.readFully(buf, off, n);
1271                     off += n;
1272                     N -= n;
1273                 }
1274                 return len;
1275             }
1276         }
1277 
</pre>
<hr />
<pre>
1421                 total = end.centot;
1422             } else {
1423                 cen = this.cen;
1424                 total = knownTotal;
1425             }
1426             // hash table for entries
1427             entries  = new int[total * 3];
1428 
1429             this.tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1430             int tablelen = this.tablelen;
1431 
1432             this.table = new int[tablelen];
1433             int[] table = this.table;
1434 
1435             Arrays.fill(table, ZIP_ENDCHAIN);
1436             int idx = 0;
1437             int hash;
1438             int next;
1439 
1440             // list for all meta entries
<span class="line-modified">1441             ArrayList&lt;Integer&gt; metanamesList = null;</span>
1442             // Set of all version numbers seen in META-INF/versions/
1443             Set&lt;Integer&gt; metaVersionsSet = null;
1444 
1445             // Iterate through the entries in the central directory
1446             int i = 0;
1447             int hsh;
1448             int pos = 0;
1449             int entryPos = CENHDR;
1450             int limit = cen.length - ENDHDR;
1451             while (entryPos &lt;= limit) {
1452                 if (i &gt;= total) {
1453                     // This will only happen if the zip file has an incorrect
1454                     // ENDTOT field, which usually means it contains more than
1455                     // 65535 entries.
1456                     initCEN(countCENHeaders(cen, limit));
1457                     return;
1458                 }
1459                 if (CENSIG(cen, pos) != CENSIG)
1460                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1461                 int method = CENHOW(cen, pos);
1462                 int nlen   = CENNAM(cen, pos);
1463                 int elen   = CENEXT(cen, pos);
1464                 int clen   = CENCOM(cen, pos);
1465                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1466                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1467                 if (method != STORED &amp;&amp; method != DEFLATED)
1468                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1469                 if (entryPos + nlen &gt; limit)
1470                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1471                 // Record the CEN offset and the name hash in our hash cell.
1472                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);
1473                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1474                 next = table[hsh];
1475                 table[hsh] = idx;
1476                 idx = addEntry(idx, hash, next, pos);
1477                 // Adds name to metanames.
1478                 if (isMetaName(cen, entryPos, nlen)) {
<span class="line-modified">1479                     if (metanamesList == null)</span>
<span class="line-modified">1480                         metanamesList = new ArrayList&lt;&gt;(4);</span>
<span class="line-modified">1481                     metanamesList.add(pos);</span>
<span class="line-modified">1482 </span>
<span class="line-modified">1483                     // If this is a versioned entry, parse the version</span>
<span class="line-modified">1484                     // and store it for later. This optimizes lookup</span>
<span class="line-modified">1485                     // performance in multi-release jar files</span>
<span class="line-modified">1486                     int version = getMetaVersion(cen,</span>
<span class="line-modified">1487                         entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);</span>
<span class="line-modified">1488                     if (version &gt; 0) {</span>
<span class="line-modified">1489                         if (metaVersionsSet == null)</span>
<span class="line-modified">1490                             metaVersionsSet = new TreeSet&lt;&gt;();</span>
<span class="line-modified">1491                         metaVersionsSet.add(version);</span>








1492                     }
1493                 }
1494                 // skip ext and comment
1495                 pos = entryPos + nlen + elen + clen;
1496                 entryPos = pos + CENHDR;
1497                 i++;
1498             }
1499             total = i;
<span class="line-modified">1500             if (metanamesList != null) {</span>
<span class="line-modified">1501                 metanames = new int[metanamesList.size()];</span>
<span class="line-modified">1502                 for (int j = 0, len = metanames.length; j &lt; len; j++) {</span>
<span class="line-modified">1503                     metanames[j] = metanamesList.get(j);</span>

1504                 }
1505             }
1506             if (metaVersionsSet != null) {
1507                 metaVersions = new int[metaVersionsSet.size()];
1508                 int c = 0;
1509                 for (Integer version : metaVersionsSet) {
1510                     metaVersions[c++] = version;
1511                 }
1512             } else {
1513                 metaVersions = EMPTY_META_VERSIONS;
1514             }
1515             if (pos + ENDHDR != cen.length) {
1516                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1517             }
1518         }
1519 
1520         private static void zerror(String msg) throws ZipException {
1521             throw new ZipException(msg);
1522         }
1523 
</pre>
<hr />
<pre>
1563                 idx = getEntryNext(idx);
1564             }
1565             return -1;
1566         }
1567 
1568         private ZipCoder zipCoderForPos(int pos) {
1569             if (zc.isUTF8()) {
1570                 return zc;
1571             }
1572             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
1573                 return ZipCoder.UTF8;
1574             }
1575             return zc;
1576         }
1577 
1578         /**
1579          * Returns true if the bytes represent a non-directory name
1580          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1581          */
1582         private static boolean isMetaName(byte[] name, int off, int len) {
<span class="line-modified">1583             // Use the &quot;oldest ASCII trick in the book&quot;</span>

1584             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1585                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1586                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1587                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1588                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1589                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1590                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1591                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1592                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1593                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1594                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1595         }
1596 














































1597         /*
1598          * If the bytes represents a non-directory name beginning
1599          * with &quot;versions/&quot;, continuing with a positive integer,
1600          * followed by a &#39;/&#39;, then return that integer value.
1601          * Otherwise, return 0
1602          */
1603         private static int getMetaVersion(byte[] name, int off, int len) {
1604             int nend = off + len;
1605             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1606                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1607                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1608                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1609                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1610                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1611                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1612                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1613                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1614                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1615                     &amp;&amp; (name[off++]       ) == &#39;/&#39;)) {
1616                 return 0;
</pre>
</td>
<td>
<hr />
<pre>
  28 import java.io.Closeable;
  29 import java.io.InputStream;
  30 import java.io.IOException;
  31 import java.io.EOFException;
  32 import java.io.File;
  33 import java.io.RandomAccessFile;
  34 import java.io.UncheckedIOException;
  35 import java.lang.ref.Cleaner.Cleanable;
  36 import java.nio.charset.Charset;
  37 import java.nio.file.InvalidPathException;
  38 import java.nio.file.attribute.BasicFileAttributes;
  39 import java.nio.file.Files;
  40 import java.util.ArrayDeque;
  41 import java.util.ArrayList;
  42 import java.util.Arrays;
  43 import java.util.Collections;
  44 import java.util.Deque;
  45 import java.util.Enumeration;
  46 import java.util.HashMap;
  47 import java.util.Iterator;
<span class="line-added">  48 import java.util.List;</span>
<span class="line-added">  49 import java.util.Locale;</span>
  50 import java.util.Objects;
  51 import java.util.NoSuchElementException;
  52 import java.util.Set;
  53 import java.util.Spliterator;
  54 import java.util.Spliterators;
  55 import java.util.TreeSet;
  56 import java.util.WeakHashMap;
  57 import java.util.function.Consumer;

  58 import java.util.function.IntFunction;
  59 import java.util.jar.JarEntry;
  60 import java.util.jar.JarFile;
  61 import java.util.stream.Stream;
  62 import java.util.stream.StreamSupport;
  63 import jdk.internal.access.JavaUtilZipFileAccess;
<span class="line-added">  64 import jdk.internal.access.JavaUtilJarAccess;</span>
  65 import jdk.internal.access.SharedSecrets;
  66 import jdk.internal.misc.VM;
  67 import jdk.internal.perf.PerfCounter;
  68 import jdk.internal.ref.CleanerFactory;
  69 import jdk.internal.vm.annotation.Stable;
  70 import sun.nio.cs.UTF_8;
<span class="line-added">  71 import sun.security.util.SignatureFileVerifier;</span>
  72 
  73 import static java.util.zip.ZipConstants64.*;
  74 import static java.util.zip.ZipUtils.*;
  75 
  76 /**
  77  * This class is used to read entries from a zip file.
  78  *
  79  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
  80  * or method in this class will cause a {@link NullPointerException} to be
  81  * thrown.
  82  *
  83  * @apiNote
  84  * To release resources used by this {@code ZipFile}, the {@link #close()} method
  85  * should be called explicitly or by try-with-resources. Subclasses are responsible
  86  * for the cleanup of resources acquired by the subclass. Subclasses that override
  87  * {@link #finalize()} in order to perform cleanup should be modified to use alternative
  88  * cleanup mechanisms such as {@link java.lang.ref.Cleaner} and remove the overriding
  89  * {@code finalize} method.
  90  *
  91  * @author      David Connelly
</pre>
<hr />
<pre>
 304      */
 305     public String getComment() {
 306         synchronized (this) {
 307             ensureOpen();
 308             if (res.zsrc.comment == null) {
 309                 return null;
 310             }
 311             return res.zsrc.zc.toString(res.zsrc.comment);
 312         }
 313     }
 314 
 315     /**
 316      * Returns the zip file entry for the specified name, or null
 317      * if not found.
 318      *
 319      * @param name the name of the entry
 320      * @return the zip file entry, or null if not found
 321      * @throws IllegalStateException if the zip file has been closed
 322      */
 323     public ZipEntry getEntry(String name) {














 324         Objects.requireNonNull(name, &quot;name&quot;);
 325         ZipEntry entry = null;
 326         synchronized (this) {
 327             ensureOpen();
 328             int pos = res.zsrc.getEntryPos(name, true);
 329             if (pos != -1) {
<span class="line-modified"> 330                 entry = getZipEntry(name, pos);</span>
 331             }
 332         }
 333         return entry;
 334     }
 335 
 336     /**
 337      * Returns an input stream for reading the contents of the specified
 338      * zip file entry.
 339      * &lt;p&gt;
 340      * Closing this ZIP file will, in turn, close all input streams that
 341      * have been returned by invocations of this method.
 342      *
 343      * @param entry the zip file entry
 344      * @return the input stream for reading the contents of the specified
 345      * zip file entry.
 346      * @throws ZipException if a ZIP format error has occurred
 347      * @throws IOException if an I/O error has occurred
 348      * @throws IllegalStateException if the zip file has been closed
 349      */
 350     public InputStream getInputStream(ZipEntry entry) throws IOException {
</pre>
<hr />
<pre>
 456                 return 0;
 457             long avail = ((ZipFileInputStream)in).size() - inf.getBytesWritten();
 458             return (avail &gt; (long) Integer.MAX_VALUE ?
 459                     Integer.MAX_VALUE : (int) avail);
 460         }
 461     }
 462 
 463     /**
 464      * Returns the path name of the ZIP file.
 465      * @return the path name of the ZIP file
 466      */
 467     public String getName() {
 468         return name;
 469     }
 470 
 471     private class ZipEntryIterator&lt;T extends ZipEntry&gt;
 472             implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; {
 473 
 474         private int i = 0;
 475         private final int entryCount;

 476 
<span class="line-modified"> 477         public ZipEntryIterator(int entryCount) {</span>
 478             this.entryCount = entryCount;

 479         }
 480 
 481         @Override
 482         public boolean hasMoreElements() {
 483             return hasNext();
 484         }
 485 
 486         @Override
 487         public boolean hasNext() {
 488             return i &lt; entryCount;
 489         }
 490 
 491         @Override
 492         public T nextElement() {
 493             return next();
 494         }
 495 
 496         @Override
 497         @SuppressWarnings(&quot;unchecked&quot;)
 498         public T next() {
 499             synchronized (ZipFile.this) {
 500                 ensureOpen();
 501                 if (!hasNext()) {
 502                     throw new NoSuchElementException();
 503                 }
 504                 // each &quot;entry&quot; has 3 ints in table entries
<span class="line-modified"> 505                 return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));</span>
 506             }
 507         }
 508 
 509         @Override
 510         public Iterator&lt;T&gt; asIterator() {
 511             return this;
 512         }
 513     }
 514 
 515     /**
 516      * Returns an enumeration of the ZIP file entries.
 517      * @return an enumeration of the ZIP file entries
 518      * @throws IllegalStateException if the zip file has been closed
 519      */
 520     public Enumeration&lt;? extends ZipEntry&gt; entries() {
 521         synchronized (this) {
 522             ensureOpen();
<span class="line-modified"> 523             return new ZipEntryIterator&lt;ZipEntry&gt;(res.zsrc.total);</span>
 524         }
 525     }
 526 
<span class="line-modified"> 527     private Enumeration&lt;JarEntry&gt; jarEntries() {</span>
 528         synchronized (this) {
 529             ensureOpen();
<span class="line-modified"> 530             return new ZipEntryIterator&lt;JarEntry&gt;(res.zsrc.total);</span>
 531         }
 532     }
 533 
 534     private class EntrySpliterator&lt;T&gt; extends Spliterators.AbstractSpliterator&lt;T&gt; {
 535         private int index;
 536         private final int fence;
 537         private final IntFunction&lt;T&gt; gen;
 538 
 539         EntrySpliterator(int index, int fence, IntFunction&lt;T&gt; gen) {
 540             super((long)fence,
 541                   Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE |
 542                   Spliterator.NONNULL);
 543             this.index = index;
 544             this.fence = fence;
 545             this.gen = gen;
 546         }
 547 
 548         @Override
 549         public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
 550             if (action == null)
</pre>
<hr />
<pre>
 557                 return true;
 558             }
 559             return false;
 560         }
 561     }
 562 
 563     /**
 564      * Returns an ordered {@code Stream} over the ZIP file entries.
 565      *
 566      * Entries appear in the {@code Stream} in the order they appear in
 567      * the central directory of the ZIP file.
 568      *
 569      * @return an ordered {@code Stream} of entries in this ZIP file
 570      * @throws IllegalStateException if the zip file has been closed
 571      * @since 1.8
 572      */
 573     public Stream&lt;? extends ZipEntry&gt; stream() {
 574         synchronized (this) {
 575             ensureOpen();
 576             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 577                 pos -&gt; getZipEntry(null, pos)), false);</span>
 578        }
 579     }
 580 
 581     private String getEntryName(int pos) {
 582         byte[] cen = res.zsrc.cen;
 583         int nlen = CENNAM(cen, pos);
 584         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 585         return zc.toString(cen, pos + CENHDR, nlen);
 586     }
 587 
 588     /*
 589      * Returns an ordered {@code Stream} over the zip file entry names.
 590      *
 591      * Entry names appear in the {@code Stream} in the order they appear in
 592      * the central directory of the ZIP file.
 593      *
 594      * @return an ordered {@code Stream} of entry names in this zip file
 595      * @throws IllegalStateException if the zip file has been closed
 596      * @since 10
 597      */
 598     private Stream&lt;String&gt; entryNameStream() {
 599         synchronized (this) {
 600             ensureOpen();
 601             return StreamSupport.stream(
 602                 new EntrySpliterator&lt;&gt;(0, res.zsrc.total, this::getEntryName), false);
 603         }
 604     }
 605 
 606     /*
 607      * Returns an ordered {@code Stream} over the zip file entries.
 608      *
 609      * Entries appear in the {@code Stream} in the order they appear in
 610      * the central directory of the jar file.
 611      *

 612      * @return an ordered {@code Stream} of entries in this zip file
 613      * @throws IllegalStateException if the zip file has been closed
 614      * @since 10
 615      */
<span class="line-modified"> 616     private Stream&lt;JarEntry&gt; jarStream() {</span>
 617         synchronized (this) {
 618             ensureOpen();
 619             return StreamSupport.stream(new EntrySpliterator&lt;&gt;(0, res.zsrc.total,
<span class="line-modified"> 620                 pos -&gt; (JarEntry)getZipEntry(null, pos)), false);</span>
 621         }
 622     }
 623 
 624     private String lastEntryName;
 625     private int lastEntryPos;
 626 
 627     /* Check ensureOpen() before invoking this method */
<span class="line-modified"> 628     private ZipEntry getZipEntry(String name, int pos) {</span>

 629         byte[] cen = res.zsrc.cen;
 630         int nlen = CENNAM(cen, pos);
 631         int elen = CENEXT(cen, pos);
 632         int clen = CENCOM(cen, pos);
 633 
 634         ZipCoder zc = res.zsrc.zipCoderForPos(pos);
 635         if (name != null) {
 636             // only need to check for mismatch of trailing slash
 637             if (nlen &gt; 0 &amp;&amp;
 638                 !name.isEmpty() &amp;&amp;
 639                 zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &amp;&amp;
 640                 !name.endsWith(&quot;/&quot;))
 641             {
 642                 name += &#39;/&#39;;
 643             }
 644         } else {
 645             // invoked from iterator, use the entry name stored in cen
 646             name = zc.toString(cen, pos + CENHDR, nlen);
 647         }
<span class="line-modified"> 648         ZipEntry e;</span>
<span class="line-added"> 649         if (this instanceof JarFile) {</span>
<span class="line-added"> 650             e = Source.JUJA.entryFor((JarFile)this, name);</span>
<span class="line-added"> 651         } else {</span>
<span class="line-added"> 652             e = new ZipEntry(name);</span>
<span class="line-added"> 653         }</span>
 654         e.flag = CENFLG(cen, pos);
 655         e.xdostime = CENTIM(cen, pos);
 656         e.crc = CENCRC(cen, pos);
 657         e.size = CENLEN(cen, pos);
 658         e.csize = CENSIZ(cen, pos);
 659         e.method = CENHOW(cen, pos);
 660         if (elen != 0) {
 661             int start = pos + CENHDR + nlen;
 662             e.setExtra0(Arrays.copyOfRange(cen, start, start + elen), true, false);
 663         }
 664         if (clen != 0) {
 665             int start = pos + CENHDR + nlen + elen;
 666             e.comment = zc.toString(cen, start, clen);
 667         }
 668         lastEntryName = e.name;
 669         lastEntryPos = pos;
 670         return e;
 671     }
 672 
 673     /**
</pre>
<hr />
<pre>
 983         }
 984 
 985         public long size() {
 986             return size;
 987         }
 988 
 989         public void close() {
 990             if (closeRequested) {
 991                 return;
 992             }
 993             closeRequested = true;
 994             rem = 0;
 995             synchronized (res.istreams) {
 996                 res.istreams.remove(this);
 997             }
 998         }
 999 
1000     }
1001 
1002     /**
<span class="line-modified">1003      * Returns the names of the META-INF/MANIFEST.MF entry - if exists -</span>
<span class="line-modified">1004      * and any signature-related files under META-INF. This method is used in</span>
<span class="line-modified">1005      * JarFile, via SharedSecrets, as an optimization.</span>

1006      */
<span class="line-modified">1007     private List&lt;String&gt; getManifestAndSignatureRelatedFiles() {</span>
1008         synchronized (this) {
1009             ensureOpen();
1010             Source zsrc = res.zsrc;
<span class="line-modified">1011             int[] metanames = zsrc.signatureMetaNames;</span>
<span class="line-modified">1012             List&lt;String&gt; files = null;</span>
<span class="line-added">1013             if (zsrc.manifestPos &gt;= 0) {</span>
<span class="line-added">1014                 files = new ArrayList&lt;&gt;();</span>
<span class="line-added">1015                 files.add(getEntryName(zsrc.manifestPos));</span>
1016             }
<span class="line-modified">1017             if (metanames != null) {</span>
<span class="line-modified">1018                 if (files == null) {</span>
<span class="line-modified">1019                     files = new ArrayList&lt;&gt;();</span>
<span class="line-modified">1020                 }</span>
<span class="line-modified">1021                 for (int i = 0; i &lt; metanames.length; i++) {</span>
<span class="line-modified">1022                     files.add(getEntryName(metanames[i]));</span>
<span class="line-modified">1023                 }</span>

1024             }
<span class="line-modified">1025             return files == null ? List.of() : files;</span>
1026         }
1027     }
1028 
<span class="line-added">1029     /**</span>
<span class="line-added">1030      * Returns the name of the META-INF/MANIFEST.MF entry, ignoring</span>
<span class="line-added">1031      * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the</span>
<span class="line-added">1032      * manifest if there is also at least one signature-related file.</span>
<span class="line-added">1033      * This method is used in JarFile, via SharedSecrets, as an optimization</span>
<span class="line-added">1034      * when looking up the manifest file.</span>
<span class="line-added">1035      */</span>
<span class="line-added">1036     private String getManifestName(boolean onlyIfSignatureRelatedFiles) {</span>
<span class="line-added">1037         synchronized (this) {</span>
<span class="line-added">1038             ensureOpen();</span>
<span class="line-added">1039             Source zsrc = res.zsrc;</span>
<span class="line-added">1040             int pos = zsrc.manifestPos;</span>
<span class="line-added">1041             if (pos &gt;= 0 &amp;&amp; (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {</span>
<span class="line-added">1042                 return getEntryName(pos);</span>
<span class="line-added">1043             }</span>
<span class="line-added">1044         }</span>
<span class="line-added">1045         return null;</span>
<span class="line-added">1046     }</span>
<span class="line-added">1047 </span>
1048     /**
1049      * Returns the versions for which there exists a non-directory
1050      * entry that begin with &quot;META-INF/versions/&quot; (case ignored).
1051      * This method is used in JarFile, via SharedSecrets, as an
1052      * optimization when looking up potentially versioned entries.
1053      * Returns an empty array if no versioned entries exist.
1054      */
1055     private int[] getMetaInfVersions() {
1056         synchronized (this) {
1057             ensureOpen();
1058             return res.zsrc.metaVersions;
1059         }
1060     }
1061 
1062     private static boolean isWindows;
1063 
1064     static {
1065         SharedSecrets.setJavaUtilZipFileAccess(
1066             new JavaUtilZipFileAccess() {
1067                 @Override
1068                 public boolean startsWithLocHeader(ZipFile zip) {
1069                     return zip.res.zsrc.startsWithLoc;
1070                 }
1071                 @Override
<span class="line-modified">1072                 public List&lt;String&gt; getManifestAndSignatureRelatedFiles(JarFile jar) {</span>
<span class="line-modified">1073                     return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();</span>
1074                 }
1075                 @Override
<span class="line-modified">1076                 public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {</span>
<span class="line-modified">1077                     return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);</span>
1078                 }
1079                 @Override
<span class="line-modified">1080                 public int[] getMetaInfVersions(JarFile jar) {</span>
<span class="line-modified">1081                     return ((ZipFile)jar).getMetaInfVersions();</span>

1082                 }
1083                 @Override
<span class="line-modified">1084                 public Enumeration&lt;JarEntry&gt; entries(ZipFile zip) {</span>
<span class="line-modified">1085                     return zip.jarEntries();</span>

1086                 }
1087                 @Override
<span class="line-modified">1088                 public Stream&lt;JarEntry&gt; stream(ZipFile zip) {</span>
<span class="line-modified">1089                     return zip.jarStream();</span>

1090                 }
1091                 @Override
1092                 public Stream&lt;String&gt; entryNameStream(ZipFile zip) {
1093                     return zip.entryNameStream();
1094                 }
1095              }
1096         );
1097         isWindows = VM.getSavedProperty(&quot;os.name&quot;).contains(&quot;Windows&quot;);
1098     }
1099 
1100     private static class Source {
<span class="line-added">1101         // While this is only used from ZipFile, defining it there would cause</span>
<span class="line-added">1102         // a bootstrap cycle that would leave this initialized as null</span>
<span class="line-added">1103         private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();</span>
1104         // &quot;META-INF/&quot;.length()
1105         private static final int META_INF_LENGTH = 9;
1106         private static final int[] EMPTY_META_VERSIONS = new int[0];
1107 
1108         private final Key key;               // the key in files
1109         private final @Stable ZipCoder zc;   // zip coder used to decode/encode
1110 
1111         private int refs = 1;
1112 
1113         private RandomAccessFile zfile;      // zfile of the underlying zip file
1114         private byte[] cen;                  // CEN &amp; ENDHDR
1115         private long locpos;                 // position of first LOC header (usually 0)
1116         private byte[] comment;              // zip file comment
1117                                              // list of meta entries in META-INF dir
<span class="line-modified">1118         private int   manifestPos = -1;      // position of the META-INF/MANIFEST.MF, if exists</span>
<span class="line-added">1119         private int[] signatureMetaNames;    // positions of signature related entries, if such exist</span>
1120         private int[] metaVersions;          // list of unique versions found in META-INF/versions/
1121         private final boolean startsWithLoc; // true, if zip file starts with LOCSIG (usually true)
1122 
1123         // A Hashmap for all entries.
1124         //
1125         // A cen entry of Zip/JAR file. As we have one for every entry in every active Zip/JAR,
1126         // We might have a lot of these in a typical system. In order to save space we don&#39;t
1127         // keep the name in memory, but merely remember a 32 bit {@code hash} value of the
1128         // entry name and its offset {@code pos} in the central directory hdeader.
1129         //
1130         // private static class Entry {
1131         //     int hash;       // 32 bit hashcode on name
1132         //     int next;       // hash chain: index into entries
1133         //     int pos;        // Offset of central directory file header
1134         // }
1135         // private Entry[] entries;             // array of hashed cen entry
1136         //
1137         // To reduce the total size of entries further, we use a int[] here to store 3 &quot;int&quot;
1138         // {@code hash}, {@code next and {@code &quot;pos for each entry. The entry can then be
1139         // referred by their index of their positions in the {@code entries}.
</pre>
<hr />
<pre>
1248             }
1249             try {
1250                 initCEN(-1);
1251                 byte[] buf = new byte[4];
1252                 readFullyAt(buf, 0, 4, 0);
1253                 this.startsWithLoc = (LOCSIG(buf) == LOCSIG);
1254             } catch (IOException x) {
1255                 try {
1256                     this.zfile.close();
1257                 } catch (IOException xx) {}
1258                 throw x;
1259             }
1260         }
1261 
1262         private void close() throws IOException {
1263             zfile.close();
1264             zfile = null;
1265             cen = null;
1266             entries = null;
1267             table = null;
<span class="line-modified">1268             manifestPos = -1;</span>
<span class="line-added">1269             signatureMetaNames = null;</span>
1270             metaVersions = EMPTY_META_VERSIONS;
1271         }
1272 
1273         private static final int BUF_SIZE = 8192;
1274         private final int readFullyAt(byte[] buf, int off, int len, long pos)
1275             throws IOException
1276         {
1277             synchronized (zfile) {
1278                 zfile.seek(pos);
1279                 int N = len;
1280                 while (N &gt; 0) {
1281                     int n = Math.min(BUF_SIZE, N);
1282                     zfile.readFully(buf, off, n);
1283                     off += n;
1284                     N -= n;
1285                 }
1286                 return len;
1287             }
1288         }
1289 
</pre>
<hr />
<pre>
1433                 total = end.centot;
1434             } else {
1435                 cen = this.cen;
1436                 total = knownTotal;
1437             }
1438             // hash table for entries
1439             entries  = new int[total * 3];
1440 
1441             this.tablelen = ((total/2) | 1); // Odd -&gt; fewer collisions
1442             int tablelen = this.tablelen;
1443 
1444             this.table = new int[tablelen];
1445             int[] table = this.table;
1446 
1447             Arrays.fill(table, ZIP_ENDCHAIN);
1448             int idx = 0;
1449             int hash;
1450             int next;
1451 
1452             // list for all meta entries
<span class="line-modified">1453             ArrayList&lt;Integer&gt; signatureNames = null;</span>
1454             // Set of all version numbers seen in META-INF/versions/
1455             Set&lt;Integer&gt; metaVersionsSet = null;
1456 
1457             // Iterate through the entries in the central directory
1458             int i = 0;
1459             int hsh;
1460             int pos = 0;
1461             int entryPos = CENHDR;
1462             int limit = cen.length - ENDHDR;
1463             while (entryPos &lt;= limit) {
1464                 if (i &gt;= total) {
1465                     // This will only happen if the zip file has an incorrect
1466                     // ENDTOT field, which usually means it contains more than
1467                     // 65535 entries.
1468                     initCEN(countCENHeaders(cen, limit));
1469                     return;
1470                 }
1471                 if (CENSIG(cen, pos) != CENSIG)
1472                     zerror(&quot;invalid CEN header (bad signature)&quot;);
1473                 int method = CENHOW(cen, pos);
1474                 int nlen   = CENNAM(cen, pos);
1475                 int elen   = CENEXT(cen, pos);
1476                 int clen   = CENCOM(cen, pos);
1477                 if ((CENFLG(cen, pos) &amp; 1) != 0)
1478                     zerror(&quot;invalid CEN header (encrypted entry)&quot;);
1479                 if (method != STORED &amp;&amp; method != DEFLATED)
1480                     zerror(&quot;invalid CEN header (bad compression method: &quot; + method + &quot;)&quot;);
1481                 if (entryPos + nlen &gt; limit)
1482                     zerror(&quot;invalid CEN header (bad header size)&quot;);
1483                 // Record the CEN offset and the name hash in our hash cell.
1484                 hash = zipCoderForPos(pos).normalizedHash(cen, entryPos, nlen);
1485                 hsh = (hash &amp; 0x7fffffff) % tablelen;
1486                 next = table[hsh];
1487                 table[hsh] = idx;
1488                 idx = addEntry(idx, hash, next, pos);
1489                 // Adds name to metanames.
1490                 if (isMetaName(cen, entryPos, nlen)) {
<span class="line-modified">1491                     // nlen is at least META_INF_LENGTH</span>
<span class="line-modified">1492                     if (isManifestName(cen, entryPos + META_INF_LENGTH,</span>
<span class="line-modified">1493                             nlen - META_INF_LENGTH)) {</span>
<span class="line-modified">1494                         manifestPos = pos;</span>
<span class="line-modified">1495                     } else {</span>
<span class="line-modified">1496                         if (isSignatureRelated(cen, entryPos, nlen)) {</span>
<span class="line-modified">1497                             if (signatureNames == null)</span>
<span class="line-modified">1498                                 signatureNames = new ArrayList&lt;&gt;(4);</span>
<span class="line-modified">1499                             signatureNames.add(pos);</span>
<span class="line-modified">1500                         }</span>
<span class="line-modified">1501 </span>
<span class="line-modified">1502                         // If this is a versioned entry, parse the version</span>
<span class="line-modified">1503                         // and store it for later. This optimizes lookup</span>
<span class="line-added">1504                         // performance in multi-release jar files</span>
<span class="line-added">1505                         int version = getMetaVersion(cen,</span>
<span class="line-added">1506                             entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);</span>
<span class="line-added">1507                         if (version &gt; 0) {</span>
<span class="line-added">1508                             if (metaVersionsSet == null)</span>
<span class="line-added">1509                                 metaVersionsSet = new TreeSet&lt;&gt;();</span>
<span class="line-added">1510                             metaVersionsSet.add(version);</span>
<span class="line-added">1511                         }</span>
1512                     }
1513                 }
1514                 // skip ext and comment
1515                 pos = entryPos + nlen + elen + clen;
1516                 entryPos = pos + CENHDR;
1517                 i++;
1518             }
1519             total = i;
<span class="line-modified">1520             if (signatureNames != null) {</span>
<span class="line-modified">1521                 int len = signatureNames.size();</span>
<span class="line-modified">1522                 signatureMetaNames = new int[len];</span>
<span class="line-modified">1523                 for (int j = 0; j &lt; len; j++) {</span>
<span class="line-added">1524                     signatureMetaNames[j] = signatureNames.get(j);</span>
1525                 }
1526             }
1527             if (metaVersionsSet != null) {
1528                 metaVersions = new int[metaVersionsSet.size()];
1529                 int c = 0;
1530                 for (Integer version : metaVersionsSet) {
1531                     metaVersions[c++] = version;
1532                 }
1533             } else {
1534                 metaVersions = EMPTY_META_VERSIONS;
1535             }
1536             if (pos + ENDHDR != cen.length) {
1537                 zerror(&quot;invalid CEN header (bad header size)&quot;);
1538             }
1539         }
1540 
1541         private static void zerror(String msg) throws ZipException {
1542             throw new ZipException(msg);
1543         }
1544 
</pre>
<hr />
<pre>
1584                 idx = getEntryNext(idx);
1585             }
1586             return -1;
1587         }
1588 
1589         private ZipCoder zipCoderForPos(int pos) {
1590             if (zc.isUTF8()) {
1591                 return zc;
1592             }
1593             if ((CENFLG(cen, pos) &amp; USE_UTF8) != 0) {
1594                 return ZipCoder.UTF8;
1595             }
1596             return zc;
1597         }
1598 
1599         /**
1600          * Returns true if the bytes represent a non-directory name
1601          * beginning with &quot;META-INF/&quot;, disregarding ASCII case.
1602          */
1603         private static boolean isMetaName(byte[] name, int off, int len) {
<span class="line-modified">1604             // Use the &quot;oldest ASCII trick in the book&quot;:</span>
<span class="line-added">1605             // ch | 0x20 == Character.toLowerCase(ch)</span>
1606             return len &gt; META_INF_LENGTH       // &quot;META-INF/&quot;.length()
1607                 &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1608                 &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;
1609                 &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1610                 &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;
1611                 &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;
1612                 &amp;&amp; (name[off++]       ) == &#39;-&#39;
1613                 &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1614                 &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1615                 &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;
1616                 &amp;&amp; (name[off]         ) == &#39;/&#39;;
1617         }
1618 
<span class="line-added">1619         /*</span>
<span class="line-added">1620          * Check if the bytes represents a name equals to MANIFEST.MF</span>
<span class="line-added">1621          */</span>
<span class="line-added">1622         private static boolean isManifestName(byte[] name, int off, int len) {</span>
<span class="line-added">1623             return (len == 11 // &quot;MANIFEST.MF&quot;.length()</span>
<span class="line-added">1624                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;</span>
<span class="line-added">1625                     &amp;&amp; (name[off++] | 0x20) == &#39;a&#39;</span>
<span class="line-added">1626                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;</span>
<span class="line-added">1627                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;</span>
<span class="line-added">1628                     &amp;&amp; (name[off++] | 0x20) == &#39;f&#39;</span>
<span class="line-added">1629                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;</span>
<span class="line-added">1630                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;</span>
<span class="line-added">1631                     &amp;&amp; (name[off++] | 0x20) == &#39;t&#39;</span>
<span class="line-added">1632                     &amp;&amp; (name[off++]       ) == &#39;.&#39;</span>
<span class="line-added">1633                     &amp;&amp; (name[off++] | 0x20) == &#39;m&#39;</span>
<span class="line-added">1634                     &amp;&amp; (name[off]   | 0x20) == &#39;f&#39;);</span>
<span class="line-added">1635         }</span>
<span class="line-added">1636 </span>
<span class="line-added">1637         private static boolean isSignatureRelated(byte[] name, int off, int len) {</span>
<span class="line-added">1638             // Only called when isMetaName(name, off, len) is true, which means</span>
<span class="line-added">1639             // len is at least META_INF_LENGTH</span>
<span class="line-added">1640             // assert isMetaName(name, off, len)</span>
<span class="line-added">1641             boolean signatureRelated = false;</span>
<span class="line-added">1642             if (name[off + len - 3] == &#39;.&#39;) {</span>
<span class="line-added">1643                 // Check if entry ends with .EC and .SF</span>
<span class="line-added">1644                 int b1 = name[off + len - 2] | 0x20;</span>
<span class="line-added">1645                 int b2 = name[off + len - 1] | 0x20;</span>
<span class="line-added">1646                 if ((b1 == &#39;e&#39; &amp;&amp; b2 == &#39;c&#39;) || (b1 == &#39;s&#39; &amp;&amp; b2 == &#39;f&#39;)) {</span>
<span class="line-added">1647                     signatureRelated = true;</span>
<span class="line-added">1648                 }</span>
<span class="line-added">1649             } else if (name[off + len - 4] == &#39;.&#39;) {</span>
<span class="line-added">1650                 // Check if entry ends with .DSA and .RSA</span>
<span class="line-added">1651                 int b1 = name[off + len - 3] | 0x20;</span>
<span class="line-added">1652                 int b2 = name[off + len - 2] | 0x20;</span>
<span class="line-added">1653                 int b3 = name[off + len - 1] | 0x20;</span>
<span class="line-added">1654                 if ((b1 == &#39;r&#39; || b1 == &#39;d&#39;) &amp;&amp; b2 == &#39;s&#39; &amp;&amp; b3 == &#39;a&#39;) {</span>
<span class="line-added">1655                     signatureRelated = true;</span>
<span class="line-added">1656                 }</span>
<span class="line-added">1657             }</span>
<span class="line-added">1658             // Above logic must match SignatureFileVerifier.isBlockOrSF</span>
<span class="line-added">1659             assert(signatureRelated == SignatureFileVerifier</span>
<span class="line-added">1660                 .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)</span>
<span class="line-added">1661                     .toUpperCase(Locale.ENGLISH)));</span>
<span class="line-added">1662             return signatureRelated;</span>
<span class="line-added">1663         }</span>
<span class="line-added">1664 </span>
1665         /*
1666          * If the bytes represents a non-directory name beginning
1667          * with &quot;versions/&quot;, continuing with a positive integer,
1668          * followed by a &#39;/&#39;, then return that integer value.
1669          * Otherwise, return 0
1670          */
1671         private static int getMetaVersion(byte[] name, int off, int len) {
1672             int nend = off + len;
1673             if (!(len &gt; 10                         // &quot;versions//&quot;.length()
1674                     &amp;&amp; name[off + len - 1] != &#39;/&#39;  // non-directory
1675                     &amp;&amp; (name[off++] | 0x20) == &#39;v&#39;
1676                     &amp;&amp; (name[off++] | 0x20) == &#39;e&#39;
1677                     &amp;&amp; (name[off++] | 0x20) == &#39;r&#39;
1678                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1679                     &amp;&amp; (name[off++] | 0x20) == &#39;i&#39;
1680                     &amp;&amp; (name[off++] | 0x20) == &#39;o&#39;
1681                     &amp;&amp; (name[off++] | 0x20) == &#39;n&#39;
1682                     &amp;&amp; (name[off++] | 0x20) == &#39;s&#39;
1683                     &amp;&amp; (name[off++]       ) == &#39;/&#39;)) {
1684                 return 0;
</pre>
</td>
</tr>
</table>
<center><a href="../regex/Grapheme.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/access/JavaUtilJarAccess.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/jar/JarFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 112      */
 113     private static final char TAG_ARG = &#39;\u0001&#39;;
 114 
 115     /**
 116      * Tag used to demarcate a constant.
 117      */
 118     private static final char TAG_CONST = &#39;\u0002&#39;;
 119 
 120     /**
 121      * Maximum number of argument slots in String Concat call.
 122      *
 123      * While the maximum number of argument slots that indy call can handle is 253,
 124      * we do not use all those slots, to let the strategies with MethodHandle
 125      * combinators to use some arguments.
 126      */
 127     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 128 
 129     /**
 130      * Concatenation strategy to use. See {@link Strategy} for possible options.
 131      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.


 132      */
<span class="line-modified"> 133     private static Strategy STRATEGY;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135     /**</span>
<span class="line-removed"> 136      * Default strategy to use for concatenation.</span>
<span class="line-removed"> 137      */</span>
<span class="line-removed"> 138     private static final Strategy DEFAULT_STRATEGY = Strategy.MH_INLINE_SIZED_EXACT;</span>
 139 
 140     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 141 
 142     private enum Strategy {
 143         /**
 144          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 145          */
 146         BC_SB,
 147 
 148         /**
 149          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 150          * but trying to estimate the required storage.
 151          */
 152         BC_SB_SIZED,
 153 
 154         /**
 155          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 156          * but computing the required storage exactly.
 157          */
 158         BC_SB_SIZED_EXACT,
</pre>
<hr />
<pre>
 165 
 166         /**
 167          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 168          * This strategy also estimate the required storage exactly.
 169          */
 170         MH_SB_SIZED_EXACT,
 171 
 172         /**
 173          * MethodHandle-based generator, that constructs its own byte[] array from
 174          * the arguments. It computes the required storage exactly.
 175          */
 176         MH_INLINE_SIZED_EXACT
 177     }
 178 
 179     /**
 180      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 181      * checks, etc.
 182      */
 183     private static final boolean DEBUG;
 184 
<span class="line-removed"> 185     /**</span>
<span class="line-removed"> 186      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed"> 187      * code, at the expense of contaminating the profiles.</span>
<span class="line-removed"> 188      */</span>
<span class="line-removed"> 189     private static final boolean CACHE_ENABLE;</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed"> 192 </span>
<span class="line-removed"> 193     /**</span>
<span class="line-removed"> 194      * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed"> 195      */</span>
<span class="line-removed"> 196     private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed"> 197 </span>
 198     static {
<span class="line-removed"> 199         // In case we need to double-back onto the StringConcatFactory during this</span>
<span class="line-removed"> 200         // static initialization, make sure we have the reasonable defaults to complete</span>
<span class="line-removed"> 201         // the static initialization properly. After that, actual users would use</span>
<span class="line-removed"> 202         // the proper values we have read from the properties.</span>
<span class="line-removed"> 203         STRATEGY = DEFAULT_STRATEGY;</span>
<span class="line-removed"> 204         // CACHE_ENABLE = false; // implied</span>
<span class="line-removed"> 205         // CACHE = null;         // implied</span>
<span class="line-removed"> 206         // DEBUG = false;        // implied</span>
<span class="line-removed"> 207         // DUMPER = null;        // implied</span>
<span class="line-removed"> 208 </span>
 209         final String strategy =
 210                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified"> 211         CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-modified"> 212                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
 213         DEBUG = Boolean.parseBoolean(
 214                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
<span class="line-removed"> 215         final String dumpPath =</span>
<span class="line-removed"> 216                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);</span>
<span class="line-removed"> 219         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed"> 220         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
 221     }
 222 
 223     /**
 224      * Cache key is a composite of:
 225      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 226      *   - method type, describing the dynamic arguments for concatenation
 227      *   - concat recipe, describing the constants and concat shape
 228      */
 229     private static final class Key {
 230         final String className;
 231         final MethodType mt;
 232         final Recipe recipe;
 233 
 234         public Key(String className, MethodType mt, Recipe recipe) {
 235             this.className = className;
 236             this.mt = mt;
 237             this.recipe = recipe;
 238         }
 239 
 240         @Override
</pre>
<hr />
<pre>
 243             if (o == null || getClass() != o.getClass()) return false;
 244 
 245             Key key = (Key) o;
 246 
 247             if (!className.equals(key.className)) return false;
 248             if (!mt.equals(key.mt)) return false;
 249             if (!recipe.equals(key.recipe)) return false;
 250             return true;
 251         }
 252 
 253         @Override
 254         public int hashCode() {
 255             int result = className.hashCode();
 256             result = 31 * result + mt.hashCode();
 257             result = 31 * result + recipe.hashCode();
 258             return result;
 259         }
 260     }
 261 
 262     /**
<span class="line-modified"> 263      * Parses the recipe string, and produces the traversable collection of</span>
 264      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 265      * strategies. Notably, this class parses out the constants from the recipe
 266      * and from other static arguments.
 267      */
 268     private static final class Recipe {
 269         private final List&lt;RecipeElement&gt; elements;
 270 
 271         public Recipe(String src, Object[] constants) {
 272             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 273 
 274             int constC = 0;
 275             int argC = 0;
 276 
 277             StringBuilder acc = new StringBuilder();
 278 
 279             for (int i = 0; i &lt; src.length(); i++) {
 280                 char c = src.charAt(i);
 281 
 282                 if (c == TAG_CONST || c == TAG_ARG) {
 283                     // Detected a special tag, flush all accumulated characters
</pre>
<hr />
<pre>
 651                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 652                             cCount +
 653                             &quot; constants, but only &quot; +
 654                             constants.length +
 655                             &quot; are passed&quot;);
 656         }
 657 
 658         if (!concatType.returnType().isAssignableFrom(String.class)) {
 659             throw new StringConcatException(
 660                     &quot;The return type should be compatible with String, but it is &quot; +
 661                             concatType.returnType());
 662         }
 663 
 664         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 665             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 666                     concatType.parameterSlotCount() +
 667                     &quot;, can only accept &quot; +
 668                     MAX_INDY_CONCAT_ARG_SLOTS);
 669         }
 670 
<span class="line-removed"> 671         String className = getClassName(lookup.lookupClass());</span>
 672         MethodType mt = adaptType(concatType);
 673         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 674 </span>
<span class="line-removed"> 675         MethodHandle mh;</span>
<span class="line-removed"> 676         if (CACHE_ENABLE) {</span>
<span class="line-removed"> 677             Key key = new Key(className, mt, rec);</span>
<span class="line-removed"> 678             mh = CACHE.get(key);</span>
<span class="line-removed"> 679             if (mh == null) {</span>
<span class="line-removed"> 680                 mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 681                 CACHE.put(key, mh);</span>
<span class="line-removed"> 682             }</span>
<span class="line-removed"> 683         } else {</span>
<span class="line-removed"> 684             mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 685         }</span>
 686         return new ConstantCallSite(mh.asType(concatType));
 687     }
 688 
 689     /**
 690      * Adapt method type to an API we are going to use.
 691      *
 692      * This strips the concrete classes from the signatures, thus preventing
 693      * class leakage when we cache the concatenation stubs.
 694      *
 695      * @param args actual argument types
 696      * @return argument types the strategy is going to use
 697      */
 698     private static MethodType adaptType(MethodType args) {
 699         Class&lt;?&gt;[] ptypes = null;
 700         for (int i = 0; i &lt; args.parameterCount(); i++) {
 701             Class&lt;?&gt; ptype = args.parameterType(i);
 702             if (!ptype.isPrimitive() &amp;&amp;
 703                     ptype != String.class &amp;&amp;
 704                     ptype != Object.class) { // truncate to Object
 705                 if (ptypes == null) {
 706                     ptypes = args.parameterArray();
 707                 }
 708                 ptypes[i] = Object.class;
 709             }
 710             // else other primitives or String or Object (unchanged)
 711         }
 712         return (ptypes != null)
 713                 ? MethodType.methodType(args.returnType(), ptypes)
 714                 : args;
 715     }
 716 
<span class="line-modified"> 717     private static String getClassName(Class&lt;?&gt; hostClass) throws StringConcatException {</span>
<span class="line-removed"> 718         /*</span>
<span class="line-removed"> 719           The generated class is in the same package as the host class as</span>
<span class="line-removed"> 720           it&#39;s the implementation of the string concatenation for the host class.</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722           When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed"> 723          */</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725         switch (STRATEGY) {</span>
<span class="line-removed"> 726             case BC_SB:</span>
<span class="line-removed"> 727             case BC_SB_SIZED:</span>
<span class="line-removed"> 728             case BC_SB_SIZED_EXACT: {</span>
<span class="line-removed"> 729                 if (CACHE_ENABLE) {</span>
<span class="line-removed"> 730                     String pkgName = hostClass.getPackageName();</span>
<span class="line-removed"> 731                     return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed"> 732                 } else {</span>
<span class="line-removed"> 733                     String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed"> 734                                                        : hostClass.getName();</span>
<span class="line-removed"> 735                     return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed"> 736                 }</span>
<span class="line-removed"> 737             }</span>
<span class="line-removed"> 738             case MH_SB_SIZED:</span>
<span class="line-removed"> 739             case MH_SB_SIZED_EXACT:</span>
<span class="line-removed"> 740             case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed"> 741                 // MethodHandle strategies do not need a class name.</span>
<span class="line-removed"> 742                 return &quot;&quot;;</span>
<span class="line-removed"> 743             default:</span>
<span class="line-removed"> 744                 throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed"> 745         }</span>
<span class="line-removed"> 746     }</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748     private static MethodHandle generate(Lookup lookup, String className, MethodType mt, Recipe recipe) throws StringConcatException {</span>
 749         try {



 750             switch (STRATEGY) {
 751                 case BC_SB:
<span class="line-modified"> 752                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.DEFAULT);</span>
 753                 case BC_SB_SIZED:
<span class="line-modified"> 754                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED);</span>
 755                 case BC_SB_SIZED_EXACT:
<span class="line-modified"> 756                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED_EXACT);</span>
 757                 case MH_SB_SIZED:
 758                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 759                 case MH_SB_SIZED_EXACT:
 760                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 761                 case MH_INLINE_SIZED_EXACT:
 762                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 763                 default:
 764                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 765             }
 766         } catch (Error | StringConcatException e) {
 767             // Pass through any error or existing StringConcatException
 768             throw e;
 769         } catch (Throwable t) {
 770             throw new StringConcatException(&quot;Generator failed&quot;, t);
 771         }
 772     }
 773 
 774     private enum Mode {
 775         DEFAULT(false, false),
 776         SIZED(true, false),
</pre>
<hr />
<pre>
 819      * it only guesses the space required for known types (e.g. primitives and
 820      * Strings), but does not otherwise convert arguments. Therefore, the
 821      * capacity estimate may be wrong, and StringBuilder may have to
 822      * transparently resize or trim when doing the actual concatenation. While
 823      * this does not constitute a correctness issue (in the end, that what BC_SB
 824      * has to do anyway), this does pose a potential performance problem.
 825      *
 826      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 827      * sized exactly&quot;.&lt;/b&gt;
 828      *
 829      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 830      * converting all arguments to String in order to get the exact capacity
 831      * StringBuilder should have. The conversion is done via the public
 832      * String.valueOf and/or Object.toString methods, and does not touch any
 833      * private String API.
 834      */
 835     private static final class BytecodeStringBuilderStrategy {
 836         static final int CLASSFILE_VERSION = 52;
 837         static final String METHOD_NAME = &quot;concat&quot;;
 838 
























 839         private BytecodeStringBuilderStrategy() {
 840             // no instantiation
 841         }
 842 
<span class="line-modified"> 843         private static MethodHandle generate(Lookup lookup, String className, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>










 844             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 845 
 846             cw.visit(CLASSFILE_VERSION,
 847                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 848                     className,
 849                     null,
 850                     &quot;java/lang/Object&quot;,
 851                     null
 852             );
 853 
 854             MethodVisitor mv = cw.visitMethod(
 855                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 856                     METHOD_NAME,
 857                     args.toMethodDescriptorString(),
 858                     null,
 859                     null);
 860 
 861             // use of @ForceInline no longer has any effect
 862             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 863             mv.visitCode();
</pre>
<hr />
<pre>
1113             }
1114 
1115             mv.visitMethodInsn(
1116                     INVOKEVIRTUAL,
1117                     &quot;java/lang/StringBuilder&quot;,
1118                     &quot;toString&quot;,
1119                     &quot;()Ljava/lang/String;&quot;,
1120                     false
1121             );
1122 
1123             mv.visitInsn(ARETURN);
1124 
1125             mv.visitMaxs(-1, -1);
1126             mv.visitEnd();
1127             cw.visitEnd();
1128 
1129             byte[] classBytes = cw.toByteArray();
1130             try {
1131                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1132                 dumpIfEnabled(className, classBytes);
<span class="line-modified">1133                 return lookup.findStatic(innerClass, METHOD_NAME, args);</span>




1134             } catch (Exception e) {
1135                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1136                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1137             }
1138         }
1139 


















1140         private static void dumpIfEnabled(String name, byte[] bytes) {
1141             if (DUMPER != null) {
1142                 DUMPER.dumpClass(name, bytes);
1143             }
1144         }
1145 
1146         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1147             if (cl.isPrimitive()) {
1148                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1149                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1150                 } else if (cl == Boolean.TYPE) {
1151                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1152                 } else if (cl == Character.TYPE) {
1153                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1154                 } else if (cl == Double.TYPE) {
1155                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1156                 } else if (cl == Float.TYPE) {
1157                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1158                 } else if (cl == Long.TYPE) {
1159                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
</pre>
<hr />
<pre>
1690                         1 + ac // selected argument
1691                 );
1692             } else {
1693                 // No mixer (constants only concat), insert initialLengthCoder directly
1694                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1695             }
1696 
1697             // The method handle shape here is (&lt;args&gt;).
1698 
1699             // Apply filters, converting the arguments:
1700             if (filters != null) {
1701                 mh = MethodHandles.filterArguments(mh, 0, filters);
1702             }
1703 
1704             return mh;
1705         }
1706 
1707         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1708             return MethodHandles.insertArguments(
1709                     MethodHandles.insertArguments(
<span class="line-modified">1710                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>
1711         }
1712 
1713         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1714             return MIXERS.computeIfAbsent(cl, MIX);
1715         }
1716 
1717         // This one is deliberately non-lambdified to optimize startup time:
1718         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1719             @Override
1720             public MethodHandle apply(Class&lt;?&gt; c) {
1721                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1722                             methodType(long.class, long.class, byte[].class,
1723                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1724             }
1725         };
1726 
1727         // This one is deliberately non-lambdified to optimize startup time:
1728         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1729             @Override
1730             public MethodHandle apply(Class&lt;?&gt; c) {
</pre>
<hr />
<pre>
1735         private static final MethodHandle SIMPLE;
1736         private static final MethodHandle NEW_STRING;
1737         private static final MethodHandle NEW_ARRAY;
1738         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1739         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1740         private static final long INITIAL_CODER;
1741 
1742         static {
1743             try {
1744                 MethodHandle initCoder = JLA.stringConcatHelper(&quot;initialCoder&quot;, methodType(long.class));
1745                 INITIAL_CODER = (long) initCoder.invoke();
1746             } catch (Throwable e) {
1747                 throw new AssertionError(e);
1748             }
1749 
1750             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1751             MIXERS = new ConcurrentHashMap&lt;&gt;();
1752 
1753             SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
1754             NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-modified">1755             NEW_ARRAY  = JLA.stringConcatHelper( &quot;newArray&quot;, methodType(byte[].class, long.class));</span>
1756         }
1757     }
1758 
1759     /**
1760      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1761      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1762      */
1763     private static final class Stringifiers {
1764         private Stringifiers() {
1765             // no instantiation
1766         }
1767 
1768         private static final MethodHandle OBJECT_INSTANCE =
1769                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1770 
1771         private static class FloatStringifiers {
1772             private static final MethodHandle FLOAT_INSTANCE =
1773                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1774 
1775             private static final MethodHandle DOUBLE_INSTANCE =
</pre>
</td>
<td>
<hr />
<pre>
 112      */
 113     private static final char TAG_ARG = &#39;\u0001&#39;;
 114 
 115     /**
 116      * Tag used to demarcate a constant.
 117      */
 118     private static final char TAG_CONST = &#39;\u0002&#39;;
 119 
 120     /**
 121      * Maximum number of argument slots in String Concat call.
 122      *
 123      * While the maximum number of argument slots that indy call can handle is 253,
 124      * we do not use all those slots, to let the strategies with MethodHandle
 125      * combinators to use some arguments.
 126      */
 127     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 128 
 129     /**
 130      * Concatenation strategy to use. See {@link Strategy} for possible options.
 131      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
<span class="line-added"> 132      *</span>
<span class="line-added"> 133      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
 134      */
<span class="line-modified"> 135     private static final Strategy STRATEGY;</span>





 136 
 137     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 138 
 139     private enum Strategy {
 140         /**
 141          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 142          */
 143         BC_SB,
 144 
 145         /**
 146          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 147          * but trying to estimate the required storage.
 148          */
 149         BC_SB_SIZED,
 150 
 151         /**
 152          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 153          * but computing the required storage exactly.
 154          */
 155         BC_SB_SIZED_EXACT,
</pre>
<hr />
<pre>
 162 
 163         /**
 164          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 165          * This strategy also estimate the required storage exactly.
 166          */
 167         MH_SB_SIZED_EXACT,
 168 
 169         /**
 170          * MethodHandle-based generator, that constructs its own byte[] array from
 171          * the arguments. It computes the required storage exactly.
 172          */
 173         MH_INLINE_SIZED_EXACT
 174     }
 175 
 176     /**
 177      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 178      * checks, etc.
 179      */
 180     private static final boolean DEBUG;
 181 













 182     static {










 183         final String strategy =
 184                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<span class="line-modified"> 185         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-modified"> 186 </span>
 187         DEBUG = Boolean.parseBoolean(
 188                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));






 189     }
 190 
 191     /**
 192      * Cache key is a composite of:
 193      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 194      *   - method type, describing the dynamic arguments for concatenation
 195      *   - concat recipe, describing the constants and concat shape
 196      */
 197     private static final class Key {
 198         final String className;
 199         final MethodType mt;
 200         final Recipe recipe;
 201 
 202         public Key(String className, MethodType mt, Recipe recipe) {
 203             this.className = className;
 204             this.mt = mt;
 205             this.recipe = recipe;
 206         }
 207 
 208         @Override
</pre>
<hr />
<pre>
 211             if (o == null || getClass() != o.getClass()) return false;
 212 
 213             Key key = (Key) o;
 214 
 215             if (!className.equals(key.className)) return false;
 216             if (!mt.equals(key.mt)) return false;
 217             if (!recipe.equals(key.recipe)) return false;
 218             return true;
 219         }
 220 
 221         @Override
 222         public int hashCode() {
 223             int result = className.hashCode();
 224             result = 31 * result + mt.hashCode();
 225             result = 31 * result + recipe.hashCode();
 226             return result;
 227         }
 228     }
 229 
 230     /**
<span class="line-modified"> 231      * Parses the recipe string, and produces a traversable collection of</span>
 232      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 233      * strategies. Notably, this class parses out the constants from the recipe
 234      * and from other static arguments.
 235      */
 236     private static final class Recipe {
 237         private final List&lt;RecipeElement&gt; elements;
 238 
 239         public Recipe(String src, Object[] constants) {
 240             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 241 
 242             int constC = 0;
 243             int argC = 0;
 244 
 245             StringBuilder acc = new StringBuilder();
 246 
 247             for (int i = 0; i &lt; src.length(); i++) {
 248                 char c = src.charAt(i);
 249 
 250                 if (c == TAG_CONST || c == TAG_ARG) {
 251                     // Detected a special tag, flush all accumulated characters
</pre>
<hr />
<pre>
 619                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 620                             cCount +
 621                             &quot; constants, but only &quot; +
 622                             constants.length +
 623                             &quot; are passed&quot;);
 624         }
 625 
 626         if (!concatType.returnType().isAssignableFrom(String.class)) {
 627             throw new StringConcatException(
 628                     &quot;The return type should be compatible with String, but it is &quot; +
 629                             concatType.returnType());
 630         }
 631 
 632         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 633             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 634                     concatType.parameterSlotCount() +
 635                     &quot;, can only accept &quot; +
 636                     MAX_INDY_CONCAT_ARG_SLOTS);
 637         }
 638 

 639         MethodType mt = adaptType(concatType);
 640         Recipe rec = new Recipe(recipe, constants);
<span class="line-modified"> 641         MethodHandle mh = generate(lookup, mt, rec);</span>











 642         return new ConstantCallSite(mh.asType(concatType));
 643     }
 644 
 645     /**
 646      * Adapt method type to an API we are going to use.
 647      *
 648      * This strips the concrete classes from the signatures, thus preventing
 649      * class leakage when we cache the concatenation stubs.
 650      *
 651      * @param args actual argument types
 652      * @return argument types the strategy is going to use
 653      */
 654     private static MethodType adaptType(MethodType args) {
 655         Class&lt;?&gt;[] ptypes = null;
 656         for (int i = 0; i &lt; args.parameterCount(); i++) {
 657             Class&lt;?&gt; ptype = args.parameterType(i);
 658             if (!ptype.isPrimitive() &amp;&amp;
 659                     ptype != String.class &amp;&amp;
 660                     ptype != Object.class) { // truncate to Object
 661                 if (ptypes == null) {
 662                     ptypes = args.parameterArray();
 663                 }
 664                 ptypes[i] = Object.class;
 665             }
 666             // else other primitives or String or Object (unchanged)
 667         }
 668         return (ptypes != null)
 669                 ? MethodType.methodType(args.returnType(), ptypes)
 670                 : args;
 671     }
 672 
<span class="line-modified"> 673     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>































 674         try {
<span class="line-added"> 675             if (STRATEGY == null) {</span>
<span class="line-added"> 676                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-added"> 677             }</span>
 678             switch (STRATEGY) {
 679                 case BC_SB:
<span class="line-modified"> 680                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
 681                 case BC_SB_SIZED:
<span class="line-modified"> 682                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
 683                 case BC_SB_SIZED_EXACT:
<span class="line-modified"> 684                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
 685                 case MH_SB_SIZED:
 686                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 687                 case MH_SB_SIZED_EXACT:
 688                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 689                 case MH_INLINE_SIZED_EXACT:
 690                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 691                 default:
 692                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 693             }
 694         } catch (Error | StringConcatException e) {
 695             // Pass through any error or existing StringConcatException
 696             throw e;
 697         } catch (Throwable t) {
 698             throw new StringConcatException(&quot;Generator failed&quot;, t);
 699         }
 700     }
 701 
 702     private enum Mode {
 703         DEFAULT(false, false),
 704         SIZED(true, false),
</pre>
<hr />
<pre>
 747      * it only guesses the space required for known types (e.g. primitives and
 748      * Strings), but does not otherwise convert arguments. Therefore, the
 749      * capacity estimate may be wrong, and StringBuilder may have to
 750      * transparently resize or trim when doing the actual concatenation. While
 751      * this does not constitute a correctness issue (in the end, that what BC_SB
 752      * has to do anyway), this does pose a potential performance problem.
 753      *
 754      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 755      * sized exactly&quot;.&lt;/b&gt;
 756      *
 757      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 758      * converting all arguments to String in order to get the exact capacity
 759      * StringBuilder should have. The conversion is done via the public
 760      * String.valueOf and/or Object.toString methods, and does not touch any
 761      * private String API.
 762      */
 763     private static final class BytecodeStringBuilderStrategy {
 764         static final int CLASSFILE_VERSION = 52;
 765         static final String METHOD_NAME = &quot;concat&quot;;
 766 
<span class="line-added"> 767         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769         /**</span>
<span class="line-added"> 770          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-added"> 771          * code, at the expense of contaminating the profiles.</span>
<span class="line-added"> 772          */</span>
<span class="line-added"> 773         private static final boolean CACHE_ENABLE;</span>
<span class="line-added"> 774 </span>
<span class="line-added"> 775         /**</span>
<span class="line-added"> 776          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-added"> 777          */</span>
<span class="line-added"> 778         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780         static {</span>
<span class="line-added"> 781             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-added"> 782                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-added"> 783             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785             final String dumpPath =</span>
<span class="line-added"> 786                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-added"> 787 </span>
<span class="line-added"> 788             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-added"> 789         }</span>
<span class="line-added"> 790 </span>
 791         private BytecodeStringBuilderStrategy() {
 792             // no instantiation
 793         }
 794 
<span class="line-modified"> 795         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-added"> 796             String className = getClassName(lookup.lookupClass());</span>
<span class="line-added"> 797             Key key = null;</span>
<span class="line-added"> 798             if (CACHE_ENABLE) {</span>
<span class="line-added"> 799                 key = new Key(className, args, recipe);</span>
<span class="line-added"> 800                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-added"> 801                 if (mh != null) {</span>
<span class="line-added"> 802                     return mh;</span>
<span class="line-added"> 803                 }</span>
<span class="line-added"> 804             }</span>
<span class="line-added"> 805 </span>
 806             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 807 
 808             cw.visit(CLASSFILE_VERSION,
 809                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 810                     className,
 811                     null,
 812                     &quot;java/lang/Object&quot;,
 813                     null
 814             );
 815 
 816             MethodVisitor mv = cw.visitMethod(
 817                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 818                     METHOD_NAME,
 819                     args.toMethodDescriptorString(),
 820                     null,
 821                     null);
 822 
 823             // use of @ForceInline no longer has any effect
 824             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 825             mv.visitCode();
</pre>
<hr />
<pre>
1075             }
1076 
1077             mv.visitMethodInsn(
1078                     INVOKEVIRTUAL,
1079                     &quot;java/lang/StringBuilder&quot;,
1080                     &quot;toString&quot;,
1081                     &quot;()Ljava/lang/String;&quot;,
1082                     false
1083             );
1084 
1085             mv.visitInsn(ARETURN);
1086 
1087             mv.visitMaxs(-1, -1);
1088             mv.visitEnd();
1089             cw.visitEnd();
1090 
1091             byte[] classBytes = cw.toByteArray();
1092             try {
1093                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1094                 dumpIfEnabled(className, classBytes);
<span class="line-modified">1095                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-added">1096                 if (CACHE_ENABLE) {</span>
<span class="line-added">1097                     CACHE.put(key, mh);</span>
<span class="line-added">1098                 }</span>
<span class="line-added">1099                 return mh;</span>
1100             } catch (Exception e) {
1101                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1102                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1103             }
1104         }
1105 
<span class="line-added">1106         /**</span>
<span class="line-added">1107          * The generated class is in the same package as the host class as</span>
<span class="line-added">1108          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-added">1109          * class.</span>
<span class="line-added">1110          *</span>
<span class="line-added">1111          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-added">1112          */</span>
<span class="line-added">1113         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-added">1114             if (CACHE_ENABLE) {</span>
<span class="line-added">1115                 String pkgName = hostClass.getPackageName();</span>
<span class="line-added">1116                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-added">1117             } else {</span>
<span class="line-added">1118                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-added">1119                         : hostClass.getName();</span>
<span class="line-added">1120                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-added">1121             }</span>
<span class="line-added">1122         }</span>
<span class="line-added">1123 </span>
1124         private static void dumpIfEnabled(String name, byte[] bytes) {
1125             if (DUMPER != null) {
1126                 DUMPER.dumpClass(name, bytes);
1127             }
1128         }
1129 
1130         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1131             if (cl.isPrimitive()) {
1132                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1133                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1134                 } else if (cl == Boolean.TYPE) {
1135                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1136                 } else if (cl == Character.TYPE) {
1137                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1138                 } else if (cl == Double.TYPE) {
1139                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1140                 } else if (cl == Float.TYPE) {
1141                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1142                 } else if (cl == Long.TYPE) {
1143                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
</pre>
<hr />
<pre>
1674                         1 + ac // selected argument
1675                 );
1676             } else {
1677                 // No mixer (constants only concat), insert initialLengthCoder directly
1678                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1679             }
1680 
1681             // The method handle shape here is (&lt;args&gt;).
1682 
1683             // Apply filters, converting the arguments:
1684             if (filters != null) {
1685                 mh = MethodHandles.filterArguments(mh, 0, filters);
1686             }
1687 
1688             return mh;
1689         }
1690 
1691         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1692             return MethodHandles.insertArguments(
1693                     MethodHandles.insertArguments(
<span class="line-modified">1694                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
1695         }
1696 
1697         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1698             return MIXERS.computeIfAbsent(cl, MIX);
1699         }
1700 
1701         // This one is deliberately non-lambdified to optimize startup time:
1702         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1703             @Override
1704             public MethodHandle apply(Class&lt;?&gt; c) {
1705                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1706                             methodType(long.class, long.class, byte[].class,
1707                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1708             }
1709         };
1710 
1711         // This one is deliberately non-lambdified to optimize startup time:
1712         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1713             @Override
1714             public MethodHandle apply(Class&lt;?&gt; c) {
</pre>
<hr />
<pre>
1719         private static final MethodHandle SIMPLE;
1720         private static final MethodHandle NEW_STRING;
1721         private static final MethodHandle NEW_ARRAY;
1722         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1723         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1724         private static final long INITIAL_CODER;
1725 
1726         static {
1727             try {
1728                 MethodHandle initCoder = JLA.stringConcatHelper(&quot;initialCoder&quot;, methodType(long.class));
1729                 INITIAL_CODER = (long) initCoder.invoke();
1730             } catch (Throwable e) {
1731                 throw new AssertionError(e);
1732             }
1733 
1734             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1735             MIXERS = new ConcurrentHashMap&lt;&gt;();
1736 
1737             SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
1738             NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<span class="line-modified">1739             NEW_ARRAY  = JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
1740         }
1741     }
1742 
1743     /**
1744      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1745      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1746      */
1747     private static final class Stringifiers {
1748         private Stringifiers() {
1749             // no instantiation
1750         }
1751 
1752         private static final MethodHandle OBJECT_INSTANCE =
1753                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1754 
1755         private static class FloatStringifiers {
1756             private static final MethodHandle FLOAT_INSTANCE =
1757                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1758 
1759             private static final MethodHandle DOUBLE_INSTANCE =
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandles.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../util/jar/JarFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
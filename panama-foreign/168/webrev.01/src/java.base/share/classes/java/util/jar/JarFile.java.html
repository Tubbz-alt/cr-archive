<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/jar/JarFile.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util.jar;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.access.JavaUtilZipFileAccess;
  30 import sun.security.action.GetPropertyAction;
  31 import sun.security.util.ManifestEntryVerifier;
  32 import sun.security.util.SignatureFileVerifier;
  33 
  34 import java.io.ByteArrayInputStream;
  35 import java.io.EOFException;
  36 import java.io.File;
  37 import java.io.IOException;
  38 import java.io.InputStream;
  39 import java.lang.ref.SoftReference;
  40 import java.net.URL;
  41 import java.security.CodeSigner;
  42 import java.security.CodeSource;
  43 import java.security.cert.Certificate;
  44 import java.util.ArrayList;
  45 import java.util.Collections;
  46 import java.util.Enumeration;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.NoSuchElementException;
  50 import java.util.Objects;
  51 import java.util.function.Function;
  52 import java.util.stream.Stream;
  53 import java.util.zip.ZipEntry;
  54 import java.util.zip.ZipException;
  55 import java.util.zip.ZipFile;
  56 
  57 /**
  58  * The {@code JarFile} class is used to read the contents of a jar file
  59  * from any file that can be opened with {@code java.io.RandomAccessFile}.
  60  * It extends the class {@code java.util.zip.ZipFile} with support
  61  * for reading an optional {@code Manifest} entry, and support for
  62  * processing multi-release jar files.  The {@code Manifest} can be used
  63  * to specify meta-information about the jar file and its entries.
  64  *
  65  * &lt;p&gt;&lt;a id=&quot;multirelease&quot;&gt;A multi-release jar file&lt;/a&gt; is a jar file that
  66  * contains a manifest with a main attribute named &quot;Multi-Release&quot;,
  67  * a set of &quot;base&quot; entries, some of which are public classes with public
  68  * or protected methods that comprise the public interface of the jar file,
  69  * and a set of &quot;versioned&quot; entries contained in subdirectories of the
  70  * &quot;META-INF/versions&quot; directory.  The versioned entries are partitioned by the
  71  * major version of the Java platform.  A versioned entry, with a version
  72  * {@code n}, {@code 8 &lt; n}, in the &quot;META-INF/versions/{n}&quot; directory overrides
  73  * the base entry as well as any entry with a version number {@code i} where
  74  * {@code 8 &lt; i &lt; n}.
  75  *
  76  * &lt;p&gt;By default, a {@code JarFile} for a multi-release jar file is configured
  77  * to process the multi-release jar file as if it were a plain (unversioned) jar
  78  * file, and as such an entry name is associated with at most one base entry.
  79  * The {@code JarFile} may be configured to process a multi-release jar file by
  80  * creating the {@code JarFile} with the
  81  * {@link JarFile#JarFile(File, boolean, int, Runtime.Version)} constructor.  The
  82  * {@code Runtime.Version} object sets a maximum version used when searching for
  83  * versioned entries.  When so configured, an entry name
  84  * can correspond with at most one base entry and zero or more versioned
  85  * entries. A search is required to associate the entry name with the latest
  86  * versioned entry whose version is less than or equal to the maximum version
  87  * (see {@link #getEntry(String)}).
  88  *
  89  * &lt;p&gt;Class loaders that utilize {@code JarFile} to load classes from the
  90  * contents of {@code JarFile} entries should construct the {@code JarFile}
  91  * by invoking the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
  92  * constructor with the value {@code Runtime.version()} assigned to the last
  93  * argument.  This assures that classes compatible with the major
  94  * version of the running JVM are loaded from multi-release jar files.
  95  *
  96  * &lt;p&gt; If the {@code verify} flag is on when opening a signed jar file, the content
  97  * of the jar entry is verified against the signature embedded inside the manifest
  98  * that is associated with its {@link JarEntry#getRealName() path name}. For a
  99  * multi-release jar file, the content of a versioned entry is verfieid against
 100  * its own signature and {@link JarEntry#getCodeSigners()} returns its own signers.
 101  *
 102  * Please note that the verification process does not include validating the
 103  * signer&#39;s certificate. A caller should inspect the return value of
 104  * {@link JarEntry#getCodeSigners()} to further determine if the signature
 105  * can be trusted.
 106  *
 107  * &lt;p&gt; Unless otherwise noted, passing a {@code null} argument to a constructor
 108  * or method in this class will cause a {@link NullPointerException} to be
 109  * thrown.
 110  *
 111  * @implNote
 112  * &lt;div class=&quot;block&quot;&gt;
 113  * If the API can not be used to configure a {@code JarFile} (e.g. to override
 114  * the configuration of a compiled application or library), two {@code System}
 115  * properties are available.
 116  * &lt;ul&gt;
 117  * &lt;li&gt;
 118  * {@code jdk.util.jar.version} can be assigned a value that is the
 119  * {@code String} representation of a non-negative integer
 120  * {@code &lt;= Runtime.version().feature()}.  The value is used to set the effective
 121  * runtime version to something other than the default value obtained by
 122  * evaluating {@code Runtime.version().feature()}. The effective runtime version
 123  * is the version that the {@link JarFile#JarFile(File, boolean, int, Runtime.Version)}
 124  * constructor uses when the value of the last argument is
 125  * {@code JarFile.runtimeVersion()}.
 126  * &lt;/li&gt;
 127  * &lt;li&gt;
 128  * {@code jdk.util.jar.enableMultiRelease} can be assigned one of the three
 129  * {@code String} values &lt;em&gt;true&lt;/em&gt;, &lt;em&gt;false&lt;/em&gt;, or &lt;em&gt;force&lt;/em&gt;.  The
 130  * value &lt;em&gt;true&lt;/em&gt;, the default value, enables multi-release jar file
 131  * processing.  The value &lt;em&gt;false&lt;/em&gt; disables multi-release jar processing,
 132  * ignoring the &quot;Multi-Release&quot; manifest attribute, and the versioned
 133  * directories in a multi-release jar file if they exist.  Furthermore,
 134  * the method {@link JarFile#isMultiRelease()} returns &lt;em&gt;false&lt;/em&gt;. The value
 135  * &lt;em&gt;force&lt;/em&gt; causes the {@code JarFile} to be initialized to runtime
 136  * versioning after construction.  It effectively does the same as this code:
 137  * {@code (new JarFile(File, boolean, int, JarFile.runtimeVersion())}.
 138  * &lt;/li&gt;
 139  * &lt;/ul&gt;
 140  * &lt;/div&gt;
 141  *
 142  * @author  David Connelly
 143  * @see     Manifest
 144  * @see     java.util.zip.ZipFile
 145  * @see     java.util.jar.JarEntry
 146  * @since   1.2
 147  */
 148 public class JarFile extends ZipFile {
 149     private static final Runtime.Version BASE_VERSION;
 150     private static final int BASE_VERSION_FEATURE;
 151     private static final Runtime.Version RUNTIME_VERSION;
 152     private static final boolean MULTI_RELEASE_ENABLED;
 153     private static final boolean MULTI_RELEASE_FORCED;
 154     private static final ThreadLocal&lt;Boolean&gt; isInitializing = new ThreadLocal&lt;&gt;();
 155 
 156     private SoftReference&lt;Manifest&gt; manRef;
 157     private JarEntry manEntry;
 158     private JarVerifier jv;
 159     private boolean jvInitialized;
 160     private boolean verify;
 161     private final Runtime.Version version;  // current version
 162     private final int versionFeature;       // version.feature()
 163     private boolean isMultiRelease;         // is jar multi-release?
 164 
 165     // indicates if Class-Path attribute present
 166     private boolean hasClassPathAttribute;
 167     // true if manifest checked for special attributes
 168     private volatile boolean hasCheckedSpecialAttributes;
 169 
 170     private static final JavaUtilZipFileAccess JUZFA;
 171 
 172     static {
 173         // Set up JavaUtilJarAccess in SharedSecrets
 174         SharedSecrets.setJavaUtilJarAccess(new JavaUtilJarAccessImpl());
 175         // Get JavaUtilZipFileAccess from SharedSecrets
 176         JUZFA = SharedSecrets.getJavaUtilZipFileAccess();
 177         // multi-release jar file versions &gt;= 9
 178         BASE_VERSION = Runtime.Version.parse(Integer.toString(8));
 179         BASE_VERSION_FEATURE = BASE_VERSION.feature();
 180         String jarVersion = GetPropertyAction.privilegedGetProperty(&quot;jdk.util.jar.version&quot;);
 181         int runtimeVersion = Runtime.version().feature();
 182         if (jarVersion != null) {
 183             int jarVer = Integer.parseInt(jarVersion);
 184             runtimeVersion = (jarVer &gt; runtimeVersion)
 185                     ? runtimeVersion
 186                     : Math.max(jarVer, BASE_VERSION_FEATURE);
 187         }
 188         RUNTIME_VERSION = Runtime.Version.parse(Integer.toString(runtimeVersion));
 189         String enableMultiRelease = GetPropertyAction
 190                 .privilegedGetProperty(&quot;jdk.util.jar.enableMultiRelease&quot;, &quot;true&quot;);
 191         switch (enableMultiRelease) {
 192             case &quot;true&quot;:
 193             default:
 194                 MULTI_RELEASE_ENABLED = true;
 195                 MULTI_RELEASE_FORCED = false;
 196                 break;
 197             case &quot;false&quot;:
 198                 MULTI_RELEASE_ENABLED = false;
 199                 MULTI_RELEASE_FORCED = false;
 200                 break;
 201             case &quot;force&quot;:
 202                 MULTI_RELEASE_ENABLED = true;
 203                 MULTI_RELEASE_FORCED = true;
 204                 break;
 205         }
 206     }
 207 
 208     private static final String META_INF = &quot;META-INF/&quot;;
 209 
 210     private static final String META_INF_VERSIONS = META_INF + &quot;versions/&quot;;
 211 
 212     /**
 213      * The JAR manifest file name.
 214      */
 215     public static final String MANIFEST_NAME = META_INF + &quot;MANIFEST.MF&quot;;
 216 
 217     /**
 218      * Returns the version that represents the unversioned configuration of a
 219      * multi-release jar file.
 220      *
 221      * @return the version that represents the unversioned configuration
 222      *
 223      * @since 9
 224      */
 225     public static Runtime.Version baseVersion() {
 226         return BASE_VERSION;
 227     }
 228 
 229     /**
 230      * Returns the version that represents the effective runtime versioned
 231      * configuration of a multi-release jar file.
 232      * &lt;p&gt;
 233      * By default the feature version number of the returned {@code Version} will
 234      * be equal to the feature version number of {@code Runtime.version()}.
 235      * However, if the {@code jdk.util.jar.version} property is set, the
 236      * returned {@code Version} is derived from that property and feature version
 237      * numbers may not be equal.
 238      *
 239      * @return the version that represents the runtime versioned configuration
 240      *
 241      * @since 9
 242      */
 243     public static Runtime.Version runtimeVersion() {
 244         return RUNTIME_VERSION;
 245     }
 246 
 247     /**
 248      * Creates a new {@code JarFile} to read from the specified
 249      * file {@code name}. The {@code JarFile} will be verified if
 250      * it is signed.
 251      * @param name the name of the jar file to be opened for reading
 252      * @throws IOException if an I/O error has occurred
 253      * @throws SecurityException if access to the file is denied
 254      *         by the SecurityManager
 255      */
 256     public JarFile(String name) throws IOException {
 257         this(new File(name), true, ZipFile.OPEN_READ);
 258     }
 259 
 260     /**
 261      * Creates a new {@code JarFile} to read from the specified
 262      * file {@code name}.
 263      * @param name the name of the jar file to be opened for reading
 264      * @param verify whether or not to verify the jar file if
 265      * it is signed.
 266      * @throws IOException if an I/O error has occurred
 267      * @throws SecurityException if access to the file is denied
 268      *         by the SecurityManager
 269      */
 270     public JarFile(String name, boolean verify) throws IOException {
 271         this(new File(name), verify, ZipFile.OPEN_READ);
 272     }
 273 
 274     /**
 275      * Creates a new {@code JarFile} to read from the specified
 276      * {@code File} object. The {@code JarFile} will be verified if
 277      * it is signed.
 278      * @param file the jar file to be opened for reading
 279      * @throws IOException if an I/O error has occurred
 280      * @throws SecurityException if access to the file is denied
 281      *         by the SecurityManager
 282      */
 283     public JarFile(File file) throws IOException {
 284         this(file, true, ZipFile.OPEN_READ);
 285     }
 286 
 287     /**
 288      * Creates a new {@code JarFile} to read from the specified
 289      * {@code File} object.
 290      * @param file the jar file to be opened for reading
 291      * @param verify whether or not to verify the jar file if
 292      * it is signed.
 293      * @throws IOException if an I/O error has occurred
 294      * @throws SecurityException if access to the file is denied
 295      *         by the SecurityManager.
 296      */
 297     public JarFile(File file, boolean verify) throws IOException {
 298         this(file, verify, ZipFile.OPEN_READ);
 299     }
 300 
 301     /**
 302      * Creates a new {@code JarFile} to read from the specified
 303      * {@code File} object in the specified mode.  The mode argument
 304      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 305      *
 306      * @param file the jar file to be opened for reading
 307      * @param verify whether or not to verify the jar file if
 308      * it is signed.
 309      * @param mode the mode in which the file is to be opened
 310      * @throws IOException if an I/O error has occurred
 311      * @throws IllegalArgumentException
 312      *         if the {@code mode} argument is invalid
 313      * @throws SecurityException if access to the file is denied
 314      *         by the SecurityManager
 315      * @since 1.3
 316      */
 317     public JarFile(File file, boolean verify, int mode) throws IOException {
 318         this(file, verify, mode, BASE_VERSION);
 319     }
 320 
 321     /**
 322      * Creates a new {@code JarFile} to read from the specified
 323      * {@code File} object in the specified mode.  The mode argument
 324      * must be either {@code OPEN_READ} or {@code OPEN_READ | OPEN_DELETE}.
 325      * The version argument, after being converted to a canonical form, is
 326      * used to configure the {@code JarFile} for processing
 327      * multi-release jar files.
 328      * &lt;p&gt;
 329      * The canonical form derived from the version parameter is
 330      * {@code Runtime.Version.parse(Integer.toString(n))} where {@code n} is
 331      * {@code Math.max(version.feature(), JarFile.baseVersion().feature())}.
 332      *
 333      * @param file the jar file to be opened for reading
 334      * @param verify whether or not to verify the jar file if
 335      * it is signed.
 336      * @param mode the mode in which the file is to be opened
 337      * @param version specifies the release version for a multi-release jar file
 338      * @throws IOException if an I/O error has occurred
 339      * @throws IllegalArgumentException
 340      *         if the {@code mode} argument is invalid
 341      * @throws SecurityException if access to the file is denied
 342      *         by the SecurityManager
 343      * @throws NullPointerException if {@code version} is {@code null}
 344      * @since 9
 345      */
 346     public JarFile(File file, boolean verify, int mode, Runtime.Version version) throws IOException {
 347         super(file, mode);
 348         this.verify = verify;
 349         Objects.requireNonNull(version);
 350         if (MULTI_RELEASE_FORCED || version.feature() == RUNTIME_VERSION.feature()) {
 351             // This deals with the common case where the value from JarFile.runtimeVersion() is passed
 352             this.version = RUNTIME_VERSION;
 353         } else if (version.feature() &lt;= BASE_VERSION_FEATURE) {
 354             // This also deals with the common case where the value from JarFile.baseVersion() is passed
 355             this.version = BASE_VERSION;
 356         } else {
 357             // Canonicalize
 358             this.version = Runtime.Version.parse(Integer.toString(version.feature()));
 359         }
 360         this.versionFeature = this.version.feature();
 361     }
 362 
 363     /**
 364      * Returns the maximum version used when searching for versioned entries.
 365      * &lt;p&gt;
 366      * If this {@code JarFile} is not a multi-release jar file or is not
 367      * configured to be processed as such, then the version returned will be the
 368      * same as that returned from {@link #baseVersion()}.
 369      *
 370      * @return the maximum version
 371      * @since 9
 372      */
 373     public final Runtime.Version getVersion() {
 374         return isMultiRelease() ? this.version : BASE_VERSION;
 375     }
 376 
 377     /**
 378      * Indicates whether or not this jar file is a multi-release jar file.
 379      *
 380      * @return true if this JarFile is a multi-release jar file
 381      * @since 9
 382      */
 383     public final boolean isMultiRelease() {
 384         if (isMultiRelease) {
 385             return true;
 386         }
 387         if (MULTI_RELEASE_ENABLED) {
 388             try {
 389                 checkForSpecialAttributes();
 390             } catch (IOException io) {
 391                 isMultiRelease = false;
 392             }
 393         }
 394         return isMultiRelease;
 395     }
 396 
 397     /**
 398      * Returns the jar file manifest, or {@code null} if none.
 399      *
 400      * @return the jar file manifest, or {@code null} if none
 401      *
 402      * @throws IllegalStateException
 403      *         may be thrown if the jar file has been closed
 404      * @throws IOException  if an I/O error has occurred
 405      */
 406     public Manifest getManifest() throws IOException {
 407         return getManifestFromReference();
 408     }
 409 
 410     private Manifest getManifestFromReference() throws IOException {
 411         Manifest man = manRef != null ? manRef.get() : null;
 412 
 413         if (man == null) {
 414 
 415             JarEntry manEntry = getManEntry();
 416 
 417             // If found then load the manifest
 418             if (manEntry != null) {
 419                 if (verify) {
 420                     byte[] b = getBytes(manEntry);
 421                     if (!jvInitialized) {
 422                         jv = new JarVerifier(b);
 423                     }
 424                     man = new Manifest(jv, new ByteArrayInputStream(b), getName());
 425                 } else {
 426                     man = new Manifest(super.getInputStream(manEntry), getName());
 427                 }
 428                 manRef = new SoftReference&lt;&gt;(man);
 429             }
 430         }
 431         return man;
 432     }
 433 
 434     /**
 435      * Returns the {@code JarEntry} for the given base entry name or
 436      * {@code null} if not found.
 437      *
 438      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 439      * to be processed as such, then a search is performed to find and return
 440      * a {@code JarEntry} that is the latest versioned entry associated with the
 441      * given entry name.  The returned {@code JarEntry} is the versioned entry
 442      * corresponding to the given base entry name prefixed with the string
 443      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 444      * which an entry exists.  If such a versioned entry does not exist, then
 445      * the {@code JarEntry} for the base entry is returned, otherwise
 446      * {@code null} is returned if no entries are found.  The initial value for
 447      * the version {@code n} is the maximum version as returned by the method
 448      * {@link JarFile#getVersion()}.
 449      *
 450      * @param name the jar file entry name
 451      * @return the {@code JarEntry} for the given entry name, or
 452      *         the versioned entry name, or {@code null} if not found
 453      *
 454      * @throws IllegalStateException
 455      *         may be thrown if the jar file has been closed
 456      *
 457      * @see java.util.jar.JarEntry
 458      *
 459      * @implSpec
 460      * &lt;div class=&quot;block&quot;&gt;
 461      * This implementation invokes {@link JarFile#getEntry(String)}.
 462      * &lt;/div&gt;
 463      */
 464     public JarEntry getJarEntry(String name) {
 465         return (JarEntry)getEntry(name);
 466     }
 467 
 468     /**
 469      * Returns the {@code ZipEntry} for the given base entry name or
 470      * {@code null} if not found.
 471      *
 472      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured
 473      * to be processed as such, then a search is performed to find and return
 474      * a {@code ZipEntry} that is the latest versioned entry associated with the
 475      * given entry name.  The returned {@code ZipEntry} is the versioned entry
 476      * corresponding to the given base entry name prefixed with the string
 477      * {@code &quot;META-INF/versions/{n}/&quot;}, for the largest value of {@code n} for
 478      * which an entry exists.  If such a versioned entry does not exist, then
 479      * the {@code ZipEntry} for the base entry is returned, otherwise
 480      * {@code null} is returned if no entries are found.  The initial value for
 481      * the version {@code n} is the maximum version as returned by the method
 482      * {@link JarFile#getVersion()}.
 483      *
 484      * @param name the jar file entry name
 485      * @return the {@code ZipEntry} for the given entry name or
 486      *         the versioned entry name or {@code null} if not found
 487      *
 488      * @throws IllegalStateException
 489      *         may be thrown if the jar file has been closed
 490      *
 491      * @see java.util.zip.ZipEntry
 492      *
 493      * @implSpec
 494      * &lt;div class=&quot;block&quot;&gt;
 495      * This implementation may return a versioned entry for the requested name
 496      * even if there is not a corresponding base entry.  This can occur
 497      * if there is a private or package-private versioned entry that matches.
 498      * If a subclass overrides this method, assure that the override method
 499      * invokes {@code super.getEntry(name)} to obtain all versioned entries.
 500      * &lt;/div&gt;
 501      */
 502     public ZipEntry getEntry(String name) {
 503         if (isMultiRelease()) {
 504             JarEntry je = getVersionedEntry(name, null);
 505             if (je == null) {
 506                 je = (JarEntry)super.getEntry(name);
 507             }
 508             return je;
 509         } else {
 510             return super.getEntry(name);
 511         }
 512     }
 513 
 514     /**
 515      * Returns an enumeration of the jar file entries.
 516      *
 517      * @return an enumeration of the jar file entries
 518      * @throws IllegalStateException
 519      *         may be thrown if the jar file has been closed
 520      */
 521     public Enumeration&lt;JarEntry&gt; entries() {
 522         return JUZFA.entries(this);
 523     }
 524 
 525     /**
 526      * Returns an ordered {@code Stream} over the jar file entries.
 527      * Entries appear in the {@code Stream} in the order they appear in
 528      * the central directory of the jar file.
 529      *
 530      * @return an ordered {@code Stream} of entries in this jar file
 531      * @throws IllegalStateException if the jar file has been closed
 532      * @since 1.8
 533      */
 534     public Stream&lt;JarEntry&gt; stream() {
 535         return JUZFA.stream(this);
 536     }
 537 
 538     /**
 539      * Returns a {@code Stream} of the versioned jar file entries.
 540      *
 541      * &lt;p&gt;If this {@code JarFile} is a multi-release jar file and is configured to
 542      * be processed as such, then an entry in the stream is the latest versioned entry
 543      * associated with the corresponding base entry name. The maximum version of the
 544      * latest versioned entry is the version returned by {@link #getVersion()}.
 545      * The returned stream may include an entry that only exists as a versioned entry.
 546      *
 547      * If the jar file is not a multi-release jar file or the {@code JarFile} is not
 548      * configured for processing a multi-release jar file, this method returns the
 549      * same stream that {@link #stream()} returns.
 550      *
 551      * @return stream of versioned entries
 552      * @since 10
 553      */
 554     public Stream&lt;JarEntry&gt; versionedStream() {
 555 
 556         if (isMultiRelease()) {
 557             return JUZFA.entryNameStream(this).map(this::getBasename)
 558                                               .filter(Objects::nonNull)
 559                                               .distinct()
 560                                               .map(this::getJarEntry)
 561                                               .filter(Objects::nonNull);
 562         }
 563         return stream();
 564     }
 565 
 566     /**
 567      * Creates a ZipEntry suitable for the given ZipFile.
 568      */
 569     JarEntry entryFor(String name) {
 570         return new JarFileEntry(name);
 571     }
 572 
 573     private String getBasename(String name) {
 574         if (name.startsWith(META_INF_VERSIONS)) {
 575             int off = META_INF_VERSIONS.length();
 576             int index = name.indexOf(&#39;/&#39;, off);
 577             try {
 578                 // filter out dir META-INF/versions/ and META-INF/versions/*/
 579                 // and any entry with version &gt; &#39;version&#39;
 580                 if (index == -1 || index == (name.length() - 1) ||
 581                     Integer.parseInt(name, off, index, 10) &gt; versionFeature) {
 582                     return null;
 583                 }
 584             } catch (NumberFormatException x) {
 585                 return null; // remove malformed entries silently
 586             }
 587             // map to its base name
 588             return name.substring(index + 1);
 589         }
 590         return name;
 591     }
 592 
 593     private JarEntry getVersionedEntry(String name, JarEntry defaultEntry) {
 594         if (!name.startsWith(META_INF)) {
 595             int[] versions = JUZFA.getMetaInfVersions(this);
 596             if (BASE_VERSION_FEATURE &lt; versionFeature &amp;&amp; versions.length &gt; 0) {
 597                 // search for versioned entry
 598                 for (int i = versions.length - 1; i &gt;= 0; i--) {
 599                     int version = versions[i];
 600                     // skip versions above versionFeature
 601                     if (version &gt; versionFeature) {
 602                         continue;
 603                     }
 604                     // skip versions below base version
 605                     if (version &lt; BASE_VERSION_FEATURE) {
 606                         break;
 607                     }
 608                     JarFileEntry vje = (JarFileEntry)super.getEntry(
 609                             META_INF_VERSIONS + version + &quot;/&quot; + name);
 610                     if (vje != null) {
 611                         return vje.withBasename(name);
 612                     }
 613                 }
 614             }
 615         }
 616         return defaultEntry;
 617     }
 618 
 619     // placeholder for now
 620     String getRealName(JarEntry entry) {
 621         return entry.getRealName();
 622     }
 623 
 624     private class JarFileEntry extends JarEntry {
 625         private String basename;
 626 
 627         JarFileEntry(String name) {
 628             super(name);
 629             this.basename = name;
 630         }
 631 
 632         JarFileEntry(String name, ZipEntry vze) {
 633             super(vze);
 634             this.basename = name;
 635         }
 636 
 637         @Override
 638         public Attributes getAttributes() throws IOException {
 639             Manifest man = JarFile.this.getManifest();
 640             if (man != null) {
 641                 return man.getAttributes(super.getName());
 642             } else {
 643                 return null;
 644             }
 645         }
 646 
 647         @Override
 648         public Certificate[] getCertificates() {
 649             try {
 650                 maybeInstantiateVerifier();
 651             } catch (IOException e) {
 652                 throw new RuntimeException(e);
 653             }
 654             if (certs == null &amp;&amp; jv != null) {
 655                 certs = jv.getCerts(JarFile.this, realEntry());
 656             }
 657             return certs == null ? null : certs.clone();
 658         }
 659 
 660         @Override
 661         public CodeSigner[] getCodeSigners() {
 662             try {
 663                 maybeInstantiateVerifier();
 664             } catch (IOException e) {
 665                 throw new RuntimeException(e);
 666             }
 667             if (signers == null &amp;&amp; jv != null) {
 668                 signers = jv.getCodeSigners(JarFile.this, realEntry());
 669             }
 670             return signers == null ? null : signers.clone();
 671         }
 672 
 673         @Override
 674         public String getRealName() {
 675             return super.getName();
 676         }
 677 
 678         @Override
 679         public String getName() {
 680             return basename;
 681         }
 682 
 683         JarFileEntry realEntry() {
 684             if (isMultiRelease() &amp;&amp; versionFeature != BASE_VERSION_FEATURE) {
 685                 String entryName = super.getName();
 686                 return entryName == basename || entryName.equals(basename) ?
 687                         this : new JarFileEntry(entryName, this);
 688             }
 689             return this;
 690         }
 691 
 692         // changes the basename, returns &quot;this&quot;
 693         JarFileEntry withBasename(String name) {
 694             basename = name;
 695             return this;
 696         }
 697     }
 698 
 699     /*
 700      * Ensures that the JarVerifier has been created if one is
 701      * necessary (i.e., the jar appears to be signed.) This is done as
 702      * a quick check to avoid processing of the manifest for unsigned
 703      * jars.
 704      */
 705     private void maybeInstantiateVerifier() throws IOException {
 706         if (jv != null) {
 707             return;
 708         }
 709 
 710         if (verify) {
 711             // Gets the manifest name, but only if there are
 712             // signature-related files. If so we can assume
 713             // that the jar is signed and that we therefore
 714             // need a JarVerifier and Manifest
 715             String name = JUZFA.getManifestName(this, true);
 716             if (name != null) {
 717                 getManifest();
 718                 return;
 719             }
 720             // No signature-related files; don&#39;t instantiate a
 721             // verifier
 722             verify = false;
 723         }
 724     }
 725 
 726     /*
 727      * Initializes the verifier object by reading all the manifest
 728      * entries and passing them to the verifier.
 729      */
 730     private void initializeVerifier() {
 731         ManifestEntryVerifier mev = null;
 732 
 733         // Verify &quot;META-INF/&quot; entries...
 734         try {
 735             List&lt;String&gt; names = JUZFA.getManifestAndSignatureRelatedFiles(this);
 736             for (String name : names) {
 737                 JarEntry e = getJarEntry(name);
 738                 if (e == null) {
 739                     throw new JarException(&quot;corrupted jar file&quot;);
 740                 }
 741                 if (mev == null) {
 742                     mev = new ManifestEntryVerifier
 743                         (getManifestFromReference());
 744                 }
 745                 byte[] b = getBytes(e);
 746                 if (b != null &amp;&amp; b.length &gt; 0) {
 747                     jv.beginEntry(e, mev);
 748                     jv.update(b.length, b, 0, b.length, mev);
 749                     jv.update(-1, null, 0, 0, mev);
 750                 }
 751             }
 752         } catch (IOException | IllegalArgumentException ex) {
 753             // if we had an error parsing any blocks, just
 754             // treat the jar file as being unsigned
 755             jv = null;
 756             verify = false;
 757             if (JarVerifier.debug != null) {
 758                 JarVerifier.debug.println(&quot;jarfile parsing error!&quot;);
 759                 ex.printStackTrace();
 760             }
 761         }
 762 
 763         // if after initializing the verifier we have nothing
 764         // signed, we null it out.
 765 
 766         if (jv != null) {
 767 
 768             jv.doneWithMeta();
 769             if (JarVerifier.debug != null) {
 770                 JarVerifier.debug.println(&quot;done with meta!&quot;);
 771             }
 772 
 773             if (jv.nothingToVerify()) {
 774                 if (JarVerifier.debug != null) {
 775                     JarVerifier.debug.println(&quot;nothing to verify!&quot;);
 776                 }
 777                 jv = null;
 778                 verify = false;
 779             }
 780         }
 781     }
 782 
 783     /*
 784      * Reads all the bytes for a given entry. Used to process the
 785      * META-INF files.
 786      */
 787     private byte[] getBytes(ZipEntry ze) throws IOException {
 788         try (InputStream is = super.getInputStream(ze)) {
 789             int len = (int)ze.getSize();
 790             int bytesRead;
 791             byte[] b;
 792             // trust specified entry sizes when reasonably small
 793             if (len != -1 &amp;&amp; len &lt;= 65535) {
 794                 b = new byte[len];
 795                 bytesRead = is.readNBytes(b, 0, len);
 796             } else {
 797                 b = is.readAllBytes();
 798                 bytesRead = b.length;
 799             }
 800             if (len != -1 &amp;&amp; len != bytesRead) {
 801                 throw new EOFException(&quot;Expected:&quot; + len + &quot;, read:&quot; + bytesRead);
 802             }
 803             return b;
 804         }
 805     }
 806 
 807     /**
 808      * Returns an input stream for reading the contents of the specified
 809      * zip file entry.
 810      * @param ze the zip file entry
 811      * @return an input stream for reading the contents of the specified
 812      *         zip file entry
 813      * @throws ZipException if a zip file format error has occurred
 814      * @throws IOException if an I/O error has occurred
 815      * @throws SecurityException if any of the jar file entries
 816      *         are incorrectly signed.
 817      * @throws IllegalStateException
 818      *         may be thrown if the jar file has been closed
 819      */
 820     public synchronized InputStream getInputStream(ZipEntry ze)
 821         throws IOException
 822     {
 823         maybeInstantiateVerifier();
 824         if (jv == null) {
 825             return super.getInputStream(ze);
 826         }
 827         if (!jvInitialized) {
 828             initializeVerifier();
 829             jvInitialized = true;
 830             // could be set to null after a call to
 831             // initializeVerifier if we have nothing to
 832             // verify
 833             if (jv == null)
 834                 return super.getInputStream(ze);
 835         }
 836 
 837         // wrap a verifier stream around the real stream
 838         return new JarVerifier.VerifierStream(
 839             getManifestFromReference(),
 840             verifiableEntry(ze),
 841             super.getInputStream(ze),
 842             jv);
 843     }
 844 
 845     private JarEntry verifiableEntry(ZipEntry ze) {
 846         if (ze instanceof JarFileEntry) {
 847             // assure the name and entry match for verification
 848             return ((JarFileEntry)ze).realEntry();
 849         }
 850         ze = getJarEntry(ze.getName());
 851         if (ze instanceof JarFileEntry) {
 852             return ((JarFileEntry)ze).realEntry();
 853         }
 854         return (JarEntry)ze;
 855     }
 856 
 857     // Statics for hand-coded Boyer-Moore search
 858     private static final byte[] CLASSPATH_CHARS =
 859             {&#39;C&#39;,&#39;L&#39;,&#39;A&#39;,&#39;S&#39;,&#39;S&#39;,&#39;-&#39;,&#39;P&#39;,&#39;A&#39;,&#39;T&#39;,&#39;H&#39;, &#39;:&#39;, &#39; &#39;};
 860 
 861     // The bad character shift for &quot;class-path: &quot;
 862     private static final byte[] CLASSPATH_LASTOCC;
 863 
 864     // The good suffix shift for &quot;class-path: &quot;
 865     private static final byte[] CLASSPATH_OPTOSFT;
 866 
 867     private static final byte[] MULTIRELEASE_CHARS =
 868             {&#39;M&#39;,&#39;U&#39;,&#39;L&#39;,&#39;T&#39;,&#39;I&#39;,&#39;-&#39;,&#39;R&#39;,&#39;E&#39;,&#39;L&#39;,&#39;E&#39;, &#39;A&#39;, &#39;S&#39;, &#39;E&#39;, &#39;:&#39;,
 869                     &#39; &#39;, &#39;T&#39;, &#39;R&#39;, &#39;U&#39;, &#39;E&#39;};
 870 
 871     // The bad character shift for &quot;multi-release: true&quot;
 872     private static final byte[] MULTIRELEASE_LASTOCC;
 873 
 874     // The good suffix shift for &quot;multi-release: true&quot;
 875     private static final byte[] MULTIRELEASE_OPTOSFT;
 876 
 877     static {
 878         CLASSPATH_LASTOCC = new byte[65];
 879         CLASSPATH_OPTOSFT = new byte[12];
 880         CLASSPATH_LASTOCC[(int)&#39;C&#39; - 32] = 1;
 881         CLASSPATH_LASTOCC[(int)&#39;L&#39; - 32] = 2;
 882         CLASSPATH_LASTOCC[(int)&#39;S&#39; - 32] = 5;
 883         CLASSPATH_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 884         CLASSPATH_LASTOCC[(int)&#39;P&#39; - 32] = 7;
 885         CLASSPATH_LASTOCC[(int)&#39;A&#39; - 32] = 8;
 886         CLASSPATH_LASTOCC[(int)&#39;T&#39; - 32] = 9;
 887         CLASSPATH_LASTOCC[(int)&#39;H&#39; - 32] = 10;
 888         CLASSPATH_LASTOCC[(int)&#39;:&#39; - 32] = 11;
 889         CLASSPATH_LASTOCC[(int)&#39; &#39; - 32] = 12;
 890         for (int i = 0; i &lt; 11; i++) {
 891             CLASSPATH_OPTOSFT[i] = 12;
 892         }
 893         CLASSPATH_OPTOSFT[11] = 1;
 894 
 895         MULTIRELEASE_LASTOCC = new byte[65];
 896         MULTIRELEASE_OPTOSFT = new byte[19];
 897         MULTIRELEASE_LASTOCC[(int)&#39;M&#39; - 32] = 1;
 898         MULTIRELEASE_LASTOCC[(int)&#39;I&#39; - 32] = 5;
 899         MULTIRELEASE_LASTOCC[(int)&#39;-&#39; - 32] = 6;
 900         MULTIRELEASE_LASTOCC[(int)&#39;L&#39; - 32] = 9;
 901         MULTIRELEASE_LASTOCC[(int)&#39;A&#39; - 32] = 11;
 902         MULTIRELEASE_LASTOCC[(int)&#39;S&#39; - 32] = 12;
 903         MULTIRELEASE_LASTOCC[(int)&#39;:&#39; - 32] = 14;
 904         MULTIRELEASE_LASTOCC[(int)&#39; &#39; - 32] = 15;
 905         MULTIRELEASE_LASTOCC[(int)&#39;T&#39; - 32] = 16;
 906         MULTIRELEASE_LASTOCC[(int)&#39;R&#39; - 32] = 17;
 907         MULTIRELEASE_LASTOCC[(int)&#39;U&#39; - 32] = 18;
 908         MULTIRELEASE_LASTOCC[(int)&#39;E&#39; - 32] = 19;
 909         for (int i = 0; i &lt; 17; i++) {
 910             MULTIRELEASE_OPTOSFT[i] = 19;
 911         }
 912         MULTIRELEASE_OPTOSFT[17] = 6;
 913         MULTIRELEASE_OPTOSFT[18] = 1;
 914     }
 915 
 916     private JarEntry getManEntry() {
 917         if (manEntry == null) {
 918             // The manifest entry position is resolved during
 919             // initialization
 920             String name = JUZFA.getManifestName(this, false);
 921             if (name != null) {
 922                 this.manEntry = (JarEntry)super.getEntry(name);
 923             }
 924         }
 925         return manEntry;
 926     }
 927 
 928    /**
 929     * Returns {@code true} iff this JAR file has a manifest with the
 930     * Class-Path attribute
 931     */
 932     boolean hasClassPathAttribute() throws IOException {
 933         checkForSpecialAttributes();
 934         return hasClassPathAttribute;
 935     }
 936 
 937     /**
 938      * Returns true if the pattern {@code src} is found in {@code b}.
 939      * The {@code lastOcc} array is the precomputed bad character shifts.
 940      * Since there are no repeated substring in our search strings,
 941      * the good suffix shifts can be replaced with a comparison.
 942      */
 943     private int match(byte[] src, byte[] b, byte[] lastOcc, byte[] optoSft) {
 944         int len = src.length;
 945         int last = b.length - len;
 946         int i = 0;
 947         next:
 948         while (i &lt;= last) {
 949             for (int j = (len - 1); j &gt;= 0; j--) {
 950                 byte c = b[i + j];
 951                 if (c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;z&#39;) {
 952                     if (c &gt;= &#39;a&#39;) c -= 32; // Canonicalize
 953 
 954                     if (c != src[j]) {
 955                         // no match
 956                         int badShift = lastOcc[c - 32];
 957                         i += Math.max(j + 1 - badShift, optoSft[j]);
 958                         continue next;
 959                     }
 960                 } else {
 961                     // no match, character not valid for name
 962                     i += len;
 963                     continue next;
 964                 }
 965             }
 966             return i;
 967         }
 968         return -1;
 969     }
 970 
 971     /**
 972      * On first invocation, check if the JAR file has the Class-Path
 973      * and the Multi-Release attribute. A no-op on subsequent calls.
 974      */
 975     private void checkForSpecialAttributes() throws IOException {
 976         if (hasCheckedSpecialAttributes) {
 977             return;
 978         }
 979         synchronized (this) {
 980             if (hasCheckedSpecialAttributes) {
 981                 return;
 982             }
 983             JarEntry manEntry = getManEntry();
 984             if (manEntry != null) {
 985                 byte[] b = getBytes(manEntry);
 986                 hasClassPathAttribute = match(CLASSPATH_CHARS, b,
 987                         CLASSPATH_LASTOCC, CLASSPATH_OPTOSFT) != -1;
 988                 // is this a multi-release jar file
 989                 if (MULTI_RELEASE_ENABLED) {
 990                     int i = match(MULTIRELEASE_CHARS, b, MULTIRELEASE_LASTOCC,
 991                             MULTIRELEASE_OPTOSFT);
 992                     if (i != -1) {
 993                         // Read the main attributes of the manifest
 994                         byte[] lbuf = new byte[512];
 995                         Attributes attr = new Attributes();
 996                         attr.read(new Manifest.FastInputStream(
 997                                 new ByteArrayInputStream(b)), lbuf);
 998                         isMultiRelease = Boolean.parseBoolean(
 999                             attr.getValue(Attributes.Name.MULTI_RELEASE));
1000                     }
1001                 }
1002             }
1003             hasCheckedSpecialAttributes = true;
1004         }
1005     }
1006 
1007     synchronized void ensureInitialization() {
1008         try {
1009             maybeInstantiateVerifier();
1010         } catch (IOException e) {
1011             throw new RuntimeException(e);
1012         }
1013         if (jv != null &amp;&amp; !jvInitialized) {
1014             isInitializing.set(Boolean.TRUE);
1015             try {
1016                 initializeVerifier();
1017                 jvInitialized = true;
1018             } finally {
1019                 isInitializing.set(Boolean.FALSE);
1020             }
1021         }
1022     }
1023 
1024     static boolean isInitializing() {
1025         Boolean value = isInitializing.get();
1026         return (value == null) ? false : value;
1027     }
1028 
1029     /*
1030      * Returns a versioned {@code JarFileEntry} for the given entry,
1031      * if there is one. Otherwise returns the original entry. This
1032      * is invoked by the {@code entries2} for verifier.
1033      */
1034     JarEntry newEntry(JarEntry je) {
1035         if (isMultiRelease()) {
1036             return getVersionedEntry(je.getName(), je);
1037         }
1038         return je;
1039     }
1040 
1041     /*
1042      * Returns a versioned {@code JarFileEntry} for the given entry
1043      * name, if there is one. Otherwise returns a {@code JarFileEntry}
1044      * with the given name. It is invoked from JarVerifier&#39;s entries2
1045      * for {@code singers}.
1046      */
1047     JarEntry newEntry(String name) {
1048         if (isMultiRelease()) {
1049             JarEntry vje = getVersionedEntry(name, null);
1050             if (vje != null) {
1051                 return vje;
1052             }
1053         }
1054         return new JarFileEntry(name);
1055     }
1056 
1057     Enumeration&lt;String&gt; entryNames(CodeSource[] cs) {
1058         ensureInitialization();
1059         if (jv != null) {
1060             return jv.entryNames(this, cs);
1061         }
1062 
1063         /*
1064          * JAR file has no signed content. Is there a non-signing
1065          * code source?
1066          */
1067         boolean includeUnsigned = false;
1068         for (CodeSource c : cs) {
1069             if (c.getCodeSigners() == null) {
1070                 includeUnsigned = true;
1071                 break;
1072             }
1073         }
1074         if (includeUnsigned) {
1075             return unsignedEntryNames();
1076         } else {
1077             return Collections.emptyEnumeration();
1078         }
1079     }
1080 
1081     /**
1082      * Returns an enumeration of the zip file entries
1083      * excluding internal JAR mechanism entries and including
1084      * signed entries missing from the ZIP directory.
1085      */
1086     Enumeration&lt;JarEntry&gt; entries2() {
1087         ensureInitialization();
1088         if (jv != null) {
1089             return jv.entries2(this, JUZFA.entries(JarFile.this));
1090         }
1091 
1092         // screen out entries which are never signed
1093         final var unfilteredEntries = JUZFA.entries(JarFile.this);
1094 
1095         return new Enumeration&lt;&gt;() {
1096 
1097             JarEntry entry;
1098 
1099             public boolean hasMoreElements() {
1100                 if (entry != null) {
1101                     return true;
1102                 }
1103                 while (unfilteredEntries.hasMoreElements()) {
1104                     JarEntry je = unfilteredEntries.nextElement();
1105                     if (JarVerifier.isSigningRelated(je.getName())) {
1106                         continue;
1107                     }
1108                     entry = je;
1109                     return true;
1110                 }
1111                 return false;
1112             }
1113 
1114             public JarEntry nextElement() {
1115                 if (hasMoreElements()) {
1116                     JarEntry je = entry;
1117                     entry = null;
1118                     return newEntry(je);
1119                 }
1120                 throw new NoSuchElementException();
1121             }
1122         };
1123     }
1124 
1125     CodeSource[] getCodeSources(URL url) {
1126         ensureInitialization();
1127         if (jv != null) {
1128             return jv.getCodeSources(this, url);
1129         }
1130 
1131         /*
1132          * JAR file has no signed content. Is there a non-signing
1133          * code source?
1134          */
1135         Enumeration&lt;String&gt; unsigned = unsignedEntryNames();
1136         if (unsigned.hasMoreElements()) {
1137             return new CodeSource[]{JarVerifier.getUnsignedCS(url)};
1138         } else {
1139             return null;
1140         }
1141     }
1142 
1143     private Enumeration&lt;String&gt; unsignedEntryNames() {
1144         final Enumeration&lt;JarEntry&gt; entries = entries();
1145         return new Enumeration&lt;&gt;() {
1146 
1147             String name;
1148 
1149             /*
1150              * Grab entries from ZIP directory but screen out
1151              * metadata.
1152              */
1153             public boolean hasMoreElements() {
1154                 if (name != null) {
1155                     return true;
1156                 }
1157                 while (entries.hasMoreElements()) {
1158                     String value;
1159                     ZipEntry e = entries.nextElement();
1160                     value = e.getName();
1161                     if (e.isDirectory() || JarVerifier.isSigningRelated(value)) {
1162                         continue;
1163                     }
1164                     name = value;
1165                     return true;
1166                 }
1167                 return false;
1168             }
1169 
1170             public String nextElement() {
1171                 if (hasMoreElements()) {
1172                     String value = name;
1173                     name = null;
1174                     return value;
1175                 }
1176                 throw new NoSuchElementException();
1177             }
1178         };
1179     }
1180 
1181     CodeSource getCodeSource(URL url, String name) {
1182         ensureInitialization();
1183         if (jv != null) {
1184             if (jv.eagerValidation) {
1185                 CodeSource cs;
1186                 JarEntry je = getJarEntry(name);
1187                 if (je != null) {
1188                     cs = jv.getCodeSource(url, this, je);
1189                 } else {
1190                     cs = jv.getCodeSource(url, name);
1191                 }
1192                 return cs;
1193             } else {
1194                 return jv.getCodeSource(url, name);
1195             }
1196         }
1197 
1198         return JarVerifier.getUnsignedCS(url);
1199     }
1200 
1201     void setEagerValidation(boolean eager) {
1202         try {
1203             maybeInstantiateVerifier();
1204         } catch (IOException e) {
1205             throw new RuntimeException(e);
1206         }
1207         if (jv != null) {
1208             jv.setEagerValidation(eager);
1209         }
1210     }
1211 
1212     List&lt;Object&gt; getManifestDigests() {
1213         ensureInitialization();
1214         if (jv != null) {
1215             return jv.getManifestDigests();
1216         }
1217         return new ArrayList&lt;&gt;();
1218     }
1219 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.VM;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.Label;
  33 import jdk.internal.org.objectweb.asm.MethodVisitor;
  34 import jdk.internal.org.objectweb.asm.Opcodes;
  35 import sun.invoke.util.Wrapper;
  36 
  37 import java.lang.invoke.MethodHandles.Lookup;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.List;
  41 import java.util.Objects;
  42 import java.util.concurrent.ConcurrentHashMap;
  43 import java.util.concurrent.ConcurrentMap;
  44 import java.util.function.Function;
  45 
  46 import static java.lang.invoke.MethodHandles.lookup;
  47 import static java.lang.invoke.MethodType.methodType;
  48 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;
  49 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  50 
  51 /**
  52  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  53  * can be used to efficiently concatenate a known number of arguments of known
  54  * types, possibly after type adaptation and partial evaluation of arguments.
  55  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  56  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  57  * feature of the Java Programming Language.
  58  *
  59  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  60  * MethodHandle} proceeds in order through two phases:
  61  *
  62  * &lt;ol&gt;
  63  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  64  * They take as arguments a method type describing the concatenated arguments
  65  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  66  * constants that participate in the String concatenation. The details on
  67  * accepted recipe shapes are described further below. Linkage may involve
  68  * dynamically loading a new class that implements the expected concatenation
  69  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
  70  * exact concatenation method. The concatenation methods may be shared among
  71  * different {@code CallSite}s, e.g. if linkage methods produce them as pure
  72  * functions.&lt;/li&gt;
  73  *
  74  * &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when a generated concatenation method is
  75  * invoked with the exact dynamic arguments. This may occur many times for a
  76  * single concatenation method. The method referenced by the behavior {@code
  77  * MethodHandle} is invoked with the static arguments and any additional dynamic
  78  * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
  79  * &lt;/ol&gt;
  80  *
  81  * &lt;p&gt; This class provides two forms of linkage methods: a simple version
  82  * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
  83  * MethodType)}) using only the dynamic arguments, and an advanced version
  84  * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
  85  * String, MethodType, String, Object...)} using the advanced forms of capturing
  86  * the constant arguments. The advanced strategy can produce marginally better
  87  * invocation bytecode, at the expense of exploding the number of shapes of
  88  * string concatenation methods present at runtime, because those shapes would
  89  * include constant static arguments as well.
  90  *
  91  * @author Aleksey Shipilev
  92  * @author Remi Forax
  93  * @author Peter Levart
  94  *
  95  * @apiNote
  96  * &lt;p&gt;There is a JVM limit (classfile structural constraint): no method
  97  * can call with more than 255 slots. This limits the number of static and
  98  * dynamic arguments one can pass to bootstrap method. Since there are potential
  99  * concatenation strategies that use {@code MethodHandle} combinators, we need
 100  * to reserve a few empty slots on the parameter lists to capture the
 101  * temporal results. This is why bootstrap methods in this factory do not accept
 102  * more than 200 argument slots. Users requiring more than 200 argument slots in
 103  * concatenation are expected to split the large concatenation in smaller
 104  * expressions.
 105  *
 106  * @since 9
 107  */
 108 public final class StringConcatFactory {
 109 
 110     /**
 111      * Tag used to demarcate an ordinary argument.
 112      */
 113     private static final char TAG_ARG = &#39;\u0001&#39;;
 114 
 115     /**
 116      * Tag used to demarcate a constant.
 117      */
 118     private static final char TAG_CONST = &#39;\u0002&#39;;
 119 
 120     /**
 121      * Maximum number of argument slots in String Concat call.
 122      *
 123      * While the maximum number of argument slots that indy call can handle is 253,
 124      * we do not use all those slots, to let the strategies with MethodHandle
 125      * combinators to use some arguments.
 126      */
 127     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 128 
 129     /**
 130      * Concatenation strategy to use. See {@link Strategy} for possible options.
 131      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
<a name="1" id="anc1"></a>

 132      */
<a name="2" id="anc2"></a><span class="line-modified"> 133     private static Strategy STRATEGY;</span>
<span class="line-removed"> 134 </span>
<span class="line-removed"> 135     /**</span>
<span class="line-removed"> 136      * Default strategy to use for concatenation.</span>
<span class="line-removed"> 137      */</span>
<span class="line-removed"> 138     private static final Strategy DEFAULT_STRATEGY = Strategy.MH_INLINE_SIZED_EXACT;</span>
 139 
 140     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 141 
 142     private enum Strategy {
 143         /**
 144          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 145          */
 146         BC_SB,
 147 
 148         /**
 149          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 150          * but trying to estimate the required storage.
 151          */
 152         BC_SB_SIZED,
 153 
 154         /**
 155          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 156          * but computing the required storage exactly.
 157          */
 158         BC_SB_SIZED_EXACT,
 159 
 160         /**
 161          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 162          * This strategy also tries to estimate the required storage.
 163          */
 164         MH_SB_SIZED,
 165 
 166         /**
 167          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 168          * This strategy also estimate the required storage exactly.
 169          */
 170         MH_SB_SIZED_EXACT,
 171 
 172         /**
 173          * MethodHandle-based generator, that constructs its own byte[] array from
 174          * the arguments. It computes the required storage exactly.
 175          */
 176         MH_INLINE_SIZED_EXACT
 177     }
 178 
 179     /**
 180      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 181      * checks, etc.
 182      */
 183     private static final boolean DEBUG;
 184 
<a name="3" id="anc3"></a><span class="line-removed"> 185     /**</span>
<span class="line-removed"> 186      * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-removed"> 187      * code, at the expense of contaminating the profiles.</span>
<span class="line-removed"> 188      */</span>
<span class="line-removed"> 189     private static final boolean CACHE_ENABLE;</span>
<span class="line-removed"> 190 </span>
<span class="line-removed"> 191     private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-removed"> 192 </span>
<span class="line-removed"> 193     /**</span>
<span class="line-removed"> 194      * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-removed"> 195      */</span>
<span class="line-removed"> 196     private static final ProxyClassesDumper DUMPER;</span>
<span class="line-removed"> 197 </span>
 198     static {
<a name="4" id="anc4"></a><span class="line-removed"> 199         // In case we need to double-back onto the StringConcatFactory during this</span>
<span class="line-removed"> 200         // static initialization, make sure we have the reasonable defaults to complete</span>
<span class="line-removed"> 201         // the static initialization properly. After that, actual users would use</span>
<span class="line-removed"> 202         // the proper values we have read from the properties.</span>
<span class="line-removed"> 203         STRATEGY = DEFAULT_STRATEGY;</span>
<span class="line-removed"> 204         // CACHE_ENABLE = false; // implied</span>
<span class="line-removed"> 205         // CACHE = null;         // implied</span>
<span class="line-removed"> 206         // DEBUG = false;        // implied</span>
<span class="line-removed"> 207         // DUMPER = null;        // implied</span>
<span class="line-removed"> 208 </span>
 209         final String strategy =
 210                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 211         CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-modified"> 212                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
 213         DEBUG = Boolean.parseBoolean(
 214                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
<a name="6" id="anc6"></a><span class="line-removed"> 215         final String dumpPath =</span>
<span class="line-removed"> 216                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-removed"> 217 </span>
<span class="line-removed"> 218         STRATEGY = (strategy == null) ? DEFAULT_STRATEGY : Strategy.valueOf(strategy);</span>
<span class="line-removed"> 219         CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-removed"> 220         DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
 221     }
 222 
 223     /**
 224      * Cache key is a composite of:
 225      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 226      *   - method type, describing the dynamic arguments for concatenation
 227      *   - concat recipe, describing the constants and concat shape
 228      */
 229     private static final class Key {
 230         final String className;
 231         final MethodType mt;
 232         final Recipe recipe;
 233 
 234         public Key(String className, MethodType mt, Recipe recipe) {
 235             this.className = className;
 236             this.mt = mt;
 237             this.recipe = recipe;
 238         }
 239 
 240         @Override
 241         public boolean equals(Object o) {
 242             if (this == o) return true;
 243             if (o == null || getClass() != o.getClass()) return false;
 244 
 245             Key key = (Key) o;
 246 
 247             if (!className.equals(key.className)) return false;
 248             if (!mt.equals(key.mt)) return false;
 249             if (!recipe.equals(key.recipe)) return false;
 250             return true;
 251         }
 252 
 253         @Override
 254         public int hashCode() {
 255             int result = className.hashCode();
 256             result = 31 * result + mt.hashCode();
 257             result = 31 * result + recipe.hashCode();
 258             return result;
 259         }
 260     }
 261 
 262     /**
<a name="7" id="anc7"></a><span class="line-modified"> 263      * Parses the recipe string, and produces the traversable collection of</span>
 264      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 265      * strategies. Notably, this class parses out the constants from the recipe
 266      * and from other static arguments.
 267      */
 268     private static final class Recipe {
 269         private final List&lt;RecipeElement&gt; elements;
 270 
 271         public Recipe(String src, Object[] constants) {
 272             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 273 
 274             int constC = 0;
 275             int argC = 0;
 276 
 277             StringBuilder acc = new StringBuilder();
 278 
 279             for (int i = 0; i &lt; src.length(); i++) {
 280                 char c = src.charAt(i);
 281 
 282                 if (c == TAG_CONST || c == TAG_ARG) {
 283                     // Detected a special tag, flush all accumulated characters
 284                     // as a constant first:
 285                     if (acc.length() &gt; 0) {
 286                         el.add(new RecipeElement(acc.toString()));
 287                         acc.setLength(0);
 288                     }
 289                     if (c == TAG_CONST) {
 290                         Object cnst = constants[constC++];
 291                         el.add(new RecipeElement(cnst));
 292                     } else if (c == TAG_ARG) {
 293                         el.add(new RecipeElement(argC++));
 294                     }
 295                 } else {
 296                     // Not a special character, this is a constant embedded into
 297                     // the recipe itself.
 298                     acc.append(c);
 299                 }
 300             }
 301 
 302             // Flush the remaining characters as constant:
 303             if (acc.length() &gt; 0) {
 304                 el.add(new RecipeElement(acc.toString()));
 305             }
 306 
 307             elements = el;
 308         }
 309 
 310         public List&lt;RecipeElement&gt; getElements() {
 311             return elements;
 312         }
 313 
 314         @Override
 315         public boolean equals(Object o) {
 316             if (this == o) return true;
 317             if (o == null || getClass() != o.getClass()) return false;
 318 
 319             Recipe recipe = (Recipe) o;
 320             return elements.equals(recipe.elements);
 321         }
 322 
 323         @Override
 324         public String toString() {
 325             return &quot;Recipe{&quot; +
 326                     &quot;elements=&quot; + elements +
 327                     &#39;}&#39;;
 328         }
 329 
 330         @Override
 331         public int hashCode() {
 332             return elements.hashCode();
 333         }
 334     }
 335 
 336     private static final class RecipeElement {
 337         private final String value;
 338         private final int argPos;
 339         private final char tag;
 340 
 341         public RecipeElement(Object cnst) {
 342             this.value = String.valueOf(Objects.requireNonNull(cnst));
 343             this.argPos = -1;
 344             this.tag = TAG_CONST;
 345         }
 346 
 347         public RecipeElement(int arg) {
 348             this.value = null;
 349             this.argPos = arg;
 350             this.tag = TAG_ARG;
 351         }
 352 
 353         public String getValue() {
 354             assert (tag == TAG_CONST);
 355             return value;
 356         }
 357 
 358         public int getArgPos() {
 359             assert (tag == TAG_ARG);
 360             return argPos;
 361         }
 362 
 363         public char getTag() {
 364             return tag;
 365         }
 366 
 367         @Override
 368         public boolean equals(Object o) {
 369             if (this == o) return true;
 370             if (o == null || getClass() != o.getClass()) return false;
 371 
 372             RecipeElement that = (RecipeElement) o;
 373 
 374             if (this.tag != that.tag) return false;
 375             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;
 376             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;
 377             return true;
 378         }
 379 
 380         @Override
 381         public String toString() {
 382             return &quot;RecipeElement{&quot; +
 383                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +
 384                     &quot;, argPos=&quot; + argPos +
 385                     &quot;, tag=&quot; + tag +
 386                     &#39;}&#39;;
 387         }
 388 
 389         @Override
 390         public int hashCode() {
 391             return (int)tag;
 392         }
 393     }
 394 
 395     // StringConcatFactory bootstrap methods are startup sensitive, and may be
 396     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
 397     // methods are invoked with exact type information to avoid generating
 398     // code for runtime checks. Take care any changes or additions here are
 399     // reflected there as appropriate.
 400 
 401     /**
 402      * Facilitates the creation of optimized String concatenation methods, that
 403      * can be used to efficiently concatenate a known number of arguments of
 404      * known types, possibly after type adaptation and partial evaluation of
 405      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 406      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 407      * feature of the Java Programming Language.
 408      *
 409      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 410      * invoked, it returns the result of String concatenation, taking all
 411      * function arguments passed to the linkage method as inputs for
 412      * concatenation. The target signature is given by {@code concatType}.
 413      * For a target accepting:
 414      * &lt;ul&gt;
 415      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 416      *     &lt;li&gt;one input, concatenation results in the single
 417      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 418      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 419      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 420      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 421      *     and combined from left to right.&lt;/li&gt;
 422      * &lt;/ul&gt;
 423      *
 424      * &lt;p&gt;Assume the linkage arguments are as follows:
 425      *
 426      * &lt;ul&gt;
 427      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 428      * &lt;/ul&gt;
 429      *
 430      * &lt;p&gt;Then the following linkage invariants must hold:
 431      *
 432      * &lt;ul&gt;
 433      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 434      *         less than or equal to 200&lt;/li&gt;
 435      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 436      * &lt;/ul&gt;
 437      *
 438      * @param lookup   Represents a lookup context with the accessibility
 439      *                 privileges of the caller. Specifically, the lookup
 440      *                 context must have
 441      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 442      *                 full privilege access}.
 443      *                 When used with {@code invokedynamic}, this is stacked
 444      *                 automatically by the VM.
 445      * @param name     The name of the method to implement. This name is
 446      *                 arbitrary, and has no meaning for this linkage method.
 447      *                 When used with {@code invokedynamic}, this is provided by
 448      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 449      *                 structure and is stacked automatically by the VM.
 450      * @param concatType The expected signature of the {@code CallSite}.  The
 451      *                   parameter types represent the types of concatenation
 452      *                   arguments; the return type is always assignable from {@link
 453      *                   java.lang.String}.  When used with {@code invokedynamic},
 454      *                   this is provided by the {@code NameAndType} of the {@code
 455      *                   InvokeDynamic} structure and is stacked automatically by
 456      *                   the VM.
 457      * @return a CallSite whose target can be used to perform String
 458      * concatenation, with dynamic concatenation arguments described by the given
 459      * {@code concatType}.
 460      * @throws StringConcatException If any of the linkage invariants described
 461      *                               here are violated, or the lookup context
 462      *                               does not have private access privileges.
 463      * @throws NullPointerException If any of the incoming arguments is null.
 464      *                              This will never happen when a bootstrap method
 465      *                              is called with invokedynamic.
 466      *
 467      * @jls  5.1.11 String Conversion
 468      * @jls 15.18.1 String Concatenation Operator +
 469      */
 470     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 471                                       String name,
 472                                       MethodType concatType) throws StringConcatException {
 473         if (DEBUG) {
 474             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);
 475         }
 476 
 477         return doStringConcat(lookup, name, concatType, true, null);
 478     }
 479 
 480     /**
 481      * Facilitates the creation of optimized String concatenation methods, that
 482      * can be used to efficiently concatenate a known number of arguments of
 483      * known types, possibly after type adaptation and partial evaluation of
 484      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 485      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 486      * feature of the Java Programming Language.
 487      *
 488      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 489      * invoked, it returns the result of String concatenation, taking all
 490      * function arguments and constants passed to the linkage method as inputs for
 491      * concatenation. The target signature is given by {@code concatType}, and
 492      * does not include constants.
 493      * For a target accepting:
 494      * &lt;ul&gt;
 495      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 496      *     &lt;li&gt;one input, concatenation results in the single
 497      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 498      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 499      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 500      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 501      *     and combined from left to right.&lt;/li&gt;
 502      * &lt;/ul&gt;
 503      *
 504      * &lt;p&gt;The concatenation &lt;em&gt;recipe&lt;/em&gt; is a String description for the way to
 505      * construct a concatenated String from the arguments and constants. The
 506      * recipe is processed from left to right, and each character represents an
 507      * input to concatenation. Recipe characters mean:
 508      *
 509      * &lt;ul&gt;
 510      *
 511      *   &lt;li&gt;&lt;em&gt;\1 (Unicode point 0001)&lt;/em&gt;: an ordinary argument. This
 512      *   input is passed through dynamic argument, and is provided during the
 513      *   concatenation method invocation. This input can be null.&lt;/li&gt;
 514      *
 515      *   &lt;li&gt;&lt;em&gt;\2 (Unicode point 0002):&lt;/em&gt; a constant. This input passed
 516      *   through static bootstrap argument. This constant can be any value
 517      *   representable in constant pool. If necessary, the factory would call
 518      *   {@code toString} to perform a one-time String conversion.&lt;/li&gt;
 519      *
 520      *   &lt;li&gt;&lt;em&gt;Any other char value:&lt;/em&gt; a single character constant.&lt;/li&gt;
 521      * &lt;/ul&gt;
 522      *
 523      * &lt;p&gt;Assume the linkage arguments are as follows:
 524      *
 525      * &lt;ul&gt;
 526      *   &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 527      *   &lt;li&gt;{@code recipe}, describing the String recipe&lt;/li&gt;
 528      *   &lt;li&gt;{@code constants}, the vararg array of constants&lt;/li&gt;
 529      * &lt;/ul&gt;
 530      *
 531      * &lt;p&gt;Then the following linkage invariants must hold:
 532      *
 533      * &lt;ul&gt;
 534      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 535      *       or equal to 200&lt;/li&gt;
 536      *
 537      *   &lt;li&gt;The parameter count in {@code concatType} is equal to number of \1 tags
 538      *   in {@code recipe}&lt;/li&gt;
 539      *
 540      *   &lt;li&gt;The return type in {@code concatType} is assignable
 541      *   from {@link java.lang.String}, and matches the return type of the
 542      *   returned {@link MethodHandle}&lt;/li&gt;
 543      *
 544      *   &lt;li&gt;The number of elements in {@code constants} is equal to number of \2
 545      *   tags in {@code recipe}&lt;/li&gt;
 546      * &lt;/ul&gt;
 547      *
 548      * @param lookup    Represents a lookup context with the accessibility
 549      *                  privileges of the caller. Specifically, the lookup
 550      *                  context must have
 551      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 552      *                  full privilege access}.
 553      *                  When used with {@code invokedynamic}, this is stacked
 554      *                  automatically by the VM.
 555      * @param name      The name of the method to implement. This name is
 556      *                  arbitrary, and has no meaning for this linkage method.
 557      *                  When used with {@code invokedynamic}, this is provided
 558      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 559      *                  structure and is stacked automatically by the VM.
 560      * @param concatType The expected signature of the {@code CallSite}.  The
 561      *                  parameter types represent the types of dynamic concatenation
 562      *                  arguments; the return type is always assignable from {@link
 563      *                  java.lang.String}.  When used with {@code
 564      *                  invokedynamic}, this is provided by the {@code
 565      *                  NameAndType} of the {@code InvokeDynamic} structure and
 566      *                  is stacked automatically by the VM.
 567      * @param recipe    Concatenation recipe, described above.
 568      * @param constants A vararg parameter representing the constants passed to
 569      *                  the linkage method.
 570      * @return a CallSite whose target can be used to perform String
 571      * concatenation, with dynamic concatenation arguments described by the given
 572      * {@code concatType}.
 573      * @throws StringConcatException If any of the linkage invariants described
 574      *                               here are violated, or the lookup context
 575      *                               does not have private access privileges.
 576      * @throws NullPointerException If any of the incoming arguments is null, or
 577      *                              any constant in {@code recipe} is null.
 578      *                              This will never happen when a bootstrap method
 579      *                              is called with invokedynamic.
 580      * @apiNote Code generators have three distinct ways to process a constant
 581      * string operand S in a string concatenation expression.  First, S can be
 582      * materialized as a reference (using ldc) and passed as an ordinary argument
 583      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 584      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 585      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 586      * itself, causing its characters to be inserted into the result.
 587      *
 588      * @jls  5.1.11 String Conversion
 589      * @jls 15.18.1 String Concatenation Operator +
 590      */
 591     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 592                                                    String name,
 593                                                    MethodType concatType,
 594                                                    String recipe,
 595                                                    Object... constants) throws StringConcatException {
 596         if (DEBUG) {
 597             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));
 598         }
 599 
 600         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 601     }
 602 
 603     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 604                                            String name,
 605                                            MethodType concatType,
 606                                            boolean generateRecipe,
 607                                            String recipe,
 608                                            Object... constants) throws StringConcatException {
 609         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 610         Objects.requireNonNull(name, &quot;Name is null&quot;);
 611         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 612         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 613 
 614         for (Object o : constants) {
 615             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 616         }
 617 
 618         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 619             throw new StringConcatException(&quot;Invalid caller: &quot; +
 620                     lookup.lookupClass().getName());
 621         }
 622 
 623         int cCount = 0;
 624         int oCount = 0;
 625         if (generateRecipe) {
 626             // Mock the recipe to reuse the concat generator code
 627             char[] value = new char[concatType.parameterCount()];
 628             Arrays.fill(value, TAG_ARG);
 629             recipe = new String(value);
 630             oCount = concatType.parameterCount();
 631         } else {
 632             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);
 633 
 634             for (int i = 0; i &lt; recipe.length(); i++) {
 635                 char c = recipe.charAt(i);
 636                 if (c == TAG_CONST) cCount++;
 637                 if (c == TAG_ARG)   oCount++;
 638             }
 639         }
 640 
 641         if (oCount != concatType.parameterCount()) {
 642             throw new StringConcatException(
 643                     &quot;Mismatched number of concat arguments: recipe wants &quot; +
 644                             oCount +
 645                             &quot; arguments, but signature provides &quot; +
 646                             concatType.parameterCount());
 647         }
 648 
 649         if (cCount != constants.length) {
 650             throw new StringConcatException(
 651                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 652                             cCount +
 653                             &quot; constants, but only &quot; +
 654                             constants.length +
 655                             &quot; are passed&quot;);
 656         }
 657 
 658         if (!concatType.returnType().isAssignableFrom(String.class)) {
 659             throw new StringConcatException(
 660                     &quot;The return type should be compatible with String, but it is &quot; +
 661                             concatType.returnType());
 662         }
 663 
 664         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 665             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 666                     concatType.parameterSlotCount() +
 667                     &quot;, can only accept &quot; +
 668                     MAX_INDY_CONCAT_ARG_SLOTS);
 669         }
 670 
<a name="8" id="anc8"></a><span class="line-removed"> 671         String className = getClassName(lookup.lookupClass());</span>
 672         MethodType mt = adaptType(concatType);
 673         Recipe rec = new Recipe(recipe, constants);
<a name="9" id="anc9"></a><span class="line-modified"> 674 </span>
<span class="line-removed"> 675         MethodHandle mh;</span>
<span class="line-removed"> 676         if (CACHE_ENABLE) {</span>
<span class="line-removed"> 677             Key key = new Key(className, mt, rec);</span>
<span class="line-removed"> 678             mh = CACHE.get(key);</span>
<span class="line-removed"> 679             if (mh == null) {</span>
<span class="line-removed"> 680                 mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 681                 CACHE.put(key, mh);</span>
<span class="line-removed"> 682             }</span>
<span class="line-removed"> 683         } else {</span>
<span class="line-removed"> 684             mh = generate(lookup, className, mt, rec);</span>
<span class="line-removed"> 685         }</span>
 686         return new ConstantCallSite(mh.asType(concatType));
 687     }
 688 
 689     /**
 690      * Adapt method type to an API we are going to use.
 691      *
 692      * This strips the concrete classes from the signatures, thus preventing
 693      * class leakage when we cache the concatenation stubs.
 694      *
 695      * @param args actual argument types
 696      * @return argument types the strategy is going to use
 697      */
 698     private static MethodType adaptType(MethodType args) {
 699         Class&lt;?&gt;[] ptypes = null;
 700         for (int i = 0; i &lt; args.parameterCount(); i++) {
 701             Class&lt;?&gt; ptype = args.parameterType(i);
 702             if (!ptype.isPrimitive() &amp;&amp;
 703                     ptype != String.class &amp;&amp;
 704                     ptype != Object.class) { // truncate to Object
 705                 if (ptypes == null) {
 706                     ptypes = args.parameterArray();
 707                 }
 708                 ptypes[i] = Object.class;
 709             }
 710             // else other primitives or String or Object (unchanged)
 711         }
 712         return (ptypes != null)
 713                 ? MethodType.methodType(args.returnType(), ptypes)
 714                 : args;
 715     }
 716 
<a name="10" id="anc10"></a><span class="line-modified"> 717     private static String getClassName(Class&lt;?&gt; hostClass) throws StringConcatException {</span>
<span class="line-removed"> 718         /*</span>
<span class="line-removed"> 719           The generated class is in the same package as the host class as</span>
<span class="line-removed"> 720           it&#39;s the implementation of the string concatenation for the host class.</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722           When cache is enabled, we want to cache as much as we can.</span>
<span class="line-removed"> 723          */</span>
<span class="line-removed"> 724 </span>
<span class="line-removed"> 725         switch (STRATEGY) {</span>
<span class="line-removed"> 726             case BC_SB:</span>
<span class="line-removed"> 727             case BC_SB_SIZED:</span>
<span class="line-removed"> 728             case BC_SB_SIZED_EXACT: {</span>
<span class="line-removed"> 729                 if (CACHE_ENABLE) {</span>
<span class="line-removed"> 730                     String pkgName = hostClass.getPackageName();</span>
<span class="line-removed"> 731                     return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-removed"> 732                 } else {</span>
<span class="line-removed"> 733                     String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-removed"> 734                                                        : hostClass.getName();</span>
<span class="line-removed"> 735                     return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-removed"> 736                 }</span>
<span class="line-removed"> 737             }</span>
<span class="line-removed"> 738             case MH_SB_SIZED:</span>
<span class="line-removed"> 739             case MH_SB_SIZED_EXACT:</span>
<span class="line-removed"> 740             case MH_INLINE_SIZED_EXACT:</span>
<span class="line-removed"> 741                 // MethodHandle strategies do not need a class name.</span>
<span class="line-removed"> 742                 return &quot;&quot;;</span>
<span class="line-removed"> 743             default:</span>
<span class="line-removed"> 744                 throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);</span>
<span class="line-removed"> 745         }</span>
<span class="line-removed"> 746     }</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748     private static MethodHandle generate(Lookup lookup, String className, MethodType mt, Recipe recipe) throws StringConcatException {</span>
 749         try {
<a name="11" id="anc11"></a>


 750             switch (STRATEGY) {
 751                 case BC_SB:
<a name="12" id="anc12"></a><span class="line-modified"> 752                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.DEFAULT);</span>
 753                 case BC_SB_SIZED:
<a name="13" id="anc13"></a><span class="line-modified"> 754                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED);</span>
 755                 case BC_SB_SIZED_EXACT:
<a name="14" id="anc14"></a><span class="line-modified"> 756                     return BytecodeStringBuilderStrategy.generate(lookup, className, mt, recipe, Mode.SIZED_EXACT);</span>
 757                 case MH_SB_SIZED:
 758                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 759                 case MH_SB_SIZED_EXACT:
 760                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 761                 case MH_INLINE_SIZED_EXACT:
 762                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 763                 default:
 764                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 765             }
 766         } catch (Error | StringConcatException e) {
 767             // Pass through any error or existing StringConcatException
 768             throw e;
 769         } catch (Throwable t) {
 770             throw new StringConcatException(&quot;Generator failed&quot;, t);
 771         }
 772     }
 773 
 774     private enum Mode {
 775         DEFAULT(false, false),
 776         SIZED(true, false),
 777         SIZED_EXACT(true, true);
 778 
 779         private final boolean sized;
 780         private final boolean exact;
 781 
 782         Mode(boolean sized, boolean exact) {
 783             this.sized = sized;
 784             this.exact = exact;
 785         }
 786 
 787         boolean isSized() {
 788             return sized;
 789         }
 790 
 791         boolean isExact() {
 792             return exact;
 793         }
 794     }
 795 
 796     /**
 797      * Bytecode StringBuilder strategy.
 798      *
 799      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.
 800      *
 801      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;
 802      *
 803      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder
 804      * chain javac would otherwise emit. This strategy uses only the public API,
 805      * and comes as the baseline for the current JDK behavior. On other words,
 806      * this strategy moves the javac generated bytecode to runtime. The
 807      * generated bytecode is loaded via Lookup::defineClass, but with
 808      * the caller class coming from the BSM -- in other words, the protection
 809      * guarantees are inherited from the method where invokedynamic was
 810      * originally called. This means, among other things, that the bytecode is
 811      * verified for all non-JDK uses.
 812      *
 813      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but
 814      * sized&quot;.&lt;/b&gt;
 815      *
 816      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also
 817      * tries to guess the capacity required for StringBuilder to accept all
 818      * arguments without resizing. This strategy only makes an educated guess:
 819      * it only guesses the space required for known types (e.g. primitives and
 820      * Strings), but does not otherwise convert arguments. Therefore, the
 821      * capacity estimate may be wrong, and StringBuilder may have to
 822      * transparently resize or trim when doing the actual concatenation. While
 823      * this does not constitute a correctness issue (in the end, that what BC_SB
 824      * has to do anyway), this does pose a potential performance problem.
 825      *
 826      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 827      * sized exactly&quot;.&lt;/b&gt;
 828      *
 829      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 830      * converting all arguments to String in order to get the exact capacity
 831      * StringBuilder should have. The conversion is done via the public
 832      * String.valueOf and/or Object.toString methods, and does not touch any
 833      * private String API.
 834      */
 835     private static final class BytecodeStringBuilderStrategy {
 836         static final int CLASSFILE_VERSION = 52;
 837         static final String METHOD_NAME = &quot;concat&quot;;
 838 
<a name="15" id="anc15"></a>























 839         private BytecodeStringBuilderStrategy() {
 840             // no instantiation
 841         }
 842 
<a name="16" id="anc16"></a><span class="line-modified"> 843         private static MethodHandle generate(Lookup lookup, String className, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>










 844             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 845 
 846             cw.visit(CLASSFILE_VERSION,
 847                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 848                     className,
 849                     null,
 850                     &quot;java/lang/Object&quot;,
 851                     null
 852             );
 853 
 854             MethodVisitor mv = cw.visitMethod(
 855                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 856                     METHOD_NAME,
 857                     args.toMethodDescriptorString(),
 858                     null,
 859                     null);
 860 
 861             // use of @ForceInline no longer has any effect
 862             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 863             mv.visitCode();
 864 
 865             Class&lt;?&gt;[] arr = args.parameterArray();
 866             boolean[] guaranteedNonNull = new boolean[arr.length];
 867 
 868             if (mode.isExact()) {
 869                 /*
 870                     In exact mode, we need to convert all arguments to their String representations,
 871                     as this allows to compute their String sizes exactly. We cannot use private
 872                     methods for primitives in here, therefore we need to convert those as well.
 873 
 874                     We also record what arguments are guaranteed to be non-null as the result
 875                     of the conversion. String.valueOf does the null checks for us. The only
 876                     corner case to take care of is String.valueOf(Object) returning null itself.
 877 
 878                     Also, if any conversion happened, then the slot indices in the incoming
 879                     arguments are not equal to the final local maps. The only case this may break
 880                     is when converting 2-slot long/double argument to 1-slot String. Therefore,
 881                     we get away with tracking modified offset, since no conversion can overwrite
 882                     the upcoming the argument.
 883                  */
 884 
 885                 int off = 0;
 886                 int modOff = 0;
 887                 for (int c = 0; c &lt; arr.length; c++) {
 888                     Class&lt;?&gt; cl = arr[c];
 889                     if (cl == String.class) {
 890                         if (off != modOff) {
 891                             mv.visitIntInsn(getLoadOpcode(cl), off);
 892                             mv.visitIntInsn(ASTORE, modOff);
 893                         }
 894                     } else {
 895                         mv.visitIntInsn(getLoadOpcode(cl), off);
 896                         mv.visitMethodInsn(
 897                                 INVOKESTATIC,
 898                                 &quot;java/lang/String&quot;,
 899                                 &quot;valueOf&quot;,
 900                                 getStringValueOfDesc(cl),
 901                                 false
 902                         );
 903                         mv.visitIntInsn(ASTORE, modOff);
 904                         arr[c] = String.class;
 905                         guaranteedNonNull[c] = cl.isPrimitive();
 906                     }
 907                     off += getParameterSize(cl);
 908                     modOff += getParameterSize(String.class);
 909                 }
 910             }
 911 
 912             if (mode.isSized()) {
 913                 /*
 914                     When operating in sized mode (this includes exact mode), it makes sense to make
 915                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we
 916                     need to do null-checks early, not make the append chain shape simpler.
 917                  */
 918 
 919                 int off = 0;
 920                 for (RecipeElement el : recipe.getElements()) {
 921                     switch (el.getTag()) {
 922                         case TAG_CONST:
 923                             // Guaranteed non-null, no null check required.
 924                             break;
 925                         case TAG_ARG:
 926                             // Null-checks are needed only for String arguments, and when a previous stage
 927                             // did not do implicit null-checks. If a String is null, we eagerly replace it
 928                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call
 929                             // .length() on them down below.
 930                             int ac = el.getArgPos();
 931                             Class&lt;?&gt; cl = arr[ac];
 932                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {
 933                                 Label l0 = new Label();
 934                                 mv.visitIntInsn(ALOAD, off);
 935                                 mv.visitJumpInsn(IFNONNULL, l0);
 936                                 mv.visitLdcInsn(&quot;null&quot;);
 937                                 mv.visitIntInsn(ASTORE, off);
 938                                 mv.visitLabel(l0);
 939                             }
 940                             off += getParameterSize(cl);
 941                             break;
 942                         default:
 943                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 944                     }
 945                 }
 946             }
 947 
 948             // Prepare StringBuilder instance
 949             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);
 950             mv.visitInsn(DUP);
 951 
 952             if (mode.isSized()) {
 953                 /*
 954                     Sized mode requires us to walk through the arguments, and estimate the final length.
 955                     In exact mode, this will operate on Strings only. This code would accumulate the
 956                     final length on stack.
 957                  */
 958                 int len = 0;
 959                 int off = 0;
 960 
 961                 mv.visitInsn(ICONST_0);
 962 
 963                 for (RecipeElement el : recipe.getElements()) {
 964                     switch (el.getTag()) {
 965                         case TAG_CONST:
 966                             len += el.getValue().length();
 967                             break;
 968                         case TAG_ARG:
 969                             /*
 970                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have
 971                                 converted arguments for us. If an argument is primitive, we can provide a guess
 972                                 for its String representation size.
 973                             */
 974                             Class&lt;?&gt; cl = arr[el.getArgPos()];
 975                             if (cl == String.class) {
 976                                 mv.visitIntInsn(ALOAD, off);
 977                                 mv.visitMethodInsn(
 978                                         INVOKEVIRTUAL,
 979                                         &quot;java/lang/String&quot;,
 980                                         &quot;length&quot;,
 981                                         &quot;()I&quot;,
 982                                         false
 983                                 );
 984                                 mv.visitInsn(IADD);
 985                             } else if (cl.isPrimitive()) {
 986                                 len += estimateSize(cl);
 987                             }
 988                             off += getParameterSize(cl);
 989                             break;
 990                         default:
 991                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 992                     }
 993                 }
 994 
 995                 // Constants have non-zero length, mix in
 996                 if (len &gt; 0) {
 997                     iconst(mv, len);
 998                     mv.visitInsn(IADD);
 999                 }
1000 
1001                 mv.visitMethodInsn(
1002                         INVOKESPECIAL,
1003                         &quot;java/lang/StringBuilder&quot;,
1004                         &quot;&lt;init&gt;&quot;,
1005                         &quot;(I)V&quot;,
1006                         false
1007                 );
1008             } else {
1009                 mv.visitMethodInsn(
1010                         INVOKESPECIAL,
1011                         &quot;java/lang/StringBuilder&quot;,
1012                         &quot;&lt;init&gt;&quot;,
1013                         &quot;()V&quot;,
1014                         false
1015                 );
1016             }
1017 
1018             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.
1019             {
1020                 int off = 0;
1021                 for (RecipeElement el : recipe.getElements()) {
1022                     String desc;
1023                     switch (el.getTag()) {
1024                         case TAG_CONST:
1025                             mv.visitLdcInsn(el.getValue());
1026                             desc = getSBAppendDesc(String.class);
1027                             break;
1028                         case TAG_ARG:
1029                             Class&lt;?&gt; cl = arr[el.getArgPos()];
1030                             mv.visitVarInsn(getLoadOpcode(cl), off);
1031                             off += getParameterSize(cl);
1032                             desc = getSBAppendDesc(cl);
1033                             break;
1034                         default:
1035                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1036                     }
1037 
1038                     mv.visitMethodInsn(
1039                             INVOKEVIRTUAL,
1040                             &quot;java/lang/StringBuilder&quot;,
1041                             &quot;append&quot;,
1042                             desc,
1043                             false
1044                     );
1045                 }
1046             }
1047 
1048             if (DEBUG &amp;&amp; mode.isExact()) {
1049                 /*
1050                     Exactness checks compare the final StringBuilder.capacity() with a resulting
1051                     String.length(). If these values disagree, that means StringBuilder had to perform
1052                     storage trimming, which defeats the purpose of exact strategies.
1053                  */
1054 
1055                 /*
1056                    The logic for this check is as follows:
1057 
1058                      Stack before:     Op:
1059                       (SB)              dup, dup
1060                       (SB, SB, SB)      capacity()
1061                       (int, SB, SB)     swap
1062                       (SB, int, SB)     toString()
1063                       (S, int, SB)      length()
1064                       (int, int, SB)    if_icmpeq
1065                       (SB)              &lt;end&gt;
1066 
1067                    Note that it leaves the same StringBuilder on exit, like the one on enter.
1068                  */
1069 
1070                 mv.visitInsn(DUP);
1071                 mv.visitInsn(DUP);
1072 
1073                 mv.visitMethodInsn(
1074                         INVOKEVIRTUAL,
1075                         &quot;java/lang/StringBuilder&quot;,
1076                         &quot;capacity&quot;,
1077                         &quot;()I&quot;,
1078                         false
1079                 );
1080 
1081                 mv.visitInsn(SWAP);
1082 
1083                 mv.visitMethodInsn(
1084                         INVOKEVIRTUAL,
1085                         &quot;java/lang/StringBuilder&quot;,
1086                         &quot;toString&quot;,
1087                         &quot;()Ljava/lang/String;&quot;,
1088                         false
1089                 );
1090 
1091                 mv.visitMethodInsn(
1092                         INVOKEVIRTUAL,
1093                         &quot;java/lang/String&quot;,
1094                         &quot;length&quot;,
1095                         &quot;()I&quot;,
1096                         false
1097                 );
1098 
1099                 Label l0 = new Label();
1100                 mv.visitJumpInsn(IF_ICMPEQ, l0);
1101 
1102                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);
1103                 mv.visitInsn(DUP);
1104                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);
1105                 mv.visitMethodInsn(INVOKESPECIAL,
1106                         &quot;java/lang/AssertionError&quot;,
1107                         &quot;&lt;init&gt;&quot;,
1108                         &quot;(Ljava/lang/Object;)V&quot;,
1109                         false);
1110                 mv.visitInsn(ATHROW);
1111 
1112                 mv.visitLabel(l0);
1113             }
1114 
1115             mv.visitMethodInsn(
1116                     INVOKEVIRTUAL,
1117                     &quot;java/lang/StringBuilder&quot;,
1118                     &quot;toString&quot;,
1119                     &quot;()Ljava/lang/String;&quot;,
1120                     false
1121             );
1122 
1123             mv.visitInsn(ARETURN);
1124 
1125             mv.visitMaxs(-1, -1);
1126             mv.visitEnd();
1127             cw.visitEnd();
1128 
1129             byte[] classBytes = cw.toByteArray();
1130             try {
1131                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1132                 dumpIfEnabled(className, classBytes);
<a name="17" id="anc17"></a><span class="line-modified">1133                 return lookup.findStatic(innerClass, METHOD_NAME, args);</span>




1134             } catch (Exception e) {
1135                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1136                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1137             }
1138         }
1139 
<a name="18" id="anc18"></a>

















1140         private static void dumpIfEnabled(String name, byte[] bytes) {
1141             if (DUMPER != null) {
1142                 DUMPER.dumpClass(name, bytes);
1143             }
1144         }
1145 
1146         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1147             if (cl.isPrimitive()) {
1148                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1149                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1150                 } else if (cl == Boolean.TYPE) {
1151                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1152                 } else if (cl == Character.TYPE) {
1153                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1154                 } else if (cl == Double.TYPE) {
1155                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1156                 } else if (cl == Float.TYPE) {
1157                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1158                 } else if (cl == Long.TYPE) {
1159                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
1160                 } else {
1161                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);
1162                 }
1163             } else if (cl == String.class) {
1164                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;
1165             } else {
1166                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;
1167             }
1168         }
1169 
1170         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {
1171             if (cl.isPrimitive()) {
1172                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1173                     return &quot;(I)Ljava/lang/String;&quot;;
1174                 } else if (cl == Boolean.TYPE) {
1175                     return &quot;(Z)Ljava/lang/String;&quot;;
1176                 } else if (cl == Character.TYPE) {
1177                     return &quot;(C)Ljava/lang/String;&quot;;
1178                 } else if (cl == Double.TYPE) {
1179                     return &quot;(D)Ljava/lang/String;&quot;;
1180                 } else if (cl == Float.TYPE) {
1181                     return &quot;(F)Ljava/lang/String;&quot;;
1182                 } else if (cl == Long.TYPE) {
1183                     return &quot;(J)Ljava/lang/String;&quot;;
1184                 } else {
1185                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);
1186                 }
1187             } else if (cl == String.class) {
1188                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;
1189             } else {
1190                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;
1191             }
1192         }
1193 
1194         /**
1195          * The following method is copied from
1196          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small
1197          * and fast Java bytecode manipulation framework.
1198          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.
1199          */
1200         private static void iconst(MethodVisitor mv, final int cst) {
1201             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
1202                 mv.visitInsn(Opcodes.ICONST_0 + cst);
1203             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
1204                 mv.visitIntInsn(Opcodes.BIPUSH, cst);
1205             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
1206                 mv.visitIntInsn(Opcodes.SIPUSH, cst);
1207             } else {
1208                 mv.visitLdcInsn(cst);
1209             }
1210         }
1211 
1212         private static int getLoadOpcode(Class&lt;?&gt; c) {
1213             if (c == Void.TYPE) {
1214                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);
1215             }
1216             return ILOAD + getOpcodeOffset(c);
1217         }
1218 
1219         private static int getOpcodeOffset(Class&lt;?&gt; c) {
1220             if (c.isPrimitive()) {
1221                 if (c == Long.TYPE) {
1222                     return 1;
1223                 } else if (c == Float.TYPE) {
1224                     return 2;
1225                 } else if (c == Double.TYPE) {
1226                     return 3;
1227                 }
1228                 return 0;
1229             } else {
1230                 return 4;
1231             }
1232         }
1233 
1234         private static int getParameterSize(Class&lt;?&gt; c) {
1235             if (c == Void.TYPE) {
1236                 return 0;
1237             } else if (c == Long.TYPE || c == Double.TYPE) {
1238                 return 2;
1239             }
1240             return 1;
1241         }
1242     }
1243 
1244     /**
1245      * MethodHandle StringBuilder strategy.
1246      *
1247      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.
1248      *
1249      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,
1250      * sized&quot;.&lt;/b&gt;
1251      *
1252      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the
1253      * computation on MethodHandle combinators. The computation is built with
1254      * public MethodHandle APIs, resolved from a public Lookup sequence, and
1255      * ends up calling the public StringBuilder API. Therefore, this strategy
1256      * does not use any private API at all since everything is handled under
1257      * cover by java.lang.invoke APIs.
1258      *
1259      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,
1260      * sized exactly&quot;.&lt;/b&gt;
1261      *
1262      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first
1263      * converting all arguments to String in order to get the exact capacity
1264      * StringBuilder should have. The conversion is done via the public
1265      * String.valueOf and/or Object.toString methods, and does not touch any
1266      * private String API.
1267      */
1268     private static final class MethodHandleStringBuilderStrategy {
1269         private MethodHandleStringBuilderStrategy() {
1270             // no instantiation
1271         }
1272 
1273         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {
1274             int pc = mt.parameterCount();
1275 
1276             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1277             MethodHandle[] filters = new MethodHandle[ptypes.length];
1278             for (int i = 0; i &lt; ptypes.length; i++) {
1279                 MethodHandle filter;
1280                 switch (mode) {
1281                     case SIZED:
1282                         // In sized mode, we convert all references and floats/doubles
1283                         // to String: there is no specialization for different
1284                         // classes in StringBuilder API, and it will convert to
1285                         // String internally anyhow.
1286                         filter = Stringifiers.forMost(ptypes[i]);
1287                         break;
1288                     case SIZED_EXACT:
1289                         // In exact mode, we convert everything to String:
1290                         // this helps to compute the storage exactly.
1291                         filter = Stringifiers.forAny(ptypes[i]);
1292                         break;
1293                     default:
1294                         throw new StringConcatException(&quot;Not supported&quot;);
1295                 }
1296                 if (filter != null) {
1297                     filters[i] = filter;
1298                     ptypes[i] = filter.type().returnType();
1299                 }
1300             }
1301 
1302             MethodHandle[] lengthers = new MethodHandle[pc];
1303 
1304             // Figure out lengths: constants&#39; lengths can be deduced on the spot.
1305             // All reference arguments were filtered to String in the combinators below, so we can
1306             // call the usual String.length(). Primitive values string sizes can be estimated.
1307             int initial = 0;
1308             for (RecipeElement el : recipe.getElements()) {
1309                 switch (el.getTag()) {
1310                     case TAG_CONST:
1311                         initial += el.getValue().length();
1312                         break;
1313                     case TAG_ARG:
1314                         final int i = el.getArgPos();
1315                         Class&lt;?&gt; type = ptypes[i];
1316                         if (type.isPrimitive()) {
1317                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));
1318                             est = MethodHandles.dropArguments(est, 0, type);
1319                             lengthers[i] = est;
1320                         } else {
1321                             lengthers[i] = STRING_LENGTH;
1322                         }
1323                         break;
1324                     default:
1325                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1326                 }
1327             }
1328 
1329             // Create (StringBuilder, &lt;args&gt;) shape for appending:
1330             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);
1331 
1332             // Compose append calls. This is done in reverse because the application order is
1333             // reverse as well.
1334             List&lt;RecipeElement&gt; elements = recipe.getElements();
1335             for (int i = elements.size() - 1; i &gt;= 0; i--) {
1336                 RecipeElement el = elements.get(i);
1337                 MethodHandle appender;
1338                 switch (el.getTag()) {
1339                     case TAG_CONST:
1340                         MethodHandle mh = appender(adaptToStringBuilder(String.class));
1341                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());
1342                         break;
1343                     case TAG_ARG:
1344                         int ac = el.getArgPos();
1345                         appender = appender(ptypes[ac]);
1346 
1347                         // Insert dummy arguments to match the prefix in the signature.
1348                         // The actual appender argument will be the ac-ith argument.
1349                         if (ac != 0) {
1350                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));
1351                         }
1352                         break;
1353                     default:
1354                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1355                 }
1356                 builder = MethodHandles.foldArguments(builder, appender);
1357             }
1358 
1359             // Build the sub-tree that adds the sizes and produces a StringBuilder:
1360 
1361             // a) Start with the reducer that accepts all arguments, plus one
1362             //    slot for the initial value. Inject the initial value right away.
1363             //    This produces (&lt;ints&gt;)int shape:
1364             MethodHandle sum = getReducerFor(pc + 1);
1365             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);
1366 
1367             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int
1368             adder = MethodHandles.filterArguments(adder, 0, lengthers);
1369 
1370             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder
1371             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);
1372 
1373             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder
1374             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);
1375 
1376             // Convert non-primitive arguments to Strings
1377             mh = MethodHandles.filterArguments(mh, 0, filters);
1378 
1379             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String
1380             if (DEBUG &amp;&amp; mode.isExact()) {
1381                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);
1382             } else {
1383                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);
1384             }
1385 
1386             return mh;
1387         }
1388 
1389         private static MethodHandle getReducerFor(int cnt) {
1390             return SUMMERS.computeIfAbsent(cnt, SUMMER);
1391         }
1392 
1393         private static MethodHandle appender(Class&lt;?&gt; appendType) {
1394             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,
1395                     StringBuilder.class, adaptToStringBuilder(appendType));
1396 
1397             // appenders should return void, this would not modify the target signature during folding
1398             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);
1399             return appender.asType(nt);
1400         }
1401 
1402         private static String toStringChecked(StringBuilder sb) {
1403             String s = sb.toString();
1404             if (s.length() != sb.capacity()) {
1405                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());
1406             }
1407             return s;
1408         }
1409 
1410         private static int sum(int v1, int v2) {
1411             return v1 + v2;
1412         }
1413 
1414         private static int sum(int v1, int v2, int v3) {
1415             return v1 + v2 + v3;
1416         }
1417 
1418         private static int sum(int v1, int v2, int v3, int v4) {
1419             return v1 + v2 + v3 + v4;
1420         }
1421 
1422         private static int sum(int v1, int v2, int v3, int v4, int v5) {
1423             return v1 + v2 + v3 + v4 + v5;
1424         }
1425 
1426         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {
1427             return v1 + v2 + v3 + v4 + v5 + v6;
1428         }
1429 
1430         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {
1431             return v1 + v2 + v3 + v4 + v5 + v6 + v7;
1432         }
1433 
1434         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {
1435             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;
1436         }
1437 
1438         private static int sum(int initial, int[] vs) {
1439             int sum = initial;
1440             for (int v : vs) {
1441                 sum += v;
1442             }
1443             return sum;
1444         }
1445 
1446         private static final Lookup MHSBS_LOOKUP = lookup();
1447 
1448         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;
1449 
1450         // This one is deliberately non-lambdified to optimize startup time:
1451         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {
1452             @Override
1453             public MethodHandle apply(Integer cnt) {
1454                 if (cnt == 1) {
1455                     return MethodHandles.identity(int.class);
1456                 } else if (cnt &lt;= 8) {
1457                     // Variable-arity collectors are not as efficient as small-count methods,
1458                     // unroll some initial sizes.
1459                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];
1460                     Arrays.fill(cls, int.class);
1461                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);
1462                 } else {
1463                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)
1464                             .asCollector(int[].class, cnt - 1);
1465                 }
1466             }
1467         };
1468 
1469         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;
1470 
1471         static {
1472             SUMMERS = new ConcurrentHashMap&lt;&gt;();
1473             Lookup publicLookup = MethodHandles.publicLookup();
1474             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);
1475             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);
1476             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);
1477             if (DEBUG) {
1478                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,
1479                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);
1480             } else {
1481                 BUILDER_TO_STRING_CHECKED = null;
1482             }
1483         }
1484 
1485     }
1486 
1487 
1488     /**
1489      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,
1490      * sized exactly&quot;.&lt;/b&gt;
1491      *
1492      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
1493      * byte[] array on its own and passes that byte[] array to String
1494      * constructor. This strategy requires access to some private APIs in JDK,
1495      * most notably, the read-only Integer/Long.stringSize methods that measure
1496      * the character length of the integers, and the private String constructor
1497      * that accepts byte[] arrays without copying. While this strategy assumes a
1498      * particular implementation details for String, this opens the door for
1499      * building a very optimal concatenation sequence. This is the only strategy
1500      * that requires porting if there are private JDK changes occur.
1501      */
1502     private static final class MethodHandleInlineCopyStrategy {
1503         private MethodHandleInlineCopyStrategy() {
1504             // no instantiation
1505         }
1506 
1507         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1508 
1509             // Fast-path two-argument Object + Object concatenations
1510             if (recipe.getElements().size() == 2) {
1511                 // Two object arguments
1512                 if (mt.parameterCount() == 2 &amp;&amp;
1513                     !mt.parameterType(0).isPrimitive() &amp;&amp;
1514                     !mt.parameterType(1).isPrimitive() &amp;&amp;
1515                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;
1516                     recipe.getElements().get(1).getTag() == TAG_ARG) {
1517 
1518                     return SIMPLE;
1519 
1520                 } else if (mt.parameterCount() == 1 &amp;&amp;
1521                            !mt.parameterType(0).isPrimitive()) {
1522                     // One Object argument, one constant
1523                     MethodHandle mh = SIMPLE;
1524 
1525                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;
1526                         recipe.getElements().get(1).getTag() == TAG_ARG) {
1527                         // First recipe element is a constant
1528                         return MethodHandles.insertArguments(mh, 0,
1529                                 recipe.getElements().get(0).getValue());
1530 
1531                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;
1532                                recipe.getElements().get(0).getTag() == TAG_ARG) {
1533                         // Second recipe element is a constant
1534                         return MethodHandles.insertArguments(mh, 1,
1535                                 recipe.getElements().get(1).getValue());
1536 
1537                     }
1538                 }
1539                 // else... fall-through to slow-path
1540             }
1541 
1542             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1543             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
1544             // The filtered argument type list is used all over in the combinators below.
1545             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1546             MethodHandle[] filters = null;
1547             for (int i = 0; i &lt; ptypes.length; i++) {
1548                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1549                 if (filter != null) {
1550                     if (filters == null) {
1551                         filters = new MethodHandle[ptypes.length];
1552                     }
1553                     filters[i] = filter;
1554                     ptypes[i] = filter.type().returnType();
1555                 }
1556             }
1557 
1558             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1559             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1560             // assembled bottom-up, which makes the code arguably hard to read.
1561 
1562             // Drop all remaining parameter types, leave only helper arguments:
1563             MethodHandle mh;
1564 
1565             mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
1566 
1567             long initialLengthCoder = INITIAL_CODER;
1568 
1569             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1570             // known from the combinators below. We are assembling the string backwards, so the index coded
1571             // into indexCoder is the *ending* index.
1572 
1573             // We need one prepender per argument, but also need to fold in constants. We do so by greedily
1574             // create prependers that fold in surrounding constants into the argument prepender. This reduces
1575             // the number of unique MH combinator tree shapes we&#39;ll create in an application.
1576             String prefixConstant = null, suffixConstant = null;
1577             int pos = -1;
1578             for (RecipeElement el : recipe.getElements()) {
1579                 // Do the prepend, and put &quot;new&quot; index at index 1
1580                 switch (el.getTag()) {
1581                     case TAG_CONST: {
1582                         String constantValue = el.getValue();
1583 
1584                         // Eagerly update the initialLengthCoder value
1585                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);
1586 
1587                         if (pos &lt; 0) {
1588                             // Collecting into prefixConstant
1589                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;
1590                         } else {
1591                             // Collecting into suffixConstant
1592                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;
1593                         }
1594                         break;
1595                     }
1596                     case TAG_ARG: {
1597 
1598                         if (pos &gt;= 0) {
1599                             // Flush the previous non-constant arg with any prefix/suffix constant
1600                             mh = MethodHandles.filterArgumentsWithCombiner(
1601                                 mh, 1,
1602                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
1603                                 1, 0, // indexCoder, storage
1604                                 2 + pos  // selected argument
1605                             );
1606                             prefixConstant = suffixConstant = null;
1607                         }
1608                         // Mark the pos of next non-constant arg
1609                         pos = el.getArgPos();
1610                         break;
1611                     }
1612                     default:
1613                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1614                 }
1615             }
1616 
1617             // Insert any trailing args, constants
1618             if (pos &gt;= 0) {
1619                 mh = MethodHandles.filterArgumentsWithCombiner(
1620                     mh, 1,
1621                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1622                     1, 0, // indexCoder, storage
1623                     2 + pos  // selected argument
1624                 );
1625             } else if (prefixConstant != null) {
1626                 assert (suffixConstant == null);
1627                 // Sole prefixConstant can only happen if there were no non-constant arguments
1628                 mh = MethodHandles.filterArgumentsWithCombiner(
1629                     mh, 1,
1630                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1631                     1, 0 // indexCoder, storage
1632                 );
1633             }
1634 
1635             // Fold in byte[] instantiation at argument 0
1636             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
1637                     1 // index
1638             );
1639 
1640             // Start combining length and coder mixers.
1641             //
1642             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1643             // shapes have been either converted to Strings, or explicit methods for getting the
1644             // string length out of primitives are provided.
1645             //
1646             // Coders are more interesting. Only Object, String and char arguments (and constants)
1647             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1648             // and deduce the coder from there. Arguments would be either converted to Strings
1649             // during the initial filtering, or handled by specializations in MIXERS.
1650             //
1651             // The method handle shape before all mixers are combined in is:
1652             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
1653             //
1654             // We will bind the initialLengthCoder value to the last mixer (the one that will be
1655             // executed first), then fold that in. This leaves the shape after all mixers are
1656             // combined in as:
1657             //   (&lt;args&gt;)String = (&lt;args&gt;)
1658 
1659             int ac = -1;
1660             MethodHandle mix = null;
1661             for (RecipeElement el : recipe.getElements()) {
1662                 switch (el.getTag()) {
1663                     case TAG_CONST:
1664                         // Constants already handled in the code above
1665                         break;
1666                     case TAG_ARG:
1667                         if (ac &gt;= 0) {
1668                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
1669                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
1670                                     0, // old-index
1671                                     1 + ac // selected argument
1672                             );
1673                         }
1674 
1675                         ac = el.getArgPos();
1676                         Class&lt;?&gt; argClass = ptypes[ac];
1677                         mix = mixer(argClass);
1678 
1679                         break;
1680                     default:
1681                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1682                 }
1683             }
1684 
1685             // Insert the initialLengthCoder value into the final mixer, then
1686             // fold that into the base method handle
1687             if (ac &gt;= 0) {
1688                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
1689                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
1690                         1 + ac // selected argument
1691                 );
1692             } else {
1693                 // No mixer (constants only concat), insert initialLengthCoder directly
1694                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1695             }
1696 
1697             // The method handle shape here is (&lt;args&gt;).
1698 
1699             // Apply filters, converting the arguments:
1700             if (filters != null) {
1701                 mh = MethodHandles.filterArguments(mh, 0, filters);
1702             }
1703 
1704             return mh;
1705         }
1706 
1707         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1708             return MethodHandles.insertArguments(
1709                     MethodHandles.insertArguments(
<a name="19" id="anc19"></a><span class="line-modified">1710                         PREPENDERS.computeIfAbsent(cl, PREPEND),2, prefix), 3, suffix);</span>
1711         }
1712 
1713         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1714             return MIXERS.computeIfAbsent(cl, MIX);
1715         }
1716 
1717         // This one is deliberately non-lambdified to optimize startup time:
1718         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1719             @Override
1720             public MethodHandle apply(Class&lt;?&gt; c) {
1721                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1722                             methodType(long.class, long.class, byte[].class,
1723                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1724             }
1725         };
1726 
1727         // This one is deliberately non-lambdified to optimize startup time:
1728         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1729             @Override
1730             public MethodHandle apply(Class&lt;?&gt; c) {
1731                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
1732             }
1733         };
1734 
1735         private static final MethodHandle SIMPLE;
1736         private static final MethodHandle NEW_STRING;
1737         private static final MethodHandle NEW_ARRAY;
1738         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1739         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1740         private static final long INITIAL_CODER;
1741 
1742         static {
1743             try {
1744                 MethodHandle initCoder = JLA.stringConcatHelper(&quot;initialCoder&quot;, methodType(long.class));
1745                 INITIAL_CODER = (long) initCoder.invoke();
1746             } catch (Throwable e) {
1747                 throw new AssertionError(e);
1748             }
1749 
1750             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1751             MIXERS = new ConcurrentHashMap&lt;&gt;();
1752 
1753             SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
1754             NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<a name="20" id="anc20"></a><span class="line-modified">1755             NEW_ARRAY  = JLA.stringConcatHelper( &quot;newArray&quot;, methodType(byte[].class, long.class));</span>
1756         }
1757     }
1758 
1759     /**
1760      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1761      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1762      */
1763     private static final class Stringifiers {
1764         private Stringifiers() {
1765             // no instantiation
1766         }
1767 
1768         private static final MethodHandle OBJECT_INSTANCE =
1769                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1770 
1771         private static class FloatStringifiers {
1772             private static final MethodHandle FLOAT_INSTANCE =
1773                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1774 
1775             private static final MethodHandle DOUBLE_INSTANCE =
1776                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
1777         }
1778 
1779         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {
1780 
1781             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();
1782 
1783             @Override
1784             protected MethodHandle computeValue(Class&lt;?&gt; cl) {
1785                 if (cl == byte.class || cl == short.class || cl == int.class) {
1786                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);
1787                 } else if (cl == boolean.class) {
1788                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);
1789                 } else if (cl == char.class) {
1790                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);
1791                 } else if (cl == long.class) {
1792                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);
1793                 } else {
1794                     MethodHandle mh = forMost(cl);
1795                     if (mh != null) {
1796                         return mh;
1797                     } else {
1798                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);
1799                     }
1800                 }
1801             }
1802         }
1803 
1804         /**
1805          * Returns a stringifier for references and floats/doubles only.
1806          * Always returns null for other primitives.
1807          *
1808          * @param t class to stringify
1809          * @return stringifier; null, if not available
1810          */
1811         static MethodHandle forMost(Class&lt;?&gt; t) {
1812             if (!t.isPrimitive()) {
1813                 return OBJECT_INSTANCE;
1814             } else if (t == float.class) {
1815                 return FloatStringifiers.FLOAT_INSTANCE;
1816             } else if (t == double.class) {
1817                 return FloatStringifiers.DOUBLE_INSTANCE;
1818             }
1819             return null;
1820         }
1821 
1822         /**
1823          * Returns a stringifier for any type. Never returns null.
1824          *
1825          * @param t class to stringify
1826          * @return stringifier
1827          */
1828         static MethodHandle forAny(Class&lt;?&gt; t) {
1829             return StringifierAny.INSTANCE.get(t);
1830         }
1831     }
1832 
1833     /* ------------------------------- Common utilities ------------------------------------ */
1834 
1835     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1836         try {
1837             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));
1838         } catch (NoSuchMethodException | IllegalAccessException e) {
1839             throw new AssertionError(e);
1840         }
1841     }
1842 
1843     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1844         try {
1845             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));
1846         } catch (NoSuchMethodException | IllegalAccessException e) {
1847             throw new AssertionError(e);
1848         }
1849     }
1850 
1851     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {
1852         try {
1853             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));
1854         } catch (NoSuchMethodException | IllegalAccessException e) {
1855             throw new AssertionError(e);
1856         }
1857     }
1858 
1859     static int estimateSize(Class&lt;?&gt; cl) {
1860         if (cl == Integer.TYPE) {
1861             return 11; // &quot;-2147483648&quot;
1862         } else if (cl == Boolean.TYPE) {
1863             return 5; // &quot;false&quot;
1864         } else if (cl == Byte.TYPE) {
1865             return 4; // &quot;-128&quot;
1866         } else if (cl == Character.TYPE) {
1867             return 1; // duh
1868         } else if (cl == Short.TYPE) {
1869             return 6; // &quot;-32768&quot;
1870         } else if (cl == Double.TYPE) {
1871             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1872         } else if (cl == Float.TYPE) {
1873             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1874         } else if (cl == Long.TYPE)  {
1875             return 20; // &quot;-9223372036854775808&quot;
1876         } else {
1877             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);
1878         }
1879     }
1880 
1881     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {
1882         if (c.isPrimitive()) {
1883             if (c == Byte.TYPE || c == Short.TYPE) {
1884                 return int.class;
1885             }
1886         } else {
1887             if (c != String.class) {
1888                 return Object.class;
1889             }
1890         }
1891         return c;
1892     }
1893 
1894     private StringConcatFactory() {
1895         // no instantiation
1896     }
1897 
1898 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
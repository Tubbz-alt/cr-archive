<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/StringConcatFactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
  30 import jdk.internal.misc.VM;
  31 import jdk.internal.org.objectweb.asm.ClassWriter;
  32 import jdk.internal.org.objectweb.asm.Label;
  33 import jdk.internal.org.objectweb.asm.MethodVisitor;
  34 import jdk.internal.org.objectweb.asm.Opcodes;
  35 import sun.invoke.util.Wrapper;
  36 
  37 import java.lang.invoke.MethodHandles.Lookup;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.List;
  41 import java.util.Objects;
  42 import java.util.concurrent.ConcurrentHashMap;
  43 import java.util.concurrent.ConcurrentMap;
  44 import java.util.function.Function;
  45 
  46 import static java.lang.invoke.MethodHandles.lookup;
  47 import static java.lang.invoke.MethodType.methodType;
  48 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;
  49 import static jdk.internal.org.objectweb.asm.Opcodes.*;
  50 
  51 /**
  52  * &lt;p&gt;Methods to facilitate the creation of String concatenation methods, that
  53  * can be used to efficiently concatenate a known number of arguments of known
  54  * types, possibly after type adaptation and partial evaluation of arguments.
  55  * These methods are typically used as &lt;em&gt;bootstrap methods&lt;/em&gt; for {@code
  56  * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
  57  * feature of the Java Programming Language.
  58  *
  59  * &lt;p&gt;Indirect access to the behavior specified by the provided {@code
  60  * MethodHandle} proceeds in order through two phases:
  61  *
  62  * &lt;ol&gt;
  63  *     &lt;li&gt;&lt;em&gt;Linkage&lt;/em&gt; occurs when the methods in this class are invoked.
  64  * They take as arguments a method type describing the concatenated arguments
  65  * count and types, and optionally the String &lt;em&gt;recipe&lt;/em&gt;, plus the
  66  * constants that participate in the String concatenation. The details on
  67  * accepted recipe shapes are described further below. Linkage may involve
  68  * dynamically loading a new class that implements the expected concatenation
  69  * behavior. The {@code CallSite} holds the {@code MethodHandle} pointing to the
  70  * exact concatenation method. The concatenation methods may be shared among
  71  * different {@code CallSite}s, e.g. if linkage methods produce them as pure
  72  * functions.&lt;/li&gt;
  73  *
  74  * &lt;li&gt;&lt;em&gt;Invocation&lt;/em&gt; occurs when a generated concatenation method is
  75  * invoked with the exact dynamic arguments. This may occur many times for a
  76  * single concatenation method. The method referenced by the behavior {@code
  77  * MethodHandle} is invoked with the static arguments and any additional dynamic
  78  * arguments provided on invocation, as if by {@link MethodHandle#invoke(Object...)}.&lt;/li&gt;
  79  * &lt;/ol&gt;
  80  *
  81  * &lt;p&gt; This class provides two forms of linkage methods: a simple version
  82  * ({@link #makeConcat(java.lang.invoke.MethodHandles.Lookup, String,
  83  * MethodType)}) using only the dynamic arguments, and an advanced version
  84  * ({@link #makeConcatWithConstants(java.lang.invoke.MethodHandles.Lookup,
  85  * String, MethodType, String, Object...)} using the advanced forms of capturing
  86  * the constant arguments. The advanced strategy can produce marginally better
  87  * invocation bytecode, at the expense of exploding the number of shapes of
  88  * string concatenation methods present at runtime, because those shapes would
  89  * include constant static arguments as well.
  90  *
  91  * @author Aleksey Shipilev
  92  * @author Remi Forax
  93  * @author Peter Levart
  94  *
  95  * @apiNote
  96  * &lt;p&gt;There is a JVM limit (classfile structural constraint): no method
  97  * can call with more than 255 slots. This limits the number of static and
  98  * dynamic arguments one can pass to bootstrap method. Since there are potential
  99  * concatenation strategies that use {@code MethodHandle} combinators, we need
 100  * to reserve a few empty slots on the parameter lists to capture the
 101  * temporal results. This is why bootstrap methods in this factory do not accept
 102  * more than 200 argument slots. Users requiring more than 200 argument slots in
 103  * concatenation are expected to split the large concatenation in smaller
 104  * expressions.
 105  *
 106  * @since 9
 107  */
 108 public final class StringConcatFactory {
 109 
 110     /**
 111      * Tag used to demarcate an ordinary argument.
 112      */
 113     private static final char TAG_ARG = &#39;\u0001&#39;;
 114 
 115     /**
 116      * Tag used to demarcate a constant.
 117      */
 118     private static final char TAG_CONST = &#39;\u0002&#39;;
 119 
 120     /**
 121      * Maximum number of argument slots in String Concat call.
 122      *
 123      * While the maximum number of argument slots that indy call can handle is 253,
 124      * we do not use all those slots, to let the strategies with MethodHandle
 125      * combinators to use some arguments.
 126      */
 127     private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;
 128 
 129     /**
 130      * Concatenation strategy to use. See {@link Strategy} for possible options.
 131      * This option is controllable with -Djava.lang.invoke.stringConcat JDK option.
<a name="1" id="anc1"></a><span class="line-added"> 132      *</span>
<span class="line-added"> 133      * Defaults to MH_INLINE_SIZED_EXACT if not set.</span>
 134      */
<a name="2" id="anc2"></a><span class="line-modified"> 135     private static final Strategy STRATEGY;</span>





 136 
 137     private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
 138 
 139     private enum Strategy {
 140         /**
 141          * Bytecode generator, calling into {@link java.lang.StringBuilder}.
 142          */
 143         BC_SB,
 144 
 145         /**
 146          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 147          * but trying to estimate the required storage.
 148          */
 149         BC_SB_SIZED,
 150 
 151         /**
 152          * Bytecode generator, calling into {@link java.lang.StringBuilder};
 153          * but computing the required storage exactly.
 154          */
 155         BC_SB_SIZED_EXACT,
 156 
 157         /**
 158          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 159          * This strategy also tries to estimate the required storage.
 160          */
 161         MH_SB_SIZED,
 162 
 163         /**
 164          * MethodHandle-based generator, that in the end calls into {@link java.lang.StringBuilder}.
 165          * This strategy also estimate the required storage exactly.
 166          */
 167         MH_SB_SIZED_EXACT,
 168 
 169         /**
 170          * MethodHandle-based generator, that constructs its own byte[] array from
 171          * the arguments. It computes the required storage exactly.
 172          */
 173         MH_INLINE_SIZED_EXACT
 174     }
 175 
 176     /**
 177      * Enables debugging: this may print debugging messages, perform additional (non-neutral for performance)
 178      * checks, etc.
 179      */
 180     private static final boolean DEBUG;
 181 
<a name="3" id="anc3"></a>












 182     static {
<a name="4" id="anc4"></a>









 183         final String strategy =
 184                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat&quot;);
<a name="5" id="anc5"></a><span class="line-modified"> 185         STRATEGY = (strategy == null) ? null : Strategy.valueOf(strategy);</span>
<span class="line-modified"> 186 </span>
 187         DEBUG = Boolean.parseBoolean(
 188                 VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.debug&quot;));
<a name="6" id="anc6"></a>





 189     }
 190 
 191     /**
 192      * Cache key is a composite of:
 193      *   - class name, that lets to disambiguate stubs, to avoid excess sharing
 194      *   - method type, describing the dynamic arguments for concatenation
 195      *   - concat recipe, describing the constants and concat shape
 196      */
 197     private static final class Key {
 198         final String className;
 199         final MethodType mt;
 200         final Recipe recipe;
 201 
 202         public Key(String className, MethodType mt, Recipe recipe) {
 203             this.className = className;
 204             this.mt = mt;
 205             this.recipe = recipe;
 206         }
 207 
 208         @Override
 209         public boolean equals(Object o) {
 210             if (this == o) return true;
 211             if (o == null || getClass() != o.getClass()) return false;
 212 
 213             Key key = (Key) o;
 214 
 215             if (!className.equals(key.className)) return false;
 216             if (!mt.equals(key.mt)) return false;
 217             if (!recipe.equals(key.recipe)) return false;
 218             return true;
 219         }
 220 
 221         @Override
 222         public int hashCode() {
 223             int result = className.hashCode();
 224             result = 31 * result + mt.hashCode();
 225             result = 31 * result + recipe.hashCode();
 226             return result;
 227         }
 228     }
 229 
 230     /**
<a name="7" id="anc7"></a><span class="line-modified"> 231      * Parses the recipe string, and produces a traversable collection of</span>
 232      * {@link java.lang.invoke.StringConcatFactory.RecipeElement}-s for generator
 233      * strategies. Notably, this class parses out the constants from the recipe
 234      * and from other static arguments.
 235      */
 236     private static final class Recipe {
 237         private final List&lt;RecipeElement&gt; elements;
 238 
 239         public Recipe(String src, Object[] constants) {
 240             List&lt;RecipeElement&gt; el = new ArrayList&lt;&gt;();
 241 
 242             int constC = 0;
 243             int argC = 0;
 244 
 245             StringBuilder acc = new StringBuilder();
 246 
 247             for (int i = 0; i &lt; src.length(); i++) {
 248                 char c = src.charAt(i);
 249 
 250                 if (c == TAG_CONST || c == TAG_ARG) {
 251                     // Detected a special tag, flush all accumulated characters
 252                     // as a constant first:
 253                     if (acc.length() &gt; 0) {
 254                         el.add(new RecipeElement(acc.toString()));
 255                         acc.setLength(0);
 256                     }
 257                     if (c == TAG_CONST) {
 258                         Object cnst = constants[constC++];
 259                         el.add(new RecipeElement(cnst));
 260                     } else if (c == TAG_ARG) {
 261                         el.add(new RecipeElement(argC++));
 262                     }
 263                 } else {
 264                     // Not a special character, this is a constant embedded into
 265                     // the recipe itself.
 266                     acc.append(c);
 267                 }
 268             }
 269 
 270             // Flush the remaining characters as constant:
 271             if (acc.length() &gt; 0) {
 272                 el.add(new RecipeElement(acc.toString()));
 273             }
 274 
 275             elements = el;
 276         }
 277 
 278         public List&lt;RecipeElement&gt; getElements() {
 279             return elements;
 280         }
 281 
 282         @Override
 283         public boolean equals(Object o) {
 284             if (this == o) return true;
 285             if (o == null || getClass() != o.getClass()) return false;
 286 
 287             Recipe recipe = (Recipe) o;
 288             return elements.equals(recipe.elements);
 289         }
 290 
 291         @Override
 292         public String toString() {
 293             return &quot;Recipe{&quot; +
 294                     &quot;elements=&quot; + elements +
 295                     &#39;}&#39;;
 296         }
 297 
 298         @Override
 299         public int hashCode() {
 300             return elements.hashCode();
 301         }
 302     }
 303 
 304     private static final class RecipeElement {
 305         private final String value;
 306         private final int argPos;
 307         private final char tag;
 308 
 309         public RecipeElement(Object cnst) {
 310             this.value = String.valueOf(Objects.requireNonNull(cnst));
 311             this.argPos = -1;
 312             this.tag = TAG_CONST;
 313         }
 314 
 315         public RecipeElement(int arg) {
 316             this.value = null;
 317             this.argPos = arg;
 318             this.tag = TAG_ARG;
 319         }
 320 
 321         public String getValue() {
 322             assert (tag == TAG_CONST);
 323             return value;
 324         }
 325 
 326         public int getArgPos() {
 327             assert (tag == TAG_ARG);
 328             return argPos;
 329         }
 330 
 331         public char getTag() {
 332             return tag;
 333         }
 334 
 335         @Override
 336         public boolean equals(Object o) {
 337             if (this == o) return true;
 338             if (o == null || getClass() != o.getClass()) return false;
 339 
 340             RecipeElement that = (RecipeElement) o;
 341 
 342             if (this.tag != that.tag) return false;
 343             if (this.tag == TAG_CONST &amp;&amp; (!value.equals(that.value))) return false;
 344             if (this.tag == TAG_ARG &amp;&amp; (argPos != that.argPos)) return false;
 345             return true;
 346         }
 347 
 348         @Override
 349         public String toString() {
 350             return &quot;RecipeElement{&quot; +
 351                     &quot;value=&#39;&quot; + value + &#39;\&#39;&#39; +
 352                     &quot;, argPos=&quot; + argPos +
 353                     &quot;, tag=&quot; + tag +
 354                     &#39;}&#39;;
 355         }
 356 
 357         @Override
 358         public int hashCode() {
 359             return (int)tag;
 360         }
 361     }
 362 
 363     // StringConcatFactory bootstrap methods are startup sensitive, and may be
 364     // special cased in java.lang.invokeBootstrapMethodInvoker to ensure
 365     // methods are invoked with exact type information to avoid generating
 366     // code for runtime checks. Take care any changes or additions here are
 367     // reflected there as appropriate.
 368 
 369     /**
 370      * Facilitates the creation of optimized String concatenation methods, that
 371      * can be used to efficiently concatenate a known number of arguments of
 372      * known types, possibly after type adaptation and partial evaluation of
 373      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 374      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 375      * feature of the Java Programming Language.
 376      *
 377      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 378      * invoked, it returns the result of String concatenation, taking all
 379      * function arguments passed to the linkage method as inputs for
 380      * concatenation. The target signature is given by {@code concatType}.
 381      * For a target accepting:
 382      * &lt;ul&gt;
 383      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 384      *     &lt;li&gt;one input, concatenation results in the single
 385      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 386      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 387      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 388      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 389      *     and combined from left to right.&lt;/li&gt;
 390      * &lt;/ul&gt;
 391      *
 392      * &lt;p&gt;Assume the linkage arguments are as follows:
 393      *
 394      * &lt;ul&gt;
 395      *     &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 396      * &lt;/ul&gt;
 397      *
 398      * &lt;p&gt;Then the following linkage invariants must hold:
 399      *
 400      * &lt;ul&gt;
 401      *     &lt;li&gt;The number of parameter slots in {@code concatType} is
 402      *         less than or equal to 200&lt;/li&gt;
 403      *     &lt;li&gt;The return type in {@code concatType} is assignable from {@link java.lang.String}&lt;/li&gt;
 404      * &lt;/ul&gt;
 405      *
 406      * @param lookup   Represents a lookup context with the accessibility
 407      *                 privileges of the caller. Specifically, the lookup
 408      *                 context must have
 409      *                 {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 410      *                 full privilege access}.
 411      *                 When used with {@code invokedynamic}, this is stacked
 412      *                 automatically by the VM.
 413      * @param name     The name of the method to implement. This name is
 414      *                 arbitrary, and has no meaning for this linkage method.
 415      *                 When used with {@code invokedynamic}, this is provided by
 416      *                 the {@code NameAndType} of the {@code InvokeDynamic}
 417      *                 structure and is stacked automatically by the VM.
 418      * @param concatType The expected signature of the {@code CallSite}.  The
 419      *                   parameter types represent the types of concatenation
 420      *                   arguments; the return type is always assignable from {@link
 421      *                   java.lang.String}.  When used with {@code invokedynamic},
 422      *                   this is provided by the {@code NameAndType} of the {@code
 423      *                   InvokeDynamic} structure and is stacked automatically by
 424      *                   the VM.
 425      * @return a CallSite whose target can be used to perform String
 426      * concatenation, with dynamic concatenation arguments described by the given
 427      * {@code concatType}.
 428      * @throws StringConcatException If any of the linkage invariants described
 429      *                               here are violated, or the lookup context
 430      *                               does not have private access privileges.
 431      * @throws NullPointerException If any of the incoming arguments is null.
 432      *                              This will never happen when a bootstrap method
 433      *                              is called with invokedynamic.
 434      *
 435      * @jls  5.1.11 String Conversion
 436      * @jls 15.18.1 String Concatenation Operator +
 437      */
 438     public static CallSite makeConcat(MethodHandles.Lookup lookup,
 439                                       String name,
 440                                       MethodType concatType) throws StringConcatException {
 441         if (DEBUG) {
 442             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType);
 443         }
 444 
 445         return doStringConcat(lookup, name, concatType, true, null);
 446     }
 447 
 448     /**
 449      * Facilitates the creation of optimized String concatenation methods, that
 450      * can be used to efficiently concatenate a known number of arguments of
 451      * known types, possibly after type adaptation and partial evaluation of
 452      * arguments. Typically used as a &lt;em&gt;bootstrap method&lt;/em&gt; for {@code
 453      * invokedynamic} call sites, to support the &lt;em&gt;string concatenation&lt;/em&gt;
 454      * feature of the Java Programming Language.
 455      *
 456      * &lt;p&gt;When the target of the {@code CallSite} returned from this method is
 457      * invoked, it returns the result of String concatenation, taking all
 458      * function arguments and constants passed to the linkage method as inputs for
 459      * concatenation. The target signature is given by {@code concatType}, and
 460      * does not include constants.
 461      * For a target accepting:
 462      * &lt;ul&gt;
 463      *     &lt;li&gt;zero inputs, concatenation results in an empty string;&lt;/li&gt;
 464      *     &lt;li&gt;one input, concatenation results in the single
 465      *     input converted as per JLS 5.1.11 &quot;String Conversion&quot;; otherwise&lt;/li&gt;
 466      *     &lt;li&gt;two or more inputs, the inputs are concatenated as per
 467      *     requirements stated in JLS 15.18.1 &quot;String Concatenation Operator +&quot;.
 468      *     The inputs are converted as per JLS 5.1.11 &quot;String Conversion&quot;,
 469      *     and combined from left to right.&lt;/li&gt;
 470      * &lt;/ul&gt;
 471      *
 472      * &lt;p&gt;The concatenation &lt;em&gt;recipe&lt;/em&gt; is a String description for the way to
 473      * construct a concatenated String from the arguments and constants. The
 474      * recipe is processed from left to right, and each character represents an
 475      * input to concatenation. Recipe characters mean:
 476      *
 477      * &lt;ul&gt;
 478      *
 479      *   &lt;li&gt;&lt;em&gt;\1 (Unicode point 0001)&lt;/em&gt;: an ordinary argument. This
 480      *   input is passed through dynamic argument, and is provided during the
 481      *   concatenation method invocation. This input can be null.&lt;/li&gt;
 482      *
 483      *   &lt;li&gt;&lt;em&gt;\2 (Unicode point 0002):&lt;/em&gt; a constant. This input passed
 484      *   through static bootstrap argument. This constant can be any value
 485      *   representable in constant pool. If necessary, the factory would call
 486      *   {@code toString} to perform a one-time String conversion.&lt;/li&gt;
 487      *
 488      *   &lt;li&gt;&lt;em&gt;Any other char value:&lt;/em&gt; a single character constant.&lt;/li&gt;
 489      * &lt;/ul&gt;
 490      *
 491      * &lt;p&gt;Assume the linkage arguments are as follows:
 492      *
 493      * &lt;ul&gt;
 494      *   &lt;li&gt;{@code concatType}, describing the {@code CallSite} signature&lt;/li&gt;
 495      *   &lt;li&gt;{@code recipe}, describing the String recipe&lt;/li&gt;
 496      *   &lt;li&gt;{@code constants}, the vararg array of constants&lt;/li&gt;
 497      * &lt;/ul&gt;
 498      *
 499      * &lt;p&gt;Then the following linkage invariants must hold:
 500      *
 501      * &lt;ul&gt;
 502      *   &lt;li&gt;The number of parameter slots in {@code concatType} is less than
 503      *       or equal to 200&lt;/li&gt;
 504      *
 505      *   &lt;li&gt;The parameter count in {@code concatType} is equal to number of \1 tags
 506      *   in {@code recipe}&lt;/li&gt;
 507      *
 508      *   &lt;li&gt;The return type in {@code concatType} is assignable
 509      *   from {@link java.lang.String}, and matches the return type of the
 510      *   returned {@link MethodHandle}&lt;/li&gt;
 511      *
 512      *   &lt;li&gt;The number of elements in {@code constants} is equal to number of \2
 513      *   tags in {@code recipe}&lt;/li&gt;
 514      * &lt;/ul&gt;
 515      *
 516      * @param lookup    Represents a lookup context with the accessibility
 517      *                  privileges of the caller. Specifically, the lookup
 518      *                  context must have
 519      *                  {@linkplain MethodHandles.Lookup#hasFullPrivilegeAccess()
 520      *                  full privilege access}.
 521      *                  When used with {@code invokedynamic}, this is stacked
 522      *                  automatically by the VM.
 523      * @param name      The name of the method to implement. This name is
 524      *                  arbitrary, and has no meaning for this linkage method.
 525      *                  When used with {@code invokedynamic}, this is provided
 526      *                  by the {@code NameAndType} of the {@code InvokeDynamic}
 527      *                  structure and is stacked automatically by the VM.
 528      * @param concatType The expected signature of the {@code CallSite}.  The
 529      *                  parameter types represent the types of dynamic concatenation
 530      *                  arguments; the return type is always assignable from {@link
 531      *                  java.lang.String}.  When used with {@code
 532      *                  invokedynamic}, this is provided by the {@code
 533      *                  NameAndType} of the {@code InvokeDynamic} structure and
 534      *                  is stacked automatically by the VM.
 535      * @param recipe    Concatenation recipe, described above.
 536      * @param constants A vararg parameter representing the constants passed to
 537      *                  the linkage method.
 538      * @return a CallSite whose target can be used to perform String
 539      * concatenation, with dynamic concatenation arguments described by the given
 540      * {@code concatType}.
 541      * @throws StringConcatException If any of the linkage invariants described
 542      *                               here are violated, or the lookup context
 543      *                               does not have private access privileges.
 544      * @throws NullPointerException If any of the incoming arguments is null, or
 545      *                              any constant in {@code recipe} is null.
 546      *                              This will never happen when a bootstrap method
 547      *                              is called with invokedynamic.
 548      * @apiNote Code generators have three distinct ways to process a constant
 549      * string operand S in a string concatenation expression.  First, S can be
 550      * materialized as a reference (using ldc) and passed as an ordinary argument
 551      * (recipe &#39;\1&#39;). Or, S can be stored in the constant pool and passed as a
 552      * constant (recipe &#39;\2&#39;) . Finally, if S contains neither of the recipe
 553      * tag characters (&#39;\1&#39;, &#39;\2&#39;) then S can be interpolated into the recipe
 554      * itself, causing its characters to be inserted into the result.
 555      *
 556      * @jls  5.1.11 String Conversion
 557      * @jls 15.18.1 String Concatenation Operator +
 558      */
 559     public static CallSite makeConcatWithConstants(MethodHandles.Lookup lookup,
 560                                                    String name,
 561                                                    MethodType concatType,
 562                                                    String recipe,
 563                                                    Object... constants) throws StringConcatException {
 564         if (DEBUG) {
 565             System.out.println(&quot;StringConcatFactory &quot; + STRATEGY + &quot; is here for &quot; + concatType + &quot;, {&quot; + recipe + &quot;}, &quot; + Arrays.toString(constants));
 566         }
 567 
 568         return doStringConcat(lookup, name, concatType, false, recipe, constants);
 569     }
 570 
 571     private static CallSite doStringConcat(MethodHandles.Lookup lookup,
 572                                            String name,
 573                                            MethodType concatType,
 574                                            boolean generateRecipe,
 575                                            String recipe,
 576                                            Object... constants) throws StringConcatException {
 577         Objects.requireNonNull(lookup, &quot;Lookup is null&quot;);
 578         Objects.requireNonNull(name, &quot;Name is null&quot;);
 579         Objects.requireNonNull(concatType, &quot;Concat type is null&quot;);
 580         Objects.requireNonNull(constants, &quot;Constants are null&quot;);
 581 
 582         for (Object o : constants) {
 583             Objects.requireNonNull(o, &quot;Cannot accept null constants&quot;);
 584         }
 585 
 586         if ((lookup.lookupModes() &amp; MethodHandles.Lookup.PRIVATE) == 0) {
 587             throw new StringConcatException(&quot;Invalid caller: &quot; +
 588                     lookup.lookupClass().getName());
 589         }
 590 
 591         int cCount = 0;
 592         int oCount = 0;
 593         if (generateRecipe) {
 594             // Mock the recipe to reuse the concat generator code
 595             char[] value = new char[concatType.parameterCount()];
 596             Arrays.fill(value, TAG_ARG);
 597             recipe = new String(value);
 598             oCount = concatType.parameterCount();
 599         } else {
 600             Objects.requireNonNull(recipe, &quot;Recipe is null&quot;);
 601 
 602             for (int i = 0; i &lt; recipe.length(); i++) {
 603                 char c = recipe.charAt(i);
 604                 if (c == TAG_CONST) cCount++;
 605                 if (c == TAG_ARG)   oCount++;
 606             }
 607         }
 608 
 609         if (oCount != concatType.parameterCount()) {
 610             throw new StringConcatException(
 611                     &quot;Mismatched number of concat arguments: recipe wants &quot; +
 612                             oCount +
 613                             &quot; arguments, but signature provides &quot; +
 614                             concatType.parameterCount());
 615         }
 616 
 617         if (cCount != constants.length) {
 618             throw new StringConcatException(
 619                     &quot;Mismatched number of concat constants: recipe wants &quot; +
 620                             cCount +
 621                             &quot; constants, but only &quot; +
 622                             constants.length +
 623                             &quot; are passed&quot;);
 624         }
 625 
 626         if (!concatType.returnType().isAssignableFrom(String.class)) {
 627             throw new StringConcatException(
 628                     &quot;The return type should be compatible with String, but it is &quot; +
 629                             concatType.returnType());
 630         }
 631 
 632         if (concatType.parameterSlotCount() &gt; MAX_INDY_CONCAT_ARG_SLOTS) {
 633             throw new StringConcatException(&quot;Too many concat argument slots: &quot; +
 634                     concatType.parameterSlotCount() +
 635                     &quot;, can only accept &quot; +
 636                     MAX_INDY_CONCAT_ARG_SLOTS);
 637         }
 638 
<a name="8" id="anc8"></a>
 639         MethodType mt = adaptType(concatType);
 640         Recipe rec = new Recipe(recipe, constants);
<a name="9" id="anc9"></a><span class="line-modified"> 641         MethodHandle mh = generate(lookup, mt, rec);</span>











 642         return new ConstantCallSite(mh.asType(concatType));
 643     }
 644 
 645     /**
 646      * Adapt method type to an API we are going to use.
 647      *
 648      * This strips the concrete classes from the signatures, thus preventing
 649      * class leakage when we cache the concatenation stubs.
 650      *
 651      * @param args actual argument types
 652      * @return argument types the strategy is going to use
 653      */
 654     private static MethodType adaptType(MethodType args) {
 655         Class&lt;?&gt;[] ptypes = null;
 656         for (int i = 0; i &lt; args.parameterCount(); i++) {
 657             Class&lt;?&gt; ptype = args.parameterType(i);
 658             if (!ptype.isPrimitive() &amp;&amp;
 659                     ptype != String.class &amp;&amp;
 660                     ptype != Object.class) { // truncate to Object
 661                 if (ptypes == null) {
 662                     ptypes = args.parameterArray();
 663                 }
 664                 ptypes[i] = Object.class;
 665             }
 666             // else other primitives or String or Object (unchanged)
 667         }
 668         return (ptypes != null)
 669                 ? MethodType.methodType(args.returnType(), ptypes)
 670                 : args;
 671     }
 672 
<a name="10" id="anc10"></a><span class="line-modified"> 673     private static MethodHandle generate(Lookup lookup, MethodType mt, Recipe recipe) throws StringConcatException {</span>































 674         try {
<a name="11" id="anc11"></a><span class="line-added"> 675             if (STRATEGY == null) {</span>
<span class="line-added"> 676                 return MethodHandleInlineCopyStrategy.generate(mt, recipe);</span>
<span class="line-added"> 677             }</span>
 678             switch (STRATEGY) {
 679                 case BC_SB:
<a name="12" id="anc12"></a><span class="line-modified"> 680                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.DEFAULT);</span>
 681                 case BC_SB_SIZED:
<a name="13" id="anc13"></a><span class="line-modified"> 682                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED);</span>
 683                 case BC_SB_SIZED_EXACT:
<a name="14" id="anc14"></a><span class="line-modified"> 684                     return BytecodeStringBuilderStrategy.generate(lookup, mt, recipe, Mode.SIZED_EXACT);</span>
 685                 case MH_SB_SIZED:
 686                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED);
 687                 case MH_SB_SIZED_EXACT:
 688                     return MethodHandleStringBuilderStrategy.generate(mt, recipe, Mode.SIZED_EXACT);
 689                 case MH_INLINE_SIZED_EXACT:
 690                     return MethodHandleInlineCopyStrategy.generate(mt, recipe);
 691                 default:
 692                     throw new StringConcatException(&quot;Concatenation strategy &quot; + STRATEGY + &quot; is not implemented&quot;);
 693             }
 694         } catch (Error | StringConcatException e) {
 695             // Pass through any error or existing StringConcatException
 696             throw e;
 697         } catch (Throwable t) {
 698             throw new StringConcatException(&quot;Generator failed&quot;, t);
 699         }
 700     }
 701 
 702     private enum Mode {
 703         DEFAULT(false, false),
 704         SIZED(true, false),
 705         SIZED_EXACT(true, true);
 706 
 707         private final boolean sized;
 708         private final boolean exact;
 709 
 710         Mode(boolean sized, boolean exact) {
 711             this.sized = sized;
 712             this.exact = exact;
 713         }
 714 
 715         boolean isSized() {
 716             return sized;
 717         }
 718 
 719         boolean isExact() {
 720             return exact;
 721         }
 722     }
 723 
 724     /**
 725      * Bytecode StringBuilder strategy.
 726      *
 727      * &lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.
 728      *
 729      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;
 730      *
 731      * &lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder
 732      * chain javac would otherwise emit. This strategy uses only the public API,
 733      * and comes as the baseline for the current JDK behavior. On other words,
 734      * this strategy moves the javac generated bytecode to runtime. The
 735      * generated bytecode is loaded via Lookup::defineClass, but with
 736      * the caller class coming from the BSM -- in other words, the protection
 737      * guarantees are inherited from the method where invokedynamic was
 738      * originally called. This means, among other things, that the bytecode is
 739      * verified for all non-JDK uses.
 740      *
 741      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED}: &quot;bytecode StringBuilder, but
 742      * sized&quot;.&lt;/b&gt;
 743      *
 744      * &lt;p&gt;This strategy acts similarly to {@link Strategy#BC_SB}, but it also
 745      * tries to guess the capacity required for StringBuilder to accept all
 746      * arguments without resizing. This strategy only makes an educated guess:
 747      * it only guesses the space required for known types (e.g. primitives and
 748      * Strings), but does not otherwise convert arguments. Therefore, the
 749      * capacity estimate may be wrong, and StringBuilder may have to
 750      * transparently resize or trim when doing the actual concatenation. While
 751      * this does not constitute a correctness issue (in the end, that what BC_SB
 752      * has to do anyway), this does pose a potential performance problem.
 753      *
 754      * &lt;p&gt;&lt;b&gt;{@link Strategy#BC_SB_SIZED_EXACT}: &quot;bytecode StringBuilder, but
 755      * sized exactly&quot;.&lt;/b&gt;
 756      *
 757      * &lt;p&gt;This strategy improves on @link Strategy#BC_SB_SIZED}, by first
 758      * converting all arguments to String in order to get the exact capacity
 759      * StringBuilder should have. The conversion is done via the public
 760      * String.valueOf and/or Object.toString methods, and does not touch any
 761      * private String API.
 762      */
 763     private static final class BytecodeStringBuilderStrategy {
 764         static final int CLASSFILE_VERSION = 52;
 765         static final String METHOD_NAME = &quot;concat&quot;;
 766 
<a name="15" id="anc15"></a><span class="line-added"> 767         private static final ConcurrentMap&lt;Key, MethodHandle&gt; CACHE;</span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769         /**</span>
<span class="line-added"> 770          * Enables caching of strategy stubs. This may improve the linkage time by reusing the generated</span>
<span class="line-added"> 771          * code, at the expense of contaminating the profiles.</span>
<span class="line-added"> 772          */</span>
<span class="line-added"> 773         private static final boolean CACHE_ENABLE;</span>
<span class="line-added"> 774 </span>
<span class="line-added"> 775         /**</span>
<span class="line-added"> 776          * Dump generated classes to disk, for debugging purposes.</span>
<span class="line-added"> 777          */</span>
<span class="line-added"> 778         private static final ProxyClassesDumper DUMPER;</span>
<span class="line-added"> 779 </span>
<span class="line-added"> 780         static {</span>
<span class="line-added"> 781             CACHE_ENABLE = Boolean.parseBoolean(</span>
<span class="line-added"> 782                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.cache&quot;));</span>
<span class="line-added"> 783             CACHE = CACHE_ENABLE ? new ConcurrentHashMap&lt;&gt;() : null;</span>
<span class="line-added"> 784 </span>
<span class="line-added"> 785             final String dumpPath =</span>
<span class="line-added"> 786                     VM.getSavedProperty(&quot;java.lang.invoke.stringConcat.dumpClasses&quot;);</span>
<span class="line-added"> 787 </span>
<span class="line-added"> 788             DUMPER = (dumpPath == null) ? null : ProxyClassesDumper.getInstance(dumpPath);</span>
<span class="line-added"> 789         }</span>
<span class="line-added"> 790 </span>
 791         private BytecodeStringBuilderStrategy() {
 792             // no instantiation
 793         }
 794 
<a name="16" id="anc16"></a><span class="line-modified"> 795         private static MethodHandle generate(Lookup lookup, MethodType args, Recipe recipe, Mode mode) throws Exception {</span>
<span class="line-added"> 796             String className = getClassName(lookup.lookupClass());</span>
<span class="line-added"> 797             Key key = null;</span>
<span class="line-added"> 798             if (CACHE_ENABLE) {</span>
<span class="line-added"> 799                 key = new Key(className, args, recipe);</span>
<span class="line-added"> 800                 MethodHandle mh = CACHE.get(key);</span>
<span class="line-added"> 801                 if (mh != null) {</span>
<span class="line-added"> 802                     return mh;</span>
<span class="line-added"> 803                 }</span>
<span class="line-added"> 804             }</span>
<span class="line-added"> 805 </span>
 806             ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 807 
 808             cw.visit(CLASSFILE_VERSION,
 809                     ACC_SUPER + ACC_PUBLIC + ACC_FINAL + ACC_SYNTHETIC,
 810                     className,
 811                     null,
 812                     &quot;java/lang/Object&quot;,
 813                     null
 814             );
 815 
 816             MethodVisitor mv = cw.visitMethod(
 817                     ACC_PUBLIC + ACC_STATIC + ACC_FINAL,
 818                     METHOD_NAME,
 819                     args.toMethodDescriptorString(),
 820                     null,
 821                     null);
 822 
 823             // use of @ForceInline no longer has any effect
 824             mv.visitAnnotation(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;, true);
 825             mv.visitCode();
 826 
 827             Class&lt;?&gt;[] arr = args.parameterArray();
 828             boolean[] guaranteedNonNull = new boolean[arr.length];
 829 
 830             if (mode.isExact()) {
 831                 /*
 832                     In exact mode, we need to convert all arguments to their String representations,
 833                     as this allows to compute their String sizes exactly. We cannot use private
 834                     methods for primitives in here, therefore we need to convert those as well.
 835 
 836                     We also record what arguments are guaranteed to be non-null as the result
 837                     of the conversion. String.valueOf does the null checks for us. The only
 838                     corner case to take care of is String.valueOf(Object) returning null itself.
 839 
 840                     Also, if any conversion happened, then the slot indices in the incoming
 841                     arguments are not equal to the final local maps. The only case this may break
 842                     is when converting 2-slot long/double argument to 1-slot String. Therefore,
 843                     we get away with tracking modified offset, since no conversion can overwrite
 844                     the upcoming the argument.
 845                  */
 846 
 847                 int off = 0;
 848                 int modOff = 0;
 849                 for (int c = 0; c &lt; arr.length; c++) {
 850                     Class&lt;?&gt; cl = arr[c];
 851                     if (cl == String.class) {
 852                         if (off != modOff) {
 853                             mv.visitIntInsn(getLoadOpcode(cl), off);
 854                             mv.visitIntInsn(ASTORE, modOff);
 855                         }
 856                     } else {
 857                         mv.visitIntInsn(getLoadOpcode(cl), off);
 858                         mv.visitMethodInsn(
 859                                 INVOKESTATIC,
 860                                 &quot;java/lang/String&quot;,
 861                                 &quot;valueOf&quot;,
 862                                 getStringValueOfDesc(cl),
 863                                 false
 864                         );
 865                         mv.visitIntInsn(ASTORE, modOff);
 866                         arr[c] = String.class;
 867                         guaranteedNonNull[c] = cl.isPrimitive();
 868                     }
 869                     off += getParameterSize(cl);
 870                     modOff += getParameterSize(String.class);
 871                 }
 872             }
 873 
 874             if (mode.isSized()) {
 875                 /*
 876                     When operating in sized mode (this includes exact mode), it makes sense to make
 877                     StringBuilder append chains look familiar to OptimizeStringConcat. For that, we
 878                     need to do null-checks early, not make the append chain shape simpler.
 879                  */
 880 
 881                 int off = 0;
 882                 for (RecipeElement el : recipe.getElements()) {
 883                     switch (el.getTag()) {
 884                         case TAG_CONST:
 885                             // Guaranteed non-null, no null check required.
 886                             break;
 887                         case TAG_ARG:
 888                             // Null-checks are needed only for String arguments, and when a previous stage
 889                             // did not do implicit null-checks. If a String is null, we eagerly replace it
 890                             // with &quot;null&quot; constant. Note, we omit Objects here, because we don&#39;t call
 891                             // .length() on them down below.
 892                             int ac = el.getArgPos();
 893                             Class&lt;?&gt; cl = arr[ac];
 894                             if (cl == String.class &amp;&amp; !guaranteedNonNull[ac]) {
 895                                 Label l0 = new Label();
 896                                 mv.visitIntInsn(ALOAD, off);
 897                                 mv.visitJumpInsn(IFNONNULL, l0);
 898                                 mv.visitLdcInsn(&quot;null&quot;);
 899                                 mv.visitIntInsn(ASTORE, off);
 900                                 mv.visitLabel(l0);
 901                             }
 902                             off += getParameterSize(cl);
 903                             break;
 904                         default:
 905                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 906                     }
 907                 }
 908             }
 909 
 910             // Prepare StringBuilder instance
 911             mv.visitTypeInsn(NEW, &quot;java/lang/StringBuilder&quot;);
 912             mv.visitInsn(DUP);
 913 
 914             if (mode.isSized()) {
 915                 /*
 916                     Sized mode requires us to walk through the arguments, and estimate the final length.
 917                     In exact mode, this will operate on Strings only. This code would accumulate the
 918                     final length on stack.
 919                  */
 920                 int len = 0;
 921                 int off = 0;
 922 
 923                 mv.visitInsn(ICONST_0);
 924 
 925                 for (RecipeElement el : recipe.getElements()) {
 926                     switch (el.getTag()) {
 927                         case TAG_CONST:
 928                             len += el.getValue().length();
 929                             break;
 930                         case TAG_ARG:
 931                             /*
 932                                 If an argument is String, then we can call .length() on it. Sized/Exact modes have
 933                                 converted arguments for us. If an argument is primitive, we can provide a guess
 934                                 for its String representation size.
 935                             */
 936                             Class&lt;?&gt; cl = arr[el.getArgPos()];
 937                             if (cl == String.class) {
 938                                 mv.visitIntInsn(ALOAD, off);
 939                                 mv.visitMethodInsn(
 940                                         INVOKEVIRTUAL,
 941                                         &quot;java/lang/String&quot;,
 942                                         &quot;length&quot;,
 943                                         &quot;()I&quot;,
 944                                         false
 945                                 );
 946                                 mv.visitInsn(IADD);
 947                             } else if (cl.isPrimitive()) {
 948                                 len += estimateSize(cl);
 949                             }
 950                             off += getParameterSize(cl);
 951                             break;
 952                         default:
 953                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 954                     }
 955                 }
 956 
 957                 // Constants have non-zero length, mix in
 958                 if (len &gt; 0) {
 959                     iconst(mv, len);
 960                     mv.visitInsn(IADD);
 961                 }
 962 
 963                 mv.visitMethodInsn(
 964                         INVOKESPECIAL,
 965                         &quot;java/lang/StringBuilder&quot;,
 966                         &quot;&lt;init&gt;&quot;,
 967                         &quot;(I)V&quot;,
 968                         false
 969                 );
 970             } else {
 971                 mv.visitMethodInsn(
 972                         INVOKESPECIAL,
 973                         &quot;java/lang/StringBuilder&quot;,
 974                         &quot;&lt;init&gt;&quot;,
 975                         &quot;()V&quot;,
 976                         false
 977                 );
 978             }
 979 
 980             // At this point, we have a blank StringBuilder on stack, fill it in with .append calls.
 981             {
 982                 int off = 0;
 983                 for (RecipeElement el : recipe.getElements()) {
 984                     String desc;
 985                     switch (el.getTag()) {
 986                         case TAG_CONST:
 987                             mv.visitLdcInsn(el.getValue());
 988                             desc = getSBAppendDesc(String.class);
 989                             break;
 990                         case TAG_ARG:
 991                             Class&lt;?&gt; cl = arr[el.getArgPos()];
 992                             mv.visitVarInsn(getLoadOpcode(cl), off);
 993                             off += getParameterSize(cl);
 994                             desc = getSBAppendDesc(cl);
 995                             break;
 996                         default:
 997                             throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
 998                     }
 999 
1000                     mv.visitMethodInsn(
1001                             INVOKEVIRTUAL,
1002                             &quot;java/lang/StringBuilder&quot;,
1003                             &quot;append&quot;,
1004                             desc,
1005                             false
1006                     );
1007                 }
1008             }
1009 
1010             if (DEBUG &amp;&amp; mode.isExact()) {
1011                 /*
1012                     Exactness checks compare the final StringBuilder.capacity() with a resulting
1013                     String.length(). If these values disagree, that means StringBuilder had to perform
1014                     storage trimming, which defeats the purpose of exact strategies.
1015                  */
1016 
1017                 /*
1018                    The logic for this check is as follows:
1019 
1020                      Stack before:     Op:
1021                       (SB)              dup, dup
1022                       (SB, SB, SB)      capacity()
1023                       (int, SB, SB)     swap
1024                       (SB, int, SB)     toString()
1025                       (S, int, SB)      length()
1026                       (int, int, SB)    if_icmpeq
1027                       (SB)              &lt;end&gt;
1028 
1029                    Note that it leaves the same StringBuilder on exit, like the one on enter.
1030                  */
1031 
1032                 mv.visitInsn(DUP);
1033                 mv.visitInsn(DUP);
1034 
1035                 mv.visitMethodInsn(
1036                         INVOKEVIRTUAL,
1037                         &quot;java/lang/StringBuilder&quot;,
1038                         &quot;capacity&quot;,
1039                         &quot;()I&quot;,
1040                         false
1041                 );
1042 
1043                 mv.visitInsn(SWAP);
1044 
1045                 mv.visitMethodInsn(
1046                         INVOKEVIRTUAL,
1047                         &quot;java/lang/StringBuilder&quot;,
1048                         &quot;toString&quot;,
1049                         &quot;()Ljava/lang/String;&quot;,
1050                         false
1051                 );
1052 
1053                 mv.visitMethodInsn(
1054                         INVOKEVIRTUAL,
1055                         &quot;java/lang/String&quot;,
1056                         &quot;length&quot;,
1057                         &quot;()I&quot;,
1058                         false
1059                 );
1060 
1061                 Label l0 = new Label();
1062                 mv.visitJumpInsn(IF_ICMPEQ, l0);
1063 
1064                 mv.visitTypeInsn(NEW, &quot;java/lang/AssertionError&quot;);
1065                 mv.visitInsn(DUP);
1066                 mv.visitLdcInsn(&quot;Failed exactness check&quot;);
1067                 mv.visitMethodInsn(INVOKESPECIAL,
1068                         &quot;java/lang/AssertionError&quot;,
1069                         &quot;&lt;init&gt;&quot;,
1070                         &quot;(Ljava/lang/Object;)V&quot;,
1071                         false);
1072                 mv.visitInsn(ATHROW);
1073 
1074                 mv.visitLabel(l0);
1075             }
1076 
1077             mv.visitMethodInsn(
1078                     INVOKEVIRTUAL,
1079                     &quot;java/lang/StringBuilder&quot;,
1080                     &quot;toString&quot;,
1081                     &quot;()Ljava/lang/String;&quot;,
1082                     false
1083             );
1084 
1085             mv.visitInsn(ARETURN);
1086 
1087             mv.visitMaxs(-1, -1);
1088             mv.visitEnd();
1089             cw.visitEnd();
1090 
1091             byte[] classBytes = cw.toByteArray();
1092             try {
1093                 Class&lt;?&gt; innerClass = lookup.defineHiddenClass(classBytes, true, STRONG).lookupClass();
1094                 dumpIfEnabled(className, classBytes);
<a name="17" id="anc17"></a><span class="line-modified">1095                 MethodHandle mh = lookup.findStatic(innerClass, METHOD_NAME, args);</span>
<span class="line-added">1096                 if (CACHE_ENABLE) {</span>
<span class="line-added">1097                     CACHE.put(key, mh);</span>
<span class="line-added">1098                 }</span>
<span class="line-added">1099                 return mh;</span>
1100             } catch (Exception e) {
1101                 dumpIfEnabled(className + &quot;$$FAILED&quot;, classBytes);
1102                 throw new StringConcatException(&quot;Exception while spinning the class&quot;, e);
1103             }
1104         }
1105 
<a name="18" id="anc18"></a><span class="line-added">1106         /**</span>
<span class="line-added">1107          * The generated class is in the same package as the host class as</span>
<span class="line-added">1108          * it&#39;s the implementation of the string concatenation for the host</span>
<span class="line-added">1109          * class.</span>
<span class="line-added">1110          *</span>
<span class="line-added">1111          * When cache is enabled, we want to cache as much as we can.</span>
<span class="line-added">1112          */</span>
<span class="line-added">1113         private static String getClassName(Class&lt;?&gt; hostClass) {</span>
<span class="line-added">1114             if (CACHE_ENABLE) {</span>
<span class="line-added">1115                 String pkgName = hostClass.getPackageName();</span>
<span class="line-added">1116                 return (!pkgName.isEmpty() ? pkgName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; : &quot;&quot;) + &quot;Stubs$$StringConcat&quot;;</span>
<span class="line-added">1117             } else {</span>
<span class="line-added">1118                 String name = hostClass.isHidden() ? hostClass.getName().replace(&#39;/&#39;, &#39;_&#39;)</span>
<span class="line-added">1119                         : hostClass.getName();</span>
<span class="line-added">1120                 return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$StringConcat&quot;;</span>
<span class="line-added">1121             }</span>
<span class="line-added">1122         }</span>
<span class="line-added">1123 </span>
1124         private static void dumpIfEnabled(String name, byte[] bytes) {
1125             if (DUMPER != null) {
1126                 DUMPER.dumpClass(name, bytes);
1127             }
1128         }
1129 
1130         private static String getSBAppendDesc(Class&lt;?&gt; cl) {
1131             if (cl.isPrimitive()) {
1132                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1133                     return &quot;(I)Ljava/lang/StringBuilder;&quot;;
1134                 } else if (cl == Boolean.TYPE) {
1135                     return &quot;(Z)Ljava/lang/StringBuilder;&quot;;
1136                 } else if (cl == Character.TYPE) {
1137                     return &quot;(C)Ljava/lang/StringBuilder;&quot;;
1138                 } else if (cl == Double.TYPE) {
1139                     return &quot;(D)Ljava/lang/StringBuilder;&quot;;
1140                 } else if (cl == Float.TYPE) {
1141                     return &quot;(F)Ljava/lang/StringBuilder;&quot;;
1142                 } else if (cl == Long.TYPE) {
1143                     return &quot;(J)Ljava/lang/StringBuilder;&quot;;
1144                 } else {
1145                     throw new IllegalStateException(&quot;Unhandled primitive StringBuilder.append: &quot; + cl);
1146                 }
1147             } else if (cl == String.class) {
1148                 return &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;;
1149             } else {
1150                 return &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;;
1151             }
1152         }
1153 
1154         private static String getStringValueOfDesc(Class&lt;?&gt; cl) {
1155             if (cl.isPrimitive()) {
1156                 if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {
1157                     return &quot;(I)Ljava/lang/String;&quot;;
1158                 } else if (cl == Boolean.TYPE) {
1159                     return &quot;(Z)Ljava/lang/String;&quot;;
1160                 } else if (cl == Character.TYPE) {
1161                     return &quot;(C)Ljava/lang/String;&quot;;
1162                 } else if (cl == Double.TYPE) {
1163                     return &quot;(D)Ljava/lang/String;&quot;;
1164                 } else if (cl == Float.TYPE) {
1165                     return &quot;(F)Ljava/lang/String;&quot;;
1166                 } else if (cl == Long.TYPE) {
1167                     return &quot;(J)Ljava/lang/String;&quot;;
1168                 } else {
1169                     throw new IllegalStateException(&quot;Unhandled String.valueOf: &quot; + cl);
1170                 }
1171             } else if (cl == String.class) {
1172                 return &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;;
1173             } else {
1174                 return &quot;(Ljava/lang/Object;)Ljava/lang/String;&quot;;
1175             }
1176         }
1177 
1178         /**
1179          * The following method is copied from
1180          * org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small
1181          * and fast Java bytecode manipulation framework.
1182          * Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.
1183          */
1184         private static void iconst(MethodVisitor mv, final int cst) {
1185             if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
1186                 mv.visitInsn(Opcodes.ICONST_0 + cst);
1187             } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
1188                 mv.visitIntInsn(Opcodes.BIPUSH, cst);
1189             } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
1190                 mv.visitIntInsn(Opcodes.SIPUSH, cst);
1191             } else {
1192                 mv.visitLdcInsn(cst);
1193             }
1194         }
1195 
1196         private static int getLoadOpcode(Class&lt;?&gt; c) {
1197             if (c == Void.TYPE) {
1198                 throw new InternalError(&quot;Unexpected void type of load opcode&quot;);
1199             }
1200             return ILOAD + getOpcodeOffset(c);
1201         }
1202 
1203         private static int getOpcodeOffset(Class&lt;?&gt; c) {
1204             if (c.isPrimitive()) {
1205                 if (c == Long.TYPE) {
1206                     return 1;
1207                 } else if (c == Float.TYPE) {
1208                     return 2;
1209                 } else if (c == Double.TYPE) {
1210                     return 3;
1211                 }
1212                 return 0;
1213             } else {
1214                 return 4;
1215             }
1216         }
1217 
1218         private static int getParameterSize(Class&lt;?&gt; c) {
1219             if (c == Void.TYPE) {
1220                 return 0;
1221             } else if (c == Long.TYPE || c == Double.TYPE) {
1222                 return 2;
1223             }
1224             return 1;
1225         }
1226     }
1227 
1228     /**
1229      * MethodHandle StringBuilder strategy.
1230      *
1231      * &lt;p&gt;This strategy operates in two modes, gated by {@link Mode}.
1232      *
1233      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED}: &quot;MethodHandles StringBuilder,
1234      * sized&quot;.&lt;/b&gt;
1235      *
1236      * &lt;p&gt;This strategy avoids spinning up the bytecode by building the
1237      * computation on MethodHandle combinators. The computation is built with
1238      * public MethodHandle APIs, resolved from a public Lookup sequence, and
1239      * ends up calling the public StringBuilder API. Therefore, this strategy
1240      * does not use any private API at all since everything is handled under
1241      * cover by java.lang.invoke APIs.
1242      *
1243      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_SB_SIZED_EXACT}: &quot;MethodHandles StringBuilder,
1244      * sized exactly&quot;.&lt;/b&gt;
1245      *
1246      * &lt;p&gt;This strategy improves on @link Strategy#MH_SB_SIZED}, by first
1247      * converting all arguments to String in order to get the exact capacity
1248      * StringBuilder should have. The conversion is done via the public
1249      * String.valueOf and/or Object.toString methods, and does not touch any
1250      * private String API.
1251      */
1252     private static final class MethodHandleStringBuilderStrategy {
1253         private MethodHandleStringBuilderStrategy() {
1254             // no instantiation
1255         }
1256 
1257         private static MethodHandle generate(MethodType mt, Recipe recipe, Mode mode) throws Exception {
1258             int pc = mt.parameterCount();
1259 
1260             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1261             MethodHandle[] filters = new MethodHandle[ptypes.length];
1262             for (int i = 0; i &lt; ptypes.length; i++) {
1263                 MethodHandle filter;
1264                 switch (mode) {
1265                     case SIZED:
1266                         // In sized mode, we convert all references and floats/doubles
1267                         // to String: there is no specialization for different
1268                         // classes in StringBuilder API, and it will convert to
1269                         // String internally anyhow.
1270                         filter = Stringifiers.forMost(ptypes[i]);
1271                         break;
1272                     case SIZED_EXACT:
1273                         // In exact mode, we convert everything to String:
1274                         // this helps to compute the storage exactly.
1275                         filter = Stringifiers.forAny(ptypes[i]);
1276                         break;
1277                     default:
1278                         throw new StringConcatException(&quot;Not supported&quot;);
1279                 }
1280                 if (filter != null) {
1281                     filters[i] = filter;
1282                     ptypes[i] = filter.type().returnType();
1283                 }
1284             }
1285 
1286             MethodHandle[] lengthers = new MethodHandle[pc];
1287 
1288             // Figure out lengths: constants&#39; lengths can be deduced on the spot.
1289             // All reference arguments were filtered to String in the combinators below, so we can
1290             // call the usual String.length(). Primitive values string sizes can be estimated.
1291             int initial = 0;
1292             for (RecipeElement el : recipe.getElements()) {
1293                 switch (el.getTag()) {
1294                     case TAG_CONST:
1295                         initial += el.getValue().length();
1296                         break;
1297                     case TAG_ARG:
1298                         final int i = el.getArgPos();
1299                         Class&lt;?&gt; type = ptypes[i];
1300                         if (type.isPrimitive()) {
1301                             MethodHandle est = MethodHandles.constant(int.class, estimateSize(type));
1302                             est = MethodHandles.dropArguments(est, 0, type);
1303                             lengthers[i] = est;
1304                         } else {
1305                             lengthers[i] = STRING_LENGTH;
1306                         }
1307                         break;
1308                     default:
1309                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1310                 }
1311             }
1312 
1313             // Create (StringBuilder, &lt;args&gt;) shape for appending:
1314             MethodHandle builder = MethodHandles.dropArguments(MethodHandles.identity(StringBuilder.class), 1, ptypes);
1315 
1316             // Compose append calls. This is done in reverse because the application order is
1317             // reverse as well.
1318             List&lt;RecipeElement&gt; elements = recipe.getElements();
1319             for (int i = elements.size() - 1; i &gt;= 0; i--) {
1320                 RecipeElement el = elements.get(i);
1321                 MethodHandle appender;
1322                 switch (el.getTag()) {
1323                     case TAG_CONST:
1324                         MethodHandle mh = appender(adaptToStringBuilder(String.class));
1325                         appender = MethodHandles.insertArguments(mh, 1, el.getValue());
1326                         break;
1327                     case TAG_ARG:
1328                         int ac = el.getArgPos();
1329                         appender = appender(ptypes[ac]);
1330 
1331                         // Insert dummy arguments to match the prefix in the signature.
1332                         // The actual appender argument will be the ac-ith argument.
1333                         if (ac != 0) {
1334                             appender = MethodHandles.dropArguments(appender, 1, Arrays.copyOf(ptypes, ac));
1335                         }
1336                         break;
1337                     default:
1338                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1339                 }
1340                 builder = MethodHandles.foldArguments(builder, appender);
1341             }
1342 
1343             // Build the sub-tree that adds the sizes and produces a StringBuilder:
1344 
1345             // a) Start with the reducer that accepts all arguments, plus one
1346             //    slot for the initial value. Inject the initial value right away.
1347             //    This produces (&lt;ints&gt;)int shape:
1348             MethodHandle sum = getReducerFor(pc + 1);
1349             MethodHandle adder = MethodHandles.insertArguments(sum, 0, initial);
1350 
1351             // b) Apply lengthers to transform arguments to lengths, producing (&lt;args&gt;)int
1352             adder = MethodHandles.filterArguments(adder, 0, lengthers);
1353 
1354             // c) Instantiate StringBuilder (&lt;args&gt;)int -&gt; (&lt;args&gt;)StringBuilder
1355             MethodHandle newBuilder = MethodHandles.filterReturnValue(adder, NEW_STRING_BUILDER);
1356 
1357             // d) Fold in StringBuilder constructor, this produces (&lt;args&gt;)StringBuilder
1358             MethodHandle mh = MethodHandles.foldArguments(builder, newBuilder);
1359 
1360             // Convert non-primitive arguments to Strings
1361             mh = MethodHandles.filterArguments(mh, 0, filters);
1362 
1363             // Convert (&lt;args&gt;)StringBuilder to (&lt;args&gt;)String
1364             if (DEBUG &amp;&amp; mode.isExact()) {
1365                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING_CHECKED);
1366             } else {
1367                 mh = MethodHandles.filterReturnValue(mh, BUILDER_TO_STRING);
1368             }
1369 
1370             return mh;
1371         }
1372 
1373         private static MethodHandle getReducerFor(int cnt) {
1374             return SUMMERS.computeIfAbsent(cnt, SUMMER);
1375         }
1376 
1377         private static MethodHandle appender(Class&lt;?&gt; appendType) {
1378             MethodHandle appender = lookupVirtual(MethodHandles.publicLookup(), StringBuilder.class, &quot;append&quot;,
1379                     StringBuilder.class, adaptToStringBuilder(appendType));
1380 
1381             // appenders should return void, this would not modify the target signature during folding
1382             MethodType nt = MethodType.methodType(void.class, StringBuilder.class, appendType);
1383             return appender.asType(nt);
1384         }
1385 
1386         private static String toStringChecked(StringBuilder sb) {
1387             String s = sb.toString();
1388             if (s.length() != sb.capacity()) {
1389                 throw new AssertionError(&quot;Exactness check failed: result length = &quot; + s.length() + &quot;, buffer capacity = &quot; + sb.capacity());
1390             }
1391             return s;
1392         }
1393 
1394         private static int sum(int v1, int v2) {
1395             return v1 + v2;
1396         }
1397 
1398         private static int sum(int v1, int v2, int v3) {
1399             return v1 + v2 + v3;
1400         }
1401 
1402         private static int sum(int v1, int v2, int v3, int v4) {
1403             return v1 + v2 + v3 + v4;
1404         }
1405 
1406         private static int sum(int v1, int v2, int v3, int v4, int v5) {
1407             return v1 + v2 + v3 + v4 + v5;
1408         }
1409 
1410         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6) {
1411             return v1 + v2 + v3 + v4 + v5 + v6;
1412         }
1413 
1414         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7) {
1415             return v1 + v2 + v3 + v4 + v5 + v6 + v7;
1416         }
1417 
1418         private static int sum(int v1, int v2, int v3, int v4, int v5, int v6, int v7, int v8) {
1419             return v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8;
1420         }
1421 
1422         private static int sum(int initial, int[] vs) {
1423             int sum = initial;
1424             for (int v : vs) {
1425                 sum += v;
1426             }
1427             return sum;
1428         }
1429 
1430         private static final Lookup MHSBS_LOOKUP = lookup();
1431 
1432         private static final ConcurrentMap&lt;Integer, MethodHandle&gt; SUMMERS;
1433 
1434         // This one is deliberately non-lambdified to optimize startup time:
1435         private static final Function&lt;Integer, MethodHandle&gt; SUMMER = new Function&lt;Integer, MethodHandle&gt;() {
1436             @Override
1437             public MethodHandle apply(Integer cnt) {
1438                 if (cnt == 1) {
1439                     return MethodHandles.identity(int.class);
1440                 } else if (cnt &lt;= 8) {
1441                     // Variable-arity collectors are not as efficient as small-count methods,
1442                     // unroll some initial sizes.
1443                     Class&lt;?&gt;[] cls = new Class&lt;?&gt;[cnt];
1444                     Arrays.fill(cls, int.class);
1445                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, cls);
1446                 } else {
1447                     return lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class, &quot;sum&quot;, int.class, int.class, int[].class)
1448                             .asCollector(int[].class, cnt - 1);
1449                 }
1450             }
1451         };
1452 
1453         private static final MethodHandle NEW_STRING_BUILDER, STRING_LENGTH, BUILDER_TO_STRING, BUILDER_TO_STRING_CHECKED;
1454 
1455         static {
1456             SUMMERS = new ConcurrentHashMap&lt;&gt;();
1457             Lookup publicLookup = MethodHandles.publicLookup();
1458             NEW_STRING_BUILDER = lookupConstructor(publicLookup, StringBuilder.class, int.class);
1459             STRING_LENGTH = lookupVirtual(publicLookup, String.class, &quot;length&quot;, int.class);
1460             BUILDER_TO_STRING = lookupVirtual(publicLookup, StringBuilder.class, &quot;toString&quot;, String.class);
1461             if (DEBUG) {
1462                 BUILDER_TO_STRING_CHECKED = lookupStatic(MHSBS_LOOKUP, MethodHandleStringBuilderStrategy.class,
1463                         &quot;toStringChecked&quot;, String.class, StringBuilder.class);
1464             } else {
1465                 BUILDER_TO_STRING_CHECKED = null;
1466             }
1467         }
1468 
1469     }
1470 
1471 
1472     /**
1473      * &lt;p&gt;&lt;b&gt;{@link Strategy#MH_INLINE_SIZED_EXACT}: &quot;MethodHandles inline,
1474      * sized exactly&quot;.&lt;/b&gt;
1475      *
1476      * &lt;p&gt;This strategy replicates what StringBuilders are doing: it builds the
1477      * byte[] array on its own and passes that byte[] array to String
1478      * constructor. This strategy requires access to some private APIs in JDK,
1479      * most notably, the read-only Integer/Long.stringSize methods that measure
1480      * the character length of the integers, and the private String constructor
1481      * that accepts byte[] arrays without copying. While this strategy assumes a
1482      * particular implementation details for String, this opens the door for
1483      * building a very optimal concatenation sequence. This is the only strategy
1484      * that requires porting if there are private JDK changes occur.
1485      */
1486     private static final class MethodHandleInlineCopyStrategy {
1487         private MethodHandleInlineCopyStrategy() {
1488             // no instantiation
1489         }
1490 
1491         static MethodHandle generate(MethodType mt, Recipe recipe) throws Throwable {
1492 
1493             // Fast-path two-argument Object + Object concatenations
1494             if (recipe.getElements().size() == 2) {
1495                 // Two object arguments
1496                 if (mt.parameterCount() == 2 &amp;&amp;
1497                     !mt.parameterType(0).isPrimitive() &amp;&amp;
1498                     !mt.parameterType(1).isPrimitive() &amp;&amp;
1499                     recipe.getElements().get(0).getTag() == TAG_ARG &amp;&amp;
1500                     recipe.getElements().get(1).getTag() == TAG_ARG) {
1501 
1502                     return SIMPLE;
1503 
1504                 } else if (mt.parameterCount() == 1 &amp;&amp;
1505                            !mt.parameterType(0).isPrimitive()) {
1506                     // One Object argument, one constant
1507                     MethodHandle mh = SIMPLE;
1508 
1509                     if (recipe.getElements().get(0).getTag() == TAG_CONST &amp;&amp;
1510                         recipe.getElements().get(1).getTag() == TAG_ARG) {
1511                         // First recipe element is a constant
1512                         return MethodHandles.insertArguments(mh, 0,
1513                                 recipe.getElements().get(0).getValue());
1514 
1515                     } else if (recipe.getElements().get(1).getTag() == TAG_CONST &amp;&amp;
1516                                recipe.getElements().get(0).getTag() == TAG_ARG) {
1517                         // Second recipe element is a constant
1518                         return MethodHandles.insertArguments(mh, 1,
1519                                 recipe.getElements().get(1).getValue());
1520 
1521                     }
1522                 }
1523                 // else... fall-through to slow-path
1524             }
1525 
1526             // Create filters and obtain filtered parameter types. Filters would be used in the beginning
1527             // to convert the incoming arguments into the arguments we can process (e.g. Objects -&gt; Strings).
1528             // The filtered argument type list is used all over in the combinators below.
1529             Class&lt;?&gt;[] ptypes = mt.parameterArray();
1530             MethodHandle[] filters = null;
1531             for (int i = 0; i &lt; ptypes.length; i++) {
1532                 MethodHandle filter = Stringifiers.forMost(ptypes[i]);
1533                 if (filter != null) {
1534                     if (filters == null) {
1535                         filters = new MethodHandle[ptypes.length];
1536                     }
1537                     filters[i] = filter;
1538                     ptypes[i] = filter.type().returnType();
1539                 }
1540             }
1541 
1542             // Start building the combinator tree. The tree &quot;starts&quot; with (&lt;parameters&gt;)String, and &quot;finishes&quot;
1543             // with the (byte[], long)String shape to invoke newString in StringConcatHelper. The combinators are
1544             // assembled bottom-up, which makes the code arguably hard to read.
1545 
1546             // Drop all remaining parameter types, leave only helper arguments:
1547             MethodHandle mh;
1548 
1549             mh = MethodHandles.dropArguments(NEW_STRING, 2, ptypes);
1550 
1551             long initialLengthCoder = INITIAL_CODER;
1552 
1553             // Mix in prependers. This happens when (byte[], long) = (storage, indexCoder) is already
1554             // known from the combinators below. We are assembling the string backwards, so the index coded
1555             // into indexCoder is the *ending* index.
1556 
1557             // We need one prepender per argument, but also need to fold in constants. We do so by greedily
1558             // create prependers that fold in surrounding constants into the argument prepender. This reduces
1559             // the number of unique MH combinator tree shapes we&#39;ll create in an application.
1560             String prefixConstant = null, suffixConstant = null;
1561             int pos = -1;
1562             for (RecipeElement el : recipe.getElements()) {
1563                 // Do the prepend, and put &quot;new&quot; index at index 1
1564                 switch (el.getTag()) {
1565                     case TAG_CONST: {
1566                         String constantValue = el.getValue();
1567 
1568                         // Eagerly update the initialLengthCoder value
1569                         initialLengthCoder = (long)mixer(String.class).invoke(initialLengthCoder, constantValue);
1570 
1571                         if (pos &lt; 0) {
1572                             // Collecting into prefixConstant
1573                             prefixConstant = prefixConstant == null ? constantValue : prefixConstant + constantValue;
1574                         } else {
1575                             // Collecting into suffixConstant
1576                             suffixConstant = suffixConstant == null ? constantValue : suffixConstant + constantValue;
1577                         }
1578                         break;
1579                     }
1580                     case TAG_ARG: {
1581 
1582                         if (pos &gt;= 0) {
1583                             // Flush the previous non-constant arg with any prefix/suffix constant
1584                             mh = MethodHandles.filterArgumentsWithCombiner(
1585                                 mh, 1,
1586                                 prepender(prefixConstant, ptypes[pos], suffixConstant),
1587                                 1, 0, // indexCoder, storage
1588                                 2 + pos  // selected argument
1589                             );
1590                             prefixConstant = suffixConstant = null;
1591                         }
1592                         // Mark the pos of next non-constant arg
1593                         pos = el.getArgPos();
1594                         break;
1595                     }
1596                     default:
1597                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1598                 }
1599             }
1600 
1601             // Insert any trailing args, constants
1602             if (pos &gt;= 0) {
1603                 mh = MethodHandles.filterArgumentsWithCombiner(
1604                     mh, 1,
1605                     prepender(prefixConstant, ptypes[pos], suffixConstant),
1606                     1, 0, // indexCoder, storage
1607                     2 + pos  // selected argument
1608                 );
1609             } else if (prefixConstant != null) {
1610                 assert (suffixConstant == null);
1611                 // Sole prefixConstant can only happen if there were no non-constant arguments
1612                 mh = MethodHandles.filterArgumentsWithCombiner(
1613                     mh, 1,
1614                     MethodHandles.insertArguments(prepender(null, String.class, null), 2, prefixConstant),
1615                     1, 0 // indexCoder, storage
1616                 );
1617             }
1618 
1619             // Fold in byte[] instantiation at argument 0
1620             mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, NEW_ARRAY,
1621                     1 // index
1622             );
1623 
1624             // Start combining length and coder mixers.
1625             //
1626             // Length is easy: constant lengths can be computed on the spot, and all non-constant
1627             // shapes have been either converted to Strings, or explicit methods for getting the
1628             // string length out of primitives are provided.
1629             //
1630             // Coders are more interesting. Only Object, String and char arguments (and constants)
1631             // can have non-Latin1 encoding. It is easier to blindly convert constants to String,
1632             // and deduce the coder from there. Arguments would be either converted to Strings
1633             // during the initial filtering, or handled by specializations in MIXERS.
1634             //
1635             // The method handle shape before all mixers are combined in is:
1636             //   (long, &lt;args&gt;)String = (&quot;indexCoder&quot;, &lt;args&gt;)
1637             //
1638             // We will bind the initialLengthCoder value to the last mixer (the one that will be
1639             // executed first), then fold that in. This leaves the shape after all mixers are
1640             // combined in as:
1641             //   (&lt;args&gt;)String = (&lt;args&gt;)
1642 
1643             int ac = -1;
1644             MethodHandle mix = null;
1645             for (RecipeElement el : recipe.getElements()) {
1646                 switch (el.getTag()) {
1647                     case TAG_CONST:
1648                         // Constants already handled in the code above
1649                         break;
1650                     case TAG_ARG:
1651                         if (ac &gt;= 0) {
1652                             // Compute new &quot;index&quot; in-place using old value plus the appropriate argument.
1653                             mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,
1654                                     0, // old-index
1655                                     1 + ac // selected argument
1656                             );
1657                         }
1658 
1659                         ac = el.getArgPos();
1660                         Class&lt;?&gt; argClass = ptypes[ac];
1661                         mix = mixer(argClass);
1662 
1663                         break;
1664                     default:
1665                         throw new StringConcatException(&quot;Unhandled tag: &quot; + el.getTag());
1666                 }
1667             }
1668 
1669             // Insert the initialLengthCoder value into the final mixer, then
1670             // fold that into the base method handle
1671             if (ac &gt;= 0) {
1672                 mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);
1673                 mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,
1674                         1 + ac // selected argument
1675                 );
1676             } else {
1677                 // No mixer (constants only concat), insert initialLengthCoder directly
1678                 mh = MethodHandles.insertArguments(mh, 0, initialLengthCoder);
1679             }
1680 
1681             // The method handle shape here is (&lt;args&gt;).
1682 
1683             // Apply filters, converting the arguments:
1684             if (filters != null) {
1685                 mh = MethodHandles.filterArguments(mh, 0, filters);
1686             }
1687 
1688             return mh;
1689         }
1690 
1691         private static MethodHandle prepender(String prefix, Class&lt;?&gt; cl, String suffix) {
1692             return MethodHandles.insertArguments(
1693                     MethodHandles.insertArguments(
<a name="19" id="anc19"></a><span class="line-modified">1694                         PREPENDERS.computeIfAbsent(cl, PREPEND), 2, prefix), 3, suffix);</span>
1695         }
1696 
1697         private static MethodHandle mixer(Class&lt;?&gt; cl) {
1698             return MIXERS.computeIfAbsent(cl, MIX);
1699         }
1700 
1701         // This one is deliberately non-lambdified to optimize startup time:
1702         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; PREPEND = new Function&lt;&gt;() {
1703             @Override
1704             public MethodHandle apply(Class&lt;?&gt; c) {
1705                 return JLA.stringConcatHelper(&quot;prepend&quot;,
1706                             methodType(long.class, long.class, byte[].class,
1707                                        String.class, Wrapper.asPrimitiveType(c), String.class));
1708             }
1709         };
1710 
1711         // This one is deliberately non-lambdified to optimize startup time:
1712         private static final Function&lt;Class&lt;?&gt;, MethodHandle&gt; MIX = new Function&lt;&gt;() {
1713             @Override
1714             public MethodHandle apply(Class&lt;?&gt; c) {
1715                 return JLA.stringConcatHelper(&quot;mix&quot;, methodType(long.class, long.class, Wrapper.asPrimitiveType(c)));
1716             }
1717         };
1718 
1719         private static final MethodHandle SIMPLE;
1720         private static final MethodHandle NEW_STRING;
1721         private static final MethodHandle NEW_ARRAY;
1722         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; PREPENDERS;
1723         private static final ConcurrentMap&lt;Class&lt;?&gt;, MethodHandle&gt; MIXERS;
1724         private static final long INITIAL_CODER;
1725 
1726         static {
1727             try {
1728                 MethodHandle initCoder = JLA.stringConcatHelper(&quot;initialCoder&quot;, methodType(long.class));
1729                 INITIAL_CODER = (long) initCoder.invoke();
1730             } catch (Throwable e) {
1731                 throw new AssertionError(e);
1732             }
1733 
1734             PREPENDERS = new ConcurrentHashMap&lt;&gt;();
1735             MIXERS = new ConcurrentHashMap&lt;&gt;();
1736 
1737             SIMPLE     = JLA.stringConcatHelper(&quot;simpleConcat&quot;, methodType(String.class, Object.class, Object.class));
1738             NEW_STRING = JLA.stringConcatHelper(&quot;newString&quot;, methodType(String.class, byte[].class, long.class));
<a name="20" id="anc20"></a><span class="line-modified">1739             NEW_ARRAY  = JLA.stringConcatHelper(&quot;newArray&quot;, methodType(byte[].class, long.class));</span>
1740         }
1741     }
1742 
1743     /**
1744      * Public gateways to public &quot;stringify&quot; methods. These methods have the form String apply(T obj), and normally
1745      * delegate to {@code String.valueOf}, depending on argument&#39;s type.
1746      */
1747     private static final class Stringifiers {
1748         private Stringifiers() {
1749             // no instantiation
1750         }
1751 
1752         private static final MethodHandle OBJECT_INSTANCE =
1753                 JLA.stringConcatHelper(&quot;stringOf&quot;, methodType(String.class, Object.class));
1754 
1755         private static class FloatStringifiers {
1756             private static final MethodHandle FLOAT_INSTANCE =
1757                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, float.class);
1758 
1759             private static final MethodHandle DOUBLE_INSTANCE =
1760                     lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, double.class);
1761         }
1762 
1763         private static class StringifierAny extends ClassValue&lt;MethodHandle&gt; {
1764 
1765             private static final ClassValue&lt;MethodHandle&gt; INSTANCE = new StringifierAny();
1766 
1767             @Override
1768             protected MethodHandle computeValue(Class&lt;?&gt; cl) {
1769                 if (cl == byte.class || cl == short.class || cl == int.class) {
1770                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, int.class);
1771                 } else if (cl == boolean.class) {
1772                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, boolean.class);
1773                 } else if (cl == char.class) {
1774                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, char.class);
1775                 } else if (cl == long.class) {
1776                     return lookupStatic(MethodHandles.publicLookup(), String.class, &quot;valueOf&quot;, String.class, long.class);
1777                 } else {
1778                     MethodHandle mh = forMost(cl);
1779                     if (mh != null) {
1780                         return mh;
1781                     } else {
1782                         throw new IllegalStateException(&quot;Unknown class: &quot; + cl);
1783                     }
1784                 }
1785             }
1786         }
1787 
1788         /**
1789          * Returns a stringifier for references and floats/doubles only.
1790          * Always returns null for other primitives.
1791          *
1792          * @param t class to stringify
1793          * @return stringifier; null, if not available
1794          */
1795         static MethodHandle forMost(Class&lt;?&gt; t) {
1796             if (!t.isPrimitive()) {
1797                 return OBJECT_INSTANCE;
1798             } else if (t == float.class) {
1799                 return FloatStringifiers.FLOAT_INSTANCE;
1800             } else if (t == double.class) {
1801                 return FloatStringifiers.DOUBLE_INSTANCE;
1802             }
1803             return null;
1804         }
1805 
1806         /**
1807          * Returns a stringifier for any type. Never returns null.
1808          *
1809          * @param t class to stringify
1810          * @return stringifier
1811          */
1812         static MethodHandle forAny(Class&lt;?&gt; t) {
1813             return StringifierAny.INSTANCE.get(t);
1814         }
1815     }
1816 
1817     /* ------------------------------- Common utilities ------------------------------------ */
1818 
1819     static MethodHandle lookupStatic(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1820         try {
1821             return lookup.findStatic(refc, name, MethodType.methodType(rtype, ptypes));
1822         } catch (NoSuchMethodException | IllegalAccessException e) {
1823             throw new AssertionError(e);
1824         }
1825     }
1826 
1827     static MethodHandle lookupVirtual(Lookup lookup, Class&lt;?&gt; refc, String name, Class&lt;?&gt; rtype, Class&lt;?&gt;... ptypes) {
1828         try {
1829             return lookup.findVirtual(refc, name, MethodType.methodType(rtype, ptypes));
1830         } catch (NoSuchMethodException | IllegalAccessException e) {
1831             throw new AssertionError(e);
1832         }
1833     }
1834 
1835     static MethodHandle lookupConstructor(Lookup lookup, Class&lt;?&gt; refc, Class&lt;?&gt; ptypes) {
1836         try {
1837             return lookup.findConstructor(refc, MethodType.methodType(void.class, ptypes));
1838         } catch (NoSuchMethodException | IllegalAccessException e) {
1839             throw new AssertionError(e);
1840         }
1841     }
1842 
1843     static int estimateSize(Class&lt;?&gt; cl) {
1844         if (cl == Integer.TYPE) {
1845             return 11; // &quot;-2147483648&quot;
1846         } else if (cl == Boolean.TYPE) {
1847             return 5; // &quot;false&quot;
1848         } else if (cl == Byte.TYPE) {
1849             return 4; // &quot;-128&quot;
1850         } else if (cl == Character.TYPE) {
1851             return 1; // duh
1852         } else if (cl == Short.TYPE) {
1853             return 6; // &quot;-32768&quot;
1854         } else if (cl == Double.TYPE) {
1855             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1856         } else if (cl == Float.TYPE) {
1857             return 26; // apparently, no larger than this, see FloatingDecimal.BinaryToASCIIBuffer.buffer
1858         } else if (cl == Long.TYPE)  {
1859             return 20; // &quot;-9223372036854775808&quot;
1860         } else {
1861             throw new IllegalArgumentException(&quot;Cannot estimate the size for &quot; + cl);
1862         }
1863     }
1864 
1865     static Class&lt;?&gt; adaptToStringBuilder(Class&lt;?&gt; c) {
1866         if (c.isPrimitive()) {
1867             if (c == Byte.TYPE || c == Short.TYPE) {
1868                 return int.class;
1869             }
1870         } else {
1871             if (c != String.class) {
1872                 return Object.class;
1873             }
1874         }
1875         return c;
1876     }
1877 
1878     private StringConcatFactory() {
1879         // no instantiation
1880     }
1881 
1882 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
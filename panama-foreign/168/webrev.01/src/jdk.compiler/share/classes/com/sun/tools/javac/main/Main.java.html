<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/main/Main.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.main;
 27 
 28 import java.io.FileNotFoundException;
 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.PrintWriter;
 32 import java.io.Writer;
 33 import java.net.URL;
 34 import java.nio.file.Files;
 35 import java.nio.file.NoSuchFileException;
 36 import java.nio.file.Path;
 37 import java.nio.file.Paths;
 38 import java.security.CodeSource;
 39 import java.security.DigestInputStream;
 40 import java.security.MessageDigest;
 41 import java.security.NoSuchAlgorithmException;
 42 import java.text.SimpleDateFormat;
 43 import java.util.Calendar;
 44 import java.util.Set;
 45 import java.util.regex.Matcher;
 46 import java.util.regex.Pattern;
 47 
 48 import javax.tools.JavaFileManager;
 49 
 50 import com.sun.tools.javac.api.BasicJavacTask;
 51 import com.sun.tools.javac.file.CacheFSInfo;
 52 import com.sun.tools.javac.file.BaseFileManager;
 53 import com.sun.tools.javac.file.JavacFileManager;
 54 import com.sun.tools.javac.jvm.Target;
 55 import com.sun.tools.javac.main.CommandLine.UnmatchedQuote;
 56 import com.sun.tools.javac.platform.PlatformDescription;
 57 import com.sun.tools.javac.processing.AnnotationProcessingError;
 58 import com.sun.tools.javac.resources.CompilerProperties.Errors;
 59 import com.sun.tools.javac.util.*;
 60 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticInfo;
 61 import com.sun.tools.javac.util.Log.PrefixKind;
 62 import com.sun.tools.javac.util.Log.WriterKind;
 63 
 64 /** This class provides a command line interface to the javac compiler.
 65  *
 66  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 67  *  If you write code that depends on this, you do so at your own risk.
 68  *  This code and its internal interfaces are subject to change or
 69  *  deletion without notice.&lt;/b&gt;
 70  */
 71 public class Main {
 72 
 73     /** The name of the compiler, for use in diagnostics.
 74      */
 75     String ownName;
 76 
 77     /** The writer to use for normal output.
 78      */
 79     PrintWriter stdOut;
 80 
 81     /** The writer to use for diagnostic output.
 82      */
 83     PrintWriter stdErr;
 84 
 85     /** The log to use for diagnostic output.
 86      */
 87     public Log log;
 88 
 89     /**
 90      * If true, certain errors will cause an exception, such as command line
 91      * arg errors, or exceptions in user provided code.
 92      */
 93     boolean apiMode;
 94 
 95     private static final String ENV_OPT_NAME = &quot;JDK_JAVAC_OPTIONS&quot;;
 96 
 97     /** Result codes.
 98      */
 99     public enum Result {
100         OK(0),        // Compilation completed with no errors.
101         ERROR(1),     // Completed but reported errors.
102         CMDERR(2),    // Bad command-line arguments
103         SYSERR(3),    // System error or resource exhaustion.
104         ABNORMAL(4);  // Compiler terminated abnormally
105 
106         Result(int exitCode) {
107             this.exitCode = exitCode;
108         }
109 
110         public boolean isOK() {
111             return (exitCode == 0);
112         }
113 
114         public final int exitCode;
115     }
116 
117     /**
118      * Construct a compiler instance.
119      * @param name the name of this tool
120      */
121     public Main(String name) {
122         this.ownName = name;
123     }
124 
125     /**
126      * Construct a compiler instance.
127      * @param name the name of this tool
128      * @param out a stream to which to write messages
129      */
130     public Main(String name, PrintWriter out) {
131         this.ownName = name;
132         this.stdOut = this.stdErr = out;
133     }
134 
135     /**
136      * Construct a compiler instance.
137      * @param name the name of this tool
138      * @param out a stream to which to write expected output
139      * @param err a stream to which to write diagnostic output
140      */
141     public Main(String name, PrintWriter out, PrintWriter err) {
142         this.ownName = name;
143         this.stdOut = out;
144         this.stdErr = err;
145     }
146 
147     /** Report a usage error.
148      */
149     void reportDiag(DiagnosticInfo diag) {
150         if (apiMode) {
151             String msg = log.localize(diag);
152             throw new PropagatedException(new IllegalStateException(msg));
153         }
154         reportHelper(diag);
155         log.printLines(PrefixKind.JAVAC, &quot;msg.usage&quot;, ownName);
156     }
157 
158     /** Report helper.
159      */
160     void reportHelper(DiagnosticInfo diag) {
161         String msg = log.localize(diag);
162         String errorPrefix = log.localize(Errors.Error);
163         msg = msg.startsWith(errorPrefix) ? msg : errorPrefix + msg;
164         log.printRawLines(msg);
165     }
166 
167 
168     /**
169      * Programmatic interface for main function.
170      * @param args  the command line parameters
171      * @return the result of the compilation
172      */
173     public Result compile(String[] args) {
174         Context context = new Context();
175         JavacFileManager.preRegister(context); // can&#39;t create it until Log has been set up
176         Result result = compile(args, context);
177         try {
178             // A fresh context was created above, so the file manager can be safely closed:
179             if (fileManager != null)
180                 fileManager.close();
181         } catch (IOException ex) {
182             bugMessage(ex);
183         }
184         return result;
185     }
186 
187     /**
188      * Internal version of compile, allowing context to be provided.
189      * Note that the context needs to have a file manager set up.
190      * @param argv  the command line parameters
191      * @param context the context
192      * @return the result of the compilation
193      */
194     public Result compile(String[] argv, Context context) {
195         if (stdOut != null) {
196             context.put(Log.outKey, stdOut);
197         }
198 
199         if (stdErr != null) {
200             context.put(Log.errKey, stdErr);
201         }
202 
203         log = Log.instance(context);
204 
205         if (argv.length == 0) {
206             OptionHelper h = new OptionHelper.GrumpyHelper(log) {
207                 @Override
208                 public String getOwnName() { return ownName; }
209                 @Override
210                 public void put(String name, String value) { }
211             };
212             try {
213                 Option.HELP.process(h, &quot;-help&quot;);
214             } catch (Option.InvalidValueException ignore) {
215             }
216             return Result.CMDERR;
217         }
218 
219         // prefix argv with contents of environment variable and expand @-files
220         Iterable&lt;String&gt; allArgs;
221         try {
222             allArgs = CommandLine.parse(ENV_OPT_NAME, List.from(argv));
223         } catch (UnmatchedQuote ex) {
224             reportDiag(Errors.UnmatchedQuote(ex.variableName));
225             return Result.CMDERR;
226         } catch (FileNotFoundException | NoSuchFileException e) {
227             reportHelper(Errors.FileNotFound(e.getMessage()));
228             return Result.SYSERR;
229         } catch (IOException ex) {
230             log.printLines(PrefixKind.JAVAC, &quot;msg.io&quot;);
231             ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
232             return Result.SYSERR;
233         }
234 
235         Arguments args = Arguments.instance(context);
236         args.init(ownName, allArgs);
237 
238         if (log.nerrors &gt; 0)
239             return Result.CMDERR;
240 
241         Options options = Options.instance(context);
242 
243         // init Log
244         boolean forceStdOut = options.isSet(&quot;stdout&quot;);
245         if (forceStdOut) {
246             log.flush();
247             log.setWriters(new PrintWriter(System.out, true));
248         }
249 
250         // init CacheFSInfo
251         // allow System property in following line as a Mustang legacy
252         boolean batchMode = (options.isUnset(&quot;nonBatchMode&quot;)
253                     &amp;&amp; System.getProperty(&quot;nonBatchMode&quot;) == null);
254         if (batchMode)
255             CacheFSInfo.preRegister(context);
256 
257         boolean ok = true;
258 
259         // init file manager
260         fileManager = context.get(JavaFileManager.class);
261         JavaFileManager undel = fileManager instanceof DelegatingJavaFileManager ?
262                 ((DelegatingJavaFileManager) fileManager).getBaseFileManager() : fileManager;
263         if (undel instanceof BaseFileManager) {
264             ((BaseFileManager) undel).setContext(context); // reinit with options
265             ok &amp;= ((BaseFileManager) undel).handleOptions(args.getDeferredFileManagerOptions());
266         }
267 
268         // handle this here so it works even if no other options given
269         String showClass = options.get(&quot;showClass&quot;);
270         if (showClass != null) {
271             if (showClass.equals(&quot;showClass&quot;)) // no value given for option
272                 showClass = &quot;com.sun.tools.javac.Main&quot;;
273             showClass(showClass);
274         }
275 
276         ok &amp;= args.validate();
277         if (!ok || log.nerrors &gt; 0)
278             return Result.CMDERR;
279 
280         if (args.isEmpty())
281             return Result.OK;
282 
283         // init Dependencies
284         if (options.isSet(&quot;debug.completionDeps&quot;)) {
285             Dependencies.GraphDependencies.preRegister(context);
286         }
287 
288         BasicJavacTask t = (BasicJavacTask) BasicJavacTask.instance(context);
289 
290         // init plugins
291         Set&lt;List&lt;String&gt;&gt; pluginOpts = args.getPluginOpts();
292         t.initPlugins(pluginOpts);
293 
294         // init multi-release jar handling
295         if (fileManager.isSupportedOption(Option.MULTIRELEASE.primaryName) == 1) {
296             Target target = Target.instance(context);
297             List&lt;String&gt; list = List.of(target.multiReleaseValue());
298             fileManager.handleOption(Option.MULTIRELEASE.primaryName, list.iterator());
299         }
300 
301         // init JavaCompiler
302         JavaCompiler comp = JavaCompiler.instance(context);
303 
304         // init doclint
305         List&lt;String&gt; docLintOpts = args.getDocLintOpts();
306         if (!docLintOpts.isEmpty()) {
307             t.initDocLint(docLintOpts);
308         }
309 
310         if (options.get(Option.XSTDOUT) != null) {
311             // Stdout reassigned - ask compiler to close it when it is done
312             comp.closeables = comp.closeables.prepend(log.getWriter(WriterKind.NOTICE));
313         }
314 
315         boolean printArgsToFile = options.isSet(&quot;printArgsToFile&quot;);
316         try {
317             comp.compile(args.getFileObjects(), args.getClassNames(), null, List.nil());
318 
319             if (log.expectDiagKeys != null) {
320                 if (log.expectDiagKeys.isEmpty()) {
321                     log.printRawLines(&quot;all expected diagnostics found&quot;);
322                     return Result.OK;
323                 } else {
324                     log.printRawLines(&quot;expected diagnostic keys not found: &quot; + log.expectDiagKeys);
325                     return Result.ERROR;
326                 }
327             }
328 
329             return (comp.errorCount() == 0) ? Result.OK : Result.ERROR;
330 
331         } catch (OutOfMemoryError | StackOverflowError ex) {
332             resourceMessage(ex);
333             return Result.SYSERR;
334         } catch (FatalError ex) {
335             feMessage(ex, options);
336             return Result.SYSERR;
337         } catch (AnnotationProcessingError ex) {
338             apMessage(ex);
339             return Result.SYSERR;
340         } catch (PropagatedException ex) {
341             // TODO: what about errors from plugins?   should not simply rethrow the error here
342             throw ex.getCause();
343         } catch (IllegalAccessError iae) {
344             if (twoClassLoadersInUse(iae)) {
345                 bugMessage(iae);
346             }
347             printArgsToFile = true;
348             return Result.ABNORMAL;
349         } catch (Throwable ex) {
350             // Nasty.  If we&#39;ve already reported an error, compensate
351             // for buggy compiler error recovery by swallowing thrown
352             // exceptions.
353             if (comp == null || comp.errorCount() == 0 || options.isSet(&quot;dev&quot;))
354                 bugMessage(ex);
355             printArgsToFile = true;
356             return Result.ABNORMAL;
357         } finally {
358             if (printArgsToFile) {
359                 printArgumentsToFile(argv);
360             }
361             if (comp != null) {
362                 try {
363                     comp.close();
364                 } catch (ClientCodeException ex) {
365                     throw new RuntimeException(ex.getCause());
366                 }
367             }
368         }
369     }
370 
371     void printArgumentsToFile(String... params) {
372         Path out = Paths.get(String.format(&quot;javac.%s.args&quot;,
373                 new SimpleDateFormat(&quot;yyyyMMdd_HHmmss&quot;).format(Calendar.getInstance().getTime())));
374         String strOut = &quot;&quot;;
375         try {
376             try (Writer w = Files.newBufferedWriter(out)) {
377                 for (String param : params) {
378                     param = param.replaceAll(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;);
379                     if (param.matches(&quot;.*\\s+.*&quot;)) {
380                         param = &quot;\&quot;&quot; + param + &quot;\&quot;&quot;;
381                     }
382                     strOut += param + &#39;\n&#39;;
383                 }
384                 w.write(strOut);
385             }
386             log.printLines(PrefixKind.JAVAC, &quot;msg.parameters.output&quot;, out.toAbsolutePath());
387         } catch (IOException ioe) {
388             log.printLines(PrefixKind.JAVAC, &quot;msg.parameters.output.error&quot;, out.toAbsolutePath());
389             System.err.println(strOut);
390             System.err.println();
391         }
392     }
393 
394     private boolean twoClassLoadersInUse(IllegalAccessError iae) {
395         String msg = iae.getMessage();
396         Pattern pattern = Pattern.compile(&quot;(?i)(?&lt;=tried to access class )([a-z_$][a-z\\d_$]*\\.)*[a-z_$][a-z\\d_$]*&quot;);
397         Matcher matcher = pattern.matcher(msg);
398         if (matcher.find()) {
399             try {
400                 String otherClassName = matcher.group(0);
401                 Class&lt;?&gt; otherClass = Class.forName(otherClassName);
402                 ClassLoader otherClassLoader = otherClass.getClassLoader();
403                 ClassLoader javacClassLoader = this.getClass().getClassLoader();
404                 if (javacClassLoader != otherClassLoader) {
405                     CodeSource otherClassCodeSource = otherClass.getProtectionDomain().getCodeSource();
406                     CodeSource javacCodeSource = this.getClass().getProtectionDomain().getCodeSource();
407                     if (otherClassCodeSource != null &amp;&amp; javacCodeSource != null) {
408                         log.printLines(Errors.TwoClassLoaders2(otherClassCodeSource.getLocation(),
409                                 javacCodeSource.getLocation()));
410                     } else {
411                         log.printLines(Errors.TwoClassLoaders1);
412                     }
413                     return true;
414                 }
415             } catch (Throwable t) {
416                 return false;
417             }
418         }
419         return false;
420     }
421 
422     /** Print a message reporting an internal error.
423      */
424     void bugMessage(Throwable ex) {
425         log.printLines(PrefixKind.JAVAC, &quot;msg.bug&quot;, JavaCompiler.version());
426         ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
427     }
428 
429     /** Print a message reporting a fatal error.
430      */
431     void feMessage(Throwable ex, Options options) {
432         log.printRawLines(ex.getMessage());
433         if (ex.getCause() != null &amp;&amp; options.isSet(&quot;dev&quot;)) {
434             ex.getCause().printStackTrace(log.getWriter(WriterKind.NOTICE));
435         }
436     }
437 
438     /** Print a message reporting an input/output error.
439      */
440     void ioMessage(Throwable ex) {
441         log.printLines(PrefixKind.JAVAC, &quot;msg.io&quot;);
442         ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
443     }
444 
445     /** Print a message reporting an out-of-resources error.
446      */
447     void resourceMessage(Throwable ex) {
448         log.printLines(PrefixKind.JAVAC, &quot;msg.resource&quot;);
449         ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
450     }
451 
452     /** Print a message reporting an uncaught exception from an
453      * annotation processor.
454      */
455     void apMessage(AnnotationProcessingError ex) {
456         log.printLines(PrefixKind.JAVAC, &quot;msg.proc.annotation.uncaught.exception&quot;);
457         ex.getCause().printStackTrace(log.getWriter(WriterKind.NOTICE));
458     }
459 
460     /** Print a message reporting an uncaught exception from an
461      * annotation processor.
462      */
463     void pluginMessage(Throwable ex) {
464         log.printLines(PrefixKind.JAVAC, &quot;msg.plugin.uncaught.exception&quot;);
465         ex.printStackTrace(log.getWriter(WriterKind.NOTICE));
466     }
467 
468     /** Display the location and checksum of a class. */
469     void showClass(String className) {
470         PrintWriter pw = log.getWriter(WriterKind.NOTICE);
471         pw.println(&quot;javac: show class: &quot; + className);
472 
473         URL url = getClass().getResource(&#39;/&#39; + className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;);
474         if (url != null) {
475             pw.println(&quot;  &quot; + url);
476         }
477 
478         try (InputStream in = getClass().getResourceAsStream(&#39;/&#39; + className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;)) {
479             final String algorithm = &quot;SHA-256&quot;;
480             byte[] digest;
481             MessageDigest md = MessageDigest.getInstance(algorithm);
482             try (DigestInputStream din = new DigestInputStream(in, md)) {
483                 byte[] buf = new byte[8192];
484                 int n;
485                 do { n = din.read(buf); } while (n &gt; 0);
486                 digest = md.digest();
487             }
488             StringBuilder sb = new StringBuilder();
489             for (byte b: digest)
490                 sb.append(String.format(&quot;%02x&quot;, b));
491             pw.println(&quot;  &quot; + algorithm + &quot; checksum: &quot; + sb);
492         } catch (NoSuchAlgorithmException | IOException e) {
493             pw.println(&quot;  cannot compute digest: &quot; + e);
494         }
495     }
496 
497     // TODO: update this to JavacFileManager
498     private JavaFileManager fileManager;
499 
500     /* ************************************************************************
501      * Internationalization
502      *************************************************************************/
503 
504     public static final String javacBundleName =
505         &quot;com.sun.tools.javac.resources.javac&quot;;
506 }
    </pre>
  </body>
</html>
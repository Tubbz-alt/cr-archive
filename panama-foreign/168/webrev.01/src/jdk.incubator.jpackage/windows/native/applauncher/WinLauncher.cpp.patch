diff a/src/jdk.incubator.jpackage/windows/native/applauncher/WinLauncher.cpp b/src/jdk.incubator.jpackage/windows/native/applauncher/WinLauncher.cpp
--- a/src/jdk.incubator.jpackage/windows/native/applauncher/WinLauncher.cpp
+++ b/src/jdk.incubator.jpackage/windows/native/applauncher/WinLauncher.cpp
@@ -26,37 +26,114 @@
 #include <io.h>
 #include <fcntl.h>
 #include <windows.h>
 
 #include "AppLauncher.h"
+#include "JvmLauncher.h"
 #include "Log.h"
+#include "Dll.h"
+#include "Toolbox.h"
 #include "FileUtils.h"
 #include "UniqueHandle.h"
 #include "ErrorHandling.h"
+#include "WinSysInfo.h"
 #include "WinErrorHandling.h"
 
 
 // AllowSetForegroundWindow
 #pragma comment(lib, "user32")
 
 
 namespace {
 
+std::unique_ptr<Dll> loadDllWithAlteredPATH(const tstring& dllFullPath) {
+    LOG_TRACE_FUNCTION();
+
+    const tstring vanillaPathEnvVariable = SysInfo::getEnvVariable(_T("PATH"));
+
+    tstring pathEnvVariable = vanillaPathEnvVariable
+            + _T(";")
+            + FileUtils::dirname(dllFullPath);
+
+    SysInfo::setEnvVariable(_T("PATH"), pathEnvVariable);
+
+    LOG_TRACE(tstrings::any() << "New value of PATH: " << pathEnvVariable);
+
+    // Schedule restore of PATH after attempt to load the given dll
+    const auto resetPATH = runAtEndOfScope([&vanillaPathEnvVariable]() -> void {
+        SysInfo::setEnvVariable(_T("PATH"), vanillaPathEnvVariable);
+    });
+
+    return std::unique_ptr<Dll>(new Dll(dllFullPath));
+}
+
+std::unique_ptr<Dll> loadDllWithAddDllDirectory(const tstring& dllFullPath) {
+    LOG_TRACE_FUNCTION();
+
+    const tstring dirPath = FileUtils::dirname(dllFullPath);
+
+    typedef DLL_DIRECTORY_COOKIE(WINAPI *AddDllDirectoryFunc)(PCWSTR);
+
+    DllFunction<AddDllDirectoryFunc> _AddDllDirectory(
+            Dll("kernel32.dll", Dll::System()), "AddDllDirectory");
+
+    AddDllDirectoryFunc func = _AddDllDirectory;
+    DLL_DIRECTORY_COOKIE res = func(dirPath.c_str());
+    if (!res) {
+        JP_THROW(SysError(tstrings::any()
+                << "AddDllDirectory(" << dirPath << ") failed", func));
+    }
+
+    LOG_TRACE(tstrings::any() << "AddDllDirectory(" << dirPath << "): OK");
+
+    // Important: use LOAD_LIBRARY_SEARCH_DEFAULT_DIRS flag,
+    // but not LOAD_LIBRARY_SEARCH_USER_DIRS!
+    HMODULE dllHandle = LoadLibraryEx(dllFullPath.c_str(), NULL,
+            LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+
+    LOG_TRACE(tstrings::any() << "LoadLibraryEx(" << dllFullPath
+            << ", LOAD_LIBRARY_SEARCH_DEFAULT_DIRS): " << dllHandle);
+
+    const auto freeDll = runAtEndOfScope([&dllHandle]() -> void {
+        Dll::freeLibrary(dllHandle);
+    });
+
+    return std::unique_ptr<Dll>(new Dll(dllFullPath));
+}
+
 void launchApp() {
     // [RT-31061] otherwise UI can be left in back of other windows.
     ::AllowSetForegroundWindow(ASFW_ANY);
 
     const tstring launcherPath = SysInfo::getProcessModulePath();
     const tstring appImageRoot = FileUtils::dirname(launcherPath);
 
-    AppLauncher()
+    std::unique_ptr<Jvm> jvm(AppLauncher()
         .setImageRoot(appImageRoot)
         .addJvmLibName(_T("bin\\jli.dll"))
         .setAppDir(FileUtils::mkpath() << appImageRoot << _T("app"))
         .setDefaultRuntimePath(FileUtils::mkpath() << appImageRoot
                 << _T("runtime"))
-        .launch();
+        .createJvmLauncher());
+
+    std::unique_ptr<Dll> jvmDll;
+    try {
+        // Try load JVM DLL.
+        jvmDll = std::unique_ptr<Dll>(new Dll(jvm->getPath()));
+    } catch (const std::exception&) {
+        // JVM DLL load failed, though it exists in file system.
+        try {
+            // Try adjust the DLL search paths with AddDllDirectory() WINAPI CALL
+            jvmDll = loadDllWithAddDllDirectory(jvm->getPath());
+        } catch (const std::exception&) {
+            // AddDllDirectory() didn't work. Try altering PATH environment
+            // variable as the last resort.
+            jvmDll = loadDllWithAlteredPATH(jvm->getPath());
+        }
+    }
+
+    jvm->launch();
 }
 
 } // namespace
 
 

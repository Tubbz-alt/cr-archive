<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/hotspot/jtreg/compiler/compilercontrol/share/scenario/Scenario.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package compiler.compilercontrol.share.scenario;
 25 
 26 import compiler.compilercontrol.share.method.MethodDescriptor;
 27 import compiler.compilercontrol.share.pool.PoolHelper;
 28 import compiler.compilercontrol.share.processors.CommandProcessor;
 29 import compiler.compilercontrol.share.processors.LogProcessor;
 30 import compiler.compilercontrol.share.processors.PrintDirectivesProcessor;
 31 import compiler.compilercontrol.share.processors.PrintProcessor;
 32 import jdk.test.lib.Asserts;
 33 import jdk.test.lib.process.OutputAnalyzer;
 34 import jdk.test.lib.util.Pair;
 35 
 36 import java.lang.reflect.Executable;
 37 import java.util.ArrayList;
 38 import java.util.Collections;
 39 import java.util.HashMap;
 40 import java.util.LinkedHashSet;
 41 import java.util.List;
 42 import java.util.Map;
 43 import java.util.Set;
 44 import java.util.concurrent.Callable;
 45 import java.util.function.Consumer;
 46 
 47 /**
 48  * Test scenario
 49  */
 50 public final class Scenario {
 51     private final boolean isValid;
 52     private final Map&lt;Executable, State&gt; states;
 53     private final List&lt;Consumer&lt;OutputAnalyzer&gt;&gt; processors;
 54     private final Executor executor;
 55     private final Consumer&lt;List&lt;OutputAnalyzer&gt;&gt; jcmdProcessor;
 56 
 57     private Scenario(boolean isValid,
 58                      List&lt;String&gt; vmopts,
 59                      Map&lt;Executable, State&gt; states,
 60                      List&lt;CompileCommand&gt; compileCommands,
 61                      List&lt;JcmdCommand&gt; jcmdCommands,
 62                      List&lt;CompileCommand&gt; directives) {
 63         this.isValid = isValid;
 64         this.states = states;
 65         processors = new ArrayList&lt;&gt;();
 66         processors.add(new LogProcessor(states));
 67         processors.add(new PrintProcessor(states));
 68         List&lt;CompileCommand&gt; nonQuieted = new ArrayList&lt;&gt;();
 69         List&lt;CompileCommand&gt; quieted = new ArrayList&lt;&gt;();
 70         boolean metQuiet = false;
 71         for (CompileCommand cc : compileCommands) {
 72             metQuiet |= cc.command == Command.QUIET;
 73             if (metQuiet) {
 74                 quieted.add(cc);
 75             } else {
 76                 nonQuieted.add(cc);
 77             }
 78         }
 79         processors.add(new CommandProcessor(nonQuieted, quieted));
 80         List&lt;String&gt; jcmdExecCommands = new ArrayList&lt;&gt;();
 81         boolean addCommandMet = false;
 82         boolean printCommandMet = false;
 83         for (JcmdCommand cmd : jcmdCommands) {
 84             switch (cmd.jcmdType) {
 85                 case ADD:
 86                     if (!addCommandMet) {
 87                         jcmdExecCommands.add(JcmdType.ADD.command);
 88                     }
 89                     addCommandMet = true;
 90                     break;
 91                 case PRINT:
 92                     printCommandMet = true;
 93                     break;
 94                 default:
 95                     jcmdExecCommands.add(cmd.jcmdType.command);
 96                     break;
 97             }
 98         }
 99         // Add print command only in the end to get directives printed
100         if (printCommandMet) {
101             jcmdExecCommands.add(JcmdType.PRINT.command);
102         }
103         jcmdProcessor = new PrintDirectivesProcessor(directives);
104         executor = new Executor(isValid, vmopts, states, jcmdExecCommands);
105     }
106 
107     /**
108      * Executes scenario
109      */
110     public void execute() {
111         List&lt;OutputAnalyzer&gt; outputList = executor.execute();
112         // The first one contains output from the test VM
113         OutputAnalyzer mainOuput = outputList.get(0);
114         if (isValid) {
115             mainOuput.shouldHaveExitValue(0);
116             processors.forEach(processor -&gt; processor.accept(mainOuput));
117             // only the last output contains directives got from print command
118             List&lt;OutputAnalyzer&gt; last = new ArrayList&lt;&gt;();
119             last.add(outputList.get(outputList.size() - 1));
120             jcmdProcessor.accept(last);
121         } else {
122             Asserts.assertNE(mainOuput.getExitValue(), 0, &quot;VM should exit with &quot;
123                     + &quot;error for incorrect directives&quot;);
124             mainOuput.shouldContain(&quot;Parsing of compiler directives failed&quot;);
125         }
126     }
127 
128     /**
129      * Gets states of methods for this scenario
130      *
131      * @return pairs of executable and its state
132      */
133     public Map&lt;Executable, State&gt; getStates() {
134         return states;
135     }
136 
137     public static enum Compiler {
138         C1(&quot;c1&quot;),
139         C2(&quot;c2&quot;);
140 
141         public final String name;
142 
143         Compiler(String name) {
144             this.name = name;
145         }
146     }
147 
148     /**
149      * Type of diagnostic (jcmd) command
150      */
151     public static enum JcmdType {
152         ADD(&quot;Compiler.directives_add &quot; + Type.JCMD.fileName),
153         PRINT(&quot;Compiler.directives_print&quot;),
154         CLEAR(&quot;Compiler.directives_clear&quot;),
155         REMOVE(&quot;Compiler.directives_remove&quot;);
156 
157         public final String command;
158         private JcmdType(String command) {
159             this.command = command;
160         }
161     }
162 
163     /**
164      * Type of the compile command
165      */
166     public static enum Type {
167         OPTION(&quot;&quot;),
168         FILE(&quot;command_file&quot;),
169         DIRECTIVE(&quot;directives.json&quot;),
170         JCMD(&quot;jcmd_directives.json&quot;) {
171             @Override
172             public CompileCommand createCompileCommand(Command command,
173                     MethodDescriptor md, Compiler compiler) {
174                 return new JcmdCommand(command, md, compiler, this,
175                         JcmdType.ADD);
176             }
177         };
178 
179         public final String fileName;
180 
181         public CompileCommand createCompileCommand(Command command,
182                 MethodDescriptor md, Compiler compiler) {
183             return new CompileCommand(command, md, compiler, this);
184         }
185 
186         private Type(String fileName) {
187             this.fileName = fileName;
188         }
189     }
190 
191     public static Builder getBuilder() {
192         return new Builder();
193     }
194 
195     public static class Builder {
196         private final Set&lt;String&gt; vmopts = new LinkedHashSet&lt;&gt;();
197         private final Map&lt;Type, StateBuilder&lt;CompileCommand&gt;&gt; builders
198                 = new HashMap&lt;&gt;();
199         private final JcmdStateBuilder jcmdStateBuilder;
200         private final List&lt;JcmdCommand&gt; jcmdCommands = new ArrayList&lt;&gt;();
201         private boolean logCommandMet = false;
202 
203         public Builder() {
204             addFlag(&quot;-Xmixed&quot;);
205             builders.put(Type.FILE, new CommandFileBuilder(Type.FILE.fileName));
206             builders.put(Type.OPTION, new CommandOptionsBuilder());
207             builders.put(Type.DIRECTIVE, new DirectiveBuilder(
208                     Type.DIRECTIVE.fileName));
209             jcmdStateBuilder = new JcmdStateBuilder(Type.JCMD.fileName);
210         }
211 
212         public void addFlag(String flag) {
213             vmopts.add(flag);
214         }
215 
216         public void add(CompileCommand compileCommand) {
<a name="2" id="anc2"></a><span class="line-added">217             System.out.println(compileCommand);</span>
218             String[] vmOptions = compileCommand.command.vmOpts;
219             Collections.addAll(vmopts, vmOptions);
220             if (compileCommand.command == Command.LOG) {
221                 logCommandMet = true;
222             }
223             if (compileCommand.type == Type.JCMD) {
224                 jcmdStateBuilder.add((JcmdCommand) compileCommand);
225                 jcmdCommands.add((JcmdCommand) compileCommand);
226             } else {
227                 StateBuilder&lt;CompileCommand&gt; builder = builders.get(
228                         compileCommand.type);
229                 if (builder == null) {
230                     throw new Error(&quot;TESTBUG: Missing builder for the type: &quot;
231                             + compileCommand.type);
232                 }
233                 builder.add(compileCommand);
234             }
235         }
236 
237         public Scenario build() {
238             boolean isValid = true;
239 
240             // Get states from each of the state builders
241             Map&lt;Executable, State&gt; commandFileStates
242                     = builders.get(Type.FILE).getStates();
243             Map&lt;Executable, State&gt; commandOptionStates
244                     = builders.get(Type.OPTION).getStates();
245             Map&lt;Executable, State&gt; directiveFileStates
246                     = builders.get(Type.DIRECTIVE).getStates();
247 
248             // check if directives stack was cleared by jcmd
249             boolean isClearedState = false;
250             if (jcmdContainsCommand(JcmdType.CLEAR)) {
251                 isClearedState = true;
252             }
253 
254             // Merge states
255             List&lt;Pair&lt;Executable, Callable&lt;?&gt;&gt;&gt; methods = new PoolHelper()
256                     .getAllMethods();
257             Map&lt;Executable, State&gt; finalStates = new HashMap&lt;&gt;();
258             Map&lt;Executable, State&gt; jcmdStates = jcmdStateBuilder.getStates();
259             for (Pair&lt;Executable, Callable&lt;?&gt;&gt; pair : methods) {
260                 Executable x = pair.first;
261                 State commandOptionState = commandOptionStates.get(x);
262                 State commandFileState = commandFileStates.get(x);
263                 State st = State.merge(commandOptionState, commandFileState);
264                 if (!isClearedState) {
265                     State directiveState = directiveFileStates.get(x);
266                     State jcmdState = jcmdStates.get(x);
267                     if (jcmdState != null) {
268                         st = State.merge(st, jcmdState);
269                     } else if (directiveState != null) {
270                         st = State.merge(st, directiveState);
271                     }
272                 }
273                 finalStates.put(x, st);
274             }
275 
276             /*
277              * Create a list of commands from options and file
278              * to handle quiet command
279              */
280             List&lt;CompileCommand&gt; ccList = new ArrayList&lt;&gt;();
281             ccList.addAll(builders.get(Type.OPTION).getCompileCommands());
282             ccList.addAll(builders.get(Type.FILE).getCompileCommands());
283 
284             // Create a list of directives to check which one was printed
285             List&lt;CompileCommand&gt; directives = new ArrayList&lt;&gt;();
286             if (jcmdContainsCommand(JcmdType.PRINT)) {
287                 if (!isClearedState) {
288                     directives.addAll(builders.get(Type.DIRECTIVE)
289                             .getCompileCommands());
290                 }
291                 directives.addAll(jcmdStateBuilder.getCompileCommands());
292             }
293 
294             // Get all VM options after we build all states and files
295             List&lt;String&gt; options = new ArrayList&lt;&gt;();
296             options.addAll(vmopts);
297             for (StateBuilder&lt;?&gt; builder : builders.values()) {
298                 options.addAll(builder.getOptions());
299                 isValid &amp;= builder.isValid();
300             }
301             options.addAll(jcmdStateBuilder.getOptions());
302 
303             /*
304              * Update final states if LogCompilation is enabled and
305              * there is no any log command, then all methods should be logged
306              */
307             boolean isLogComp = vmopts.stream()
308                     .anyMatch(opt -&gt; opt.contains(&quot;-XX:+LogCompilation&quot;));
309             if (isLogComp &amp;&amp; !logCommandMet) {
310                 finalStates.entrySet()
311                         .forEach(entry -&gt; entry.getValue().setLog(true));
312             }
313 
314             return new Scenario(isValid, options, finalStates, ccList,
315                     jcmdCommands, directives);
316         }
317 
318         // shows if jcmd have passed a specified jcmd command type
319         private boolean jcmdContainsCommand(JcmdType type) {
320             for (JcmdCommand jcmdCommand : jcmdCommands) {
321                 if (jcmdCommand.jcmdType == type) {
322                     return true;
323                 }
324             }
325             return false;
326         }
327     }
328 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
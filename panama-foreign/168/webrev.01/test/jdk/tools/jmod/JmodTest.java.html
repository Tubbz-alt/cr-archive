<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/tools/jmod/JmodTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /**
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8142968 8166568 8166286 8170618 8168149 8240910
 27  * @summary Basic test for jmod
 28  * @library /test/lib
 29  * @modules jdk.compiler
 30  *          jdk.jlink
 31  * @build jdk.test.lib.compiler.CompilerUtils
 32  *        jdk.test.lib.util.FileUtils
 33  *        jdk.test.lib.Platform
 34  * @run testng/othervm -Djava.io.tmpdir=. JmodTest
 35  */
 36 
 37 import java.io.*;
 38 import java.lang.module.ModuleDescriptor;
 39 import java.lang.reflect.Method;
 40 import java.nio.file.*;
 41 import java.util.*;
 42 import java.util.function.Consumer;
 43 import java.util.regex.Pattern;
 44 import java.util.spi.ToolProvider;
 45 import java.util.stream.Stream;
 46 import jdk.test.lib.compiler.CompilerUtils;
 47 import jdk.test.lib.util.FileUtils;
 48 import org.testng.annotations.BeforeTest;
 49 import org.testng.annotations.Test;
 50 
 51 import static java.io.File.pathSeparator;
 52 import static java.lang.module.ModuleDescriptor.Version;
 53 import static java.nio.charset.StandardCharsets.UTF_8;
 54 import static java.util.stream.Collectors.toSet;
 55 import static org.testng.Assert.*;
 56 
 57 public class JmodTest {
 58 
 59     static final ToolProvider JMOD_TOOL = ToolProvider.findFirst(&quot;jmod&quot;)
 60         .orElseThrow(() -&gt;
 61             new RuntimeException(&quot;jmod tool not found&quot;)
 62         );
 63     static final ToolProvider JAR_TOOL = ToolProvider.findFirst(&quot;jar&quot;)
 64         .orElseThrow(() -&gt;
 65             new RuntimeException(&quot;jar tool not found&quot;)
 66         );
 67 
 68     static final String TEST_SRC = System.getProperty(&quot;test.src&quot;, &quot;.&quot;);
 69     static final Path SRC_DIR = Paths.get(TEST_SRC, &quot;src&quot;);
 70     static final Path EXPLODED_DIR = Paths.get(&quot;build&quot;);
 71     static final Path MODS_DIR = Paths.get(&quot;jmods&quot;);
 72 
 73     static final String CLASSES_PREFIX = &quot;classes/&quot;;
 74     static final String CMDS_PREFIX = &quot;bin/&quot;;
 75     static final String LIBS_PREFIX = &quot;lib/&quot;;
 76     static final String CONFIGS_PREFIX = &quot;conf/&quot;;
 77 
 78     @BeforeTest
 79     public void buildExplodedModules() throws IOException {
 80         if (Files.exists(EXPLODED_DIR))
 81             FileUtils.deleteFileTreeWithRetry(EXPLODED_DIR);
 82 
 83         for (String name : new String[] { &quot;foo&quot;/*, &quot;bar&quot;, &quot;baz&quot;*/ } ) {
 84             Path dir = EXPLODED_DIR.resolve(name);
 85             assertTrue(compileModule(name, dir.resolve(&quot;classes&quot;)));
 86             copyResource(SRC_DIR.resolve(&quot;foo&quot;),
 87                          dir.resolve(&quot;classes&quot;),
 88                          &quot;jdk/test/foo/resources/foo.properties&quot;);
 89             createCmds(dir.resolve(&quot;bin&quot;));
 90             createLibs(dir.resolve(&quot;lib&quot;));
 91             createConfigs(dir.resolve(&quot;conf&quot;));
 92         }
 93 
 94         if (Files.exists(MODS_DIR))
 95             FileUtils.deleteFileTreeWithRetry(MODS_DIR);
 96         Files.createDirectories(MODS_DIR);
 97     }
 98 
 99     // JDK-8166286 - jmod fails on symlink to directory
100     @Test
101     public void testSymlinks() throws IOException {
102         Path apaDir = EXPLODED_DIR.resolve(&quot;apa&quot;);
103         Path classesDir = EXPLODED_DIR.resolve(&quot;apa&quot;).resolve(&quot;classes&quot;);
104         assertTrue(compileModule(&quot;apa&quot;, classesDir));
105         Path libDir = apaDir.resolve(&quot;lib&quot;);
106         createFiles(libDir, List.of(&quot;foo/bar/libfoo.so&quot;));
107         try {
108             Path link = Files.createSymbolicLink(
109                 libDir.resolve(&quot;baz&quot;), libDir.resolve(&quot;foo&quot;).toAbsolutePath());
110             assertTrue(Files.exists(link));
111         } catch (IOException|UnsupportedOperationException uoe) {
112             // OS does not support symlinks. Nothing to test!
113             return;
114         }
115 
116         Path jmod = MODS_DIR.resolve(&quot;apa.jmod&quot;);
117         jmod(&quot;create&quot;,
118              &quot;--libs=&quot; + libDir.toString(),
119              &quot;--class-path&quot;, classesDir.toString(),
120              jmod.toString())
121             .assertSuccess();
122     }
123 
124     // JDK-8170618 - jmod should validate if any exported or open package is missing
125     @Test
126     public void testMissingPackages() throws IOException {
127         Path apaDir = EXPLODED_DIR.resolve(&quot;apa&quot;);
128         Path classesDir = EXPLODED_DIR.resolve(&quot;apa&quot;).resolve(&quot;classes&quot;);
129         if (Files.exists(classesDir))
130             FileUtils.deleteFileTreeWithRetry(classesDir);
131         assertTrue(compileModule(&quot;apa&quot;, classesDir));
132         FileUtils.deleteFileTreeWithRetry(classesDir.resolve(&quot;jdk&quot;));
133         Path jmod = MODS_DIR.resolve(&quot;apa.jmod&quot;);
134         jmod(&quot;create&quot;,
135              &quot;--class-path&quot;, classesDir.toString(),
136              jmod.toString())
137             .assertFailure()
138             .resultChecker(r -&gt; {
139                 assertContains(r.output, &quot;Packages that are exported or open in apa are not present: [jdk.test.apa]&quot;);
140             });
141         if (Files.exists(classesDir))
142             FileUtils.deleteFileTreeWithRetry(classesDir);
143     }
144 
145     @Test
146     public void testList() throws IOException {
147         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
148         jmod(&quot;create&quot;,
149              &quot;--class-path&quot;, cp,
150              MODS_DIR.resolve(&quot;foo.jmod&quot;).toString())
151             .assertSuccess();
152 
153         jmod(&quot;list&quot;,
154              MODS_DIR.resolve(&quot;foo.jmod&quot;).toString())
155             .assertSuccess()
156             .resultChecker(r -&gt; {
157                 // asserts dependent on the exact contents of foo
158                 assertContains(r.output, CLASSES_PREFIX + &quot;module-info.class&quot;);
159                 assertContains(r.output, CLASSES_PREFIX + &quot;jdk/test/foo/Foo.class&quot;);
160                 assertContains(r.output, CLASSES_PREFIX + &quot;jdk/test/foo/internal/Message.class&quot;);
161                 assertContains(r.output, CLASSES_PREFIX + &quot;jdk/test/foo/resources/foo.properties&quot;);
162             });
163     }
164 
165     @Test
166     public void testExtractCWD() throws IOException {
167         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
168         jmod(&quot;create&quot;,
169              &quot;--class-path&quot;, cp.toString(),
170              MODS_DIR.resolve(&quot;fooExtractCWD.jmod&quot;).toString())
171             .assertSuccess();
172 
173         jmod(&quot;extract&quot;,
174              MODS_DIR.resolve(&quot;fooExtractCWD.jmod&quot;).toString())
175             .assertSuccess()
176             .resultChecker(r -&gt; {
177                 // module-info should exist, but jmod will have added its Packages attr.
178                 assertTrue(Files.exists(Paths.get(&quot;classes/module-info.class&quot;)));
179                 assertSameContent(cp.resolve(&quot;jdk/test/foo/Foo.class&quot;),
180                                   Paths.get(&quot;classes/jdk/test/foo/Foo.class&quot;));
181                 assertSameContent(cp.resolve(&quot;jdk/test/foo/internal/Message.class&quot;),
182                                   Paths.get(&quot;classes/jdk/test/foo/internal/Message.class&quot;));
183                 assertSameContent(cp.resolve(&quot;jdk/test/foo/resources/foo.properties&quot;),
184                                   Paths.get(&quot;classes/jdk/test/foo/resources/foo.properties&quot;));
185             });
186     }
187 
188     @Test
189     public void testExtractDir() throws IOException {
190         if (Files.exists(Paths.get(&quot;extractTestDir&quot;)))
191             FileUtils.deleteFileTreeWithRetry(Paths.get(&quot;extractTestDir&quot;));
192         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
193         Path bp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;bin&quot;);
194         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
195         Path cf = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;conf&quot;);
196 
197         jmod(&quot;create&quot;,
198              &quot;--conf&quot;, cf.toString(),
199              &quot;--cmds&quot;, bp.toString(),
200              &quot;--libs&quot;, lp.toString(),
201              &quot;--class-path&quot;, cp.toString(),
202              MODS_DIR.resolve(&quot;fooExtractDir.jmod&quot;).toString())
203             .assertSuccess();
204 
205         jmod(&quot;extract&quot;,
206              &quot;--dir&quot;, &quot;extractTestDir&quot;,
207              MODS_DIR.resolve(&quot;fooExtractDir.jmod&quot;).toString())
208             .assertSuccess();
209 
210         jmod(&quot;extract&quot;,
211              &quot;--dir&quot;, &quot;extractTestDir&quot;,
212              MODS_DIR.resolve(&quot;fooExtractDir.jmod&quot;).toString())
213             .assertSuccess()
214             .resultChecker(r -&gt; {
215                 // check a sample of the extracted files
216                 Path p = Paths.get(&quot;extractTestDir&quot;);
217                 assertTrue(Files.exists(p.resolve(&quot;classes/module-info.class&quot;)));
218                 assertSameContent(cp.resolve(&quot;jdk/test/foo/Foo.class&quot;),
219                                   p.resolve(&quot;classes/jdk/test/foo/Foo.class&quot;));
220                 assertSameContent(bp.resolve(&quot;first&quot;),
221                                   p.resolve(CMDS_PREFIX).resolve(&quot;first&quot;));
222                 assertSameContent(lp.resolve(&quot;first.so&quot;),
223                                   p.resolve(LIBS_PREFIX).resolve(&quot;second.so&quot;));
224                 assertSameContent(cf.resolve(&quot;second.cfg&quot;),
225                                   p.resolve(CONFIGS_PREFIX).resolve(&quot;second.cfg&quot;));
226             });
227     }
228 
229     @Test
230     public void testMainClass() throws IOException {
231         Path jmod = MODS_DIR.resolve(&quot;fooMainClass.jmod&quot;);
232         FileUtils.deleteFileIfExistsWithRetry(jmod);
233         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
234 
235         jmod(&quot;create&quot;,
236              &quot;--class-path&quot;, cp,
237              &quot;--main-class&quot;, &quot;jdk.test.foo.Foo&quot;,
238              jmod.toString())
239             .assertSuccess()
240             .resultChecker(r -&gt; {
241                 Optional&lt;String&gt; omc = getModuleDescriptor(jmod).mainClass();
242                 assertTrue(omc.isPresent());
243                 assertEquals(omc.get(), &quot;jdk.test.foo.Foo&quot;);
244             });
245     }
246 
247     @Test
248     public void testModuleVersion() throws IOException {
249         Path jmod = MODS_DIR.resolve(&quot;fooVersion.jmod&quot;);
250         FileUtils.deleteFileIfExistsWithRetry(jmod);
251         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
252 
253         jmod(&quot;create&quot;,
254              &quot;--class-path&quot;, cp,
255              &quot;--module-version&quot;, &quot;5.4.3&quot;,
256              jmod.toString())
257             .assertSuccess()
258             .resultChecker(r -&gt; {
259                 Optional&lt;Version&gt; ov = getModuleDescriptor(jmod).version();
260                 assertTrue(ov.isPresent());
261                 assertEquals(ov.get().toString(), &quot;5.4.3&quot;);
262             });
263     }
264 
265     @Test
266     public void testConfig() throws IOException {
267         Path jmod = MODS_DIR.resolve(&quot;fooConfig.jmod&quot;);
268         FileUtils.deleteFileIfExistsWithRetry(jmod);
269         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
270         Path cf = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;conf&quot;);
271 
272         jmod(&quot;create&quot;,
273              &quot;--class-path&quot;, cp.toString(),
274              &quot;--config&quot;, cf.toString(),
275              jmod.toString())
276             .assertSuccess()
277             .resultChecker(r -&gt; {
278                 try (Stream&lt;String&gt; s1 = findFiles(cf).map(p -&gt; CONFIGS_PREFIX + p);
279                      Stream&lt;String&gt; s2 = findFiles(cp).map(p -&gt; CLASSES_PREFIX + p)) {
280                     Set&lt;String&gt; expectedFilenames = Stream.concat(s1, s2)
281                                                           .collect(toSet());
282                     assertJmodContent(jmod, expectedFilenames);
283                 }
284             });
285     }
286 
287     @Test
288     public void testCmds() throws IOException {
289         Path jmod = MODS_DIR.resolve(&quot;fooCmds.jmod&quot;);
290         FileUtils.deleteFileIfExistsWithRetry(jmod);
291         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
292         Path bp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;bin&quot;);
293 
294         jmod(&quot;create&quot;,
295              &quot;--cmds&quot;, bp.toString(),
296              &quot;--class-path&quot;, cp.toString(),
297              jmod.toString())
298             .assertSuccess()
299             .resultChecker(r -&gt; {
300                 try (Stream&lt;String&gt; s1 = findFiles(bp).map(p -&gt; CMDS_PREFIX + p);
301                      Stream&lt;String&gt; s2 = findFiles(cp).map(p -&gt; CLASSES_PREFIX + p)) {
302                     Set&lt;String&gt; expectedFilenames = Stream.concat(s1,s2)
303                                                           .collect(toSet());
304                     assertJmodContent(jmod, expectedFilenames);
305                 }
306             });
307     }
308 
309     @Test
310     public void testLibs() throws IOException {
311         Path jmod = MODS_DIR.resolve(&quot;fooLibs.jmod&quot;);
312         FileUtils.deleteFileIfExistsWithRetry(jmod);
313         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
314         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
315 
316         jmod(&quot;create&quot;,
317              &quot;--libs=&quot; + lp.toString(),
318              &quot;--class-path&quot;, cp.toString(),
319              jmod.toString())
320             .assertSuccess()
321             .resultChecker(r -&gt; {
322                 try (Stream&lt;String&gt; s1 = findFiles(lp).map(p -&gt; LIBS_PREFIX + p);
323                      Stream&lt;String&gt; s2 = findFiles(cp).map(p -&gt; CLASSES_PREFIX + p)) {
324                     Set&lt;String&gt; expectedFilenames = Stream.concat(s1,s2)
325                                                           .collect(toSet());
326                     assertJmodContent(jmod, expectedFilenames);
327                 }
328             });
329     }
330 
331     @Test
332     public void testAll() throws IOException {
333         Path jmod = MODS_DIR.resolve(&quot;fooAll.jmod&quot;);
334         FileUtils.deleteFileIfExistsWithRetry(jmod);
335         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
336         Path bp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;bin&quot;);
337         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
338         Path cf = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;conf&quot;);
339 
340         jmod(&quot;create&quot;,
341              &quot;--conf&quot;, cf.toString(),
342              &quot;--cmds=&quot; + bp.toString(),
343              &quot;--libs=&quot; + lp.toString(),
344              &quot;--class-path&quot;, cp.toString(),
345              jmod.toString())
346             .assertSuccess()
347             .resultChecker(r -&gt; {
348                 try (Stream&lt;String&gt; s1 = findFiles(lp).map(p -&gt; LIBS_PREFIX + p);
349                      Stream&lt;String&gt; s2 = findFiles(cp).map(p -&gt; CLASSES_PREFIX + p);
350                      Stream&lt;String&gt; s3 = findFiles(bp).map(p -&gt; CMDS_PREFIX + p);
351                      Stream&lt;String&gt; s4 = findFiles(cf).map(p -&gt; CONFIGS_PREFIX + p)) {
352                     Set&lt;String&gt; expectedFilenames = Stream.concat(Stream.concat(s1,s2),
353                                                                   Stream.concat(s3, s4))
354                                                           .collect(toSet());
355                     assertJmodContent(jmod, expectedFilenames);
356                 }
357             });
358     }
359 
360     @Test
361     public void testExcludes() throws IOException {
362         Path jmod = MODS_DIR.resolve(&quot;fooLibs.jmod&quot;);
363         FileUtils.deleteFileIfExistsWithRetry(jmod);
364         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
365         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
366 
367         jmod(&quot;create&quot;,
368              &quot;--libs=&quot; + lp.toString(),
369              &quot;--class-path&quot;, cp.toString(),
370              &quot;--exclude&quot;, &quot;**internal**&quot;,
371              &quot;--exclude&quot;, &quot;first.so&quot;,
372              jmod.toString())
373              .assertSuccess()
374              .resultChecker(r -&gt; {
375                  Set&lt;String&gt; expectedFilenames = new HashSet&lt;&gt;();
376                  expectedFilenames.add(CLASSES_PREFIX + &quot;module-info.class&quot;);
377                  expectedFilenames.add(CLASSES_PREFIX + &quot;jdk/test/foo/Foo.class&quot;);
378                  expectedFilenames.add(CLASSES_PREFIX + &quot;jdk/test/foo/resources/foo.properties&quot;);
379                  expectedFilenames.add(LIBS_PREFIX + &quot;second.so&quot;);
380                  expectedFilenames.add(LIBS_PREFIX + &quot;third/third.so&quot;);
381                  assertJmodContent(jmod, expectedFilenames);
382 
383                  Set&lt;String&gt; unexpectedFilenames = new HashSet&lt;&gt;();
384                  unexpectedFilenames.add(CLASSES_PREFIX + &quot;jdk/test/foo/internal/Message.class&quot;);
385                  unexpectedFilenames.add(LIBS_PREFIX + &quot;first.so&quot;);
386                  assertJmodDoesNotContain(jmod, unexpectedFilenames);
387              });
388     }
389 
390     @Test
391     public void describe() throws IOException {
392         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
393         jmod(&quot;create&quot;,
394              &quot;--class-path&quot;, cp,
395               MODS_DIR.resolve(&quot;describeFoo.jmod&quot;).toString())
396              .assertSuccess();
397 
398         jmod(&quot;describe&quot;,
399              MODS_DIR.resolve(&quot;describeFoo.jmod&quot;).toString())
400              .assertSuccess()
401              .resultChecker(r -&gt; {
402                  // Expect similar output: &quot;foo... exports jdk.test.foo ...
403                  //   ... requires java.base mandated... contains jdk.test.foo.internal&quot;
404                  Pattern p = Pattern.compile(&quot;foo\\s+exports\\s+jdk.test.foo&quot;);
405                  assertTrue(p.matcher(r.output).find(),
406                            &quot;Expecting to find \&quot;foo... exports jdk.test.foo\&quot;&quot; +
407                                 &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
408                  p = Pattern.compile(
409                         &quot;requires\\s+java.base\\s+mandated\\s+contains\\s+jdk.test.foo.internal&quot;);
410                  assertTrue(p.matcher(r.output).find(),
411                            &quot;Expecting to find \&quot;requires java.base mandated..., &quot; +
412                                 &quot;contains jdk.test.foo.internal ...\&quot;&quot; +
413                                 &quot;in output, but did not: [&quot; + r.output + &quot;]&quot;);
414              });
415     }
416 
417     @Test
418     public void testDuplicateEntries() throws IOException {
419         Path jmod = MODS_DIR.resolve(&quot;testDuplicates.jmod&quot;);
420         FileUtils.deleteFileIfExistsWithRetry(jmod);
421         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
422         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
423 
424         jmod(&quot;create&quot;,
425              &quot;--class-path&quot;, cp + pathSeparator + cp,
426              jmod.toString())
427              .assertSuccess()
428              .resultChecker(r -&gt;
429                  assertContains(r.output, &quot;Warning: ignoring duplicate entry&quot;)
430              );
431 
432         FileUtils.deleteFileIfExistsWithRetry(jmod);
433         jmod(&quot;create&quot;,
434              &quot;--class-path&quot;, cp,
435              &quot;--libs&quot;, lp.toString() + pathSeparator + lp.toString(),
436              jmod.toString())
437              .assertSuccess()
438              .resultChecker(r -&gt;
439                  assertContains(r.output, &quot;Warning: ignoring duplicate entry&quot;)
440              );
441     }
442 
443     @Test
444     public void testDuplicateEntriesFromJarFile() throws IOException {
445         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
446         Path jar = Paths.get(&quot;foo.jar&quot;);
447         Path jmod = MODS_DIR.resolve(&quot;testDuplicates.jmod&quot;);
448         FileUtils.deleteFileIfExistsWithRetry(jar);
449         FileUtils.deleteFileIfExistsWithRetry(jmod);
450         // create JAR file
451         assertTrue(JAR_TOOL.run(System.out, System.err, &quot;cf&quot;, jar.toString(), &quot;-C&quot;, cp, &quot;.&quot;) == 0);
452 
453         jmod(&quot;create&quot;,
454              &quot;--class-path&quot;, jar.toString() + pathSeparator + jar.toString(),
455              jmod.toString())
456              .assertSuccess()
457              .resultChecker(r -&gt;
458                  assertContains(r.output, &quot;Warning: ignoring duplicate entry&quot;)
459              );
460     }
461 
462     @Test
463     public void testIgnoreModuleInfoInOtherSections() throws IOException {
464         Path jmod = MODS_DIR.resolve(&quot;testIgnoreModuleInfoInOtherSections.jmod&quot;);
465         FileUtils.deleteFileIfExistsWithRetry(jmod);
466         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
467 
468         jmod(&quot;create&quot;,
469             &quot;--class-path&quot;, cp,
470             &quot;--libs&quot;, cp,
471             jmod.toString())
472             .assertSuccess()
473             .resultChecker(r -&gt;
474                 assertContains(r.output, &quot;Warning: ignoring entry&quot;)
475             );
476 
477         FileUtils.deleteFileIfExistsWithRetry(jmod);
478         jmod(&quot;create&quot;,
479              &quot;--class-path&quot;, cp,
480              &quot;--cmds&quot;, cp,
481              jmod.toString())
482              .assertSuccess()
483              .resultChecker(r -&gt;
484                  assertContains(r.output, &quot;Warning: ignoring entry&quot;)
485              );
486     }
487 
488     @Test
489     public void testLastOneWins() throws IOException {
490         Path workDir = Paths.get(&quot;lastOneWins&quot;);
491         if (Files.exists(workDir))
492             FileUtils.deleteFileTreeWithRetry(workDir);
493         Files.createDirectory(workDir);
494         Path jmod = MODS_DIR.resolve(&quot;lastOneWins.jmod&quot;);
495         FileUtils.deleteFileIfExistsWithRetry(jmod);
496         Path cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;);
497         Path bp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;bin&quot;);
498         Path lp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;lib&quot;);
499         Path cf = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;conf&quot;);
500 
501         Path shouldNotBeAdded = workDir.resolve(&quot;shouldNotBeAdded&quot;);
502         Files.createDirectory(shouldNotBeAdded);
503         Files.write(shouldNotBeAdded.resolve(&quot;aFile&quot;), &quot;hello&quot;.getBytes(UTF_8));
504 
505         // Pairs of options. For options with required arguments the last one
506         // should win ( first should be effectively ignored, but may still be
507         // validated ).
508         jmod(&quot;create&quot;,
509              &quot;--conf&quot;, shouldNotBeAdded.toString(),
510              &quot;--conf&quot;, cf.toString(),
511              &quot;--cmds&quot;, shouldNotBeAdded.toString(),
512              &quot;--cmds&quot;, bp.toString(),
513              &quot;--libs&quot;, shouldNotBeAdded.toString(),
514              &quot;--libs&quot;, lp.toString(),
515              &quot;--class-path&quot;, shouldNotBeAdded.toString(),
516              &quot;--class-path&quot;, cp.toString(),
517              &quot;--main-class&quot;, &quot;does.NotExist&quot;,
518              &quot;--main-class&quot;, &quot;jdk.test.foo.Foo&quot;,
519              &quot;--module-version&quot;, &quot;00001&quot;,
520              &quot;--module-version&quot;, &quot;5.4.3&quot;,
521              &quot;--do-not-resolve-by-default&quot;,
522              &quot;--do-not-resolve-by-default&quot;,
523              &quot;--warn-if-resolved=incubating&quot;,
524              &quot;--warn-if-resolved=deprecated&quot;,
525              MODS_DIR.resolve(&quot;lastOneWins.jmod&quot;).toString())
526             .assertSuccess()
527             .resultChecker(r -&gt; {
528                 ModuleDescriptor md = getModuleDescriptor(jmod);
529                 Optional&lt;String&gt; omc = md.mainClass();
530                 assertTrue(omc.isPresent());
531                 assertEquals(omc.get(), &quot;jdk.test.foo.Foo&quot;);
532                 Optional&lt;Version&gt; ov = md.version();
533                 assertTrue(ov.isPresent());
534                 assertEquals(ov.get().toString(), &quot;5.4.3&quot;);
535 
536                 try (Stream&lt;String&gt; s1 = findFiles(lp).map(p -&gt; LIBS_PREFIX + p);
537                      Stream&lt;String&gt; s2 = findFiles(cp).map(p -&gt; CLASSES_PREFIX + p);
538                      Stream&lt;String&gt; s3 = findFiles(bp).map(p -&gt; CMDS_PREFIX + p);
539                      Stream&lt;String&gt; s4 = findFiles(cf).map(p -&gt; CONFIGS_PREFIX + p)) {
540                     Set&lt;String&gt; expectedFilenames = Stream.concat(Stream.concat(s1,s2),
541                                                                   Stream.concat(s3, s4))
542                                                           .collect(toSet());
543                     assertJmodContent(jmod, expectedFilenames);
544                 }
545             });
546 
547         jmod(&quot;extract&quot;,
548              &quot;--dir&quot;, &quot;blah&quot;,
549              &quot;--dir&quot;, &quot;lastOneWinsExtractDir&quot;,
550              jmod.toString())
551             .assertSuccess()
552             .resultChecker(r -&gt; {
553                 assertTrue(Files.exists(Paths.get(&quot;lastOneWinsExtractDir&quot;)));
554                 assertTrue(Files.notExists(Paths.get(&quot;blah&quot;)));
555             });
556     }
557 
558     @Test
559     public void testPackagesAttribute() throws IOException {
560         Path jmod = MODS_DIR.resolve(&quot;foo.jmod&quot;);
561         FileUtils.deleteFileIfExistsWithRetry(jmod);
562         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;).toString();
563 
564         Set&lt;String&gt; expectedPackages = Set.of(&quot;jdk.test.foo&quot;,
565                                               &quot;jdk.test.foo.internal&quot;,
566                                               &quot;jdk.test.foo.resources&quot;);
567 
568         jmod(&quot;create&quot;,
569              &quot;--class-path&quot;, cp,
570              jmod.toString())
571              .assertSuccess()
572              .resultChecker(r -&gt; {
573                  Set&lt;String&gt; pkgs = getModuleDescriptor(jmod).packages();
574                  assertEquals(pkgs, expectedPackages);
575              });
576         }
577 
578     @Test
579     public void testVersion() {
580         jmod(&quot;--version&quot;)
581             .assertSuccess()
582             .resultChecker(r -&gt; {
583                 assertContains(r.output, System.getProperty(&quot;java.version&quot;));
584             });
585     }
586 
587     @Test
588     public void testHelp() {
589         jmod(&quot;--help&quot;)
590             .assertSuccess()
591             .resultChecker(r -&gt; {
592                 assertTrue(r.output.startsWith(&quot;Usage: jmod&quot;), &quot;Help not printed&quot;);
593                 assertFalse(r.output.contains(&quot;--do-not-resolve-by-default&quot;));
594                 assertFalse(r.output.contains(&quot;--warn-if-resolved&quot;));
595             });
596     }
597 
598     @Test
599     public void testHelpExtra() {
600         jmod(&quot;--help-extra&quot;)
601             .assertSuccess()
602             .resultChecker(r -&gt; {
603                 assertTrue(r.output.startsWith(&quot;Usage: jmod&quot;), &quot;Extra help not printed&quot;);
604                 assertContains(r.output, &quot;--do-not-resolve-by-default&quot;);
605                 assertContains(r.output, &quot;--warn-if-resolved&quot;);
606             });
607     }
608 
609     @Test
610     public void testTmpFileRemoved() throws IOException {
611         // Implementation detail: jmod tool creates &lt;jmod-file&gt;.tmp
612         // Ensure that it is removed in the event of a failure.
613         // The failure in this case is a class in the unnamed package.
614 
615         Path jmod = MODS_DIR.resolve(&quot;testTmpFileRemoved.jmod&quot;);
616         Path tmp = MODS_DIR.resolve(&quot;.testTmpFileRemoved.jmod.tmp&quot;);
617         FileUtils.deleteFileIfExistsWithRetry(jmod);
618         FileUtils.deleteFileIfExistsWithRetry(tmp);
619         String cp = EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;) + File.pathSeparator +
620                     EXPLODED_DIR.resolve(&quot;foo&quot;).resolve(&quot;classes&quot;)
621                                 .resolve(&quot;jdk&quot;).resolve(&quot;test&quot;).resolve(&quot;foo&quot;).toString();
622 
623         jmod(&quot;create&quot;,
624              &quot;--class-path&quot;, cp,
625              jmod.toString())
626             .assertFailure()
627             .resultChecker(r -&gt; {
628                 assertContains(r.output, &quot;unnamed package&quot;);
629                 assertTrue(Files.notExists(tmp), &quot;Unexpected tmp file:&quot; + tmp);
630             });
631     }
632 
633     // ---
634 
635     static boolean compileModule(String name, Path dest) throws IOException {
636         return CompilerUtils.compile(SRC_DIR.resolve(name), dest);
637     }
638 
639     static void assertContains(String output, String subString) {
640         if (output.contains(subString))
641             assertTrue(true);
642         else
643             assertTrue(false,&quot;Expected to find [&quot; + subString + &quot;], in output [&quot;
644                            + output + &quot;]&quot; + &quot;\n&quot;);
645     }
646 
647     static ModuleDescriptor getModuleDescriptor(Path jmod) {
648         ClassLoader cl = ClassLoader.getSystemClassLoader();
649         try (FileSystem fs = FileSystems.newFileSystem(jmod, cl)) {
650             String p = &quot;/classes/module-info.class&quot;;
651             try (InputStream is = Files.newInputStream(fs.getPath(p))) {
652                 return ModuleDescriptor.read(is);
653             }
654         } catch (IOException ioe) {
655             throw new UncheckedIOException(ioe);
656         }
657     }
658 
659     static Stream&lt;String&gt; findFiles(Path dir) {
660         try {
661             return Files.find(dir, Integer.MAX_VALUE, (p, a) -&gt; a.isRegularFile())
662                         .map(dir::relativize)
663                         .map(Path::toString)
664                         .map(p -&gt; p.replace(File.separator, &quot;/&quot;));
665         } catch (IOException x) {
666             throw new UncheckedIOException(x);
667         }
668     }
669 
670     static Set&lt;String&gt; getJmodContent(Path jmod) {
671         JmodResult r = jmod(&quot;list&quot;, jmod.toString()).assertSuccess();
672         return Stream.of(r.output.split(&quot;\r?\n&quot;)).collect(toSet());
673     }
674 
675     static void assertJmodContent(Path jmod, Set&lt;String&gt; expected) {
676         Set&lt;String&gt; actual = getJmodContent(jmod);
677         if (!Objects.equals(actual, expected)) {
678             Set&lt;String&gt; unexpected = new HashSet&lt;&gt;(actual);
679             unexpected.removeAll(expected);
680             Set&lt;String&gt; notFound = new HashSet&lt;&gt;(expected);
681             notFound.removeAll(actual);
682             StringBuilder sb = new StringBuilder();
683             sb.append(&quot;Unexpected but found:\n&quot;);
684             unexpected.forEach(s -&gt; sb.append(&quot;\t&quot; + s + &quot;\n&quot;));
685             sb.append(&quot;Expected but not found:\n&quot;);
686             notFound.forEach(s -&gt; sb.append(&quot;\t&quot; + s + &quot;\n&quot;));
687             assertTrue(false, &quot;Jmod content check failed.\n&quot; + sb.toString());
688         }
689     }
690 
691     static void assertJmodDoesNotContain(Path jmod, Set&lt;String&gt; unexpectedNames) {
692         Set&lt;String&gt; actual = getJmodContent(jmod);
693         Set&lt;String&gt; unexpected = new HashSet&lt;&gt;();
694         for (String name : unexpectedNames) {
695             if (actual.contains(name))
696                 unexpected.add(name);
697         }
698         if (!unexpected.isEmpty()) {
699             StringBuilder sb = new StringBuilder();
700             for (String s : unexpected)
701                 sb.append(&quot;Unexpected but found: &quot; + s + &quot;\n&quot;);
702             sb.append(&quot;In :&quot;);
703             for (String s : actual)
704                 sb.append(&quot;\t&quot; + s + &quot;\n&quot;);
705             assertTrue(false, &quot;Jmod content check failed.\n&quot; + sb.toString());
706         }
707     }
708 
709     static void assertSameContent(Path p1, Path p2) {
710         try {
711             byte[] ba1 = Files.readAllBytes(p1);
712             byte[] ba2 = Files.readAllBytes(p2);
713             assertEquals(ba1, ba2);
714         } catch (IOException x) {
715             throw new UncheckedIOException(x);
716         }
717     }
718 
719     static JmodResult jmod(String... args) {
720         ByteArrayOutputStream baos = new ByteArrayOutputStream();
721         PrintStream ps = new PrintStream(baos);
722         System.out.println(&quot;jmod &quot; + Arrays.asList(args));
723         int ec = JMOD_TOOL.run(ps, ps, args);
724         return new JmodResult(ec, new String(baos.toByteArray(), UTF_8));
725     }
726 
727     static class JmodResult {
728         final int exitCode;
729         final String output;
730 
731         JmodResult(int exitValue, String output) {
732             this.exitCode = exitValue;
733             this.output = output;
734         }
735         JmodResult assertSuccess() { assertTrue(exitCode == 0, output); return this; }
736         JmodResult assertFailure() { assertTrue(exitCode != 0, output); return this; }
737         JmodResult resultChecker(Consumer&lt;JmodResult&gt; r) { r.accept(this); return this; }
738     }
739 
740     static void createCmds(Path dir) throws IOException {
741         List&lt;String&gt; files = Arrays.asList(
742                 &quot;first&quot;, &quot;second&quot;, &quot;third&quot; + File.separator + &quot;third&quot;);
743         createFiles(dir, files);
744     }
745 
746     static void createLibs(Path dir) throws IOException {
747         List&lt;String&gt; files = Arrays.asList(
748                 &quot;first.so&quot;, &quot;second.so&quot;, &quot;third&quot; + File.separator + &quot;third.so&quot;);
749         createFiles(dir, files);
750     }
751 
752     static void createConfigs(Path dir) throws IOException {
753         List&lt;String&gt; files = Arrays.asList(
754                 &quot;first.cfg&quot;, &quot;second.cfg&quot;, &quot;third&quot; + File.separator + &quot;third.cfg&quot;);
755         createFiles(dir, files);
756     }
757 
758     static void createFiles(Path dir, List&lt;String&gt; filenames) throws IOException {
759         for (String name : filenames) {
760             Path file = dir.resolve(name);
761             Files.createDirectories(file.getParent());
762             Files.createFile(file);
763             try (OutputStream os  = Files.newOutputStream(file)) {
764                 os.write(&quot;blahblahblah&quot;.getBytes(UTF_8));
765             }
766         }
767     }
768 
769     static void copyResource(Path srcDir, Path dir, String resource) throws IOException {
770         Path dest = dir.resolve(resource);
771         Files.deleteIfExists(dest);
772 
773         Files.createDirectories(dest.getParent());
774         Files.copy(srcDir.resolve(resource), dest);
775     }
776 
777     // Standalone entry point.
778     public static void main(String[] args) throws Throwable {
779         JmodTest test = new JmodTest();
780         test.buildExplodedModules();
781         for (Method m : JmodTest.class.getDeclaredMethods()) {
782             if (m.getAnnotation(Test.class) != null) {
783                 System.out.println(&quot;Invoking &quot; + m.getName());
784                 m.invoke(test);
785             }
786         }
787     }
788 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/System.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package java.lang;
  26 
  27 import java.io.BufferedInputStream;
  28 import java.io.BufferedOutputStream;
  29 import java.io.Console;
  30 import java.io.FileDescriptor;
  31 import java.io.FileInputStream;
  32 import java.io.FileOutputStream;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.PrintStream;
  36 import java.io.UnsupportedEncodingException;
  37 import java.lang.annotation.Annotation;
  38 import java.lang.invoke.MethodHandle;
  39 import java.lang.invoke.MethodType;
  40 import java.lang.invoke.StringConcatFactory;
  41 import java.lang.module.ModuleDescriptor;
  42 import java.lang.reflect.Constructor;
  43 import java.lang.reflect.Executable;
  44 import java.lang.reflect.Method;
  45 import java.lang.reflect.Modifier;
  46 import java.net.URI;
  47 import java.nio.charset.CharacterCodingException;
  48 import java.security.AccessControlContext;
  49 import java.security.ProtectionDomain;
  50 import java.security.AccessController;
  51 import java.security.PrivilegedAction;
  52 import java.nio.channels.Channel;
  53 import java.nio.channels.spi.SelectorProvider;
  54 import java.nio.charset.Charset;
  55 import java.util.List;
  56 import java.util.Map;
  57 import java.util.Objects;
  58 import java.util.Properties;
  59 import java.util.PropertyPermission;
  60 import java.util.ResourceBundle;
  61 import java.util.Set;
  62 import java.util.function.Supplier;
  63 import java.util.concurrent.ConcurrentHashMap;
  64 import java.util.stream.Stream;
  65 
  66 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  67 import jdk.internal.misc.Unsafe;
  68 =======
  69 import jdk.internal.loader.NativeLibraries;
  70 import jdk.internal.loader.NativeLibrary;
  71 &gt;&gt;&gt;&gt;&gt;&gt;&gt; b1eb5e82bd282c5770554ceb954a7cd565caabb5
  72 import jdk.internal.util.StaticProperty;
  73 import jdk.internal.module.ModuleBootstrap;
  74 import jdk.internal.module.ServicesCatalog;
  75 import jdk.internal.reflect.CallerSensitive;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.HotSpotIntrinsicCandidate;
  78 import jdk.internal.access.JavaLangAccess;
  79 import jdk.internal.access.SharedSecrets;
  80 import jdk.internal.misc.VM;
  81 import jdk.internal.logger.LoggerFinderLoader;
  82 import jdk.internal.logger.LazyLoggers;
  83 import jdk.internal.logger.LocalizedLoggerWrapper;
  84 import jdk.internal.util.SystemProps;
  85 import jdk.internal.vm.annotation.Stable;
  86 import sun.nio.fs.DefaultFileSystemProvider;
  87 import sun.reflect.annotation.AnnotationType;
  88 import sun.nio.ch.Interruptible;
  89 import sun.security.util.SecurityConstants;
  90 
  91 /**
  92  * The {@code System} class contains several useful class fields
  93  * and methods. It cannot be instantiated.
  94  *
  95  * Among the facilities provided by the {@code System} class
  96  * are standard input, standard output, and error output streams;
  97  * access to externally defined properties and environment
  98  * variables; a means of loading files and libraries; and a utility
  99  * method for quickly copying a portion of an array.
 100  *
 101  * @since   1.0
 102  */
 103 public final class System {
 104     /* Register the natives via the static initializer.
 105      *
 106      * The VM will invoke the initPhase1 method to complete the initialization
 107      * of this class separate from &lt;clinit&gt;.
 108      */
 109     private static native void registerNatives();
 110     static {
 111         registerNatives();
 112     }
 113 
 114     /** Don&#39;t let anyone instantiate this class */
 115     private System() {
 116     }
 117 
 118     /**
 119      * The &quot;standard&quot; input stream. This stream is already
 120      * open and ready to supply input data. Typically this stream
 121      * corresponds to keyboard input or another input source specified by
 122      * the host environment or user.
 123      */
 124     public static final InputStream in = null;
 125 
 126     /**
 127      * The &quot;standard&quot; output stream. This stream is already
 128      * open and ready to accept output data. Typically this stream
 129      * corresponds to display output or another output destination
 130      * specified by the host environment or user.
 131      * &lt;p&gt;
 132      * For simple stand-alone Java applications, a typical way to write
 133      * a line of output data is:
 134      * &lt;blockquote&gt;&lt;pre&gt;
 135      *     System.out.println(data)
 136      * &lt;/pre&gt;&lt;/blockquote&gt;
 137      * &lt;p&gt;
 138      * See the {@code println} methods in class {@code PrintStream}.
 139      *
 140      * @see     java.io.PrintStream#println()
 141      * @see     java.io.PrintStream#println(boolean)
 142      * @see     java.io.PrintStream#println(char)
 143      * @see     java.io.PrintStream#println(char[])
 144      * @see     java.io.PrintStream#println(double)
 145      * @see     java.io.PrintStream#println(float)
 146      * @see     java.io.PrintStream#println(int)
 147      * @see     java.io.PrintStream#println(long)
 148      * @see     java.io.PrintStream#println(java.lang.Object)
 149      * @see     java.io.PrintStream#println(java.lang.String)
 150      */
 151     public static final PrintStream out = null;
 152 
 153     /**
 154      * The &quot;standard&quot; error output stream. This stream is already
 155      * open and ready to accept output data.
 156      * &lt;p&gt;
 157      * Typically this stream corresponds to display output or another
 158      * output destination specified by the host environment or user. By
 159      * convention, this output stream is used to display error messages
 160      * or other information that should come to the immediate attention
 161      * of a user even if the principal output stream, the value of the
 162      * variable {@code out}, has been redirected to a file or other
 163      * destination that is typically not continuously monitored.
 164      */
 165     public static final PrintStream err = null;
 166 
 167     // indicates if a security manager is possible
 168     private static final int NEVER = 1;
 169     private static final int MAYBE = 2;
 170     private static @Stable int allowSecurityManager;
 171 
 172     // current security manager
 173     private static volatile SecurityManager security;   // read by VM
 174 
 175     // return true if a security manager is allowed
 176     private static boolean allowSecurityManager() {
 177         return (allowSecurityManager != NEVER);
 178     }
 179 
 180     /**
 181      * Reassigns the &quot;standard&quot; input stream.
 182      *
 183      * First, if there is a security manager, its {@code checkPermission}
 184      * method is called with a {@code RuntimePermission(&quot;setIO&quot;)} permission
 185      *  to see if it&#39;s ok to reassign the &quot;standard&quot; input stream.
 186      *
 187      * @param in the new standard input stream.
 188      *
 189      * @throws SecurityException
 190      *        if a security manager exists and its
 191      *        {@code checkPermission} method doesn&#39;t allow
 192      *        reassigning of the standard input stream.
 193      *
 194      * @see SecurityManager#checkPermission
 195      * @see java.lang.RuntimePermission
 196      *
 197      * @since   1.1
 198      */
 199     public static void setIn(InputStream in) {
 200         checkIO();
 201         setIn0(in);
 202     }
 203 
 204     /**
 205      * Reassigns the &quot;standard&quot; output stream.
 206      *
 207      * First, if there is a security manager, its {@code checkPermission}
 208      * method is called with a {@code RuntimePermission(&quot;setIO&quot;)} permission
 209      *  to see if it&#39;s ok to reassign the &quot;standard&quot; output stream.
 210      *
 211      * @param out the new standard output stream
 212      *
 213      * @throws SecurityException
 214      *        if a security manager exists and its
 215      *        {@code checkPermission} method doesn&#39;t allow
 216      *        reassigning of the standard output stream.
 217      *
 218      * @see SecurityManager#checkPermission
 219      * @see java.lang.RuntimePermission
 220      *
 221      * @since   1.1
 222      */
 223     public static void setOut(PrintStream out) {
 224         checkIO();
 225         setOut0(out);
 226     }
 227 
 228     /**
 229      * Reassigns the &quot;standard&quot; error output stream.
 230      *
 231      * First, if there is a security manager, its {@code checkPermission}
 232      * method is called with a {@code RuntimePermission(&quot;setIO&quot;)} permission
 233      *  to see if it&#39;s ok to reassign the &quot;standard&quot; error output stream.
 234      *
 235      * @param err the new standard error output stream.
 236      *
 237      * @throws SecurityException
 238      *        if a security manager exists and its
 239      *        {@code checkPermission} method doesn&#39;t allow
 240      *        reassigning of the standard error output stream.
 241      *
 242      * @see SecurityManager#checkPermission
 243      * @see java.lang.RuntimePermission
 244      *
 245      * @since   1.1
 246      */
 247     public static void setErr(PrintStream err) {
 248         checkIO();
 249         setErr0(err);
 250     }
 251 
 252     private static volatile Console cons;
 253 
 254     /**
 255      * Returns the unique {@link java.io.Console Console} object associated
 256      * with the current Java virtual machine, if any.
 257      *
 258      * @return  The system console, if any, otherwise {@code null}.
 259      *
 260      * @since   1.6
 261      */
 262      public static Console console() {
 263          Console c;
 264          if ((c = cons) == null) {
 265              synchronized (System.class) {
 266                  if ((c = cons) == null) {
 267                      cons = c = SharedSecrets.getJavaIOAccess().console();
 268                  }
 269              }
 270          }
 271          return c;
 272      }
 273 
 274     /**
 275      * Returns the channel inherited from the entity that created this
 276      * Java virtual machine.
 277      *
 278      * This method returns the channel obtained by invoking the
 279      * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
 280      * inheritedChannel} method of the system-wide default
 281      * {@link java.nio.channels.spi.SelectorProvider} object.
 282      *
 283      * &lt;p&gt; In addition to the network-oriented channels described in
 284      * {@link java.nio.channels.spi.SelectorProvider#inheritedChannel
 285      * inheritedChannel}, this method may return other kinds of
 286      * channels in the future.
 287      *
 288      * @return  The inherited channel, if any, otherwise {@code null}.
 289      *
 290      * @throws  IOException
 291      *          If an I/O error occurs
 292      *
 293      * @throws  SecurityException
 294      *          If a security manager is present and it does not
 295      *          permit access to the channel.
 296      *
 297      * @since 1.5
 298      */
 299     public static Channel inheritedChannel() throws IOException {
 300         return SelectorProvider.provider().inheritedChannel();
 301     }
 302 
 303     private static void checkIO() {
 304         SecurityManager sm = getSecurityManager();
 305         if (sm != null) {
 306             sm.checkPermission(new RuntimePermission(&quot;setIO&quot;));
 307         }
 308     }
 309 
 310     private static native void setIn0(InputStream in);
 311     private static native void setOut0(PrintStream out);
 312     private static native void setErr0(PrintStream err);
 313 
 314     /**
 315      * Sets the system-wide security manager.
 316      *
 317      * If there is a security manager already installed, this method first
 318      * calls the security manager&#39;s {@code checkPermission} method
 319      * with a {@code RuntimePermission(&quot;setSecurityManager&quot;)}
 320      * permission to ensure it&#39;s ok to replace the existing
 321      * security manager.
 322      * This may result in throwing a {@code SecurityException}.
 323      *
 324      * &lt;p&gt; Otherwise, the argument is established as the current
 325      * security manager. If the argument is {@code null} and no
 326      * security manager has been established, then no action is taken and
 327      * the method simply returns.
 328      *
 329      * @implNote In the JDK implementation, if the Java virtual machine is
 330      * started with the system property {@code java.security.manager} set to
 331      * the special token &quot;{@code disallow}&quot; then the {@code setSecurityManager}
 332      * method cannot be used to set a security manager.
 333      *
 334      * @param  sm the security manager or {@code null}
 335      * @throws SecurityException
 336      *         if the security manager has already been set and its {@code
 337      *         checkPermission} method doesn&#39;t allow it to be replaced
 338      * @throws UnsupportedOperationException
 339      *         if {@code sm} is non-null and a security manager is not allowed
 340      *         to be set dynamically
 341      * @see #getSecurityManager
 342      * @see SecurityManager#checkPermission
 343      * @see java.lang.RuntimePermission
 344      */
 345     public static void setSecurityManager(SecurityManager sm) {
 346         if (allowSecurityManager()) {
 347             if (security == null) {
 348                 // ensure image reader is initialized
 349                 Object.class.getResource(&quot;java/lang/ANY&quot;);
 350                 // ensure the default file system is initialized
 351                 DefaultFileSystemProvider.theFileSystem();
 352             }
 353             if (sm != null) {
 354                 try {
 355                     // pre-populates the SecurityManager.packageAccess cache
 356                     // to avoid recursive permission checking issues with custom
 357                     // SecurityManager implementations
 358                     sm.checkPackageAccess(&quot;java.lang&quot;);
 359                 } catch (Exception e) {
 360                     // no-op
 361                 }
 362             }
 363             setSecurityManager0(sm);
 364         } else {
 365             // security manager not allowed
 366             if (sm != null) {
 367                 throw new UnsupportedOperationException(
 368                     &quot;Runtime configured to disallow security manager&quot;);
 369             }
 370         }
 371     }
 372 
 373     private static synchronized
 374     void setSecurityManager0(final SecurityManager s) {
 375         SecurityManager sm = getSecurityManager();
 376         if (sm != null) {
 377             // ask the currently installed security manager if we
 378             // can replace it.
 379             sm.checkPermission(new RuntimePermission(&quot;setSecurityManager&quot;));
 380         }
 381 
 382         if ((s != null) &amp;&amp; (s.getClass().getClassLoader() != null)) {
 383             // New security manager class is not on bootstrap classpath.
 384             // Force policy to get initialized before we install the new
 385             // security manager, in order to prevent infinite loops when
 386             // trying to initialize the policy (which usually involves
 387             // accessing some security and/or system properties, which in turn
 388             // calls the installed security manager&#39;s checkPermission method
 389             // which will loop infinitely if there is a non-system class
 390             // (in this case: the new security manager class) on the stack).
 391             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
 392                 public Object run() {
 393                     s.getClass().getProtectionDomain().implies
 394                         (SecurityConstants.ALL_PERMISSION);
 395                     return null;
 396                 }
 397             });
 398         }
 399 
 400         security = s;
 401     }
 402 
 403     /**
 404      * Gets the system-wide security manager.
 405      *
 406      * @return  if a security manager has already been established for the
 407      *          current application, then that security manager is returned;
 408      *          otherwise, {@code null} is returned.
 409      * @see     #setSecurityManager
 410      */
 411     public static SecurityManager getSecurityManager() {
 412         if (allowSecurityManager()) {
 413             return security;
 414         } else {
 415             return null;
 416         }
 417     }
 418 
 419     /**
 420      * Returns the current time in milliseconds.  Note that
 421      * while the unit of time of the return value is a millisecond,
 422      * the granularity of the value depends on the underlying
 423      * operating system and may be larger.  For example, many
 424      * operating systems measure time in units of tens of
 425      * milliseconds.
 426      *
 427      * &lt;p&gt; See the description of the class {@code Date} for
 428      * a discussion of slight discrepancies that may arise between
 429      * &quot;computer time&quot; and coordinated universal time (UTC).
 430      *
 431      * @return  the difference, measured in milliseconds, between
 432      *          the current time and midnight, January 1, 1970 UTC.
 433      * @see     java.util.Date
 434      */
 435     @HotSpotIntrinsicCandidate
 436     public static native long currentTimeMillis();
 437 
 438     /**
 439      * Returns the current value of the running Java Virtual Machine&#39;s
 440      * high-resolution time source, in nanoseconds.
 441      *
 442      * This method can only be used to measure elapsed time and is
 443      * not related to any other notion of system or wall-clock time.
 444      * The value returned represents nanoseconds since some fixed but
 445      * arbitrary &lt;i&gt;origin&lt;/i&gt; time (perhaps in the future, so values
 446      * may be negative).  The same origin is used by all invocations of
 447      * this method in an instance of a Java virtual machine; other
 448      * virtual machine instances are likely to use a different origin.
 449      *
 450      * &lt;p&gt;This method provides nanosecond precision, but not necessarily
 451      * nanosecond resolution (that is, how frequently the value changes)
 452      * - no guarantees are made except that the resolution is at least as
 453      * good as that of {@link #currentTimeMillis()}.
 454      *
 455      * &lt;p&gt;Differences in successive calls that span greater than
 456      * approximately 292 years (2&lt;sup&gt;63&lt;/sup&gt; nanoseconds) will not
 457      * correctly compute elapsed time due to numerical overflow.
 458      *
 459      * &lt;p&gt;The values returned by this method become meaningful only when
 460      * the difference between two such values, obtained within the same
 461      * instance of a Java virtual machine, is computed.
 462      *
 463      * &lt;p&gt;For example, to measure how long some code takes to execute:
 464      * &lt;pre&gt; {@code
 465      * long startTime = System.nanoTime();
 466      * // ... the code being measured ...
 467      * long elapsedNanos = System.nanoTime() - startTime;}&lt;/pre&gt;
 468      *
 469      * &lt;p&gt;To compare elapsed time against a timeout, use &lt;pre&gt; {@code
 470      * if (System.nanoTime() - startTime &gt;= timeoutNanos) ...}&lt;/pre&gt;
 471      * instead of &lt;pre&gt; {@code
 472      * if (System.nanoTime() &gt;= startTime + timeoutNanos) ...}&lt;/pre&gt;
 473      * because of the possibility of numerical overflow.
 474      *
 475      * @return the current value of the running Java Virtual Machine&#39;s
 476      *         high-resolution time source, in nanoseconds
 477      * @since 1.5
 478      */
 479     @HotSpotIntrinsicCandidate
 480     public static native long nanoTime();
 481 
 482     /**
 483      * Copies an array from the specified source array, beginning at the
 484      * specified position, to the specified position of the destination array.
 485      * A subsequence of array components are copied from the source
 486      * array referenced by {@code src} to the destination array
 487      * referenced by {@code dest}. The number of components copied is
 488      * equal to the {@code length} argument. The components at
 489      * positions {@code srcPos} through
 490      * {@code srcPos+length-1} in the source array are copied into
 491      * positions {@code destPos} through
 492      * {@code destPos+length-1}, respectively, of the destination
 493      * array.
 494      * &lt;p&gt;
 495      * If the {@code src} and {@code dest} arguments refer to the
 496      * same array object, then the copying is performed as if the
 497      * components at positions {@code srcPos} through
 498      * {@code srcPos+length-1} were first copied to a temporary
 499      * array with {@code length} components and then the contents of
 500      * the temporary array were copied into positions
 501      * {@code destPos} through {@code destPos+length-1} of the
 502      * destination array.
 503      * &lt;p&gt;
 504      * If {@code dest} is {@code null}, then a
 505      * {@code NullPointerException} is thrown.
 506      * &lt;p&gt;
 507      * If {@code src} is {@code null}, then a
 508      * {@code NullPointerException} is thrown and the destination
 509      * array is not modified.
 510      * &lt;p&gt;
 511      * Otherwise, if any of the following is true, an
 512      * {@code ArrayStoreException} is thrown and the destination is
 513      * not modified:
 514      * &lt;ul&gt;
 515      * &lt;li&gt;The {@code src} argument refers to an object that is not an
 516      *     array.
 517      * &lt;li&gt;The {@code dest} argument refers to an object that is not an
 518      *     array.
 519      * &lt;li&gt;The {@code src} argument and {@code dest} argument refer
 520      *     to arrays whose component types are different primitive types.
 521      * &lt;li&gt;The {@code src} argument refers to an array with a primitive
 522      *    component type and the {@code dest} argument refers to an array
 523      *     with a reference component type.
 524      * &lt;li&gt;The {@code src} argument refers to an array with a reference
 525      *    component type and the {@code dest} argument refers to an array
 526      *     with a primitive component type.
 527      * &lt;/ul&gt;
 528      * &lt;p&gt;
 529      * Otherwise, if any of the following is true, an
 530      * {@code IndexOutOfBoundsException} is
 531      * thrown and the destination is not modified:
 532      * &lt;ul&gt;
 533      * &lt;li&gt;The {@code srcPos} argument is negative.
 534      * &lt;li&gt;The {@code destPos} argument is negative.
 535      * &lt;li&gt;The {@code length} argument is negative.
 536      * &lt;li&gt;{@code srcPos+length} is greater than
 537      *     {@code src.length}, the length of the source array.
 538      * &lt;li&gt;{@code destPos+length} is greater than
 539      *     {@code dest.length}, the length of the destination array.
 540      * &lt;/ul&gt;
 541      * &lt;p&gt;
 542      * Otherwise, if any actual component of the source array from
 543      * position {@code srcPos} through
 544      * {@code srcPos+length-1} cannot be converted to the component
 545      * type of the destination array by assignment conversion, an
 546      * {@code ArrayStoreException} is thrown. In this case, let
 547      * &lt;b&gt;&lt;i&gt;k&lt;/i&gt;&lt;/b&gt; be the smallest nonnegative integer less than
 548      * length such that {@code src[srcPos+}&lt;i&gt;k&lt;/i&gt;{@code ]}
 549      * cannot be converted to the component type of the destination
 550      * array; when the exception is thrown, source array components from
 551      * positions {@code srcPos} through
 552      * {@code srcPos+}&lt;i&gt;k&lt;/i&gt;{@code -1}
 553      * will already have been copied to destination array positions
 554      * {@code destPos} through
 555      * {@code destPos+}&lt;i&gt;k&lt;/I&gt;{@code -1} and no other
 556      * positions of the destination array will have been modified.
 557      * (Because of the restrictions already itemized, this
 558      * paragraph effectively applies only to the situation where both
 559      * arrays have component types that are reference types.)
 560      *
 561      * @param      src      the source array.
 562      * @param      srcPos   starting position in the source array.
 563      * @param      dest     the destination array.
 564      * @param      destPos  starting position in the destination data.
 565      * @param      length   the number of array elements to be copied.
 566      * @throws     IndexOutOfBoundsException  if copying would cause
 567      *             access of data outside array bounds.
 568      * @throws     ArrayStoreException  if an element in the {@code src}
 569      *             array could not be stored into the {@code dest} array
 570      *             because of a type mismatch.
 571      * @throws     NullPointerException if either {@code src} or
 572      *             {@code dest} is {@code null}.
 573      */
 574     @HotSpotIntrinsicCandidate
 575     public static native void arraycopy(Object src,  int  srcPos,
 576                                         Object dest, int destPos,
 577                                         int length);
 578 
 579     /**
 580      * Returns the same hash code for the given object as
 581      * would be returned by the default method hashCode(),
 582      * whether or not the given object&#39;s class overrides
 583      * hashCode().
 584      * The hash code for the null reference is zero.
 585      *
 586      * @param x object for which the hashCode is to be calculated
 587      * @return  the hashCode
 588      * @since   1.1
 589      * @see Object#hashCode
 590      * @see java.util.Objects#hashCode(Object)
 591      */
 592     @HotSpotIntrinsicCandidate
 593     public static native int identityHashCode(Object x);
 594 
 595     /**
 596      * System properties.
 597      *
 598      * See {@linkplain #getProperties getProperties} for details.
 599      */
 600     private static Properties props;
 601 
 602     /**
 603      * Determines the current system properties.
 604      *
 605      * First, if there is a security manager, its
 606      * {@code checkPropertiesAccess} method is called with no
 607      * arguments. This may result in a security exception.
 608      * &lt;p&gt;
 609      * The current set of system properties for use by the
 610      * {@link #getProperty(String)} method is returned as a
 611      * {@code Properties} object. If there is no current set of
 612      * system properties, a set of system properties is first created and
 613      * initialized. This set of system properties includes a value
 614      * for each of the following keys unless the description of the associated
 615      * value indicates that the value is optional.
 616      * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 617      * &lt;caption style=&quot;display:none&quot;&gt;Shows property keys and associated values&lt;/caption&gt;
 618      * &lt;thead&gt;
 619      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Key&lt;/th&gt;
 620      *     &lt;th scope=&quot;col&quot;&gt;Description of Associated Value&lt;/th&gt;&lt;/tr&gt;
 621      * &lt;/thead&gt;
 622      * &lt;tbody&gt;
 623      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.version}&lt;/th&gt;
 624      *     &lt;td&gt;Java Runtime Environment version, which may be interpreted
 625      *     as a {@link Runtime.Version}&lt;/td&gt;&lt;/tr&gt;
 626      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.version.date}&lt;/th&gt;
 627      *     &lt;td&gt;Java Runtime Environment version date, in ISO-8601 YYYY-MM-DD
 628      *     format, which may be interpreted as a {@link
 629      *     java.time.LocalDate}&lt;/td&gt;&lt;/tr&gt;
 630      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vendor}&lt;/th&gt;
 631      *     &lt;td&gt;Java Runtime Environment vendor&lt;/td&gt;&lt;/tr&gt;
 632      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vendor.url}&lt;/th&gt;
 633      *     &lt;td&gt;Java vendor URL&lt;/td&gt;&lt;/tr&gt;
 634      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vendor.version}&lt;/th&gt;
 635      *     &lt;td&gt;Java vendor version &lt;em&gt;(optional)&lt;/em&gt; &lt;/td&gt;&lt;/tr&gt;
 636      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.home}&lt;/th&gt;
 637      *     &lt;td&gt;Java installation directory&lt;/td&gt;&lt;/tr&gt;
 638      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.specification.version}&lt;/th&gt;
 639      *     &lt;td&gt;Java Virtual Machine specification version, whose value is the
 640      *     {@linkplain Runtime.Version#feature feature} element of the
 641      *     {@linkplain Runtime#version() runtime version}&lt;/td&gt;&lt;/tr&gt;
 642      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.specification.vendor}&lt;/th&gt;
 643      *     &lt;td&gt;Java Virtual Machine specification vendor&lt;/td&gt;&lt;/tr&gt;
 644      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.specification.name}&lt;/th&gt;
 645      *     &lt;td&gt;Java Virtual Machine specification name&lt;/td&gt;&lt;/tr&gt;
 646      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.version}&lt;/th&gt;
 647      *     &lt;td&gt;Java Virtual Machine implementation version which may be
 648      *     interpreted as a {@link Runtime.Version}&lt;/td&gt;&lt;/tr&gt;
 649      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.vendor}&lt;/th&gt;
 650      *     &lt;td&gt;Java Virtual Machine implementation vendor&lt;/td&gt;&lt;/tr&gt;
 651      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.vm.name}&lt;/th&gt;
 652      *     &lt;td&gt;Java Virtual Machine implementation name&lt;/td&gt;&lt;/tr&gt;
 653      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.specification.version}&lt;/th&gt;
 654      *     &lt;td&gt;Java Runtime Environment specification version, whose value is
 655      *     the {@linkplain Runtime.Version#feature feature} element of the
 656      *     {@linkplain Runtime#version() runtime version}&lt;/td&gt;&lt;/tr&gt;
 657      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.specification.vendor}&lt;/th&gt;
 658      *     &lt;td&gt;Java Runtime Environment specification  vendor&lt;/td&gt;&lt;/tr&gt;
 659      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.specification.name}&lt;/th&gt;
 660      *     &lt;td&gt;Java Runtime Environment specification  name&lt;/td&gt;&lt;/tr&gt;
 661      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.class.version}&lt;/th&gt;
 662      *     &lt;td&gt;Java class format version number&lt;/td&gt;&lt;/tr&gt;
 663      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.class.path}&lt;/th&gt;
 664      *     &lt;td&gt;Java class path  (refer to
 665      *        {@link ClassLoader#getSystemClassLoader()} for details)&lt;/td&gt;&lt;/tr&gt;
 666      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.library.path}&lt;/th&gt;
 667      *     &lt;td&gt;List of paths to search when loading libraries&lt;/td&gt;&lt;/tr&gt;
 668      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.io.tmpdir}&lt;/th&gt;
 669      *     &lt;td&gt;Default temp file path&lt;/td&gt;&lt;/tr&gt;
 670      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty java.compiler}&lt;/th&gt;
 671      *     &lt;td&gt;Name of JIT compiler to use&lt;/td&gt;&lt;/tr&gt;
 672      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty os.name}&lt;/th&gt;
 673      *     &lt;td&gt;Operating system name&lt;/td&gt;&lt;/tr&gt;
 674      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty os.arch}&lt;/th&gt;
 675      *     &lt;td&gt;Operating system architecture&lt;/td&gt;&lt;/tr&gt;
 676      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty os.version}&lt;/th&gt;
 677      *     &lt;td&gt;Operating system version&lt;/td&gt;&lt;/tr&gt;
 678      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty file.separator}&lt;/th&gt;
 679      *     &lt;td&gt;File separator (&quot;/&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
 680      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty path.separator}&lt;/th&gt;
 681      *     &lt;td&gt;Path separator (&quot;:&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
 682      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty line.separator}&lt;/th&gt;
 683      *     &lt;td&gt;Line separator (&quot;\n&quot; on UNIX)&lt;/td&gt;&lt;/tr&gt;
 684      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty user.name}&lt;/th&gt;
 685      *     &lt;td&gt;User&#39;s account name&lt;/td&gt;&lt;/tr&gt;
 686      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty user.home}&lt;/th&gt;
 687      *     &lt;td&gt;User&#39;s home directory&lt;/td&gt;&lt;/tr&gt;
 688      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty user.dir}&lt;/th&gt;
 689      *     &lt;td&gt;User&#39;s current working directory&lt;/td&gt;&lt;/tr&gt;
 690      * &lt;/tbody&gt;
 691      * &lt;/table&gt;
 692      * &lt;p&gt;
 693      * Multiple paths in a system property value are separated by the path
 694      * separator character of the platform.
 695      * &lt;p&gt;
 696      * Note that even if the security manager does not permit the
 697      * {@code getProperties} operation, it may choose to permit the
 698      * {@link #getProperty(String)} operation.
 699      *
 700      * @apiNote
 701      * &lt;strong&gt;Changing a standard system property may have unpredictable results
 702      * unless otherwise specified.&lt;/strong&gt;
 703      * Property values may be cached during initialization or on first use.
 704      * Setting a standard property after initialization using {@link #getProperties()},
 705      * {@link #setProperties(Properties)}, {@link #setProperty(String, String)}, or
 706      * {@link #clearProperty(String)} may not have the desired effect.
 707      *
 708      * @implNote
 709      * In addition to the standard system properties, the system
 710      * properties may include the following keys:
 711      * &lt;table class=&quot;striped&quot;&gt;
 712      * &lt;caption style=&quot;display:none&quot;&gt;Shows property keys and associated values&lt;/caption&gt;
 713      * &lt;thead&gt;
 714      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Key&lt;/th&gt;
 715      *     &lt;th scope=&quot;col&quot;&gt;Description of Associated Value&lt;/th&gt;&lt;/tr&gt;
 716      * &lt;/thead&gt;
 717      * &lt;tbody&gt;
 718      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty jdk.module.path}&lt;/th&gt;
 719      *     &lt;td&gt;The application module path&lt;/td&gt;&lt;/tr&gt;
 720      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty jdk.module.upgrade.path}&lt;/th&gt;
 721      *     &lt;td&gt;The upgrade module path&lt;/td&gt;&lt;/tr&gt;
 722      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty jdk.module.main}&lt;/th&gt;
 723      *     &lt;td&gt;The module name of the initial/main module&lt;/td&gt;&lt;/tr&gt;
 724      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@systemProperty jdk.module.main.class}&lt;/th&gt;
 725      *     &lt;td&gt;The main class name of the initial module&lt;/td&gt;&lt;/tr&gt;
 726      * &lt;/tbody&gt;
 727      * &lt;/table&gt;
 728      *
 729      * @return     the system properties
 730      * @throws     SecurityException  if a security manager exists and its
 731      *             {@code checkPropertiesAccess} method doesn&#39;t allow access
 732      *             to the system properties.
 733      * @see        #setProperties
 734      * @see        java.lang.SecurityException
 735      * @see        java.lang.SecurityManager#checkPropertiesAccess()
 736      * @see        java.util.Properties
 737      */
 738     public static Properties getProperties() {
 739         SecurityManager sm = getSecurityManager();
 740         if (sm != null) {
 741             sm.checkPropertiesAccess();
 742         }
 743 
 744         return props;
 745     }
 746 
 747     /**
 748      * Returns the system-dependent line separator string.  It always
 749      * returns the same value - the initial value of the {@linkplain
 750      * #getProperty(String) system property} {@code line.separator}.
 751      *
 752      * &lt;p&gt;On UNIX systems, it returns {@code &quot;\n&quot;}; on Microsoft
 753      * Windows systems it returns {@code &quot;\r\n&quot;}.
 754      *
 755      * @return the system-dependent line separator string
 756      * @since 1.7
 757      */
 758     public static String lineSeparator() {
 759         return lineSeparator;
 760     }
 761 
 762     private static String lineSeparator;
 763 
 764     /**
 765      * Sets the system properties to the {@code Properties} argument.
 766      *
 767      * First, if there is a security manager, its
 768      * {@code checkPropertiesAccess} method is called with no
 769      * arguments. This may result in a security exception.
 770      * &lt;p&gt;
 771      * The argument becomes the current set of system properties for use
 772      * by the {@link #getProperty(String)} method. If the argument is
 773      * {@code null}, then the current set of system properties is
 774      * forgotten.
 775      *
 776      * @apiNote
 777      * &lt;strong&gt;Changing a standard system property may have unpredictable results
 778      * unless otherwise specified&lt;/strong&gt;.
 779      * See {@linkplain #getProperties getProperties} for details.
 780      *
 781      * @param      props   the new system properties.
 782      * @throws     SecurityException  if a security manager exists and its
 783      *             {@code checkPropertiesAccess} method doesn&#39;t allow access
 784      *             to the system properties.
 785      * @see        #getProperties
 786      * @see        java.util.Properties
 787      * @see        java.lang.SecurityException
 788      * @see        java.lang.SecurityManager#checkPropertiesAccess()
 789      */
 790     public static void setProperties(Properties props) {
 791         SecurityManager sm = getSecurityManager();
 792         if (sm != null) {
 793             sm.checkPropertiesAccess();
 794         }
 795 
 796         if (props == null) {
 797             Map&lt;String, String&gt; tempProps = SystemProps.initProperties();
 798             VersionProps.init(tempProps);
 799             props = createProperties(tempProps);
 800         }
 801         System.props = props;
 802     }
 803 
 804     /**
 805      * Gets the system property indicated by the specified key.
 806      *
 807      * First, if there is a security manager, its
 808      * {@code checkPropertyAccess} method is called with the key as
 809      * its argument. This may result in a SecurityException.
 810      * &lt;p&gt;
 811      * If there is no current set of system properties, a set of system
 812      * properties is first created and initialized in the same manner as
 813      * for the {@code getProperties} method.
 814      *
 815      * @apiNote
 816      * &lt;strong&gt;Changing a standard system property may have unpredictable results
 817      * unless otherwise specified&lt;/strong&gt;.
 818      * See {@linkplain #getProperties getProperties} for details.
 819      *
 820      * @param      key   the name of the system property.
 821      * @return     the string value of the system property,
 822      *             or {@code null} if there is no property with that key.
 823      *
 824      * @throws     SecurityException  if a security manager exists and its
 825      *             {@code checkPropertyAccess} method doesn&#39;t allow
 826      *             access to the specified system property.
 827      * @throws     NullPointerException if {@code key} is {@code null}.
 828      * @throws     IllegalArgumentException if {@code key} is empty.
 829      * @see        #setProperty
 830      * @see        java.lang.SecurityException
 831      * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
 832      * @see        java.lang.System#getProperties()
 833      */
 834     public static String getProperty(String key) {
 835         checkKey(key);
 836         SecurityManager sm = getSecurityManager();
 837         if (sm != null) {
 838             sm.checkPropertyAccess(key);
 839         }
 840 
 841         return props.getProperty(key);
 842     }
 843 
 844     /**
 845      * Gets the system property indicated by the specified key.
 846      *
 847      * First, if there is a security manager, its
 848      * {@code checkPropertyAccess} method is called with the
 849      * {@code key} as its argument.
 850      * &lt;p&gt;
 851      * If there is no current set of system properties, a set of system
 852      * properties is first created and initialized in the same manner as
 853      * for the {@code getProperties} method.
 854      *
 855      * @param      key   the name of the system property.
 856      * @param      def   a default value.
 857      * @return     the string value of the system property,
 858      *             or the default value if there is no property with that key.
 859      *
 860      * @throws     SecurityException  if a security manager exists and its
 861      *             {@code checkPropertyAccess} method doesn&#39;t allow
 862      *             access to the specified system property.
 863      * @throws     NullPointerException if {@code key} is {@code null}.
 864      * @throws     IllegalArgumentException if {@code key} is empty.
 865      * @see        #setProperty
 866      * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)
 867      * @see        java.lang.System#getProperties()
 868      */
 869     public static String getProperty(String key, String def) {
 870         checkKey(key);
 871         SecurityManager sm = getSecurityManager();
 872         if (sm != null) {
 873             sm.checkPropertyAccess(key);
 874         }
 875 
 876         return props.getProperty(key, def);
 877     }
 878 
 879     /**
 880      * Sets the system property indicated by the specified key.
 881      *
 882      * First, if a security manager exists, its
 883      * {@code SecurityManager.checkPermission} method
 884      * is called with a {@code PropertyPermission(key, &quot;write&quot;)}
 885      * permission. This may result in a SecurityException being thrown.
 886      * If no exception is thrown, the specified property is set to the given
 887      * value.
 888      *
 889      * @apiNote
 890      * &lt;strong&gt;Changing a standard system property may have unpredictable results
 891      * unless otherwise specified&lt;/strong&gt;.
 892      * See {@linkplain #getProperties getProperties} for details.
 893      *
 894      * @param      key   the name of the system property.
 895      * @param      value the value of the system property.
 896      * @return     the previous value of the system property,
 897      *             or {@code null} if it did not have one.
 898      *
 899      * @throws     SecurityException  if a security manager exists and its
 900      *             {@code checkPermission} method doesn&#39;t allow
 901      *             setting of the specified property.
 902      * @throws     NullPointerException if {@code key} or
 903      *             {@code value} is {@code null}.
 904      * @throws     IllegalArgumentException if {@code key} is empty.
 905      * @see        #getProperty
 906      * @see        java.lang.System#getProperty(java.lang.String)
 907      * @see        java.lang.System#getProperty(java.lang.String, java.lang.String)
 908      * @see        java.util.PropertyPermission
 909      * @see        SecurityManager#checkPermission
 910      * @since      1.2
 911      */
 912     public static String setProperty(String key, String value) {
 913         checkKey(key);
 914         SecurityManager sm = getSecurityManager();
 915         if (sm != null) {
 916             sm.checkPermission(new PropertyPermission(key,
 917                 SecurityConstants.PROPERTY_WRITE_ACTION));
 918         }
 919 
 920         return (String) props.setProperty(key, value);
 921     }
 922 
 923     /**
 924      * Removes the system property indicated by the specified key.
 925      *
 926      * First, if a security manager exists, its
 927      * {@code SecurityManager.checkPermission} method
 928      * is called with a {@code PropertyPermission(key, &quot;write&quot;)}
 929      * permission. This may result in a SecurityException being thrown.
 930      * If no exception is thrown, the specified property is removed.
 931      *
 932      * @apiNote
 933      * &lt;strong&gt;Changing a standard system property may have unpredictable results
 934      * unless otherwise specified&lt;/strong&gt;.
 935      * See {@linkplain #getProperties getProperties} method for details.
 936      *
 937      * @param      key   the name of the system property to be removed.
 938      * @return     the previous string value of the system property,
 939      *             or {@code null} if there was no property with that key.
 940      *
 941      * @throws     SecurityException  if a security manager exists and its
 942      *             {@code checkPropertyAccess} method doesn&#39;t allow
 943      *              access to the specified system property.
 944      * @throws     NullPointerException if {@code key} is {@code null}.
 945      * @throws     IllegalArgumentException if {@code key} is empty.
 946      * @see        #getProperty
 947      * @see        #setProperty
 948      * @see        java.util.Properties
 949      * @see        java.lang.SecurityException
 950      * @see        java.lang.SecurityManager#checkPropertiesAccess()
 951      * @since 1.5
 952      */
 953     public static String clearProperty(String key) {
 954         checkKey(key);
 955         SecurityManager sm = getSecurityManager();
 956         if (sm != null) {
 957             sm.checkPermission(new PropertyPermission(key, &quot;write&quot;));
 958         }
 959 
 960         return (String) props.remove(key);
 961     }
 962 
 963     private static void checkKey(String key) {
 964         if (key == null) {
 965             throw new NullPointerException(&quot;key can&#39;t be null&quot;);
 966         }
 967         if (key.isEmpty()) {
 968             throw new IllegalArgumentException(&quot;key can&#39;t be empty&quot;);
 969         }
 970     }
 971 
 972     /**
 973      * Gets the value of the specified environment variable. An
 974      * environment variable is a system-dependent external named
 975      * value.
 976      *
 977      * &lt;p&gt;If a security manager exists, its
 978      * {@link SecurityManager#checkPermission checkPermission}
 979      * method is called with a
 980      * {@link RuntimePermission RuntimePermission(&quot;getenv.&quot;+name)}
 981      * permission.  This may result in a {@link SecurityException}
 982      * being thrown.  If no exception is thrown the value of the
 983      * variable {@code name} is returned.
 984      *
 985      * &lt;p&gt;&lt;a id=&quot;EnvironmentVSSystemProperties&quot;&gt;&lt;i&gt;System
 986      * properties&lt;/i&gt; and &lt;i&gt;environment variables&lt;/i&gt;&lt;/a&gt; are both
 987      * conceptually mappings between names and values.  Both
 988      * mechanisms can be used to pass user-defined information to a
 989      * Java process.  Environment variables have a more global effect,
 990      * because they are visible to all descendants of the process
 991      * which defines them, not just the immediate Java subprocess.
 992      * They can have subtly different semantics, such as case
 993      * insensitivity, on different operating systems.  For these
 994      * reasons, environment variables are more likely to have
 995      * unintended side effects.  It is best to use system properties
 996      * where possible.  Environment variables should be used when a
 997      * global effect is desired, or when an external system interface
 998      * requires an environment variable (such as {@code PATH}).
 999      *
1000      * &lt;p&gt;On UNIX systems the alphabetic case of {@code name} is
1001      * typically significant, while on Microsoft Windows systems it is
1002      * typically not.  For example, the expression
1003      * {@code System.getenv(&quot;FOO&quot;).equals(System.getenv(&quot;foo&quot;))}
1004      * is likely to be true on Microsoft Windows.
1005      *
1006      * @param  name the name of the environment variable
1007      * @return the string value of the variable, or {@code null}
1008      *         if the variable is not defined in the system environment
1009      * @throws NullPointerException if {@code name} is {@code null}
1010      * @throws SecurityException
1011      *         if a security manager exists and its
1012      *         {@link SecurityManager#checkPermission checkPermission}
1013      *         method doesn&#39;t allow access to the environment variable
1014      *         {@code name}
1015      * @see    #getenv()
1016      * @see    ProcessBuilder#environment()
1017      */
1018     public static String getenv(String name) {
1019         SecurityManager sm = getSecurityManager();
1020         if (sm != null) {
1021             sm.checkPermission(new RuntimePermission(&quot;getenv.&quot;+name));
1022         }
1023 
1024         return ProcessEnvironment.getenv(name);
1025     }
1026 
1027 
1028     /**
1029      * Returns an unmodifiable string map view of the current system environment.
1030      * The environment is a system-dependent mapping from names to
1031      * values which is passed from parent to child processes.
1032      *
1033      * &lt;p&gt;If the system does not support environment variables, an
1034      * empty map is returned.
1035      *
1036      * &lt;p&gt;The returned map will never contain null keys or values.
1037      * Attempting to query the presence of a null key or value will
1038      * throw a {@link NullPointerException}.  Attempting to query
1039      * the presence of a key or value which is not of type
1040      * {@link String} will throw a {@link ClassCastException}.
1041      *
1042      * &lt;p&gt;The returned map and its collection views may not obey the
1043      * general contract of the {@link Object#equals} and
1044      * {@link Object#hashCode} methods.
1045      *
1046      * &lt;p&gt;The returned map is typically case-sensitive on all platforms.
1047      *
1048      * &lt;p&gt;If a security manager exists, its
1049      * {@link SecurityManager#checkPermission checkPermission}
1050      * method is called with a
1051      * {@link RuntimePermission RuntimePermission(&quot;getenv.*&quot;)} permission.
1052      * This may result in a {@link SecurityException} being thrown.
1053      *
1054      * &lt;p&gt;When passing information to a Java subprocess,
1055      * &lt;a href=#EnvironmentVSSystemProperties&gt;system properties&lt;/a&gt;
1056      * are generally preferred over environment variables.
1057      *
1058      * @return the environment as a map of variable names to values
1059      * @throws SecurityException
1060      *         if a security manager exists and its
1061      *         {@link SecurityManager#checkPermission checkPermission}
1062      *         method doesn&#39;t allow access to the process environment
1063      * @see    #getenv(String)
1064      * @see    ProcessBuilder#environment()
1065      * @since  1.5
1066      */
1067     public static java.util.Map&lt;String,String&gt; getenv() {
1068         SecurityManager sm = getSecurityManager();
1069         if (sm != null) {
1070             sm.checkPermission(new RuntimePermission(&quot;getenv.*&quot;));
1071         }
1072 
1073         return ProcessEnvironment.getenv();
1074     }
1075 
1076     /**
1077      * {@code System.Logger} instances log messages that will be
1078      * routed to the underlying logging framework the {@link System.LoggerFinder
1079      * LoggerFinder} uses.
1080      *
1081      * {@code System.Logger} instances are typically obtained from
1082      * the {@link java.lang.System System} class, by calling
1083      * {@link java.lang.System#getLogger(java.lang.String) System.getLogger(loggerName)}
1084      * or {@link java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)
1085      * System.getLogger(loggerName, bundle)}.
1086      *
1087      * @see java.lang.System#getLogger(java.lang.String)
1088      * @see java.lang.System#getLogger(java.lang.String, java.util.ResourceBundle)
1089      * @see java.lang.System.LoggerFinder
1090      *
1091      * @since 9
1092      */
1093     public interface Logger {
1094 
1095         /**
1096          * System {@linkplain Logger loggers} levels.
1097          *
1098          * A level has a {@linkplain #getName() name} and {@linkplain
1099          * #getSeverity() severity}.
1100          * Level values are {@link #ALL}, {@link #TRACE}, {@link #DEBUG},
1101          * {@link #INFO}, {@link #WARNING}, {@link #ERROR}, {@link #OFF},
1102          * by order of increasing severity.
1103          * &lt;br&gt;
1104          * {@link #ALL} and {@link #OFF}
1105          * are simple markers with severities mapped respectively to
1106          * {@link java.lang.Integer#MIN_VALUE Integer.MIN_VALUE} and
1107          * {@link java.lang.Integer#MAX_VALUE Integer.MAX_VALUE}.
1108          * &lt;p&gt;
1109          * &lt;b&gt;Severity values and Mapping to {@code java.util.logging.Level}.&lt;/b&gt;
1110          * &lt;p&gt;
1111          * {@linkplain System.Logger.Level System logger levels} are mapped to
1112          * {@linkplain java.util.logging.Level  java.util.logging levels}
1113          * of corresponding severity.
1114          * &lt;br&gt;The mapping is as follows:
1115          * &lt;br&gt;&lt;br&gt;
1116          * &lt;table class=&quot;striped&quot;&gt;
1117          * &lt;caption&gt;System.Logger Severity Level Mapping&lt;/caption&gt;
1118          * &lt;thead&gt;
1119          * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;System.Logger Levels&lt;/th&gt;
1120          *     &lt;th scope=&quot;col&quot;&gt;java.util.logging Levels&lt;/th&gt;
1121          * &lt;/thead&gt;
1122          * &lt;tbody&gt;
1123          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#ALL ALL}&lt;/th&gt;
1124          *     &lt;td&gt;{@link java.util.logging.Level#ALL ALL}&lt;/td&gt;
1125          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#TRACE TRACE}&lt;/th&gt;
1126          *     &lt;td&gt;{@link java.util.logging.Level#FINER FINER}&lt;/td&gt;
1127          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#DEBUG DEBUG}&lt;/th&gt;
1128          *     &lt;td&gt;{@link java.util.logging.Level#FINE FINE}&lt;/td&gt;
1129          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#INFO INFO}&lt;/th&gt;
1130          *     &lt;td&gt;{@link java.util.logging.Level#INFO INFO}&lt;/td&gt;
1131          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#WARNING WARNING}&lt;/th&gt;
1132          *     &lt;td&gt;{@link java.util.logging.Level#WARNING WARNING}&lt;/td&gt;
1133          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#ERROR ERROR}&lt;/th&gt;
1134          *     &lt;td&gt;{@link java.util.logging.Level#SEVERE SEVERE}&lt;/td&gt;
1135          * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@link Logger.Level#OFF OFF}&lt;/th&gt;
1136          *     &lt;td&gt;{@link java.util.logging.Level#OFF OFF}&lt;/td&gt;
1137          * &lt;/tbody&gt;
1138          * &lt;/table&gt;
1139          *
1140          * @since 9
1141          *
1142          * @see java.lang.System.LoggerFinder
1143          * @see java.lang.System.Logger
1144          */
1145         public enum Level {
1146 
1147             // for convenience, we&#39;re reusing java.util.logging.Level int values
1148             // the mapping logic in sun.util.logging.PlatformLogger depends
1149             // on this.
1150             /**
1151              * A marker to indicate that all levels are enabled.
1152              * This level {@linkplain #getSeverity() severity} is
1153              * {@link Integer#MIN_VALUE}.
1154              */
1155             ALL(Integer.MIN_VALUE),  // typically mapped to/from j.u.l.Level.ALL
1156             /**
1157              * {@code TRACE} level: usually used to log diagnostic information.
1158              * This level {@linkplain #getSeverity() severity} is
1159              * {@code 400}.
1160              */
1161             TRACE(400),   // typically mapped to/from j.u.l.Level.FINER
1162             /**
1163              * {@code DEBUG} level: usually used to log debug information traces.
1164              * This level {@linkplain #getSeverity() severity} is
1165              * {@code 500}.
1166              */
1167             DEBUG(500),   // typically mapped to/from j.u.l.Level.FINEST/FINE/CONFIG
1168             /**
1169              * {@code INFO} level: usually used to log information messages.
1170              * This level {@linkplain #getSeverity() severity} is
1171              * {@code 800}.
1172              */
1173             INFO(800),    // typically mapped to/from j.u.l.Level.INFO
1174             /**
1175              * {@code WARNING} level: usually used to log warning messages.
1176              * This level {@linkplain #getSeverity() severity} is
1177              * {@code 900}.
1178              */
1179             WARNING(900), // typically mapped to/from j.u.l.Level.WARNING
1180             /**
1181              * {@code ERROR} level: usually used to log error messages.
1182              * This level {@linkplain #getSeverity() severity} is
1183              * {@code 1000}.
1184              */
1185             ERROR(1000),  // typically mapped to/from j.u.l.Level.SEVERE
1186             /**
1187              * A marker to indicate that all levels are disabled.
1188              * This level {@linkplain #getSeverity() severity} is
1189              * {@link Integer#MAX_VALUE}.
1190              */
1191             OFF(Integer.MAX_VALUE);  // typically mapped to/from j.u.l.Level.OFF
1192 
1193             private final int severity;
1194 
1195             private Level(int severity) {
1196                 this.severity = severity;
1197             }
1198 
1199             /**
1200              * Returns the name of this level.
1201              * @return this level {@linkplain #name()}.
1202              */
1203             public final String getName() {
1204                 return name();
1205             }
1206 
1207             /**
1208              * Returns the severity of this level.
1209              * A higher severity means a more severe condition.
1210              * @return this level severity.
1211              */
1212             public final int getSeverity() {
1213                 return severity;
1214             }
1215         }
1216 
1217         /**
1218          * Returns the name of this logger.
1219          *
1220          * @return the logger name.
1221          */
1222         public String getName();
1223 
1224         /**
1225          * Checks if a message of the given level would be logged by
1226          * this logger.
1227          *
1228          * @param level the log message level.
1229          * @return {@code true} if the given log message level is currently
1230          *         being logged.
1231          *
1232          * @throws NullPointerException if {@code level} is {@code null}.
1233          */
1234         public boolean isLoggable(Level level);
1235 
1236         /**
1237          * Logs a message.
1238          *
1239          * @implSpec The default implementation for this method calls
1240          * {@code this.log(level, (ResourceBundle)null, msg, (Object[])null);}
1241          *
1242          * @param level the log message level.
1243          * @param msg the string message (or a key in the message catalog, if
1244          * this logger is a {@link
1245          * LoggerFinder#getLocalizedLogger(java.lang.String,
1246          * java.util.ResourceBundle, java.lang.Module) localized logger});
1247          * can be {@code null}.
1248          *
1249          * @throws NullPointerException if {@code level} is {@code null}.
1250          */
1251         public default void log(Level level, String msg) {
1252             log(level, (ResourceBundle) null, msg, (Object[]) null);
1253         }
1254 
1255         /**
1256          * Logs a lazily supplied message.
1257          *
1258          * If the logger is currently enabled for the given log message level
1259          * then a message is logged that is the result produced by the
1260          * given supplier function.  Otherwise, the supplier is not operated on.
1261          *
1262          * @implSpec When logging is enabled for the given level, the default
1263          * implementation for this method calls
1264          * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), (Object[])null);}
1265          *
1266          * @param level the log message level.
1267          * @param msgSupplier a supplier function that produces a message.
1268          *
1269          * @throws NullPointerException if {@code level} is {@code null},
1270          *         or {@code msgSupplier} is {@code null}.
1271          */
1272         public default void log(Level level, Supplier&lt;String&gt; msgSupplier) {
1273             Objects.requireNonNull(msgSupplier);
1274             if (isLoggable(Objects.requireNonNull(level))) {
1275                 log(level, (ResourceBundle) null, msgSupplier.get(), (Object[]) null);
1276             }
1277         }
1278 
1279         /**
1280          * Logs a message produced from the given object.
1281          *
1282          * If the logger is currently enabled for the given log message level then
1283          * a message is logged that, by default, is the result produced from
1284          * calling  toString on the given object.
1285          * Otherwise, the object is not operated on.
1286          *
1287          * @implSpec When logging is enabled for the given level, the default
1288          * implementation for this method calls
1289          * {@code this.log(level, (ResourceBundle)null, obj.toString(), (Object[])null);}
1290          *
1291          * @param level the log message level.
1292          * @param obj the object to log.
1293          *
1294          * @throws NullPointerException if {@code level} is {@code null}, or
1295          *         {@code obj} is {@code null}.
1296          */
1297         public default void log(Level level, Object obj) {
1298             Objects.requireNonNull(obj);
1299             if (isLoggable(Objects.requireNonNull(level))) {
1300                 this.log(level, (ResourceBundle) null, obj.toString(), (Object[]) null);
1301             }
1302         }
1303 
1304         /**
1305          * Logs a message associated with a given throwable.
1306          *
1307          * @implSpec The default implementation for this method calls
1308          * {@code this.log(level, (ResourceBundle)null, msg, thrown);}
1309          *
1310          * @param level the log message level.
1311          * @param msg the string message (or a key in the message catalog, if
1312          * this logger is a {@link
1313          * LoggerFinder#getLocalizedLogger(java.lang.String,
1314          * java.util.ResourceBundle, java.lang.Module) localized logger});
1315          * can be {@code null}.
1316          * @param thrown a {@code Throwable} associated with the log message;
1317          *        can be {@code null}.
1318          *
1319          * @throws NullPointerException if {@code level} is {@code null}.
1320          */
1321         public default void log(Level level, String msg, Throwable thrown) {
1322             this.log(level, null, msg, thrown);
1323         }
1324 
1325         /**
1326          * Logs a lazily supplied message associated with a given throwable.
1327          *
1328          * If the logger is currently enabled for the given log message level
1329          * then a message is logged that is the result produced by the
1330          * given supplier function.  Otherwise, the supplier is not operated on.
1331          *
1332          * @implSpec When logging is enabled for the given level, the default
1333          * implementation for this method calls
1334          * {@code this.log(level, (ResourceBundle)null, msgSupplier.get(), thrown);}
1335          *
1336          * @param level one of the log message level identifiers.
1337          * @param msgSupplier a supplier function that produces a message.
1338          * @param thrown a {@code Throwable} associated with log message;
1339          *               can be {@code null}.
1340          *
1341          * @throws NullPointerException if {@code level} is {@code null}, or
1342          *                               {@code msgSupplier} is {@code null}.
1343          */
1344         public default void log(Level level, Supplier&lt;String&gt; msgSupplier,
1345                 Throwable thrown) {
1346             Objects.requireNonNull(msgSupplier);
1347             if (isLoggable(Objects.requireNonNull(level))) {
1348                 this.log(level, null, msgSupplier.get(), thrown);
1349             }
1350         }
1351 
1352         /**
1353          * Logs a message with an optional list of parameters.
1354          *
1355          * @implSpec The default implementation for this method calls
1356          * {@code this.log(level, (ResourceBundle)null, format, params);}
1357          *
1358          * @param level one of the log message level identifiers.
1359          * @param format the string message format in {@link
1360          * java.text.MessageFormat} format, (or a key in the message
1361          * catalog, if this logger is a {@link
1362          * LoggerFinder#getLocalizedLogger(java.lang.String,
1363          * java.util.ResourceBundle, java.lang.Module) localized logger});
1364          * can be {@code null}.
1365          * @param params an optional list of parameters to the message (may be
1366          * none).
1367          *
1368          * @throws NullPointerException if {@code level} is {@code null}.
1369          */
1370         public default void log(Level level, String format, Object... params) {
1371             this.log(level, null, format, params);
1372         }
1373 
1374         /**
1375          * Logs a localized message associated with a given throwable.
1376          *
1377          * If the given resource bundle is non-{@code null},  the {@code msg}
1378          * string is localized using the given resource bundle.
1379          * Otherwise the {@code msg} string is not localized.
1380          *
1381          * @param level the log message level.
1382          * @param bundle a resource bundle to localize {@code msg}; can be
1383          * {@code null}.
1384          * @param msg the string message (or a key in the message catalog,
1385          *            if {@code bundle} is not {@code null}); can be {@code null}.
1386          * @param thrown a {@code Throwable} associated with the log message;
1387          *        can be {@code null}.
1388          *
1389          * @throws NullPointerException if {@code level} is {@code null}.
1390          */
1391         public void log(Level level, ResourceBundle bundle, String msg,
1392                 Throwable thrown);
1393 
1394         /**
1395          * Logs a message with resource bundle and an optional list of
1396          * parameters.
1397          *
1398          * If the given resource bundle is non-{@code null},  the {@code format}
1399          * string is localized using the given resource bundle.
1400          * Otherwise the {@code format} string is not localized.
1401          *
1402          * @param level the log message level.
1403          * @param bundle a resource bundle to localize {@code format}; can be
1404          * {@code null}.
1405          * @param format the string message format in {@link
1406          * java.text.MessageFormat} format, (or a key in the message
1407          * catalog if {@code bundle} is not {@code null}); can be {@code null}.
1408          * @param params an optional list of parameters to the message (may be
1409          * none).
1410          *
1411          * @throws NullPointerException if {@code level} is {@code null}.
1412          */
1413         public void log(Level level, ResourceBundle bundle, String format,
1414                 Object... params);
1415     }
1416 
1417     /**
1418      * The {@code LoggerFinder} service is responsible for creating, managing,
1419      * and configuring loggers to the underlying framework it uses.
1420      *
1421      * A logger finder is a concrete implementation of this class that has a
1422      * zero-argument constructor and implements the abstract methods defined
1423      * by this class.
1424      * The loggers returned from a logger finder are capable of routing log
1425      * messages to the logging backend this provider supports.
1426      * A given invocation of the Java Runtime maintains a single
1427      * system-wide LoggerFinder instance that is loaded as follows:
1428      * &lt;ul&gt;
1429      *    &lt;li&gt;First it finds any custom {@code LoggerFinder} provider
1430      *        using the {@link java.util.ServiceLoader} facility with the
1431      *        {@linkplain ClassLoader#getSystemClassLoader() system class
1432      *        loader}.&lt;/li&gt;
1433      *    &lt;li&gt;If no {@code LoggerFinder} provider is found, the system default
1434      *        {@code LoggerFinder} implementation will be used.&lt;/li&gt;
1435      * &lt;/ul&gt;
1436      * &lt;p&gt;
1437      * An application can replace the logging backend
1438      * &lt;i&gt;even when the java.logging module is present&lt;/i&gt;, by simply providing
1439      * and declaring an implementation of the {@link LoggerFinder} service.
1440      * &lt;p&gt;
1441      * &lt;b&gt;Default Implementation&lt;/b&gt;
1442      * &lt;p&gt;
1443      * The system default {@code LoggerFinder} implementation uses
1444      * {@code java.util.logging} as the backend framework when the
1445      * {@code java.logging} module is present.
1446      * It returns a {@linkplain System.Logger logger} instance
1447      * that will route log messages to a {@link java.util.logging.Logger
1448      * java.util.logging.Logger}. Otherwise, if {@code java.logging} is not
1449      * present, the default implementation will return a simple logger
1450      * instance that will route log messages of {@code INFO} level and above to
1451      * the console ({@code System.err}).
1452      * &lt;p&gt;
1453      * &lt;b&gt;Logging Configuration&lt;/b&gt;
1454      * &lt;p&gt;
1455      * {@linkplain Logger Logger} instances obtained from the
1456      * {@code LoggerFinder} factory methods are not directly configurable by
1457      * the application. Configuration is the responsibility of the underlying
1458      * logging backend, and usually requires using APIs specific to that backend.
1459      * &lt;p&gt;For the default {@code LoggerFinder} implementation
1460      * using {@code java.util.logging} as its backend, refer to
1461      * {@link java.util.logging java.util.logging} for logging configuration.
1462      * For the default {@code LoggerFinder} implementation returning simple loggers
1463      * when the {@code java.logging} module is absent, the configuration
1464      * is implementation dependent.
1465      * &lt;p&gt;
1466      * Usually an application that uses a logging framework will log messages
1467      * through a logger facade defined (or supported) by that framework.
1468      * Applications that wish to use an external framework should log
1469      * through the facade associated with that framework.
1470      * &lt;p&gt;
1471      * A system class that needs to log messages will typically obtain
1472      * a {@link System.Logger} instance to route messages to the logging
1473      * framework selected by the application.
1474      * &lt;p&gt;
1475      * Libraries and classes that only need loggers to produce log messages
1476      * should not attempt to configure loggers by themselves, as that
1477      * would make them dependent from a specific implementation of the
1478      * {@code LoggerFinder} service.
1479      * &lt;p&gt;
1480      * In addition, when a security manager is present, loggers provided to
1481      * system classes should not be directly configurable through the logging
1482      * backend without requiring permissions.
1483      * &lt;br&gt;
1484      * It is the responsibility of the provider of
1485      * the concrete {@code LoggerFinder} implementation to ensure that
1486      * these loggers are not configured by untrusted code without proper
1487      * permission checks, as configuration performed on such loggers usually
1488      * affects all applications in the same Java Runtime.
1489      * &lt;p&gt;
1490      * &lt;b&gt;Message Levels and Mapping to backend levels&lt;/b&gt;
1491      * &lt;p&gt;
1492      * A logger finder is responsible for mapping from a {@code
1493      * System.Logger.Level} to a level supported by the logging backend it uses.
1494      * &lt;br&gt;The default LoggerFinder using {@code java.util.logging} as the backend
1495      * maps {@code System.Logger} levels to
1496      * {@linkplain java.util.logging.Level java.util.logging} levels
1497      * of corresponding severity - as described in {@link Logger.Level
1498      * Logger.Level}.
1499      *
1500      * @see java.lang.System
1501      * @see java.lang.System.Logger
1502      *
1503      * @since 9
1504      */
1505     public static abstract class LoggerFinder {
1506         /**
1507          * The {@code RuntimePermission(&quot;loggerFinder&quot;)} is
1508          * necessary to subclass and instantiate the {@code LoggerFinder} class,
1509          * as well as to obtain loggers from an instance of that class.
1510          */
1511         static final RuntimePermission LOGGERFINDER_PERMISSION =
1512                 new RuntimePermission(&quot;loggerFinder&quot;);
1513 
1514         /**
1515          * Creates a new instance of {@code LoggerFinder}.
1516          *
1517          * @implNote It is recommended that a {@code LoggerFinder} service
1518          *   implementation does not perform any heavy initialization in its
1519          *   constructor, in order to avoid possible risks of deadlock or class
1520          *   loading cycles during the instantiation of the service provider.
1521          *
1522          * @throws SecurityException if a security manager is present and its
1523          *         {@code checkPermission} method doesn&#39;t allow the
1524          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1525          */
1526         protected LoggerFinder() {
1527             this(checkPermission());
1528         }
1529 
1530         private LoggerFinder(Void unused) {
1531             // nothing to do.
1532         }
1533 
1534         private static Void checkPermission() {
1535             final SecurityManager sm = System.getSecurityManager();
1536             if (sm != null) {
1537                 sm.checkPermission(LOGGERFINDER_PERMISSION);
1538             }
1539             return null;
1540         }
1541 
1542         /**
1543          * Returns an instance of {@link Logger Logger}
1544          * for the given {@code module}.
1545          *
1546          * @param name the name of the logger.
1547          * @param module the module for which the logger is being requested.
1548          *
1549          * @return a {@link Logger logger} suitable for use within the given
1550          *         module.
1551          * @throws NullPointerException if {@code name} is {@code null} or
1552          *        {@code module} is {@code null}.
1553          * @throws SecurityException if a security manager is present and its
1554          *         {@code checkPermission} method doesn&#39;t allow the
1555          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1556          */
1557         public abstract Logger getLogger(String name, Module module);
1558 
1559         /**
1560          * Returns a localizable instance of {@link Logger Logger}
1561          * for the given {@code module}.
1562          * The returned logger will use the provided resource bundle for
1563          * message localization.
1564          *
1565          * @implSpec By default, this method calls {@link
1566          * #getLogger(java.lang.String, java.lang.Module)
1567          * this.getLogger(name, module)} to obtain a logger, then wraps that
1568          * logger in a {@link Logger} instance where all methods that do not
1569          * take a {@link ResourceBundle} as parameter are redirected to one
1570          * which does - passing the given {@code bundle} for
1571          * localization. So for instance, a call to {@link
1572          * Logger#log(Logger.Level, String) Logger.log(Level.INFO, msg)}
1573          * will end up as a call to {@link
1574          * Logger#log(Logger.Level, ResourceBundle, String, Object...)
1575          * Logger.log(Level.INFO, bundle, msg, (Object[])null)} on the wrapped
1576          * logger instance.
1577          * Note however that by default, string messages returned by {@link
1578          * java.util.function.Supplier Supplier&amp;lt;String&amp;gt;} will not be
1579          * localized, as it is assumed that such strings are messages which are
1580          * already constructed, rather than keys in a resource bundle.
1581          * &lt;p&gt;
1582          * An implementation of {@code LoggerFinder} may override this method,
1583          * for example, when the underlying logging backend provides its own
1584          * mechanism for localizing log messages, then such a
1585          * {@code LoggerFinder} would be free to return a logger
1586          * that makes direct use of the mechanism provided by the backend.
1587          *
1588          * @param name    the name of the logger.
1589          * @param bundle  a resource bundle; can be {@code null}.
1590          * @param module  the module for which the logger is being requested.
1591          * @return an instance of {@link Logger Logger}  which will use the
1592          * provided resource bundle for message localization.
1593          *
1594          * @throws NullPointerException if {@code name} is {@code null} or
1595          *         {@code module} is {@code null}.
1596          * @throws SecurityException if a security manager is present and its
1597          *         {@code checkPermission} method doesn&#39;t allow the
1598          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1599          */
1600         public Logger getLocalizedLogger(String name, ResourceBundle bundle,
1601                                          Module module) {
1602             return new LocalizedLoggerWrapper&lt;&gt;(getLogger(name, module), bundle);
1603         }
1604 
1605         /**
1606          * Returns the {@code LoggerFinder} instance. There is one
1607          * single system-wide {@code LoggerFinder} instance in
1608          * the Java Runtime.  See the class specification of how the
1609          * {@link LoggerFinder LoggerFinder} implementation is located and
1610          * loaded.
1611          *
1612          * @return the {@link LoggerFinder LoggerFinder} instance.
1613          * @throws SecurityException if a security manager is present and its
1614          *         {@code checkPermission} method doesn&#39;t allow the
1615          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1616          */
1617         public static LoggerFinder getLoggerFinder() {
1618             final SecurityManager sm = System.getSecurityManager();
1619             if (sm != null) {
1620                 sm.checkPermission(LOGGERFINDER_PERMISSION);
1621             }
1622             return accessProvider();
1623         }
1624 
1625 
1626         private static volatile LoggerFinder service;
1627         static LoggerFinder accessProvider() {
1628             // We do not need to synchronize: LoggerFinderLoader will
1629             // always return the same instance, so if we don&#39;t have it,
1630             // just fetch it again.
1631             if (service == null) {
1632                 PrivilegedAction&lt;LoggerFinder&gt; pa =
1633                         () -&gt; LoggerFinderLoader.getLoggerFinder();
1634                 service = AccessController.doPrivileged(pa, null,
1635                         LOGGERFINDER_PERMISSION);
1636             }
1637             return service;
1638         }
1639 
1640     }
1641 
1642 
1643     /**
1644      * Returns an instance of {@link Logger Logger} for the caller&#39;s
1645      * use.
1646      *
1647      * @implSpec
1648      * Instances returned by this method route messages to loggers
1649      * obtained by calling {@link LoggerFinder#getLogger(java.lang.String,
1650      * java.lang.Module) LoggerFinder.getLogger(name, module)}, where
1651      * {@code module} is the caller&#39;s module.
1652      * In cases where {@code System.getLogger} is called from a context where
1653      * there is no caller frame on the stack (e.g when called directly
1654      * from a JNI attached thread), {@code IllegalCallerException} is thrown.
1655      * To obtain a logger in such a context, use an auxiliary class that will
1656      * implicitly be identified as the caller, or use the system {@link
1657      * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.
1658      * Note that doing the latter may eagerly initialize the underlying
1659      * logging system.
1660      *
1661      * @apiNote
1662      * This method may defer calling the {@link
1663      * LoggerFinder#getLogger(java.lang.String, java.lang.Module)
1664      * LoggerFinder.getLogger} method to create an actual logger supplied by
1665      * the logging backend, for instance, to allow loggers to be obtained during
1666      * the system initialization time.
1667      *
1668      * @param name the name of the logger.
1669      * @return an instance of {@link Logger} that can be used by the calling
1670      *         class.
1671      * @throws NullPointerException if {@code name} is {@code null}.
1672      * @throws IllegalCallerException if there is no Java caller frame on the
1673      *         stack.
1674      *
1675      * @since 9
1676      */
1677     @CallerSensitive
1678     public static Logger getLogger(String name) {
1679         Objects.requireNonNull(name);
1680         final Class&lt;?&gt; caller = Reflection.getCallerClass();
1681         if (caller == null) {
1682             throw new IllegalCallerException(&quot;no caller frame&quot;);
1683         }
1684         return LazyLoggers.getLogger(name, caller.getModule());
1685     }
1686 
1687     /**
1688      * Returns a localizable instance of {@link Logger
1689      * Logger} for the caller&#39;s use.
1690      * The returned logger will use the provided resource bundle for message
1691      * localization.
1692      *
1693      * @implSpec
1694      * The returned logger will perform message localization as specified
1695      * by {@link LoggerFinder#getLocalizedLogger(java.lang.String,
1696      * java.util.ResourceBundle, java.lang.Module)
1697      * LoggerFinder.getLocalizedLogger(name, bundle, module)}, where
1698      * {@code module} is the caller&#39;s module.
1699      * In cases where {@code System.getLogger} is called from a context where
1700      * there is no caller frame on the stack (e.g when called directly
1701      * from a JNI attached thread), {@code IllegalCallerException} is thrown.
1702      * To obtain a logger in such a context, use an auxiliary class that
1703      * will implicitly be identified as the caller, or use the system {@link
1704      * LoggerFinder#getLoggerFinder() LoggerFinder} to obtain a logger instead.
1705      * Note that doing the latter may eagerly initialize the underlying
1706      * logging system.
1707      *
1708      * @apiNote
1709      * This method is intended to be used after the system is fully initialized.
1710      * This method may trigger the immediate loading and initialization
1711      * of the {@link LoggerFinder} service, which may cause issues if the
1712      * Java Runtime is not ready to initialize the concrete service
1713      * implementation yet.
1714      * System classes which may be loaded early in the boot sequence and
1715      * need to log localized messages should create a logger using
1716      * {@link #getLogger(java.lang.String)} and then use the log methods that
1717      * take a resource bundle as parameter.
1718      *
1719      * @param name    the name of the logger.
1720      * @param bundle  a resource bundle.
1721      * @return an instance of {@link Logger} which will use the provided
1722      * resource bundle for message localization.
1723      * @throws NullPointerException if {@code name} is {@code null} or
1724      *         {@code bundle} is {@code null}.
1725      * @throws IllegalCallerException if there is no Java caller frame on the
1726      *         stack.
1727      *
1728      * @since 9
1729      */
1730     @CallerSensitive
1731     public static Logger getLogger(String name, ResourceBundle bundle) {
1732         final ResourceBundle rb = Objects.requireNonNull(bundle);
1733         Objects.requireNonNull(name);
1734         final Class&lt;?&gt; caller = Reflection.getCallerClass();
1735         if (caller == null) {
1736             throw new IllegalCallerException(&quot;no caller frame&quot;);
1737         }
1738         final SecurityManager sm = System.getSecurityManager();
1739         // We don&#39;t use LazyLoggers if a resource bundle is specified.
1740         // Bootstrap sensitive classes in the JDK do not use resource bundles
1741         // when logging. This could be revisited later, if it needs to.
1742         if (sm != null) {
1743             final PrivilegedAction&lt;Logger&gt; pa =
1744                     () -&gt; LoggerFinder.accessProvider()
1745                             .getLocalizedLogger(name, rb, caller.getModule());
1746             return AccessController.doPrivileged(pa, null,
1747                                          LoggerFinder.LOGGERFINDER_PERMISSION);
1748         }
1749         return LoggerFinder.accessProvider()
1750                 .getLocalizedLogger(name, rb, caller.getModule());
1751     }
1752 
1753     /**
1754      * Terminates the currently running Java Virtual Machine. The
1755      * argument serves as a status code; by convention, a nonzero status
1756      * code indicates abnormal termination.
1757      * &lt;p&gt;
1758      * This method calls the {@code exit} method in class
1759      * {@code Runtime}. This method never returns normally.
1760      * &lt;p&gt;
1761      * The call {@code System.exit(n)} is effectively equivalent to
1762      * the call:
1763      * &lt;blockquote&gt;&lt;pre&gt;
1764      * Runtime.getRuntime().exit(n)
1765      * &lt;/pre&gt;&lt;/blockquote&gt;
1766      *
1767      * @param      status   exit status.
1768      * @throws  SecurityException
1769      *        if a security manager exists and its {@code checkExit}
1770      *        method doesn&#39;t allow exit with the specified status.
1771      * @see        java.lang.Runtime#exit(int)
1772      */
1773     public static void exit(int status) {
1774         Runtime.getRuntime().exit(status);
1775     }
1776 
1777     /**
1778      * Runs the garbage collector in the Java Virtual Machine.
1779      * &lt;p&gt;
1780      * Calling the {@code gc} method suggests that the Java Virtual Machine
1781      * expend effort toward recycling unused objects in order to
1782      * make the memory they currently occupy available for reuse
1783      * by the Java Virtual Machine.
1784      * When control returns from the method call, the Java Virtual Machine
1785      * has made a best effort to reclaim space from all unused objects.
1786      * There is no guarantee that this effort will recycle any particular
1787      * number of unused objects, reclaim any particular amount of space, or
1788      * complete at any particular time, if at all, before the method returns or ever.
1789      * &lt;p&gt;
1790      * The call {@code System.gc()} is effectively equivalent to the
1791      * call:
1792      * &lt;blockquote&gt;&lt;pre&gt;
1793      * Runtime.getRuntime().gc()
1794      * &lt;/pre&gt;&lt;/blockquote&gt;
1795      *
1796      * @see     java.lang.Runtime#gc()
1797      */
1798     public static void gc() {
1799         Runtime.getRuntime().gc();
1800     }
1801 
1802     /**
1803      * Runs the finalization methods of any objects pending finalization.
1804      *
1805      * Calling this method suggests that the Java Virtual Machine expend
1806      * effort toward running the {@code finalize} methods of objects
1807      * that have been found to be discarded but whose {@code finalize}
1808      * methods have not yet been run. When control returns from the
1809      * method call, the Java Virtual Machine has made a best effort to
1810      * complete all outstanding finalizations.
1811      * &lt;p&gt;
1812      * The call {@code System.runFinalization()} is effectively
1813      * equivalent to the call:
1814      * &lt;blockquote&gt;&lt;pre&gt;
1815      * Runtime.getRuntime().runFinalization()
1816      * &lt;/pre&gt;&lt;/blockquote&gt;
1817      *
1818      * @see     java.lang.Runtime#runFinalization()
1819      */
1820     public static void runFinalization() {
1821         Runtime.getRuntime().runFinalization();
1822     }
1823 
1824     /**
1825      * Loads the native library specified by the filename argument.  The filename
1826      * argument must be an absolute path name.
1827      *
1828      * If the filename argument, when stripped of any platform-specific library
1829      * prefix, path, and file extension, indicates a library whose name is,
1830      * for example, L, and a native library called L is statically linked
1831      * with the VM, then the JNI_OnLoad_L function exported by the library
1832      * is invoked rather than attempting to load a dynamic library.
1833      * A filename matching the argument does not have to exist in the
1834      * file system.
1835      * See the &lt;a href=&quot;{@docRoot}/../specs/jni/index.html&quot;&gt; JNI Specification&lt;/a&gt;
1836      * for more details.
1837      *
1838      * Otherwise, the filename argument is mapped to a native library image in
1839      * an implementation-dependent manner.
1840      *
1841      * &lt;p&gt;
1842      * The call {@code System.load(name)} is effectively equivalent
1843      * to the call:
1844      * &lt;blockquote&gt;&lt;pre&gt;
1845      * Runtime.getRuntime().load(name)
1846      * &lt;/pre&gt;&lt;/blockquote&gt;
1847      *
1848      * @param      filename   the file to load.
1849      * @throws     SecurityException  if a security manager exists and its
1850      *             {@code checkLink} method doesn&#39;t allow
1851      *             loading of the specified dynamic library
1852      * @throws     UnsatisfiedLinkError  if either the filename is not an
1853      *             absolute path name, the native library is not statically
1854      *             linked with the VM, or the library cannot be mapped to
1855      *             a native library image by the host system.
1856      * @throws     NullPointerException if {@code filename} is {@code null}
1857      * @see        java.lang.Runtime#load(java.lang.String)
1858      * @see        java.lang.SecurityManager#checkLink(java.lang.String)
1859      */
1860     @CallerSensitive
1861     public static void load(String filename) {
1862         Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);
1863     }
1864 
1865     /**
1866      * Loads the native library specified by the {@code libname}
1867      * argument.  The {@code libname} argument must not contain any platform
1868      * specific prefix, file extension or path. If a native library
1869      * called {@code libname} is statically linked with the VM, then the
1870      * JNI_OnLoad_{@code libname} function exported by the library is invoked.
1871      * See the &lt;a href=&quot;{@docRoot}/../specs/jni/index.html&quot;&gt; JNI Specification&lt;/a&gt;
1872      * for more details.
1873      *
1874      * Otherwise, the libname argument is loaded from a system library
1875      * location and mapped to a native library image in an
1876      * implementation-dependent manner.
1877      * &lt;p&gt;
1878      * The call {@code System.loadLibrary(name)} is effectively
1879      * equivalent to the call
1880      * &lt;blockquote&gt;&lt;pre&gt;
1881      * Runtime.getRuntime().loadLibrary(name)
1882      * &lt;/pre&gt;&lt;/blockquote&gt;
1883      *
1884      * @param      libname   the name of the library.
1885      * @throws     SecurityException  if a security manager exists and its
1886      *             {@code checkLink} method doesn&#39;t allow
1887      *             loading of the specified dynamic library
1888      * @throws     UnsatisfiedLinkError if either the libname argument
1889      *             contains a file path, the native library is not statically
1890      *             linked with the VM,  or the library cannot be mapped to a
1891      *             native library image by the host system.
1892      * @throws     NullPointerException if {@code libname} is {@code null}
1893      * @see        java.lang.Runtime#loadLibrary(java.lang.String)
1894      * @see        java.lang.SecurityManager#checkLink(java.lang.String)
1895      */
1896     @CallerSensitive
1897     public static void loadLibrary(String libname) {
1898         Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);
1899     }
1900 
1901     /**
1902      * Maps a library name into a platform-specific string representing
1903      * a native library.
1904      *
1905      * @param      libname the name of the library.
1906      * @return     a platform-dependent native library name.
1907      * @throws     NullPointerException if {@code libname} is {@code null}
1908      * @see        java.lang.System#loadLibrary(java.lang.String)
1909      * @see        java.lang.ClassLoader#findLibrary(java.lang.String)
1910      * @since      1.2
1911      */
1912     public static native String mapLibraryName(String libname);
1913 
1914     /**
1915      * Create PrintStream for stdout/err based on encoding.
1916      */
1917     private static PrintStream newPrintStream(FileOutputStream fos, String enc) {
1918        if (enc != null) {
1919             try {
1920                 return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);
1921             } catch (UnsupportedEncodingException uee) {}
1922         }
1923         return new PrintStream(new BufferedOutputStream(fos, 128), true);
1924     }
1925 
1926     /**
1927      * Logs an exception/error at initialization time to stdout or stderr.
1928      *
1929      * @param printToStderr to print to stderr rather than stdout
1930      * @param printStackTrace to print the stack trace
1931      * @param msg the message to print before the exception, can be {@code null}
1932      * @param e the exception or error
1933      */
1934     private static void logInitException(boolean printToStderr,
1935                                          boolean printStackTrace,
1936                                          String msg,
1937                                          Throwable e) {
1938         if (VM.initLevel() &lt; 1) {
1939             throw new InternalError(&quot;system classes not initialized&quot;);
1940         }
1941         PrintStream log = (printToStderr) ? err : out;
1942         if (msg != null) {
1943             log.println(msg);
1944         }
1945         if (printStackTrace) {
1946             e.printStackTrace(log);
1947         } else {
1948             log.println(e);
1949             for (Throwable suppressed : e.getSuppressed()) {
1950                 log.println(&quot;Suppressed: &quot; + suppressed);
1951             }
1952             Throwable cause = e.getCause();
1953             if (cause != null) {
1954                 log.println(&quot;Caused by: &quot; + cause);
1955             }
1956         }
1957     }
1958 
1959     /**
1960      * Create the Properties object from a map - masking out system properties
1961      * that are not intended for public access.
1962      */
1963     private static Properties createProperties(Map&lt;String, String&gt; initialProps) {
1964         Properties properties = new Properties(initialProps.size());
1965         for (var entry : initialProps.entrySet()) {
1966             String prop = entry.getKey();
1967             switch (prop) {
1968                 // Do not add private system properties to the Properties
1969                 case &quot;sun.nio.MaxDirectMemorySize&quot;:
1970                 case &quot;sun.nio.PageAlignDirectMemory&quot;:
1971                     // used by java.lang.Integer.IntegerCache
1972                 case &quot;java.lang.Integer.IntegerCache.high&quot;:
1973                     // used by sun.launcher.LauncherHelper
1974                 case &quot;sun.java.launcher.diag&quot;:
1975                     // used by jdk.internal.loader.ClassLoaders
1976                 case &quot;jdk.boot.class.path.append&quot;:
1977                     break;
1978                 default:
1979                     properties.put(prop, entry.getValue());
1980             }
1981         }
1982         return properties;
1983     }
1984 
1985     /**
1986      * Initialize the system class.  Called after thread initialization.
1987      */
1988     private static void initPhase1() {
1989         // VM might invoke JNU_NewStringPlatform() to set those encoding
1990         // sensitive properties (user.home, user.name, boot.class.path, etc.)
1991         // during &quot;props&quot; initialization.
1992         // The charset is initialized in System.c and does not depend on the Properties.
1993         Map&lt;String, String&gt; tempProps = SystemProps.initProperties();
1994         VersionProps.init(tempProps);
1995 
1996         // There are certain system configurations that may be controlled by
1997         // VM options such as the maximum amount of direct memory and
1998         // Integer cache size used to support the object identity semantics
1999         // of autoboxing.  Typically, the library will obtain these values
2000         // from the properties set by the VM.  If the properties are for
2001         // internal implementation use only, these properties should be
2002         // masked from the system properties.
2003         //
2004         // Save a private copy of the system properties object that
2005         // can only be accessed by the internal implementation.
2006         VM.saveProperties(tempProps);
2007         props = createProperties(tempProps);
2008 
2009         StaticProperty.javaHome();          // Load StaticProperty to cache the property values
2010 
2011         lineSeparator = props.getProperty(&quot;line.separator&quot;);
2012 
2013         FileInputStream fdIn = new FileInputStream(FileDescriptor.in);
2014         FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);
2015         FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);
2016         setIn0(new BufferedInputStream(fdIn));
2017         setOut0(newPrintStream(fdOut, props.getProperty(&quot;sun.stdout.encoding&quot;)));
2018         setErr0(newPrintStream(fdErr, props.getProperty(&quot;sun.stderr.encoding&quot;)));
2019 
2020         // Setup Java signal handlers for HUP, TERM, and INT (where available).
2021         Terminator.setup();
2022 
2023         // Initialize any miscellaneous operating system settings that need to be
2024         // set for the class libraries. Currently this is no-op everywhere except
2025         // for Windows where the process-wide error mode is set before the java.io
2026         // classes are used.
2027         VM.initializeOSEnvironment();
2028 
2029         // The main thread is not added to its thread group in the same
2030         // way as other threads; we must do it ourselves here.
2031         Thread current = Thread.currentThread();
2032         current.getThreadGroup().add(current);
2033 
2034         // register shared secrets
2035         setJavaLangAccess();
2036 
2037         // Subsystems that are invoked during initialization can invoke
2038         // VM.isBooted() in order to avoid doing things that should
2039         // wait until the VM is fully initialized. The initialization level
2040         // is incremented from 0 to 1 here to indicate the first phase of
2041         // initialization has completed.
2042         // IMPORTANT: Ensure that this remains the last initialization action!
2043         VM.initLevel(1);
2044     }
2045 
2046     // @see #initPhase2()
2047     static ModuleLayer bootLayer;
2048 
2049     /*
2050      * Invoked by VM.  Phase 2 module system initialization.
2051      * Only classes in java.base can be loaded in this phase.
2052      *
2053      * @param printToStderr print exceptions to stderr rather than stdout
2054      * @param printStackTrace print stack trace when exception occurs
2055      *
2056      * @return JNI_OK for success, JNI_ERR for failure
2057      */
2058     private static int initPhase2(boolean printToStderr, boolean printStackTrace) {
2059 
2060         try {
2061             bootLayer = ModuleBootstrap.boot();
2062         } catch (Exception | Error e) {
2063             logInitException(printToStderr, printStackTrace,
2064                              &quot;Error occurred during initialization of boot layer&quot;, e);
2065             return -1; // JNI_ERR
2066         }
2067 
2068         // module system initialized
2069         VM.initLevel(2);
2070 
2071         return 0; // JNI_OK
2072     }
2073 
2074     /*
2075      * Invoked by VM.  Phase 3 is the final system initialization:
2076      * 1. eagerly initialize bootstrap method factories that might interact
2077      *    negatively with custom security managers and custom class loaders
2078      * 2. set security manager
2079      * 3. set system class loader
2080      * 4. set TCCL
2081      *
2082      * This method must be called after the module system initialization.
2083      * The security manager and system class loader may be a custom class from
2084      * the application classpath or modulepath.
2085      */
2086     private static void initPhase3() {
2087 
2088         // Initialize the StringConcatFactory eagerly to avoid potential
2089         // bootstrap circularity issues that could be caused by a custom
2090         // SecurityManager
2091         Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);
2092 
2093         String smProp = System.getProperty(&quot;java.security.manager&quot;);
2094         if (smProp != null) {
2095             switch (smProp) {
2096                 case &quot;disallow&quot;:
2097                     allowSecurityManager = NEVER;
2098                     break;
2099                 case &quot;allow&quot;:
2100                     allowSecurityManager = MAYBE;
2101                     break;
2102                 case &quot;&quot;:
2103                 case &quot;default&quot;:
2104                     setSecurityManager(new SecurityManager());
2105                     allowSecurityManager = MAYBE;
2106                     break;
2107                 default:
2108                     try {
2109                         ClassLoader cl = ClassLoader.getBuiltinAppClassLoader();
2110                         Class&lt;?&gt; c = Class.forName(smProp, false, cl);
2111                         Constructor&lt;?&gt; ctor = c.getConstructor();
2112                         // Must be a public subclass of SecurityManager with
2113                         // a public no-arg constructor
2114                         if (!SecurityManager.class.isAssignableFrom(c) ||
2115                             !Modifier.isPublic(c.getModifiers()) ||
2116                             !Modifier.isPublic(ctor.getModifiers())) {
2117                             throw new Error(&quot;Could not create SecurityManager: &quot;
2118                                              + ctor.toString());
2119                         }
2120                         // custom security manager may be in non-exported package
2121                         ctor.setAccessible(true);
2122                         SecurityManager sm = (SecurityManager) ctor.newInstance();
2123                         setSecurityManager(sm);
2124                     } catch (Exception e) {
2125                         throw new InternalError(&quot;Could not create SecurityManager&quot;, e);
2126                     }
2127                     allowSecurityManager = MAYBE;
2128             }
2129         } else {
2130             allowSecurityManager = MAYBE;
2131         }
2132 
2133         // initializing the system class loader
2134         VM.initLevel(3);
2135 
2136         // system class loader initialized
2137         ClassLoader scl = ClassLoader.initSystemClassLoader();
2138 
2139         // set TCCL
2140         Thread.currentThread().setContextClassLoader(scl);
2141 
2142         // system is fully initialized
2143         VM.initLevel(4);
2144     }
2145 
2146     private static void setJavaLangAccess() {
2147         // Allow privileged classes outside of java.lang
2148         SharedSecrets.setJavaLangAccess(new JavaLangAccess() {
2149             public List&lt;Method&gt; getDeclaredPublicMethods(Class&lt;?&gt; klass, String name, Class&lt;?&gt;... parameterTypes) {
2150                 return klass.getDeclaredPublicMethods(name, parameterTypes);
2151             }
2152             public jdk.internal.reflect.ConstantPool getConstantPool(Class&lt;?&gt; klass) {
2153                 return klass.getConstantPool();
2154             }
2155             public boolean casAnnotationType(Class&lt;?&gt; klass, AnnotationType oldType, AnnotationType newType) {
2156                 return klass.casAnnotationType(oldType, newType);
2157             }
2158             public AnnotationType getAnnotationType(Class&lt;?&gt; klass) {
2159                 return klass.getAnnotationType();
2160             }
2161             public Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap(Class&lt;?&gt; klass) {
2162                 return klass.getDeclaredAnnotationMap();
2163             }
2164             public byte[] getRawClassAnnotations(Class&lt;?&gt; klass) {
2165                 return klass.getRawAnnotations();
2166             }
2167             public byte[] getRawClassTypeAnnotations(Class&lt;?&gt; klass) {
2168                 return klass.getRawTypeAnnotations();
2169             }
2170             public byte[] getRawExecutableTypeAnnotations(Executable executable) {
2171                 return Class.getExecutableTypeAnnotationBytes(executable);
2172             }
2173             public &lt;E extends Enum&lt;E&gt;&gt;
2174             E[] getEnumConstantsShared(Class&lt;E&gt; klass) {
2175                 return klass.getEnumConstantsShared();
2176             }
2177             public void blockedOn(Interruptible b) {
2178                 Thread.blockedOn(b);
2179             }
2180             public void registerShutdownHook(int slot, boolean registerShutdownInProgress, Runnable hook) {
2181                 Shutdown.add(slot, registerShutdownInProgress, hook);
2182             }
2183             public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {
2184                 return new Thread(target, acc);
2185             }
2186             @SuppressWarnings(&quot;deprecation&quot;)
2187             public void invokeFinalize(Object o) throws Throwable {
2188                 o.finalize();
2189             }
2190             public ConcurrentHashMap&lt;?, ?&gt; createOrGetClassLoaderValueMap(ClassLoader cl) {
2191                 return cl.createOrGetClassLoaderValueMap();
2192             }
2193             public Class&lt;?&gt; defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {
2194                 return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);
2195             }
2196             public Class&lt;?&gt; defineClass(ClassLoader loader, Class&lt;?&gt; lookup, String name, byte[] b, ProtectionDomain pd,
2197                                         boolean initialize, int flags, Object classData) {
2198                 return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);
2199             }
2200             public Class&lt;?&gt; findBootstrapClassOrNull(ClassLoader cl, String name) {
2201                 return cl.findBootstrapClassOrNull(name);
2202             }
2203             public Package definePackage(ClassLoader cl, String name, Module module) {
2204                 return cl.definePackage(name, module);
2205             }
2206             public String fastUUID(long lsb, long msb) {
2207                 return Long.fastUUID(lsb, msb);
2208             }
2209             public void addNonExportedPackages(ModuleLayer layer) {
2210                 SecurityManager.addNonExportedPackages(layer);
2211             }
2212             public void invalidatePackageAccessCache() {
2213                 SecurityManager.invalidatePackageAccessCache();
2214             }
2215             public Module defineModule(ClassLoader loader,
2216                                        ModuleDescriptor descriptor,
2217                                        URI uri) {
2218                 return new Module(null, loader, descriptor, uri);
2219             }
2220             public Module defineUnnamedModule(ClassLoader loader) {
2221                 return new Module(loader);
2222             }
2223             public void addReads(Module m1, Module m2) {
2224                 m1.implAddReads(m2);
2225             }
2226             public void addReadsAllUnnamed(Module m) {
2227                 m.implAddReadsAllUnnamed();
2228             }
2229             public void addExports(Module m, String pn, Module other) {
2230                 m.implAddExports(pn, other);
2231             }
2232             public void addExportsToAllUnnamed(Module m, String pn) {
2233                 m.implAddExportsToAllUnnamed(pn);
2234             }
2235             public void addOpens(Module m, String pn, Module other) {
2236                 m.implAddOpens(pn, other);
2237             }
2238             public void addOpensToAllUnnamed(Module m, String pn) {
2239                 m.implAddOpensToAllUnnamed(pn);
2240             }
2241             public void addOpensToAllUnnamed(Module m, Set&lt;String&gt; concealedPackages, Set&lt;String&gt; exportedPackages) {
2242                 m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);
2243             }
2244             public void addUses(Module m, Class&lt;?&gt; service) {
2245                 m.implAddUses(service);
2246             }
2247             public boolean isReflectivelyExported(Module m, String pn, Module other) {
2248                 return m.isReflectivelyExported(pn, other);
2249             }
2250             public boolean isReflectivelyOpened(Module m, String pn, Module other) {
2251                 return m.isReflectivelyOpened(pn, other);
2252             }
2253             public ServicesCatalog getServicesCatalog(ModuleLayer layer) {
2254                 return layer.getServicesCatalog();
2255             }
2256             public Stream&lt;ModuleLayer&gt; layers(ModuleLayer layer) {
2257                 return layer.layers();
2258             }
2259             public Stream&lt;ModuleLayer&gt; layers(ClassLoader loader) {
2260                 return ModuleLayer.layers(loader);
2261             }
2262 
2263             public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {
2264                 return StringCoding.newStringNoRepl(bytes, cs);
2265             }
2266 
2267             public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
2268                 return StringCoding.getBytesNoRepl(s, cs);
2269             }
2270 
2271             public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {
2272                 return StringCoding.newStringUTF8NoRepl(bytes, off, len);
2273             }
2274 
2275             public byte[] getBytesUTF8NoRepl(String s) {
2276                 return StringCoding.getBytesUTF8NoRepl(s);
2277             }
2278 
2279             public void setCause(Throwable t, Throwable cause) {
2280                 t.setCause(cause);
2281             }
2282 
2283             public ProtectionDomain protectionDomain(Class&lt;?&gt; c) {
2284                 return c.protectionDomain();
2285             }
2286 
2287             public MethodHandle stringConcatHelper(String name, MethodType methodType) {
2288                 return StringConcatHelper.lookupStatic(name, methodType);
2289             }
2290 
2291             public Object classData(Class&lt;?&gt; c) {
2292                 return c.getClassData();
2293             }
2294         });
2295     }
2296 }
    </pre>
  </body>
</html>
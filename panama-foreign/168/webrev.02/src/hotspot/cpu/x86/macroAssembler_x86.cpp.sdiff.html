<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2031     increment(dst);
2032   } else { // unordered is greater
2033     movl(dst, 1);
2034     jcc(Assembler::parity, L);
2035     jcc(Assembler::above , L);
2036     movl(dst, 0);
2037     jcc(Assembler::equal , L);
2038     decrementl(dst);
2039   }
2040   bind(L);
2041 }
2042 
2043 void MacroAssembler::fld_d(AddressLiteral src) {
2044   fld_d(as_Address(src));
2045 }
2046 
2047 void MacroAssembler::fld_s(AddressLiteral src) {
2048   fld_s(as_Address(src));
2049 }
2050 
<span class="line-removed">2051 void MacroAssembler::fld_x(AddressLiteral src) {</span>
<span class="line-removed">2052   Assembler::fld_x(as_Address(src));</span>
<span class="line-removed">2053 }</span>
<span class="line-removed">2054 </span>
2055 void MacroAssembler::fldcw(AddressLiteral src) {
2056   Assembler::fldcw(as_Address(src));
2057 }
2058 
2059 void MacroAssembler::fpop() {
2060   ffree();
2061   fincstp();
2062 }
2063 
2064 void MacroAssembler::fremr(Register tmp) {
2065   save_rax(tmp);
2066   { Label L;
2067     bind(L);
2068     fprem();
2069     fwait(); fnstsw_ax();
2070     sahf();
2071     jcc(Assembler::parity, L);
2072   }
2073   restore_rax(tmp);
2074   // Result is in ST0.
</pre>
<hr />
<pre>
2242       emit_int8(0x70 | cc);
2243       emit_int8((offs - short_size) &amp; 0xFF);
2244     } else {
2245       // 0000 1111 1000 tttn #32-bit disp
2246       emit_int8(0x0F);
2247       emit_int8((unsigned char)(0x80 | cc));
2248       emit_int32(offs - long_size);
2249     }
2250   } else {
2251 #ifdef ASSERT
2252     warning(&quot;reversing conditional branch&quot;);
2253 #endif /* ASSERT */
2254     Label skip;
2255     jccb(reverse[cc], skip);
2256     lea(rscratch1, dst);
2257     Assembler::jmp(rscratch1);
2258     bind(skip);
2259   }
2260 }
2261 




2262 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2263   if (reachable(src)) {
2264     Assembler::ldmxcsr(as_Address(src));
2265   } else {
2266     lea(rscratch1, src);
2267     Assembler::ldmxcsr(Address(rscratch1, 0));
2268   }
2269 }
2270 
2271 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2272   int off;
2273   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2274     off = offset();
2275     movsbl(dst, src); // movsxb
2276   } else {
2277     off = load_unsigned_byte(dst, src);
2278     shll(dst, 24);
2279     sarl(dst, 24);
2280   }
2281   return off;
</pre>
</td>
<td>
<hr />
<pre>
2031     increment(dst);
2032   } else { // unordered is greater
2033     movl(dst, 1);
2034     jcc(Assembler::parity, L);
2035     jcc(Assembler::above , L);
2036     movl(dst, 0);
2037     jcc(Assembler::equal , L);
2038     decrementl(dst);
2039   }
2040   bind(L);
2041 }
2042 
2043 void MacroAssembler::fld_d(AddressLiteral src) {
2044   fld_d(as_Address(src));
2045 }
2046 
2047 void MacroAssembler::fld_s(AddressLiteral src) {
2048   fld_s(as_Address(src));
2049 }
2050 




2051 void MacroAssembler::fldcw(AddressLiteral src) {
2052   Assembler::fldcw(as_Address(src));
2053 }
2054 
2055 void MacroAssembler::fpop() {
2056   ffree();
2057   fincstp();
2058 }
2059 
2060 void MacroAssembler::fremr(Register tmp) {
2061   save_rax(tmp);
2062   { Label L;
2063     bind(L);
2064     fprem();
2065     fwait(); fnstsw_ax();
2066     sahf();
2067     jcc(Assembler::parity, L);
2068   }
2069   restore_rax(tmp);
2070   // Result is in ST0.
</pre>
<hr />
<pre>
2238       emit_int8(0x70 | cc);
2239       emit_int8((offs - short_size) &amp; 0xFF);
2240     } else {
2241       // 0000 1111 1000 tttn #32-bit disp
2242       emit_int8(0x0F);
2243       emit_int8((unsigned char)(0x80 | cc));
2244       emit_int32(offs - long_size);
2245     }
2246   } else {
2247 #ifdef ASSERT
2248     warning(&quot;reversing conditional branch&quot;);
2249 #endif /* ASSERT */
2250     Label skip;
2251     jccb(reverse[cc], skip);
2252     lea(rscratch1, dst);
2253     Assembler::jmp(rscratch1);
2254     bind(skip);
2255   }
2256 }
2257 
<span class="line-added">2258 void MacroAssembler::fld_x(AddressLiteral src) {</span>
<span class="line-added">2259   Assembler::fld_x(as_Address(src));</span>
<span class="line-added">2260 }</span>
<span class="line-added">2261 </span>
2262 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2263   if (reachable(src)) {
2264     Assembler::ldmxcsr(as_Address(src));
2265   } else {
2266     lea(rscratch1, src);
2267     Assembler::ldmxcsr(Address(rscratch1, 0));
2268   }
2269 }
2270 
2271 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2272   int off;
2273   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2274     off = offset();
2275     movsbl(dst, src); // movsxb
2276   } else {
2277     off = load_unsigned_byte(dst, src);
2278     shll(dst, 24);
2279     sarl(dst, 24);
2280   }
2281   return off;
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
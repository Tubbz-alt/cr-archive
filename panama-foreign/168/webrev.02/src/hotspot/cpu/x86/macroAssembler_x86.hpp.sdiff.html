<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/prims/nativeLookup.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 801   // they will be hidden by the following overriding declaration.
 802   using Assembler::testl;
 803   void testl(Register dst, AddressLiteral src);
 804 
 805   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 806   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 807   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 808   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 809 
 810   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 811   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 812   void testptr(Register src1, Register src2);
 813 
 814   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 815   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 816 
 817   // Calls
 818 
 819   void call(Label&amp; L, relocInfo::relocType rtype);
 820   void call(Register entry);

 821 
 822   // NOTE: this call transfers to the effective address of entry NOT
 823   // the address contained by entry. This is because this is more natural
 824   // for jumps/calls.
 825   void call(AddressLiteral entry);
 826 
 827   // Emit the CompiledIC call idiom
 828   void ic_call(address entry, jint method_index = 0);
 829 
 830   // Jumps
 831 
 832   // NOTE: these jumps tranfer to the effective address of dst NOT
 833   // the address contained by dst. This is because this is more natural
 834   // for jumps/calls.
 835   void jump(AddressLiteral dst);
 836   void jump_cc(Condition cc, AddressLiteral dst);
 837 
 838   // 32bit can do a case table jump in one instruction but we no longer allow the base
 839   // to be installed in the Address class. This jump will tranfers to the address
 840   // contained in the location described by entry (not the address of entry)
</pre>
<hr />
<pre>
 855   void comiss(XMMRegister dst, AddressLiteral src);
 856 
 857   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 858   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 859   void comisd(XMMRegister dst, AddressLiteral src);
 860 
 861 #ifndef _LP64
 862   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 863   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 864 
 865   void fldcw(Address src) { Assembler::fldcw(src); }
 866   void fldcw(AddressLiteral src);
 867 
 868   void fld_s(int index)   { Assembler::fld_s(index); }
 869   void fld_s(Address src) { Assembler::fld_s(src); }
 870   void fld_s(AddressLiteral src);
 871 
 872   void fld_d(Address src) { Assembler::fld_d(src); }
 873   void fld_d(AddressLiteral src);
 874 
<span class="line-removed"> 875   void fld_x(Address src) { Assembler::fld_x(src); }</span>
<span class="line-removed"> 876   void fld_x(AddressLiteral src);</span>
<span class="line-removed"> 877 </span>
 878   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 879   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 880 #endif // _LP64
 881 



 882   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 883   void ldmxcsr(AddressLiteral src);
 884 
 885 #ifdef _LP64
 886  private:
 887   void sha256_AVX2_one_round_compute(
 888     Register  reg_old_h,
 889     Register  reg_a,
 890     Register  reg_b,
 891     Register  reg_c,
 892     Register  reg_d,
 893     Register  reg_e,
 894     Register  reg_f,
 895     Register  reg_g,
 896     Register  reg_h,
 897     int iter);
 898   void sha256_AVX2_four_rounds_compute_first(int start);
 899   void sha256_AVX2_four_rounds_compute_last(int start);
 900   void sha256_AVX2_one_round_and_sched(
 901         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
</pre>
</td>
<td>
<hr />
<pre>
 801   // they will be hidden by the following overriding declaration.
 802   using Assembler::testl;
 803   void testl(Register dst, AddressLiteral src);
 804 
 805   void orptr(Register dst, Address src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 806   void orptr(Register dst, Register src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 807   void orptr(Register dst, int32_t src) { LP64_ONLY(orq(dst, src)) NOT_LP64(orl(dst, src)); }
 808   void orptr(Address dst, int32_t imm32) { LP64_ONLY(orq(dst, imm32)) NOT_LP64(orl(dst, imm32)); }
 809 
 810   void testptr(Register src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }
 811   void testptr(Register src1, Address src2) { LP64_ONLY(testq(src1, src2)) NOT_LP64(testl(src1, src2)); }
 812   void testptr(Register src1, Register src2);
 813 
 814   void xorptr(Register dst, Register src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 815   void xorptr(Register dst, Address src) { LP64_ONLY(xorq(dst, src)) NOT_LP64(xorl(dst, src)); }
 816 
 817   // Calls
 818 
 819   void call(Label&amp; L, relocInfo::relocType rtype);
 820   void call(Register entry);
<span class="line-added"> 821   void call(Address addr) { Assembler::call(addr); }</span>
 822 
 823   // NOTE: this call transfers to the effective address of entry NOT
 824   // the address contained by entry. This is because this is more natural
 825   // for jumps/calls.
 826   void call(AddressLiteral entry);
 827 
 828   // Emit the CompiledIC call idiom
 829   void ic_call(address entry, jint method_index = 0);
 830 
 831   // Jumps
 832 
 833   // NOTE: these jumps tranfer to the effective address of dst NOT
 834   // the address contained by dst. This is because this is more natural
 835   // for jumps/calls.
 836   void jump(AddressLiteral dst);
 837   void jump_cc(Condition cc, AddressLiteral dst);
 838 
 839   // 32bit can do a case table jump in one instruction but we no longer allow the base
 840   // to be installed in the Address class. This jump will tranfers to the address
 841   // contained in the location described by entry (not the address of entry)
</pre>
<hr />
<pre>
 856   void comiss(XMMRegister dst, AddressLiteral src);
 857 
 858   void comisd(XMMRegister dst, XMMRegister src) { Assembler::comisd(dst, src); }
 859   void comisd(XMMRegister dst, Address src) { Assembler::comisd(dst, src); }
 860   void comisd(XMMRegister dst, AddressLiteral src);
 861 
 862 #ifndef _LP64
 863   void fadd_s(Address src)        { Assembler::fadd_s(src); }
 864   void fadd_s(AddressLiteral src) { Assembler::fadd_s(as_Address(src)); }
 865 
 866   void fldcw(Address src) { Assembler::fldcw(src); }
 867   void fldcw(AddressLiteral src);
 868 
 869   void fld_s(int index)   { Assembler::fld_s(index); }
 870   void fld_s(Address src) { Assembler::fld_s(src); }
 871   void fld_s(AddressLiteral src);
 872 
 873   void fld_d(Address src) { Assembler::fld_d(src); }
 874   void fld_d(AddressLiteral src);
 875 



 876   void fmul_s(Address src)        { Assembler::fmul_s(src); }
 877   void fmul_s(AddressLiteral src) { Assembler::fmul_s(as_Address(src)); }
 878 #endif // _LP64
 879 
<span class="line-added"> 880   void fld_x(Address src) { Assembler::fld_x(src); }</span>
<span class="line-added"> 881   void fld_x(AddressLiteral src);</span>
<span class="line-added"> 882 </span>
 883   void ldmxcsr(Address src) { Assembler::ldmxcsr(src); }
 884   void ldmxcsr(AddressLiteral src);
 885 
 886 #ifdef _LP64
 887  private:
 888   void sha256_AVX2_one_round_compute(
 889     Register  reg_old_h,
 890     Register  reg_a,
 891     Register  reg_b,
 892     Register  reg_c,
 893     Register  reg_d,
 894     Register  reg_e,
 895     Register  reg_f,
 896     Register  reg_g,
 897     Register  reg_h,
 898     int iter);
 899   void sha256_AVX2_four_rounds_compute_first(int start);
 900   void sha256_AVX2_four_rounds_compute_last(int start);
 901   void sha256_AVX2_one_round_and_sched(
 902         XMMRegister xmm_0,     /* == ymm4 on 0, 1, 2, 3 iterations, then rotate 4 registers left on 4, 8, 12 iterations */
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/prims/nativeLookup.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
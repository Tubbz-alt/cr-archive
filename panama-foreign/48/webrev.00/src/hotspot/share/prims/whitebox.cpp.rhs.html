<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;</span>
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/iterator.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
  53 #include &quot;oops/constantPool.inline.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  59 #include &quot;prims/resolvedMethodTable.hpp&quot;
  60 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  61 #include &quot;prims/whitebox.inline.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/deoptimization.hpp&quot;
  65 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  66 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  67 #include &quot;runtime/frame.inline.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jniHandles.inline.hpp&quot;
  73 #include &quot;runtime/os.hpp&quot;
  74 #include &quot;runtime/sweeper.hpp&quot;
  75 #include &quot;runtime/thread.hpp&quot;
  76 #include &quot;runtime/threadSMR.hpp&quot;
  77 #include &quot;runtime/vm_version.hpp&quot;
  78 #include &quot;services/memoryService.hpp&quot;
  79 #include &quot;utilities/align.hpp&quot;
  80 #include &quot;utilities/debug.hpp&quot;
  81 #include &quot;utilities/elfFile.hpp&quot;
  82 #include &quot;utilities/exceptions.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #if INCLUDE_CDS
  85 #include &quot;prims/cdsoffsets.hpp&quot;
  86 #endif // INCLUDE_CDS
  87 #if INCLUDE_G1GC
  88 #include &quot;gc/g1/g1Arguments.hpp&quot;
  89 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  90 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  91 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  92 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  93 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  94 #endif // INCLUDE_G1GC
  95 #if INCLUDE_PARALLELGC
  96 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  97 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  98 #endif // INCLUDE_PARALLELGC
  99 #if INCLUDE_NMT
 100 #include &quot;services/mallocSiteTable.hpp&quot;
 101 #include &quot;services/memTracker.hpp&quot;
 102 #include &quot;utilities/nativeCallStack.hpp&quot;
 103 #endif // INCLUDE_NMT
 104 #if INCLUDE_AOT
 105 #include &quot;aot/aotLoader.hpp&quot;
 106 #endif // INCLUDE_AOT
 107 
 108 #ifdef LINUX
 109 #include &quot;osContainer_linux.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added"> 110 #include &quot;cgroupSubsystem_linux.hpp&quot;</span>
 111 #endif
 112 
 113 #define SIZE_T_MAX_VALUE ((size_t) -1)
 114 
 115 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 116   do {                                                                 \
 117     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 118     THREAD-&gt;clear_pending_jni_exception_check();                       \
 119     if (HAS_PENDING_EXCEPTION) {                                       \
 120       return(value);                                                   \
 121     }                                                                  \
 122   } while (0)
 123 
 124 #define CHECK_JNI_EXCEPTION(env)                                       \
 125   do {                                                                 \
 126     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 127     THREAD-&gt;clear_pending_jni_exception_check();                       \
 128     if (HAS_PENDING_EXCEPTION) {                                       \
 129       return;                                                          \
 130     }                                                                  \
 131   } while (0)
 132 
 133 bool WhiteBox::_used = false;
 134 volatile bool WhiteBox::compilation_locked = false;
 135 
 136 class VM_WhiteBoxOperation : public VM_Operation {
 137  public:
 138   VM_WhiteBoxOperation()                         { }
 139   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 140   bool allow_nested_vm_operations() const        { return true; }
 141 };
 142 
 143 
 144 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 145   return (jlong)(void*)JNIHandles::resolve(obj);
 146 WB_END
 147 
 148 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 149   return heapOopSize;
 150 WB_END
 151 
 152 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 153   return os::vm_page_size();
 154 WB_END
 155 
 156 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 157   return os::vm_allocation_granularity();
 158 WB_END
 159 
 160 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 161   return os::large_page_size();
 162 WB_END
 163 
 164 class WBIsKlassAliveClosure : public LockedClassesDo {
 165     Symbol* _name;
 166     int _count;
 167 public:
 168     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 169 
 170     void do_klass(Klass* k) {
 171       Symbol* ksym = k-&gt;name();
 172       if (ksym-&gt;fast_compare(_name) == 0) {
 173         _count++;
 174       }
 175     }
 176 
 177     int count() const {
 178         return _count;
 179     }
 180 };
 181 
 182 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 183   oop h_name = JNIHandles::resolve(name);
 184   if (h_name == NULL) return false;
 185   Symbol* sym = java_lang_String::as_symbol(h_name);
 186   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 187 
 188   WBIsKlassAliveClosure closure(sym);
 189   ClassLoaderDataGraph::classes_do(&amp;closure);
 190 
 191   // Return the count of alive classes with this name.
 192   return closure.count();
 193 WB_END
 194 
 195 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 196   oop h_name = JNIHandles::resolve(name);
 197   if (h_name == NULL) return false;
 198   Symbol* sym = java_lang_String::as_symbol(h_name);
 199   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 200   return (jint)sym-&gt;refcount();
 201 WB_END
 202 
 203 
 204 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 205 #if INCLUDE_JVMTI
 206   ResourceMark rm;
 207   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 208   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 209   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 210   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 211 #endif
 212 }
 213 WB_END
 214 
 215 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 216 #if INCLUDE_JVMTI
 217   ResourceMark rm;
 218   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 219   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 220   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 221   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 222 #endif
 223 }
 224 WB_END
 225 
 226 
 227 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 228   return (jlong)Arguments::max_heap_for_compressed_oops();
 229 }
 230 WB_END
 231 
 232 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 233   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 234                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 235                 MinHeapSize,
 236                 InitialHeapSize,
 237                 MaxHeapSize,
 238                 SpaceAlignment,
 239                 HeapAlignment);
 240 }
 241 WB_END
 242 
 243 #ifndef PRODUCT
 244 // Forward declaration
 245 void TestReservedSpace_test();
 246 void TestReserveMemorySpecial_test();
 247 void TestVirtualSpace_test();
 248 #endif
 249 
 250 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 251 #ifndef PRODUCT
 252   TestReservedSpace_test();
 253   TestReserveMemorySpecial_test();
 254   TestVirtualSpace_test();
 255 #endif
 256 WB_END
 257 
 258 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 259   size_t granularity = os::vm_allocation_granularity();
 260   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 261   VirtualSpace vs;
 262   vs.initialize(rhs, 50 * granularity);
 263 
 264   // Check if constraints are complied
 265   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 266          CompressedOops::base() != NULL &amp;&amp;
 267          CompressedOops::use_implicit_null_checks() )) {
 268     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 269                   &quot;\tUseCompressedOops is %d\n&quot;
 270                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 271                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 272                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 273                   UseCompressedOops,
 274                   p2i(rhs.base()),
 275                   p2i(CompressedOops::base()),
 276                   CompressedOops::use_implicit_null_checks());
 277     return;
 278   }
 279   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 280   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 281                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 282 WB_END
 283 
 284 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 285                                            size_t magnitude, size_t iterations) {
 286   size_t granularity = os::vm_allocation_granularity();
 287   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 288   VirtualSpace vs;
 289   if (!vs.initialize(rhs, 0)) {
 290     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 291     return 3;
 292   }
 293 
 294   int seed = os::random();
 295   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 296   os::init_random(seed);
 297 
 298   for (size_t i = 0; i &lt; iterations; i++) {
 299 
 300     // Whether we will shrink or grow
 301     bool shrink = os::random() % 2L == 0;
 302 
 303     // Get random delta to resize virtual space
 304     size_t delta = (size_t)os::random() % magnitude;
 305 
 306     // If we are about to shrink virtual space below zero, then expand instead
 307     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 308       shrink = false;
 309     }
 310 
 311     // Resizing by delta
 312     if (shrink) {
 313       vs.shrink_by(delta);
 314     } else {
 315       // If expanding fails expand_by will silently return false
 316       vs.expand_by(delta, true);
 317     }
 318   }
 319   return 0;
 320 }
 321 
 322 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 323         jlong reserved_space_size, jlong magnitude, jlong iterations))
 324   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 325                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 326                 iterations);
 327   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 328     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 329     return 1;
 330   }
 331 
 332   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 333   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 334   if (sizeof(size_t) &lt; sizeof(jlong)) {
 335     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 336     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 337         || iterations &gt; size_t_max_value) {
 338       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 339       return 2;
 340     }
 341   }
 342 
 343   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 344                                         (size_t) magnitude, (size_t) iterations);
 345 WB_END
 346 
 347 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 348   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 349 WB_END
 350 
 351 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 352   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 353 WB_END
 354 
 355 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 356   return GCConfig::is_gc_selected_ergonomically();
 357 WB_END
 358 
 359 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 360   oop p = JNIHandles::resolve(obj);
 361 #if INCLUDE_G1GC
 362   if (UseG1GC) {
 363     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 364     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 365     if (hr == NULL) {
 366       return false;
 367     }
 368     return !(hr-&gt;is_young());
 369   }
 370 #endif
 371 #if INCLUDE_PARALLELGC
 372   if (UseParallelGC) {
 373     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 374     return !psh-&gt;is_in_young(p);
 375   }
 376 #endif
 377 #if INCLUDE_ZGC
 378   if (UseZGC) {
 379     return Universe::heap()-&gt;is_in(p);
 380   }
 381 #endif
 382   GenCollectedHeap* gch = GenCollectedHeap::heap();
 383   return !gch-&gt;is_in_young(p);
 384 WB_END
 385 
 386 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 387   oop p = JNIHandles::resolve(obj);
 388   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 389 WB_END
 390 
 391 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 392   return (jlong)SpaceAlignment;
 393 WB_END
 394 
 395 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 396   return (jlong)HeapAlignment;
 397 WB_END
 398 
<a name="3" id="anc3"></a><span class="line-modified"> 399 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 400   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();</span>
 401 WB_END
 402 
<a name="4" id="anc4"></a><span class="line-modified"> 403 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 404   ConcurrentGCBreakpoints::acquire_control();</span>
<span class="line-added"> 405 WB_END</span>
<span class="line-added"> 406 </span>
<span class="line-added"> 407 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))</span>
<span class="line-added"> 408   ConcurrentGCBreakpoints::release_control();</span>
<span class="line-added"> 409 WB_END</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))</span>
<span class="line-added"> 412   ConcurrentGCBreakpoints::run_to_idle();</span>
<span class="line-added"> 413 WB_END</span>
<span class="line-added"> 414 </span>
<span class="line-added"> 415 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))</span>
<span class="line-added"> 416   Handle h_name(THREAD, JNIHandles::resolve(at));</span>
 417   ResourceMark rm;
 418   const char* c_name = java_lang_String::as_utf8_string(h_name());
<a name="5" id="anc5"></a><span class="line-modified"> 419   return ConcurrentGCBreakpoints::run_to(c_name);</span>
 420 WB_END
 421 
 422 #if INCLUDE_G1GC
 423 
 424 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 425   if (UseG1GC) {
 426     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 427     oop result = JNIHandles::resolve(obj);
 428     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 429     return hr-&gt;is_humongous();
 430   }
 431   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 432 WB_END
 433 
 434 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 435   if (UseG1GC) {
 436     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 437     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 438     return hr-&gt;is_humongous();
 439   }
 440   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 441 WB_END
 442 
 443 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 444   if (UseG1GC) {
 445     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 446     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 447     return hr-&gt;is_free();
 448   }
 449   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 450 WB_END
 451 
 452 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 453   if (UseG1GC) {
 454     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 455     size_t nr = g1h-&gt;max_regions();
 456     return (jlong)nr;
 457   }
 458   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 459 WB_END
 460 
 461 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 462   if (UseG1GC) {
 463     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 464     size_t nr = g1h-&gt;num_free_regions();
 465     return (jlong)nr;
 466   }
 467   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 468 WB_END
 469 
 470 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 471   if (UseG1GC) {
 472     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 473     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 474   }
 475   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 476 WB_END
 477 
 478 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 479   if (UseG1GC) {
 480     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 481     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 482       g1h-&gt;collect(GCCause::_wb_conc_mark);
 483       return true;
 484     }
 485     return false;
 486   }
 487   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 488 WB_END
 489 
 490 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 491   if (UseG1GC) {
 492     return (jint)HeapRegion::GrainBytes;
 493   }
 494   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 495 WB_END
 496 
 497 #endif // INCLUDE_G1GC
 498 
 499 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 500 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 501 #if INCLUDE_G1GC
 502   if (UseG1GC) {
 503     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 504     if (g1h-&gt;is_heterogeneous_heap()) {
 505       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 506       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 507     } else {
 508       return (jlong)g1h-&gt;base();
 509     }
 510   }
 511 #endif // INCLUDE_G1GC
 512 #if INCLUDE_PARALLELGC
 513   if (UseParallelGC) {
 514     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 515     if (AllocateOldGenAt != NULL) {
 516       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 517       return (jlong)reserved.start();
 518     } else {
 519       return (jlong)ps_heap-&gt;base();
 520     }
 521   }
 522 #endif // INCLUDE_PARALLELGC
 523   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 524 WB_END
 525 
 526 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 527 #if INCLUDE_G1GC
 528   if (UseG1GC) {
 529     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 530     if (g1h-&gt;is_heterogeneous_heap()) {
 531       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 532       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 533     } else {
 534       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 535     }
 536   }
 537 #endif // INCLUDE_G1GC
 538 #if INCLUDE_PARALLELGC
 539   if (UseParallelGC) {
 540     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 541     if (AllocateOldGenAt != NULL) {
 542       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 543       return (jlong)reserved.end();
 544     } else {
 545       return (jlong)ps_heap-&gt;reserved_region().end();
 546     }
 547   }
 548 #endif // INCLUDE_PARALLELGC
 549   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 550 WB_END
 551 
 552 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 553 #if INCLUDE_G1GC
 554   if (UseG1GC) {
 555     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 556     if (g1h-&gt;is_heterogeneous_heap()) {
 557       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 558       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 559     } else {
 560       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 561     }
 562   }
 563 #endif // INCLUDE_G1GC
 564 #if INCLUDE_PARALLELGC
 565   if (UseParallelGC) {
 566     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 567     if (AllocateOldGenAt != NULL) {
 568       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 569       return (jlong)reserved.start();
 570     } else {
 571       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 572     }
 573   }
 574 #endif // INCLUDE_PARALLELGC
 575   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 576 WB_END
 577 
 578 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 579 #if INCLUDE_G1GC
 580   if (UseG1GC) {
 581     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 582     if (g1h-&gt;is_heterogeneous_heap()) {
 583       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 584       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 585     } else {
 586       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 587     }
 588   }
 589 #endif // INCLUDE_G1GC
 590 #if INCLUDE_PARALLELGC
 591   if (UseParallelGC) {
 592     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 593     if (AllocateOldGenAt != NULL) {
 594       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 595       return (jlong)reserved.end();
 596       } else {
 597       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 598     }
 599   }
 600 #endif // INCLUDE_PARALLELGC
 601   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 602 WB_END
 603 
 604 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 605 
 606 #if INCLUDE_PARALLELGC
 607 
 608 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 609   if (UseParallelGC) {
 610     return ParallelScavengeHeap::heap()-&gt;gens()-&gt;virtual_spaces()-&gt;alignment();
 611   }
 612   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 613 WB_END
 614 
 615 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 616   if (UseParallelGC) {
 617     return GenAlignment;
 618   }
 619   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 620 WB_END
 621 
 622 #endif // INCLUDE_PARALLELGC
 623 
 624 #if INCLUDE_G1GC
 625 
 626 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 627   if (UseG1GC) {
 628     ResourceMark rm(THREAD);
 629     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 630     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 631     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 632     return JNIHandles::make_local(env, h());
 633   }
 634   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 635 WB_END
 636 
 637 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 638   if (UseG1GC) {
 639     G1NUMA* numa = G1NUMA::numa();
 640     return (jint)numa-&gt;num_active_nodes();
 641   }
 642   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 643 WB_END
 644 
 645 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 646   if (UseG1GC) {
 647     G1NUMA* numa = G1NUMA::numa();
 648     int num_node_ids = (int)numa-&gt;num_active_nodes();
 649     const int* node_ids = numa-&gt;node_ids();
 650 
 651     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 652     for (int i = 0; i &lt; num_node_ids; i++) {
 653       result-&gt;int_at_put(i, (jint)node_ids[i]);
 654     }
 655     return (jintArray) JNIHandles::make_local(env, result);
 656   }
 657   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 658 WB_END
 659 
 660 class OldRegionsLivenessClosure: public HeapRegionClosure {
 661 
 662  private:
 663   const int _liveness;
 664   size_t _total_count;
 665   size_t _total_memory;
 666   size_t _total_memory_to_free;
 667 
 668  public:
 669   OldRegionsLivenessClosure(int liveness) :
 670     _liveness(liveness),
 671     _total_count(0),
 672     _total_memory(0),
 673     _total_memory_to_free(0) { }
 674 
 675     size_t total_count() { return _total_count; }
 676     size_t total_memory() { return _total_memory; }
 677     size_t total_memory_to_free() { return _total_memory_to_free; }
 678 
 679   bool do_heap_region(HeapRegion* r) {
 680     if (r-&gt;is_old()) {
 681       size_t prev_live = r-&gt;marked_bytes();
 682       size_t live = r-&gt;live_bytes();
 683       size_t size = r-&gt;used();
 684       size_t reg_size = HeapRegion::GrainBytes;
 685       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 686         _total_memory += size;
 687         ++_total_count;
 688         if (size == reg_size) {
 689         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 690         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 691           _total_memory_to_free += size - prev_live;
 692         }
 693       }
 694     }
 695     return false;
 696   }
 697 };
 698 
 699 
 700 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 701   if (!UseG1GC) {
 702     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 703   }
 704   if (liveness &lt; 0) {
 705     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 706   }
 707 
 708   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 709   OldRegionsLivenessClosure rli(liveness);
 710   g1h-&gt;heap_region_iterate(&amp;rli);
 711 
 712   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 713   result-&gt;long_at_put(0, rli.total_count());
 714   result-&gt;long_at_put(1, rli.total_memory());
 715   result-&gt;long_at_put(2, rli.total_memory_to_free());
 716   return (jlongArray) JNIHandles::make_local(env, result);
 717 WB_END
 718 
 719 #endif // INCLUDE_G1GC
 720 
 721 #if INCLUDE_NMT
 722 // Alloc memory using the test memory type so that we can use that to see if
 723 // NMT picks it up correctly
 724 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 725   jlong addr = 0;
 726   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 727   return addr;
 728 WB_END
 729 
 730 // Alloc memory with pseudo call stack. The test can create psudo malloc
 731 // allocation site to stress the malloc tracking.
 732 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 733   address pc = (address)(size_t)pseudo_stack;
 734   NativeCallStack stack(&amp;pc, 1);
 735   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 736 WB_END
 737 
 738 // Alloc memory with pseudo call stack and specific memory type.
 739 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 740   address pc = (address)(size_t)pseudo_stack;
 741   NativeCallStack stack(&amp;pc, 1);
 742   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 743 WB_END
 744 
 745 // Free the memory allocated by NMTAllocTest
 746 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 747   os::free((void*)(uintptr_t)mem);
 748 WB_END
 749 
 750 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 751   jlong addr = 0;
 752 
 753   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 754   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 755 
 756   return addr;
 757 WB_END
 758 
 759 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 760   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 761   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 762 
 763   return addr;
 764 WB_END
 765 
 766 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 767   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 768   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 769 WB_END
 770 
 771 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 772   os::uncommit_memory((char *)(uintptr_t)addr, size);
 773 WB_END
 774 
 775 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 776   os::release_memory((char *)(uintptr_t)addr, size);
 777 WB_END
 778 
 779 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 780   // Test that we can downgrade NMT levels but not upgrade them.
 781   if (MemTracker::tracking_level() == NMT_off) {
 782     MemTracker::transition_to(NMT_off);
 783     return MemTracker::tracking_level() == NMT_off;
 784   } else {
 785     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 786     MemTracker::transition_to(NMT_summary);
 787     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 788 
 789     // Can&#39;t go to detail once NMT is set to summary.
 790     MemTracker::transition_to(NMT_detail);
 791     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 792 
 793     // Shutdown sets tracking level to minimal.
 794     MemTracker::shutdown();
 795     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 796 
 797     // Once the tracking level is minimal, we cannot increase to summary.
 798     // The code ignores this request instead of asserting because if the malloc site
 799     // table overflows in another thread, it tries to change the code to summary.
 800     MemTracker::transition_to(NMT_summary);
 801     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 802 
 803     // Really can never go up to detail, verify that the code would never do this.
 804     MemTracker::transition_to(NMT_detail);
 805     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 806     return MemTracker::tracking_level() == NMT_minimal;
 807   }
 808 WB_END
 809 
 810 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 811   int hash_size = MallocSiteTable::hash_buckets();
 812   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 813   return (jint)hash_size;
 814 WB_END
 815 
 816 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 817   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 818   return (jlong)arena;
 819 WB_END
 820 
 821 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 822   Arena* a = (Arena*)arena;
 823   delete a;
 824 WB_END
 825 
 826 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 827   Arena* a = (Arena*)arena;
 828   a-&gt;Amalloc(size_t(size));
 829 WB_END
 830 #endif // INCLUDE_NMT
 831 
 832 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 833   assert(method != NULL, &quot;method should not be null&quot;);
 834   ThreadToNativeFromVM ttn(thread);
 835   return env-&gt;FromReflectedMethod(method);
 836 }
 837 
 838 static CompLevel highestCompLevel() {
 839   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 840 }
 841 
 842 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 843 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 844  private:
 845   int _result;
 846   const bool _make_not_entrant;
 847  public:
 848   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 849         _result(0), _make_not_entrant(make_not_entrant) { }
 850   int  result() const { return _result; }
 851 
 852   void doit() {
 853     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 854       if (t-&gt;has_last_Java_frame()) {
 855         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 856           frame* f = fst.current();
 857           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 858             Deoptimization::deoptimize(t, *f);
 859             if (_make_not_entrant) {
 860                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 861                 assert(cm != NULL, &quot;sanity check&quot;);
 862                 cm-&gt;make_not_entrant();
 863             }
 864             ++_result;
 865           }
 866         }
 867       }
 868     }
 869   }
 870 };
 871 
 872 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 873   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 874   VMThread::execute(&amp;op);
 875   return op.result();
 876 WB_END
 877 
 878 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 879   CodeCache::mark_all_nmethods_for_deoptimization();
 880   Deoptimization::deoptimize_all_marked();
 881 WB_END
 882 
 883 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 884   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 885   int result = 0;
 886   CHECK_JNI_EXCEPTION_(env, result);
 887   MutexLocker mu(Compile_lock);
 888   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 889   if (is_osr) {
 890     result += mh-&gt;mark_osr_nmethods();
 891   } else if (mh-&gt;code() != NULL) {
 892     mh-&gt;code()-&gt;mark_for_deoptimization();
 893     ++result;
 894   }
 895   result += CodeCache::mark_for_deoptimization(mh());
 896   if (result &gt; 0) {
 897     Deoptimization::deoptimize_all_marked();
 898   }
 899   return result;
 900 WB_END
 901 
 902 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 903   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 904   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 905   MutexLocker mu(Compile_lock);
 906   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 907   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 908   if (code == NULL) {
 909     return JNI_FALSE;
 910   }
 911   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 912 WB_END
 913 
 914 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 915   if (method == NULL || comp_level &gt; highestCompLevel()) {
 916     return false;
 917   }
 918   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 919   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 920   MutexLocker mu(Compile_lock);
 921   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 922   if (is_osr) {
 923     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 924   } else {
 925     return CompilationPolicy::can_be_compiled(mh, comp_level);
 926   }
 927 WB_END
 928 
 929 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 930   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 931   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 932   MutexLocker mu(Compile_lock);
 933   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 934   return mh-&gt;queued_for_compilation();
 935 WB_END
 936 
 937 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 938   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 939     return false; // Intrinsic is not available on a non-existent compilation level.
 940   }
 941   jmethodID method_id, compilation_context_id;
 942   method_id = reflected_method_to_jmid(thread, env, method);
 943   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 944   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 945 
 946   DirectiveSet* directive;
 947   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 948   assert(comp != NULL, &quot;compiler not available&quot;);
 949   if (compilation_context != NULL) {
 950     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 951     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 952     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 953     directive = DirectivesStack::getMatchingDirective(cch, comp);
 954   } else {
 955     // Calling with NULL matches default directive
 956     directive = DirectivesStack::getDefaultDirective(comp);
 957   }
 958   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 959   DirectivesStack::release(directive);
 960   return result;
 961 WB_END
 962 
 963 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 964   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 965   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 966   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 967   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 968   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 969 WB_END
 970 
 971 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 972   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 973   CHECK_JNI_EXCEPTION(env);
 974   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 975   if (is_osr) {
 976     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 977   } else {
 978     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 979   }
 980 WB_END
 981 
 982 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 983   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 984   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 985   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 986   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 987   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 988 WB_END
 989 
 990 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 991   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 992   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 993   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 994   bool result = mh-&gt;dont_inline();
 995   mh-&gt;set_dont_inline(value == JNI_TRUE);
 996   return result;
 997 WB_END
 998 
 999 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1000   if (comp_level == CompLevel_any) {
1001     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1002         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1003   } else {
1004     return CompileBroker::queue_size(comp_level);
1005   }
1006 WB_END
1007 
1008 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1009   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1010   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1011   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1012   bool result = mh-&gt;force_inline();
1013   mh-&gt;set_force_inline(value == JNI_TRUE);
1014   return result;
1015 WB_END
1016 
<a name="6" id="anc6"></a><span class="line-added">1017 #ifdef LINUX</span>
<span class="line-added">1018 bool WhiteBox::validate_cgroup(const char* proc_cgroups,</span>
<span class="line-added">1019                                const char* proc_self_cgroup,</span>
<span class="line-added">1020                                const char* proc_self_mountinfo,</span>
<span class="line-added">1021                                u1* cg_flags) {</span>
<span class="line-added">1022   CgroupInfo cg_infos[4];</span>
<span class="line-added">1023   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,</span>
<span class="line-added">1024                                                     proc_self_cgroup,</span>
<span class="line-added">1025                                                     proc_self_mountinfo, cg_flags);</span>
<span class="line-added">1026 }</span>
<span class="line-added">1027 #endif</span>
<span class="line-added">1028 </span>
1029 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1030   // Screen for unavailable/bad comp level or null method
1031   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1032   if (method == NULL) {
1033     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1034     return false;
1035   }
1036   if (comp_level &gt; highestCompLevel()) {
1037     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1038     return false;
1039   }
1040   if (comp == NULL) {
1041     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1042     return false;
1043   }
1044 
1045   // Check if compilation is blocking
1046   methodHandle mh(THREAD, method);
1047   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1048   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1049   DirectivesStack::release(directive);
1050 
1051   // Compile method and check result
1052   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1053   MutexLocker mu(THREAD, Compile_lock);
1054   bool is_queued = mh-&gt;queued_for_compilation();
1055   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1056     return true;
1057   }
1058   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1059   mh-&gt;print_short_name(tty);
1060   tty-&gt;cr();
1061   if (is_blocking &amp;&amp; is_queued) {
1062     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1063   }
1064   return false;
1065 }
1066 
1067 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1068   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1069   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1070   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1071 WB_END
1072 
1073 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1074   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1075   Method* clinit = ik-&gt;class_initializer();
1076   if (clinit == NULL) {
1077     return false;
1078   }
1079   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1080 WB_END
1081 
1082 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1083   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1084   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1085 
1086   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1087   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1088   bool result = directive-&gt;PrintAssemblyOption;
1089   DirectivesStack::release(directive);
1090 
1091   return result;
1092 WB_END
1093 
1094 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1095   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1096   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1097 
1098   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1099 
1100   ResourceMark rm(THREAD);
1101   const char* error_msg = NULL;
1102   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1103   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1104 
1105   if (m == NULL) {
1106     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1107     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1108     return -1; // Pattern failed
1109   }
1110 
1111   // Pattern works - now check if it matches
1112   int result;
1113   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1114     result = 2; // Force inline match
1115   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1116     result = 1; // Dont inline match
1117   } else {
1118     result = 0; // No match
1119   }
1120   delete m;
1121   return result;
1122 WB_END
1123 
1124 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1125   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1126   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1127 
1128   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1129 
1130   ResourceMark rm;
1131   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1132 
1133   const char* error_msg = NULL;
1134 
1135   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1136   if (m == NULL) {
1137     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1138     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1139     return -1;
1140   }
1141 
1142   // Pattern works - now check if it matches
1143   int result = m-&gt;matches(mh);
1144   delete m;
1145   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1146   return result;
1147 WB_END
1148 
1149 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1150   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1151   CHECK_JNI_EXCEPTION(env);
1152   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1153 
1154   MethodData* mdo = mh-&gt;method_data();
1155   if (mdo == NULL) {
1156     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1157     mdo = mh-&gt;method_data();
1158   }
1159   mdo-&gt;init();
1160   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1161   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1162   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1163   icnt-&gt;set(Tier4MinInvocationThreshold);
1164   bcnt-&gt;set(Tier4CompileThreshold);
1165 WB_END
1166 
1167 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1168   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1169   CHECK_JNI_EXCEPTION(env);
1170   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1171   MutexLocker mu(THREAD, Compile_lock);
1172   MethodData* mdo = mh-&gt;method_data();
1173   MethodCounters* mcs = mh-&gt;method_counters();
1174 
1175   if (mdo != NULL) {
1176     mdo-&gt;init();
1177     ResourceMark rm(THREAD);
1178     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1179     for (int i = 0; i &lt; arg_count; i++) {
1180       mdo-&gt;set_arg_modified(i, 0);
1181     }
1182     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1183     mdo-&gt;clean_method_data(/*always_clean*/true);
1184   }
1185 
1186   mh-&gt;clear_not_c1_compilable();
1187   mh-&gt;clear_not_c2_compilable();
1188   mh-&gt;clear_not_c2_osr_compilable();
1189   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1190   if (mcs != NULL) {
1191     mcs-&gt;backedge_counter()-&gt;init();
1192     mcs-&gt;invocation_counter()-&gt;init();
1193     mcs-&gt;set_interpreter_invocation_count(0);
1194     mcs-&gt;set_interpreter_throwout_count(0);
1195 
1196 #ifdef TIERED
1197     mcs-&gt;set_rate(0.0F);
1198     mh-&gt;set_prev_event_count(0);
1199     mh-&gt;set_prev_time(0);
1200 #endif
1201   }
1202 WB_END
1203 
1204 template &lt;typename T&gt;
1205 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1206   if (name == NULL) {
1207     return false;
1208   }
1209   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1210   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1211   CHECK_JNI_EXCEPTION_(env, false);
1212   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1213   JVMFlag::Error result = (*TAt)(flag, value);
1214   env-&gt;ReleaseStringUTFChars(name, flag_name);
1215   return (result == JVMFlag::SUCCESS);
1216 }
1217 
1218 template &lt;typename T&gt;
1219 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1220   if (name == NULL) {
1221     return false;
1222   }
1223   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1224   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1225   CHECK_JNI_EXCEPTION_(env, false);
1226   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1227   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1228   env-&gt;ReleaseStringUTFChars(name, flag_name);
1229   return (result == JVMFlag::SUCCESS);
1230 }
1231 
1232 template &lt;typename T&gt;
1233 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1234   ResourceMark rm(thread);
1235   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1236   CHECK_JNI_EXCEPTION_(env, NULL);
1237   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1238         vmSymbols::valueOf_name()-&gt;as_C_string(),
1239         sig-&gt;as_C_string());
1240   CHECK_JNI_EXCEPTION_(env, NULL);
1241   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1242   CHECK_JNI_EXCEPTION_(env, NULL);
1243   return result;
1244 }
1245 
1246 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1247   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1248 }
1249 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1250   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1251 }
1252 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1253   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1254 }
1255 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1256   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1257 }*/
1258 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1259   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1260 }
1261 
1262 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1263   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1264   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1265   CHECK_JNI_EXCEPTION_(env, NULL);
1266   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1267   env-&gt;ReleaseStringUTFChars(name, flag_name);
1268   return result;
1269 }
1270 
1271 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1272   const JVMFlag* flag = getVMFlag(thread, env, name);
1273   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1274 WB_END
1275 
1276 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1277   const JVMFlag* flag = getVMFlag(thread, env, name);
1278   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1279 WB_END
1280 
1281 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1282   bool result;
1283   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1284     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1285     return booleanBox(thread, env, result);
1286   }
1287   return NULL;
1288 WB_END
1289 
1290 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1291   int result;
1292   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1293     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1294     return longBox(thread, env, result);
1295   }
1296   return NULL;
1297 WB_END
1298 
1299 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1300   uint result;
1301   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1302     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1303     return longBox(thread, env, result);
1304   }
1305   return NULL;
1306 WB_END
1307 
1308 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1309   intx result;
1310   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1311     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1312     return longBox(thread, env, result);
1313   }
1314   return NULL;
1315 WB_END
1316 
1317 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1318   uintx result;
1319   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1320     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1321     return longBox(thread, env, result);
1322   }
1323   return NULL;
1324 WB_END
1325 
1326 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1327   uint64_t result;
1328   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1329     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1330     return longBox(thread, env, result);
1331   }
1332   return NULL;
1333 WB_END
1334 
1335 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1336   size_t result;
1337   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1338     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1339     return longBox(thread, env, result);
1340   }
1341   return NULL;
1342 WB_END
1343 
1344 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1345   double result;
1346   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1347     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1348     return doubleBox(thread, env, result);
1349   }
1350   return NULL;
1351 WB_END
1352 
1353 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1354   ccstr ccstrResult;
1355   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1356     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1357     jstring result = env-&gt;NewStringUTF(ccstrResult);
1358     CHECK_JNI_EXCEPTION_(env, NULL);
1359     return result;
1360   }
1361   return NULL;
1362 WB_END
1363 
1364 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1365   bool result = value == JNI_TRUE ? true : false;
1366   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1367 WB_END
1368 
1369 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1370   int result = value;
1371   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1372 WB_END
1373 
1374 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1375   uint result = value;
1376   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1377 WB_END
1378 
1379 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1380   intx result = value;
1381   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1382 WB_END
1383 
1384 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1385   uintx result = value;
1386   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1387 WB_END
1388 
1389 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1390   uint64_t result = value;
1391   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1392 WB_END
1393 
1394 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1395   size_t result = value;
1396   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1397 WB_END
1398 
1399 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1400   double result = value;
1401   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1402 WB_END
1403 
1404 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1405   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1406   const char* ccstrValue;
1407   if (value == NULL) {
1408     ccstrValue = NULL;
1409   }
1410   else {
1411     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1412     CHECK_JNI_EXCEPTION(env);
1413   }
1414   ccstr ccstrResult = ccstrValue;
1415   bool needFree;
1416   {
1417     ThreadInVMfromNative ttvfn(thread); // back to VM
1418     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1419   }
1420   if (value != NULL) {
1421     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1422   }
1423   if (needFree) {
1424     FREE_C_HEAP_ARRAY(char, ccstrResult);
1425   }
1426 WB_END
1427 
1428 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1429   WhiteBox::compilation_locked = true;
1430 WB_END
1431 
1432 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1433   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1434   WhiteBox::compilation_locked = false;
1435   mo.notify_all();
1436 WB_END
1437 
1438 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1439   // Force a code cache sweep and block until it finished
1440   NMethodSweeper::force_sweep();
1441 WB_END
1442 
1443 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1444   ResourceMark rm(THREAD);
1445   int len;
1446   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1447   return (StringTable::lookup(name, len) != NULL);
1448 WB_END
1449 
1450 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1451   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1452   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1453 #if INCLUDE_G1GC
1454   if (UseG1GC) {
1455     // Needs to be cleared explicitly for G1
1456     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1457   }
1458 #endif // INCLUDE_G1GC
1459 WB_END
1460 
1461 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1462   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1463 WB_END
1464 
1465 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1466   // static+volatile in order to force the read to happen
1467   // (not be eliminated by the compiler)
1468   static char c;
1469   static volatile char* p;
1470 
1471   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1472   if (p == NULL) {
1473     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1474   }
1475 
1476   c = *p;
1477 WB_END
1478 
1479 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1480   const char* features = VM_Version::features_string();
1481   ThreadToNativeFromVM ttn(thread);
1482   jstring features_string = env-&gt;NewStringUTF(features);
1483 
1484   CHECK_JNI_EXCEPTION_(env, NULL);
1485 
1486   return features_string;
1487 WB_END
1488 
1489 int WhiteBox::get_blob_type(const CodeBlob* code) {
1490   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1491   if (code-&gt;is_aot()) {
1492     return -1;
1493   }
1494   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1495 }
1496 
1497 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1498   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1499   return CodeCache::get_code_heap(blob_type);
1500 }
1501 
1502 struct CodeBlobStub {
1503   CodeBlobStub(const CodeBlob* blob) :
1504       name(os::strdup(blob-&gt;name())),
1505       size(blob-&gt;size()),
1506       blob_type(WhiteBox::get_blob_type(blob)),
1507       address((jlong) blob) { }
1508   ~CodeBlobStub() { os::free((void*) name); }
1509   const char* const name;
1510   const jint        size;
1511   const jint        blob_type;
1512   const jlong       address;
1513 };
1514 
1515 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1516   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1517   CHECK_JNI_EXCEPTION_(env, NULL);
1518   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1519 
1520   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1521   CHECK_JNI_EXCEPTION_(env, NULL);
1522   env-&gt;SetObjectArrayElement(result, 0, name);
1523 
1524   jobject obj = integerBox(thread, env, cb-&gt;size);
1525   CHECK_JNI_EXCEPTION_(env, NULL);
1526   env-&gt;SetObjectArrayElement(result, 1, obj);
1527 
1528   obj = integerBox(thread, env, cb-&gt;blob_type);
1529   CHECK_JNI_EXCEPTION_(env, NULL);
1530   env-&gt;SetObjectArrayElement(result, 2, obj);
1531 
1532   obj = longBox(thread, env, cb-&gt;address);
1533   CHECK_JNI_EXCEPTION_(env, NULL);
1534   env-&gt;SetObjectArrayElement(result, 3, obj);
1535 
1536   return result;
1537 }
1538 
1539 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1540   ResourceMark rm(THREAD);
1541   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1542   CHECK_JNI_EXCEPTION_(env, NULL);
1543   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1544   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1545   jobjectArray result = NULL;
1546   if (code == NULL) {
1547     return result;
1548   }
1549   int comp_level = code-&gt;comp_level();
1550   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1551 
1552   ThreadToNativeFromVM ttn(thread);
1553   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1554   CHECK_JNI_EXCEPTION_(env, NULL);
1555   result = env-&gt;NewObjectArray(5, clazz, NULL);
1556   if (result == NULL) {
1557     return result;
1558   }
1559 
1560   CodeBlobStub stub(code);
1561   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1562   CHECK_JNI_EXCEPTION_(env, NULL);
1563   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1564 
1565   jobject level = integerBox(thread, env, comp_level);
1566   CHECK_JNI_EXCEPTION_(env, NULL);
1567   env-&gt;SetObjectArrayElement(result, 1, level);
1568 
1569   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1570   CHECK_JNI_EXCEPTION_(env, NULL);
1571   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1572   env-&gt;SetObjectArrayElement(result, 2, insts);
1573 
1574   jobject id = integerBox(thread, env, code-&gt;compile_id());
1575   CHECK_JNI_EXCEPTION_(env, NULL);
1576   env-&gt;SetObjectArrayElement(result, 3, id);
1577 
1578   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1579   CHECK_JNI_EXCEPTION_(env, NULL);
1580   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1581 
1582   return result;
1583 WB_END
1584 
1585 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1586   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1587   BufferBlob* blob;
1588   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1589   if (full_size &lt; size) {
1590     full_size += align_up(size - full_size, oopSize);
1591   }
1592   {
1593     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1594     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1595     if (blob != NULL) {
1596       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1597     }
1598   }
1599   // Track memory usage statistic after releasing CodeCache_lock
1600   MemoryService::track_code_cache_memory_usage();
1601   return blob;
1602 }
1603 
1604 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1605   if (size &lt; 0) {
1606     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1607       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1608   }
1609   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1610 WB_END
1611 
1612 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1613   if (addr == 0) {
1614     return;
1615   }
1616   BufferBlob::free((BufferBlob*) addr);
1617 WB_END
1618 
1619 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1620   ResourceMark rm;
1621   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1622   {
1623     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1624     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1625     if (heap == NULL) {
1626       return NULL;
1627     }
1628     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1629          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1630       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1631       new (stub) CodeBlobStub(cb);
1632       blobs.append(stub);
1633     }
1634   }
1635   ThreadToNativeFromVM ttn(thread);
1636   jobjectArray result = NULL;
1637   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1638   CHECK_JNI_EXCEPTION_(env, NULL);
1639   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1640   CHECK_JNI_EXCEPTION_(env, NULL);
1641   if (result == NULL) {
1642     return result;
1643   }
1644   int i = 0;
1645   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1646        it != blobs.end(); ++it) {
1647     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1648     CHECK_JNI_EXCEPTION_(env, NULL);
1649     env-&gt;SetObjectArrayElement(result, i, obj);
1650     CHECK_JNI_EXCEPTION_(env, NULL);
1651     ++i;
1652   }
1653   return result;
1654 WB_END
1655 
1656 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1657   return CompileBroker::get_compilation_activity_mode();
1658 WB_END
1659 
1660 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1661   if (addr == 0) {
1662     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1663       &quot;WB_GetCodeBlob: addr is null&quot;);
1664   }
1665   ThreadToNativeFromVM ttn(thread);
1666   CodeBlobStub stub((CodeBlob*) addr);
1667   return codeBlob2objectArray(thread, env, &amp;stub);
1668 WB_END
1669 
1670 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1671   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1672   CHECK_JNI_EXCEPTION_(env, 0);
1673   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1674   return (jlong) mh-&gt;method_data();
1675 WB_END
1676 
1677 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1678   return (jlong) Thread::current()-&gt;stack_size();
1679 WB_END
1680 
1681 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1682   JavaThread* t = JavaThread::current();
1683   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1684 WB_END
1685 
1686 
1687 int WhiteBox::array_bytes_to_length(size_t bytes) {
1688   return Array&lt;u1&gt;::bytes_to_length(bytes);
1689 }
1690 
1691 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1692   if (size &lt; 0) {
1693     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1694         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1695   }
1696 
1697   oop class_loader_oop = JNIHandles::resolve(class_loader);
1698   ClassLoaderData* cld = class_loader_oop != NULL
1699       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1700       : ClassLoaderData::the_null_class_loader_data();
1701 
1702   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1703 
1704   return (jlong)(uintptr_t)metadata;
1705 WB_END
1706 
1707 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1708   oop class_loader_oop = JNIHandles::resolve(class_loader);
1709   ClassLoaderData* cld = class_loader_oop != NULL
1710       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1711       : ClassLoaderData::the_null_class_loader_data();
1712 
1713   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1714 WB_END
1715 
1716 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1717                                 jstring version, jstring location, jobjectArray packages))
1718   ResourceMark rm(THREAD);
1719 
1720   objArrayOop packages_oop = objArrayOop(JNIHandles::resolve(packages));
1721   objArrayHandle packages_h(THREAD, packages_oop);
1722   int num_packages = (packages_h == NULL ? 0 : packages_h-&gt;length());
1723 
1724   char** pkgs = NULL;
1725   if (num_packages &gt; 0) {
1726     pkgs = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char*, num_packages);
1727     for (int x = 0; x &lt; num_packages; x++) {
1728       oop pkg_str = packages_h-&gt;obj_at(x);
1729       if (pkg_str == NULL || !pkg_str-&gt;is_a(SystemDictionary::String_klass())) {
1730         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1731                   err_msg(&quot;Bad package name&quot;));
1732       }
1733       pkgs[x] = java_lang_String::as_utf8_string(pkg_str);
1734     }
1735   }
1736   Modules::define_module(module, is_open, version, location, (const char* const*)pkgs, num_packages, CHECK);
1737 WB_END
1738 
1739 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1740   ResourceMark rm(THREAD);
1741   char* package_name = NULL;
1742   if (package != NULL) {
1743       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1744   }
1745   Modules::add_module_exports_qualified(from_module, package_name, to_module, CHECK);
1746 WB_END
1747 
1748 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1749   ResourceMark rm(THREAD);
1750   char* package_name = NULL;
1751   if (package != NULL) {
1752       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1753   }
1754   Modules::add_module_exports_to_all_unnamed(module, package_name, CHECK);
1755 WB_END
1756 
1757 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1758   ResourceMark rm(THREAD);
1759   char* package_name = NULL;
1760   if (package != NULL) {
1761       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1762   }
1763   Modules::add_module_exports(module, package_name, NULL, CHECK);
1764 WB_END
1765 
1766 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1767   Modules::add_reads_module(from_module, source_module, CHECK);
1768 WB_END
1769 
1770 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1771   if (inc &lt; 0) {
1772     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1773         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1774   }
1775 
1776   jlong max_size_t = (jlong) ((size_t) -1);
1777   if (inc &gt; max_size_t) {
1778     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1779         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1780   }
1781 
1782   size_t new_cap_until_GC = 0;
1783   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1784   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1785   if (!success) {
1786     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1787                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1788                 &quot;due to contention with another thread&quot;);
1789   }
1790   return (jlong) new_cap_until_GC;
1791 WB_END
1792 
1793 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1794   return (jlong) MetaspaceGC::capacity_until_GC();
1795 WB_END
1796 
1797 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1798   return (jlong)Metaspace::reserve_alignment();
1799 WB_END
1800 
1801 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1802   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1803                                            Mutex::_safepoint_check_always :
1804                                            Mutex::_safepoint_check_never;
1805   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1806                                            Mutex::_no_safepoint_check_flag :
1807                                            Mutex::_safepoint_check_flag;
1808   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1809                  sfpt_check_attempted);
1810 WB_END
1811 
1812 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1813   // Create a special lock violating condition in value
1814   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1815                                            Mutex::_safepoint_check_always :
1816                                            Mutex::_safepoint_check_never;
1817   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1818                                            Monitor::_safepoint_check_flag :
1819                                            Monitor::_no_safepoint_check_flag;
1820 
1821   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1822   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1823   ThreadBlockInVM tbivm(JavaThread::current());
1824 WB_END
1825 
1826 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1827   oop obj_oop = JNIHandles::resolve(obj);
1828   return (jboolean) obj_oop-&gt;mark().has_monitor();
1829 WB_END
1830 
1831 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1832   VM_ForceSafepoint force_safepoint_op;
1833   VMThread::execute(&amp;force_safepoint_op);
1834 WB_END
1835 
1836 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1837   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1838   return (jlong) ik-&gt;constants();
1839 WB_END
1840 
1841 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1842   return ConstantPool::CPCACHE_INDEX_TAG;
1843 WB_END
1844 
1845 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1846   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1847   ConstantPool* cp = ik-&gt;constants();
1848   if (cp-&gt;cache() == NULL) {
1849       return -1;
1850   }
1851   return cp-&gt;cache()-&gt;length();
1852 WB_END
1853 
1854 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1855   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1856   ConstantPool* cp = ik-&gt;constants();
1857   if (cp-&gt;cache() == NULL) {
1858     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1859   }
1860   jint cpci = index;
1861   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1862   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1863     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1864   }
1865   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1866   return cpi;
1867 WB_END
1868 
1869 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1870   return ConstantPool::encode_invokedynamic_index(index);
1871 WB_END
1872 
1873 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1874   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1875   VMThread::execute(&amp;clear_ics);
1876 WB_END
1877 
1878 template &lt;typename T&gt;
1879 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1880   assert(value != NULL, &quot;sanity&quot;);
1881   if (method == NULL || name == NULL) {
1882     return false;
1883   }
1884   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1885   CHECK_JNI_EXCEPTION_(env, false);
1886   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1887   // can&#39;t be in VM when we call JNI
1888   ThreadToNativeFromVM ttnfv(thread);
1889   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1890   CHECK_JNI_EXCEPTION_(env, false);
1891   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1892   env-&gt;ReleaseStringUTFChars(name, flag_name);
1893   return result;
1894 }
1895 
1896 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1897   bool result;
1898   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1899     // can&#39;t be in VM when we call JNI
1900     ThreadToNativeFromVM ttnfv(thread);
1901     return booleanBox(thread, env, result);
1902   }
1903   return NULL;
1904 WB_END
1905 
1906 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1907   intx result;
1908   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1909     // can&#39;t be in VM when we call JNI
1910     ThreadToNativeFromVM ttnfv(thread);
1911     return longBox(thread, env, result);
1912   }
1913   return NULL;
1914 WB_END
1915 
1916 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1917   uintx result;
1918   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1919     // can&#39;t be in VM when we call JNI
1920     ThreadToNativeFromVM ttnfv(thread);
1921     return longBox(thread, env, result);
1922   }
1923   return NULL;
1924 WB_END
1925 
1926 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1927   double result;
1928   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1929     // can&#39;t be in VM when we call JNI
1930     ThreadToNativeFromVM ttnfv(thread);
1931     return doubleBox(thread, env, result);
1932   }
1933   return NULL;
1934 WB_END
1935 
1936 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1937   ccstr ccstrResult;
1938   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1939     // can&#39;t be in VM when we call JNI
1940     ThreadToNativeFromVM ttnfv(thread);
1941     jstring result = env-&gt;NewStringUTF(ccstrResult);
1942     CHECK_JNI_EXCEPTION_(env, NULL);
1943     return result;
1944   }
1945   return NULL;
1946 WB_END
1947 
1948 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1949   const char* p = Arguments::get_default_shared_archive_path();
1950   ThreadToNativeFromVM ttn(thread);
1951   jstring path_string = env-&gt;NewStringUTF(p);
1952 
1953   CHECK_JNI_EXCEPTION_(env, NULL);
1954 
1955   return path_string;
1956 WB_END
1957 
1958 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1959   return UseSharedSpaces;
1960 WB_END
1961 
1962 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
1963   return FileMapInfo::memory_mapping_failed();
1964 WB_END
1965 
1966 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1967   oop obj_oop = JNIHandles::resolve(obj);
1968   return HeapShared::is_archived_object(obj_oop);
1969 WB_END
1970 
1971 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1972   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1973 WB_END
1974 
1975 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
1976   return !HeapShared::closed_archive_heap_region_mapped();
1977 WB_END
1978 
1979 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
1980   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1981   if (k-&gt;is_instance_klass()) {
1982     InstanceKlass *ik = InstanceKlass::cast(k);
1983     ConstantPool *cp = ik-&gt;constants();
1984     objArrayOop refs =  cp-&gt;resolved_references();
1985     return (jobject)JNIHandles::make_local(env, refs);
1986   } else {
1987     return NULL;
1988   }
1989 WB_END
1990 
1991 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1992   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1993   if (!k-&gt;is_instance_klass()) {
1994     return;
1995   }
1996   InstanceKlass *ik = InstanceKlass::cast(k);
1997   ik-&gt;link_class(THREAD); // may throw verification error
1998 WB_END
1999 
2000 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2001   return HeapShared::open_archive_heap_region_mapped();
2002 WB_END
2003 
2004 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2005 #if INCLUDE_CDS
<a name="7" id="anc7"></a>





2006   return true;
2007 #else
2008   return false;
2009 #endif // INCLUDE_CDS
2010 WB_END
2011 
2012 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2013 #if COMPILER2_OR_JVMCI
2014   return true;
2015 #else
2016   return false;
2017 #endif
2018 WB_END
2019 
2020 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2021   return HeapShared::is_heap_object_archiving_allowed();
2022 WB_END
2023 
2024 
2025 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2026 #if INCLUDE_JFR
2027   return true;
2028 #else
2029   return false;
2030 #endif // INCLUDE_JFR
2031 WB_END
2032 
2033 #if INCLUDE_CDS
2034 
2035 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2036   ResourceMark rm;
2037   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2038   int result = CDSOffsets::find_offset(c_name);
2039   return (jint)result;
2040 WB_END
2041 
2042 #endif // INCLUDE_CDS
2043 
2044 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2045   class TraceSelfClosure : public HandshakeClosure {
2046     jint _num_threads_completed;
2047 
2048     void do_thread(Thread* th) {
2049       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2050       JavaThread* jt = (JavaThread*)th;
2051       ResourceMark rm;
2052 
2053       jt-&gt;print_on(tty);
2054       jt-&gt;print_stack_on(tty);
2055       tty-&gt;cr();
2056       Atomic::inc(&amp;_num_threads_completed);
2057     }
2058 
2059   public:
2060     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2061 
2062     jint num_threads_completed() const { return _num_threads_completed; }
2063   };
2064   TraceSelfClosure tsc;
2065 
2066   if (all_threads) {
2067     Handshake::execute(&amp;tsc);
2068   } else {
2069     oop thread_oop = JNIHandles::resolve(thread_handle);
2070     if (thread_oop != NULL) {
2071       JavaThread* target = java_lang_Thread::thread(thread_oop);
2072       Handshake::execute(&amp;tsc, target);
2073     }
2074   }
2075   return tsc.num_threads_completed();
2076 WB_END
2077 
2078 //Some convenience methods to deal with objects from java
2079 int WhiteBox::offset_for_field(const char* field_name, oop object,
2080     Symbol* signature_symbol) {
2081   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2082   Thread* THREAD = Thread::current();
2083 
2084   //Get the class of our object
2085   Klass* arg_klass = object-&gt;klass();
2086   //Turn it into an instance-klass
2087   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2088 
2089   //Create symbols to look for in the class
2090   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2091 
2092   //To be filled in with an offset of the field we&#39;re looking for
2093   fieldDescriptor fd;
2094 
2095   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2096   if (res == NULL) {
2097     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2098         name_symbol-&gt;as_C_string());
2099     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2100   }
2101 
2102   //fetch the field at the offset we&#39;ve found
2103   int dest_offset = fd.offset();
2104 
2105   return dest_offset;
2106 }
2107 
2108 
2109 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2110   int offset = offset_for_field(field_name, object,
2111       vmSymbols::string_signature());
2112   oop string = object-&gt;obj_field(offset);
2113   if (string == NULL) {
2114     return NULL;
2115   }
2116   const char* ret = java_lang_String::as_utf8_string(string);
2117   return ret;
2118 }
2119 
2120 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2121   int offset =
2122       offset_for_field(field_name, object, vmSymbols::bool_signature());
2123   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2124   return ret;
2125 }
2126 
2127 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2128   ResourceMark rm;
2129   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2130 
2131   //  one by one registration natives for exception catching
2132   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2133   CHECK_JNI_EXCEPTION(env);
2134   for (int i = 0, n = method_count; i &lt; n; ++i) {
2135     // Skip dummy entries
2136     if (method_array[i].fnPtr == NULL) continue;
2137     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2138       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2139       if (throwable_obj != NULL) {
2140         env-&gt;ExceptionClear();
2141         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2142           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2143           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2144           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2145               method_array[i].name, method_array[i].signature);
2146         }
2147       } else {
2148         // Registration failed unexpectedly.
2149         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2150             method_array[i].name, method_array[i].signature);
2151         env-&gt;UnregisterNatives(wbclass);
2152         break;
2153       }
2154     }
2155   }
2156 }
2157 
2158 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2159   // can&#39;t be in VM when we call JNI
2160   ThreadToNativeFromVM ttnfv(thread);
2161   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2162   CHECK_JNI_EXCEPTION_(env, 0);
2163   int ret;
2164   {
2165     ThreadInVMfromNative ttvfn(thread); // back to VM
2166     ret = DirectivesParser::parse_string(dir, tty);
2167   }
2168   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2169   // -1 for error parsing directive. Return 0 as number of directives added.
2170   if (ret == -1) {
2171     ret = 0;
2172   }
2173   return (jint) ret;
2174 WB_END
2175 
2176 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2177   DirectivesStack::pop(count);
2178 WB_END
2179 
2180 // Checks that the library libfile has the noexecstack bit set.
2181 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2182   jboolean ret = false;
2183 #ifdef LINUX
2184   // Can&#39;t be in VM when we call JNI.
2185   ThreadToNativeFromVM ttnfv(thread);
2186   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2187   CHECK_JNI_EXCEPTION_(env, 0);
2188   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2189   env-&gt;ReleaseStringUTFChars(libfile, lf);
2190 #endif
2191   return ret;
2192 WB_END
2193 
2194 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2195   LINUX_ONLY(return OSContainer::is_containerized();)
2196   return false;
2197 WB_END
2198 
<a name="8" id="anc8"></a><span class="line-added">2199 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,</span>
<span class="line-added">2200                                     jobject o,</span>
<span class="line-added">2201                                     jstring proc_cgroups,</span>
<span class="line-added">2202                                     jstring proc_self_cgroup,</span>
<span class="line-added">2203                                     jstring proc_self_mountinfo))</span>
<span class="line-added">2204   jint ret = 0;</span>
<span class="line-added">2205 #ifdef LINUX</span>
<span class="line-added">2206   ThreadToNativeFromVM ttnfv(thread);</span>
<span class="line-added">2207   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);</span>
<span class="line-added">2208   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2209   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);</span>
<span class="line-added">2210   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2211   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);</span>
<span class="line-added">2212   CHECK_JNI_EXCEPTION_(env, 0);</span>
<span class="line-added">2213   u1 cg_type_flags = 0;</span>
<span class="line-added">2214   // This sets cg_type_flags</span>
<span class="line-added">2215   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);</span>
<span class="line-added">2216   ret = (jint)cg_type_flags;</span>
<span class="line-added">2217   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);</span>
<span class="line-added">2218   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);</span>
<span class="line-added">2219   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);</span>
<span class="line-added">2220 #endif</span>
<span class="line-added">2221   return ret;</span>
<span class="line-added">2222 WB_END</span>
<span class="line-added">2223 </span>
2224 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2225   os::print_os_info(tty);
2226 WB_END
2227 
2228 // Elf decoder
2229 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2230 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2231   ElfFile::_do_not_cache_elf_section = true;
2232 #endif
2233 WB_END
2234 
2235 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2236   return (jlong) ResolvedMethodTable::items_count();
2237 WB_END
2238 
2239 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2240   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2241 WB_END
2242 
2243 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2244   jint result = 0;
2245 #if INCLUDE_AOT
2246   result = (jint) AOTLoader::heaps_count();
2247 #endif
2248   return result;
2249 WB_END
2250 
2251 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2252   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2253   // Return size in bytes.
2254   return k-&gt;size() * wordSize;
2255 WB_END
2256 
2257 #define CC (char*)
2258 
2259 static JNINativeMethod methods[] = {
2260   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2261   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2262   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2263   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2264   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2265   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2266   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2267   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2268   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2269   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2270   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2271   {CC&quot;parseCommandLine0&quot;,
2272       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2273       (void*) &amp;WB_ParseCommandLine
2274   },
2275   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2276                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2277   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2278                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2279   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2280       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2281   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2282   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2283   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2284   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2285 #if INCLUDE_CDS
2286   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2287 #endif
2288 #if INCLUDE_G1GC
2289   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2290   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2291   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2292   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2293   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2294   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2295   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2296   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2297   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2298                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2299   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2300   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2301   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2302 #endif // INCLUDE_G1GC
2303 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2304   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2305   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2306   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2307   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2308 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2309 #if INCLUDE_PARALLELGC
2310   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2311   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2312 #endif
2313 #if INCLUDE_NMT
2314   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2315   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2316   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2317   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2318   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2319   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2320   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2321   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2322   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2323   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2324   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2325   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2326   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2327   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2328 #endif // INCLUDE_NMT
2329   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2330   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2331   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2332                                                       (void*)&amp;WB_DeoptimizeMethod  },
2333   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2334                                                       (void*)&amp;WB_IsMethodCompiled  },
2335   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2336                                                       (void*)&amp;WB_IsMethodCompilable},
2337   {CC&quot;isMethodQueuedForCompilation0&quot;,
2338       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2339   {CC&quot;isIntrinsicAvailable0&quot;,
2340       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2341                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2342   {CC&quot;makeMethodNotCompilable0&quot;,
2343       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2344   {CC&quot;testSetDontInlineMethod0&quot;,
2345       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2346   {CC&quot;getMethodCompilationLevel0&quot;,
2347       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2348   {CC&quot;getMethodEntryBci0&quot;,
2349       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2350   {CC&quot;getCompileQueueSize&quot;,
2351       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2352   {CC&quot;testSetForceInlineMethod0&quot;,
2353       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2354   {CC&quot;enqueueMethodForCompilation0&quot;,
2355       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2356   {CC&quot;enqueueInitializerForCompilation0&quot;,
2357       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2358   {CC&quot;markMethodProfiled&quot;,
2359       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2360   {CC&quot;clearMethodState0&quot;,
2361       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2362   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2363   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2364   {CC&quot;matchesMethod&quot;,
2365       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2366                                                       (void*)&amp;WB_MatchesMethod},
2367   {CC&quot;matchesInline&quot;,
2368       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2369                                                       (void*)&amp;WB_MatchesInline},
2370   {CC&quot;shouldPrintAssembly&quot;,
2371         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2372                                                         (void*)&amp;WB_ShouldPrintAssembly},
2373 
2374   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2375   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2376   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2377   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2378   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2379   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2380   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2381   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2382   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2383   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2384   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2385                                                       (void*)&amp;WB_SetStringVMFlag},
2386   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2387                                                       (void*)&amp;WB_GetBooleanVMFlag},
2388   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2389                                                       (void*)&amp;WB_GetIntVMFlag},
2390   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2391                                                       (void*)&amp;WB_GetUintVMFlag},
2392   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2393                                                       (void*)&amp;WB_GetIntxVMFlag},
2394   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2395                                                       (void*)&amp;WB_GetUintxVMFlag},
2396   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2397                                                       (void*)&amp;WB_GetUint64VMFlag},
2398   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2399                                                       (void*)&amp;WB_GetSizeTVMFlag},
2400   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2401                                                       (void*)&amp;WB_GetDoubleVMFlag},
2402   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2403                                                       (void*)&amp;WB_GetStringVMFlag},
2404   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2405   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2406   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2407   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2408   {CC&quot;allocateMetaspace&quot;,
2409      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2410   {CC&quot;freeMetaspace&quot;,
2411      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2412   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2413   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2414   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2415   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2416   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2417                                                       (void*)&amp;WB_GetNMethod         },
2418   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2419   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2420   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2421   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2422   {CC&quot;getCompilationActivityMode&quot;,
2423                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2424   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2425                                                       (void*)&amp;WB_GetMethodData      },
2426   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2427   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2428   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2429   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2430                                                       (void*)&amp;WB_DefineModule },
2431   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2432                                                       (void*)&amp;WB_AddModuleExports },
2433   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2434                                                       (void*)&amp;WB_AddReadsModule },
2435   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2436                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2437   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2438                                                       (void*)&amp;WB_AddModuleExportsToAll },
2439   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2440   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2441   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2442   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2443   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2444   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2445   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2446   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2447       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2448   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2449       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2450   {CC&quot;getMethodBooleanOption&quot;,
2451       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2452                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2453   {CC&quot;getMethodIntxOption&quot;,
2454       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2455                                                       (void*)&amp;WB_GetMethodIntxOption},
2456   {CC&quot;getMethodUintxOption&quot;,
2457       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2458                                                       (void*)&amp;WB_GetMethodUintxOption},
2459   {CC&quot;getMethodDoubleOption&quot;,
2460       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2461                                                       (void*)&amp;WB_GetMethodDoubleOption},
2462   {CC&quot;getMethodStringOption&quot;,
2463       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2464                                                       (void*)&amp;WB_GetMethodStringOption},
2465   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2466                                                       (void*)&amp;WB_GetDefaultArchivePath},
2467   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2468   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2469   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2470   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2471   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2472   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2473   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2474   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2475   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2476   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2477   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2478   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2479 
2480   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2481   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2482   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2483                                                       (void*)&amp;WB_AddCompilerDirective },
2484   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2485   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2486   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2487   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<a name="9" id="anc9"></a><span class="line-modified">2488   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},</span>
<span class="line-modified">2489   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},</span>
<span class="line-modified">2490   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},</span>
<span class="line-added">2491   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},</span>
<span class="line-added">2492   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-added">2493                                                       (void*)&amp;WB_ConcurrentGCRunTo},</span>
2494   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2495                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2496   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
<a name="10" id="anc10"></a><span class="line-added">2497   {CC&quot;validateCgroup&quot;,</span>
<span class="line-added">2498       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,</span>
<span class="line-added">2499                                                       (void*)&amp;WB_ValidateCgroup },</span>
2500   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2501   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2502   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2503   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2504   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2505   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2506 };
2507 
2508 
2509 #undef CC
2510 
2511 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2512   {
2513     if (WhiteBoxAPI) {
2514       // Make sure that wbclass is loaded by the null classloader
2515       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2516       Handle loader(THREAD, ik-&gt;class_loader());
2517       if (loader.is_null()) {
2518         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2519         WhiteBox::set_used();
2520       }
2521     }
2522   }
2523 JVM_END
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahCollectionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahConcurrentMark.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;

 44 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
<span class="line-removed"> 45 #include &quot;gc/shenandoah/shenandoahTimingTracker.hpp&quot;</span>
 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 64   }
 65 
</pre>
<hr />
<pre>
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
 86   ShenandoahAllRootScanner* _rp;
<span class="line-removed"> 87   bool _process_refs;</span>
 88 public:
<span class="line-modified"> 89   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp, bool process_refs) :</span>
 90     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<span class="line-modified"> 91     _rp(rp),</span>
<span class="line-removed"> 92     _process_refs(process_refs) {</span>
 93   }
 94 
 95   void work(uint worker_id) {
 96     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 97     ShenandoahParallelWorkerSession worker_session(worker_id);
 98 
 99     ShenandoahHeap* heap = ShenandoahHeap::heap();
100     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
101     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
102 
103     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
104 
105     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
106     do_work(heap, &amp;mark_cl, worker_id);
107   }
108 
109 private:
110   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
111     // The rationale for selecting the roots to scan is as follows:
112     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
</pre>
<hr />
<pre>
251 };
252 
253 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
254   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
255   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
256 
257   ShenandoahHeap* heap = ShenandoahHeap::heap();
258 
259   ShenandoahGCPhase phase(root_phase);
260 
261   WorkGang* workers = heap-&gt;workers();
262   uint nworkers = workers-&gt;active_workers();
263 
264   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
265 
266   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
267   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
268   task_queues()-&gt;reserve(nworkers);
269 
270   if (heap-&gt;has_forwarded_objects()) {
<span class="line-modified">271     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());</span>
272     workers-&gt;run_task(&amp;mark_roots);
273   } else {
274     // No need to update references, which means the heap is stable.
275     // Can save time not walking through forwarding pointers.
<span class="line-modified">276     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc, _heap-&gt;process_references());</span>
277     workers-&gt;run_task(&amp;mark_roots);
278   }
279 
280   if (ShenandoahConcurrentScanCodeRoots) {
281     clear_claim_codecache();
282   }
283 }
284 
285 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
286   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
287   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
288          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
289          &quot;Only for these phases&quot;);
290 
291   ShenandoahGCPhase phase(root_phase);
292 
293   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
294 
295 #if COMPILER2_OR_JVMCI
296   DerivedPointerTable::clear();
297 #endif
298 
299   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
300 
301   ShenandoahRootUpdater root_updater(nworkers, root_phase);
302   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
303   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
304 
305 #if COMPILER2_OR_JVMCI
306   DerivedPointerTable::update_pointers();
307 #endif
308 }
309 
310 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
311 private:
312   ShenandoahThreadRoots           _thread_roots;
313   ShenandoahPhaseTimings::Phase   _phase;

314 public:
315   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
316     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
317     _thread_roots(is_par),
<span class="line-modified">318     _phase(phase) {</span>
<span class="line-modified">319     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_start(_phase);</span>
<span class="line-removed">320   }</span>
321 
<span class="line-removed">322   ~ShenandoahUpdateThreadRootsTask() {</span>
<span class="line-removed">323     ShenandoahHeap::heap()-&gt;phase_timings()-&gt;record_workers_end(_phase);</span>
<span class="line-removed">324   }</span>
325   void work(uint worker_id) {
326     ShenandoahUpdateRefsClosure cl;
327     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
328   }
329 };
330 
331 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
332   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
333 
334   ShenandoahGCPhase phase(root_phase);
335 
336 #if COMPILER2_OR_JVMCI
337   DerivedPointerTable::clear();
338 #endif
339 
340   WorkGang* workers = _heap-&gt;workers();
341   bool is_par = workers-&gt;active_workers() &gt; 1;
342 
343   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
344   workers-&gt;run_task(&amp;task);
</pre>
<hr />
<pre>
686   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
687 };
688 
689 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
690 public:
691   void do_void() {
692     ShenandoahHeap* sh = ShenandoahHeap::heap();
693     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
694     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
695     TaskTerminator terminator(1, scm-&gt;task_queues());
696 
697     ReferenceProcessor* rp = sh-&gt;ref_processor();
698     shenandoah_assert_rp_isalive_installed();
699 
700     scm-&gt;mark_loop(0, &amp;terminator, rp,
701                    false, // not cancellable
702                    false); // do not do strdedup
703   }
704 };
705 
<span class="line-removed">706 class ShenandoahPrecleanKeepAliveUpdateClosure : public OopClosure {</span>
<span class="line-removed">707 private:</span>
<span class="line-removed">708   ShenandoahObjToScanQueue* _queue;</span>
<span class="line-removed">709   ShenandoahHeap* _heap;</span>
<span class="line-removed">710   ShenandoahMarkingContext* const _mark_context;</span>
<span class="line-removed">711 </span>
<span class="line-removed">712   template &lt;class T&gt;</span>
<span class="line-removed">713   inline void do_oop_work(T* p) {</span>
<span class="line-removed">714     ShenandoahConcurrentMark::mark_through_ref&lt;T, CONCURRENT, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);</span>
<span class="line-removed">715   }</span>
<span class="line-removed">716 </span>
<span class="line-removed">717 public:</span>
<span class="line-removed">718   ShenandoahPrecleanKeepAliveUpdateClosure(ShenandoahObjToScanQueue* q) :</span>
<span class="line-removed">719     _queue(q),</span>
<span class="line-removed">720     _heap(ShenandoahHeap::heap()),</span>
<span class="line-removed">721     _mark_context(_heap-&gt;marking_context()) {}</span>
<span class="line-removed">722 </span>
<span class="line-removed">723   void do_oop(narrowOop* p) { do_oop_work(p); }</span>
<span class="line-removed">724   void do_oop(oop* p)       { do_oop_work(p); }</span>
<span class="line-removed">725 };</span>
<span class="line-removed">726 </span>
727 class ShenandoahPrecleanTask : public AbstractGangTask {
728 private:
729   ReferenceProcessor* _rp;
730 
731 public:
732   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
733           AbstractGangTask(&quot;Precleaning task&quot;),
734           _rp(rp) {}
735 
736   void work(uint worker_id) {
737     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
738     ShenandoahParallelWorkerSession worker_session(worker_id);
739 
740     ShenandoahHeap* sh = ShenandoahHeap::heap();

741 
742     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
743 
744     ShenandoahCancelledGCYieldClosure yield;
745     ShenandoahPrecleanCompleteGCClosure complete_gc;
746 
<span class="line-modified">747     if (sh-&gt;has_forwarded_objects()) {</span>
<span class="line-modified">748       ShenandoahForwardedIsAliveClosure is_alive;</span>
<span class="line-modified">749       ShenandoahPrecleanKeepAliveUpdateClosure keep_alive(q);</span>
<span class="line-modified">750       ResourceMark rm;</span>
<span class="line-modified">751       _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">752                                           &amp;complete_gc, &amp;yield,</span>
<span class="line-removed">753                                           NULL);</span>
<span class="line-removed">754     } else {</span>
<span class="line-removed">755       ShenandoahIsAliveClosure is_alive;</span>
<span class="line-removed">756       ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-removed">757       ResourceMark rm;</span>
<span class="line-removed">758       _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-removed">759                                           &amp;complete_gc, &amp;yield,</span>
<span class="line-removed">760                                           NULL);</span>
<span class="line-removed">761     }</span>
762   }
763 };
764 
765 void ShenandoahConcurrentMark::preclean_weak_refs() {
766   // Pre-cleaning weak references before diving into STW makes sense at the
767   // end of concurrent mark. This will filter out the references which referents
768   // are alive. Note that ReferenceProcessor already filters out these on reference
769   // discovery, and the bulk of work is done here. This phase processes leftovers
770   // that missed the initial filtering, i.e. when referent was marked alive after
771   // reference was discovered by RP.
772 
773   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
774 
775   // Shortcut if no references were discovered to avoid winding up threads.
776   ReferenceProcessor* rp = _heap-&gt;ref_processor();
777   if (!rp-&gt;has_discovered_references()) {
778     return;
779   }
780 
781   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
</pre>
</td>
<td>
<hr />
<pre>
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 
 27 #include &quot;classfile/symbolTable.hpp&quot;
 28 #include &quot;classfile/systemDictionary.hpp&quot;
 29 #include &quot;code/codeCache.hpp&quot;
 30 
 31 #include &quot;gc/shared/weakProcessor.inline.hpp&quot;
 32 #include &quot;gc/shared/gcTimer.hpp&quot;
 33 #include &quot;gc/shared/referenceProcessor.hpp&quot;
 34 #include &quot;gc/shared/referenceProcessorPhaseTimes.hpp&quot;
 35 #include &quot;gc/shared/strongRootsScope.hpp&quot;
 36 
 37 #include &quot;gc/shenandoah/shenandoahBarrierSet.inline.hpp&quot;
 38 #include &quot;gc/shenandoah/shenandoahClosures.inline.hpp&quot;
 39 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
 40 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
 41 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
 43 #include &quot;gc/shenandoah/shenandoahOopClosures.inline.hpp&quot;
<span class="line-added"> 44 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;</span>
 45 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;

 46 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
 47 
 48 #include &quot;memory/iterator.inline.hpp&quot;
 49 #include &quot;memory/metaspace.hpp&quot;
 50 #include &quot;memory/resourceArea.hpp&quot;
 51 #include &quot;oops/oop.inline.hpp&quot;
 52 #include &quot;runtime/handles.inline.hpp&quot;
 53 
 54 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 55 class ShenandoahInitMarkRootsClosure : public OopClosure {
 56 private:
 57   ShenandoahObjToScanQueue* _queue;
 58   ShenandoahHeap* _heap;
 59   ShenandoahMarkingContext* const _mark_context;
 60 
 61   template &lt;class T&gt;
 62   inline void do_oop_work(T* p) {
 63     ShenandoahConcurrentMark::mark_through_ref&lt;T, UPDATE_REFS, NO_DEDUP&gt;(p, _heap, _queue, _mark_context);
 64   }
 65 
</pre>
<hr />
<pre>
 67   ShenandoahInitMarkRootsClosure(ShenandoahObjToScanQueue* q) :
 68     _queue(q),
 69     _heap(ShenandoahHeap::heap()),
 70     _mark_context(_heap-&gt;marking_context()) {};
 71 
 72   void do_oop(narrowOop* p) { do_oop_work(p); }
 73   void do_oop(oop* p)       { do_oop_work(p); }
 74 };
 75 
 76 ShenandoahMarkRefsSuperClosure::ShenandoahMarkRefsSuperClosure(ShenandoahObjToScanQueue* q, ReferenceProcessor* rp) :
 77   MetadataVisitingOopIterateClosure(rp),
 78   _queue(q),
 79   _heap(ShenandoahHeap::heap()),
 80   _mark_context(_heap-&gt;marking_context())
 81 { }
 82 
 83 template&lt;UpdateRefsMode UPDATE_REFS&gt;
 84 class ShenandoahInitMarkRootsTask : public AbstractGangTask {
 85 private:
 86   ShenandoahAllRootScanner* _rp;

 87 public:
<span class="line-modified"> 88   ShenandoahInitMarkRootsTask(ShenandoahAllRootScanner* rp) :</span>
 89     AbstractGangTask(&quot;Shenandoah init mark roots task&quot;),
<span class="line-modified"> 90     _rp(rp) {</span>

 91   }
 92 
 93   void work(uint worker_id) {
 94     assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
 95     ShenandoahParallelWorkerSession worker_session(worker_id);
 96 
 97     ShenandoahHeap* heap = ShenandoahHeap::heap();
 98     ShenandoahObjToScanQueueSet* queues = heap-&gt;concurrent_mark()-&gt;task_queues();
 99     assert(queues-&gt;get_reserved() &gt; worker_id, &quot;Queue has not been reserved for worker id: %d&quot;, worker_id);
100 
101     ShenandoahObjToScanQueue* q = queues-&gt;queue(worker_id);
102 
103     ShenandoahInitMarkRootsClosure&lt;UPDATE_REFS&gt; mark_cl(q);
104     do_work(heap, &amp;mark_cl, worker_id);
105   }
106 
107 private:
108   void do_work(ShenandoahHeap* heap, OopClosure* oops, uint worker_id) {
109     // The rationale for selecting the roots to scan is as follows:
110     //   a. With unload_classes = true, we only want to scan the actual strong roots from the
</pre>
<hr />
<pre>
249 };
250 
251 void ShenandoahConcurrentMark::mark_roots(ShenandoahPhaseTimings::Phase root_phase) {
252   assert(Thread::current()-&gt;is_VM_thread(), &quot;can only do this in VMThread&quot;);
253   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
254 
255   ShenandoahHeap* heap = ShenandoahHeap::heap();
256 
257   ShenandoahGCPhase phase(root_phase);
258 
259   WorkGang* workers = heap-&gt;workers();
260   uint nworkers = workers-&gt;active_workers();
261 
262   assert(nworkers &lt;= task_queues()-&gt;size(), &quot;Just check&quot;);
263 
264   ShenandoahAllRootScanner root_proc(nworkers, root_phase);
265   TASKQUEUE_STATS_ONLY(task_queues()-&gt;reset_taskqueue_stats());
266   task_queues()-&gt;reserve(nworkers);
267 
268   if (heap-&gt;has_forwarded_objects()) {
<span class="line-modified">269     ShenandoahInitMarkRootsTask&lt;RESOLVE&gt; mark_roots(&amp;root_proc);</span>
270     workers-&gt;run_task(&amp;mark_roots);
271   } else {
272     // No need to update references, which means the heap is stable.
273     // Can save time not walking through forwarding pointers.
<span class="line-modified">274     ShenandoahInitMarkRootsTask&lt;NONE&gt; mark_roots(&amp;root_proc);</span>
275     workers-&gt;run_task(&amp;mark_roots);
276   }
277 
278   if (ShenandoahConcurrentScanCodeRoots) {
279     clear_claim_codecache();
280   }
281 }
282 
283 void ShenandoahConcurrentMark::update_roots(ShenandoahPhaseTimings::Phase root_phase) {
284   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
285   assert(root_phase == ShenandoahPhaseTimings::full_gc_roots ||
286          root_phase == ShenandoahPhaseTimings::degen_gc_update_roots,
287          &quot;Only for these phases&quot;);
288 
289   ShenandoahGCPhase phase(root_phase);
290 
291   bool check_alive = root_phase == ShenandoahPhaseTimings::degen_gc_update_roots;
292 
293 #if COMPILER2_OR_JVMCI
294   DerivedPointerTable::clear();
295 #endif
296 
297   uint nworkers = _heap-&gt;workers()-&gt;active_workers();
298 
299   ShenandoahRootUpdater root_updater(nworkers, root_phase);
300   ShenandoahUpdateRootsTask update_roots(&amp;root_updater, check_alive);
301   _heap-&gt;workers()-&gt;run_task(&amp;update_roots);
302 
303 #if COMPILER2_OR_JVMCI
304   DerivedPointerTable::update_pointers();
305 #endif
306 }
307 
308 class ShenandoahUpdateThreadRootsTask : public AbstractGangTask {
309 private:
310   ShenandoahThreadRoots           _thread_roots;
311   ShenandoahPhaseTimings::Phase   _phase;
<span class="line-added">312   ShenandoahGCWorkerPhase         _worker_phase;</span>
313 public:
314   ShenandoahUpdateThreadRootsTask(bool is_par, ShenandoahPhaseTimings::Phase phase) :
315     AbstractGangTask(&quot;Shenandoah Update Thread Roots&quot;),
316     _thread_roots(is_par),
<span class="line-modified">317     _phase(phase),</span>
<span class="line-modified">318     _worker_phase(phase) {}</span>

319 



320   void work(uint worker_id) {
321     ShenandoahUpdateRefsClosure cl;
322     _thread_roots.oops_do(&amp;cl, NULL, worker_id);
323   }
324 };
325 
326 void ShenandoahConcurrentMark::update_thread_roots(ShenandoahPhaseTimings::Phase root_phase) {
327   assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), &quot;Must be at a safepoint&quot;);
328 
329   ShenandoahGCPhase phase(root_phase);
330 
331 #if COMPILER2_OR_JVMCI
332   DerivedPointerTable::clear();
333 #endif
334 
335   WorkGang* workers = _heap-&gt;workers();
336   bool is_par = workers-&gt;active_workers() &gt; 1;
337 
338   ShenandoahUpdateThreadRootsTask task(is_par, root_phase);
339   workers-&gt;run_task(&amp;task);
</pre>
<hr />
<pre>
681   virtual bool should_return() { return _heap-&gt;cancelled_gc(); }
682 };
683 
684 class ShenandoahPrecleanCompleteGCClosure : public VoidClosure {
685 public:
686   void do_void() {
687     ShenandoahHeap* sh = ShenandoahHeap::heap();
688     ShenandoahConcurrentMark* scm = sh-&gt;concurrent_mark();
689     assert(sh-&gt;process_references(), &quot;why else would we be here?&quot;);
690     TaskTerminator terminator(1, scm-&gt;task_queues());
691 
692     ReferenceProcessor* rp = sh-&gt;ref_processor();
693     shenandoah_assert_rp_isalive_installed();
694 
695     scm-&gt;mark_loop(0, &amp;terminator, rp,
696                    false, // not cancellable
697                    false); // do not do strdedup
698   }
699 };
700 





















701 class ShenandoahPrecleanTask : public AbstractGangTask {
702 private:
703   ReferenceProcessor* _rp;
704 
705 public:
706   ShenandoahPrecleanTask(ReferenceProcessor* rp) :
707           AbstractGangTask(&quot;Precleaning task&quot;),
708           _rp(rp) {}
709 
710   void work(uint worker_id) {
711     assert(worker_id == 0, &quot;The code below is single-threaded, only one worker is expected&quot;);
712     ShenandoahParallelWorkerSession worker_session(worker_id);
713 
714     ShenandoahHeap* sh = ShenandoahHeap::heap();
<span class="line-added">715     assert(!sh-&gt;has_forwarded_objects(), &quot;No forwarded objects expected here&quot;);</span>
716 
717     ShenandoahObjToScanQueue* q = sh-&gt;concurrent_mark()-&gt;get_queue(worker_id);
718 
719     ShenandoahCancelledGCYieldClosure yield;
720     ShenandoahPrecleanCompleteGCClosure complete_gc;
721 
<span class="line-modified">722     ShenandoahIsAliveClosure is_alive;</span>
<span class="line-modified">723     ShenandoahCMKeepAliveClosure keep_alive(q);</span>
<span class="line-modified">724     ResourceMark rm;</span>
<span class="line-modified">725     _rp-&gt;preclean_discovered_references(&amp;is_alive, &amp;keep_alive,</span>
<span class="line-modified">726                                         &amp;complete_gc, &amp;yield,</span>
<span class="line-modified">727                                         NULL);</span>









728   }
729 };
730 
731 void ShenandoahConcurrentMark::preclean_weak_refs() {
732   // Pre-cleaning weak references before diving into STW makes sense at the
733   // end of concurrent mark. This will filter out the references which referents
734   // are alive. Note that ReferenceProcessor already filters out these on reference
735   // discovery, and the bulk of work is done here. This phase processes leftovers
736   // that missed the initial filtering, i.e. when referent was marked alive after
737   // reference was discovered by RP.
738 
739   assert(_heap-&gt;process_references(), &quot;sanity&quot;);
740 
741   // Shortcut if no references were discovered to avoid winding up threads.
742   ReferenceProcessor* rp = _heap-&gt;ref_processor();
743   if (!rp-&gt;has_discovered_references()) {
744     return;
745   }
746 
747   assert(task_queues()-&gt;is_empty(), &quot;Should be empty&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahCollectionSet.inline.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahControlThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
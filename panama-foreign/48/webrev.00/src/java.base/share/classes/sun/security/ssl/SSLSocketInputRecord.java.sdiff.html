<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SSLSocketInputRecord.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLTransport.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SSLSocketInputRecord.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.

  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.EOFException;

 29 import java.io.IOException;
 30 import java.io.InputStream;
 31 import java.io.OutputStream;
 32 import java.nio.ByteBuffer;
 33 import java.security.GeneralSecurityException;
 34 import java.util.ArrayList;
 35 import javax.crypto.BadPaddingException;
 36 import javax.net.ssl.SSLException;
 37 import javax.net.ssl.SSLHandshakeException;
 38 import javax.net.ssl.SSLProtocolException;
 39 
 40 import sun.security.ssl.SSLCipher.SSLReadCipher;
 41 
 42 /**
 43  * {@code InputRecord} implementation for {@code SSLSocket}.
 44  *
 45  * @author David Brownell
 46  */
 47 final class SSLSocketInputRecord extends InputRecord implements SSLRecord {
 48     private InputStream is = null;
 49     private OutputStream os = null;
<span class="line-modified"> 50     private final byte[] temporary = new byte[1024];</span>



 51 
 52     private boolean formatVerified = false;     // SSLv2 ruled out?
 53 
 54     // Cache for incomplete handshake messages.
 55     private ByteBuffer handshakeBuffer = null;
 56 
<span class="line-removed"> 57     private boolean hasHeader = false;          // Had read the record header</span>
<span class="line-removed"> 58 </span>
 59     SSLSocketInputRecord(HandshakeHash handshakeHash) {
 60         super(handshakeHash, SSLReadCipher.nullTlsReadCipher());
 61     }
 62 
 63     @Override
 64     int bytesInCompletePacket() throws IOException {
<span class="line-modified"> 65         if (!hasHeader) {</span>
<span class="line-modified"> 66             // read exactly one record</span>
<span class="line-modified"> 67             try {</span>
<span class="line-modified"> 68                 int really = read(is, temporary, 0, headerSize);</span>
<span class="line-modified"> 69                 if (really &lt; 0) {</span>
<span class="line-modified"> 70                     // EOF: peer shut down incorrectly</span>
<span class="line-removed"> 71                     return -1;</span>
<span class="line-removed"> 72                 }</span>
<span class="line-removed"> 73             } catch (EOFException eofe) {</span>
<span class="line-removed"> 74                 // The caller will handle EOF.</span>
<span class="line-removed"> 75                 return -1;</span>
<span class="line-removed"> 76             }</span>
<span class="line-removed"> 77             hasHeader = true;</span>
 78         }
 79 
<span class="line-modified"> 80         byte byteZero = temporary[0];</span>
 81         int len = 0;
 82 
 83         /*
 84          * If we have already verified previous packets, we can
 85          * ignore the verifications steps, and jump right to the
 86          * determination.  Otherwise, try one last heuristic to
 87          * see if it&#39;s SSL/TLS.
 88          */
 89         if (formatVerified ||
 90                 (byteZero == ContentType.HANDSHAKE.id) ||
 91                 (byteZero == ContentType.ALERT.id)) {
 92             /*
 93              * Last sanity check that it&#39;s not a wild record
 94              */
 95             if (!ProtocolVersion.isNegotiable(
<span class="line-modified"> 96                     temporary[1], temporary[2], false, false)) {</span>
 97                 throw new SSLException(&quot;Unrecognized record version &quot; +
<span class="line-modified"> 98                         ProtocolVersion.nameOf(temporary[1], temporary[2]) +</span>
 99                         &quot; , plaintext connection?&quot;);
100             }
101 
102             /*
103              * Reasonably sure this is a V3, disable further checks.
104              * We can&#39;t do the same in the v2 check below, because
105              * read still needs to parse/handle the v2 clientHello.
106              */
107             formatVerified = true;
108 
109             /*
110              * One of the SSLv3/TLS message types.
111              */
<span class="line-modified">112             len = ((temporary[3] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-modified">113                    (temporary[4] &amp; 0xFF) + headerSize;</span>
114         } else {
115             /*
116              * Must be SSLv2 or something unknown.
117              * Check if it&#39;s short (2 bytes) or
118              * long (3) header.
119              *
120              * Internals can warn about unsupported SSLv2
121              */
122             boolean isShort = ((byteZero &amp; 0x80) != 0);
123 
<span class="line-modified">124             if (isShort &amp;&amp; ((temporary[2] == 1) || (temporary[2] == 4))) {</span>
125                 if (!ProtocolVersion.isNegotiable(
<span class="line-modified">126                         temporary[3], temporary[4], false, false)) {</span>
127                     throw new SSLException(&quot;Unrecognized record version &quot; +
<span class="line-modified">128                             ProtocolVersion.nameOf(temporary[3], temporary[4]) +</span>
129                             &quot; , plaintext connection?&quot;);
130                 }
131 
132                 /*
133                  * Client or Server Hello
134                  */
135                 //
136                 // Short header is using here.  We reverse the code here
137                 // in case it is used in the future.
138                 //
139                 // int mask = (isShort ? 0x7F : 0x3F);
140                 // len = ((byteZero &amp; mask) &lt;&lt; 8) +
<span class="line-modified">141                 //        (temporary[1] &amp; 0xFF) + (isShort ? 2 : 3);</span>
142                 //
<span class="line-modified">143                 len = ((byteZero &amp; 0x7F) &lt;&lt; 8) + (temporary[1] &amp; 0xFF) + 2;</span>
144             } else {
145                 // Gobblygook!
146                 throw new SSLException(
147                         &quot;Unrecognized SSL message, plaintext connection?&quot;);
148             }
149         }
150 
151         return len;
152     }
153 
154     // Note that the input arguments are not used actually.
155     @Override
156     Plaintext[] decode(ByteBuffer[] srcs, int srcsOffset,
157             int srcsLength) throws IOException, BadPaddingException {
158 
159         if (isClosed) {
160             return null;
161         }
162 
<span class="line-modified">163         if (!hasHeader) {</span>
<span class="line-modified">164             // read exactly one record</span>
<span class="line-removed">165             int really = read(is, temporary, 0, headerSize);</span>
<span class="line-removed">166             if (really &lt; 0) {</span>
<span class="line-removed">167                 throw new EOFException(&quot;SSL peer shut down incorrectly&quot;);</span>
<span class="line-removed">168             }</span>
<span class="line-removed">169             hasHeader = true;</span>
<span class="line-removed">170         }</span>
171 
<span class="line-modified">172         Plaintext plaintext = null;</span>
<span class="line-modified">173         if (!formatVerified) {</span>
<span class="line-modified">174             formatVerified = true;</span>


175 
<span class="line-modified">176             /*</span>
<span class="line-modified">177              * The first record must either be a handshake record or an</span>
<span class="line-modified">178              * alert message. If it&#39;s not, it is either invalid or an</span>
<span class="line-modified">179              * SSLv2 message.</span>
<span class="line-modified">180              */</span>
<span class="line-modified">181             if ((temporary[0] != ContentType.HANDSHAKE.id) &amp;&amp;</span>
<span class="line-modified">182                 (temporary[0] != ContentType.ALERT.id)) {</span>
<span class="line-modified">183                 hasHeader = false;</span>
<span class="line-modified">184                 return handleUnknownRecord(temporary);</span>
185             }
<span class="line-removed">186         }</span>
187 
<span class="line-modified">188         // The record header should has consumed.</span>
<span class="line-modified">189         hasHeader = false;</span>
<span class="line-modified">190         return decodeInputRecord(temporary);</span>












191     }
192 
193     @Override
194     void setReceiverStream(InputStream inputStream) {
195         this.is = inputStream;
196     }
197 
198     @Override
199     void setDeliverStream(OutputStream outputStream) {
200         this.os = outputStream;
201     }
202 
<span class="line-modified">203     // Note that destination may be null</span>
<span class="line-removed">204     private Plaintext[] decodeInputRecord(</span>
<span class="line-removed">205             byte[] header) throws IOException, BadPaddingException {</span>
206         byte contentType = header[0];                   // pos: 0
207         byte majorVersion = header[1];                  // pos: 1
208         byte minorVersion = header[2];                  // pos: 2
209         int contentLen = ((header[3] &amp; 0xFF) &lt;&lt; 8) +
210                            (header[4] &amp; 0xFF);          // pos: 3, 4
211 
212         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
213             SSLLogger.fine(
214                     &quot;READ: &quot; +
215                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
216                     &quot; &quot; + ContentType.nameOf(contentType) + &quot;, length = &quot; +
217                     contentLen);
218         }
219 
220         //
221         // Check for upper bound.
222         //
223         // Note: May check packetSize limit in the future.
224         if (contentLen &lt; 0 || contentLen &gt; maxLargeRecordSize - headerSize) {
225             throw new SSLProtocolException(
226                 &quot;Bad input record size, TLSCiphertext.length = &quot; + contentLen);
227         }
228 
229         //
<span class="line-modified">230         // Read a complete record.</span>


231         //
<span class="line-modified">232         ByteBuffer destination = ByteBuffer.allocate(headerSize + contentLen);</span>
<span class="line-modified">233         int dstPos = destination.position();</span>
<span class="line-modified">234         destination.put(temporary, 0, headerSize);</span>
<span class="line-removed">235         while (contentLen &gt; 0) {</span>
<span class="line-removed">236             int howmuch = Math.min(temporary.length, contentLen);</span>
<span class="line-removed">237             int really = read(is, temporary, 0, howmuch);</span>
<span class="line-removed">238             if (really &lt; 0) {</span>
<span class="line-removed">239                 throw new EOFException(&quot;SSL peer shut down incorrectly&quot;);</span>
240             }
<span class="line-modified">241 </span>
<span class="line-modified">242             destination.put(temporary, 0, howmuch);</span>
<span class="line-modified">243             contentLen -= howmuch;</span>
244         }
<span class="line-modified">245         destination.flip();</span>
<span class="line-modified">246         destination.position(dstPos + headerSize);</span>
247 
248         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
249             SSLLogger.fine(
250                     &quot;READ: &quot; +
251                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
252                     &quot; &quot; + ContentType.nameOf(contentType) + &quot;, length = &quot; +
<span class="line-modified">253                     destination.remaining());</span>
254         }
255 
256         //
257         // Decrypt the fragment
258         //
259         ByteBuffer fragment;
260         try {
261             Plaintext plaintext =
<span class="line-modified">262                     readCipher.decrypt(contentType, destination, null);</span>
263             fragment = plaintext.fragment;
264             contentType = plaintext.contentType;
265         } catch (BadPaddingException bpe) {
266             throw bpe;
267         } catch (GeneralSecurityException gse) {
268             throw (SSLProtocolException)(new SSLProtocolException(
269                     &quot;Unexpected exception&quot;)).initCause(gse);
270         }
271 
272         if (contentType != ContentType.HANDSHAKE.id &amp;&amp;
273                 handshakeBuffer != null &amp;&amp; handshakeBuffer.hasRemaining()) {
274             throw new SSLProtocolException(
275                     &quot;Expecting a handshake fragment, but received &quot; +
276                     ContentType.nameOf(contentType));
277         }
278 
279         //
280         // parse handshake messages
281         //
282         if (contentType == ContentType.HANDSHAKE.id) {
</pre>
<hr />
<pre>
344 
345                     plaintexts.add(
346                         new Plaintext(contentType, majorVersion, minorVersion,
347                             -1, -1L, handshakeFrag.slice())
348                     );
349 
350                     handshakeFrag.position(nextPos);
351                     handshakeFrag.limit(fragLim);
352                 }
353             }
354 
355             return plaintexts.toArray(new Plaintext[0]);
356         }
357 
358         return new Plaintext[] {
359                 new Plaintext(contentType,
360                     majorVersion, minorVersion, -1, -1L, fragment)
361             };
362     }
363 
<span class="line-modified">364     private Plaintext[] handleUnknownRecord(</span>
<span class="line-removed">365             byte[] header) throws IOException, BadPaddingException {</span>
366         byte firstByte = header[0];
367         byte thirdByte = header[2];
368 
369         // Does it look like a Version 2 client hello (V2ClientHello)?
370         if (((firstByte &amp; 0x80) != 0) &amp;&amp; (thirdByte == 1)) {
371             /*
372              * If SSLv2Hello is not enabled, throw an exception.
373              */
374             if (helloVersion != ProtocolVersion.SSL20Hello) {
375                 throw new SSLHandshakeException(&quot;SSLv2Hello is not enabled&quot;);
376             }
377 
378             byte majorVersion = header[3];
379             byte minorVersion = header[4];
380 
381             if ((majorVersion == ProtocolVersion.SSL20Hello.major) &amp;&amp;
382                 (minorVersion == ProtocolVersion.SSL20Hello.minor)) {
383 
384                 /*
385                  * Looks like a V2 client hello, but not one saying
</pre>
<hr />
<pre>
387                  * error message, one that&#39;s treated as fatal by
388                  * clients (Otherwise we&#39;ll hang.)
389                  */
390                 os.write(SSLRecord.v2NoCipher);      // SSLv2Hello
391 
392                 if (SSLLogger.isOn) {
393                     if (SSLLogger.isOn(&quot;record&quot;)) {
394                          SSLLogger.fine(
395                                 &quot;Requested to negotiate unsupported SSLv2!&quot;);
396                     }
397 
398                     if (SSLLogger.isOn(&quot;packet&quot;)) {
399                         SSLLogger.fine(&quot;Raw write&quot;, SSLRecord.v2NoCipher);
400                     }
401                 }
402 
403                 throw new SSLException(&quot;Unsupported SSL v2.0 ClientHello&quot;);
404             }
405 
406             int msgLen = ((header[0] &amp; 0x7F) &lt;&lt; 8) | (header[1] &amp; 0xFF);
<span class="line-modified">407 </span>
<span class="line-modified">408             ByteBuffer destination = ByteBuffer.allocate(headerSize + msgLen);</span>
<span class="line-modified">409             destination.put(temporary, 0, headerSize);</span>
<span class="line-removed">410             msgLen -= 3;            // had read 3 bytes of content as header</span>
<span class="line-removed">411             while (msgLen &gt; 0) {</span>
<span class="line-removed">412                 int howmuch = Math.min(temporary.length, msgLen);</span>
<span class="line-removed">413                 int really = read(is, temporary, 0, howmuch);</span>
<span class="line-removed">414                 if (really &lt; 0) {</span>
<span class="line-removed">415                     throw new EOFException(&quot;SSL peer shut down incorrectly&quot;);</span>
416                 }
<span class="line-modified">417 </span>
<span class="line-modified">418                 destination.put(temporary, 0, howmuch);</span>
<span class="line-modified">419                 msgLen -= howmuch;</span>

420             }
<span class="line-modified">421             destination.flip();</span>


422 
423             /*
424              * If we can map this into a V3 ClientHello, read and
425              * hash the rest of the V2 handshake, turn it into a
426              * V3 ClientHello message, and pass it up.
427              */
<span class="line-modified">428             destination.position(2);     // exclude the header</span>
<span class="line-modified">429             handshakeHash.receive(destination);</span>
<span class="line-modified">430             destination.position(0);</span>
431 
<span class="line-modified">432             ByteBuffer converted = convertToClientHello(destination);</span>
433 
434             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
435                 SSLLogger.fine(
436                         &quot;[Converted] ClientHello&quot;, converted);
437             }
438 
439             return new Plaintext[] {
440                     new Plaintext(ContentType.HANDSHAKE.id,
441                     majorVersion, minorVersion, -1, -1L, converted)
442                 };
443         } else {
444             if (((firstByte &amp; 0x80) != 0) &amp;&amp; (thirdByte == 4)) {
445                 throw new SSLException(&quot;SSL V2.0 servers are not supported.&quot;);
446             }
447 
448             throw new SSLException(&quot;Unsupported or unrecognized SSL message&quot;);
449         }
450     }
451 
<span class="line-modified">452     // Read the exact bytes of data, otherwise, return -1.</span>
<span class="line-modified">453     private static int read(InputStream is,</span>
<span class="line-modified">454             byte[] buffer, int offset, int len) throws IOException {</span>
<span class="line-modified">455         int n = 0;</span>
<span class="line-modified">456         while (n &lt; len) {</span>
<span class="line-modified">457             int readLen = is.read(buffer, offset + n, len - n);</span>
<span class="line-modified">458             if (readLen &lt; 0) {</span>
<span class="line-removed">459                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-removed">460                     SSLLogger.fine(&quot;Raw read: EOF&quot;);</span>
<span class="line-removed">461                 }</span>
<span class="line-removed">462                 return -1;</span>
463             }













464 



465             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
<span class="line-modified">466                 ByteBuffer bb = ByteBuffer.wrap(buffer, offset + n, readLen);</span>
<span class="line-removed">467                 SSLLogger.fine(&quot;Raw read&quot;, bb);</span>
468             }
<span class="line-modified">469 </span>
<span class="line-removed">470             n += readLen;</span>
471         }
472 
<span class="line-modified">473         return n;</span>




474     }
475 
476     // Try to use up the input stream without impact the performance too much.
477     void deplete(boolean tryToRead) throws IOException {
478         int remaining = is.available();
479         if (tryToRead &amp;&amp; (remaining == 0)) {
480             // try to wait and read one byte if no buffered input
481             is.read();
482         }
483 
484         while ((remaining = is.available()) != 0) {
485             is.skip(remaining);
486         }
487     }
488 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
<span class="line-added">  3  * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.</span>
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.  Oracle designates this
  9  * particular file as subject to the &quot;Classpath&quot; exception as provided
 10  * by Oracle in the LICENSE file that accompanied this code.
 11  *
 12  * This code is distributed in the hope that it will be useful, but WITHOUT
 13  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 14  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 15  * version 2 for more details (a copy is included in the LICENSE file that
 16  * accompanied this code).
 17  *
 18  * You should have received a copy of the GNU General Public License version
 19  * 2 along with this work; if not, write to the Free Software Foundation,
 20  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 21  *
 22  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 23  * or visit www.oracle.com if you need additional information or have any
 24  * questions.
 25  */
 26 
 27 package sun.security.ssl;
 28 
 29 import java.io.EOFException;
<span class="line-added"> 30 import java.io.InterruptedIOException;</span>
 31 import java.io.IOException;
 32 import java.io.InputStream;
 33 import java.io.OutputStream;
 34 import java.nio.ByteBuffer;
 35 import java.security.GeneralSecurityException;
 36 import java.util.ArrayList;
 37 import javax.crypto.BadPaddingException;
 38 import javax.net.ssl.SSLException;
 39 import javax.net.ssl.SSLHandshakeException;
 40 import javax.net.ssl.SSLProtocolException;
 41 
 42 import sun.security.ssl.SSLCipher.SSLReadCipher;
 43 
 44 /**
 45  * {@code InputRecord} implementation for {@code SSLSocket}.
 46  *
 47  * @author David Brownell
 48  */
 49 final class SSLSocketInputRecord extends InputRecord implements SSLRecord {
 50     private InputStream is = null;
 51     private OutputStream os = null;
<span class="line-modified"> 52     private final byte[] header = new byte[headerSize];</span>
<span class="line-added"> 53     private int headerOff = 0;</span>
<span class="line-added"> 54     // Cache for incomplete record body.</span>
<span class="line-added"> 55     private ByteBuffer recordBody = ByteBuffer.allocate(1024);</span>
 56 
 57     private boolean formatVerified = false;     // SSLv2 ruled out?
 58 
 59     // Cache for incomplete handshake messages.
 60     private ByteBuffer handshakeBuffer = null;
 61 


 62     SSLSocketInputRecord(HandshakeHash handshakeHash) {
 63         super(handshakeHash, SSLReadCipher.nullTlsReadCipher());
 64     }
 65 
 66     @Override
 67     int bytesInCompletePacket() throws IOException {
<span class="line-modified"> 68         // read header</span>
<span class="line-modified"> 69         try {</span>
<span class="line-modified"> 70             readHeader();</span>
<span class="line-modified"> 71         } catch (EOFException eofe) {</span>
<span class="line-modified"> 72             // The caller will handle EOF.</span>
<span class="line-modified"> 73             return -1;</span>







 74         }
 75 
<span class="line-modified"> 76         byte byteZero = header[0];</span>
 77         int len = 0;
 78 
 79         /*
 80          * If we have already verified previous packets, we can
 81          * ignore the verifications steps, and jump right to the
 82          * determination.  Otherwise, try one last heuristic to
 83          * see if it&#39;s SSL/TLS.
 84          */
 85         if (formatVerified ||
 86                 (byteZero == ContentType.HANDSHAKE.id) ||
 87                 (byteZero == ContentType.ALERT.id)) {
 88             /*
 89              * Last sanity check that it&#39;s not a wild record
 90              */
 91             if (!ProtocolVersion.isNegotiable(
<span class="line-modified"> 92                     header[1], header[2], false, false)) {</span>
 93                 throw new SSLException(&quot;Unrecognized record version &quot; +
<span class="line-modified"> 94                         ProtocolVersion.nameOf(header[1], header[2]) +</span>
 95                         &quot; , plaintext connection?&quot;);
 96             }
 97 
 98             /*
 99              * Reasonably sure this is a V3, disable further checks.
100              * We can&#39;t do the same in the v2 check below, because
101              * read still needs to parse/handle the v2 clientHello.
102              */
103             formatVerified = true;
104 
105             /*
106              * One of the SSLv3/TLS message types.
107              */
<span class="line-modified">108             len = ((header[3] &amp; 0xFF) &lt;&lt; 8) +</span>
<span class="line-modified">109                     (header[4] &amp; 0xFF) + headerSize;</span>
110         } else {
111             /*
112              * Must be SSLv2 or something unknown.
113              * Check if it&#39;s short (2 bytes) or
114              * long (3) header.
115              *
116              * Internals can warn about unsupported SSLv2
117              */
118             boolean isShort = ((byteZero &amp; 0x80) != 0);
119 
<span class="line-modified">120             if (isShort &amp;&amp; ((header[2] == 1) || (header[2] == 4))) {</span>
121                 if (!ProtocolVersion.isNegotiable(
<span class="line-modified">122                         header[3], header[4], false, false)) {</span>
123                     throw new SSLException(&quot;Unrecognized record version &quot; +
<span class="line-modified">124                             ProtocolVersion.nameOf(header[3], header[4]) +</span>
125                             &quot; , plaintext connection?&quot;);
126                 }
127 
128                 /*
129                  * Client or Server Hello
130                  */
131                 //
132                 // Short header is using here.  We reverse the code here
133                 // in case it is used in the future.
134                 //
135                 // int mask = (isShort ? 0x7F : 0x3F);
136                 // len = ((byteZero &amp; mask) &lt;&lt; 8) +
<span class="line-modified">137                 //        (header[1] &amp; 0xFF) + (isShort ? 2 : 3);</span>
138                 //
<span class="line-modified">139                 len = ((byteZero &amp; 0x7F) &lt;&lt; 8) + (header[1] &amp; 0xFF) + 2;</span>
140             } else {
141                 // Gobblygook!
142                 throw new SSLException(
143                         &quot;Unrecognized SSL message, plaintext connection?&quot;);
144             }
145         }
146 
147         return len;
148     }
149 
150     // Note that the input arguments are not used actually.
151     @Override
152     Plaintext[] decode(ByteBuffer[] srcs, int srcsOffset,
153             int srcsLength) throws IOException, BadPaddingException {
154 
155         if (isClosed) {
156             return null;
157         }
158 
<span class="line-modified">159         // read header</span>
<span class="line-modified">160         readHeader();</span>






161 
<span class="line-modified">162         Plaintext[] plaintext = null;</span>
<span class="line-modified">163         boolean cleanInBuffer = true;</span>
<span class="line-modified">164         try {</span>
<span class="line-added">165             if (!formatVerified) {</span>
<span class="line-added">166                 formatVerified = true;</span>
167 
<span class="line-modified">168                 /*</span>
<span class="line-modified">169                  * The first record must either be a handshake record or an</span>
<span class="line-modified">170                  * alert message. If it&#39;s not, it is either invalid or an</span>
<span class="line-modified">171                  * SSLv2 message.</span>
<span class="line-modified">172                  */</span>
<span class="line-modified">173                 if ((header[0] != ContentType.HANDSHAKE.id) &amp;&amp;</span>
<span class="line-modified">174                         (header[0] != ContentType.ALERT.id)) {</span>
<span class="line-modified">175                     plaintext = handleUnknownRecord();</span>
<span class="line-modified">176                 }</span>
177             }

178 
<span class="line-modified">179             // The record header should has consumed.</span>
<span class="line-modified">180             if (plaintext == null) {</span>
<span class="line-modified">181                 plaintext = decodeInputRecord();</span>
<span class="line-added">182             }</span>
<span class="line-added">183         } catch(InterruptedIOException e) {</span>
<span class="line-added">184             // do not clean header and recordBody in case of Socket Timeout</span>
<span class="line-added">185             cleanInBuffer = false;</span>
<span class="line-added">186             throw e;</span>
<span class="line-added">187         } finally {</span>
<span class="line-added">188             if (cleanInBuffer) {</span>
<span class="line-added">189                 headerOff = 0;</span>
<span class="line-added">190                 recordBody.clear();</span>
<span class="line-added">191             }</span>
<span class="line-added">192         }</span>
<span class="line-added">193         return plaintext;</span>
194     }
195 
196     @Override
197     void setReceiverStream(InputStream inputStream) {
198         this.is = inputStream;
199     }
200 
201     @Override
202     void setDeliverStream(OutputStream outputStream) {
203         this.os = outputStream;
204     }
205 
<span class="line-modified">206     private Plaintext[] decodeInputRecord() throws IOException, BadPaddingException {</span>


207         byte contentType = header[0];                   // pos: 0
208         byte majorVersion = header[1];                  // pos: 1
209         byte minorVersion = header[2];                  // pos: 2
210         int contentLen = ((header[3] &amp; 0xFF) &lt;&lt; 8) +
211                            (header[4] &amp; 0xFF);          // pos: 3, 4
212 
213         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
214             SSLLogger.fine(
215                     &quot;READ: &quot; +
216                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
217                     &quot; &quot; + ContentType.nameOf(contentType) + &quot;, length = &quot; +
218                     contentLen);
219         }
220 
221         //
222         // Check for upper bound.
223         //
224         // Note: May check packetSize limit in the future.
225         if (contentLen &lt; 0 || contentLen &gt; maxLargeRecordSize - headerSize) {
226             throw new SSLProtocolException(
227                 &quot;Bad input record size, TLSCiphertext.length = &quot; + contentLen);
228         }
229 
230         //
<span class="line-modified">231         // Read a complete record and store in the recordBody</span>
<span class="line-added">232         // recordBody is used to cache incoming record and restore in case of</span>
<span class="line-added">233         // read operation timedout</span>
234         //
<span class="line-modified">235         if (recordBody.position() == 0) {</span>
<span class="line-modified">236             if (recordBody.capacity() &lt; contentLen) {</span>
<span class="line-modified">237                 recordBody = ByteBuffer.allocate(contentLen);</span>





238             }
<span class="line-modified">239             recordBody.limit(contentLen);</span>
<span class="line-modified">240         } else {</span>
<span class="line-modified">241             contentLen = recordBody.remaining();</span>
242         }
<span class="line-modified">243         readFully(contentLen);</span>
<span class="line-modified">244         recordBody.flip();</span>
245 
246         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;record&quot;)) {
247             SSLLogger.fine(
248                     &quot;READ: &quot; +
249                     ProtocolVersion.nameOf(majorVersion, minorVersion) +
250                     &quot; &quot; + ContentType.nameOf(contentType) + &quot;, length = &quot; +
<span class="line-modified">251                     recordBody.remaining());</span>
252         }
253 
254         //
255         // Decrypt the fragment
256         //
257         ByteBuffer fragment;
258         try {
259             Plaintext plaintext =
<span class="line-modified">260                     readCipher.decrypt(contentType, recordBody, null);</span>
261             fragment = plaintext.fragment;
262             contentType = plaintext.contentType;
263         } catch (BadPaddingException bpe) {
264             throw bpe;
265         } catch (GeneralSecurityException gse) {
266             throw (SSLProtocolException)(new SSLProtocolException(
267                     &quot;Unexpected exception&quot;)).initCause(gse);
268         }
269 
270         if (contentType != ContentType.HANDSHAKE.id &amp;&amp;
271                 handshakeBuffer != null &amp;&amp; handshakeBuffer.hasRemaining()) {
272             throw new SSLProtocolException(
273                     &quot;Expecting a handshake fragment, but received &quot; +
274                     ContentType.nameOf(contentType));
275         }
276 
277         //
278         // parse handshake messages
279         //
280         if (contentType == ContentType.HANDSHAKE.id) {
</pre>
<hr />
<pre>
342 
343                     plaintexts.add(
344                         new Plaintext(contentType, majorVersion, minorVersion,
345                             -1, -1L, handshakeFrag.slice())
346                     );
347 
348                     handshakeFrag.position(nextPos);
349                     handshakeFrag.limit(fragLim);
350                 }
351             }
352 
353             return plaintexts.toArray(new Plaintext[0]);
354         }
355 
356         return new Plaintext[] {
357                 new Plaintext(contentType,
358                     majorVersion, minorVersion, -1, -1L, fragment)
359             };
360     }
361 
<span class="line-modified">362     private Plaintext[] handleUnknownRecord() throws IOException, BadPaddingException {</span>

363         byte firstByte = header[0];
364         byte thirdByte = header[2];
365 
366         // Does it look like a Version 2 client hello (V2ClientHello)?
367         if (((firstByte &amp; 0x80) != 0) &amp;&amp; (thirdByte == 1)) {
368             /*
369              * If SSLv2Hello is not enabled, throw an exception.
370              */
371             if (helloVersion != ProtocolVersion.SSL20Hello) {
372                 throw new SSLHandshakeException(&quot;SSLv2Hello is not enabled&quot;);
373             }
374 
375             byte majorVersion = header[3];
376             byte minorVersion = header[4];
377 
378             if ((majorVersion == ProtocolVersion.SSL20Hello.major) &amp;&amp;
379                 (minorVersion == ProtocolVersion.SSL20Hello.minor)) {
380 
381                 /*
382                  * Looks like a V2 client hello, but not one saying
</pre>
<hr />
<pre>
384                  * error message, one that&#39;s treated as fatal by
385                  * clients (Otherwise we&#39;ll hang.)
386                  */
387                 os.write(SSLRecord.v2NoCipher);      // SSLv2Hello
388 
389                 if (SSLLogger.isOn) {
390                     if (SSLLogger.isOn(&quot;record&quot;)) {
391                          SSLLogger.fine(
392                                 &quot;Requested to negotiate unsupported SSLv2!&quot;);
393                     }
394 
395                     if (SSLLogger.isOn(&quot;packet&quot;)) {
396                         SSLLogger.fine(&quot;Raw write&quot;, SSLRecord.v2NoCipher);
397                     }
398                 }
399 
400                 throw new SSLException(&quot;Unsupported SSL v2.0 ClientHello&quot;);
401             }
402 
403             int msgLen = ((header[0] &amp; 0x7F) &lt;&lt; 8) | (header[1] &amp; 0xFF);
<span class="line-modified">404             if (recordBody.position() == 0) {</span>
<span class="line-modified">405                 if (recordBody.capacity() &lt; (headerSize + msgLen)) {</span>
<span class="line-modified">406                     recordBody = ByteBuffer.allocate(headerSize + msgLen);</span>






407                 }
<span class="line-modified">408                 recordBody.limit(headerSize + msgLen);</span>
<span class="line-modified">409                 recordBody.put(header, 0, headerSize);</span>
<span class="line-modified">410             } else {</span>
<span class="line-added">411                 msgLen = recordBody.remaining();</span>
412             }
<span class="line-modified">413             msgLen -= 3;            // had read 3 bytes of content as header</span>
<span class="line-added">414             readFully(msgLen);</span>
<span class="line-added">415             recordBody.flip();</span>
416 
417             /*
418              * If we can map this into a V3 ClientHello, read and
419              * hash the rest of the V2 handshake, turn it into a
420              * V3 ClientHello message, and pass it up.
421              */
<span class="line-modified">422             recordBody.position(2);     // exclude the header</span>
<span class="line-modified">423             handshakeHash.receive(recordBody);</span>
<span class="line-modified">424             recordBody.position(0);</span>
425 
<span class="line-modified">426             ByteBuffer converted = convertToClientHello(recordBody);</span>
427 
428             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
429                 SSLLogger.fine(
430                         &quot;[Converted] ClientHello&quot;, converted);
431             }
432 
433             return new Plaintext[] {
434                     new Plaintext(ContentType.HANDSHAKE.id,
435                     majorVersion, minorVersion, -1, -1L, converted)
436                 };
437         } else {
438             if (((firstByte &amp; 0x80) != 0) &amp;&amp; (thirdByte == 4)) {
439                 throw new SSLException(&quot;SSL V2.0 servers are not supported.&quot;);
440             }
441 
442             throw new SSLException(&quot;Unsupported or unrecognized SSL message&quot;);
443         }
444     }
445 
<span class="line-modified">446     // Read the exact bytes of data, otherwise, throw IOException.</span>
<span class="line-modified">447     private int readFully(int len) throws IOException {</span>
<span class="line-modified">448         int end = len + recordBody.position();</span>
<span class="line-modified">449         int off = recordBody.position();</span>
<span class="line-modified">450         try {</span>
<span class="line-modified">451             while (off &lt; end) {</span>
<span class="line-modified">452                 off += read(is, recordBody.array(), off, end - off);</span>




453             }
<span class="line-added">454         } finally {</span>
<span class="line-added">455             recordBody.position(off);</span>
<span class="line-added">456         }</span>
<span class="line-added">457         return len;</span>
<span class="line-added">458     }</span>
<span class="line-added">459 </span>
<span class="line-added">460     // Read SSE record header, otherwise, throw IOException.</span>
<span class="line-added">461     private int readHeader() throws IOException {</span>
<span class="line-added">462         while (headerOff &lt; headerSize) {</span>
<span class="line-added">463             headerOff += read(is, header, headerOff, headerSize - headerOff);</span>
<span class="line-added">464         }</span>
<span class="line-added">465         return headerSize;</span>
<span class="line-added">466     }</span>
467 
<span class="line-added">468     private static int read(InputStream is, byte[] buf, int off, int len)  throws IOException {</span>
<span class="line-added">469         int readLen = is.read(buf, off, len);</span>
<span class="line-added">470         if (readLen &lt; 0) {</span>
471             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {
<span class="line-modified">472                 SSLLogger.fine(&quot;Raw read: EOF&quot;);</span>

473             }
<span class="line-modified">474             throw new EOFException(&quot;SSL peer shut down incorrectly&quot;);</span>

475         }
476 
<span class="line-modified">477         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;packet&quot;)) {</span>
<span class="line-added">478             ByteBuffer bb = ByteBuffer.wrap(buf, off, readLen);</span>
<span class="line-added">479             SSLLogger.fine(&quot;Raw read&quot;, bb);</span>
<span class="line-added">480         }</span>
<span class="line-added">481         return readLen;</span>
482     }
483 
484     // Try to use up the input stream without impact the performance too much.
485     void deplete(boolean tryToRead) throws IOException {
486         int remaining = is.available();
487         if (tryToRead &amp;&amp; (remaining == 0)) {
488             // try to wait and read one byte if no buffered input
489             is.read();
490         }
491 
492         while ((remaining = is.available()) != 0) {
493             is.skip(remaining);
494         }
495     }
496 }
</pre>
</td>
</tr>
</table>
<center><a href="SSLSocketImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLTransport.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
299      * {@code float}, or {@code double}, or is not a primitive type.
300      */
301     public static VarHandle asAddressVarHandle(VarHandle target) {
302         Class&lt;?&gt; carrier = target.varType();
303         if (!carrier.isPrimitive() || carrier == boolean.class ||
304                 carrier == float.class || carrier == double.class) {
305             throw new IllegalArgumentException(&quot;Unsupported carrier type: &quot; + carrier.getName());
306         }
307 
308         if (carrier != long.class) {
309             // slow-path, we need to adapt
310             return filterValue(target,
311                     MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
312                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
313         } else {
314             // fast-path
315             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
316         }
317     }
318 















































319     /**
320      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
321      * &lt;p&gt;
322      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
323      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
324      * to the target var handle.
325      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
326      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
327      * is processed using the second filter and returned to the caller. More advanced access mode types, such as
328      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
329      * &lt;p&gt;
330      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},
331      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
332      * have type {@code S}.
333      * &lt;p&gt;
334      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
335      * atomic access guarantees as those featured by the target var handle.
336      *
337      * @param target the target var handle
338      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
</pre>
</td>
<td>
<hr />
<pre>
299      * {@code float}, or {@code double}, or is not a primitive type.
300      */
301     public static VarHandle asAddressVarHandle(VarHandle target) {
302         Class&lt;?&gt; carrier = target.varType();
303         if (!carrier.isPrimitive() || carrier == boolean.class ||
304                 carrier == float.class || carrier == double.class) {
305             throw new IllegalArgumentException(&quot;Unsupported carrier type: &quot; + carrier.getName());
306         }
307 
308         if (carrier != long.class) {
309             // slow-path, we need to adapt
310             return filterValue(target,
311                     MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
312                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
313         } else {
314             // fast-path
315             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
316         }
317     }
318 
<span class="line-added">319     /**</span>
<span class="line-added">320      * Adapts a target var handle by narrowing incoming values and widening</span>
<span class="line-added">321      * outgoing values, to and from the given type, respectively.</span>
<span class="line-added">322      * &lt;p&gt;</span>
<span class="line-added">323      * The returned var handle can be used to conveniently treat unsigned</span>
<span class="line-added">324      * primitive data types as if they were a wider signed primitive type. For</span>
<span class="line-added">325      * example, it is often convenient to model an &lt;i&gt;unsigned short&lt;/i&gt; as a</span>
<span class="line-added">326      * Java {@code int} to avoid dealing with negative values, which would be</span>
<span class="line-added">327      * the case if modeled as a Java {@code short}. The returned var handle</span>
<span class="line-added">328      * converts to and from wider primitive types, to a more narrow possibly</span>
<span class="line-added">329      * unsigned primitive type.</span>
<span class="line-added">330      * &lt;p&gt;</span>
<span class="line-added">331      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var</span>
<span class="line-added">332      * handle, the incoming value (of type {@code adaptedType}) is converted by a</span>
<span class="line-added">333      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; and then passed to the {@code</span>
<span class="line-added">334      * target} var handle. A narrowing primitive conversion may lose information</span>
<span class="line-added">335      * about the overall magnitude of a numeric value. Conversely, when calling</span>
<span class="line-added">336      * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the</span>
<span class="line-added">337      * returned value obtained from the {@code target} var handle is converted</span>
<span class="line-added">338      * by a &lt;i&gt;unsigned widening conversion&lt;/i&gt; before being returned to the</span>
<span class="line-added">339      * caller. In an unsigned widening conversion the high-order bits greater</span>
<span class="line-added">340      * than that of the {@code target} carrier type are zero, and the low-order</span>
<span class="line-added">341      * bits (equal to the width of the {@code target} carrier type) are equal to</span>
<span class="line-added">342      * the bits of the value obtained from the {@code target} var handle.</span>
<span class="line-added">343      * &lt;p&gt;</span>
<span class="line-added">344      * The returned var handle will feature the variable type {@code adaptedType},</span>
<span class="line-added">345      * and the same access coordinates, the same access modes (see {@link</span>
<span class="line-added">346      * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access</span>
<span class="line-added">347      * guarantees, as those featured by the {@code target} var handle.</span>
<span class="line-added">348      *</span>
<span class="line-added">349      * @param target the memory access var handle to be adapted</span>
<span class="line-added">350      * @param adaptedType the adapted type</span>
<span class="line-added">351      * @returns the adapted var handle.</span>
<span class="line-added">352      * @throws IllegalArgumentException if the carrier type of {@code target}</span>
<span class="line-added">353      * is not one of {@code byte}, {@code short}, or {@code int}; if {@code</span>
<span class="line-added">354      * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth</span>
<span class="line-added">355      * of the {@code adaptedType} is not greater than that of the {@code target}</span>
<span class="line-added">356      * carrier type</span>
<span class="line-added">357      * @throws NullPointerException if either of {@code target} or {@code</span>
<span class="line-added">358      * adaptedType} is null</span>
<span class="line-added">359      *</span>
<span class="line-added">360      * @jls 5.1.3 Narrowing Primitive Conversion</span>
<span class="line-added">361      */</span>
<span class="line-added">362     public static VarHandle asUnsigned(VarHandle target, final Class&lt;?&gt; adaptedType) {</span>
<span class="line-added">363         return JLI.asUnsigned(target, adaptedType);</span>
<span class="line-added">364     }</span>
<span class="line-added">365 </span>
366     /**
367      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
368      * &lt;p&gt;
369      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
370      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
371      * to the target var handle.
372      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
373      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
374      * is processed using the second filter and returned to the caller. More advanced access mode types, such as
375      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
376      * &lt;p&gt;
377      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},
378      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
379      * have type {@code S}.
380      * &lt;p&gt;
381      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
382      * atomic access guarantees as those featured by the target var handle.
383      *
384      * @param target the target var handle
385      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../java.base/share/classes/jdk/internal/access/JavaLangInvokeAccess.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
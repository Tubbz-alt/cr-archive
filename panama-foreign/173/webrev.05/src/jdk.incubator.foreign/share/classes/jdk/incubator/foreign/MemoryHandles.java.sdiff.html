<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.access.JavaLangInvokeAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.foreign.Utils;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;

 39 
 40 /**
 41  * This class defines several factory methods for constructing and combining memory access var handles.
 42  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 43  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 44  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 45  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 46  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 47  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
 48  * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate
 49  * multi-dimensional array indexing.
 50  * &lt;p&gt;
 51  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
 52  * &lt;blockquote&gt;&lt;pre&gt;{@code
 53 SequenceLayout seq = MemoryLayout.ofSequence(5,
 54     MemoryLayout.ofStruct(
 55         MemoryLayout.ofPaddingBits(32),
 56         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
 57     ));
 58  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
115  * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the
116  * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,
117  * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.
118  * &lt;p&gt;
119  * Finally, in all other cases, we say that a memory access operation is &lt;em&gt;misaligned&lt;/em&gt;; in such cases an
120  * {@code IllegalStateException} is thrown, irrespective of the access mode being used.
121  */
122 public final class MemoryHandles {
123 
124     private final static JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
125 
126     private MemoryHandles() {
127         //sorry, just the one!
128     }
129 
130     private static final MethodHandle LONG_TO_ADDRESS;
131     private static final MethodHandle ADDRESS_TO_LONG;
132     private static final MethodHandle ADD_OFFSET;
133     private static final MethodHandle ADD_STRIDE;
134 











135     static {
136         try {
137             LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;longToAddress&quot;,
138                     MethodType.methodType(MemoryAddress.class, long.class));
139             ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addressToLong&quot;,
140                     MethodType.methodType(long.class, MemoryAddress.class));
141             ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addOffset&quot;,
142                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
143 
144             ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addStride&quot;,
145                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));





















146         } catch (Throwable ex) {
147             throw new ExceptionInInitializerError(ex);
148         }
149     }
150 
151     /**
152      * Creates a memory access var handle with the given carrier type and byte order.
153      *
154      * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
155      * and its variable type is set by the given carrier type.
156      *
157      * The alignment constraint for the resulting memory access var handle is the same as the in memory size of the
158      * carrier type, and the accessed offset is set at zero.
159      *
160      * @apiNote the resulting var handle features certain &lt;a href=&quot;#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;,
161      * which are common to all memory access var handles.
162      *
163      * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},
164      * {@code float}, {@code long}, and {@code double}.
165      * @param byteOrder the required byte order.
</pre>
<hr />
<pre>
299      * {@code float}, or {@code double}, or is not a primitive type.
300      */
301     public static VarHandle asAddressVarHandle(VarHandle target) {
302         Class&lt;?&gt; carrier = target.varType();
303         if (!carrier.isPrimitive() || carrier == boolean.class ||
304                 carrier == float.class || carrier == double.class) {
305             throw new IllegalArgumentException(&quot;Unsupported carrier type: &quot; + carrier.getName());
306         }
307 
308         if (carrier != long.class) {
309             // slow-path, we need to adapt
310             return filterValue(target,
311                     MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
312                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
313         } else {
314             // fast-path
315             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
316         }
317     }
318 


































































319     /**
320      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
321      * &lt;p&gt;
322      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
323      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
324      * to the target var handle.
325      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
326      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
327      * is processed using the second filter and returned to the caller. More advanced access mode types, such as
328      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
329      * &lt;p&gt;
330      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},
331      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
332      * have type {@code S}.
333      * &lt;p&gt;
334      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
335      * atomic access guarantees as those featured by the target var handle.
336      *
337      * @param target the target var handle
338      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
</pre>
<hr />
<pre>
515     }
516 
517     private static void checkAddressFirstCoordinate(VarHandle handle) {
518         if (handle.coordinateTypes().size() &lt; 1 ||
519                 handle.coordinateTypes().get(0) != MemoryAddress.class) {
520             throw new IllegalArgumentException(&quot;Expected var handle with leading coordinate of type MemoryAddress&quot;);
521         }
522     }
523 
524     private static void checkCarrier(Class&lt;?&gt; carrier) {
525         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
526             throw new IllegalArgumentException(&quot;Illegal carrier: &quot; + carrier.getSimpleName());
527         }
528     }
529 
530     private static long carrierSize(Class&lt;?&gt; carrier) {
531         long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
532         return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
533     }
534 



















535     private static MemoryAddress longToAddress(long value) {
536         return MemoryAddress.ofLong(value);
537     }
538 
539     private static long addressToLong(MemoryAddress value) {
540         return value.toRawLongValue();
541     }
542 
543     private static MemoryAddress addOffset(MemoryAddress address, long offset) {
544         return address.addOffset(offset);
545     }
546 
547     private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
548         return address.addOffset(index * stride);
549     }
550 }
</pre>
</td>
<td>
<hr />
<pre>
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.access.JavaLangInvokeAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.foreign.Utils;
 31 import sun.invoke.util.Wrapper;
 32 
 33 import java.lang.invoke.MethodHandle;
 34 import java.lang.invoke.MethodHandles;
 35 import java.lang.invoke.MethodType;
 36 import java.lang.invoke.VarHandle;
 37 import java.nio.ByteOrder;
 38 import java.util.List;
<span class="line-added"> 39 import java.util.Objects;</span>
 40 
 41 /**
 42  * This class defines several factory methods for constructing and combining memory access var handles.
 43  * To obtain a memory access var handle, clients must start from one of the &lt;em&gt;leaf&lt;/em&gt; methods
 44  * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},
 45  * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type
 46  * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the
 47  * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways
 48  * to emulate different addressing modes. The var handles created by this class feature a &lt;em&gt;mandatory&lt;/em&gt; coordinate type
 49  * (of type {@link MemoryAddress}), and zero or more {@code long} coordinate types, which can be used to emulate
 50  * multi-dimensional array indexing.
 51  * &lt;p&gt;
 52  * As an example, consider the memory layout expressed by a {@link SequenceLayout} instance constructed as follows:
 53  * &lt;blockquote&gt;&lt;pre&gt;{@code
 54 SequenceLayout seq = MemoryLayout.ofSequence(5,
 55     MemoryLayout.ofStruct(
 56         MemoryLayout.ofPaddingBits(32),
 57         MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(&quot;value&quot;)
 58     ));
 59  * }&lt;/pre&gt;&lt;/blockquote&gt;
</pre>
<hr />
<pre>
116  * which is only compatible with the alignment constraint {@code B}; in such cases, access for anything other than the
117  * {@code get} and {@code set} access modes will result in an {@code IllegalStateException}. If access is partially aligned,
118  * atomic access is only guaranteed with respect to the largest power of two that divides the GCD of {@code A} and {@code S}.
119  * &lt;p&gt;
120  * Finally, in all other cases, we say that a memory access operation is &lt;em&gt;misaligned&lt;/em&gt;; in such cases an
121  * {@code IllegalStateException} is thrown, irrespective of the access mode being used.
122  */
123 public final class MemoryHandles {
124 
125     private final static JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();
126 
127     private MemoryHandles() {
128         //sorry, just the one!
129     }
130 
131     private static final MethodHandle LONG_TO_ADDRESS;
132     private static final MethodHandle ADDRESS_TO_LONG;
133     private static final MethodHandle ADD_OFFSET;
134     private static final MethodHandle ADD_STRIDE;
135 
<span class="line-added">136     private static final MethodHandle INT_TO_BYTE;</span>
<span class="line-added">137     private static final MethodHandle BYTE_TO_UNSIGNED_INT;</span>
<span class="line-added">138     private static final MethodHandle INT_TO_SHORT;</span>
<span class="line-added">139     private static final MethodHandle SHORT_TO_UNSIGNED_INT;</span>
<span class="line-added">140     private static final MethodHandle LONG_TO_BYTE;</span>
<span class="line-added">141     private static final MethodHandle BYTE_TO_UNSIGNED_LONG;</span>
<span class="line-added">142     private static final MethodHandle LONG_TO_SHORT;</span>
<span class="line-added">143     private static final MethodHandle SHORT_TO_UNSIGNED_LONG;</span>
<span class="line-added">144     private static final MethodHandle LONG_TO_INT;</span>
<span class="line-added">145     private static final MethodHandle INT_TO_UNSIGNED_LONG;</span>
<span class="line-added">146 </span>
147     static {
148         try {
149             LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;longToAddress&quot;,
150                     MethodType.methodType(MemoryAddress.class, long.class));
151             ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addressToLong&quot;,
152                     MethodType.methodType(long.class, MemoryAddress.class));
153             ADD_OFFSET = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addOffset&quot;,
154                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class));
155 
156             ADD_STRIDE = MethodHandles.lookup().findStatic(MemoryHandles.class, &quot;addStride&quot;,
157                     MethodType.methodType(MemoryAddress.class, MemoryAddress.class, long.class, long.class));
<span class="line-added">158 </span>
<span class="line-added">159             INT_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),</span>
<span class="line-added">160                     MethodType.methodType(byte.class, int.class));</span>
<span class="line-added">161             BYTE_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Byte.class, &quot;toUnsignedInt&quot;,</span>
<span class="line-added">162                     MethodType.methodType(int.class, byte.class));</span>
<span class="line-added">163             INT_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),</span>
<span class="line-added">164                     MethodType.methodType(short.class, int.class));</span>
<span class="line-added">165             SHORT_TO_UNSIGNED_INT = MethodHandles.lookup().findStatic(Short.class, &quot;toUnsignedInt&quot;,</span>
<span class="line-added">166                     MethodType.methodType(int.class, short.class));</span>
<span class="line-added">167             LONG_TO_BYTE = MethodHandles.explicitCastArguments(MethodHandles.identity(byte.class),</span>
<span class="line-added">168                     MethodType.methodType(byte.class, long.class));</span>
<span class="line-added">169             BYTE_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Byte.class, &quot;toUnsignedLong&quot;,</span>
<span class="line-added">170                     MethodType.methodType(long.class, byte.class));</span>
<span class="line-added">171             LONG_TO_SHORT = MethodHandles.explicitCastArguments(MethodHandles.identity(short.class),</span>
<span class="line-added">172                     MethodType.methodType(short.class, long.class));</span>
<span class="line-added">173             SHORT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Short.class, &quot;toUnsignedLong&quot;,</span>
<span class="line-added">174                     MethodType.methodType(long.class, short.class));</span>
<span class="line-added">175             LONG_TO_INT = MethodHandles.explicitCastArguments(MethodHandles.identity(int.class),</span>
<span class="line-added">176                     MethodType.methodType(int.class, long.class));</span>
<span class="line-added">177             INT_TO_UNSIGNED_LONG = MethodHandles.lookup().findStatic(Integer.class, &quot;toUnsignedLong&quot;,</span>
<span class="line-added">178                     MethodType.methodType(long.class, int.class));</span>
179         } catch (Throwable ex) {
180             throw new ExceptionInInitializerError(ex);
181         }
182     }
183 
184     /**
185      * Creates a memory access var handle with the given carrier type and byte order.
186      *
187      * The resulting memory access var handle features a single {@link MemoryAddress} access coordinate,
188      * and its variable type is set by the given carrier type.
189      *
190      * The alignment constraint for the resulting memory access var handle is the same as the in memory size of the
191      * carrier type, and the accessed offset is set at zero.
192      *
193      * @apiNote the resulting var handle features certain &lt;a href=&quot;#memaccess-mode&quot;&gt;access mode restrictions&lt;/a&gt;,
194      * which are common to all memory access var handles.
195      *
196      * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},
197      * {@code float}, {@code long}, and {@code double}.
198      * @param byteOrder the required byte order.
</pre>
<hr />
<pre>
332      * {@code float}, or {@code double}, or is not a primitive type.
333      */
334     public static VarHandle asAddressVarHandle(VarHandle target) {
335         Class&lt;?&gt; carrier = target.varType();
336         if (!carrier.isPrimitive() || carrier == boolean.class ||
337                 carrier == float.class || carrier == double.class) {
338             throw new IllegalArgumentException(&quot;Unsupported carrier type: &quot; + carrier.getName());
339         }
340 
341         if (carrier != long.class) {
342             // slow-path, we need to adapt
343             return filterValue(target,
344                     MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),
345                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
346         } else {
347             // fast-path
348             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
349         }
350     }
351 
<span class="line-added">352     /**</span>
<span class="line-added">353      * Adapts a target var handle by narrowing incoming values and widening</span>
<span class="line-added">354      * outgoing values, to and from the given type, respectively.</span>
<span class="line-added">355      * &lt;p&gt;</span>
<span class="line-added">356      * The returned var handle can be used to conveniently treat unsigned</span>
<span class="line-added">357      * primitive data types as if they were a wider signed primitive type. For</span>
<span class="line-added">358      * example, it is often convenient to model an &lt;i&gt;unsigned short&lt;/i&gt; as a</span>
<span class="line-added">359      * Java {@code int} to avoid dealing with negative values, which would be</span>
<span class="line-added">360      * the case if modeled as a Java {@code short}. The returned var handle</span>
<span class="line-added">361      * converts to and from wider primitive types, to a more narrow possibly</span>
<span class="line-added">362      * unsigned primitive type.</span>
<span class="line-added">363      * &lt;p&gt;</span>
<span class="line-added">364      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var</span>
<span class="line-added">365      * handle, the incoming value (of type {@code adaptedType}) is converted by a</span>
<span class="line-added">366      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; and then passed to the {@code</span>
<span class="line-added">367      * target} var handle. A narrowing primitive conversion may lose information</span>
<span class="line-added">368      * about the overall magnitude of a numeric value. Conversely, when calling</span>
<span class="line-added">369      * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the</span>
<span class="line-added">370      * returned value obtained from the {@code target} var handle is converted</span>
<span class="line-added">371      * by a &lt;i&gt;unsigned widening conversion&lt;/i&gt; before being returned to the</span>
<span class="line-added">372      * caller. In an unsigned widening conversion the high-order bits greater</span>
<span class="line-added">373      * than that of the {@code target} carrier type are zero, and the low-order</span>
<span class="line-added">374      * bits (equal to the width of the {@code target} carrier type) are equal to</span>
<span class="line-added">375      * the bits of the value obtained from the {@code target} var handle.</span>
<span class="line-added">376      * &lt;p&gt;</span>
<span class="line-added">377      * The returned var handle will feature the variable type {@code adaptedType},</span>
<span class="line-added">378      * and the same access coordinates, the same access modes (see {@link</span>
<span class="line-added">379      * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access</span>
<span class="line-added">380      * guarantees, as those featured by the {@code target} var handle.</span>
<span class="line-added">381      *</span>
<span class="line-added">382      * @param target the memory access var handle to be adapted</span>
<span class="line-added">383      * @param adaptedType the adapted type</span>
<span class="line-added">384      * @returns the adapted var handle.</span>
<span class="line-added">385      * @throws IllegalArgumentException if the carrier type of {@code target}</span>
<span class="line-added">386      * is not one of {@code byte}, {@code short}, or {@code int}; if {@code</span>
<span class="line-added">387      * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth</span>
<span class="line-added">388      * of the {@code adaptedType} is not greater than that of the {@code target}</span>
<span class="line-added">389      * carrier type</span>
<span class="line-added">390      * @throws NullPointerException if either of {@code target} or {@code</span>
<span class="line-added">391      * adaptedType} is null</span>
<span class="line-added">392      *</span>
<span class="line-added">393      * @jls 5.1.3 Narrowing Primitive Conversion</span>
<span class="line-added">394      */</span>
<span class="line-added">395     public static VarHandle asUnsigned(VarHandle target, final Class&lt;?&gt; adaptedType) {</span>
<span class="line-added">396         Objects.requireNonNull(target);</span>
<span class="line-added">397         Objects.requireNonNull(adaptedType);</span>
<span class="line-added">398         final Class&lt;?&gt; carrier = target.varType();</span>
<span class="line-added">399         checkWidenable(carrier);</span>
<span class="line-added">400         checkNarrowable(adaptedType);</span>
<span class="line-added">401         checkTargetWiderThanCarrier(carrier, adaptedType);</span>
<span class="line-added">402 </span>
<span class="line-added">403         if (adaptedType == int.class &amp;&amp; carrier == byte.class) {</span>
<span class="line-added">404             return filterValue(target, INT_TO_BYTE, BYTE_TO_UNSIGNED_INT);</span>
<span class="line-added">405         } else if (adaptedType == int.class &amp;&amp; carrier == short.class) {</span>
<span class="line-added">406             return filterValue(target, INT_TO_SHORT, SHORT_TO_UNSIGNED_INT);</span>
<span class="line-added">407         } else if (adaptedType == long.class &amp;&amp; carrier == byte.class) {</span>
<span class="line-added">408             return filterValue(target, LONG_TO_BYTE, BYTE_TO_UNSIGNED_LONG);</span>
<span class="line-added">409         } else if (adaptedType == long.class &amp;&amp; carrier == short.class) {</span>
<span class="line-added">410             return filterValue(target, LONG_TO_SHORT, SHORT_TO_UNSIGNED_LONG);</span>
<span class="line-added">411         } else if (adaptedType == long.class &amp;&amp; carrier == int.class) {</span>
<span class="line-added">412             return filterValue(target, LONG_TO_INT, INT_TO_UNSIGNED_LONG);</span>
<span class="line-added">413         } else {</span>
<span class="line-added">414             throw new InternalError(&quot;should not reach here&quot;);</span>
<span class="line-added">415         }</span>
<span class="line-added">416     }</span>
<span class="line-added">417 </span>
418     /**
419      * Adapts a target var handle by pre-processing incoming and outgoing values using a pair of unary filter functions.
420      * &lt;p&gt;
421      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var handle, the incoming value (of type {@code T}, where
422      * {@code T} is the parameter type of the first filter function) is processed using the first filter and then passed
423      * to the target var handle.
424      * Conversely, when calling e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the return value obtained from
425      * the target var handle (of type {@code T}, where {@code T} is the parameter type of the second filter function)
426      * is processed using the second filter and returned to the caller. More advanced access mode types, such as
427      * {@link java.lang.invoke.VarHandle.AccessMode#COMPARE_AND_EXCHANGE} might apply both filters at the same time.
428      * &lt;p&gt;
429      * For the boxing and unboxing filters to be well formed, their types must be of the form {@code S -&gt; T} and {@code T -&gt; S},
430      * respectively, where {@code T} is the type of the target var handle. If this is the case, the resulting var handle will
431      * have type {@code S}.
432      * &lt;p&gt;
433      * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and
434      * atomic access guarantees as those featured by the target var handle.
435      *
436      * @param target the target var handle
437      * @param filterToTarget a filter to convert some type {@code S} into the type of {@code target}
</pre>
<hr />
<pre>
614     }
615 
616     private static void checkAddressFirstCoordinate(VarHandle handle) {
617         if (handle.coordinateTypes().size() &lt; 1 ||
618                 handle.coordinateTypes().get(0) != MemoryAddress.class) {
619             throw new IllegalArgumentException(&quot;Expected var handle with leading coordinate of type MemoryAddress&quot;);
620         }
621     }
622 
623     private static void checkCarrier(Class&lt;?&gt; carrier) {
624         if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {
625             throw new IllegalArgumentException(&quot;Illegal carrier: &quot; + carrier.getSimpleName());
626         }
627     }
628 
629     private static long carrierSize(Class&lt;?&gt; carrier) {
630         long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());
631         return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);
632     }
633 
<span class="line-added">634     private static void checkWidenable(Class&lt;?&gt; carrier) {</span>
<span class="line-added">635         if (!(carrier == byte.class || carrier == short.class || carrier == int.class)) {</span>
<span class="line-added">636             throw new IllegalArgumentException(&quot;illegal carrier:&quot; + carrier.getSimpleName());</span>
<span class="line-added">637         }</span>
<span class="line-added">638     }</span>
<span class="line-added">639 </span>
<span class="line-added">640     private static void checkNarrowable(Class&lt;?&gt; type) {</span>
<span class="line-added">641         if (!(type == int.class || type == long.class)) {</span>
<span class="line-added">642             throw new IllegalArgumentException(&quot;illegal adapter type: &quot; + type.getSimpleName());</span>
<span class="line-added">643         }</span>
<span class="line-added">644     }</span>
<span class="line-added">645 </span>
<span class="line-added">646     private static void checkTargetWiderThanCarrier(Class&lt;?&gt; carrier, Class&lt;?&gt; target) {</span>
<span class="line-added">647         if (Wrapper.forPrimitiveType(target).bitWidth() &lt;= Wrapper.forPrimitiveType(carrier).bitWidth()) {</span>
<span class="line-added">648             throw new IllegalArgumentException(</span>
<span class="line-added">649                     target.getSimpleName() + &quot; is not wider than: &quot; + carrier.getSimpleName());</span>
<span class="line-added">650         }</span>
<span class="line-added">651     }</span>
<span class="line-added">652 </span>
653     private static MemoryAddress longToAddress(long value) {
654         return MemoryAddress.ofLong(value);
655     }
656 
657     private static long addressToLong(MemoryAddress value) {
658         return value.toRawLongValue();
659     }
660 
661     private static MemoryAddress addOffset(MemoryAddress address, long offset) {
662         return address.addOffset(offset);
663     }
664 
665     private static MemoryAddress addStride(MemoryAddress address, long index, long stride) {
666         return address.addOffset(index * stride);
667     }
668 }
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
345                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
346         } else {
347             // fast-path
348             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
349         }
350     }
351 
352     /**
353      * Adapts a target var handle by narrowing incoming values and widening
354      * outgoing values, to and from the given type, respectively.
355      * &lt;p&gt;
356      * The returned var handle can be used to conveniently treat unsigned
357      * primitive data types as if they were a wider signed primitive type. For
358      * example, it is often convenient to model an &lt;i&gt;unsigned short&lt;/i&gt; as a
359      * Java {@code int} to avoid dealing with negative values, which would be
360      * the case if modeled as a Java {@code short}. This is illustrated in the following example:
361      * &lt;blockquote&gt;&lt;pre&gt;{@code
362     MemorySegment segment = MemorySegment.allocateNative(2);
363     VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
364     VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
<span class="line-modified">365     SHORT_VH.set(segment.baseAddress(), (short)-1);</span>
<span class="line-modified">366     INT_VH.get(segment.baseAddress()); // returns 65535</span>
367      * }&lt;/pre&gt;&lt;/blockquote&gt;
368      * &lt;p&gt;
369      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
370      * handle, the incoming value (of type {@code adaptedType}) is converted by a
371      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; and then passed to the {@code
372      * target} var handle. A narrowing primitive conversion may lose information
373      * about the overall magnitude of a numeric value. Conversely, when calling
374      * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the
375      * returned value obtained from the {@code target} var handle is converted
376      * by a &lt;i&gt;unsigned widening conversion&lt;/i&gt; before being returned to the
377      * caller. In an unsigned widening conversion the high-order bits greater
378      * than that of the {@code target} carrier type are zero, and the low-order
379      * bits (equal to the width of the {@code target} carrier type) are equal to
380      * the bits of the value obtained from the {@code target} var handle.
381      * &lt;p&gt;
382      * The returned var handle will feature the variable type {@code adaptedType},
383      * and the same access coordinates, the same access modes (see {@link
384      * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access
385      * guarantees, as those featured by the {@code target} var handle.
386      *
</pre>
</td>
<td>
<hr />
<pre>
345                     MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));
346         } else {
347             // fast-path
348             return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);
349         }
350     }
351 
352     /**
353      * Adapts a target var handle by narrowing incoming values and widening
354      * outgoing values, to and from the given type, respectively.
355      * &lt;p&gt;
356      * The returned var handle can be used to conveniently treat unsigned
357      * primitive data types as if they were a wider signed primitive type. For
358      * example, it is often convenient to model an &lt;i&gt;unsigned short&lt;/i&gt; as a
359      * Java {@code int} to avoid dealing with negative values, which would be
360      * the case if modeled as a Java {@code short}. This is illustrated in the following example:
361      * &lt;blockquote&gt;&lt;pre&gt;{@code
362     MemorySegment segment = MemorySegment.allocateNative(2);
363     VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
364     VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
<span class="line-modified">365     SHORT_VH.set(segment.address(), (short)-1);</span>
<span class="line-modified">366     INT_VH.get(segment.address()); // returns 65535</span>
367      * }&lt;/pre&gt;&lt;/blockquote&gt;
368      * &lt;p&gt;
369      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
370      * handle, the incoming value (of type {@code adaptedType}) is converted by a
371      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; and then passed to the {@code
372      * target} var handle. A narrowing primitive conversion may lose information
373      * about the overall magnitude of a numeric value. Conversely, when calling
374      * e.g. {@link VarHandle#get(Object...)} on the resulting var handle, the
375      * returned value obtained from the {@code target} var handle is converted
376      * by a &lt;i&gt;unsigned widening conversion&lt;/i&gt; before being returned to the
377      * caller. In an unsigned widening conversion the high-order bits greater
378      * than that of the {@code target} carrier type are zero, and the low-order
379      * bits (equal to the width of the {@code target} carrier type) are equal to
380      * the bits of the value obtained from the {@code target} var handle.
381      * &lt;p&gt;
382      * The returned var handle will feature the variable type {@code adaptedType},
383      * and the same access coordinates, the same access modes (see {@link
384      * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access
385      * guarantees, as those featured by the {@code target} var handle.
386      *
</pre>
</td>
</tr>
</table>
<center><a href="MemoryAddress.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MemorySegment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  *  This code is free software; you can redistribute it and/or modify it
  6  *  under the terms of the GNU General Public License version 2 only, as
  7  *  published by the Free Software Foundation.  Oracle designates this
  8  *  particular file as subject to the &quot;Classpath&quot; exception as provided
  9  *  by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  *  This code is distributed in the hope that it will be useful, but WITHOUT
 12  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  *  version 2 for more details (a copy is included in the LICENSE file that
 15  *  accompanied this code).
 16  *
 17  *  You should have received a copy of the GNU General Public License version
 18  *  2 along with this work; if not, write to the Free Software Foundation,
 19  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  *  or visit www.oracle.com if you need additional information or have any
 23  *  questions.
 24  *
 25  */
 26 package jdk.incubator.foreign;
 27 
 28 import jdk.internal.foreign.AbstractMemorySegmentImpl;
 29 import jdk.internal.foreign.Utils;
 30 import jdk.internal.foreign.abi.SharedUtils;
 31 
 32 import java.nio.ByteOrder;
 33 import java.nio.charset.Charset;
 34 import java.util.Objects;
 35 import java.util.function.Consumer;
 36 
 37 /**
 38  * A set of utilities for working with libraries using the C language/ABI
 39  */
 40 public class CSupport {
 41     /**
 42      * Obtain a linker that uses the de facto C ABI of the current system to do it&#39;s linking.
 43      * &lt;p&gt;
 44      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
 45      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 46      * restricted methods, and use safe and supported functionalities, where possible.
 47      * @return a linker for this system.
 48      * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either
 49      * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).
 50      */
 51     public static ForeignLinker getSystemLinker() {
 52         Utils.checkRestrictedAccess(&quot;CSupport.getSystemLinker&quot;);
 53         return SharedUtils.getSystemLinker();
 54     }
 55 
 56     /**
 57      * An interface that models a C {@code va_list}.
 58      * &lt;p&gt;
 59      * A va list is a stateful cursor used to iterate over a set of variadic arguments.
 60      * &lt;p&gt;
 61      * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),
 62      * arguments to variadic calls are erased by way of &#39;default argument promotions&#39;,
 63      * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),
 64      * and which erases all {@code float} arguments to {@code double}.
 65      * &lt;p&gt;
 66      * As such, this interface only supports reading {@code int}, {@code double},
 67      * and any other type that fits into a {@code long}.
 68      */
 69     public interface VaList extends AutoCloseable {
 70 
 71         /**
 72          * Reads the next value as an {@code int} and advances this va list&#39;s position.
 73          *
 74          * @param layout the layout of the value
 75          * @return the value read as an {@code int}
 76          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 77          * (see {@link #close()}).
 78          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
 79          */
 80         int vargAsInt(MemoryLayout layout);
 81 
 82         /**
 83          * Reads the next value as a {@code long} and advances this va list&#39;s position.
 84          *
 85          * @param layout the layout of the value
 86          * @return the value read as an {@code long}
 87          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 88          * (see {@link #close()}).
 89          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
 90          */
 91         long vargAsLong(MemoryLayout layout);
 92 
 93         /**
 94          * Reads the next value as a {@code double} and advances this va list&#39;s position.
 95          *
 96          * @param layout the layout of the value
 97          * @return the value read as an {@code double}
 98          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
 99          * (see {@link #close()}).
100          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
101          */
102         double vargAsDouble(MemoryLayout layout);
103 
104         /**
105          * Reads the next value as a {@code MemoryAddress} and advances this va list&#39;s position.
106          *
107          * @param layout the layout of the value
108          * @return the value read as an {@code MemoryAddress}
109          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
110          * (see {@link #close()}).
111          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
112          */
113         MemoryAddress vargAsAddress(MemoryLayout layout);
114 
115         /**
116          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
117          * &lt;p&gt;
118          * The memory segment returned by this method will be allocated using
119          * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.
120          *
121          * @param layout the layout of the value
122          * @return the value read as an {@code MemorySegment}
123          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
124          * (see {@link #close()}).
125          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
126          */
127         MemorySegment vargAsSegment(MemoryLayout layout);
128 
129         /**
130          * Reads the next value as a {@code MemorySegment}, and advances this va list&#39;s position.
131          * &lt;p&gt;
132          * The memory segment returned by this method will be allocated using the given {@code NativeScope}.
133          *
134          * @param layout the layout of the value
135          * @param scope the scope to allocate the segment in
136          * @return the value read as an {@code MemorySegment}
137          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
138          * (see {@link #close()}).
139          * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
140          */
141         MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);
142 
143         /**
144          * Skips a number of elements with the given memory layouts, and advances this va list&#39;s position.
145          *
146          * @param layouts the layout of the value
147          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
148          * (see {@link #close()}).
149          */
150         void skip(MemoryLayout... layouts);
151 
152         /**
153          * A predicate used to check if the memory associated with the C {@code va_list} modelled
154          * by this instance is still valid to use.
155          *
156          * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid
157          * @see #close()
158          */
159         boolean isAlive();
160 
161         /**
162          * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached
163          * to this va list that holds its elements (see {@link VaList#make(Consumer)}).
164          * &lt;p&gt;
165          * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values
166          * from this va list will result in an exception.
167          *
168          * @see #isAlive()
169          */
170         void close();
171 
172         /**
173          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
174          * starting from the current position, without affecting the state of the original va list, essentially
175          * allowing the elements to be traversed multiple times.
176          * &lt;p&gt;
177          * If this method needs to allocate native memory for the copy, it will use
178          * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the
179          * returned va list instance to release the allocated memory.
180          * &lt;p&gt;
181          * This method only copies the va list cursor itself and not the memory that may be attached to the
182          * va list which holds its elements. That means that if this va list was created with the
183          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
184          * elements, making the copy unusable.
185          *
186          * @return a copy of this C {@code va_list}.
187          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
188          * (see {@link #close()}).
189          */
190         VaList copy();
191 
192         /**
193          * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list&#39;s elements
194          * starting from the current position, without affecting the state of the original va list, essentially
195          * allowing the elements to be traversed multiple times.
196          * &lt;p&gt;
197          * If this method needs to allocate native memory for the copy, it will use
198          * the given {@code NativeScope} to do so.
199          * &lt;p&gt;
200          * This method only copies the va list cursor itself and not the memory that may be attached to the
201          * va list which holds its elements. That means that if this va list was created with the
202          * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its
203          * elements, making the copy unusable.
204          *
205          * @param scope the scope to allocate the copy in
206          * @return a copy of this C {@code va_list}.
207          * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid
208          * (see {@link #close()}).
209          */
210         VaList copy(NativeScope scope);
211 
212         /**
213          * Returns the memory address of the C {@code va_list} associated with this instance.
214          *
215          * @return the memory address of the C {@code va_list} associated with this instance.
216          */
217         MemoryAddress address();
218 
219         /**
220          * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.
221          *
222          * @param address a memory address pointing to an existing C {@code va_list}.
223          * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.
224          */
225         static VaList ofAddress(MemoryAddress address) {
226             return SharedUtils.newVaListOfAddress(address);
227         }
228 
229         /**
230          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
231          * &lt;p&gt;
232          * If this method needs to allocate native memory for the va list, it will use
233          * {@link MemorySegment#allocateNative(long, long)} to do so.
234          * &lt;p&gt;
235          * This method will allocate native memory to hold the elements in the va list. This memory
236          * will be &#39;attached&#39; to the returned va list instance, and will be released when {@link VaList#close()}
237          * is called.
238          * &lt;p&gt;
239          * Note that when there are no elements added to the created va list,
240          * this method will return the same as {@linkplain #empty()}.
241          *
242          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
243          *                of the underlying C {@code va_list}.
244          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
245          */
246         static VaList make(Consumer&lt;VaList.Builder&gt; actions) {
247             return SharedUtils.newVaList(actions, MemorySegment::allocateNative);
248         }
249 
250         /**
251          * Constructs a new {@code VaList} using a builder (see {@link Builder}).
252          * &lt;p&gt;
253          * If this method needs to allocate native memory for the va list, it will use
254          * the given {@code NativeScope} to do so.
255          * &lt;p&gt;
256          * This method will allocate native memory to hold the elements in the va list. This memory
257          * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.
258          * &lt;p&gt;
259          * Note that when there are no elements added to the created va list,
260          * this method will return the same as {@linkplain #empty()}.
261          *
262          * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements
263          *                of the underlying C {@code va_list}.
264          * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.
265          */
266         static VaList make(Consumer&lt;VaList.Builder&gt; actions, NativeScope scope) {
267             return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));
268         }
269 
270         /**
271          * Returns an empty C {@code va_list} constant.
272          * &lt;p&gt;
273          * The returned {@code VaList} can not be closed.
274          *
275          * @return a {@code VaList} modelling an empty C {@code va_list}.
276          */
277         static VaList empty() {
278             return SharedUtils.emptyVaList();
279         }
280 
281         /**
282          * A builder interface used to construct a C {@code va_list}.
283          */
284         interface Builder {
285 
286             /**
287              * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.
288              *
289              * @param layout the native layout of the value.
290              * @param value the value, represented as an {@code int}.
291              * @return this builder.
292              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}
293              */
294             Builder vargFromInt(MemoryLayout layout, int value);
295 
296             /**
297              * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.
298              *
299              * @param layout the native layout of the value.
300              * @param value the value, represented as a {@code long}.
301              * @return this builder.
302              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}
303              */
304             Builder vargFromLong(MemoryLayout layout, long value);
305 
306             /**
307              * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.
308              *
309              * @param layout the native layout of the value.
310              * @param value the value, represented as a {@code double}.
311              * @return this builder.
312              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}
313              */
314             Builder vargFromDouble(MemoryLayout layout, double value);
315 
316             /**
317              * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.
318              *
319              * @param layout the native layout of the value.
320              * @param value the value, represented as a {@code MemoryAddress}.
321              * @return this builder.
322              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}
323              */
324             Builder vargFromAddress(MemoryLayout layout, MemoryAddress value);
325 
326             /**
327              * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.
328              *
329              * @param layout the native layout of the value.
330              * @param value the value, represented as a {@code MemorySegment}.
331              * @return this builder.
332              * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}
333              */
334             Builder vargFromSegment(MemoryLayout layout, MemorySegment value);
335         }
336     }
337 
338     /**
339      * The {@code _Bool} native type.
340      */
341     public static final ValueLayout C_BOOL = Utils.pick(SysV.C_BOOL, Win64.C_BOOL, AArch64.C_BOOL);
342     /**
343      * The {@code char} native type.
344      */
345     public static final ValueLayout C_CHAR = Utils.pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);
346     /**
347      * The {@code short} native type.
348      */
349     public static final ValueLayout C_SHORT = Utils.pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);
350     /**
351      * The {@code int} native type.
352      */
353     public static final ValueLayout C_INT = Utils.pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);
354     /**
355      * The {@code long} native type.
356      */
357     public static final ValueLayout C_LONG = Utils.pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);
358     /**
359      * The {@code long long} native type.
360      */
361     public static final ValueLayout C_LONGLONG = Utils.pick(SysV.C_LONGLONG, Win64.C_LONGLONG, AArch64.C_LONGLONG);
362     /**
363      * The {@code float} native type.
364      */
365     public static final ValueLayout C_FLOAT = Utils.pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);
366     /**
367      * The {@code double} native type.
368      */
369     public static final ValueLayout C_DOUBLE = Utils.pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);
370     /**
371      * The {@code long double} native type.
372      */
373     public static final ValueLayout C_LONGDOUBLE = Utils.pick(SysV.C_LONGDOUBLE, Win64.C_LONGDOUBLE, AArch64.C_LONGDOUBLE);
374     /**
375      * The {@code T*} native type.
376      */
377     public static final ValueLayout C_POINTER = Utils.pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);
378 
379     /**
380      * The {@code va_list} native type.
381      */
382     public static final MemoryLayout C_VA_LIST = Utils.pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);
383 
384     /**
385      * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.
386      */
387     public static final class SysV {
388         private SysV() {
389             //just the one
390         }
391 
392         /**
393          * The name of the SysV linker
394          * @see ForeignLinker#name
395          */
396         public static final String NAME = &quot;SysV&quot;;
397 
398         /**
399          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
400          * attribute value must be an enum constant from {@link ArgumentClass}.
401          */
402         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/sysv/class&quot;;
403 
404         /**
405          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
406          */
407         public enum ArgumentClass {
408             /** Classification constant for integral values */
409             INTEGER,
410             /** Classification constant for floating point values */
411             SSE,
412             /** Classification constant for x87 floating point values */
413             X87,
414             /** Classification constant for {@code complex long double} values */
415             COMPLEX_87,
416             /** Classification constant for machine pointer values */
417             POINTER;
418         }
419 
420         /**
421          * The {@code _Bool} native type.
422          */
423         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
424                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
425 
426         /**
427          * The {@code char} native type.
428          */
429         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
430                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
431 
432         /**
433          * The {@code short} native type.
434          */
435         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
436                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
437 
438         /**
439          * The {@code int} native type.
440          */
441         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
442                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
443 
444         /**
445          * The {@code long} native type.
446          */
447         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
448                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
449 
450         /**
451          * The {@code long long} native type.
452          */
453         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
454                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
455 
456         /**
457          * The {@code float} native type.
458          */
459         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
460                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
461 
462         /**
463          * The {@code double} native type.
464          */
465         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
466                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.SSE);
467 
468         /**
469          * The {@code long double} native type.
470          */
471         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
472                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.X87);
473 
474         /**
475          * The {@code complex long double} native type.
476          */
477         public static final GroupLayout C_COMPLEX_LONGDOUBLE = MemoryLayout.ofStruct(C_LONGDOUBLE, C_LONGDOUBLE)
478                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.COMPLEX_87);
479 
480         /**
481          * The {@code T*} native type.
482          */
483         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
484                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
485 
486         /**
487          * The {@code va_list} native type, as it is passed to a function.
488          */
489         public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;
490     }
491 
492     /**
493      * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.
494      */
495     public static final class Win64 {
496 
497         private Win64() {
498             //just the one
499         }
500 
501         /**
502          * The name of the Windows linker
503          * @see ForeignLinker#name
504          */
505         public final static String NAME = &quot;Windows&quot;;
506 
507         /**
508          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used to mark variadic parameters. The
509          * attribute value must be a boolean.
510          */
511         public final static String VARARGS_ATTRIBUTE_NAME = &quot;abi/windows/varargs&quot;;
512 
513         /**
514          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
515          * attribute value must be an enum constant from {@link ArgumentClass}.
516          */
517         public final static String CLASS_ATTRIBUTE_NAME = &quot;abi/windows/class&quot;;
518 
519         /**
520          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
521          */
522         public enum ArgumentClass {
523             /** Classification constant for integral values */
524             INTEGER,
525             /** Classification constant for floating point values */
526             FLOAT,
527             /** Classification constant for machine pointer values */
528             POINTER;
529         }
530 
531         /**
532          * The {@code _Bool} native type.
533          */
534         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
535                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
536 
537         /**
538          * The {@code char} native type.
539          */
540         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
541                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
542 
543         /**
544          * The {@code short} native type.
545          */
546         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
547                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
548 
549         /**
550          * The {@code int} native type.
551          */
552         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
553                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
554 
555         /**
556          * The {@code long} native type.
557          */
558         public static final ValueLayout C_LONG = MemoryLayouts.BITS_32_LE
559                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
560 
561         /**
562          * The {@code long long} native type.
563          */
564         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
565                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
566 
567         /**
568          * The {@code float} native type.
569          */
570         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
571                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
572 
573         /**
574          * The {@code double} native type.
575          */
576         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
577                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
578 
579         /**
580          * The {@code long double} native type.
581          */
582         public static final ValueLayout C_LONGDOUBLE = MemoryLayouts.BITS_64_LE
583                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.FLOAT);
584 
585         /**
586          * The {@code T*} native type.
587          */
588         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
589                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
590 
591         /**
592          * The {@code va_list} native type, as it is passed to a function.
593          */
594         public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;
595 
596         /**
597          * Return a new memory layout which describes a variadic parameter to be passed to a function.
598          * @param layout the original parameter layout.
599          * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},
600          * which is set to {@code true}.
601          */
602         public static ValueLayout asVarArg(ValueLayout layout) {
603             return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);
604         }
605     }
606 
607     /**
608      * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.
609      */
610     public static final class AArch64 {
611 
612         private AArch64() {
613             //just the one
614         }
615 
616         /**
617          * The name of the AArch64 linker
618          * @see ForeignLinker#name
619          */
620         public final static String NAME = &quot;AArch64&quot;;
621 
622         /**
623          * The name of the layout attribute (see {@link MemoryLayout#attributes()} used for ABI classification. The
624          * attribute value must be an enum constant from {@link ArgumentClass}.
625          */
626         public static final String CLASS_ATTRIBUTE_NAME = &quot;abi/aarch64/class&quot;;
627 
628         /**
629          * Constants used for ABI classification. They are referred to by the layout attribute {@link #CLASS_ATTRIBUTE_NAME}.
630          */
631         public enum ArgumentClass {
632             /** Classification constant for machine integral values */
633             INTEGER,
634             /** Classification constant for machine floating point values */
635             VECTOR,
636             /** Classification constant for machine pointer values */
637             POINTER;
638         }
639 
640         /**
641          * The {@code _Bool} native type.
642          */
643         public static final ValueLayout C_BOOL = MemoryLayouts.BITS_8_LE
644                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
645 
646         /**
647          * The {@code char} native type.
648          */
649         public static final ValueLayout C_CHAR = MemoryLayouts.BITS_8_LE
650                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
651 
652         /**
653          * The {@code short} native type.
654          */
655         public static final ValueLayout C_SHORT = MemoryLayouts.BITS_16_LE
656                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
657 
658         /**
659          * The {@code int} native type.
660          */
661         public static final ValueLayout C_INT = MemoryLayouts.BITS_32_LE
662                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
663 
664         /**
665          * The {@code long} native type.
666          */
667         public static final ValueLayout C_LONG = MemoryLayouts.BITS_64_LE
668                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
669 
670         /**
671          * The {@code long long} native type.
672          */
673         public static final ValueLayout C_LONGLONG = MemoryLayouts.BITS_64_LE
674                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.INTEGER);
675 
676         /**
677          * The {@code float} native type.
678          */
679         public static final ValueLayout C_FLOAT = MemoryLayouts.BITS_32_LE
680                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
681 
682         /**
683          * The {@code double} native type.
684          */
685         public static final ValueLayout C_DOUBLE = MemoryLayouts.BITS_64_LE
686                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
687 
688         /**
689          * The {@code long double} native type.
690          */
691         public static final ValueLayout C_LONGDOUBLE = MemoryLayout.ofValueBits(128, ByteOrder.LITTLE_ENDIAN)
692                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.VECTOR);
693 
694         /**
695          * The {@code T*} native type.
696          */
697         public static final ValueLayout C_POINTER = MemoryLayouts.BITS_64_LE
698                 .withAttribute(CLASS_ATTRIBUTE_NAME, ArgumentClass.POINTER);
699 
700         /**
701          * The {@code va_list} native type, as it is passed to a function.
702          */
703         public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;
704     }
705 
706     /**
707      * Convert a Java string into a null-terminated C string, using the
708      * platform&#39;s default charset, storing the result into a new native memory segment.
709      * &lt;p&gt;
710      * This method always replaces malformed-input and unmappable-character
711      * sequences with this charset&#39;s default replacement byte array.  The
712      * {@link java.nio.charset.CharsetEncoder} class should be used when more
713      * control over the encoding process is required.
714      *
715      * @param str the Java string to be converted into a C string.
716      * @return a new native memory segment containing the converted C string.
717      * @throws NullPointerException if either {@code str == null}.
718      */
719     public static MemorySegment toCString(String str) {
720         Objects.requireNonNull(str);
721         return toCString(str.getBytes());
722     }
723 
724     /**
725      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
726      * storing the result into a new native memory segment.
727      * &lt;p&gt;
728      * This method always replaces malformed-input and unmappable-character
729      * sequences with this charset&#39;s default replacement byte array.  The
730      * {@link java.nio.charset.CharsetEncoder} class should be used when more
731      * control over the encoding process is required.
732      *
733      * @param str the Java string to be converted into a C string.
734      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
735      * @return a new native memory segment containing the converted C string.
736      * @throws NullPointerException if either {@code str == null} or {@code charset == null}.
737      */
738     public static MemorySegment toCString(String str, Charset charset) {
739         Objects.requireNonNull(str);
740         Objects.requireNonNull(charset);
741         return toCString(str.getBytes(charset));
742     }
743 
744     /**
745      * Convert a Java string into a null-terminated C string, using the platform&#39;s default charset,
746      * storing the result into a native memory segment allocated using the provided scope.
747      * &lt;p&gt;
748      * This method always replaces malformed-input and unmappable-character
749      * sequences with this charset&#39;s default replacement byte array.  The
750      * {@link java.nio.charset.CharsetEncoder} class should be used when more
751      * control over the encoding process is required.
752      *
753      * @param str the Java string to be converted into a C string.
754      * @param scope the scope to be used for the native segment allocation.
755      * @return a new native memory segment containing the converted C string.
756      * @throws NullPointerException if either {@code str == null} or {@code scope == null}.
757      */
758     public static MemoryAddress toCString(String str, NativeScope scope) {
759         Objects.requireNonNull(str);
760         Objects.requireNonNull(scope);
761         return toCString(str.getBytes(), scope);
762     }
763 
764     /**
765      * Convert a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},
766      * storing the result into a new native memory segment native memory segment allocated using the provided scope.
767      * &lt;p&gt;
768      * This method always replaces malformed-input and unmappable-character
769      * sequences with this charset&#39;s default replacement byte array.  The
770      * {@link java.nio.charset.CharsetEncoder} class should be used when more
771      * control over the encoding process is required.
772      *
773      * @param str the Java string to be converted into a C string.
774      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the C string.
775      * @param scope the scope to be used for the native segment allocation.
776      * @return a new native memory segment containing the converted C string.
777      * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.
778      */
779     public static MemoryAddress toCString(String str, Charset charset, NativeScope scope) {
780         Objects.requireNonNull(str);
781         Objects.requireNonNull(charset);
782         Objects.requireNonNull(scope);
783         return toCString(str.getBytes(charset), scope);
784     }
785 
786     /**
787      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
788      * &lt;p&gt;
789      * This method always replaces malformed-input and unmappable-character
790      * sequences with this charset&#39;s default replacement string.  The {@link
791      * java.nio.charset.CharsetDecoder} class should be used when more control
792      * over the decoding process is required.
793      * &lt;p&gt;
794      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
795      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
796      * restricted methods, and use safe and supported functionalities, where possible.
797      * @param addr the address at which the string is stored.
798      * @return a Java string with the contents of the null-terminated C string at given address.
799      * @throws NullPointerException if {@code addr == null}
800      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
801      */
802     public static String toJavaStringRestricted(MemoryAddress addr) {
803         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
804         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), Charset.defaultCharset());
805     }
806 
807     /**
808      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
809      * &lt;p&gt;
810      * This method always replaces malformed-input and unmappable-character
811      * sequences with this charset&#39;s default replacement string.  The {@link
812      * java.nio.charset.CharsetDecoder} class should be used when more control
813      * over the decoding process is required.
814      * &lt;p&gt;
815      * This method is &lt;em&gt;restricted&lt;/em&gt;. Restricted method are unsafe, and, if used incorrectly, their use might crash
816      * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
817      * restricted methods, and use safe and supported functionalities, where possible.
818      * @param addr the address at which the string is stored.
819      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
820      * @return a Java string with the contents of the null-terminated C string at given address.
821      * @throws NullPointerException if {@code addr == null}
822      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
823      */
824     public static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {
825         Utils.checkRestrictedAccess(&quot;CSupport.toJavaStringRestricted&quot;);
826         return SharedUtils.toJavaStringInternal(addr.rebase(AbstractMemorySegmentImpl.EVERYTHING), charset);
827     }
828 
829     /**
830      * Convert a null-terminated C string stored at given address into a Java string, using the platform&#39;s default charset.
831      * &lt;p&gt;
832      * This method always replaces malformed-input and unmappable-character
833      * sequences with this charset&#39;s default replacement string.  The {@link
834      * java.nio.charset.CharsetDecoder} class should be used when more control
835      * over the decoding process is required.
836      * @param addr the address at which the string is stored.
837      * @return a Java string with the contents of the null-terminated C string at given address.
838      * @throws NullPointerException if {@code addr == null}
839      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
840      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
841      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
842      */
843     public static String toJavaString(MemoryAddress addr) {
844         return SharedUtils.toJavaStringInternal(addr, Charset.defaultCharset());
845     }
846 
847     /**
848      * Convert a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.
849      * &lt;p&gt;
850      * This method always replaces malformed-input and unmappable-character
851      * sequences with this charset&#39;s default replacement string.  The {@link
852      * java.nio.charset.CharsetDecoder} class should be used when more control
853      * over the decoding process is required.
854      * @param addr the address at which the string is stored.
855      * @param charset The {@linkplain java.nio.charset.Charset} to be used to compute the contents of the Java string.
856      * @return a Java string with the contents of the null-terminated C string at given address.
857      * @throws NullPointerException if {@code addr == null}
858      * @throws IllegalArgumentException if the size of the native string is greater than {@code Integer.MAX_VALUE}.
859      * @throws IllegalStateException if the size of the native string is greater than the size of the segment
860      * associated with {@code addr}, or if {@code addr} is associated with a segment that is &lt;em&gt;not alive&lt;/em&gt;.
861      */
862     public static String toJavaString(MemoryAddress addr, Charset charset) {
863         return SharedUtils.toJavaStringInternal(addr, charset);
864     }
865 
866     private static void copy(MemoryAddress addr, byte[] bytes) {
867         var heapSegment = MemorySegment.ofArray(bytes);
868         addr.segment().copyFrom(heapSegment);
869         MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);
870     }
871 
872     private static MemorySegment toCString(byte[] bytes) {
873         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
<a name="1" id="anc1"></a><span class="line-modified">874         MemoryAddress addr = segment.address();</span>
875         copy(addr, bytes);
876         return segment;
877     }
878 
879     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
880         MemoryAddress addr = scope.allocate(bytes.length + 1, 1L);
881         copy(addr, bytes);
882         return addr;
883     }
884 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
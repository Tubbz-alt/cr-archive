<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../MemoryAddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgrammableInvoker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
198  *
199  * Return bindings:
200  * none
201  *
202  * --------------------
203  */
204 public abstract class Binding {
205     private static final MethodHandle MH_UNBOX_ADDRESS;
206     private static final MethodHandle MH_BOX_ADDRESS;
207     private static final MethodHandle MH_BASE_ADDRESS;
208     private static final MethodHandle MH_COPY_BUFFER;
209     private static final MethodHandle MH_ALLOCATE_BUFFER;
210 
211     static {
212         try {
213             MethodHandles.Lookup lookup = MethodHandles.lookup();
214             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, &quot;toRawLongValue&quot;,
215                     methodType(long.class));
216             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, &quot;ofLong&quot;,
217                     methodType(MemoryAddress.class, long.class));
<span class="line-modified">218             MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, &quot;baseAddress&quot;,</span>
219                     methodType(MemoryAddress.class));
220             MH_COPY_BUFFER = lookup.findStatic(Binding.class, &quot;copyBuffer&quot;,
221                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));
222             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, &quot;allocateNative&quot;,
223                     methodType(MemorySegment.class, long.class, long.class));
224         } catch (ReflectiveOperationException e) {
225             throw new RuntimeException(e);
226         }
227     }
228 
229     enum Tag {
230         MOVE,
231         DEREFERENCE,
232         COPY_BUFFER,
233         ALLOC_BUFFER,
234         CONVERT_ADDRESS,
235         BASE_ADDRESS,
236         DUP
237     }
238 
</pre>
<hr />
<pre>
501 
502         @Override
503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
504             Class&lt;?&gt; actualType = stack.pop();
505             SharedUtils.checkType(actualType, MemorySegment.class);
506             Class&lt;?&gt; newType = type;
507             stack.push(newType);
508         }
509 
510         @Override
511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
512             Class&lt;?&gt; storeType = stack.pop();
513             SharedUtils.checkType(storeType, type);
514             Class&lt;?&gt; segmentType = stack.pop();
515             SharedUtils.checkType(segmentType, MemorySegment.class);
516         }
517 
518         @Override
519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
520             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">521             MemoryAddress baseAddress = operand.baseAddress();</span>
522             MemoryAddress readAddress = baseAddress.addOffset(offset);
523             stack.push(SharedUtils.read(readAddress, type));
524         }
525 
526         @Override
527         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
528             Object value = stack.pop();
529             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">530             MemoryAddress baseAddress = operand.baseAddress();</span>
531             MemoryAddress writeAddress = baseAddress.addOffset(offset);
532             SharedUtils.write(writeAddress, type, value);
533         }
534 
535         private VarHandle varHandle() {
536             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);
537         }
538 
539         @Override
540         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
541             MethodHandle filter = filterArguments(
542                 varHandle()
543                     .toMethodHandle(VarHandle.AccessMode.GET)
544                     .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);
545             return filterArguments(specializedHandle, insertPos, filter);
546         }
547 
548         @Override
549         public MethodHandle specializeBox(MethodHandle returnFilter) {
550             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
</pre>
<hr />
<pre>
816             if (this == o) return true;
817             return o != null &amp;&amp; getClass() == o.getClass();
818         }
819 
820         @Override
821         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
822             Class&lt;?&gt; actualType = stack.pop();
823             SharedUtils.checkType(actualType, MemorySegment.class);
824             stack.push(MemoryAddress.class);
825         }
826 
827         @Override
828         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
829             Class&lt;?&gt; actualType = stack.pop();
830             SharedUtils.checkType(actualType, MemorySegment.class);
831             stack.push(MemoryAddress.class);
832         }
833 
834         @Override
835         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
<span class="line-modified">836             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
837         }
838 
839         @Override
840         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
<span class="line-modified">841             stack.push(((MemorySegment) stack.pop()).baseAddress());</span>
842         }
843 
844         @Override
845         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
846             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);
847         }
848 
849         @Override
850         public MethodHandle specializeBox(MethodHandle returnFilter) {
851             throw new UnsupportedOperationException();
852         }
853     }
854 
855     /**
856      * DUP()
857      *   Duplicates the value on the top of the operand stack (without popping it!),
858      *   and pushes the duplicate onto the operand stack
859      */
860     public static class Dup extends Binding {
861         private static final Dup INSTANCE = new Dup();
</pre>
</td>
<td>
<hr />
<pre>
198  *
199  * Return bindings:
200  * none
201  *
202  * --------------------
203  */
204 public abstract class Binding {
205     private static final MethodHandle MH_UNBOX_ADDRESS;
206     private static final MethodHandle MH_BOX_ADDRESS;
207     private static final MethodHandle MH_BASE_ADDRESS;
208     private static final MethodHandle MH_COPY_BUFFER;
209     private static final MethodHandle MH_ALLOCATE_BUFFER;
210 
211     static {
212         try {
213             MethodHandles.Lookup lookup = MethodHandles.lookup();
214             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, &quot;toRawLongValue&quot;,
215                     methodType(long.class));
216             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, &quot;ofLong&quot;,
217                     methodType(MemoryAddress.class, long.class));
<span class="line-modified">218             MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, &quot;address&quot;,</span>
219                     methodType(MemoryAddress.class));
220             MH_COPY_BUFFER = lookup.findStatic(Binding.class, &quot;copyBuffer&quot;,
221                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));
222             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, &quot;allocateNative&quot;,
223                     methodType(MemorySegment.class, long.class, long.class));
224         } catch (ReflectiveOperationException e) {
225             throw new RuntimeException(e);
226         }
227     }
228 
229     enum Tag {
230         MOVE,
231         DEREFERENCE,
232         COPY_BUFFER,
233         ALLOC_BUFFER,
234         CONVERT_ADDRESS,
235         BASE_ADDRESS,
236         DUP
237     }
238 
</pre>
<hr />
<pre>
501 
502         @Override
503         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
504             Class&lt;?&gt; actualType = stack.pop();
505             SharedUtils.checkType(actualType, MemorySegment.class);
506             Class&lt;?&gt; newType = type;
507             stack.push(newType);
508         }
509 
510         @Override
511         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
512             Class&lt;?&gt; storeType = stack.pop();
513             SharedUtils.checkType(storeType, type);
514             Class&lt;?&gt; segmentType = stack.pop();
515             SharedUtils.checkType(segmentType, MemorySegment.class);
516         }
517 
518         @Override
519         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
520             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">521             MemoryAddress baseAddress = operand.address();</span>
522             MemoryAddress readAddress = baseAddress.addOffset(offset);
523             stack.push(SharedUtils.read(readAddress, type));
524         }
525 
526         @Override
527         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
528             Object value = stack.pop();
529             MemorySegment operand = (MemorySegment) stack.pop();
<span class="line-modified">530             MemoryAddress baseAddress = operand.address();</span>
531             MemoryAddress writeAddress = baseAddress.addOffset(offset);
532             SharedUtils.write(writeAddress, type, value);
533         }
534 
535         private VarHandle varHandle() {
536             return MemoryHandles.withOffset(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), offset);
537         }
538 
539         @Override
540         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
541             MethodHandle filter = filterArguments(
542                 varHandle()
543                     .toMethodHandle(VarHandle.AccessMode.GET)
544                     .asType(methodType(type, MemoryAddress.class)), 0, MH_BASE_ADDRESS);
545             return filterArguments(specializedHandle, insertPos, filter);
546         }
547 
548         @Override
549         public MethodHandle specializeBox(MethodHandle returnFilter) {
550             MethodHandle setter = varHandle().toMethodHandle(VarHandle.AccessMode.SET);
</pre>
<hr />
<pre>
816             if (this == o) return true;
817             return o != null &amp;&amp; getClass() == o.getClass();
818         }
819 
820         @Override
821         public void verifyUnbox(Deque&lt;Class&lt;?&gt;&gt; stack) {
822             Class&lt;?&gt; actualType = stack.pop();
823             SharedUtils.checkType(actualType, MemorySegment.class);
824             stack.push(MemoryAddress.class);
825         }
826 
827         @Override
828         public void verifyBox(Deque&lt;Class&lt;?&gt;&gt; stack) {
829             Class&lt;?&gt; actualType = stack.pop();
830             SharedUtils.checkType(actualType, MemorySegment.class);
831             stack.push(MemoryAddress.class);
832         }
833 
834         @Override
835         public void unbox(Deque&lt;Object&gt; stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
<span class="line-modified">836             stack.push(((MemorySegment) stack.pop()).address());</span>
837         }
838 
839         @Override
840         public void box(Deque&lt;Object&gt; stack, BindingInterpreter.LoadFunc loadFunc) {
<span class="line-modified">841             stack.push(((MemorySegment) stack.pop()).address());</span>
842         }
843 
844         @Override
845         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
846             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);
847         }
848 
849         @Override
850         public MethodHandle specializeBox(MethodHandle returnFilter) {
851             throw new UnsupportedOperationException();
852         }
853     }
854 
855     /**
856      * DUP()
857      *   Duplicates the value on the top of the operand stack (without popping it!),
858      *   and pushes the duplicate onto the operand stack
859      */
860     public static class Dup extends Binding {
861         private static final Dup INSTANCE = new Dup();
</pre>
</td>
</tr>
</table>
<center><a href="../MemoryAddressImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ProgrammableInvoker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
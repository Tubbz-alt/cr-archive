<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../aarch64/AArch64VaList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../windows/WinVaList.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
123     private final MemorySegment segment;
124     private final MemorySegment regSaveArea;
125     private final List&lt;MemorySegment&gt; attachedSegments;
126 
127     private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List&lt;MemorySegment&gt; attachedSegments) {
128         this.segment = segment;
129         this.regSaveArea = regSaveArea;
130         this.attachedSegments = attachedSegments;
131     }
132 
133     private static SysVVaList readFromSegment(MemorySegment segment) {
134         MemorySegment regSaveArea = getRegSaveArea(segment);
135         return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));
136     }
137 
138     private static MemoryAddress emptyListAddress() {
139         long ptr = U.allocateMemory(LAYOUT.byteSize());
140         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
141                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -&gt; U.freeMemory(ptr), null);
142         cleaner.register(SysVVaList.class, ms::close);
<span class="line-modified">143         MemoryAddress base = ms.baseAddress();</span>
144         VH_gp_offset.set(base, MAX_GP_OFFSET);
145         VH_fp_offset.set(base, MAX_FP_OFFSET);
146         VH_overflow_arg_area.set(base, MemoryAddress.NULL);
147         VH_reg_save_area.set(base, MemoryAddress.NULL);
<span class="line-modified">148         return ms.withAccessModes(0).baseAddress();</span>
149     }
150 
151     public static CSupport.VaList empty() {
152         return EMPTY;
153     }
154 
155     private int currentGPOffset() {
<span class="line-modified">156         return (int) VH_gp_offset.get(segment.baseAddress());</span>
157     }
158 
159     private void currentGPOffset(int i) {
<span class="line-modified">160         VH_gp_offset.set(segment.baseAddress(), i);</span>
161     }
162 
163     private int currentFPOffset() {
<span class="line-modified">164         return (int) VH_fp_offset.get(segment.baseAddress());</span>
165     }
166 
167     private void currentFPOffset(int i) {
<span class="line-modified">168         VH_fp_offset.set(segment.baseAddress(), i);</span>
169     }
170 
171     private MemoryAddress stackPtr() {
<span class="line-modified">172         return (MemoryAddress) VH_overflow_arg_area.get(segment.baseAddress());</span>
173     }
174 
175     private void stackPtr(MemoryAddress ptr) {
<span class="line-modified">176         VH_overflow_arg_area.set(segment.baseAddress(), ptr);</span>
177     }
178 
179     private MemorySegment regSaveArea() {
180         return getRegSaveArea(segment);
181     }
182 
183     private static MemorySegment getRegSaveArea(MemorySegment segment) {
<span class="line-modified">184         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.baseAddress()),</span>
185             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
186     }
187 
188     private void preAlignStack(MemoryLayout layout) {
189         if (layout.byteAlignment() &gt; 8) {
190             stackPtr(Utils.alignUp(stackPtr(), 16));
191         }
192     }
193 
194     private void postAlignStack(MemoryLayout layout) {
195         stackPtr(Utils.alignUp(stackPtr().addOffset(layout.byteSize()), 8));
196     }
197 
198     @Override
199     public int vargAsInt(MemoryLayout layout) {
200         return (int) read(int.class, layout);
201     }
202 
203     @Override
204     public long vargAsLong(MemoryLayout layout) {
</pre>
<hr />
<pre>
232     private Object read(Class&lt;?&gt; carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
233         checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);
234         TypeClass typeClass = TypeClass.classifyLayout(layout);
235         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)
236                 || typeClass.inMemory()) {
237             preAlignStack(layout);
238             return switch (typeClass.kind()) {
239                 case STRUCT -&gt; {
240                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
241                                                                                 segment.ownerThread(), null, null)) {
242                         MemorySegment seg = allocator.allocate(layout);
243                         seg.copyFrom(slice);
244                         postAlignStack(layout);
245                         yield seg;
246                     }
247                 }
248                 case POINTER, INTEGER, FLOAT -&gt; {
249                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
250                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
251                                                                                 segment.ownerThread(), null, null)) {
<span class="line-modified">252                         Object res = reader.get(slice.baseAddress());</span>
253                         postAlignStack(layout);
254                         yield res;
255                     }
256                 }
257             };
258         } else {
259             return switch (typeClass.kind()) {
260                 case STRUCT -&gt; {
261                     MemorySegment value = allocator.allocate(layout);
262                     int classIdx = 0;
263                     long offset = 0;
264                     while (offset &lt; layout.byteSize()) {
265                         final long copy = Math.min(layout.byteSize() - offset, 8);
266                         boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
267                         MemorySegment slice = value.asSlice(offset, copy);
268                         if (isSSE) {
269                             slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));
270                             currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
271                         } else {
272                             slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));
273                             currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
274                         }
275                         offset += copy;
276                     }
277                     yield value;
278                 }
279                 case POINTER, INTEGER -&gt; {
280                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">281                     Object res = reader.get(regSaveArea.baseAddress().addOffset(currentGPOffset()));</span>
282                     currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
283                     yield res;
284                 }
285                 case FLOAT -&gt; {
286                     VarHandle reader = layout.varHandle(carrier);
<span class="line-modified">287                     Object res = reader.get(regSaveArea.baseAddress().addOffset(currentFPOffset()));</span>
288                     currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
289                     yield res;
290                 }
291             };
292         }
293     }
294 
295     @Override
296     public void skip(MemoryLayout... layouts) {
297         for (MemoryLayout layout : layouts) {
298             TypeClass typeClass = TypeClass.classifyLayout(layout);
299             if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {
300                 preAlignStack(layout);
301                 postAlignStack(layout);
302             } else {
303                 currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));
304                 currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));
305             }
306         }
307     }
</pre>
<hr />
<pre>
328     }
329 
330     @Override
331     public VaList copy() {
332         return copy(MemorySegment::allocateNative);
333     }
334 
335     @Override
336     public VaList copy(NativeScope scope) {
337         return copy(SharedUtils.Allocator.ofScope(scope));
338     }
339 
340     private VaList copy(SharedUtils.Allocator allocator) {
341         MemorySegment copy = allocator.allocate(LAYOUT);
342         copy.copyFrom(segment);
343         return new SysVVaList(copy, regSaveArea, List.of());
344     }
345 
346     @Override
347     public MemoryAddress address() {
<span class="line-modified">348         return segment.baseAddress();</span>
349     }
350 
351     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {
352         return currentGPOffset &gt; MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE
353                 || currentFPOffset &gt; MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;
354     }
355 
356     @Override
357     public String toString() {
358         return &quot;SysVVaList{&quot;
359                + &quot;gp_offset=&quot; + currentGPOffset()
360                + &quot;, fp_offset=&quot; + currentFPOffset()
361                + &quot;, overflow_arg_area=&quot; + stackPtr()
362                + &quot;, reg_save_area=&quot; + regSaveArea()
363                + &#39;}&#39;;
364     }
365 
366     static class Builder implements CSupport.VaList.Builder {
367         private final SharedUtils.Allocator allocator;
368         private final MemorySegment reg_save_area;
</pre>
<hr />
<pre>
412                     case STRUCT -&gt; {
413                         MemorySegment valueSegment = (MemorySegment) value;
414                         int classIdx = 0;
415                         long offset = 0;
416                         while (offset &lt; layout.byteSize()) {
417                             final long copy = Math.min(layout.byteSize() - offset, 8);
418                             boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
419                             MemorySegment slice = valueSegment.asSlice(offset, copy);
420                             if (isSSE) {
421                                 reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);
422                                 currentFPOffset += FP_SLOT_SIZE;
423                             } else {
424                                 reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);
425                                 currentGPOffset += GP_SLOT_SIZE;
426                             }
427                             offset += copy;
428                         }
429                     }
430                     case POINTER, INTEGER -&gt; {
431                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">432                         writer.set(reg_save_area.baseAddress().addOffset(currentGPOffset), value);</span>
433                         currentGPOffset += GP_SLOT_SIZE;
434                     }
435                     case FLOAT -&gt; {
436                         VarHandle writer = layout.varHandle(carrier);
<span class="line-modified">437                         writer.set(reg_save_area.baseAddress().addOffset(currentFPOffset), value);</span>
438                         currentFPOffset += FP_SLOT_SIZE;
439                     }
440                 }
441             }
442             return this;
443         }
444 
445         private boolean isEmpty() {
446             return currentGPOffset == 0 &amp;&amp; currentFPOffset == FP_OFFSET &amp;&amp; stackArgs.isEmpty();
447         }
448 
449         public VaList build() {
450             if (isEmpty()) {
451                 return EMPTY;
452             }
453 
454             MemorySegment vaListSegment = allocator.allocate(LAYOUT);
455             List&lt;MemorySegment&gt; attachedSegments = new ArrayList&lt;&gt;();
456             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
457             if (!stackArgs.isEmpty()) {
458                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -&gt; acc + e.layout.byteSize(), Long::sum);
459                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
<span class="line-modified">460                 MemoryAddress maOverflowArgArea = stackArgsSegment.baseAddress();</span>
461                 for (SimpleVaArg arg : stackArgs) {
462                     if (arg.layout.byteSize() &gt; 8) {
463                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
464                     }
465                     if (arg.value instanceof MemorySegment) {
466                         MemorySegment slice
467                             = stackArgsSegment.asSlice(maOverflowArgArea.segmentOffset(), arg.layout.byteSize());
468                         slice.copyFrom((MemorySegment) arg.value);
469                     } else {
470                         VarHandle writer = arg.varHandle();
471                         writer.set(maOverflowArgArea, arg.value);
472                     }
473                     maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
474                 }
<span class="line-modified">475                 stackArgsPtr = stackArgsSegment.baseAddress();</span>
476                 attachedSegments.add(stackArgsSegment);
477             }
478 
<span class="line-modified">479             MemoryAddress vaListAddr = vaListSegment.baseAddress();</span>
480             VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
481             VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
<span class="line-modified">482             VH_reg_save_area.set(vaListAddr, reg_save_area.baseAddress());</span>
483             attachedSegments.add(reg_save_area);
484             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
485             return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
486         }
487     }
488 }
</pre>
</td>
<td>
<hr />
<pre>
123     private final MemorySegment segment;
124     private final MemorySegment regSaveArea;
125     private final List&lt;MemorySegment&gt; attachedSegments;
126 
127     private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List&lt;MemorySegment&gt; attachedSegments) {
128         this.segment = segment;
129         this.regSaveArea = regSaveArea;
130         this.attachedSegments = attachedSegments;
131     }
132 
133     private static SysVVaList readFromSegment(MemorySegment segment) {
134         MemorySegment regSaveArea = getRegSaveArea(segment);
135         return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));
136     }
137 
138     private static MemoryAddress emptyListAddress() {
139         long ptr = U.allocateMemory(LAYOUT.byteSize());
140         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
141                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -&gt; U.freeMemory(ptr), null);
142         cleaner.register(SysVVaList.class, ms::close);
<span class="line-modified">143         MemoryAddress base = ms.address();</span>
144         VH_gp_offset.set(base, MAX_GP_OFFSET);
145         VH_fp_offset.set(base, MAX_FP_OFFSET);
146         VH_overflow_arg_area.set(base, MemoryAddress.NULL);
147         VH_reg_save_area.set(base, MemoryAddress.NULL);
<span class="line-modified">148         return ms.withAccessModes(0).address();</span>
149     }
150 
151     public static CSupport.VaList empty() {
152         return EMPTY;
153     }
154 
155     private int currentGPOffset() {
<span class="line-modified">156         return (int) VH_gp_offset.get(segment.address());</span>
157     }
158 
159     private void currentGPOffset(int i) {
<span class="line-modified">160         VH_gp_offset.set(segment.address(), i);</span>
161     }
162 
163     private int currentFPOffset() {
<span class="line-modified">164         return (int) VH_fp_offset.get(segment.address());</span>
165     }
166 
167     private void currentFPOffset(int i) {
<span class="line-modified">168         VH_fp_offset.set(segment.address(), i);</span>
169     }
170 
171     private MemoryAddress stackPtr() {
<span class="line-modified">172         return (MemoryAddress) VH_overflow_arg_area.get(segment.address());</span>
173     }
174 
175     private void stackPtr(MemoryAddress ptr) {
<span class="line-modified">176         VH_overflow_arg_area.set(segment.address(), ptr);</span>
177     }
178 
179     private MemorySegment regSaveArea() {
180         return getRegSaveArea(segment);
181     }
182 
183     private static MemorySegment getRegSaveArea(MemorySegment segment) {
<span class="line-modified">184         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.address()),</span>
185             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
186     }
187 
188     private void preAlignStack(MemoryLayout layout) {
189         if (layout.byteAlignment() &gt; 8) {
190             stackPtr(Utils.alignUp(stackPtr(), 16));
191         }
192     }
193 
194     private void postAlignStack(MemoryLayout layout) {
195         stackPtr(Utils.alignUp(stackPtr().addOffset(layout.byteSize()), 8));
196     }
197 
198     @Override
199     public int vargAsInt(MemoryLayout layout) {
200         return (int) read(int.class, layout);
201     }
202 
203     @Override
204     public long vargAsLong(MemoryLayout layout) {
</pre>
<hr />
<pre>
232     private Object read(Class&lt;?&gt; carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {
233         checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);
234         TypeClass typeClass = TypeClass.classifyLayout(layout);
235         if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)
236                 || typeClass.inMemory()) {
237             preAlignStack(layout);
238             return switch (typeClass.kind()) {
239                 case STRUCT -&gt; {
240                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
241                                                                                 segment.ownerThread(), null, null)) {
242                         MemorySegment seg = allocator.allocate(layout);
243                         seg.copyFrom(slice);
244                         postAlignStack(layout);
245                         yield seg;
246                     }
247                 }
248                 case POINTER, INTEGER, FLOAT -&gt; {
249                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
250                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
251                                                                                 segment.ownerThread(), null, null)) {
<span class="line-modified">252                         Object res = reader.get(slice.address());</span>
253                         postAlignStack(layout);
254                         yield res;
255                     }
256                 }
257             };
258         } else {
259             return switch (typeClass.kind()) {
260                 case STRUCT -&gt; {
261                     MemorySegment value = allocator.allocate(layout);
262                     int classIdx = 0;
263                     long offset = 0;
264                     while (offset &lt; layout.byteSize()) {
265                         final long copy = Math.min(layout.byteSize() - offset, 8);
266                         boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
267                         MemorySegment slice = value.asSlice(offset, copy);
268                         if (isSSE) {
269                             slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));
270                             currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
271                         } else {
272                             slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));
273                             currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
274                         }
275                         offset += copy;
276                     }
277                     yield value;
278                 }
279                 case POINTER, INTEGER -&gt; {
280                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">281                     Object res = reader.get(regSaveArea.address().addOffset(currentGPOffset()));</span>
282                     currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
283                     yield res;
284                 }
285                 case FLOAT -&gt; {
286                     VarHandle reader = layout.varHandle(carrier);
<span class="line-modified">287                     Object res = reader.get(regSaveArea.address().addOffset(currentFPOffset()));</span>
288                     currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
289                     yield res;
290                 }
291             };
292         }
293     }
294 
295     @Override
296     public void skip(MemoryLayout... layouts) {
297         for (MemoryLayout layout : layouts) {
298             TypeClass typeClass = TypeClass.classifyLayout(layout);
299             if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {
300                 preAlignStack(layout);
301                 postAlignStack(layout);
302             } else {
303                 currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));
304                 currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));
305             }
306         }
307     }
</pre>
<hr />
<pre>
328     }
329 
330     @Override
331     public VaList copy() {
332         return copy(MemorySegment::allocateNative);
333     }
334 
335     @Override
336     public VaList copy(NativeScope scope) {
337         return copy(SharedUtils.Allocator.ofScope(scope));
338     }
339 
340     private VaList copy(SharedUtils.Allocator allocator) {
341         MemorySegment copy = allocator.allocate(LAYOUT);
342         copy.copyFrom(segment);
343         return new SysVVaList(copy, regSaveArea, List.of());
344     }
345 
346     @Override
347     public MemoryAddress address() {
<span class="line-modified">348         return segment.address();</span>
349     }
350 
351     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {
352         return currentGPOffset &gt; MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE
353                 || currentFPOffset &gt; MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;
354     }
355 
356     @Override
357     public String toString() {
358         return &quot;SysVVaList{&quot;
359                + &quot;gp_offset=&quot; + currentGPOffset()
360                + &quot;, fp_offset=&quot; + currentFPOffset()
361                + &quot;, overflow_arg_area=&quot; + stackPtr()
362                + &quot;, reg_save_area=&quot; + regSaveArea()
363                + &#39;}&#39;;
364     }
365 
366     static class Builder implements CSupport.VaList.Builder {
367         private final SharedUtils.Allocator allocator;
368         private final MemorySegment reg_save_area;
</pre>
<hr />
<pre>
412                     case STRUCT -&gt; {
413                         MemorySegment valueSegment = (MemorySegment) value;
414                         int classIdx = 0;
415                         long offset = 0;
416                         while (offset &lt; layout.byteSize()) {
417                             final long copy = Math.min(layout.byteSize() - offset, 8);
418                             boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;
419                             MemorySegment slice = valueSegment.asSlice(offset, copy);
420                             if (isSSE) {
421                                 reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);
422                                 currentFPOffset += FP_SLOT_SIZE;
423                             } else {
424                                 reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);
425                                 currentGPOffset += GP_SLOT_SIZE;
426                             }
427                             offset += copy;
428                         }
429                     }
430                     case POINTER, INTEGER -&gt; {
431                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">432                         writer.set(reg_save_area.address().addOffset(currentGPOffset), value);</span>
433                         currentGPOffset += GP_SLOT_SIZE;
434                     }
435                     case FLOAT -&gt; {
436                         VarHandle writer = layout.varHandle(carrier);
<span class="line-modified">437                         writer.set(reg_save_area.address().addOffset(currentFPOffset), value);</span>
438                         currentFPOffset += FP_SLOT_SIZE;
439                     }
440                 }
441             }
442             return this;
443         }
444 
445         private boolean isEmpty() {
446             return currentGPOffset == 0 &amp;&amp; currentFPOffset == FP_OFFSET &amp;&amp; stackArgs.isEmpty();
447         }
448 
449         public VaList build() {
450             if (isEmpty()) {
451                 return EMPTY;
452             }
453 
454             MemorySegment vaListSegment = allocator.allocate(LAYOUT);
455             List&lt;MemorySegment&gt; attachedSegments = new ArrayList&lt;&gt;();
456             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
457             if (!stackArgs.isEmpty()) {
458                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -&gt; acc + e.layout.byteSize(), Long::sum);
459                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
<span class="line-modified">460                 MemoryAddress maOverflowArgArea = stackArgsSegment.address();</span>
461                 for (SimpleVaArg arg : stackArgs) {
462                     if (arg.layout.byteSize() &gt; 8) {
463                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
464                     }
465                     if (arg.value instanceof MemorySegment) {
466                         MemorySegment slice
467                             = stackArgsSegment.asSlice(maOverflowArgArea.segmentOffset(), arg.layout.byteSize());
468                         slice.copyFrom((MemorySegment) arg.value);
469                     } else {
470                         VarHandle writer = arg.varHandle();
471                         writer.set(maOverflowArgArea, arg.value);
472                     }
473                     maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
474                 }
<span class="line-modified">475                 stackArgsPtr = stackArgsSegment.address();</span>
476                 attachedSegments.add(stackArgsSegment);
477             }
478 
<span class="line-modified">479             MemoryAddress vaListAddr = vaListSegment.address();</span>
480             VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
481             VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
<span class="line-modified">482             VH_reg_save_area.set(vaListAddr, reg_save_area.address());</span>
483             attachedSegments.add(reg_save_area);
484             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
485             return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
486         }
487     }
488 }
</pre>
</td>
</tr>
</table>
<center><a href="../../aarch64/AArch64VaList.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../windows/WinVaList.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
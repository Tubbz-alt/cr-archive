<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../aarch64/AArch64VaList.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../windows/WinVaList.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 138,52 ***</span>
      private static MemoryAddress emptyListAddress() {
          long ptr = U.allocateMemory(LAYOUT.byteSize());
          MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                  MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -&gt; U.freeMemory(ptr), null);
          cleaner.register(SysVVaList.class, ms::close);
<span class="line-modified">!         MemoryAddress base = ms.baseAddress();</span>
          VH_gp_offset.set(base, MAX_GP_OFFSET);
          VH_fp_offset.set(base, MAX_FP_OFFSET);
          VH_overflow_arg_area.set(base, MemoryAddress.NULL);
          VH_reg_save_area.set(base, MemoryAddress.NULL);
<span class="line-modified">!         return ms.withAccessModes(0).baseAddress();</span>
      }
  
      public static CSupport.VaList empty() {
          return EMPTY;
      }
  
      private int currentGPOffset() {
<span class="line-modified">!         return (int) VH_gp_offset.get(segment.baseAddress());</span>
      }
  
      private void currentGPOffset(int i) {
<span class="line-modified">!         VH_gp_offset.set(segment.baseAddress(), i);</span>
      }
  
      private int currentFPOffset() {
<span class="line-modified">!         return (int) VH_fp_offset.get(segment.baseAddress());</span>
      }
  
      private void currentFPOffset(int i) {
<span class="line-modified">!         VH_fp_offset.set(segment.baseAddress(), i);</span>
      }
  
      private MemoryAddress stackPtr() {
<span class="line-modified">!         return (MemoryAddress) VH_overflow_arg_area.get(segment.baseAddress());</span>
      }
  
      private void stackPtr(MemoryAddress ptr) {
<span class="line-modified">!         VH_overflow_arg_area.set(segment.baseAddress(), ptr);</span>
      }
  
      private MemorySegment regSaveArea() {
          return getRegSaveArea(segment);
      }
  
      private static MemorySegment getRegSaveArea(MemorySegment segment) {
<span class="line-modified">!         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.baseAddress()),</span>
              LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
      }
  
      private void preAlignStack(MemoryLayout layout) {
          if (layout.byteAlignment() &gt; 8) {
<span class="line-new-header">--- 138,52 ---</span>
      private static MemoryAddress emptyListAddress() {
          long ptr = U.allocateMemory(LAYOUT.byteSize());
          MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                  MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -&gt; U.freeMemory(ptr), null);
          cleaner.register(SysVVaList.class, ms::close);
<span class="line-modified">!         MemoryAddress base = ms.address();</span>
          VH_gp_offset.set(base, MAX_GP_OFFSET);
          VH_fp_offset.set(base, MAX_FP_OFFSET);
          VH_overflow_arg_area.set(base, MemoryAddress.NULL);
          VH_reg_save_area.set(base, MemoryAddress.NULL);
<span class="line-modified">!         return ms.withAccessModes(0).address();</span>
      }
  
      public static CSupport.VaList empty() {
          return EMPTY;
      }
  
      private int currentGPOffset() {
<span class="line-modified">!         return (int) VH_gp_offset.get(segment.address());</span>
      }
  
      private void currentGPOffset(int i) {
<span class="line-modified">!         VH_gp_offset.set(segment.address(), i);</span>
      }
  
      private int currentFPOffset() {
<span class="line-modified">!         return (int) VH_fp_offset.get(segment.address());</span>
      }
  
      private void currentFPOffset(int i) {
<span class="line-modified">!         VH_fp_offset.set(segment.address(), i);</span>
      }
  
      private MemoryAddress stackPtr() {
<span class="line-modified">!         return (MemoryAddress) VH_overflow_arg_area.get(segment.address());</span>
      }
  
      private void stackPtr(MemoryAddress ptr) {
<span class="line-modified">!         VH_overflow_arg_area.set(segment.address(), ptr);</span>
      }
  
      private MemorySegment regSaveArea() {
          return getRegSaveArea(segment);
      }
  
      private static MemorySegment getRegSaveArea(MemorySegment segment) {
<span class="line-modified">!         return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.address()),</span>
              LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
      }
  
      private void preAlignStack(MemoryLayout layout) {
          if (layout.byteAlignment() &gt; 8) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,11 ***</span>
                  }
                  case POINTER, INTEGER, FLOAT -&gt; {
                      VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                      try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                  segment.ownerThread(), null, null)) {
<span class="line-modified">!                         Object res = reader.get(slice.baseAddress());</span>
                          postAlignStack(layout);
                          yield res;
                      }
                  }
              };
<span class="line-new-header">--- 247,11 ---</span>
                  }
                  case POINTER, INTEGER, FLOAT -&gt; {
                      VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                      try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                  segment.ownerThread(), null, null)) {
<span class="line-modified">!                         Object res = reader.get(slice.address());</span>
                          postAlignStack(layout);
                          yield res;
                      }
                  }
              };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,17 ***</span>
                      }
                      yield value;
                  }
                  case POINTER, INTEGER -&gt; {
                      VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">!                     Object res = reader.get(regSaveArea.baseAddress().addOffset(currentGPOffset()));</span>
                      currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
                      yield res;
                  }
                  case FLOAT -&gt; {
                      VarHandle reader = layout.varHandle(carrier);
<span class="line-modified">!                     Object res = reader.get(regSaveArea.baseAddress().addOffset(currentFPOffset()));</span>
                      currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
                      yield res;
                  }
              };
          }
<span class="line-new-header">--- 276,17 ---</span>
                      }
                      yield value;
                  }
                  case POINTER, INTEGER -&gt; {
                      VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">!                     Object res = reader.get(regSaveArea.address().addOffset(currentGPOffset()));</span>
                      currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
                      yield res;
                  }
                  case FLOAT -&gt; {
                      VarHandle reader = layout.varHandle(carrier);
<span class="line-modified">!                     Object res = reader.get(regSaveArea.address().addOffset(currentFPOffset()));</span>
                      currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
                      yield res;
                  }
              };
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,11 ***</span>
          return new SysVVaList(copy, regSaveArea, List.of());
      }
  
      @Override
      public MemoryAddress address() {
<span class="line-modified">!         return segment.baseAddress();</span>
      }
  
      private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {
          return currentGPOffset &gt; MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE
                  || currentFPOffset &gt; MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;
<span class="line-new-header">--- 343,11 ---</span>
          return new SysVVaList(copy, regSaveArea, List.of());
      }
  
      @Override
      public MemoryAddress address() {
<span class="line-modified">!         return segment.address();</span>
      }
  
      private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {
          return currentGPOffset &gt; MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE
                  || currentFPOffset &gt; MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,16 ***</span>
                              offset += copy;
                          }
                      }
                      case POINTER, INTEGER -&gt; {
                          VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">!                         writer.set(reg_save_area.baseAddress().addOffset(currentGPOffset), value);</span>
                          currentGPOffset += GP_SLOT_SIZE;
                      }
                      case FLOAT -&gt; {
                          VarHandle writer = layout.varHandle(carrier);
<span class="line-modified">!                         writer.set(reg_save_area.baseAddress().addOffset(currentFPOffset), value);</span>
                          currentFPOffset += FP_SLOT_SIZE;
                      }
                  }
              }
              return this;
<span class="line-new-header">--- 427,16 ---</span>
                              offset += copy;
                          }
                      }
                      case POINTER, INTEGER -&gt; {
                          VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
<span class="line-modified">!                         writer.set(reg_save_area.address().addOffset(currentGPOffset), value);</span>
                          currentGPOffset += GP_SLOT_SIZE;
                      }
                      case FLOAT -&gt; {
                          VarHandle writer = layout.varHandle(carrier);
<span class="line-modified">!                         writer.set(reg_save_area.address().addOffset(currentFPOffset), value);</span>
                          currentFPOffset += FP_SLOT_SIZE;
                      }
                  }
              }
              return this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,11 ***</span>
              List&lt;MemorySegment&gt; attachedSegments = new ArrayList&lt;&gt;();
              MemoryAddress stackArgsPtr = MemoryAddress.NULL;
              if (!stackArgs.isEmpty()) {
                  long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -&gt; acc + e.layout.byteSize(), Long::sum);
                  MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
<span class="line-modified">!                 MemoryAddress maOverflowArgArea = stackArgsSegment.baseAddress();</span>
                  for (SimpleVaArg arg : stackArgs) {
                      if (arg.layout.byteSize() &gt; 8) {
                          maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                      }
                      if (arg.value instanceof MemorySegment) {
<span class="line-new-header">--- 455,11 ---</span>
              List&lt;MemorySegment&gt; attachedSegments = new ArrayList&lt;&gt;();
              MemoryAddress stackArgsPtr = MemoryAddress.NULL;
              if (!stackArgs.isEmpty()) {
                  long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -&gt; acc + e.layout.byteSize(), Long::sum);
                  MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
<span class="line-modified">!                 MemoryAddress maOverflowArgArea = stackArgsSegment.address();</span>
                  for (SimpleVaArg arg : stackArgs) {
                      if (arg.layout.byteSize() &gt; 8) {
                          maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                      }
                      if (arg.value instanceof MemorySegment) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,18 ***</span>
                          VarHandle writer = arg.varHandle();
                          writer.set(maOverflowArgArea, arg.value);
                      }
                      maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
                  }
<span class="line-modified">!                 stackArgsPtr = stackArgsSegment.baseAddress();</span>
                  attachedSegments.add(stackArgsSegment);
              }
  
<span class="line-modified">!             MemoryAddress vaListAddr = vaListSegment.baseAddress();</span>
              VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
              VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
<span class="line-modified">!             VH_reg_save_area.set(vaListAddr, reg_save_area.baseAddress());</span>
              attachedSegments.add(reg_save_area);
              assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
              return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
          }
      }
<span class="line-new-header">--- 470,18 ---</span>
                          VarHandle writer = arg.varHandle();
                          writer.set(maOverflowArgArea, arg.value);
                      }
                      maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
                  }
<span class="line-modified">!                 stackArgsPtr = stackArgsSegment.address();</span>
                  attachedSegments.add(stackArgsSegment);
              }
  
<span class="line-modified">!             MemoryAddress vaListAddr = vaListSegment.address();</span>
              VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
              VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
<span class="line-modified">!             VH_reg_save_area.set(vaListAddr, reg_save_area.address());</span>
              attachedSegments.add(reg_save_area);
              assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
              return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
          }
      }
</pre>
<center><a href="../../aarch64/AArch64VaList.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../windows/WinVaList.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
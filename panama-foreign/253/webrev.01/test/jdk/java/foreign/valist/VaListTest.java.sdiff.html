<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../TestVarHandleCombinators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
187                               MemoryLayout doubleLayout) {
188         try (VaList vaList = vaListFactory.apply(b -&gt;
189                 b.vargFromDouble(doubleLayout, 3.0D)
190                  .vargFromDouble(doubleLayout, 4.0D)
191                  .vargFromDouble(doubleLayout, 5.0D))) {
192             double x = sumDoubles.apply(3, vaList);
193             assertEquals(x, 12.0D);
194         }
195     }
196 
197     @DataProvider
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public static Object[][] pointers() {
200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
201             list -&gt; {
202                 MemoryAddress ma = list.vargAsAddress(layout);
203                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
204                         4, Thread.currentThread(), null, null);
<span class="line-modified">205                 return MemoryAccess.getInt(accessibleSegment.baseAddress());</span>
206             };
207         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
208         return new Object[][]{
209             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
210             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
211             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
212             { platformVaListFactory, getIntNative,                            C_POINTER         },
213         };
214     }
215 
216     @Test(dataProvider = &quot;pointers&quot;)
217     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
218                                         Function&lt;VaList, Integer&gt; getFromPointer,
219                                         MemoryLayout pointerLayout) {
220         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">221             MemoryAccess.setInt(msInt.baseAddress(), 10);</span>
<span class="line-modified">222             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {</span>
223                 int x = getFromPointer.apply(vaList);
224                 assertEquals(x, 10);
225             }
226         }
227     }
228 
229     interface TriFunction&lt;S, T, U, R&gt; {
230         R apply(S s, T t, U u);
231     }
232 
233     @DataProvider
234     @SuppressWarnings(&quot;unchecked&quot;)
235     public static Object[][] structs() {
236         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
237             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
238                 list -&gt; {
239                     MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">240                     int x = (int) VH_Point_x.get(struct.baseAddress());</span>
<span class="line-modified">241                     int y = (int) VH_Point_y.get(struct.baseAddress());</span>
242                     return x + y;
243                 };
244 
245         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
246             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
247                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
248 
249         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
250                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
251             = (vaListFact, intLayout, sumStructFact) -&gt; {
252                 GroupLayout pointLayout =  MemoryLayout.ofStruct(
253                     intLayout.withName(&quot;x&quot;),
254                     intLayout.withName(&quot;y&quot;)
255                 );
256                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));
257                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));
258                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
259                                       pointLayout, VH_Point_x, VH_Point_y  };
260             };
261         return new Object[][]{
262             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
263             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
264             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
265             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
266         };
267     }
268 
269     @Test(dataProvider = &quot;structs&quot;)
270     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
271                            Function&lt;VaList, Integer&gt; sumStruct,
272                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
273         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">274             VH_Point_x.set(struct.baseAddress(), 5);</span>
<span class="line-modified">275             VH_Point_y.set(struct.baseAddress(), 10);</span>
276 
277             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
278                 int sum = sumStruct.apply(vaList);
279                 assertEquals(sum, 15);
280             }
281         }
282     }
283 
284     @DataProvider
285     @SuppressWarnings(&quot;unchecked&quot;)
286     public static Object[][] bigStructs() {
287         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
288             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;
289                 list -&gt; {
290                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">291                     long x = (long) VH_BigPoint_x.get(struct.baseAddress());</span>
<span class="line-modified">292                     long y = (long) VH_BigPoint_y.get(struct.baseAddress());</span>
293                     return x + y;
294                 };
295 
296         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
297             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;
298                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
299 
300         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
301                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
302             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
303                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
304                     longLongLayout.withName(&quot;x&quot;),
305                     longLongLayout.withName(&quot;y&quot;)
306                 );
307                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
308                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
309                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
310                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
311             };
312         return new Object[][]{
313             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
314             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
315             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
316             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
317         };
318     }
319 
320     @Test(dataProvider = &quot;bigStructs&quot;)
321     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
322                               Function&lt;VaList, Long&gt; sumBigStruct,
323                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
324         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">325             VH_BigPoint_x.set(struct.baseAddress(), 5);</span>
<span class="line-modified">326             VH_BigPoint_y.set(struct.baseAddress(), 10);</span>
327 
328             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
329                 long sum = sumBigStruct.apply(vaList);
330                 assertEquals(sum, 15);
331             }
332         }
333     }
334 
335     @DataProvider
336     @SuppressWarnings(&quot;unchecked&quot;)
337     public static Object[][] floatStructs() {
338         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
339             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
340                 list -&gt; {
341                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">342                     float x = (float) VH_FloatPoint_x.get(struct.baseAddress());</span>
<span class="line-modified">343                     float y = (float) VH_FloatPoint_y.get(struct.baseAddress());</span>
344                     return x + y;
345                 };
346 
347         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
348             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
349                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
350 
351         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
352                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
353             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {
354                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
355                     floatLayout.withName(&quot;x&quot;),
356                     floatLayout.withName(&quot;y&quot;)
357                 );
358                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
359                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
360                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
361                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
362             };
363         return new Object[][]{
364             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
365             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
366             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
367             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
368         };
369     }
370 
371     @Test(dataProvider = &quot;floatStructs&quot;)
372     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
373                                 Function&lt;VaList, Float&gt; sumFloatStruct,
374                                 MemoryLayout FloatPoint_LAYOUT,
375                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
376         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">377             VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);</span>
<span class="line-modified">378             VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);</span>
379 
380             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
381                 float sum = sumFloatStruct.apply(vaList);
382                 assertEquals(sum, 4.376f, 0.00001f);
383             }
384         }
385     }
386 
387     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {
388         R apply(T0 t0, T1 t1, T2 t2, T3 t3);
389     }
390 
391     @DataProvider
392     @SuppressWarnings(&quot;unchecked&quot;)
393     public static Object[][] hugeStructs() {
394         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
395             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
396                 list -&gt; {
397                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">398                     long x = (long) VH_HugePoint_x.get(struct.baseAddress());</span>
<span class="line-modified">399                     long y = (long) VH_HugePoint_y.get(struct.baseAddress());</span>
<span class="line-modified">400                     long z = (long) VH_HugePoint_z.get(struct.baseAddress());</span>
401                     return x + y + z;
402                 };
403 
404         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
405             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
406                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
407 
408         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
409                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
410             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
411                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
412                     longLongLayout.withName(&quot;x&quot;),
413                     longLongLayout.withName(&quot;y&quot;),
414                     longLongLayout.withName(&quot;z&quot;)
415                 );
416                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
417                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
418                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
419                 return new Object[] { vaListFact,
420                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
421                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
422             };
423         return new Object[][]{
424             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
425             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
426             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
427             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
428         };
429     }
430 
431     @Test(dataProvider = &quot;hugeStructs&quot;)
432     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
433                                Function&lt;VaList, Long&gt; sumHugeStruct,
434                                MemoryLayout HugePoint_LAYOUT,
435                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
436         // On AArch64 a struct needs to be larger than 16 bytes to be
437         // passed by reference.
438         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">439             VH_HugePoint_x.set(struct.baseAddress(), 1);</span>
<span class="line-modified">440             VH_HugePoint_y.set(struct.baseAddress(), 2);</span>
<span class="line-modified">441             VH_HugePoint_z.set(struct.baseAddress(), 3);</span>
442 
443             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
444                 long sum = sumHugeStruct.apply(vaList);
445                 assertEquals(sum, 6);
446             }
447         }
448     }
449 
450     public interface SumStackFunc {
451         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);
452     }
453 
454     @DataProvider
455     public static Object[][] sumStack() {
456         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
457             (longSum, doubleSum, list) -&gt; {
458                 long lSum = 0L;
459                 for (int i = 0; i &lt; 16; i++) {
460                     lSum += list.vargAsLong(longLayout);
461                 }
</pre>
<hr />
<pre>
465                     dSum += list.vargAsDouble(doubleLayout);
466                 }
467                 MemoryAccess.setDouble(doubleSum, dSum);
468             };
469         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);
470         return new Object[][]{
471             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
472             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
473             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
474             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
475         };
476     }
477 
478     @Test(dataProvider = &quot;sumStack&quot;)
479     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
480                           SumStackFunc sumStack,
481                           MemoryLayout longLayout,
482                           MemoryLayout doubleLayout) {
483        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
484             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
<span class="line-modified">485             MemoryAccess.setLong(longSum.baseAddress(), 0L);</span>
<span class="line-modified">486             MemoryAccess.setDouble(doubleSum.baseAddress(), 0D);</span>
487 
488             VaList list = vaListFactory.apply(b -&gt; {
489                 for (long l = 1; l &lt;= 16L; l++) {
490                     b.vargFromLong(longLayout, l);
491                 }
492                 for (double d = 1; d &lt;= 16D; d++) {
493                     b.vargFromDouble(doubleLayout, d);
494                 }
495             });
496 
497             try (list) {
<span class="line-modified">498                 sumStack.invoke(longSum.baseAddress(), doubleSum.baseAddress(), list);</span>
499             }
500 
<span class="line-modified">501             long lSum = MemoryAccess.getLong(longSum.baseAddress());</span>
<span class="line-modified">502             double dSum = MemoryAccess.getDouble(doubleSum.baseAddress());</span>
503 
504             assertEquals(lSum, 136L);
505             assertEquals(dSum, 136D);
506         }
507     }
508 
509     @Test(dataProvider = &quot;upcalls&quot;)
510     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
511         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
512         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
<span class="line-modified">513             target.invokeExact(stub.baseAddress());</span>
514         }
515     }
516 
517     @DataProvider
518     public Object[][] emptyVaLists() {
519         return new Object[][] {
520             { Windowsx64Linker.emptyVaList()      },
521             { winVaListFactory.apply(b -&gt; {})     },
522             { SysVx64Linker.emptyVaList()         },
523             { sysvVaListFactory.apply(b -&gt; {})    },
524             { AArch64Linker.emptyVaList()         },
525             { aarch64VaListFactory.apply(b -&gt; {}) },
526         };
527     }
528 
529     @Test(expectedExceptions = UnsupportedOperationException.class,
530           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,
531           dataProvider = &quot;emptyVaLists&quot;)
532     public void testEmptyNotCloseable(VaList emptyList) {
533         emptyList.close();
</pre>
<hr />
<pre>
554                                  MemoryLayout intLayout) {
555         VaList listLeaked;
556         try (NativeScope scope = NativeScope.unboundedScope()) {
557             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
558                                                     .vargFromInt(intLayout, 8),
559                                                scope);
560             int x = sumInts.apply(2, list);
561             assertEquals(x, 12);
562             listLeaked = list;
563         }
564         assertFalse(listLeaked.isAlive());
565     }
566 
567     @Test(dataProvider = &quot;structs&quot;)
568     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
569                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored
570                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
571         MemorySegment pointOut;
572         try (NativeScope scope = NativeScope.unboundedScope()) {
573             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">574                 VH_Point_x.set(pointIn.baseAddress(), 3);</span>
<span class="line-modified">575                 VH_Point_y.set(pointIn.baseAddress(), 6);</span>
576                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
577                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">578                     assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);</span>
<span class="line-modified">579                     assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);</span>
580                 }
581                 assertTrue(pointOut.isAlive()); // after VaList freed
582             }
583             assertTrue(pointOut.isAlive()); // after input MS freed
584         }
585         assertFalse(pointOut.isAlive()); // after scope freed
586     }
587 
588     @DataProvider
589     public Object[][] copy() {
590         return new Object[][] {
591             { winVaListFactory,      Win64.C_INT   },
592             { sysvVaListFactory,     SysV.C_INT    },
593             { aarch64VaListFactory,  AArch64.C_INT },
594         };
595     }
596 
597     @Test(dataProvider = &quot;copy&quot;)
598     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
599         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
</pre>
<hr />
<pre>
670         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
671         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
672         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
673             C_FLOAT.withName(&quot;x&quot;),
674             C_FLOAT.withName(&quot;y&quot;)
675         );
676         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
677         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
678         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
679             C_LONGLONG.withName(&quot;x&quot;),
680             C_LONGLONG.withName(&quot;y&quot;),
681             C_LONGLONG.withName(&quot;z&quot;)
682         );
683         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
684         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
685         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
686 
687         return new Object[][]{
688             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
689                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">690                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);</span>
<span class="line-modified">691                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);</span>
692                 }
693             })},
694             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
695                 VaList copy = vaList.copy();
696                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">697                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);</span>
<span class="line-modified">698                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);</span>
699 
<span class="line-modified">700                     VH_BigPoint_x.set(struct.baseAddress(), 0);</span>
<span class="line-modified">701                     VH_BigPoint_y.set(struct.baseAddress(), 0);</span>
702                 }
703 
704                 // should be independent
705                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">706                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);</span>
<span class="line-modified">707                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);</span>
708                 }
709             })},
710             { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {
711                 try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
<span class="line-modified">712                     assertEquals((int) VH_Point_x.get(struct.baseAddress()), 5);</span>
<span class="line-modified">713                     assertEquals((int) VH_Point_y.get(struct.baseAddress()), 10);</span>
714                 }
715             })},
716             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {
717                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
<span class="line-modified">718                     assertEquals((long) VH_HugePoint_x.get(struct.baseAddress()), 1);</span>
<span class="line-modified">719                     assertEquals((long) VH_HugePoint_y.get(struct.baseAddress()), 2);</span>
<span class="line-modified">720                     assertEquals((long) VH_HugePoint_z.get(struct.baseAddress()), 3);</span>
721                 }
722             })},
723             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {
724                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
<span class="line-modified">725                     assertEquals((float) VH_FloatPoint_x.get(struct.baseAddress()), 1.0f);</span>
<span class="line-modified">726                     assertEquals((float) VH_FloatPoint_y.get(struct.baseAddress()), 2.0f);</span>
727                 }
728             })},
729             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
730                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
731                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
732                                                                     Thread.currentThread(), null, null);
<span class="line-modified">733                 int x = MemoryAccess.getInt(ms.baseAddress());</span>
734                 assertEquals(x, 10);
735             })},
736             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
737                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
738                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
739                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
740             })},
741             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {
742                 assertEquals(vaList.vargAsInt(C_INT), 10);
743                 assertEquals(vaList.vargAsInt(C_INT), 15);
744                 assertEquals(vaList.vargAsInt(C_INT), 20);
745             })},
746             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
747                 // skip all registers
748                 for (long l = 1; l &lt;= 16; l++) {
749                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);
750                 }
751                 for (double d = 1; d &lt;= 16; d++) {
752                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
753                 }
754 
755                 // test some arbitrary values on the stack
756                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
757                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
758                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
759                 assertEquals(vaList.vargAsInt(C_INT), 4);
760                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
761                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
762                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
763                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
764                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);
765                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
766                 assertEquals(vaList.vargAsInt(C_INT), 11);
767                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
768                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
769                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
770 
771                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
<span class="line-modified">772                     assertEquals((int) VH_Point_x.get(point.baseAddress()), 5);</span>
<span class="line-modified">773                     assertEquals((int) VH_Point_y.get(point.baseAddress()), 10);</span>
774                 }
775 
776                 VaList copy = vaList.copy();
777                 try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">778                     assertEquals((long) VH_BigPoint_x.get(bigPoint.baseAddress()), 15);</span>
<span class="line-modified">779                     assertEquals((long) VH_BigPoint_y.get(bigPoint.baseAddress()), 20);</span>
780 
<span class="line-modified">781                     VH_BigPoint_x.set(bigPoint.baseAddress(), 0);</span>
<span class="line-modified">782                     VH_BigPoint_y.set(bigPoint.baseAddress(), 0);</span>
783                 }
784 
785                 // should be independent
786                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">787                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 15);</span>
<span class="line-modified">788                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 20);</span>
789                 }
790             })},
791             // test skip
792             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
793                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
794                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
795                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
796                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
797                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
798                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
799                 vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
800                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
801             })},
802         };
803     }
804 
805     interface VaListConsumer {
806         void accept(CSupport.VaList list);
807 
808         static MethodHandle mh(VaListConsumer instance) {
</pre>
</td>
<td>
<hr />
<pre>
185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,
187                               MemoryLayout doubleLayout) {
188         try (VaList vaList = vaListFactory.apply(b -&gt;
189                 b.vargFromDouble(doubleLayout, 3.0D)
190                  .vargFromDouble(doubleLayout, 4.0D)
191                  .vargFromDouble(doubleLayout, 5.0D))) {
192             double x = sumDoubles.apply(3, vaList);
193             assertEquals(x, 12.0D);
194         }
195     }
196 
197     @DataProvider
198     @SuppressWarnings(&quot;unchecked&quot;)
199     public static Object[][] pointers() {
200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
201             list -&gt; {
202                 MemoryAddress ma = list.vargAsAddress(layout);
203                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
204                         4, Thread.currentThread(), null, null);
<span class="line-modified">205                 return MemoryAccess.getInt(accessibleSegment.address());</span>
206             };
207         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
208         return new Object[][]{
209             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
210             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
211             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
212             { platformVaListFactory, getIntNative,                            C_POINTER         },
213         };
214     }
215 
216     @Test(dataProvider = &quot;pointers&quot;)
217     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
218                                         Function&lt;VaList, Integer&gt; getFromPointer,
219                                         MemoryLayout pointerLayout) {
220         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
<span class="line-modified">221             MemoryAccess.setInt(msInt.address(), 10);</span>
<span class="line-modified">222             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.address()))) {</span>
223                 int x = getFromPointer.apply(vaList);
224                 assertEquals(x, 10);
225             }
226         }
227     }
228 
229     interface TriFunction&lt;S, T, U, R&gt; {
230         R apply(S s, T t, U u);
231     }
232 
233     @DataProvider
234     @SuppressWarnings(&quot;unchecked&quot;)
235     public static Object[][] structs() {
236         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
237             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
238                 list -&gt; {
239                     MemorySegment struct = list.vargAsSegment(pointLayout);
<span class="line-modified">240                     int x = (int) VH_Point_x.get(struct.address());</span>
<span class="line-modified">241                     int y = (int) VH_Point_y.get(struct.address());</span>
242                     return x + y;
243                 };
244 
245         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact
246             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
247                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);
248 
249         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
250                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact
251             = (vaListFact, intLayout, sumStructFact) -&gt; {
252                 GroupLayout pointLayout =  MemoryLayout.ofStruct(
253                     intLayout.withName(&quot;x&quot;),
254                     intLayout.withName(&quot;y&quot;)
255                 );
256                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));
257                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));
258                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),
259                                       pointLayout, VH_Point_x, VH_Point_y  };
260             };
261         return new Object[][]{
262             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),
263             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),
264             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
265             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
266         };
267     }
268 
269     @Test(dataProvider = &quot;structs&quot;)
270     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
271                            Function&lt;VaList, Integer&gt; sumStruct,
272                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
273         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">274             VH_Point_x.set(struct.address(), 5);</span>
<span class="line-modified">275             VH_Point_y.set(struct.address(), 10);</span>
276 
277             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
278                 int sum = sumStruct.apply(vaList);
279                 assertEquals(sum, 15);
280             }
281         }
282     }
283 
284     @DataProvider
285     @SuppressWarnings(&quot;unchecked&quot;)
286     public static Object[][] bigStructs() {
287         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
288             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;
289                 list -&gt; {
290                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
<span class="line-modified">291                     long x = (long) VH_BigPoint_x.get(struct.address());</span>
<span class="line-modified">292                     long y = (long) VH_BigPoint_y.get(struct.address());</span>
293                     return x + y;
294                 };
295 
296         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
297             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;
298                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);
299 
300         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
301                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
302             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
303                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(
304                     longLongLayout.withName(&quot;x&quot;),
305                     longLongLayout.withName(&quot;y&quot;)
306                 );
307                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
308                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
309                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),
310                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };
311             };
312         return new Object[][]{
313             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
314             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
315             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
316             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
317         };
318     }
319 
320     @Test(dataProvider = &quot;bigStructs&quot;)
321     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
322                               Function&lt;VaList, Long&gt; sumBigStruct,
323                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
324         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
<span class="line-modified">325             VH_BigPoint_x.set(struct.address(), 5);</span>
<span class="line-modified">326             VH_BigPoint_y.set(struct.address(), 10);</span>
327 
328             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
329                 long sum = sumBigStruct.apply(vaList);
330                 assertEquals(sum, 15);
331             }
332         }
333     }
334 
335     @DataProvider
336     @SuppressWarnings(&quot;unchecked&quot;)
337     public static Object[][] floatStructs() {
338         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
339             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
340                 list -&gt; {
341                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
<span class="line-modified">342                     float x = (float) VH_FloatPoint_x.get(struct.address());</span>
<span class="line-modified">343                     float y = (float) VH_FloatPoint_y.get(struct.address());</span>
344                     return x + y;
345                 };
346 
347         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact
348             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
349                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);
350 
351         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
352                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact
353             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {
354                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
355                     floatLayout.withName(&quot;x&quot;),
356                     floatLayout.withName(&quot;y&quot;)
357                 );
358                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
359                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
360                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),
361                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };
362             };
363         return new Object[][]{
364             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),
365             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),
366             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
367             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
368         };
369     }
370 
371     @Test(dataProvider = &quot;floatStructs&quot;)
372     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
373                                 Function&lt;VaList, Float&gt; sumFloatStruct,
374                                 MemoryLayout FloatPoint_LAYOUT,
375                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
376         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
<span class="line-modified">377             VH_FloatPoint_x.set(struct.address(), 1.234f);</span>
<span class="line-modified">378             VH_FloatPoint_y.set(struct.address(), 3.142f);</span>
379 
380             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
381                 float sum = sumFloatStruct.apply(vaList);
382                 assertEquals(sum, 4.376f, 0.00001f);
383             }
384         }
385     }
386 
387     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {
388         R apply(T0 t0, T1 t1, T2 t2, T3 t3);
389     }
390 
391     @DataProvider
392     @SuppressWarnings(&quot;unchecked&quot;)
393     public static Object[][] hugeStructs() {
394         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
395             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
396                 list -&gt; {
397                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
<span class="line-modified">398                     long x = (long) VH_HugePoint_x.get(struct.address());</span>
<span class="line-modified">399                     long y = (long) VH_HugePoint_y.get(struct.address());</span>
<span class="line-modified">400                     long z = (long) VH_HugePoint_z.get(struct.address());</span>
401                     return x + y + z;
402                 };
403 
404         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact
405             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
406                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);
407 
408         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,
409                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact
410             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {
411                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
412                     longLongLayout.withName(&quot;x&quot;),
413                     longLongLayout.withName(&quot;y&quot;),
414                     longLongLayout.withName(&quot;z&quot;)
415                 );
416                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
417                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
418                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
419                 return new Object[] { vaListFact,
420                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),
421                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };
422             };
423         return new Object[][]{
424             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),
425             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),
426             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
427             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
428         };
429     }
430 
431     @Test(dataProvider = &quot;hugeStructs&quot;)
432     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
433                                Function&lt;VaList, Long&gt; sumHugeStruct,
434                                MemoryLayout HugePoint_LAYOUT,
435                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
436         // On AArch64 a struct needs to be larger than 16 bytes to be
437         // passed by reference.
438         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
<span class="line-modified">439             VH_HugePoint_x.set(struct.address(), 1);</span>
<span class="line-modified">440             VH_HugePoint_y.set(struct.address(), 2);</span>
<span class="line-modified">441             VH_HugePoint_z.set(struct.address(), 3);</span>
442 
443             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {
444                 long sum = sumHugeStruct.apply(vaList);
445                 assertEquals(sum, 6);
446             }
447         }
448     }
449 
450     public interface SumStackFunc {
451         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);
452     }
453 
454     @DataProvider
455     public static Object[][] sumStack() {
456         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;
457             (longSum, doubleSum, list) -&gt; {
458                 long lSum = 0L;
459                 for (int i = 0; i &lt; 16; i++) {
460                     lSum += list.vargAsLong(longLayout);
461                 }
</pre>
<hr />
<pre>
465                     dSum += list.vargAsDouble(doubleLayout);
466                 }
467                 MemoryAccess.setDouble(doubleSum, dSum);
468             };
469         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);
470         return new Object[][]{
471             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },
472             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },
473             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },
474             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },
475         };
476     }
477 
478     @Test(dataProvider = &quot;sumStack&quot;)
479     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
480                           SumStackFunc sumStack,
481                           MemoryLayout longLayout,
482                           MemoryLayout doubleLayout) {
483        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
484             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
<span class="line-modified">485             MemoryAccess.setLong(longSum.address(), 0L);</span>
<span class="line-modified">486             MemoryAccess.setDouble(doubleSum.address(), 0D);</span>
487 
488             VaList list = vaListFactory.apply(b -&gt; {
489                 for (long l = 1; l &lt;= 16L; l++) {
490                     b.vargFromLong(longLayout, l);
491                 }
492                 for (double d = 1; d &lt;= 16D; d++) {
493                     b.vargFromDouble(doubleLayout, d);
494                 }
495             });
496 
497             try (list) {
<span class="line-modified">498                 sumStack.invoke(longSum.address(), doubleSum.address(), list);</span>
499             }
500 
<span class="line-modified">501             long lSum = MemoryAccess.getLong(longSum.address());</span>
<span class="line-modified">502             double dSum = MemoryAccess.getDouble(doubleSum.address());</span>
503 
504             assertEquals(lSum, 136L);
505             assertEquals(dSum, 136D);
506         }
507     }
508 
509     @Test(dataProvider = &quot;upcalls&quot;)
510     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
511         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
512         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
<span class="line-modified">513             target.invokeExact(stub.address());</span>
514         }
515     }
516 
517     @DataProvider
518     public Object[][] emptyVaLists() {
519         return new Object[][] {
520             { Windowsx64Linker.emptyVaList()      },
521             { winVaListFactory.apply(b -&gt; {})     },
522             { SysVx64Linker.emptyVaList()         },
523             { sysvVaListFactory.apply(b -&gt; {})    },
524             { AArch64Linker.emptyVaList()         },
525             { aarch64VaListFactory.apply(b -&gt; {}) },
526         };
527     }
528 
529     @Test(expectedExceptions = UnsupportedOperationException.class,
530           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,
531           dataProvider = &quot;emptyVaLists&quot;)
532     public void testEmptyNotCloseable(VaList emptyList) {
533         emptyList.close();
</pre>
<hr />
<pre>
554                                  MemoryLayout intLayout) {
555         VaList listLeaked;
556         try (NativeScope scope = NativeScope.unboundedScope()) {
557             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
558                                                     .vargFromInt(intLayout, 8),
559                                                scope);
560             int x = sumInts.apply(2, list);
561             assertEquals(x, 12);
562             listLeaked = list;
563         }
564         assertFalse(listLeaked.isAlive());
565     }
566 
567     @Test(dataProvider = &quot;structs&quot;)
568     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
569                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored
570                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
571         MemorySegment pointOut;
572         try (NativeScope scope = NativeScope.unboundedScope()) {
573             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
<span class="line-modified">574                 VH_Point_x.set(pointIn.address(), 3);</span>
<span class="line-modified">575                 VH_Point_y.set(pointIn.address(), 6);</span>
576                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {
577                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
<span class="line-modified">578                     assertEquals((int) VH_Point_x.get(pointOut.address()), 3);</span>
<span class="line-modified">579                     assertEquals((int) VH_Point_y.get(pointOut.address()), 6);</span>
580                 }
581                 assertTrue(pointOut.isAlive()); // after VaList freed
582             }
583             assertTrue(pointOut.isAlive()); // after input MS freed
584         }
585         assertFalse(pointOut.isAlive()); // after scope freed
586     }
587 
588     @DataProvider
589     public Object[][] copy() {
590         return new Object[][] {
591             { winVaListFactory,      Win64.C_INT   },
592             { sysvVaListFactory,     SysV.C_INT    },
593             { aarch64VaListFactory,  AArch64.C_INT },
594         };
595     }
596 
597     @Test(dataProvider = &quot;copy&quot;)
598     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {
599         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)
</pre>
<hr />
<pre>
670         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));
671         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));
672         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(
673             C_FLOAT.withName(&quot;x&quot;),
674             C_FLOAT.withName(&quot;y&quot;)
675         );
676         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));
677         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));
678         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(
679             C_LONGLONG.withName(&quot;x&quot;),
680             C_LONGLONG.withName(&quot;y&quot;),
681             C_LONGLONG.withName(&quot;z&quot;)
682         );
683         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));
684         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));
685         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));
686 
687         return new Object[][]{
688             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
689                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">690                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">691                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
692                 }
693             })},
694             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
695                 VaList copy = vaList.copy();
696                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">697                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">698                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
699 
<span class="line-modified">700                     VH_BigPoint_x.set(struct.address(), 0);</span>
<span class="line-modified">701                     VH_BigPoint_y.set(struct.address(), 0);</span>
702                 }
703 
704                 // should be independent
705                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">706                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);</span>
<span class="line-modified">707                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);</span>
708                 }
709             })},
710             { linkVaListCB(&quot;upcallStruct&quot;), VaListConsumer.mh(vaList -&gt; {
711                 try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
<span class="line-modified">712                     assertEquals((int) VH_Point_x.get(struct.address()), 5);</span>
<span class="line-modified">713                     assertEquals((int) VH_Point_y.get(struct.address()), 10);</span>
714                 }
715             })},
716             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {
717                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
<span class="line-modified">718                     assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);</span>
<span class="line-modified">719                     assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);</span>
<span class="line-modified">720                     assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);</span>
721                 }
722             })},
723             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {
724                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
<span class="line-modified">725                     assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);</span>
<span class="line-modified">726                     assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);</span>
727                 }
728             })},
729             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
730                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
731                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
732                                                                     Thread.currentThread(), null, null);
<span class="line-modified">733                 int x = MemoryAccess.getInt(ms.address());</span>
734                 assertEquals(x, 10);
735             })},
736             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
737                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
738                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
739                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
740             })},
741             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {
742                 assertEquals(vaList.vargAsInt(C_INT), 10);
743                 assertEquals(vaList.vargAsInt(C_INT), 15);
744                 assertEquals(vaList.vargAsInt(C_INT), 20);
745             })},
746             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
747                 // skip all registers
748                 for (long l = 1; l &lt;= 16; l++) {
749                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);
750                 }
751                 for (double d = 1; d &lt;= 16; d++) {
752                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);
753                 }
754 
755                 // test some arbitrary values on the stack
756                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
757                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
758                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
759                 assertEquals(vaList.vargAsInt(C_INT), 4);
760                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
761                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
762                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
763                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
764                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);
765                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
766                 assertEquals(vaList.vargAsInt(C_INT), 11);
767                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
768                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
769                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
770 
771                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
<span class="line-modified">772                     assertEquals((int) VH_Point_x.get(point.address()), 5);</span>
<span class="line-modified">773                     assertEquals((int) VH_Point_y.get(point.address()), 10);</span>
774                 }
775 
776                 VaList copy = vaList.copy();
777                 try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">778                     assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);</span>
<span class="line-modified">779                     assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);</span>
780 
<span class="line-modified">781                     VH_BigPoint_x.set(bigPoint.address(), 0);</span>
<span class="line-modified">782                     VH_BigPoint_y.set(bigPoint.address(), 0);</span>
783                 }
784 
785                 // should be independent
786                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
<span class="line-modified">787                     assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);</span>
<span class="line-modified">788                     assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);</span>
789                 }
790             })},
791             // test skip
792             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
793                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
794                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
795                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
796                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);
797                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
798                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);
799                 vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);
800                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);
801             })},
802         };
803     }
804 
805     interface VaListConsumer {
806         void accept(CSupport.VaList list);
807 
808         static MethodHandle mh(VaListConsumer instance) {
</pre>
</td>
</tr>
</table>
<center><a href="../TestVarHandleCombinators.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
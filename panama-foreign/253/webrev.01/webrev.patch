diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
--- /dev/null
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/Addressable.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.foreign;
+
+/**
+ * Represents a type which is <em>addressable</em>. An addressable type is one which can be projected down to
+ * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},
+ * and {@link MemoryAddress}.
+ *
+ * @apiNote In the future, if the Java language permits, {@link Addressable}
+ * may become a {@code sealed} interface, which would prohibit subclassing except by
+ * explicitly permitted types, such as {@link MemorySegment} and {@link MemoryAddress}.
+ *
+ * @implSpec
+ * Implementations of this interface <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
+ */
+public interface Addressable {
+    /**
+     * Map this object into a {@link MemoryAddress} instance.
+     * @return the {@link MemoryAddress} instance associated with this object.
+     */
+    MemoryAddress address();
+}
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/CSupport.java
@@ -869,11 +869,11 @@
         MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);
     }
 
     private static MemorySegment toCString(byte[] bytes) {
         MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
         copy(addr, bytes);
         return segment;
     }
 
     private static MemoryAddress toCString(byte[] bytes, NativeScope scope) {
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryAddress.java
@@ -28,11 +28,11 @@
 
 import jdk.internal.foreign.MemoryAddressImpl;
 
 /**
  * A memory address models a reference into a memory location. Memory addresses are typically obtained using the
- * {@link MemorySegment#baseAddress()} method; such addresses are said to be <em>checked</em>, and can be expressed
+ * {@link MemorySegment#address()} method; such addresses are said to be <em>checked</em>, and can be expressed
  * as <em>offsets</em> into some underlying memory segment (see {@link #segment()} and {@link #segmentOffset()}).
  * Since checked memory addresses feature both spatial and temporal bounds, these addresses can <em>safely</em> be
  * dereferenced using a memory access var handle (see {@link MemoryHandles}).
  * <p>
  * If an address does not have any associated segment, it is said to be <em>unchecked</em>. Unchecked memory
@@ -52,11 +52,17 @@
  * explicitly permitted types.
  *
  * @implSpec
  * Implementations of this interface are immutable, thread-safe and <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
  */
-public interface MemoryAddress {
+public interface MemoryAddress extends Addressable {
+
+    @Override
+    default MemoryAddress address() {
+        return this;
+    }
+
     /**
      * Creates a new memory address with given offset (in bytes), which might be negative, from current one.
      * @param offset specified offset (in bytes), relative to this address, which should be used to create the new address.
      * @return a new memory address with given offset from current one.
      */
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemoryHandles.java
@@ -360,12 +360,12 @@
      * the case if modeled as a Java {@code short}. This is illustrated in the following example:
      * <blockquote><pre>{@code
     MemorySegment segment = MemorySegment.allocateNative(2);
     VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);
     VarHandle INT_VH = MemoryHandles.asUnsigned(SHORT_VH, int.class);
-    SHORT_VH.set(segment.baseAddress(), (short)-1);
-    INT_VH.get(segment.baseAddress()); // returns 65535
+    SHORT_VH.set(segment.address(), (short)-1);
+    INT_VH.get(segment.address()); // returns 65535
      * }</pre></blockquote>
      * <p>
      * When calling e.g. {@link VarHandle#set(Object...)} on the resulting var
      * handle, the incoming value (of type {@code adaptedType}) is converted by a
      * <i>narrowing primitive conversion</i> and then passed to the {@code
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -156,30 +156,31 @@
  * <blockquote><pre>{@code
 MemorySegment segment = ...
 SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
 int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
-                       .mapToInt(s -> (int)VH_int.get(s.baseAddress()))
+                       .mapToInt(s -> (int)VH_int.get(s.address()))
                        .sum();
  * }</pre></blockquote>
  *
  * @apiNote In the future, if the Java language permits, {@link MemorySegment}
  * may become a {@code sealed} interface, which would prohibit subclassing except by
  * {@link MappedMemorySegment} and other explicitly permitted subtypes.
  *
  * @implSpec
  * Implementations of this interface are immutable, thread-safe and <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>.
  */
-public interface MemorySegment extends AutoCloseable {
+public interface MemorySegment extends Addressable, AutoCloseable {
 
     /**
      * The base memory address associated with this memory segment. The returned address is
-     * a <em>checked</em> memory address and can therefore be used in derefrence operations
+     * a <em>checked</em> memory address and can therefore be used in dereference operations
      * (see {@link MemoryAddress}).
      * @return The base memory address.
      */
-    MemoryAddress baseAddress();
+    @Override
+    MemoryAddress address();
 
     /**
      * Returns a spliterator for the given memory segment. The returned spliterator reports {@link Spliterator#SIZED},
      * {@link Spliterator#SUBSIZED}, {@link Spliterator#IMMUTABLE}, {@link Spliterator#NONNULL} and {@link Spliterator#ORDERED}
      * characteristics.
@@ -304,11 +305,11 @@
      *
      * <pre>{@code
 byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
          .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
 for (long l = 0; l < segment.byteSize(); l++) {
-     byteHandle.set(segment.baseAddress(), l, value);
+     byteHandle.set(segment.address(), l, value);
 }
      * }</pre>
      *
      * without any regard or guarantees on the ordering of particular memory
      * elements being set.
@@ -347,11 +348,11 @@
     void copyFrom(MemorySegment src);
 
     /**
      * Finds and returns the offset, in bytes, of the first mismatch between
      * this segment and a given other segment. The offset is relative to the
-     * {@link #baseAddress() base address} of each segment and will be in the
+     * {@link #address() base address} of each segment and will be in the
      * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of
      * the smaller memory segment (exclusive).
      * <p>
      * If the two segments share a common prefix then the returned offset is
      * the length of the common prefix and it follows that there is a mismatch
diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/package-info.java
@@ -40,11 +40,11 @@
  *
  * <pre>{@code
 static final VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
 
 try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {
-    MemoryAddress base = segment.baseAddress();
+    MemoryAddress base = segment.address();
     for (long i = 0 ; i < 10 ; i++) {
        intHandle.set(base.addOffset(i * 4), (int)i);
     }
 }
  * }</pre>
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -159,11 +159,11 @@
             return -1;
         }
 
         long i = 0;
         if (length > 7) {
-            if ((byte) BYTE_HANDLE.get(this.baseAddress(), 0) != (byte) BYTE_HANDLE.get(that.baseAddress(), 0)) {
+            if ((byte) BYTE_HANDLE.get(this.address(), 0) != (byte) BYTE_HANDLE.get(that.address(), 0)) {
                 return 0;
             }
             i = ArraysSupport.vectorizedMismatchLargeForBytes(
                     this.base(), this.min(),
                     that.base(), that.min(),
@@ -173,23 +173,23 @@
             }
             long remaining = ~i;
             assert remaining < 8 : "remaining greater than 7: " + remaining;
             i = length - remaining;
         }
-        MemoryAddress thisAddress = this.baseAddress();
-        MemoryAddress thatAddress = that.baseAddress();
+        MemoryAddress thisAddress = this.address();
+        MemoryAddress thatAddress = that.address();
         for (; i < length; i++) {
             if ((byte) BYTE_HANDLE.get(thisAddress, i) != (byte) BYTE_HANDLE.get(thatAddress, i)) {
                 return i;
             }
         }
         return thisSize != thatSize ? length : -1;
     }
 
     @Override
     @ForceInline
-    public final MemoryAddress baseAddress() {
+    public final MemoryAddress address() {
         return new MemoryAddressImpl(this, 0);
     }
 
     @Override
     public final ByteBuffer asByteBuffer() {
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractNativeScope.java
@@ -95,21 +95,21 @@
         public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
             checkOwnerThread();
             if (bytesSize > MAX_ALLOC_SIZE) {
                 MemorySegment segment = newSegment(bytesSize, bytesAlignment);
                 return segment.withAccessModes(SCOPE_MASK)
-                        .baseAddress();
+                        .address();
             }
             for (int i = 0; i < 2; i++) {
-                long min = ((MemoryAddressImpl) segment.baseAddress()).unsafeGetOffset();
+                long min = ((MemoryAddressImpl) segment.address()).unsafeGetOffset();
                 long start = Utils.alignUp(min + sp, bytesAlignment) - min;
                 try {
                     MemorySegment slice = segment.asSlice(start, bytesSize)
                             .withAccessModes(SCOPE_MASK);
                     sp = start + bytesSize;
                     size += Utils.alignUp(bytesSize, bytesAlignment);
-                    return slice.baseAddress();
+                    return slice.address();
                 } catch (IndexOutOfBoundsException ex) {
                     sp = 0L;
                     segment = newSegment(BLOCK_SIZE, 1L);
                 }
             }
@@ -137,17 +137,17 @@
         }
 
         @Override
         public MemoryAddress allocate(long bytesSize, long bytesAlignment) {
             checkOwnerThread();
-            long min = ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset();
+            long min = ((MemoryAddressImpl)segment.address()).unsafeGetOffset();
             long start = Utils.alignUp(min + sp, bytesAlignment) - min;
             try {
                 MemorySegment slice = segment.asSlice(start, bytesSize)
                         .withAccessModes(SCOPE_MASK);
                 sp = start + bytesSize;
-                return slice.baseAddress();
+                return slice.address();
             } catch (IndexOutOfBoundsException ex) {
                 throw new OutOfMemoryError("Not enough space left to allocate");
             }
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/LibrariesHelper.java
@@ -117,11 +117,11 @@
         @Override
         public MemoryAddress lookup(String name) throws NoSuchMethodException {
             long addr = library.lookup(name);
             return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(addr),
                     0, null, null, this)
-                    .baseAddress();
+                    .address();
         }
 
         static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);
     }
 
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryAddressImpl.java
@@ -88,11 +88,11 @@
         AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;
         if (segmentImpl.base() != this.segment.base()) {
             throw new IllegalArgumentException("Invalid rebase target: " + segment);
         }
         return new MemoryAddressImpl((AbstractMemorySegmentImpl)segment,
-                unsafeGetOffset() - ((MemoryAddressImpl)segment.baseAddress()).unsafeGetOffset());
+                unsafeGetOffset() - ((MemoryAddressImpl)segment.address()).unsafeGetOffset());
     }
 
     // MemoryAddressProxy methods
 
     public void checkAccess(long offset, long length, boolean readOnly) {
@@ -138,8 +138,8 @@
         return ofLongUnchecked(value, Long.MAX_VALUE);
     }
 
     public static MemoryAddress ofLongUnchecked(long value, long byteSize) {
         return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
-                MemoryAddress.ofLong(value), byteSize, null, null, null).baseAddress();
+                MemoryAddress.ofLong(value), byteSize, null, null, null).address();
     }
 }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/Binding.java
@@ -213,11 +213,11 @@
             MethodHandles.Lookup lookup = MethodHandles.lookup();
             MH_UNBOX_ADDRESS = lookup.findVirtual(MemoryAddress.class, "toRawLongValue",
                     methodType(long.class));
             MH_BOX_ADDRESS = lookup.findStatic(MemoryAddress.class, "ofLong",
                     methodType(MemoryAddress.class, long.class));
-            MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, "baseAddress",
+            MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, "address",
                     methodType(MemoryAddress.class));
             MH_COPY_BUFFER = lookup.findStatic(Binding.class, "copyBuffer",
                     methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, NativeScope.class));
             MH_ALLOCATE_BUFFER = lookup.findStatic(MemorySegment.class, "allocateNative",
                     methodType(MemorySegment.class, long.class, long.class));
@@ -516,20 +516,20 @@
         }
 
         @Override
         public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
             MemorySegment operand = (MemorySegment) stack.pop();
-            MemoryAddress baseAddress = operand.baseAddress();
+            MemoryAddress baseAddress = operand.address();
             MemoryAddress readAddress = baseAddress.addOffset(offset);
             stack.push(SharedUtils.read(readAddress, type));
         }
 
         @Override
         public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {
             Object value = stack.pop();
             MemorySegment operand = (MemorySegment) stack.pop();
-            MemoryAddress baseAddress = operand.baseAddress();
+            MemoryAddress baseAddress = operand.address();
             MemoryAddress writeAddress = baseAddress.addOffset(offset);
             SharedUtils.write(writeAddress, type, value);
         }
 
         private VarHandle varHandle() {
@@ -831,16 +831,16 @@
             stack.push(MemoryAddress.class);
         }
 
         @Override
         public void unbox(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc, NativeScope scope) {
-            stack.push(((MemorySegment) stack.pop()).baseAddress());
+            stack.push(((MemorySegment) stack.pop()).address());
         }
 
         @Override
         public void box(Deque<Object> stack, BindingInterpreter.LoadFunc loadFunc) {
-            stack.push(((MemorySegment) stack.pop()).baseAddress());
+            stack.push(((MemorySegment) stack.pop()).address());
         }
 
         @Override
         public MethodHandle specializeUnbox(MethodHandle specializedHandle, int insertPos) {
             return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/ProgrammableInvoker.java
@@ -264,15 +264,15 @@
      * @return null, a single primitive value, or an Object[] of primitive values
      */
     Object invokeMoves(Object[] args, Binding.Move[] argBindings, Binding.Move[] returnBindings) {
         MemorySegment stackArgsSeg = null;
         try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {
-            MemoryAddress argsPtr = argBuffer.baseAddress();
+            MemoryAddress argsPtr = argBuffer.address();
             MemoryAddress stackArgs;
             if (stackArgsBytes > 0) {
                 stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);
-                stackArgs = stackArgsSeg.baseAddress();
+                stackArgs = stackArgsSeg.address();
             } else {
                 stackArgs = MemoryAddressImpl.NULL;
             }
 
             VH_LONG.set(argsPtr.addOffset(layout.arguments_next_pc), addr.toRawLongValue());
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/SharedUtils.java
@@ -77,11 +77,11 @@
     static {
         try {
             var lookup = MethodHandles.lookup();
             MH_ALLOC_BUFFER = lookup.findStatic(SharedUtils.class, "allocateNative",
                     methodType(MemorySegment.class, MemoryLayout.class));
-            MH_BASEADDRESS = lookup.findVirtual(MemorySegment.class, "baseAddress",
+            MH_BASEADDRESS = lookup.findVirtual(MemorySegment.class, "address",
                     methodType(MemoryAddress.class));
             MH_BUFFER_COPY = lookup.findStatic(SharedUtils.class, "bufferCopy",
                     methodType(MemoryAddress.class, MemoryAddress.class, MemorySegment.class));
         } catch (ReflectiveOperationException e) {
             throw new BootstrapMethodError(e);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/aarch64/AArch64VaList.java
@@ -134,17 +134,17 @@
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null,
                 () -> U.freeMemory(ptr), null);
         cleaner.register(AArch64VaList.class, ms::close);
-        MemoryAddress base = ms.baseAddress();
+        MemoryAddress base = ms.address();
         VH_stack.set(base, MemoryAddress.NULL);
         VH_gr_top.set(base, MemoryAddress.NULL);
         VH_vr_top.set(base, MemoryAddress.NULL);
         VH_gr_offs.set(base, 0);
         VH_vr_offs.set(base, 0);
-        return ms.withAccessModes(0).baseAddress();
+        return ms.withAccessModes(0).address();
     }
 
     public static CSupport.VaList empty() {
         return EMPTY;
     }
@@ -152,49 +152,49 @@
     private MemoryAddress grTop() {
         return grTop(segment);
     }
 
     private static MemoryAddress grTop(MemorySegment segment) {
-        return (MemoryAddress) VH_gr_top.get(segment.baseAddress());
+        return (MemoryAddress) VH_gr_top.get(segment.address());
     }
 
     private MemoryAddress vrTop() {
         return vrTop(segment);
     }
 
     private static MemoryAddress vrTop(MemorySegment segment) {
-        return (MemoryAddress) VH_vr_top.get(segment.baseAddress());
+        return (MemoryAddress) VH_vr_top.get(segment.address());
     }
 
     private int grOffs() {
-        final int offs = (int) VH_gr_offs.get(segment.baseAddress());
+        final int offs = (int) VH_gr_offs.get(segment.address());
         assert offs <= 0;
         return offs;
     }
 
     private int vrOffs() {
-        final int offs = (int) VH_vr_offs.get(segment.baseAddress());
+        final int offs = (int) VH_vr_offs.get(segment.address());
         assert offs <= 0;
         return offs;
     }
 
     private MemoryAddress stackPtr() {
-        return (MemoryAddress) VH_stack.get(segment.baseAddress());
+        return (MemoryAddress) VH_stack.get(segment.address());
     }
 
     private void stackPtr(MemoryAddress ptr) {
-        VH_stack.set(segment.baseAddress(), ptr);
+        VH_stack.set(segment.address(), ptr);
     }
 
     private void consumeGPSlots(int num) {
-        final int old = (int) VH_gr_offs.get(segment.baseAddress());
-        VH_gr_offs.set(segment.baseAddress(), old + num * GP_SLOT_SIZE);
+        final int old = (int) VH_gr_offs.get(segment.address());
+        VH_gr_offs.set(segment.address(), old + num * GP_SLOT_SIZE);
     }
 
     private void consumeFPSlots(int num) {
-        final int old = (int) VH_vr_offs.get(segment.baseAddress());
-        VH_vr_offs.set(segment.baseAddress(), old + num * FP_SLOT_SIZE);
+        final int old = (int) VH_vr_offs.get(segment.address());
+        VH_vr_offs.set(segment.address(), old + num * FP_SLOT_SIZE);
     }
 
     private long currentGPOffset() {
         // Offset from start of GP register segment. __gr_top points to the top
         // (highest address) of the GP registers area. __gr_offs is the negative
@@ -275,11 +275,11 @@
                 case POINTER, INTEGER, FLOAT -> {
                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              stackPtr(), layout.byteSize(),
                              segment.ownerThread(), null, null)) {
-                        Object res = reader.get(slice.baseAddress());
+                        Object res = reader.get(slice.address());
                         postAlignStack(layout);
                         yield res;
                     }
                 }
             };
@@ -317,11 +317,11 @@
                 case STRUCT_REFERENCE -> {
                     // Struct is passed indirectly via a pointer in an integer register.
                     VarHandle ptrReader
                         = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);
                     MemoryAddress ptr = (MemoryAddress) ptrReader.get(
-                        gpRegsArea.baseAddress().addOffset(currentGPOffset()));
+                        gpRegsArea.address().addOffset(currentGPOffset()));
                     consumeGPSlots(1);
 
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(
                              ptr, layout.byteSize(), segment.ownerThread(), null, null)) {
                         MemorySegment seg = allocator.allocate(layout);
@@ -329,17 +329,17 @@
                         yield seg;
                     }
                 }
                 case POINTER, INTEGER -> {
                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                    Object res = reader.get(gpRegsArea.baseAddress().addOffset(currentGPOffset()));
+                    Object res = reader.get(gpRegsArea.address().addOffset(currentGPOffset()));
                     consumeGPSlots(1);
                     yield res;
                 }
                 case FLOAT -> {
                     VarHandle reader = layout.varHandle(carrier);
-                    Object res = reader.get(fpRegsArea.baseAddress().addOffset(currentFPOffset()));
+                    Object res = reader.get(fpRegsArea.address().addOffset(currentFPOffset()));
                     consumeFPSlots(1);
                     yield res;
                 }
             };
         }
@@ -398,11 +398,11 @@
         return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
-        return segment.baseAddress();
+        return segment.address();
     }
 
     private static int numSlots(MemoryLayout layout) {
         return (int) Utils.alignUp(layout.byteSize(), 8) / 8;
     }
@@ -508,22 +508,22 @@
                         // Struct is passed indirectly via a pointer in an integer register.
                         MemorySegment valueSegment = (MemorySegment) value;
                         VarHandle writer
                             = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class,
                                                                AArch64.C_POINTER);
-                        writer.set(gpRegs.baseAddress().addOffset(currentGPOffset),
-                                   valueSegment.baseAddress());
+                        writer.set(gpRegs.address().addOffset(currentGPOffset),
+                                   valueSegment.address());
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case POINTER, INTEGER -> {
                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                        writer.set(gpRegs.baseAddress().addOffset(currentGPOffset), value);
+                        writer.set(gpRegs.address().addOffset(currentGPOffset), value);
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case FLOAT -> {
                         VarHandle writer = layout.varHandle(carrier);
-                        writer.set(fpRegs.baseAddress().addOffset(currentFPOffset), value);
+                        writer.set(fpRegs.address().addOffset(currentFPOffset), value);
                         currentFPOffset += FP_SLOT_SIZE;
                     }
                 }
             }
             return this;
@@ -543,25 +543,25 @@
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream()
                     .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), 8), Long::sum);
                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
-                MemoryAddress maStackArea = stackArgsSegment.baseAddress();
+                MemoryAddress maStackArea = stackArgsSegment.address();
                 for (SimpleVaArg arg : stackArgs) {
                     final long alignedSize = Utils.alignUp(arg.layout.byteSize(), 8);
                     maStackArea = Utils.alignUp(maStackArea, alignedSize);
                     VarHandle writer = arg.varHandle();
                     writer.set(maStackArea, arg.value);
                     maStackArea = maStackArea.addOffset(alignedSize);
                 }
-                stackArgsPtr = stackArgsSegment.baseAddress();
+                stackArgsPtr = stackArgsSegment.address();
                 attachedSegments.add(stackArgsSegment);
             }
 
-            MemoryAddress vaListAddr = vaListSegment.baseAddress();
-            VH_gr_top.set(vaListAddr, gpRegs.baseAddress().addOffset(gpRegs.byteSize()));
-            VH_vr_top.set(vaListAddr, fpRegs.baseAddress().addOffset(fpRegs.byteSize()));
+            MemoryAddress vaListAddr = vaListSegment.address();
+            VH_gr_top.set(vaListAddr, gpRegs.address().addOffset(gpRegs.byteSize()));
+            VH_vr_top.set(vaListAddr, fpRegs.address().addOffset(fpRegs.byteSize()));
             VH_stack.set(vaListAddr, stackArgsPtr);
             VH_gr_offs.set(vaListAddr, -MAX_GP_OFFSET);
             VH_vr_offs.set(vaListAddr, -MAX_FP_OFFSET);
 
             attachedSegments.add(gpRegs);
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/sysv/SysVVaList.java
@@ -138,52 +138,52 @@
     private static MemoryAddress emptyListAddress() {
         long ptr = U.allocateMemory(LAYOUT.byteSize());
         MemorySegment ms = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(
                 MemoryAddress.ofLong(ptr), LAYOUT.byteSize(), null, () -> U.freeMemory(ptr), null);
         cleaner.register(SysVVaList.class, ms::close);
-        MemoryAddress base = ms.baseAddress();
+        MemoryAddress base = ms.address();
         VH_gp_offset.set(base, MAX_GP_OFFSET);
         VH_fp_offset.set(base, MAX_FP_OFFSET);
         VH_overflow_arg_area.set(base, MemoryAddress.NULL);
         VH_reg_save_area.set(base, MemoryAddress.NULL);
-        return ms.withAccessModes(0).baseAddress();
+        return ms.withAccessModes(0).address();
     }
 
     public static CSupport.VaList empty() {
         return EMPTY;
     }
 
     private int currentGPOffset() {
-        return (int) VH_gp_offset.get(segment.baseAddress());
+        return (int) VH_gp_offset.get(segment.address());
     }
 
     private void currentGPOffset(int i) {
-        VH_gp_offset.set(segment.baseAddress(), i);
+        VH_gp_offset.set(segment.address(), i);
     }
 
     private int currentFPOffset() {
-        return (int) VH_fp_offset.get(segment.baseAddress());
+        return (int) VH_fp_offset.get(segment.address());
     }
 
     private void currentFPOffset(int i) {
-        VH_fp_offset.set(segment.baseAddress(), i);
+        VH_fp_offset.set(segment.address(), i);
     }
 
     private MemoryAddress stackPtr() {
-        return (MemoryAddress) VH_overflow_arg_area.get(segment.baseAddress());
+        return (MemoryAddress) VH_overflow_arg_area.get(segment.address());
     }
 
     private void stackPtr(MemoryAddress ptr) {
-        VH_overflow_arg_area.set(segment.baseAddress(), ptr);
+        VH_overflow_arg_area.set(segment.address(), ptr);
     }
 
     private MemorySegment regSaveArea() {
         return getRegSaveArea(segment);
     }
 
     private static MemorySegment getRegSaveArea(MemorySegment segment) {
-        return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.baseAddress()),
+        return MemorySegment.ofNativeRestricted((MemoryAddress) VH_reg_save_area.get(segment.address()),
             LAYOUT_REG_SAVE_AREA.byteSize(), segment.ownerThread(), null, null);
     }
 
     private void preAlignStack(MemoryLayout layout) {
         if (layout.byteAlignment() > 8) {
@@ -247,11 +247,11 @@
                 }
                 case POINTER, INTEGER, FLOAT -> {
                     VarHandle reader = vhPrimitiveOrAddress(carrier, layout);
                     try (MemorySegment slice = MemorySegment.ofNativeRestricted(stackPtr(), layout.byteSize(),
                                                                                 segment.ownerThread(), null, null)) {
-                        Object res = reader.get(slice.baseAddress());
+                        Object res = reader.get(slice.address());
                         postAlignStack(layout);
                         yield res;
                     }
                 }
             };
@@ -276,17 +276,17 @@
                     }
                     yield value;
                 }
                 case POINTER, INTEGER -> {
                     VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                    Object res = reader.get(regSaveArea.baseAddress().addOffset(currentGPOffset()));
+                    Object res = reader.get(regSaveArea.address().addOffset(currentGPOffset()));
                     currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);
                     yield res;
                 }
                 case FLOAT -> {
                     VarHandle reader = layout.varHandle(carrier);
-                    Object res = reader.get(regSaveArea.baseAddress().addOffset(currentFPOffset()));
+                    Object res = reader.get(regSaveArea.address().addOffset(currentFPOffset()));
                     currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);
                     yield res;
                 }
             };
         }
@@ -343,11 +343,11 @@
         return new SysVVaList(copy, regSaveArea, List.of());
     }
 
     @Override
     public MemoryAddress address() {
-        return segment.baseAddress();
+        return segment.address();
     }
 
     private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {
         return currentGPOffset > MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE
                 || currentFPOffset > MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;
@@ -427,16 +427,16 @@
                             offset += copy;
                         }
                     }
                     case POINTER, INTEGER -> {
                         VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);
-                        writer.set(reg_save_area.baseAddress().addOffset(currentGPOffset), value);
+                        writer.set(reg_save_area.address().addOffset(currentGPOffset), value);
                         currentGPOffset += GP_SLOT_SIZE;
                     }
                     case FLOAT -> {
                         VarHandle writer = layout.varHandle(carrier);
-                        writer.set(reg_save_area.baseAddress().addOffset(currentFPOffset), value);
+                        writer.set(reg_save_area.address().addOffset(currentFPOffset), value);
                         currentFPOffset += FP_SLOT_SIZE;
                     }
                 }
             }
             return this;
@@ -455,11 +455,11 @@
             List<MemorySegment> attachedSegments = new ArrayList<>();
             MemoryAddress stackArgsPtr = MemoryAddress.NULL;
             if (!stackArgs.isEmpty()) {
                 long stackArgsSize = stackArgs.stream().reduce(0L, (acc, e) -> acc + e.layout.byteSize(), Long::sum);
                 MemorySegment stackArgsSegment = allocator.allocate(stackArgsSize, 16);
-                MemoryAddress maOverflowArgArea = stackArgsSegment.baseAddress();
+                MemoryAddress maOverflowArgArea = stackArgsSegment.address();
                 for (SimpleVaArg arg : stackArgs) {
                     if (arg.layout.byteSize() > 8) {
                         maOverflowArgArea = Utils.alignUp(maOverflowArgArea, Math.min(16, arg.layout.byteSize()));
                     }
                     if (arg.value instanceof MemorySegment) {
@@ -470,18 +470,18 @@
                         VarHandle writer = arg.varHandle();
                         writer.set(maOverflowArgArea, arg.value);
                     }
                     maOverflowArgArea = maOverflowArgArea.addOffset(arg.layout.byteSize());
                 }
-                stackArgsPtr = stackArgsSegment.baseAddress();
+                stackArgsPtr = stackArgsSegment.address();
                 attachedSegments.add(stackArgsSegment);
             }
 
-            MemoryAddress vaListAddr = vaListSegment.baseAddress();
+            MemoryAddress vaListAddr = vaListSegment.address();
             VH_fp_offset.set(vaListAddr, (int) FP_OFFSET);
             VH_overflow_arg_area.set(vaListAddr, stackArgsPtr);
-            VH_reg_save_area.set(vaListAddr, reg_save_area.baseAddress());
+            VH_reg_save_area.set(vaListAddr, reg_save_area.address());
             attachedSegments.add(reg_save_area);
             assert reg_save_area.ownerThread() == vaListSegment.ownerThread();
             return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);
         }
     }
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/abi/x64/windows/WinVaList.java
@@ -146,11 +146,11 @@
         ptr = ptr.addOffset(layouts.length * VA_SLOT_SIZE_BYTES);
     }
 
     static WinVaList ofAddress(MemoryAddress addr) {
         MemorySegment segment = MemorySegment.ofNativeRestricted(addr, Long.MAX_VALUE, Thread.currentThread(), null, null);
-        return new WinVaList(segment.baseAddress(), List.of(segment), null);
+        return new WinVaList(segment.address(), List.of(segment), null);
     }
 
     static Builder builder(SharedUtils.Allocator allocator) {
         return new Builder(allocator);
     }
@@ -234,21 +234,21 @@
                 return EMPTY;
             }
             MemorySegment ms = allocator.allocate(VA_SLOT_SIZE_BYTES * args.size());
             List<MemorySegment> attachedSegments = new ArrayList<>();
             attachedSegments.add(ms);
-            MemoryAddress addr = ms.baseAddress();
+            MemoryAddress addr = ms.address();
             for (SimpleVaArg arg : args) {
                 if (arg.carrier == MemorySegment.class) {
                     MemorySegment msArg = ((MemorySegment) arg.value);
                     TypeClass typeClass = TypeClass.typeClassFor(arg.layout);
                     switch (typeClass) {
                         case STRUCT_REFERENCE -> {
                             MemorySegment copy = allocator.allocate(arg.layout);
                             copy.copyFrom(msArg); // by-value
                             attachedSegments.add(copy);
-                            VH_address.set(addr, copy.baseAddress());
+                            VH_address.set(addr, copy.address());
                         }
                         case STRUCT_REGISTER -> {
                             MemorySegment slice = ms.asSlice(addr.segmentOffset(), VA_SLOT_SIZE_BYTES);
                             slice.copyFrom(msArg);
                         }
@@ -259,9 +259,9 @@
                     writer.set(addr, arg.value);
                 }
                 addr = addr.addOffset(VA_SLOT_SIZE_BYTES);
             }
 
-            return new WinVaList(ms.baseAddress(), attachedSegments, null);
+            return new WinVaList(ms.address(), attachedSegments, null);
         }
     }
 }
diff a/test/jdk/java/foreign/CallGeneratorHelper.java b/test/jdk/java/foreign/CallGeneratorHelper.java
--- a/test/jdk/java/foreign/CallGeneratorHelper.java
+++ b/test/jdk/java/foreign/CallGeneratorHelper.java
@@ -346,17 +346,17 @@
         } else if (isPointer(layout)) {
             MemorySegment segment = MemorySegment.allocateNative(1);
             if (check) {
                 checks.add(o -> {
                     try {
-                        assertEquals((MemoryAddress)o, segment.baseAddress());
+                        assertEquals((MemoryAddress)o, segment.address());
                     } catch (Throwable ex) {
                         throw new IllegalStateException(ex);
                     }
                 });
             }
-            return segment.baseAddress();
+            return segment.address();
         } else if (layout instanceof ValueLayout) {
             if (isIntegral(layout)) {
                 if (check) {
                     checks.add(o -> assertEquals(o, 42));
                 }
@@ -385,21 +385,21 @@
             Object value = makeArg(l, fieldsCheck, check);
             if (isPointer(l)) {
                 value = ((MemoryAddress)value).toRawLongValue();
             }
             //set value
-            accessor.set(str.baseAddress(), value);
+            accessor.set(str.address(), value);
             //add check
             if (check) {
                 assertTrue(fieldsCheck.size() == 1);
                 checks.add(o -> {
                     MemorySegment actual = (MemorySegment)o;
                     try {
                         if (isPointer(l)) {
-                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual.baseAddress())));
+                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual.address())));
                         } else {
-                            fieldsCheck.get(0).accept(accessor.get(actual.baseAddress()));
+                            fieldsCheck.get(0).accept(accessor.get(actual.address()));
                         }
                     } catch (Throwable ex) {
                         throw new IllegalStateException(ex);
                     }
                 });
diff a/test/jdk/java/foreign/StdLibTest.java b/test/jdk/java/foreign/StdLibTest.java
--- a/test/jdk/java/foreign/StdLibTest.java
+++ b/test/jdk/java/foreign/StdLibTest.java
@@ -231,40 +231,40 @@
         String strcat(String s1, String s2) throws Throwable {
             try (MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1) ;
                  MemorySegment other = toCString(s2)) {
                 char[] chars = s1.toCharArray();
                 for (long i = 0 ; i < chars.length ; i++) {
-                    setByteAtOffset(buf.baseAddress(), i, (byte)chars[(int)i]);
+                    setByteAtOffset(buf.address(), i, (byte)chars[(int)i]);
                 }
-                setByteAtOffset(buf.baseAddress(), chars.length, (byte)'\0');
-                return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.baseAddress(), other.baseAddress())));
+                setByteAtOffset(buf.address(), chars.length, (byte)'\0');
+                return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));
             }
         }
 
         int strcmp(String s1, String s2) throws Throwable {
             try (MemorySegment ns1 = toCString(s1) ;
                  MemorySegment ns2 = toCString(s2)) {
-                return (int)strcmp.invokeExact(ns1.baseAddress(), ns2.baseAddress());
+                return (int)strcmp.invokeExact(ns1.address(), ns2.address());
             }
         }
 
         int puts(String msg) throws Throwable {
             try (MemorySegment s = toCString(msg)) {
-                return (int)puts.invokeExact(s.baseAddress());
+                return (int)puts.invokeExact(s.address());
             }
         }
 
         int strlen(String msg) throws Throwable {
             try (MemorySegment s = toCString(msg)) {
-                return (int)strlen.invokeExact(s.baseAddress());
+                return (int)strlen.invokeExact(s.address());
             }
         }
 
         Tm gmtime(long arg) throws Throwable {
             try (MemorySegment time = MemorySegment.allocateNative(8)) {
-                setLong(time.baseAddress(), arg);
-                return new Tm((MemoryAddress)gmtime.invokeExact(time.baseAddress()));
+                setLong(time.address(), arg);
+                return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));
             }
         }
 
         static class Tm {
 
@@ -273,11 +273,11 @@
 
             static final long SIZE = 56;
 
             Tm(MemoryAddress base) {
                 this.base = MemorySegment.ofNativeRestricted(base, SIZE, Thread.currentThread(),
-                        null, null).baseAddress();
+                        null, null).address();
             }
 
             int sec() {
                 return getIntAtOffset(base, 0);
             }
@@ -316,37 +316,37 @@
 
                 //call qsort
                 MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction);
                 scope.register(qsortUpcallStub);
 
-                qsort.invokeExact(nativeArr.baseAddress(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.baseAddress());
+                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.address());
 
                 //convert back to Java array
                 return nativeArr.toIntArray();
             }
         }
 
         static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {
-            return getIntAtOffset(base.baseAddress(), addr1.rebase(base).segmentOffset()) -
-                   getIntAtOffset(base.baseAddress(), addr2.rebase(base).segmentOffset());
+            return getIntAtOffset(base.address(), addr1.rebase(base).segmentOffset()) -
+                   getIntAtOffset(base.address(), addr2.rebase(base).segmentOffset());
         }
 
         int rand() throws Throwable {
             return (int)rand.invokeExact();
         }
 
         int printf(String format, List<PrintfArg> args) throws Throwable {
             try (MemorySegment formatStr = toCString(format)) {
-                return (int)specializedPrintf(args).invokeExact(formatStr.baseAddress(),
+                return (int)specializedPrintf(args).invokeExact(formatStr.address(),
                         args.stream().map(a -> a.nativeValue).toArray());
             }
         }
 
         int vprintf(String format, List<PrintfArg> args) throws Throwable {
             try (MemorySegment formatStr = toCString(format)) {
                 VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b)));
-                int result = (int)vprintf.invokeExact(formatStr.baseAddress(), vaList);
+                int result = (int)vprintf.invokeExact(formatStr.address(), vaList);
                 try {
                     vaList.close();
                 }
                 catch (UnsupportedOperationException e) {
                     assertEquals(e.getMessage(), "Empty VaList");
@@ -423,11 +423,11 @@
     }
 
     enum PrintfArg implements Consumer<VaList.Builder> {
 
         INTEGRAL(int.class, asVarArg(C_INT), "%d", 42, 42, VaList.Builder::vargFromInt),
-        STRING(MemoryAddress.class, asVarArg(C_POINTER), "%s", toCString("str").baseAddress(), "str", VaList.Builder::vargFromAddress),
+        STRING(MemoryAddress.class, asVarArg(C_POINTER), "%s", toCString("str").address(), "str", VaList.Builder::vargFromAddress),
         CHAR(byte.class, asVarArg(C_CHAR), "%c", (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),
         DOUBLE(double.class, asVarArg(C_DOUBLE), "%.4f", 1.2345d, 1.2345d, VaList.Builder::vargFromDouble);
 
         final Class<?> carrier;
         final MemoryLayout layout;
diff a/test/jdk/java/foreign/TestAdaptVarHandles.java b/test/jdk/java/foreign/TestAdaptVarHandles.java
--- a/test/jdk/java/foreign/TestAdaptVarHandles.java
+++ b/test/jdk/java/foreign/TestAdaptVarHandles.java
@@ -90,20 +90,20 @@
     public void testFilterValue() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, S2I, I2S);
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "42");
     }
 
     @Test
     public void testFilterValueComposite() throws Throwable {
@@ -111,39 +111,39 @@
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         MethodHandle CTX_S2I = MethodHandles.dropArguments(S2I, 0, String.class, String.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, CTX_S2I, CTX_I2S);
         i2SHandle = MemoryHandles.insertCoordinates(i2SHandle, 1, "a", "b");
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "ab1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "ab43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "ab12");
-        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "ab42");
     }
 
     @Test
     public void testFilterValueLoose() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle i2SHandle = MemoryHandles.filterValue(intHandle, O2I, I2O);
-        i2SHandle.set(segment.baseAddress(), "1");
-        String oldValue = (String)i2SHandle.getAndAdd(segment.baseAddress(), "42");
+        i2SHandle.set(segment.address(), "1");
+        String oldValue = (String)i2SHandle.getAndAdd(segment.address(), "42");
         assertEquals(oldValue, "1");
-        String value = (String)i2SHandle.get(segment.baseAddress());
+        String value = (String)i2SHandle.get(segment.address());
         assertEquals(value, "43");
-        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.baseAddress(), "43", "12");
+        boolean swapped = (boolean)i2SHandle.compareAndSet(segment.address(), "43", "12");
         assertTrue(swapped);
-        oldValue = (String)i2SHandle.compareAndExchange(segment.baseAddress(), "12", "42");
+        oldValue = (String)i2SHandle.compareAndExchange(segment.address(), "12", "42");
         assertEquals(oldValue, "12");
-        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress());
+        value = (String)(Object)i2SHandle.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address());
         assertEquals(value, "42");
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadFilterNullTarget() {
@@ -275,11 +275,11 @@
     @Test
     public void testInsertCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
-        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.baseAddress(), 0L);
+        VarHandle intHandle_longIndex = MemoryHandles.insertCoordinates(intHandle, 0, segment.address(), 0L);
         intHandle_longIndex.set(1);
         int oldValue = (int)intHandle_longIndex.getAndAdd(42);
         assertEquals(oldValue, 1);
         int value = (int)intHandle_longIndex.get();
         assertEquals(value, 43);
@@ -331,20 +331,20 @@
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_swap = MemoryHandles.permuteCoordinates(intHandle,
                 List.of(long.class, MemoryAddress.class), 1, 0);
-        intHandle_swap.set(0L, segment.baseAddress(), 1);
-        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.baseAddress(), 42);
+        intHandle_swap.set(0L, segment.address(), 1);
+        int oldValue = (int)intHandle_swap.getAndAdd(0L, segment.address(), 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_swap.get(0L, segment.baseAddress());
+        int value = (int)intHandle_swap.get(0L, segment.address());
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.baseAddress(), 43, 12);
+        boolean swapped = (boolean)intHandle_swap.compareAndSet(0L, segment.address(), 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.baseAddress(), 12, 42);
+        oldValue = (int)intHandle_swap.compareAndExchange(0L, segment.address(), 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.baseAddress());
+        value = (int)intHandle_swap.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(0L, segment.address());
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadPermuteCoordinatesNullTarget() {
@@ -391,20 +391,20 @@
     public void testCollectCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_sum = MemoryHandles.collectCoordinates(intHandle, 1, SUM_OFFSETS);
-        intHandle_sum.set(segment.baseAddress(), -2L, 2L, 1);
-        int oldValue = (int)intHandle_sum.getAndAdd(segment.baseAddress(), -2L, 2L, 42);
+        intHandle_sum.set(segment.address(), -2L, 2L, 1);
+        int oldValue = (int)intHandle_sum.getAndAdd(segment.address(), -2L, 2L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_sum.get(segment.baseAddress(), -2L, 2L);
+        int value = (int)intHandle_sum.get(segment.address(), -2L, 2L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.baseAddress(), -2L, 2L, 43, 12);
+        boolean swapped = (boolean)intHandle_sum.compareAndSet(segment.address(), -2L, 2L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_sum.compareAndExchange(segment.baseAddress(), -2L, 2L, 12, 42);
+        oldValue = (int)intHandle_sum.compareAndExchange(segment.address(), -2L, 2L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), -2L, 2L);
+        value = (int)intHandle_sum.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), -2L, 2L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testBadCollectCoordinatesNullTarget() {
@@ -451,20 +451,20 @@
     public void testDropCoordinates() throws Throwable {
         ValueLayout layout = MemoryLayouts.JAVA_INT;
         MemorySegment segment = MemorySegment.allocateNative(layout);
         VarHandle intHandle = MemoryHandles.withStride(layout.varHandle(int.class), 4);
         VarHandle intHandle_dummy = MemoryHandles.dropCoordinates(intHandle, 1, float.class, String.class);
-        intHandle_dummy.set(segment.baseAddress(), 1f, "hello", 0L, 1);
-        int oldValue = (int)intHandle_dummy.getAndAdd(segment.baseAddress(), 1f, "hello", 0L, 42);
+        intHandle_dummy.set(segment.address(), 1f, "hello", 0L, 1);
+        int oldValue = (int)intHandle_dummy.getAndAdd(segment.address(), 1f, "hello", 0L, 42);
         assertEquals(oldValue, 1);
-        int value = (int)intHandle_dummy.get(segment.baseAddress(), 1f, "hello", 0L);
+        int value = (int)intHandle_dummy.get(segment.address(), 1f, "hello", 0L);
         assertEquals(value, 43);
-        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.baseAddress(), 1f, "hello", 0L, 43, 12);
+        boolean swapped = (boolean)intHandle_dummy.compareAndSet(segment.address(), 1f, "hello", 0L, 43, 12);
         assertTrue(swapped);
-        oldValue = (int)intHandle_dummy.compareAndExchange(segment.baseAddress(), 1f, "hello", 0L, 12, 42);
+        oldValue = (int)intHandle_dummy.compareAndExchange(segment.address(), 1f, "hello", 0L, 12, 42);
         assertEquals(oldValue, 12);
-        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.baseAddress(), 1f, "hello", 0L);
+        value = (int)intHandle_dummy.toMethodHandle(VarHandle.AccessMode.GET).invokeExact(segment.address(), 1f, "hello", 0L);
         assertEquals(value, 42);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadDropCoordinatesNegativePos() {
@@ -506,11 +506,11 @@
     static long stringToLongException(String s) throws Throwable {
         return Long.valueOf(s);
     }
 
     static MemoryAddress baseAddress(MemorySegment segment) {
-        return segment.baseAddress();
+        return segment.address();
     }
 
     static long sumOffsets(long l1, long l2) {
         return l1 + l2;
     }
diff a/test/jdk/java/foreign/TestAddressHandle.java b/test/jdk/java/foreign/TestAddressHandle.java
--- a/test/jdk/java/foreign/TestAddressHandle.java
+++ b/test/jdk/java/foreign/TestAddressHandle.java
@@ -62,33 +62,33 @@
     @Test(dataProvider = "addressHandles")
     public void testAddressHandle(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
             MemoryAddress target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?
-                    segment.baseAddress().addOffset(8 - byteSize) :
-                    segment.baseAddress();
-            longHandle.set(segment.baseAddress(), 42L);
+                    segment.address().addOffset(8 - byteSize) :
+                    segment.address();
+            longHandle.set(segment.address(), 42L);
             MemoryAddress address = (MemoryAddress)addrHandle.get(target);
             assertEquals(address.toRawLongValue(), 42L);
             try {
                 longHandle.get(address); // check that address cannot be de-referenced
                 fail();
             } catch (UnsupportedOperationException ex) {
                 assertTrue(true);
             }
             addrHandle.set(target, address.addOffset(1));
-            long result = (long)longHandle.get(segment.baseAddress());
+            long result = (long)longHandle.get(segment.address());
             assertEquals(43L, result);
         }
     }
 
     @Test(dataProvider = "addressHandles")
     public void testNull(VarHandle addrHandle, int byteSize) {
         VarHandle longHandle = MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder());
         try (MemorySegment segment = MemorySegment.allocateNative(8)) {
-            longHandle.set(segment.baseAddress(), 0L);
-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.baseAddress());
+            longHandle.set(segment.address(), 0L);
+            MemoryAddress address = (MemoryAddress)addrHandle.get(segment.address());
             assertTrue(address == MemoryAddress.NULL);
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
diff a/test/jdk/java/foreign/TestArrays.java b/test/jdk/java/foreign/TestArrays.java
--- a/test/jdk/java/foreign/TestArrays.java
+++ b/test/jdk/java/foreign/TestArrays.java
@@ -37,11 +37,10 @@
 import java.lang.invoke.VarHandle;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 import java.util.function.Function;
-import java.util.function.ToIntFunction;
 
 import org.testng.annotations.*;
 
 import static jdk.incubator.foreign.MemorySegment.READ;
 import static org.testng.Assert.*;
@@ -101,12 +100,12 @@
     }
 
     @Test(dataProvider = "arrays")
     public void testArrays(Consumer<MemoryAddress> init, Consumer<MemoryAddress> checker, MemoryLayout layout) {
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            init.accept(segment.baseAddress());
-            checker.accept(segment.baseAddress());
+            init.accept(segment.address());
+            checker.accept(segment.address());
         }
     }
 
     @Test(dataProvider = "elemLayouts",
           expectedExceptions = UnsupportedOperationException.class)
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -166,11 +166,11 @@
             long limit = nelems - i;
             MemorySegment resizedSegment = base.segment().asSlice(i * elemSize, limit * elemSize);
             ByteBuffer bb = resizedSegment.asByteBuffer();
             Z z = bufFactory.apply(bb);
             for (long j = i ; j < limit ; j++) {
-                Object handleValue = handleExtractor.apply(resizedSegment.baseAddress(), j - i);
+                Object handleValue = handleExtractor.apply(resizedSegment.address(), j - i);
                 Object bufferValue = bufferExtractor.apply(z);
                 if (handleValue instanceof Number) {
                     assertEquals(((Number)handleValue).longValue(), j);
                     assertEquals(((Number)bufferValue).longValue(), j);
                 } else {
@@ -182,11 +182,11 @@
     }
 
     @Test
     public void testOffheap() {
         try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initTuples(base, tuples.elementCount().getAsLong());
 
             ByteBuffer bb = segment.asByteBuffer();
             checkTuples(base, bb, tuples.elementCount().getAsLong());
         }
@@ -194,11 +194,11 @@
 
     @Test
     public void testHeap() {
         byte[] arr = new byte[(int) tuples.byteSize()];
         MemorySegment region = MemorySegment.ofArray(arr);
-        MemoryAddress base = region.baseAddress();
+        MemoryAddress base = region.address();
         initTuples(base, tuples.elementCount().getAsLong());
 
         ByteBuffer bb = region.asByteBuffer();
         checkTuples(base, bb, tuples.elementCount().getAsLong());
     }
@@ -211,21 +211,21 @@
 
         //write to channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_WRITE, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 initTuples(base, tuples.elementCount().getAsLong());
                 mbb.force();
             });
         }
 
         //read from channel
         try (FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ)) {
             withMappedBuffer(channel, FileChannel.MapMode.READ_ONLY, 0, tuples.byteSize(), mbb -> {
                 MemorySegment segment = MemorySegment.ofByteBuffer(mbb);
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 checkTuples(base, mbb, tuples.elementCount().getAsLong());
             });
         }
     }
 
@@ -248,18 +248,18 @@
         f.createNewFile();
         f.deleteOnExit();
 
         //write to channel
         try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initTuples(base, tuples.elementCount().getAsLong());
             segment.force();
         }
 
         //read from channel
         try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             checkTuples(base, segment.asByteBuffer(), tuples.elementCount().getAsLong());
         }
     }
 
     @Test
@@ -272,21 +272,21 @@
 
         // write one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //write to channel
             try (MappedMemorySegment segment = MemorySegment.mapFromPath(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 initTuples(base, 1);
                 segment.force();
             }
         }
 
         // check one at a time
         for (int i = 0 ; i < tuples.byteSize() ; i += tupleLayout.byteSize()) {
             //read from channel
             try (MemorySegment segment = MemorySegment.mapFromPath(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {
-                MemoryAddress base = segment.baseAddress();
+                MemoryAddress base = segment.address();
                 checkTuples(base, segment.asByteBuffer(), 1);
             }
         }
     }
 
@@ -311,11 +311,11 @@
 
     @Test(dataProvider = "bufferOps")
     public void testScopedBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         Buffer bb;
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             bb = bufferFactory.apply(segment.asByteBuffer());
         }
         //outside of scope!!
         for (Map.Entry<Method, Object[]> e : members.entrySet()) {
             if (!e.getKey().getName().contains("get") &&
@@ -377,11 +377,11 @@
     }
 
     @Test(dataProvider = "bufferOps")
     public void testDirectBuffer(Function<ByteBuffer, Buffer> bufferFactory, Map<Method, Object[]> members) {
         try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             Buffer bb = bufferFactory.apply(segment.asByteBuffer());
             assertTrue(bb.isDirect());
             DirectBuffer directBuffer = ((DirectBuffer)bb);
             assertEquals(directBuffer.address(), ((MemoryAddressImpl)base).unsafeGetOffset());
             assertTrue((directBuffer.attachment() == null) == (bb instanceof ByteBuffer));
@@ -390,52 +390,52 @@
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeOffheap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             initializer.accept(base);
             checker.accept(base);
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).baseAddress();
+        MemoryAddress base = MemorySegment.ofArray(new byte[capacity]).address();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeBuffer(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
-        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).baseAddress();
+        MemoryAddress base = MemorySegment.ofByteBuffer(ByteBuffer.wrap(new byte[capacity])).address();
         initializer.accept(base);
         checker.accept(base);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int capacity = (int)seq.byteSize();
         byte[] arr = new byte[capacity];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress first = segment.baseAddress();
+        MemoryAddress first = segment.address();
         initializer.accept(first);
-        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+        MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
         checker.accept(second);
     }
 
     @Test(dataProvider="resizeOps")
     public void testResizeRoundtripNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress first = segment.baseAddress();
+            MemoryAddress first = segment.address();
             initializer.accept(first);
-            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).baseAddress();
+            MemoryAddress second = MemorySegment.ofByteBuffer(segment.asByteBuffer()).address();
             checker.accept(second);
         }
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
@@ -485,25 +485,25 @@
     public void testCopyHeapToNative(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(heapArray.baseAddress());
+            initializer.accept(heapArray.address());
             nativeArray.copyFrom(heapArray);
-            checker.accept(nativeArray.baseAddress());
+            checker.accept(nativeArray.address());
         }
     }
 
     @Test(dataProvider="resizeOps")
     public void testCopyNativeToHeap(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         checkByteArrayAlignment(seq.elementLayout());
         int bytes = (int)seq.byteSize();
         try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);
              MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {
-            initializer.accept(nativeArray.baseAddress());
+            initializer.accept(nativeArray.address());
             heapArray.copyFrom(nativeArray);
-            checker.accept(heapArray.baseAddress());
+            checker.accept(heapArray.address());
         }
     }
 
     @Test
     public void testDefaultAccessModesOfBuffer() {
@@ -551,11 +551,11 @@
         MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
         MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
 
         s1.close(); // memory freed
 
-        MemoryAccess.setInt(s2.baseAddress(), 10); // Dead access!
+        MemoryAccess.setInt(s2.address(), 10); // Dead access!
     }
 
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
diff a/test/jdk/java/foreign/TestLayouts.java b/test/jdk/java/foreign/TestLayouts.java
--- a/test/jdk/java/foreign/TestLayouts.java
+++ b/test/jdk/java/foreign/TestLayouts.java
@@ -62,18 +62,18 @@
         VarHandle array_elem_handle = layout.varHandle(double.class,
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr")))) {
-            size_handle.set(segment.baseAddress(), 4);
+            size_handle.set(segment.address(), 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.baseAddress(), i, (double)i);
+                array_elem_handle.set(segment.address(), i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));
+            assertEquals(4, (int)size_handle.get(segment.address()));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -88,18 +88,18 @@
                 MemoryLayout.PathElement.groupElement("arr"),
                 MemoryLayout.PathElement.sequenceElement(0),
                 MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(
                 layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement("arr"), MemoryLayout.PathElement.sequenceElement()))) {
-            size_handle.set(segment.baseAddress(), 4);
+            size_handle.set(segment.address(), 4);
             for (int i = 0 ; i < 4 ; i++) {
-                array_elem_handle.set(segment.baseAddress(), i, (double)i);
+                array_elem_handle.set(segment.address(), i, (double)i);
             }
             //check
-            assertEquals(4, (int)size_handle.get(segment.baseAddress()));
+            assertEquals(4, (int)size_handle.get(segment.address()));
             for (int i = 0 ; i < 4 ; i++) {
-                assertEquals((double)i, (double)array_elem_handle.get(segment.baseAddress(), i));
+                assertEquals((double)i, (double)array_elem_handle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -107,17 +107,17 @@
         MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
             VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());
             // init segment
             for (int i = 0 ; i < 10 ; i++) {
-                indexHandle.set(segment.baseAddress(), (long)i, i);
+                indexHandle.set(segment.address(), (long)i, i);
             }
             //check statically indexed handles
             for (int i = 0 ; i < 10 ; i++) {
                 VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));
-                int expected = (int)indexHandle.get(segment.baseAddress(), (long)i);
-                int found = (int)preindexHandle.get(segment.baseAddress());
+                int expected = (int)indexHandle.get(segment.address(), (long)i);
+                int found = (int)preindexHandle.get(segment.address());
                 assertEquals(expected, found);
             }
         }
     }
 
diff a/test/jdk/java/foreign/TestMemoryAccess.java b/test/jdk/java/foreign/TestMemoryAccess.java
--- a/test/jdk/java/foreign/TestMemoryAccess.java
+++ b/test/jdk/java/foreign/TestMemoryAccess.java
@@ -83,11 +83,11 @@
 
     private void testAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout layout, VarHandle handle, Checker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 checker.check(handle, addr);
                 if (isRO) {
                     throw new AssertionError(); //not ok, memory should be immutable
                 }
@@ -115,11 +115,11 @@
 
     private void testArrayAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, ArrayChecker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     checker.check(handle, addr, i);
                 }
                 if (isRO) {
@@ -184,11 +184,11 @@
 
     private void testMatrixAccessInternal(Function<MemorySegment, MemorySegment> viewFactory, SequenceLayout seq, VarHandle handle, MatrixChecker checker) {
         MemoryAddress outer_address;
         try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {
             boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             try {
                 for (int i = 0; i < seq.elementCount().getAsLong(); i++) {
                     for (int j = 0; j < ((SequenceLayout) seq.elementLayout()).elementCount().getAsLong(); j++) {
                         checker.check(handle, addr, i, j);
                     }
diff a/test/jdk/java/foreign/TestMemoryAlignment.java b/test/jdk/java/foreign/TestMemoryAlignment.java
--- a/test/jdk/java/foreign/TestMemoryAlignment.java
+++ b/test/jdk/java/foreign/TestMemoryAlignment.java
@@ -49,11 +49,11 @@
         assertEquals(layout.bitAlignment(), 32);
         ValueLayout aligned = layout.withBitAlignment(align);
         assertEquals(aligned.bitAlignment(), align); //unreasonable alignment here, to make sure access throws
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh.set(addr, -42);
             int val = (int)vh.get(addr);
             assertEquals(val, -42);
         }
     }
@@ -65,11 +65,11 @@
         ValueLayout aligned = layout.withBitAlignment(align);
         MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);
         assertEquals(alignedGroup.bitAlignment(), align);
         VarHandle vh = aligned.varHandle(int.class);
         try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh.set(addr.addOffset(1L), -42);
             assertEquals(align, 8); //this is the only case where access is aligned
         } catch (IllegalStateException ex) {
             assertNotEquals(align, 8); //if align != 8, access is always unaligned
         }
@@ -92,11 +92,11 @@
     public void testUnalignedSequence(long align) {
         SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));
         try {
             VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());
             try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-                MemoryAddress addr = segment.baseAddress();
+                MemoryAddress addr = segment.address();
                 for (long i = 0 ; i < 5 ; i++) {
                     vh.set(addr, i, -42);
                 }
             }
         } catch (UnsupportedOperationException ex) {
@@ -116,11 +116,11 @@
         assertEquals(g.bitAlignment(), 8);
         VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement("a"));
         VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement("b"));
         VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement("c"));
         try (MemorySegment segment = MemorySegment.allocateNative(g)) {
-            MemoryAddress addr = segment.baseAddress();
+            MemoryAddress addr = segment.address();
             vh_c.set(addr, Byte.MIN_VALUE);
             assertEquals(vh_c.get(addr), Byte.MIN_VALUE);
             vh_s.set(addr, Short.MIN_VALUE);
             assertEquals(vh_s.get(addr), Short.MIN_VALUE);
             vh_i.set(addr, Integer.MIN_VALUE);
diff a/test/jdk/java/foreign/TestMemoryCopy.java b/test/jdk/java/foreign/TestMemoryCopy.java
--- a/test/jdk/java/foreign/TestMemoryCopy.java
+++ b/test/jdk/java/foreign/TestMemoryCopy.java
@@ -44,12 +44,12 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     @Test(dataProvider = "slices")
     public void testCopy(SegmentSlice s1, SegmentSlice s2) {
-        MemoryAddress addr1 = s1.segment.baseAddress();
-        MemoryAddress addr2 = s2.segment.baseAddress();
+        MemoryAddress addr1 = s1.segment.address();
+        MemoryAddress addr2 = s2.segment.address();
         int size = Math.min(s1.size(), s2.size());
         //prepare source and target segments
         for (int i = 0 ; i < size ; i++) {
             BYTE_HANDLE.set(addr2.addOffset(i), (byte)0);
         }
diff a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
--- a/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
+++ b/test/jdk/java/foreign/TestMemoryHandleAsUnsigned.java
@@ -57,14 +57,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), intValue);
+            intHandle.set(segment.address(), intValue);
             int expectedIntValue = Byte.toUnsignedInt(byteValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
+            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
+            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToByteData")
     public Object[][] unsignedLongToByteData() {
@@ -79,14 +79,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_8_BE;
         VarHandle byteHandle = layout.varHandle(byte.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(byteHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Byte.toUnsignedLong(byteValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((byte) byteHandle.get(segment.baseAddress()), byteValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((byte) byteHandle.get(segment.address()), byteValue);
         }
     }
 
     @DataProvider(name = "unsignedIntToShortData")
     public Object[][] unsignedIntToShortData() {
@@ -101,14 +101,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle intHandle = MemoryHandles.asUnsigned(shortHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), intValue);
+            intHandle.set(segment.address(), intValue);
             int expectedIntValue = Short.toUnsignedInt(shortValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), expectedIntValue);
-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
+            assertEquals((int) intHandle.get(segment.address()), expectedIntValue);
+            assertEquals((short) shortHandle.get(segment.address()), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToShortData")
     public Object[][] unsignedLongToShortData() {
@@ -123,14 +123,14 @@
         MemoryLayout layout = MemoryLayouts.BITS_16_BE;
         VarHandle shortHandle = layout.varHandle(short.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(shortHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Short.toUnsignedLong(shortValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((short) shortHandle.get(segment.baseAddress()), shortValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((short) shortHandle.get(segment.address()), shortValue);
         }
     }
 
     @DataProvider(name = "unsignedLongToIntData")
     public Object[][] unsignedLongToIntData() {
@@ -149,36 +149,36 @@
         MemoryLayout layout = MemoryLayouts.BITS_32_BE;
         VarHandle intHandle = layout.varHandle(int.class);
         VarHandle longHandle = MemoryHandles.asUnsigned(intHandle, long.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            longHandle.set(segment.baseAddress(), longValue);
+            longHandle.set(segment.address(), longValue);
             long expectedLongValue = Integer.toUnsignedLong(intValue);
-            assertEquals((long) longHandle.get(segment.baseAddress()), expectedLongValue);
-            assertEquals((int) intHandle.get(segment.baseAddress()), intValue);
+            assertEquals((long) longHandle.get(segment.address()), expectedLongValue);
+            assertEquals((int) intHandle.get(segment.address()), intValue);
         }
     }
 
     @Test
     public void testCoordinatesSequenceLayout() {
         MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);
         VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());
         VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
 
         try (MemorySegment segment = MemorySegment.allocateNative(layout)) {
-            intHandle.set(segment.baseAddress(), 0L, (int) -1);
-            assertEquals((int) intHandle.get(segment.baseAddress(), 0L), 255);
-            intHandle.set(segment.baseAddress(), 1L, (int) 200);
-            assertEquals((int) intHandle.get(segment.baseAddress(), 1L), 200);
+            intHandle.set(segment.address(), 0L, (int) -1);
+            assertEquals((int) intHandle.get(segment.address(), 0L), 255);
+            intHandle.set(segment.address(), 1L, (int) 200);
+            assertEquals((int) intHandle.get(segment.address(), 1L), 200);
         }
     }
 
     @Test
     public void testCoordinatesStride() {
         byte[] arr = { 0, 0, (byte) 129, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
 
         {
             VarHandle byteHandle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
             VarHandle intHandle = MemoryHandles.asUnsigned(byteHandle, int.class);
             VarHandle strideHandle = MemoryHandles.withStride(intHandle, 1);
diff a/test/jdk/java/foreign/TestMismatch.java b/test/jdk/java/foreign/TestMismatch.java
--- a/test/jdk/java/foreign/TestMismatch.java
+++ b/test/jdk/java/foreign/TestMismatch.java
@@ -45,11 +45,11 @@
 
     final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);
 
     // stores a increasing sequence of values into the memory of the given segment
     static MemorySegment initializeSegment(MemorySegment segment) {
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
         for (int i = 0 ; i < segment.byteSize() ; i++) {
             BYTE_HANDLE.set(addr.addOffset(i), (byte)i);
         }
         return segment;
     }
@@ -79,11 +79,11 @@
         s1 = initializeSegment(s1);
         s2 = initializeSegment(s2);
 
         for (long i = s2.byteSize() -1 ; i >= 0; i--) {
             long expectedMismatchOffset = i;
-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
 
             if (s1.byteSize() == s2.byteSize()) {
                 assertEquals(s1.mismatch(s2), expectedMismatchOffset);
                 assertEquals(s2.mismatch(s1), expectedMismatchOffset);
             } else if (s1.byteSize() > s2.byteSize()) {
@@ -133,11 +133,11 @@
         }
     }
 
     private void testLargeMismatchAcrossMaxBoundary(MemorySegment s1, MemorySegment s2) {
         for (long i = s2.byteSize() -1 ; i >= Integer.MAX_VALUE - 10L; i--) {
-            BYTE_HANDLE.set(s2.baseAddress().addOffset(i), (byte) 0xFF);
+            BYTE_HANDLE.set(s2.address().addOffset(i), (byte) 0xFF);
             long expectedMismatchOffset = i;
             assertEquals(s1.mismatch(s2), expectedMismatchOffset);
             assertEquals(s2.mismatch(s1), expectedMismatchOffset);
         }
     }
diff a/test/jdk/java/foreign/TestNative.java b/test/jdk/java/foreign/TestNative.java
--- a/test/jdk/java/foreign/TestNative.java
+++ b/test/jdk/java/foreign/TestNative.java
@@ -145,11 +145,11 @@
     public static native void free(long address);
 
     @Test(dataProvider="nativeAccessOps")
     public void testNativeAccess(Consumer<MemoryAddress> checker, Consumer<MemoryAddress> initializer, SequenceLayout seq) {
         try (MemorySegment segment = MemorySegment.allocateNative(seq)) {
-            MemoryAddress address = segment.baseAddress();
+            MemoryAddress address = segment.address();
             initializer.accept(address);
             checker.accept(address);
         }
     }
 
@@ -206,11 +206,11 @@
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadResize() {
         try (MemorySegment segment = MemorySegment.allocateNative(4)) {
-            MemorySegment.ofNativeRestricted(segment.baseAddress(), 0, null, null, null);
+            MemorySegment.ofNativeRestricted(segment.address(), 0, null, null, null);
         }
     }
 
     @Test(expectedExceptions = NullPointerException.class)
     public void testNullUnsafeSegment() {
diff a/test/jdk/java/foreign/TestNativeScope.java b/test/jdk/java/foreign/TestNativeScope.java
--- a/test/jdk/java/foreign/TestNativeScope.java
+++ b/test/jdk/java/foreign/TestNativeScope.java
@@ -109,11 +109,11 @@
             for (int i = 8 ; i < SIZE_256M ; i *= 8) {
                 MemoryAddress address = scope.allocate(i);
                 //check size
                 assertEquals(address.segment().byteSize(), i);
                 //check alignment
-                assertTrue(address.segment().baseAddress().toRawLongValue() % i == 0);
+                assertTrue(address.segment().address().toRawLongValue() % i == 0);
             }
         }
     }
 
     @Test
diff a/test/jdk/java/foreign/TestRebase.java b/test/jdk/java/foreign/TestRebase.java
--- a/test/jdk/java/foreign/TestRebase.java
+++ b/test/jdk/java/foreign/TestRebase.java
@@ -46,28 +46,28 @@
 
     @Test(dataProvider = "slices")
     public void testRebase(SegmentSlice s1, SegmentSlice s2) {
         if (s1.contains(s2)) {
             //check that an address and its rebased counterpart point to same element
-            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress base = s2.segment.address();
             MemoryAddress rebased = base.rebase(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
                 int expected = (int) BYTE_VH.get(base.addOffset(i));
                 int found = (int) BYTE_VH.get(rebased.addOffset(i));
                 assertEquals(found, expected);
             }
         } else if (s1.kind != s2.kind) {
             // check that rebase s1 to s2 fails
             try {
-                s1.segment.baseAddress().rebase(s2.segment);
+                s1.segment.address().rebase(s2.segment);
                 fail("Rebase unexpectedly passed!");
             } catch (IllegalArgumentException ex) {
                 assertTrue(true);
             }
         } else if (!s2.contains(s1)) {
             //disjoint segments - check that rebased address is out of bounds
-            MemoryAddress base = s2.segment.baseAddress();
+            MemoryAddress base = s2.segment.address();
             MemoryAddress rebased = base.rebase(s1.segment);
             for (int i = 0; i < s2.size(); i++) {
                 BYTE_VH.get(base.addOffset(i));
                 try {
                     BYTE_VH.get(rebased.addOffset(i));
@@ -125,11 +125,11 @@
         List<SegmentSlice> slices = new ArrayList<>();
         for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {
             //init root segment
             MemorySegment segment = kind.makeSegment(16);
             for (int i = 0 ; i < 16 ; i++) {
-                BYTE_VH.set(segment.baseAddress().addOffset(i), (byte)i);
+                BYTE_VH.set(segment.address().addOffset(i), (byte)i);
             }
             //compute all slices
             for (int size : sizes) {
                 for (int index = 0 ; index < 16 ; index += size) {
                     MemorySegment slice = segment.asSlice(index, size);
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -92,11 +92,11 @@
     public void testNativeSegmentIsZeroed() {
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(1000)) {
             for (long i = 0 ; i < segment.byteSize() ; i++) {
-                assertEquals(0, (byte)byteHandle.get(segment.baseAddress(), i));
+                assertEquals(0, (byte)byteHandle.get(segment.address(), i));
             }
         }
     }
 
     @Test
@@ -125,21 +125,21 @@
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
         try (MemorySegment segment = MemorySegment.allocateNative(10)) {
             //init
             for (byte i = 0 ; i < segment.byteSize() ; i++) {
-                byteHandle.set(segment.baseAddress(), (long)i, i);
+                byteHandle.set(segment.address(), (long)i, i);
             }
             long start = 0;
-            MemoryAddress base = segment.baseAddress();
+            MemoryAddress base = segment.address();
             MemoryAddress last = base.addOffset(10);
             while (!base.equals(last)) {
                 MemorySegment slice = segment.asSlice(base.segmentOffset(), 10 - start);
                 for (long i = start ; i < 10 ; i++) {
                     assertEquals(
-                            byteHandle.get(segment.baseAddress(), i),
-                            byteHandle.get(slice.baseAddress(), i - start)
+                            byteHandle.get(segment.address(), i),
+                            byteHandle.get(slice.address(), i - start)
                     );
                 }
                 base = base.addOffset(1);
                 start++;
             }
@@ -195,24 +195,24 @@
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
                 segment.fill(value);
                 for (long l = 0; l < segment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);
+                    assertEquals((byte) byteHandle.get(segment.address(), l), value);
                 }
 
                 // fill a slice
                 var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
                 for (long l = 0; l < sliceSegment.byteSize(); l++) {
-                    assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);
+                    assertEquals((byte) byteHandle.get(sliceSegment.address(), l), ~value);
                 }
                 // assert enclosing slice
-                assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);
+                assertEquals((byte) byteHandle.get(segment.address(), 0L), value);
                 for (long l = 1; l < segment.byteSize() - 2; l++) {
-                    assertEquals((byte) byteHandle.get(segment.baseAddress(), l), (byte) ~value);
+                    assertEquals((byte) byteHandle.get(segment.address(), l), (byte) ~value);
                 }
-                assertEquals((byte) byteHandle.get(segment.baseAddress(), segment.byteSize() - 1L), value);
+                assertEquals((byte) byteHandle.get(segment.address(), segment.byteSize() - 1L), value);
             }
         }
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
@@ -434,17 +434,17 @@
             }
         },
         READ(MemorySegment.READ) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.get(segment.baseAddress());
+                INT_HANDLE.get(segment.address());
             }
         },
         WRITE(MemorySegment.WRITE) {
             @Override
             void run(MemorySegment segment) {
-                INT_HANDLE.set(segment.baseAddress(), 42);
+                INT_HANDLE.set(segment.address(), 42);
             }
         },
         HANDOFF(MemorySegment.HANDOFF) {
             @Override
             void run(MemorySegment segment) {
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -39,11 +39,10 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Spliterator;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 
 import static org.testng.Assert.*;
@@ -55,16 +54,16 @@
     @Test
     public void testConfined() throws Throwable {
         Thread owner = Thread.currentThread();
         MemorySegment s = MemorySegment.allocateNative(4);
         AtomicReference<MemorySegment> confined = new AtomicReference<>(s);
-        setInt(s.baseAddress(), 42);
-        assertEquals(getInt(s.baseAddress()), 42);
+        setInt(s.address(), 42);
+        assertEquals(getInt(s.address()), 42);
         List<Thread> threads = new ArrayList<>();
         for (int i = 0 ; i < 1000 ; i++) {
             threads.add(new Thread(() -> {
-                assertEquals(getInt(confined.get().baseAddress()), 42);
+                assertEquals(getInt(confined.get().address()), 42);
                 confined.set(confined.get().withOwnerThread(owner));
             }));
         }
         threads.forEach(t -> {
             confined.set(confined.get().withOwnerThread(t));
@@ -81,11 +80,11 @@
     @Test
     public void testShared() throws Throwable {
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
         try (MemorySegment s = MemorySegment.allocateNative(layout)) {
             for (int i = 0 ; i < layout.elementCount().getAsLong() ; i++) {
-                setInt(s.baseAddress().addOffset(i * 4), 42);
+                setInt(s.address().addOffset(i * 4), 42);
             }
             List<Thread> threads = new ArrayList<>();
             List<Spliterator<MemorySegment>> spliterators = new ArrayList<>();
             spliterators.add(MemorySegment.spliterator(s, layout));
             while (true) {
@@ -104,11 +103,11 @@
 
             AtomicInteger accessCount = new AtomicInteger();
             for (Spliterator<MemorySegment> spliterator : spliterators) {
                 threads.add(new Thread(() -> {
                     spliterator.tryAdvance(local -> {
-                        assertEquals(getInt(local.baseAddress()), 42);
+                        assertEquals(getInt(local.address()), 42);
                         accessCount.incrementAndGet();
                     });
                 }));
             }
             threads.forEach(Thread::start);
@@ -124,18 +123,18 @@
     }
 
     @Test
     public void testSharedUnsafe() throws Throwable {
         try (MemorySegment s = MemorySegment.allocateNative(4)) {
-            setInt(s.baseAddress(), 42);
-            assertEquals(getInt(s.baseAddress()), 42);
+            setInt(s.address(), 42);
+            assertEquals(getInt(s.address()), 42);
             List<Thread> threads = new ArrayList<>();
             MemorySegment sharedSegment = MemorySegment.ofNativeRestricted(
-                    s.baseAddress(), s.byteSize(), null, null, null);
+                    s.address(), s.byteSize(), null, null, null);
             for (int i = 0 ; i < 1000 ; i++) {
                 threads.add(new Thread(() -> {
-                    assertEquals(getInt(sharedSegment.baseAddress()), 42);
+                    assertEquals(getInt(sharedSegment.address()), 42);
                 }));
             }
             threads.forEach(Thread::start);
             threads.forEach(t -> {
                 try {
@@ -224,20 +223,20 @@
                     try {
                         b.await();
                     } catch (InterruptedException e) {
                     }
 
-                    MemoryAddress base = s2.baseAddress();
+                    MemoryAddress base = s2.address();
                     setInt(base.addOffset(4), -42);
                     fail();
                 } catch (IllegalStateException ex) {
                     assertTrue(ex.getMessage().contains("owning thread"));
                 }
             });
 
             a.await();
-            MemoryAddress base = s1.baseAddress();
+            MemoryAddress base = s1.address();
             setInt(base.addOffset(4), 42);
         }
 
         b.countDown();
         r.get();
diff a/test/jdk/java/foreign/TestSlices.java b/test/jdk/java/foreign/TestSlices.java
--- a/test/jdk/java/foreign/TestSlices.java
+++ b/test/jdk/java/foreign/TestSlices.java
@@ -50,11 +50,11 @@
     public void testSlices(VarHandle handle, int lo, int hi, int[] values) {
         try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {
             //init
             for (long i = 0 ; i < 2 ; i++) {
                 for (long j = 0 ; j < 5 ; j++) {
-                    VH_ALL.set(segment.baseAddress(), i, j, (int)j + 1 + ((int)i * 5));
+                    VH_ALL.set(segment.address(), i, j, (int)j + 1 + ((int)i * 5));
                 }
             }
 
             checkSlice(segment, handle, lo, hi, values);
         }
@@ -62,11 +62,11 @@
 
     static void checkSlice(MemorySegment segment, VarHandle handle, long i_max, long j_max, int... values) {
         int index = 0;
         for (long i = 0 ; i < i_max ; i++) {
             for (long j = 0 ; j < j_max ; j++) {
-                int x = (int) handle.get(segment.baseAddress(), i, j);
+                int x = (int) handle.get(segment.address(), i, j);
                 assertEquals(x, values[index++]);
             }
         }
         assertEquals(index, values.length);
     }
diff a/test/jdk/java/foreign/TestSpliterator.java b/test/jdk/java/foreign/TestSpliterator.java
--- a/test/jdk/java/foreign/TestSpliterator.java
+++ b/test/jdk/java/foreign/TestSpliterator.java
@@ -61,11 +61,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+            INT_HANDLE.set(segment.address(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
         //serial
         long serial = sum(0, segment);
         assertEquals(serial, expected);
@@ -86,11 +86,11 @@
         SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
 
         //setup
         MemorySegment segment = MemorySegment.allocateNative(layout);
         for (int i = 0; i < layout.elementCount().getAsLong(); i++) {
-            INT_HANDLE.set(segment.baseAddress(), (long) i, i);
+            INT_HANDLE.set(segment.address(), (long) i, i);
         }
         long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();
 
         //check that a segment w/o ACQUIRE access mode can still be used from same thread
         AtomicLong spliteratorSum = new AtomicLong();
@@ -98,16 +98,16 @@
                 .forEachRemaining(s -> spliteratorSum.addAndGet(sumSingle(0L, s)));
         assertEquals(spliteratorSum.get(), expected);
     }
 
     static long sumSingle(long acc, MemorySegment segment) {
-        return acc + (int)INT_HANDLE.get(segment.baseAddress(), 0L);
+        return acc + (int)INT_HANDLE.get(segment.address(), 0L);
     }
 
     static long sum(long start, MemorySegment segment) {
         long sum = start;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         int length = (int)segment.byteSize();
         for (int i = 0 ; i < length / CARRIER_SIZE ; i++) {
             sum += (int)INT_HANDLE.get(base, (long)i);
         }
         return sum;
diff a/test/jdk/java/foreign/TestTypeAccess.java b/test/jdk/java/foreign/TestTypeAccess.java
--- a/test/jdk/java/foreign/TestTypeAccess.java
+++ b/test/jdk/java/foreign/TestTypeAccess.java
@@ -58,31 +58,31 @@
     }
 
     @Test(expectedExceptions=ClassCastException.class)
     public void testMemoryAddressValueGetAsString() {
         try (MemorySegment s = MemorySegment.allocateNative(8)) {
-            String address = (String)ADDR_HANDLE.get(s.baseAddress());
+            String address = (String)ADDR_HANDLE.get(s.address());
         }
     }
 
     @Test(expectedExceptions=ClassCastException.class)
     public void testMemoryAddressValueSetAsString() {
         try (MemorySegment s = MemorySegment.allocateNative(8)) {
-            ADDR_HANDLE.set(s.baseAddress(), "string");
+            ADDR_HANDLE.set(s.address(), "string");
         }
     }
 
     @Test(expectedExceptions=WrongMethodTypeException.class)
     public void testMemoryAddressValueGetAsPrimitive() {
         try (MemorySegment s = MemorySegment.allocateNative(8)) {
-            int address = (int)ADDR_HANDLE.get(s.baseAddress());
+            int address = (int)ADDR_HANDLE.get(s.address());
         }
     }
 
     @Test(expectedExceptions=WrongMethodTypeException.class)
     public void testMemoryAddressValueSetAsPrimitive() {
         try (MemorySegment s = MemorySegment.allocateNative(8)) {
-            ADDR_HANDLE.set(s.baseAddress(), 1);
+            ADDR_HANDLE.set(s.address(), 1);
         }
     }
 
 }
diff a/test/jdk/java/foreign/TestUpcall.java b/test/jdk/java/foreign/TestUpcall.java
--- a/test/jdk/java/foreign/TestUpcall.java
+++ b/test/jdk/java/foreign/TestUpcall.java
@@ -99,11 +99,11 @@
 
     static MemoryAddress dummyAddress;
 
     @BeforeClass
     void setup() {
-        dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid()).baseAddress();
+        dummyAddress = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid()).address();
     }
 
     @AfterClass
     void teardown() {
         dummyAddress.segment().close();
@@ -194,21 +194,21 @@
 
         MemoryLayout[] paramLayouts = params.stream().map(p -> p.layout(fields)).toArray(MemoryLayout[]::new);
         FunctionDescriptor func = ret != Ret.VOID
                 ? FunctionDescriptor.of(firstlayout, paramLayouts)
                 : FunctionDescriptor.ofVoid(paramLayouts);
-        MemoryAddress stub = abi.upcallStub(mh, func).baseAddress();
+        MemoryAddress stub = abi.upcallStub(mh, func).address();
         return stub;
     }
 
     private static void assertStructEquals(MemorySegment actual, MemorySegment expected, MemoryLayout layout) {
         assertEquals(actual.byteSize(), expected.byteSize());
         GroupLayout g = (GroupLayout) layout;
         for (MemoryLayout field : g.memberLayouts()) {
             if (field instanceof ValueLayout) {
                 VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));
-                assertEquals(vh.get(actual.baseAddress()), vh.get(expected.baseAddress()));
+                assertEquals(vh.get(actual.address()), vh.get(expected.address()));
             }
         }
     }
 
     private static Class<?> vhCarrier(MemoryLayout layout) {
diff a/test/jdk/java/foreign/TestUpcallStubs.java b/test/jdk/java/foreign/TestUpcallStubs.java
--- a/test/jdk/java/foreign/TestUpcallStubs.java
+++ b/test/jdk/java/foreign/TestUpcallStubs.java
@@ -62,11 +62,11 @@
 
     @Test(expectedExceptions = UnsupportedOperationException.class)
     public void testNoAccess() {
         try (MemorySegment stub = getStub()) {
             VarHandle vh = JAVA_INT.varHandle(int.class);
-            vh.set(stub.baseAddress(), 10);
+            vh.set(stub.address(), 10);
         }
     }
 
     @Test
     public void testFree() {
@@ -84,11 +84,11 @@
 
     @DataProvider
     public static Object[][] badAddresses() {
         return new Object[][]{
             { MemoryAddress.ofLong(42) /* random address */ },
-            { MemorySegment.ofArray(new int []{ 1, 2, 3 }).baseAddress() /* heap address */ }
+            { MemorySegment.ofArray(new int []{ 1, 2, 3 }).address() /* heap address */ }
         };
     }
 
     // where
     public static void dummy() {}
diff a/test/jdk/java/foreign/TestVarArgs.java b/test/jdk/java/foreign/TestVarArgs.java
--- a/test/jdk/java/foreign/TestVarArgs.java
+++ b/test/jdk/java/foreign/TestVarArgs.java
@@ -80,17 +80,17 @@
     public void testVarArgs(List<VarArg> args) throws Throwable {
         try (MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG);
             MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo);
             MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT))) {
 
-            MemoryAddress callInfoPtr = callInfo.baseAddress();
+            MemoryAddress callInfoPtr = callInfo.address();
 
-            VH_CallInfo_writeback.set(callInfoPtr, writeBack.baseAddress().toRawLongValue());
-            VH_CallInfo_argIDs.set(callInfoPtr, argIDs.baseAddress().toRawLongValue());
+            VH_CallInfo_writeback.set(callInfoPtr, writeBack.address().toRawLongValue());
+            VH_CallInfo_argIDs.set(callInfoPtr, argIDs.address().toRawLongValue());
 
             for (int i = 0; i < args.size(); i++) {
-                VH_IntArray.set(argIDs.baseAddress(), (long) i, args.get(i).id.ordinal());
+                VH_IntArray.set(argIDs.address(), (long) i, args.get(i).id.ordinal());
             }
 
             List<MemoryLayout> argLayouts = new ArrayList<>();
             argLayouts.add(C_POINTER); // call info
             argLayouts.add(C_INT); // size
@@ -114,11 +114,11 @@
 
             downcallHandle.invokeWithArguments(argValues);
 
             for (int i = 0; i < args.size(); i++) {
                 VarArg a = args.get(i);
-                MemoryAddress writtenPtr = writeBack.baseAddress().addOffset(i * WRITEBACK_BYTES_PER_ARG);
+                MemoryAddress writtenPtr = writeBack.address().addOffset(i * WRITEBACK_BYTES_PER_ARG);
                 Object written = a.vh.get(writtenPtr);
                 assertEquals(written, a.value);
             }
         }
     }
diff a/test/jdk/java/foreign/TestVarHandleCombinators.java b/test/jdk/java/foreign/TestVarHandleCombinators.java
--- a/test/jdk/java/foreign/TestVarHandleCombinators.java
+++ b/test/jdk/java/foreign/TestVarHandleCombinators.java
@@ -47,29 +47,29 @@
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 1);
 
         byte[] arr = { 0, 0, -1, 0 };
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress addr = segment.baseAddress();
+        MemoryAddress addr = segment.address();
 
         assertEquals((byte) vh.get(addr, 2), (byte) -1);
     }
 
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedElement() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withStride(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.baseAddress(), 1L); //should throw
+        vh.get(segment.address(), 1L); //should throw
     }
 
     public void testZeroStrideElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle strided_vh = MemoryHandles.withStride(vh, 0);
         MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.baseAddress()), strided_vh.get(segment.baseAddress(), (long)i));
+            assertEquals((int)vh.get(segment.address()), strided_vh.get(segment.address(), (long)i));
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testStrideWrongHandle() {
@@ -90,11 +90,11 @@
     @Test
     public void testAlign() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
 
         MemorySegment segment = MemorySegment.allocateNative(1, 2);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10); // fine, memory region is aligned
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
@@ -102,21 +102,21 @@
     public void testAlignBadAccess() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1); // offset by 1 byte
 
         MemorySegment segment = MemorySegment.allocateNative(2, 2);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10); // should be bad align
     }
 
     public void testZeroOffsetElement() {
         VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());
         VarHandle offset_vh = MemoryHandles.withOffset(vh, 0);
         MemorySegment segment = MemorySegment.ofArray(new int[] { 42 });
         for (int i = 0 ; i < 100 ; i++) {
-            assertEquals((int)vh.get(segment.baseAddress()), offset_vh.get(segment.baseAddress(), (long)i));
+            assertEquals((int)vh.get(segment.address()), offset_vh.get(segment.address(), (long)i));
         }
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testOffsetWrongHandle() {
@@ -127,31 +127,31 @@
     @Test(expectedExceptions = IllegalStateException.class)
     public void testUnalignedOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 2);
         MemorySegment segment = MemorySegment.ofArray(new byte[4]);
-        vh.get(segment.baseAddress()); //should throw
+        vh.get(segment.address()); //should throw
     }
 
     @Test
     public void testOffset() {
         VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());
         vh = MemoryHandles.withOffset(vh, 1);
 
         MemorySegment segment = MemorySegment.ofArray(new byte[2]);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (byte) 10);
         assertEquals((byte) vh.get(address), (byte) 10);
     }
 
     @Test
     public void testByteOrderLE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0xFF);
         assertEquals(arr[1], (byte) 0);
     }
@@ -159,11 +159,11 @@
     @Test
     public void testByteOrderBE() {
         VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);
         byte[] arr = new byte[2];
         MemorySegment segment = MemorySegment.ofArray(arr);
-        MemoryAddress address = segment.baseAddress();
+        MemoryAddress address = segment.address();
 
         vh.set(address, (short) 0xFF);
         assertEquals(arr[0], (byte) 0);
         assertEquals(arr[1], (byte) 0xFF);
     }
@@ -181,13 +181,13 @@
         VarHandle outer_vh = MemoryHandles.withStride(inner_vh, 5 * 8);
         int count = 0;
         try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {
             for (long i = 0; i < outer_size; i++) {
                 for (long j = 0; j < inner_size; j++) {
-                    outer_vh.set(segment.baseAddress(), i, j, count);
+                    outer_vh.set(segment.address(), i, j, count);
                     assertEquals(
-                            (int)inner_vh.get(segment.baseAddress().addOffset(i * inner_size * 8), j),
+                            (int)inner_vh.get(segment.address().addOffset(i * inner_size * 8), j),
                             count);
                     count++;
                 }
             }
         }
diff a/test/jdk/java/foreign/valist/VaListTest.java b/test/jdk/java/foreign/valist/VaListTest.java
--- a/test/jdk/java/foreign/valist/VaListTest.java
+++ b/test/jdk/java/foreign/valist/VaListTest.java
@@ -200,11 +200,11 @@
         Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->
             list -> {
                 MemoryAddress ma = list.vargAsAddress(layout);
                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
                         4, Thread.currentThread(), null, null);
-                return MemoryAccess.getInt(accessibleSegment.baseAddress());
+                return MemoryAccess.getInt(accessibleSegment.address());
             };
         Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
         return new Object[][]{
             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },
@@ -216,12 +216,12 @@
     @Test(dataProvider = "pointers")
     public void testVaListMemoryAddress(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                         Function<VaList, Integer> getFromPointer,
                                         MemoryLayout pointerLayout) {
         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
-            MemoryAccess.setInt(msInt.baseAddress(), 10);
-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {
+            MemoryAccess.setInt(msInt.address(), 10);
+            try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()))) {
                 int x = getFromPointer.apply(vaList);
                 assertEquals(x, 10);
             }
         }
     }
@@ -235,12 +235,12 @@
     public static Object[][] structs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact
             = (pointLayout, VH_Point_x, VH_Point_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(pointLayout);
-                    int x = (int) VH_Point_x.get(struct.baseAddress());
-                    int y = (int) VH_Point_y.get(struct.baseAddress());
+                    int x = (int) VH_Point_x.get(struct.address());
+                    int y = (int) VH_Point_y.get(struct.address());
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact
             = (pointLayout, VH_Point_x, VH_Point_y) ->
@@ -269,12 +269,12 @@
     @Test(dataProvider = "structs")
     public void testStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                            Function<VaList, Integer> sumStruct,
                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
-            VH_Point_x.set(struct.baseAddress(), 5);
-            VH_Point_y.set(struct.baseAddress(), 10);
+            VH_Point_x.set(struct.address(), 5);
+            VH_Point_y.set(struct.address(), 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {
                 int sum = sumStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -286,12 +286,12 @@
     public static Object[][] bigStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
-                    long x = (long) VH_BigPoint_x.get(struct.baseAddress());
-                    long y = (long) VH_BigPoint_y.get(struct.baseAddress());
+                    long x = (long) VH_BigPoint_x.get(struct.address());
+                    long y = (long) VH_BigPoint_y.get(struct.address());
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->
@@ -320,12 +320,12 @@
     @Test(dataProvider = "bigStructs")
     public void testBigStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                               Function<VaList, Long> sumBigStruct,
                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
-            VH_BigPoint_x.set(struct.baseAddress(), 5);
-            VH_BigPoint_y.set(struct.baseAddress(), 10);
+            VH_BigPoint_x.set(struct.address(), 5);
+            VH_BigPoint_y.set(struct.address(), 10);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {
                 long sum = sumBigStruct.apply(vaList);
                 assertEquals(sum, 15);
             }
@@ -337,12 +337,12 @@
     public static Object[][] floatStructs() {
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact
             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
-                    float x = (float) VH_FloatPoint_x.get(struct.baseAddress());
-                    float y = (float) VH_FloatPoint_y.get(struct.baseAddress());
+                    float x = (float) VH_FloatPoint_x.get(struct.address());
+                    float y = (float) VH_FloatPoint_y.get(struct.address());
                     return x + y;
                 };
 
         TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact
             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->
@@ -372,12 +372,12 @@
     public void testFloatStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,
                                 Function<VaList, Float> sumFloatStruct,
                                 MemoryLayout FloatPoint_LAYOUT,
                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {
         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
-            VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
-            VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
+            VH_FloatPoint_x.set(struct.address(), 1.234f);
+            VH_FloatPoint_y.set(struct.address(), 3.142f);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
                 float sum = sumFloatStruct.apply(vaList);
                 assertEquals(sum, 4.376f, 0.00001f);
             }
@@ -393,13 +393,13 @@
     public static Object[][] hugeStructs() {
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact
             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
                 list -> {
                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
-                    long x = (long) VH_HugePoint_x.get(struct.baseAddress());
-                    long y = (long) VH_HugePoint_y.get(struct.baseAddress());
-                    long z = (long) VH_HugePoint_z.get(struct.baseAddress());
+                    long x = (long) VH_HugePoint_x.get(struct.address());
+                    long y = (long) VH_HugePoint_y.get(struct.address());
+                    long z = (long) VH_HugePoint_z.get(struct.address());
                     return x + y + z;
                 };
 
         QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact
             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->
@@ -434,13 +434,13 @@
                                MemoryLayout HugePoint_LAYOUT,
                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {
         // On AArch64 a struct needs to be larger than 16 bytes to be
         // passed by reference.
         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
-            VH_HugePoint_x.set(struct.baseAddress(), 1);
-            VH_HugePoint_y.set(struct.baseAddress(), 2);
-            VH_HugePoint_z.set(struct.baseAddress(), 3);
+            VH_HugePoint_x.set(struct.address(), 1);
+            VH_HugePoint_y.set(struct.address(), 2);
+            VH_HugePoint_z.set(struct.address(), 3);
 
             try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {
                 long sum = sumHugeStruct.apply(vaList);
                 assertEquals(sum, 6);
             }
@@ -480,12 +480,12 @@
                           SumStackFunc sumStack,
                           MemoryLayout longLayout,
                           MemoryLayout doubleLayout) {
        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);
             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {
-            MemoryAccess.setLong(longSum.baseAddress(), 0L);
-            MemoryAccess.setDouble(doubleSum.baseAddress(), 0D);
+            MemoryAccess.setLong(longSum.address(), 0L);
+            MemoryAccess.setDouble(doubleSum.address(), 0D);
 
             VaList list = vaListFactory.apply(b -> {
                 for (long l = 1; l <= 16L; l++) {
                     b.vargFromLong(longLayout, l);
                 }
@@ -493,26 +493,26 @@
                     b.vargFromDouble(doubleLayout, d);
                 }
             });
 
             try (list) {
-                sumStack.invoke(longSum.baseAddress(), doubleSum.baseAddress(), list);
+                sumStack.invoke(longSum.address(), doubleSum.address(), list);
             }
 
-            long lSum = MemoryAccess.getLong(longSum.baseAddress());
-            double dSum = MemoryAccess.getDouble(doubleSum.baseAddress());
+            long lSum = MemoryAccess.getLong(longSum.address());
+            double dSum = MemoryAccess.getDouble(doubleSum.address());
 
             assertEquals(lSum, 136L);
             assertEquals(dSum, 136D);
         }
     }
 
     @Test(dataProvider = "upcalls")
     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
-            target.invokeExact(stub.baseAddress());
+            target.invokeExact(stub.address());
         }
     }
 
     @DataProvider
     public Object[][] emptyVaLists() {
@@ -569,16 +569,16 @@
                                 Function<VaList, Integer> sumStruct, // ignored
                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
         MemorySegment pointOut;
         try (NativeScope scope = NativeScope.unboundedScope()) {
             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
-                VH_Point_x.set(pointIn.baseAddress(), 3);
-                VH_Point_y.set(pointIn.baseAddress(), 6);
+                VH_Point_x.set(pointIn.address(), 3);
+                VH_Point_y.set(pointIn.address(), 6);
                 try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {
                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
-                    assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
-                    assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
+                    assertEquals((int) VH_Point_x.get(pointOut.address()), 3);
+                    assertEquals((int) VH_Point_y.get(pointOut.address()), 6);
                 }
                 assertTrue(pointOut.isAlive()); // after VaList freed
             }
             assertTrue(pointOut.isAlive()); // after input MS freed
         }
@@ -685,54 +685,54 @@
         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement("z"));
 
         return new Object[][]{
             { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
+                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
+                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
                 }
             })},
             { linkVaListCB("upcallBigStruct"), VaListConsumer.mh(vaList -> {
                 VaList copy = vaList.copy();
                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
+                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
+                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
 
-                    VH_BigPoint_x.set(struct.baseAddress(), 0);
-                    VH_BigPoint_y.set(struct.baseAddress(), 0);
+                    VH_BigPoint_x.set(struct.address(), 0);
+                    VH_BigPoint_y.set(struct.address(), 0);
                 }
 
                 // should be independent
                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
-                    assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
+                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 8);
+                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 16);
                 }
             })},
             { linkVaListCB("upcallStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(struct.baseAddress()), 5);
-                    assertEquals((int) VH_Point_y.get(struct.baseAddress()), 10);
+                    assertEquals((int) VH_Point_x.get(struct.address()), 5);
+                    assertEquals((int) VH_Point_y.get(struct.address()), 10);
                 }
             })},
             { linkVaListCB("upcallHugeStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
-                    assertEquals((long) VH_HugePoint_x.get(struct.baseAddress()), 1);
-                    assertEquals((long) VH_HugePoint_y.get(struct.baseAddress()), 2);
-                    assertEquals((long) VH_HugePoint_z.get(struct.baseAddress()), 3);
+                    assertEquals((long) VH_HugePoint_x.get(struct.address()), 1);
+                    assertEquals((long) VH_HugePoint_y.get(struct.address()), 2);
+                    assertEquals((long) VH_HugePoint_z.get(struct.address()), 3);
                 }
             })},
             { linkVaListCB("upcallFloatStruct"), VaListConsumer.mh(vaList -> {
                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
-                    assertEquals((float) VH_FloatPoint_x.get(struct.baseAddress()), 1.0f);
-                    assertEquals((float) VH_FloatPoint_y.get(struct.baseAddress()), 2.0f);
+                    assertEquals((float) VH_FloatPoint_x.get(struct.address()), 1.0f);
+                    assertEquals((float) VH_FloatPoint_y.get(struct.address()), 2.0f);
                 }
             })},
             { linkVaListCB("upcallMemoryAddress"), VaListConsumer.mh(vaList -> {
                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
                                                                     Thread.currentThread(), null, null);
-                int x = MemoryAccess.getInt(ms.baseAddress());
+                int x = MemoryAccess.getInt(ms.address());
                 assertEquals(x, 10);
             })},
             { linkVaListCB("upcallDoubles"), VaListConsumer.mh(vaList -> {
                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
@@ -767,27 +767,27 @@
                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
 
                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
-                    assertEquals((int) VH_Point_x.get(point.baseAddress()), 5);
-                    assertEquals((int) VH_Point_y.get(point.baseAddress()), 10);
+                    assertEquals((int) VH_Point_x.get(point.address()), 5);
+                    assertEquals((int) VH_Point_y.get(point.address()), 10);
                 }
 
                 VaList copy = vaList.copy();
                 try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(bigPoint.baseAddress()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(bigPoint.baseAddress()), 20);
+                    assertEquals((long) VH_BigPoint_x.get(bigPoint.address()), 15);
+                    assertEquals((long) VH_BigPoint_y.get(bigPoint.address()), 20);
 
-                    VH_BigPoint_x.set(bigPoint.baseAddress(), 0);
-                    VH_BigPoint_y.set(bigPoint.baseAddress(), 0);
+                    VH_BigPoint_x.set(bigPoint.address(), 0);
+                    VH_BigPoint_y.set(bigPoint.address(), 0);
                 }
 
                 // should be independent
                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
-                    assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 15);
-                    assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 20);
+                    assertEquals((long) VH_BigPoint_x.get(struct.address()), 15);
+                    assertEquals((long) VH_BigPoint_y.get(struct.address()), 20);
                 }
             })},
             // test skip
             { linkVaListCB("upcallStack"), VaListConsumer.mh(vaList -> {
                 vaList.skip(C_LONGLONG, C_LONGLONG, C_LONGLONG, C_LONGLONG);
diff a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
--- a/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
+++ b/test/jdk/java/util/stream/test/org/openjdk/tests/java/util/stream/SegmentTestDataProvider.java
@@ -46,66 +46,66 @@
     static VarHandle LONG_HANDLE = MemoryLayouts.JAVA_LONG.varHandle(long.class);
     static VarHandle FLOAT_HANDLE = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);
     static VarHandle DOUBLE_HANDLE = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);
 
     static boolean compareSegmentsByte(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Byte> mapper = segment -> (byte)BYTE_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Byte> mapper = segment -> (byte)BYTE_HANDLE.get(segment.address());
         List<Byte> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Byte> list2 = segments2.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         return list1.equals(list2);
     }
 
     static boolean compareSegmentsChar(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Character> mapper = segment -> (char)CHAR_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Character> mapper = segment -> (char)CHAR_HANDLE.get(segment.address());
         List<Character> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Character> list2 = segments2.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         return list1.equals(list2);
     }
 
     static boolean compareSegmentsShort(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Short> mapper = segment -> (short)SHORT_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Short> mapper = segment -> (short)SHORT_HANDLE.get(segment.address());
         List<Short> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Short> list2 = segments2.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         return list1.equals(list2);
     }
 
     static boolean compareSegmentsInt(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Integer> mapper = segment -> (int)INT_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Integer> mapper = segment -> (int)INT_HANDLE.get(segment.address());
         List<Integer> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Integer> list2 = segments2.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         return list1.equals(list2);
     }
 
     static boolean compareSegmentsLong(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Long> mapper = segment -> (long)LONG_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Long> mapper = segment -> (long)LONG_HANDLE.get(segment.address());
         List<Long> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Long> list2 = segments2.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         return list1.equals(list2);
     }
 
     static boolean compareSegmentsFloat(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Float> mapper = segment -> (float)FLOAT_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Float> mapper = segment -> (float)FLOAT_HANDLE.get(segment.address());
         List<Float> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Float> list2 = segments2.stream()
                 .map(mapper)
@@ -120,11 +120,11 @@
             input.accept(dest);
         };
     }
 
     static boolean compareSegmentsDouble(Collection<MemorySegment> segments1, Collection<MemorySegment> segments2, boolean isOrdered) {
-        Function<MemorySegment, Double> mapper = segment -> (double)DOUBLE_HANDLE.get(segment.baseAddress());
+        Function<MemorySegment, Double> mapper = segment -> (double)DOUBLE_HANDLE.get(segment.address());
         List<Double> list1 = segments1.stream()
                 .map(mapper)
                 .collect(Collectors.toList());
         List<Double> list2 = segments2.stream()
                 .map(mapper)
@@ -132,11 +132,11 @@
         return list1.equals(list2);
     }
 
     static void initSegment(MemorySegment segment) {
         for (int i = 0 ; i < segment.byteSize() ; i++) {
-            BYTE_HANDLE.set(segment.baseAddress(), (byte)i);
+            BYTE_HANDLE.set(segment.address(), (byte)i);
         }
     }
 
     static Object[][] spliteratorTestData = {
             { "bytes", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverConstant.java
@@ -70,11 +70,11 @@
         }
     }
 
     //setup native memory segment
 
-    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).baseAddress();
+    static final MemoryAddress segment_addr = MemorySegment.allocateNative(ALLOC_SIZE).address();
     static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());
 
     static {
         for (int i = 0; i < ELEM_SIZE; i++) {
             VH_int.set(segment_addr, (long) i, i);
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNew.java
@@ -20,11 +20,10 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 package org.openjdk.bench.jdk.incubator.foreign;
 
-import jdk.incubator.foreign.MemoryAddress;
 import jdk.incubator.foreign.MemoryLayout;
 import jdk.incubator.foreign.MemorySegment;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Fork;
@@ -72,11 +71,11 @@
 
     @Benchmark
     public void segment_loop() {
         MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
         segment.close();
     }
 
     @Benchmark
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstant.java
@@ -72,11 +72,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
         byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());
         for (int i = 0; i < ELEM_SIZE; i++) {
             byteBuffer.putInt(i * CARRIER_SIZE , i);
         }
@@ -96,11 +96,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -118,39 +118,39 @@
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantHeap.java
@@ -89,11 +89,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -110,40 +110,40 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/LoopOverNonConstantMapped.java
@@ -95,11 +95,11 @@
                 byteBuffer.putInt(i * CARRIER_SIZE, i);
             }
             ((MappedByteBuffer)byteBuffer).force();
         }
         segment = MemorySegment.mapFromPath(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);
-        unsafe_addr = segment.baseAddress().toRawLongValue();
+        unsafe_addr = segment.address().toRawLongValue();
     }
 
     @TearDown
     public void tearDown() {
         segment.close();
@@ -113,11 +113,11 @@
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int segment_get() {
-        return (int) VH_int.get(segment.baseAddress(), 0L);
+        return (int) VH_int.get(segment.address(), 0L);
     }
 
     @Benchmark
     @OutputTimeUnit(TimeUnit.NANOSECONDS)
     public int BB_get() {
@@ -134,40 +134,40 @@
     }
 
     @Benchmark
     public int segment_loop() {
         int sum = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_static() {
         int res = 0;
         for (int i = 0; i < ELEM_SIZE; i ++) {
-            res += MemoryAccess.getIntAtIndex(segment.baseAddress(), i);
+            res += MemoryAccess.getIntAtIndex(segment.address(), i);
         }
         return res;
     }
 
     @Benchmark
     public int segment_loop_slice() {
         int sum = 0;
-        MemoryAddress base = segment.asSlice(0, segment.byteSize()).baseAddress();
+        MemoryAddress base = segment.asSlice(0, segment.byteSize()).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_loop_readonly() {
         int sum = 0;
-        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).baseAddress();
+        MemoryAddress base = segment.withAccessModes(MemorySegment.READ).address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int) VH_int.get(base, (long) i);
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/ParallelSum.java
@@ -42,16 +42,14 @@
 import jdk.incubator.foreign.MemorySegment;
 import java.lang.invoke.VarHandle;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
-import java.util.OptionalInt;
 import java.util.Spliterator;
 import java.util.concurrent.CountedCompleter;
 import java.util.concurrent.RecursiveTask;
 import java.util.concurrent.TimeUnit;
-import java.util.function.IntFunction;
 import java.util.function.Predicate;
 import java.util.function.ToIntFunction;
 import java.util.stream.StreamSupport;
 
 import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;
@@ -85,11 +83,11 @@
         for (int i = 0; i < ELEM_SIZE; i++) {
             unsafe.putInt(address + (i * CARRIER_SIZE), i);
         }
         segment = MemorySegment.allocateNative(ALLOC_SIZE);
         for (int i = 0; i < ELEM_SIZE; i++) {
-            VH_int.set(segment.baseAddress(), (long) i, i);
+            VH_int.set(segment.address(), (long) i, i);
         }
     }
 
     @TearDown
     public void tearDown() throws Throwable {
@@ -98,11 +96,11 @@
     }
 
     @Benchmark
     public int segment_serial() {
         int res = 0;
-        MemoryAddress base = segment.baseAddress();
+        MemoryAddress base = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             res += (int)VH_int.get(base, (long) i);
         }
         return res;
     }
@@ -137,15 +135,15 @@
         return StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT_BULK), true)
                 .mapToInt(SEGMENT_TO_INT_BULK).sum();
     }
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT = slice ->
-            (int) VH_int.get(slice.baseAddress(), 0L);
+            (int) VH_int.get(slice.address(), 0L);
 
     final static ToIntFunction<MemorySegment> SEGMENT_TO_INT_BULK = slice -> {
         int res = 0;
-        MemoryAddress base = slice.baseAddress();
+        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
             res += (int)VH_int.get(base, (long) i);
         }
         return res;
     };
@@ -177,14 +175,14 @@
                 .filter(FIND_BULK)
                 .findAny();
     }
 
     final static Predicate<MemorySegment> FIND_SINGLE = slice ->
-            (int)VH_int.get(slice.baseAddress(), 0L) == (ELEM_SIZE - 1);
+            (int)VH_int.get(slice.address(), 0L) == (ELEM_SIZE - 1);
 
     final static Predicate<MemorySegment> FIND_BULK = slice -> {
-        MemoryAddress base = slice.baseAddress();
+        MemoryAddress base = slice.address();
         for (int i = 0; i < BULK_FACTOR ; i++) {
             if ((int)VH_int.get(base, (long)i) == (ELEM_SIZE - 1)) {
                 return true;
             }
         }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/TestAdaptVarHandles.java
@@ -142,21 +142,21 @@
     }
 
     @Benchmark
     public int segment_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.baseAddress();
+        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += (int)VH_addr_int.get(baseAddress, (long)i);
         }
         return sum;
     }
 
     @Benchmark
     public int segment_box_loop() throws Throwable {
         int sum = 0;
-        MemoryAddress baseAddress = segment.baseAddress();
+        MemoryAddress baseAddress = segment.address();
         for (int i = 0; i < ELEM_SIZE; i++) {
             sum += ((IntBox)VH_addr_box_int.get(baseAddress, (long)i)).intValue();
         }
         return sum;
     }
diff a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
--- a/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
+++ b/test/micro/org/openjdk/bench/jdk/incubator/foreign/points/support/PanamaPoint.java
@@ -79,11 +79,11 @@
         setX(x);
         setY(y);
     }
 
     public PanamaPoint(MemorySegment segment) {
-        this.address = segment.baseAddress();
+        this.address = segment.address();
     }
 
     public void setX(int x) {
         VH_x.set(address, x);
     }

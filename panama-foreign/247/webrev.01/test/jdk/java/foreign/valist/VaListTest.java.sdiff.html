<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> <a href="libVaList.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test




 27  * @run testng/othervm -Dforeign.restricted=permit VaListTest
 28  */
 29 
 30 import jdk.incubator.foreign.CSupport;


 31 import jdk.incubator.foreign.CSupport.VaList;

 32 import jdk.incubator.foreign.ForeignLinker;
 33 import jdk.incubator.foreign.FunctionDescriptor;
 34 import jdk.incubator.foreign.GroupLayout;
 35 import jdk.incubator.foreign.LibraryLookup;

 36 import jdk.incubator.foreign.MemoryAddress;
 37 import jdk.incubator.foreign.MemoryLayout;
 38 import jdk.incubator.foreign.MemorySegment;
 39 import jdk.incubator.foreign.NativeScope;




 40 import org.testng.annotations.DataProvider;
 41 import org.testng.annotations.Test;
 42 
 43 import java.lang.invoke.MethodHandle;

 44 import java.lang.invoke.MethodHandles;
 45 import java.lang.invoke.MethodType;
 46 import java.lang.invoke.VarHandle;





 47 
 48 import static jdk.incubator.foreign.CSupport.C_DOUBLE;
 49 import static jdk.incubator.foreign.CSupport.C_FLOAT;
 50 import static jdk.incubator.foreign.CSupport.C_INT;
 51 import static jdk.incubator.foreign.CSupport.C_LONGLONG;
 52 import static jdk.incubator.foreign.CSupport.C_POINTER;
 53 import static jdk.incubator.foreign.CSupport.C_VA_LIST;
<span class="line-removed"> 54 import static jdk.incubator.foreign.CSupport.Win64.asVarArg;</span>
 55 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;

 56 import static org.testng.Assert.assertEquals;
 57 import static org.testng.Assert.assertFalse;
 58 import static org.testng.Assert.assertTrue;
 59 
 60 public class VaListTest {
 61 
 62     private static final ForeignLinker abi = CSupport.getSystemLinker();
 63     private static final LibraryLookup lookup = LibraryLookup.ofLibrary(&quot;VaList&quot;);
 64 
<span class="line-removed"> 65     private static final VarHandle VH_int = C_INT.varHandle(int.class);</span>
<span class="line-removed"> 66 </span>
 67     private static final MethodHandle MH_sumInts = link(&quot;sumInts&quot;,
 68             MethodType.methodType(int.class, int.class, VaList.class),
 69             FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
 70     private static final MethodHandle MH_sumDoubles = link(&quot;sumDoubles&quot;,
 71             MethodType.methodType(double.class, int.class, VaList.class),
 72             FunctionDescriptor.of(C_DOUBLE, C_INT, CSupport.C_VA_LIST));
 73     private static final MethodHandle MH_getInt = link(&quot;getInt&quot;,
 74             MethodType.methodType(int.class, VaList.class),
 75             FunctionDescriptor.of(C_INT, C_VA_LIST));
 76     private static final MethodHandle MH_sumStruct = link(&quot;sumStruct&quot;,
 77             MethodType.methodType(int.class, VaList.class),
 78             FunctionDescriptor.of(C_INT, C_VA_LIST));
 79     private static final MethodHandle MH_sumBigStruct = link(&quot;sumBigStruct&quot;,
 80             MethodType.methodType(long.class, VaList.class),
 81             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
 82     private static final MethodHandle MH_sumHugeStruct = link(&quot;sumHugeStruct&quot;,
 83             MethodType.methodType(long.class, VaList.class),
 84             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
 85     private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
 86             MethodType.methodType(float.class, VaList.class),
 87             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
 88     private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
<span class="line-modified"> 89             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, int.class,</span>
<span class="line-modified"> 90                 long.class, long.class, long.class, long.class,</span>
<span class="line-removed"> 91                 long.class, long.class, long.class, long.class,</span>
<span class="line-removed"> 92                 long.class, long.class, long.class, long.class,</span>
<span class="line-removed"> 93                 long.class, long.class, long.class, long.class,</span>
<span class="line-removed"> 94                 double.class, double.class, double.class, double.class,</span>
<span class="line-removed"> 95                 double.class, double.class, double.class, double.class,</span>
<span class="line-removed"> 96                 double.class, double.class, double.class, double.class,</span>
<span class="line-removed"> 97                 double.class, double.class, double.class, double.class</span>
<span class="line-removed"> 98             ),</span>
<span class="line-removed"> 99             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_INT,</span>
<span class="line-removed">100                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-removed">101                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-removed">102                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-removed">103                 asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG), asVarArg(C_LONGLONG),</span>
<span class="line-removed">104                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-removed">105                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-removed">106                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE),</span>
<span class="line-removed">107                 asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE)</span>
<span class="line-removed">108             ));</span>
<span class="line-removed">109 </span>
<span class="line-removed">110     private static final VarHandle VH_long = C_LONGLONG.varHandle(long.class);</span>
<span class="line-removed">111     private static final VarHandle VH_double = C_DOUBLE.varHandle(double.class);</span>
112 
113     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
114         try {
115             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
116         } catch (NoSuchMethodException e) {
117             throw new NoSuchMethodError(e.getMessage());
118         }
119     }
120 
121     private static MethodHandle linkVaListCB(String symbol) {
122         return link(symbol,
123             MethodType.methodType(void.class, MemoryAddress.class),
124             FunctionDescriptor.ofVoid(C_POINTER));
125 
126     }
127 
<span class="line-modified">128     private static final GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">129         C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">130         C_LONGLONG.withName(&quot;y&quot;)</span>
<span class="line-modified">131     );</span>
<span class="line-modified">132     private static final VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">133     private static final VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">134     private static final GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">135         C_INT.withName(&quot;x&quot;),</span>
<span class="line-modified">136         C_INT.withName(&quot;y&quot;)</span>
<span class="line-modified">137     );</span>
<span class="line-modified">138     private static final VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">139     private static final VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">140     private static final GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">141         C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-modified">142         C_FLOAT.withName(&quot;y&quot;)</span>
<span class="line-modified">143     );</span>
<span class="line-modified">144     private static final VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">145     private static final VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">146     private static final GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-modified">147         C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-modified">148         C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-modified">149         C_LONGLONG.withName(&quot;z&quot;)</span>
<span class="line-modified">150     );</span>
<span class="line-modified">151     private static final VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-modified">152     private static final VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-modified">153     private static final VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-modified">154 </span>
<span class="line-modified">155     @Test</span>
<span class="line-modified">156     public void testIntSum() throws Throwable {</span>
<span class="line-modified">157         try (VaList vaList = VaList.make(b -&gt;</span>
<span class="line-modified">158                 b.vargFromInt(C_INT, 10)</span>
<span class="line-modified">159                  .vargFromInt(C_INT, 15)</span>
<span class="line-modified">160                  .vargFromInt(C_INT, 20))) {</span>
<span class="line-modified">161             int x = (int) MH_sumInts.invokeExact(3, vaList);</span>








162             assertEquals(x, 45);
163         }
164     }
165 
<span class="line-modified">166     @Test</span>
<span class="line-modified">167     public void testDoubleSum() throws Throwable {</span>
<span class="line-modified">168         try (VaList vaList = VaList.make(b -&gt;</span>
<span class="line-modified">169                 b.vargFromDouble(C_DOUBLE, 3.0D)</span>
<span class="line-modified">170                  .vargFromDouble(C_DOUBLE, 4.0D)</span>
<span class="line-modified">171                  .vargFromDouble(C_DOUBLE, 5.0D))) {</span>
<span class="line-modified">172             double x = (double) MH_sumDoubles.invokeExact(3, vaList);</span>

















173             assertEquals(x, 12.0D);
174         }
175     }
176 
<span class="line-modified">177     @Test</span>
<span class="line-modified">178     public void testVaListMemoryAddress() throws Throwable {</span>
<span class="line-modified">179         try (MemorySegment msInt = MemorySegment.allocateNative(C_INT)) {</span>
<span class="line-modified">180             VH_int.set(msInt.baseAddress(), 10);</span>
<span class="line-modified">181             try (VaList vaList = VaList.make(b -&gt; b.vargFromAddress(C_POINTER, msInt.baseAddress()))) {</span>
<span class="line-modified">182                 int x = (int) MH_getInt.invokeExact(vaList);</span>





















183                 assertEquals(x, 10);
184             }
185         }
186     }
187 
<span class="line-modified">188     @Test</span>
<span class="line-modified">189     public void testWinStructByValue() throws Throwable {</span>










































190         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
191             VH_Point_x.set(struct.baseAddress(), 5);
192             VH_Point_y.set(struct.baseAddress(), 10);
193 
<span class="line-modified">194             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {</span>
<span class="line-modified">195                 int sum = (int) MH_sumStruct.invokeExact(vaList);</span>
196                 assertEquals(sum, 15);
197             }
198         }
199     }
200 
<span class="line-modified">201     @Test</span>
<span class="line-modified">202     public void testWinStructByReference() throws Throwable {</span>






































203         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
204             VH_BigPoint_x.set(struct.baseAddress(), 5);
205             VH_BigPoint_y.set(struct.baseAddress(), 10);
206 
<span class="line-modified">207             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {</span>
<span class="line-modified">208                 long sum = (long) MH_sumBigStruct.invokeExact(vaList);</span>
209                 assertEquals(sum, 15);
210             }
211         }
212     }
213 
<span class="line-modified">214     @Test</span>
<span class="line-modified">215     public void testFloatStructByValue() throws Throwable {</span>







































216         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
217             VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
218             VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
219 
<span class="line-modified">220             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {</span>
<span class="line-modified">221                 float sum = (float) MH_sumFloatStruct.invokeExact(vaList);</span>
222                 assertEquals(sum, 4.376f, 0.00001f);
223             }
224         }
225     }
226 
<span class="line-modified">227     @Test</span>
<span class="line-modified">228     public void testHugeStructByValue() throws Throwable {</span>















































229         // On AArch64 a struct needs to be larger than 16 bytes to be
230         // passed by reference.
231         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
232             VH_HugePoint_x.set(struct.baseAddress(), 1);
233             VH_HugePoint_y.set(struct.baseAddress(), 2);
234             VH_HugePoint_z.set(struct.baseAddress(), 3);
235 
<span class="line-modified">236             try (VaList vaList = VaList.make(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {</span>
<span class="line-modified">237                 long sum = (long) MH_sumHugeStruct.invokeExact(vaList);</span>
238                 assertEquals(sum, 6);
239             }
240         }
241     }
242 
<span class="line-modified">243     @Test</span>
<span class="line-modified">244     public void testStack() throws Throwable {</span>
<span class="line-modified">245        try (MemorySegment longSum = MemorySegment.allocateNative(C_LONGLONG);</span>
<span class="line-modified">246             MemorySegment doubleSum = MemorySegment.allocateNative(C_DOUBLE)) {</span>
<span class="line-modified">247             VH_long.set(longSum.baseAddress(), 0L);</span>
<span class="line-modified">248             VH_double.set(doubleSum.baseAddress(), 0D);</span>








































249 
<span class="line-modified">250             MH_sumStack.invokeExact(longSum.baseAddress(), doubleSum.baseAddress(), 32,</span>
<span class="line-modified">251                 1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L,</span>
<span class="line-modified">252                 1D, 2D, 3D, 4D, 5D, 6D, 7D, 8D, 9D, 10D, 11D, 12D, 13D, 14D, 15D, 16D);</span>
253 
<span class="line-modified">254             long lSum = (long) VH_long.get(longSum.baseAddress());</span>
<span class="line-modified">255             double dSum = (double) VH_double.get(doubleSum.baseAddress());</span>
256 
257             assertEquals(lSum, 136L);
258             assertEquals(dSum, 136D);
259         }
260     }
261 
262     @Test(dataProvider = &quot;upcalls&quot;)
263     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
264         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
265         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
266             target.invokeExact(stub.baseAddress());
267         }
268     }
269 
<span class="line-modified">270     @Test(expectedExceptions = UnsupportedOperationException.class,</span>
<span class="line-modified">271           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;)</span>
<span class="line-modified">272     public void testEmptyNotCloseable() {</span>
<span class="line-modified">273         VaList list = VaList.empty();</span>
<span class="line-modified">274         list.close();</span>





275     }
276 
277     @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">278           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;)</span>
<span class="line-modified">279     public void testEmptyVaListFromBuilderNotCloseable() {</span>
<span class="line-modified">280         VaList list = VaList.make(b -&gt; {});</span>
<span class="line-modified">281         list.close();</span>















282     }
283 
<span class="line-modified">284     @Test</span>
<span class="line-modified">285     public void testScopedVaList() throws Throwable {</span>


286         VaList listLeaked;
287         try (NativeScope scope = NativeScope.unboundedScope()) {
<span class="line-modified">288             VaList list = CSupport.VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">289                                                      .vargFromInt(C_INT, 8),</span>
290                                                scope);
<span class="line-modified">291             int x = (int) MH_sumInts.invokeExact(2, list);</span>
292             assertEquals(x, 12);
293             listLeaked = list;
294         }
295         assertFalse(listLeaked.isAlive());
296     }
297 
<span class="line-modified">298     @Test</span>
<span class="line-modified">299     public void testScopeMSRead() {</span>


300         MemorySegment pointOut;
301         try (NativeScope scope = NativeScope.unboundedScope()) {
302             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
303                 VH_Point_x.set(pointIn.baseAddress(), 3);
304                 VH_Point_y.set(pointIn.baseAddress(), 6);
<span class="line-modified">305                 try (VaList list = CSupport.VaList.make(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {</span>
306                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
307                     assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
308                     assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
309                 }
310                 assertTrue(pointOut.isAlive()); // after VaList freed
311             }
312             assertTrue(pointOut.isAlive()); // after input MS freed
313         }
314         assertFalse(pointOut.isAlive()); // after scope freed
315     }
316 
<span class="line-modified">317     @Test</span>
<span class="line-modified">318     public void testCopy() {</span>
<span class="line-modified">319         try (VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">320                                              .vargFromInt(C_INT, 8))) {</span>









321             VaList  copy = list.copy();
<span class="line-modified">322             assertEquals(copy.vargAsInt(C_INT), 4);</span>
<span class="line-modified">323             assertEquals(copy.vargAsInt(C_INT), 8);</span>
324             copy.close();
325 
326             assertFalse(copy.isAlive());
327 
<span class="line-modified">328             assertEquals(list.vargAsInt(C_INT), 4);</span>
<span class="line-modified">329             assertEquals(list.vargAsInt(C_INT), 8);</span>
330         }
331     }
332 
<span class="line-modified">333     @Test</span>
<span class="line-modified">334     public void testScopedCopy() {</span>
<span class="line-modified">335         try (VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">336                                              .vargFromInt(C_INT, 8))) {</span>
337             VaList copy;
338             try (NativeScope scope = NativeScope.unboundedScope()) {
339                 copy = list.copy(scope);
340 
<span class="line-modified">341                 assertEquals(copy.vargAsInt(C_INT), 4);</span>
<span class="line-modified">342                 assertEquals(copy.vargAsInt(C_INT), 8);</span>
343             }
344             assertFalse(copy.isAlive());
345 
<span class="line-modified">346             assertEquals(list.vargAsInt(C_INT), 4);</span>
<span class="line-modified">347             assertEquals(list.vargAsInt(C_INT), 8);</span>
348         }
349     }
350 
<span class="line-modified">351     @Test(expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">352     public void testCopyUnusableAfterOriginalClosed() {</span>
<span class="line-modified">353         VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">354                                         .vargFromInt(C_INT, 8));</span>


355         try (VaList copy = list.copy()) {
356             list.close();
357 
<span class="line-modified">358             copy.vargAsInt(C_INT); // should throw</span>
359         }
360     }
361 
<span class="line-modified">362     @Test(expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">363     public void testCopyUnusableAfterOriginalClosedScope() {</span>
<span class="line-modified">364         VaList list = VaList.make(b -&gt; b.vargFromInt(C_INT, 4)</span>
<span class="line-modified">365                                         .vargFromInt(C_INT, 8));</span>


366         try (NativeScope scope = NativeScope.unboundedScope()) {
367             VaList copy = list.copy(scope);
368             list.close();
369 
<span class="line-modified">370             copy.vargAsInt(C_INT); // should throw</span>
371         }
372     }
373 
374     @DataProvider
375     public static Object[][] upcalls() {



























376         return new Object[][]{
377             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
378                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
379                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
380                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
381                 }
382             })},
383             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
384                 VaList copy = vaList.copy();
385                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
386                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
387                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
388 
389                     VH_BigPoint_x.set(struct.baseAddress(), 0);
390                     VH_BigPoint_y.set(struct.baseAddress(), 0);
391                 }
392 
393                 // should be independent
394                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
395                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
</pre>
<hr />
<pre>
402                     assertEquals((int) VH_Point_y.get(struct.baseAddress()), 10);
403                 }
404             })},
405             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {
406                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
407                     assertEquals((long) VH_HugePoint_x.get(struct.baseAddress()), 1);
408                     assertEquals((long) VH_HugePoint_y.get(struct.baseAddress()), 2);
409                     assertEquals((long) VH_HugePoint_z.get(struct.baseAddress()), 3);
410                 }
411             })},
412             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {
413                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
414                     assertEquals((float) VH_FloatPoint_x.get(struct.baseAddress()), 1.0f);
415                     assertEquals((float) VH_FloatPoint_y.get(struct.baseAddress()), 2.0f);
416                 }
417             })},
418             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
419                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
420                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
421                                                                     Thread.currentThread(), null, null);
<span class="line-modified">422                 int x = (int) VH_int.get(ms.baseAddress());</span>
423                 assertEquals(x, 10);
424             })},
425             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
426                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
427                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
428                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
429             })},
430             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {
431                 assertEquals(vaList.vargAsInt(C_INT), 10);
432                 assertEquals(vaList.vargAsInt(C_INT), 15);
433                 assertEquals(vaList.vargAsInt(C_INT), 20);
434             })},
435             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
436                 // skip all registers
<span class="line-modified">437                 assertEquals(vaList.vargAsLong(C_LONGLONG), 1L); // 1st windows arg read from shadow space</span>
<span class="line-modified">438                 assertEquals(vaList.vargAsLong(C_LONGLONG), 2L); // 2nd windows arg read from shadow space</span>
<span class="line-modified">439                 assertEquals(vaList.vargAsLong(C_LONGLONG), 3L); // windows 1st stack arg (int/float)</span>
<span class="line-modified">440                 assertEquals(vaList.vargAsLong(C_LONGLONG), 4L);</span>
<span class="line-modified">441                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);</span>
<span class="line-modified">442                 assertEquals(vaList.vargAsLong(C_LONGLONG), 6L);</span>
<span class="line-removed">443                 assertEquals(vaList.vargAsLong(C_LONGLONG), 7L); // sysv 1st int stack arg</span>
<span class="line-removed">444                 assertEquals(vaList.vargAsLong(C_LONGLONG), 8L);</span>
<span class="line-removed">445                 assertEquals(vaList.vargAsLong(C_LONGLONG), 9L);</span>
<span class="line-removed">446                 assertEquals(vaList.vargAsLong(C_LONGLONG), 10L);</span>
<span class="line-removed">447                 assertEquals(vaList.vargAsLong(C_LONGLONG), 11L);</span>
<span class="line-removed">448                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);</span>
<span class="line-removed">449                 assertEquals(vaList.vargAsLong(C_LONGLONG), 13L);</span>
<span class="line-removed">450                 assertEquals(vaList.vargAsLong(C_LONGLONG), 14L);</span>
<span class="line-removed">451                 assertEquals(vaList.vargAsLong(C_LONGLONG), 15L);</span>
<span class="line-removed">452                 assertEquals(vaList.vargAsLong(C_LONGLONG), 16L);</span>
<span class="line-removed">453                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);</span>
<span class="line-removed">454                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 2.0D);</span>
<span class="line-removed">455                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0D);</span>
<span class="line-removed">456                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0D);</span>
<span class="line-removed">457                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0D);</span>
<span class="line-removed">458                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);</span>
<span class="line-removed">459                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);</span>
<span class="line-removed">460                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 8.0D);</span>
<span class="line-removed">461                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 9.0D); // sysv 1st float stack arg</span>
<span class="line-removed">462                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 10.0D);</span>
<span class="line-removed">463                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 11.0D);</span>
<span class="line-removed">464                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 12.0D);</span>
<span class="line-removed">465                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 13.0D);</span>
<span class="line-removed">466                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);</span>
<span class="line-removed">467                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 15.0D);</span>
<span class="line-removed">468                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 16.0D);</span>
469 
470                 // test some arbitrary values on the stack
471                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
472                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
473                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
474                 assertEquals(vaList.vargAsInt(C_INT), 4);
475                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
476                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
477                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
478                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
479                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);
480                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
481                 assertEquals(vaList.vargAsInt(C_INT), 11);
482                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
483                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
484                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
485 
486                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
487                     assertEquals((int) VH_Point_x.get(point.baseAddress()), 5);
488                     assertEquals((int) VH_Point_y.get(point.baseAddress()), 10);
</pre>
</td>
<td>
<hr />
<pre>
  7  *  published by the Free Software Foundation.
  8  *
  9  *  This code is distributed in the hope that it will be useful, but WITHOUT
 10  *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  *  version 2 for more details (a copy is included in the LICENSE file that
 13  *  accompanied this code).
 14  *
 15  *  You should have received a copy of the GNU General Public License version
 16  *  2 along with this work; if not, write to the Free Software Foundation,
 17  *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  *  or visit www.oracle.com if you need additional information or have any
 21  *  questions.
 22  *
 23  */
 24 
 25 /*
 26  * @test
<span class="line-added"> 27  * @modules jdk.incubator.foreign/jdk.internal.foreign.abi</span>
<span class="line-added"> 28  *          jdk.incubator.foreign/jdk.internal.foreign.abi.aarch64</span>
<span class="line-added"> 29  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.windows</span>
<span class="line-added"> 30  *          jdk.incubator.foreign/jdk.internal.foreign.abi.x64.sysv</span>
 31  * @run testng/othervm -Dforeign.restricted=permit VaListTest
 32  */
 33 
 34 import jdk.incubator.foreign.CSupport;
<span class="line-added"> 35 import jdk.incubator.foreign.CSupport.AArch64;</span>
<span class="line-added"> 36 import jdk.incubator.foreign.CSupport.SysV;</span>
 37 import jdk.incubator.foreign.CSupport.VaList;
<span class="line-added"> 38 import jdk.incubator.foreign.CSupport.Win64;</span>
 39 import jdk.incubator.foreign.ForeignLinker;
 40 import jdk.incubator.foreign.FunctionDescriptor;
 41 import jdk.incubator.foreign.GroupLayout;
 42 import jdk.incubator.foreign.LibraryLookup;
<span class="line-added"> 43 import jdk.incubator.foreign.MemoryAccess;</span>
 44 import jdk.incubator.foreign.MemoryAddress;
 45 import jdk.incubator.foreign.MemoryLayout;
 46 import jdk.incubator.foreign.MemorySegment;
 47 import jdk.incubator.foreign.NativeScope;
<span class="line-added"> 48 import jdk.internal.foreign.abi.SharedUtils;</span>
<span class="line-added"> 49 import jdk.internal.foreign.abi.aarch64.AArch64Linker;</span>
<span class="line-added"> 50 import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;</span>
<span class="line-added"> 51 import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;</span>
 52 import org.testng.annotations.DataProvider;
 53 import org.testng.annotations.Test;
 54 
 55 import java.lang.invoke.MethodHandle;
<span class="line-added"> 56 import java.lang.invoke.MethodHandleProxies;</span>
 57 import java.lang.invoke.MethodHandles;
 58 import java.lang.invoke.MethodType;
 59 import java.lang.invoke.VarHandle;
<span class="line-added"> 60 import java.util.function.BiFunction;</span>
<span class="line-added"> 61 import java.util.function.Consumer;</span>
<span class="line-added"> 62 import java.util.function.Function;</span>
<span class="line-added"> 63 import java.util.stream.DoubleStream;</span>
<span class="line-added"> 64 import java.util.stream.IntStream;</span>
 65 
 66 import static jdk.incubator.foreign.CSupport.C_DOUBLE;
 67 import static jdk.incubator.foreign.CSupport.C_FLOAT;
 68 import static jdk.incubator.foreign.CSupport.C_INT;
 69 import static jdk.incubator.foreign.CSupport.C_LONGLONG;
 70 import static jdk.incubator.foreign.CSupport.C_POINTER;
 71 import static jdk.incubator.foreign.CSupport.C_VA_LIST;

 72 import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;
<span class="line-added"> 73 import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;</span>
 74 import static org.testng.Assert.assertEquals;
 75 import static org.testng.Assert.assertFalse;
 76 import static org.testng.Assert.assertTrue;
 77 
 78 public class VaListTest {
 79 
 80     private static final ForeignLinker abi = CSupport.getSystemLinker();
 81     private static final LibraryLookup lookup = LibraryLookup.ofLibrary(&quot;VaList&quot;);
 82 


 83     private static final MethodHandle MH_sumInts = link(&quot;sumInts&quot;,
 84             MethodType.methodType(int.class, int.class, VaList.class),
 85             FunctionDescriptor.of(C_INT, C_INT, CSupport.C_VA_LIST));
 86     private static final MethodHandle MH_sumDoubles = link(&quot;sumDoubles&quot;,
 87             MethodType.methodType(double.class, int.class, VaList.class),
 88             FunctionDescriptor.of(C_DOUBLE, C_INT, CSupport.C_VA_LIST));
 89     private static final MethodHandle MH_getInt = link(&quot;getInt&quot;,
 90             MethodType.methodType(int.class, VaList.class),
 91             FunctionDescriptor.of(C_INT, C_VA_LIST));
 92     private static final MethodHandle MH_sumStruct = link(&quot;sumStruct&quot;,
 93             MethodType.methodType(int.class, VaList.class),
 94             FunctionDescriptor.of(C_INT, C_VA_LIST));
 95     private static final MethodHandle MH_sumBigStruct = link(&quot;sumBigStruct&quot;,
 96             MethodType.methodType(long.class, VaList.class),
 97             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
 98     private static final MethodHandle MH_sumHugeStruct = link(&quot;sumHugeStruct&quot;,
 99             MethodType.methodType(long.class, VaList.class),
100             FunctionDescriptor.of(C_LONGLONG, C_VA_LIST));
101     private static final MethodHandle MH_sumFloatStruct = link(&quot;sumFloatStruct&quot;,
102             MethodType.methodType(float.class, VaList.class),
103             FunctionDescriptor.of(C_FLOAT, C_VA_LIST));
104     private static final MethodHandle MH_sumStack = link(&quot;sumStack&quot;,
<span class="line-modified">105             MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),</span>
<span class="line-modified">106             FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));</span>





















107 
108     private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {
109         try {
110             return abi.downcallHandle(lookup.lookup(symbol), mt, fd);
111         } catch (NoSuchMethodException e) {
112             throw new NoSuchMethodError(e.getMessage());
113         }
114     }
115 
116     private static MethodHandle linkVaListCB(String symbol) {
117         return link(symbol,
118             MethodType.methodType(void.class, MemoryAddress.class),
119             FunctionDescriptor.ofVoid(C_POINTER));
120 
121     }
122 
<span class="line-modified">123     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; winVaListFactory</span>
<span class="line-modified">124         = actions -&gt; Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">125     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; sysvVaListFactory</span>
<span class="line-modified">126         = actions -&gt; SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">127     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; aarch64VaListFactory</span>
<span class="line-modified">128         = actions -&gt; AArch64Linker.newVaList(actions, MemorySegment::allocateNative);</span>
<span class="line-modified">129     private static final Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; platformVaListFactory</span>
<span class="line-modified">130         = CSupport.VaList::make;</span>
<span class="line-modified">131 </span>
<span class="line-modified">132     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; winVaListScopedFactory</span>
<span class="line-modified">133         = (actions, scope) -&gt; Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">134     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; sysvVaListScopedFactory</span>
<span class="line-modified">135         = (actions, scope) -&gt; SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">136     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; aarch64VaListScopedFactory</span>
<span class="line-modified">137         = (actions, scope) -&gt; AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));</span>
<span class="line-modified">138     private static final BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; platformVaListScopedFactory</span>
<span class="line-modified">139         = CSupport.VaList::make;</span>
<span class="line-modified">140 </span>
<span class="line-modified">141     @DataProvider</span>
<span class="line-modified">142     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">143     public static Object[][] sumInts() {</span>
<span class="line-modified">144         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;</span>
<span class="line-modified">145             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
<span class="line-modified">146         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative</span>
<span class="line-modified">147             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
<span class="line-modified">148         return new Object[][]{</span>
<span class="line-modified">149             { winVaListFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-modified">150             { sysvVaListFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-modified">151             { aarch64VaListFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-modified">152             { platformVaListFactory, sumIntsNative,                        C_INT         },</span>
<span class="line-modified">153         };</span>
<span class="line-modified">154     }</span>
<span class="line-modified">155 </span>
<span class="line-modified">156     @Test(dataProvider = &quot;sumInts&quot;)</span>
<span class="line-added">157     public void testIntSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">158                            BiFunction&lt;Integer, VaList, Integer&gt; sumInts,</span>
<span class="line-added">159                            MemoryLayout intLayout) {</span>
<span class="line-added">160         try (VaList vaList = vaListFactory.apply(b -&gt;</span>
<span class="line-added">161                 b.vargFromInt(intLayout, 10)</span>
<span class="line-added">162                  .vargFromInt(intLayout, 15)</span>
<span class="line-added">163                  .vargFromInt(intLayout, 20))) {</span>
<span class="line-added">164             int x = sumInts.apply(3, vaList);</span>
165             assertEquals(x, 45);
166         }
167     }
168 
<span class="line-modified">169     @DataProvider</span>
<span class="line-modified">170     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">171     public static Object[][] sumDoubles() {</span>
<span class="line-modified">172         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Double&gt;&gt; sumDoublesJavaFact  = layout -&gt;</span>
<span class="line-modified">173             (num, list) -&gt; DoubleStream.generate(() -&gt; list.vargAsDouble(layout)).limit(num).sum();</span>
<span class="line-modified">174         BiFunction&lt;Integer, VaList, Double&gt; sumDoublesNative</span>
<span class="line-modified">175             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);</span>
<span class="line-added">176         return new Object[][]{</span>
<span class="line-added">177             { winVaListFactory,      sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },</span>
<span class="line-added">178             { sysvVaListFactory,     sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },</span>
<span class="line-added">179             { aarch64VaListFactory,  sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },</span>
<span class="line-added">180             { platformVaListFactory, sumDoublesNative,                           C_DOUBLE         },</span>
<span class="line-added">181         };</span>
<span class="line-added">182     }</span>
<span class="line-added">183 </span>
<span class="line-added">184     @Test(dataProvider = &quot;sumDoubles&quot;)</span>
<span class="line-added">185     public void testDoubleSum(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">186                               BiFunction&lt;Integer, VaList, Double&gt; sumDoubles,</span>
<span class="line-added">187                               MemoryLayout doubleLayout) {</span>
<span class="line-added">188         try (VaList vaList = vaListFactory.apply(b -&gt;</span>
<span class="line-added">189                 b.vargFromDouble(doubleLayout, 3.0D)</span>
<span class="line-added">190                  .vargFromDouble(doubleLayout, 4.0D)</span>
<span class="line-added">191                  .vargFromDouble(doubleLayout, 5.0D))) {</span>
<span class="line-added">192             double x = sumDoubles.apply(3, vaList);</span>
193             assertEquals(x, 12.0D);
194         }
195     }
196 
<span class="line-modified">197     @DataProvider</span>
<span class="line-modified">198     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-modified">199     public static Object[][] pointers() {</span>
<span class="line-modified">200         Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;</span>
<span class="line-modified">201             list -&gt; {</span>
<span class="line-modified">202                 MemoryAddress ma = list.vargAsAddress(layout);</span>
<span class="line-added">203                 MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,</span>
<span class="line-added">204                         4, Thread.currentThread(), null, null);</span>
<span class="line-added">205                 return MemoryAccess.getInt(accessibleSegment.baseAddress());</span>
<span class="line-added">206             };</span>
<span class="line-added">207         Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);</span>
<span class="line-added">208         return new Object[][]{</span>
<span class="line-added">209             { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },</span>
<span class="line-added">210             { sysvVaListFactory,     getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },</span>
<span class="line-added">211             { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },</span>
<span class="line-added">212             { platformVaListFactory, getIntNative,                            C_POINTER         },</span>
<span class="line-added">213         };</span>
<span class="line-added">214     }</span>
<span class="line-added">215 </span>
<span class="line-added">216     @Test(dataProvider = &quot;pointers&quot;)</span>
<span class="line-added">217     public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">218                                         Function&lt;VaList, Integer&gt; getFromPointer,</span>
<span class="line-added">219                                         MemoryLayout pointerLayout) {</span>
<span class="line-added">220         try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {</span>
<span class="line-added">221             MemoryAccess.setInt(msInt.baseAddress(), 10);</span>
<span class="line-added">222             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {</span>
<span class="line-added">223                 int x = getFromPointer.apply(vaList);</span>
224                 assertEquals(x, 10);
225             }
226         }
227     }
228 
<span class="line-modified">229     interface TriFunction&lt;S, T, U, R&gt; {</span>
<span class="line-modified">230         R apply(S s, T t, U u);</span>
<span class="line-added">231     }</span>
<span class="line-added">232 </span>
<span class="line-added">233     @DataProvider</span>
<span class="line-added">234     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">235     public static Object[][] structs() {</span>
<span class="line-added">236         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact</span>
<span class="line-added">237             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
<span class="line-added">238                 list -&gt; {</span>
<span class="line-added">239                     MemorySegment struct = list.vargAsSegment(pointLayout);</span>
<span class="line-added">240                     int x = (int) VH_Point_x.get(struct.baseAddress());</span>
<span class="line-added">241                     int y = (int) VH_Point_y.get(struct.baseAddress());</span>
<span class="line-added">242                     return x + y;</span>
<span class="line-added">243                 };</span>
<span class="line-added">244 </span>
<span class="line-added">245         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructNativeFact</span>
<span class="line-added">246             = (pointLayout, VH_Point_x, VH_Point_y) -&gt;</span>
<span class="line-added">247                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);</span>
<span class="line-added">248 </span>
<span class="line-added">249         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-added">250                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-added">251             = (vaListFact, intLayout, sumStructFact) -&gt; {</span>
<span class="line-added">252                 GroupLayout pointLayout =  MemoryLayout.ofStruct(</span>
<span class="line-added">253                     intLayout.withName(&quot;x&quot;),</span>
<span class="line-added">254                     intLayout.withName(&quot;y&quot;)</span>
<span class="line-added">255                 );</span>
<span class="line-added">256                 VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">257                 VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">258                 return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),</span>
<span class="line-added">259                                       pointLayout, VH_Point_x, VH_Point_y  };</span>
<span class="line-added">260             };</span>
<span class="line-added">261         return new Object[][]{</span>
<span class="line-added">262             argsFact.apply(winVaListFactory,      Win64.C_INT,   sumStructJavaFact),</span>
<span class="line-added">263             argsFact.apply(sysvVaListFactory,     SysV.C_INT,    sumStructJavaFact),</span>
<span class="line-added">264             argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),</span>
<span class="line-added">265             argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),</span>
<span class="line-added">266         };</span>
<span class="line-added">267     }</span>
<span class="line-added">268 </span>
<span class="line-added">269     @Test(dataProvider = &quot;structs&quot;)</span>
<span class="line-added">270     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">271                            Function&lt;VaList, Integer&gt; sumStruct,</span>
<span class="line-added">272                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
273         try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
274             VH_Point_x.set(struct.baseAddress(), 5);
275             VH_Point_y.set(struct.baseAddress(), 10);
276 
<span class="line-modified">277             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {</span>
<span class="line-modified">278                 int sum = sumStruct.apply(vaList);</span>
279                 assertEquals(sum, 15);
280             }
281         }
282     }
283 
<span class="line-modified">284     @DataProvider</span>
<span class="line-modified">285     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">286     public static Object[][] bigStructs() {</span>
<span class="line-added">287         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact</span>
<span class="line-added">288             = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
<span class="line-added">289                 list -&gt; {</span>
<span class="line-added">290                     MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);</span>
<span class="line-added">291                     long x = (long) VH_BigPoint_x.get(struct.baseAddress());</span>
<span class="line-added">292                     long y = (long) VH_BigPoint_y.get(struct.baseAddress());</span>
<span class="line-added">293                     return x + y;</span>
<span class="line-added">294                 };</span>
<span class="line-added">295 </span>
<span class="line-added">296         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact</span>
<span class="line-added">297             = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) -&gt;</span>
<span class="line-added">298                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);</span>
<span class="line-added">299 </span>
<span class="line-added">300         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-added">301                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-added">302             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-added">303                 GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(</span>
<span class="line-added">304                     longLongLayout.withName(&quot;x&quot;),</span>
<span class="line-added">305                     longLongLayout.withName(&quot;y&quot;)</span>
<span class="line-added">306                 );</span>
<span class="line-added">307                 VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">308                 VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">309                 return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),</span>
<span class="line-added">310                                       BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };</span>
<span class="line-added">311             };</span>
<span class="line-added">312         return new Object[][]{</span>
<span class="line-added">313             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-added">314             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-added">315             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-added">316             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
<span class="line-added">317         };</span>
<span class="line-added">318     }</span>
<span class="line-added">319 </span>
<span class="line-added">320     @Test(dataProvider = &quot;bigStructs&quot;)</span>
<span class="line-added">321     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">322                               Function&lt;VaList, Long&gt; sumBigStruct,</span>
<span class="line-added">323                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {</span>
324         try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
325             VH_BigPoint_x.set(struct.baseAddress(), 5);
326             VH_BigPoint_y.set(struct.baseAddress(), 10);
327 
<span class="line-modified">328             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {</span>
<span class="line-modified">329                 long sum = sumBigStruct.apply(vaList);</span>
330                 assertEquals(sum, 15);
331             }
332         }
333     }
334 
<span class="line-modified">335     @DataProvider</span>
<span class="line-modified">336     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">337     public static Object[][] floatStructs() {</span>
<span class="line-added">338         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact</span>
<span class="line-added">339             = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
<span class="line-added">340                 list -&gt; {</span>
<span class="line-added">341                     MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);</span>
<span class="line-added">342                     float x = (float) VH_FloatPoint_x.get(struct.baseAddress());</span>
<span class="line-added">343                     float y = (float) VH_FloatPoint_y.get(struct.baseAddress());</span>
<span class="line-added">344                     return x + y;</span>
<span class="line-added">345                 };</span>
<span class="line-added">346 </span>
<span class="line-added">347         TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructNativeFact</span>
<span class="line-added">348             = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;</span>
<span class="line-added">349                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);</span>
<span class="line-added">350 </span>
<span class="line-added">351         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-added">352                 TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-added">353             = (vaListFact, floatLayout, sumFloatStructFact) -&gt; {</span>
<span class="line-added">354                 GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">355                     floatLayout.withName(&quot;x&quot;),</span>
<span class="line-added">356                     floatLayout.withName(&quot;y&quot;)</span>
<span class="line-added">357                 );</span>
<span class="line-added">358                 VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">359                 VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">360                 return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),</span>
<span class="line-added">361                                       FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };</span>
<span class="line-added">362             };</span>
<span class="line-added">363         return new Object[][]{</span>
<span class="line-added">364             argsFact.apply(winVaListFactory,      Win64.C_FLOAT,   sumStructJavaFact),</span>
<span class="line-added">365             argsFact.apply(sysvVaListFactory,     SysV.C_FLOAT,    sumStructJavaFact),</span>
<span class="line-added">366             argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),</span>
<span class="line-added">367             argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),</span>
<span class="line-added">368         };</span>
<span class="line-added">369     }</span>
<span class="line-added">370 </span>
<span class="line-added">371     @Test(dataProvider = &quot;floatStructs&quot;)</span>
<span class="line-added">372     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">373                                 Function&lt;VaList, Float&gt; sumFloatStruct,</span>
<span class="line-added">374                                 MemoryLayout FloatPoint_LAYOUT,</span>
<span class="line-added">375                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {</span>
376         try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
377             VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
378             VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
379 
<span class="line-modified">380             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {</span>
<span class="line-modified">381                 float sum = sumFloatStruct.apply(vaList);</span>
382                 assertEquals(sum, 4.376f, 0.00001f);
383             }
384         }
385     }
386 
<span class="line-modified">387     interface QuadFunc&lt;T0, T1, T2, T3, R&gt; {</span>
<span class="line-modified">388         R apply(T0 t0, T1 t1, T2 t2, T3 t3);</span>
<span class="line-added">389     }</span>
<span class="line-added">390 </span>
<span class="line-added">391     @DataProvider</span>
<span class="line-added">392     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">393     public static Object[][] hugeStructs() {</span>
<span class="line-added">394         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact</span>
<span class="line-added">395             = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
<span class="line-added">396                 list -&gt; {</span>
<span class="line-added">397                     MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);</span>
<span class="line-added">398                     long x = (long) VH_HugePoint_x.get(struct.baseAddress());</span>
<span class="line-added">399                     long y = (long) VH_HugePoint_y.get(struct.baseAddress());</span>
<span class="line-added">400                     long z = (long) VH_HugePoint_z.get(struct.baseAddress());</span>
<span class="line-added">401                     return x + y + z;</span>
<span class="line-added">402                 };</span>
<span class="line-added">403 </span>
<span class="line-added">404         QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructNativeFact</span>
<span class="line-added">405             = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;</span>
<span class="line-added">406                 MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);</span>
<span class="line-added">407 </span>
<span class="line-added">408         TriFunction&lt;Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt;, MemoryLayout,</span>
<span class="line-added">409                 QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt;, Object[]&gt; argsFact</span>
<span class="line-added">410             = (vaListFact, longLongLayout, sumBigStructFact) -&gt; {</span>
<span class="line-added">411                 GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">412                     longLongLayout.withName(&quot;x&quot;),</span>
<span class="line-added">413                     longLongLayout.withName(&quot;y&quot;),</span>
<span class="line-added">414                     longLongLayout.withName(&quot;z&quot;)</span>
<span class="line-added">415                 );</span>
<span class="line-added">416                 VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">417                 VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">418                 VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-added">419                 return new Object[] { vaListFact,</span>
<span class="line-added">420                                       sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),</span>
<span class="line-added">421                                       HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };</span>
<span class="line-added">422             };</span>
<span class="line-added">423         return new Object[][]{</span>
<span class="line-added">424             argsFact.apply(winVaListFactory,      Win64.C_LONGLONG,   sumStructJavaFact),</span>
<span class="line-added">425             argsFact.apply(sysvVaListFactory,     SysV.C_LONGLONG,    sumStructJavaFact),</span>
<span class="line-added">426             argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),</span>
<span class="line-added">427             argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),</span>
<span class="line-added">428         };</span>
<span class="line-added">429     }</span>
<span class="line-added">430 </span>
<span class="line-added">431     @Test(dataProvider = &quot;hugeStructs&quot;)</span>
<span class="line-added">432     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">433                                Function&lt;VaList, Long&gt; sumHugeStruct,</span>
<span class="line-added">434                                MemoryLayout HugePoint_LAYOUT,</span>
<span class="line-added">435                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {</span>
436         // On AArch64 a struct needs to be larger than 16 bytes to be
437         // passed by reference.
438         try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
439             VH_HugePoint_x.set(struct.baseAddress(), 1);
440             VH_HugePoint_y.set(struct.baseAddress(), 2);
441             VH_HugePoint_z.set(struct.baseAddress(), 3);
442 
<span class="line-modified">443             try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(HugePoint_LAYOUT, struct))) {</span>
<span class="line-modified">444                 long sum = sumHugeStruct.apply(vaList);</span>
445                 assertEquals(sum, 6);
446             }
447         }
448     }
449 
<span class="line-modified">450     public interface SumStackFunc {</span>
<span class="line-modified">451         void invoke(MemoryAddress longSum, MemoryAddress doubleSum, VaList list);</span>
<span class="line-modified">452     }</span>
<span class="line-modified">453 </span>
<span class="line-modified">454     @DataProvider</span>
<span class="line-modified">455     public static Object[][] sumStack() {</span>
<span class="line-added">456         BiFunction&lt;MemoryLayout, MemoryLayout, SumStackFunc&gt; sumStackJavaFact = (longLayout, doubleLayout) -&gt;</span>
<span class="line-added">457             (longSum, doubleSum, list) -&gt; {</span>
<span class="line-added">458                 long lSum = 0L;</span>
<span class="line-added">459                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-added">460                     lSum += list.vargAsLong(longLayout);</span>
<span class="line-added">461                 }</span>
<span class="line-added">462                 MemoryAccess.setLong(longSum, lSum);</span>
<span class="line-added">463                 double dSum = 0D;</span>
<span class="line-added">464                 for (int i = 0; i &lt; 16; i++) {</span>
<span class="line-added">465                     dSum += list.vargAsDouble(doubleLayout);</span>
<span class="line-added">466                 }</span>
<span class="line-added">467                 MemoryAccess.setDouble(doubleSum, dSum);</span>
<span class="line-added">468             };</span>
<span class="line-added">469         SumStackFunc sumStackNative = MethodHandleProxies.asInterfaceInstance(SumStackFunc.class, MH_sumStack);</span>
<span class="line-added">470         return new Object[][]{</span>
<span class="line-added">471             { winVaListFactory,      sumStackJavaFact.apply(Win64.C_LONGLONG, Win64.C_DOUBLE),     Win64.C_LONGLONG,   Win64.C_DOUBLE   },</span>
<span class="line-added">472             { sysvVaListFactory,     sumStackJavaFact.apply(SysV.C_LONGLONG, SysV.C_DOUBLE),       SysV.C_LONGLONG,    SysV.C_DOUBLE    },</span>
<span class="line-added">473             { aarch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONGLONG, AArch64.C_DOUBLE), AArch64.C_LONGLONG, AArch64.C_DOUBLE },</span>
<span class="line-added">474             { platformVaListFactory, sumStackNative,                                               C_LONGLONG,         C_DOUBLE         },</span>
<span class="line-added">475         };</span>
<span class="line-added">476     }</span>
<span class="line-added">477 </span>
<span class="line-added">478     @Test(dataProvider = &quot;sumStack&quot;)</span>
<span class="line-added">479     public void testStack(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">480                           SumStackFunc sumStack,</span>
<span class="line-added">481                           MemoryLayout longLayout,</span>
<span class="line-added">482                           MemoryLayout doubleLayout) {</span>
<span class="line-added">483        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);</span>
<span class="line-added">484             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {</span>
<span class="line-added">485             MemoryAccess.setLong(longSum.baseAddress(), 0L);</span>
<span class="line-added">486             MemoryAccess.setDouble(doubleSum.baseAddress(), 0D);</span>
<span class="line-added">487 </span>
<span class="line-added">488             VaList list = vaListFactory.apply(b -&gt; {</span>
<span class="line-added">489                 for (long l = 1; l &lt;= 16L; l++) {</span>
<span class="line-added">490                     b.vargFromLong(longLayout, l);</span>
<span class="line-added">491                 }</span>
<span class="line-added">492                 for (double d = 1; d &lt;= 16D; d++) {</span>
<span class="line-added">493                     b.vargFromDouble(doubleLayout, d);</span>
<span class="line-added">494                 }</span>
<span class="line-added">495             });</span>
496 
<span class="line-modified">497             try (list) {</span>
<span class="line-modified">498                 sumStack.invoke(longSum.baseAddress(), doubleSum.baseAddress(), list);</span>
<span class="line-modified">499             }</span>
500 
<span class="line-modified">501             long lSum = MemoryAccess.getLong(longSum.baseAddress());</span>
<span class="line-modified">502             double dSum = MemoryAccess.getDouble(doubleSum.baseAddress());</span>
503 
504             assertEquals(lSum, 136L);
505             assertEquals(dSum, 136D);
506         }
507     }
508 
509     @Test(dataProvider = &quot;upcalls&quot;)
510     public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {
511         FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);
512         try (MemorySegment stub = abi.upcallStub(callback, desc)) {
513             target.invokeExact(stub.baseAddress());
514         }
515     }
516 
<span class="line-modified">517     @DataProvider</span>
<span class="line-modified">518     public Object[][] emptyVaLists() {</span>
<span class="line-modified">519         return new Object[][] {</span>
<span class="line-modified">520             { Windowsx64Linker.emptyVaList()      },</span>
<span class="line-modified">521             { winVaListFactory.apply(b -&gt; {})     },</span>
<span class="line-added">522             { SysVx64Linker.emptyVaList()         },</span>
<span class="line-added">523             { sysvVaListFactory.apply(b -&gt; {})    },</span>
<span class="line-added">524             { AArch64Linker.emptyVaList()         },</span>
<span class="line-added">525             { aarch64VaListFactory.apply(b -&gt; {}) },</span>
<span class="line-added">526         };</span>
527     }
528 
529     @Test(expectedExceptions = UnsupportedOperationException.class,
<span class="line-modified">530           expectedExceptionsMessageRegExp = &quot;.*Empty VaList.*&quot;,</span>
<span class="line-modified">531           dataProvider = &quot;emptyVaLists&quot;)</span>
<span class="line-modified">532     public void testEmptyNotCloseable(VaList emptyList) {</span>
<span class="line-modified">533         emptyList.close();</span>
<span class="line-added">534     }</span>
<span class="line-added">535 </span>
<span class="line-added">536     @DataProvider</span>
<span class="line-added">537     @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added">538     public static Object[][] sumIntsScoped() {</span>
<span class="line-added">539         Function&lt;MemoryLayout, BiFunction&lt;Integer, VaList, Integer&gt;&gt; sumIntsJavaFact = layout -&gt;</span>
<span class="line-added">540             (num, list) -&gt; IntStream.generate(() -&gt; list.vargAsInt(layout)).limit(num).sum();</span>
<span class="line-added">541         BiFunction&lt;Integer, VaList, Integer&gt; sumIntsNative</span>
<span class="line-added">542             = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);</span>
<span class="line-added">543         return new Object[][]{</span>
<span class="line-added">544             { winVaListScopedFactory,      sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },</span>
<span class="line-added">545             { sysvVaListScopedFactory,     sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },</span>
<span class="line-added">546             { aarch64VaListScopedFactory,  sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },</span>
<span class="line-added">547             { platformVaListScopedFactory, sumIntsNative,                        C_INT         },</span>
<span class="line-added">548         };</span>
549     }
550 
<span class="line-modified">551     @Test(dataProvider = &quot;sumIntsScoped&quot;)</span>
<span class="line-modified">552     public void testScopedVaList(BiFunction&lt;Consumer&lt;VaList.Builder&gt;, NativeScope, VaList&gt; vaListFactory,</span>
<span class="line-added">553                                  BiFunction&lt;Integer, VaList, Integer&gt; sumInts,</span>
<span class="line-added">554                                  MemoryLayout intLayout) {</span>
555         VaList listLeaked;
556         try (NativeScope scope = NativeScope.unboundedScope()) {
<span class="line-modified">557             VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-modified">558                                                     .vargFromInt(intLayout, 8),</span>
559                                                scope);
<span class="line-modified">560             int x = sumInts.apply(2, list);</span>
561             assertEquals(x, 12);
562             listLeaked = list;
563         }
564         assertFalse(listLeaked.isAlive());
565     }
566 
<span class="line-modified">567     @Test(dataProvider = &quot;structs&quot;)</span>
<span class="line-modified">568     public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-added">569                                 Function&lt;VaList, Integer&gt; sumStruct, // ignored</span>
<span class="line-added">570                                 MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
571         MemorySegment pointOut;
572         try (NativeScope scope = NativeScope.unboundedScope()) {
573             try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {
574                 VH_Point_x.set(pointIn.baseAddress(), 3);
575                 VH_Point_y.set(pointIn.baseAddress(), 6);
<span class="line-modified">576                 try (VaList list = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, pointIn))) {</span>
577                     pointOut = list.vargAsSegment(Point_LAYOUT, scope);
578                     assertEquals((int) VH_Point_x.get(pointOut.baseAddress()), 3);
579                     assertEquals((int) VH_Point_y.get(pointOut.baseAddress()), 6);
580                 }
581                 assertTrue(pointOut.isAlive()); // after VaList freed
582             }
583             assertTrue(pointOut.isAlive()); // after input MS freed
584         }
585         assertFalse(pointOut.isAlive()); // after scope freed
586     }
587 
<span class="line-modified">588     @DataProvider</span>
<span class="line-modified">589     public Object[][] copy() {</span>
<span class="line-modified">590         return new Object[][] {</span>
<span class="line-modified">591             { winVaListFactory,      Win64.C_INT   },</span>
<span class="line-added">592             { sysvVaListFactory,     SysV.C_INT    },</span>
<span class="line-added">593             { aarch64VaListFactory,  AArch64.C_INT },</span>
<span class="line-added">594         };</span>
<span class="line-added">595     }</span>
<span class="line-added">596 </span>
<span class="line-added">597     @Test(dataProvider = &quot;copy&quot;)</span>
<span class="line-added">598     public void testCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {</span>
<span class="line-added">599         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-added">600                                                      .vargFromInt(intLayout, 8))) {</span>
601             VaList  copy = list.copy();
<span class="line-modified">602             assertEquals(copy.vargAsInt(intLayout), 4);</span>
<span class="line-modified">603             assertEquals(copy.vargAsInt(intLayout), 8);</span>
604             copy.close();
605 
606             assertFalse(copy.isAlive());
607 
<span class="line-modified">608             assertEquals(list.vargAsInt(intLayout), 4);</span>
<span class="line-modified">609             assertEquals(list.vargAsInt(intLayout), 8);</span>
610         }
611     }
612 
<span class="line-modified">613     @Test(dataProvider = &quot;copy&quot;)</span>
<span class="line-modified">614     public void testScopedCopy(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory, MemoryLayout intLayout) {</span>
<span class="line-modified">615         try (VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-modified">616                                                      .vargFromInt(intLayout, 8))) {</span>
617             VaList copy;
618             try (NativeScope scope = NativeScope.unboundedScope()) {
619                 copy = list.copy(scope);
620 
<span class="line-modified">621                 assertEquals(copy.vargAsInt(intLayout), 4);</span>
<span class="line-modified">622                 assertEquals(copy.vargAsInt(intLayout), 8);</span>
623             }
624             assertFalse(copy.isAlive());
625 
<span class="line-modified">626             assertEquals(list.vargAsInt(intLayout), 4);</span>
<span class="line-modified">627             assertEquals(list.vargAsInt(intLayout), 8);</span>
628         }
629     }
630 
<span class="line-modified">631     @Test(dataProvider = &quot;copy&quot;,</span>
<span class="line-modified">632           expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">633     public void testCopyUnusableAfterOriginalClosed(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">634                                                     MemoryLayout intLayout) {</span>
<span class="line-added">635         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-added">636                                                 .vargFromInt(intLayout, 8));</span>
637         try (VaList copy = list.copy()) {
638             list.close();
639 
<span class="line-modified">640             copy.vargAsInt(intLayout); // should throw</span>
641         }
642     }
643 
<span class="line-modified">644     @Test(dataProvider = &quot;copy&quot;,</span>
<span class="line-modified">645           expectedExceptions = IllegalStateException.class)</span>
<span class="line-modified">646     public void testCopyUnusableAfterOriginalClosedScope(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">647                                                          MemoryLayout intLayout) {</span>
<span class="line-added">648         VaList list = vaListFactory.apply(b -&gt; b.vargFromInt(intLayout, 4)</span>
<span class="line-added">649                                                 .vargFromInt(intLayout, 8));</span>
650         try (NativeScope scope = NativeScope.unboundedScope()) {
651             VaList copy = list.copy(scope);
652             list.close();
653 
<span class="line-modified">654             copy.vargAsInt(intLayout); // should throw</span>
655         }
656     }
657 
658     @DataProvider
659     public static Object[][] upcalls() {
<span class="line-added">660         GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">661             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-added">662             C_LONGLONG.withName(&quot;y&quot;)</span>
<span class="line-added">663         );</span>
<span class="line-added">664         VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">665         VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">666         GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">667             C_INT.withName(&quot;x&quot;),</span>
<span class="line-added">668             C_INT.withName(&quot;y&quot;)</span>
<span class="line-added">669         );</span>
<span class="line-added">670         VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">671         VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">672         GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">673             C_FLOAT.withName(&quot;x&quot;),</span>
<span class="line-added">674             C_FLOAT.withName(&quot;y&quot;)</span>
<span class="line-added">675         );</span>
<span class="line-added">676         VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">677         VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">678         GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(</span>
<span class="line-added">679             C_LONGLONG.withName(&quot;x&quot;),</span>
<span class="line-added">680             C_LONGLONG.withName(&quot;y&quot;),</span>
<span class="line-added">681             C_LONGLONG.withName(&quot;z&quot;)</span>
<span class="line-added">682         );</span>
<span class="line-added">683         VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;x&quot;));</span>
<span class="line-added">684         VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;y&quot;));</span>
<span class="line-added">685         VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(&quot;z&quot;));</span>
<span class="line-added">686 </span>
687         return new Object[][]{
688             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
689                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
690                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
691                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
692                 }
693             })},
694             { linkVaListCB(&quot;upcallBigStruct&quot;), VaListConsumer.mh(vaList -&gt; {
695                 VaList copy = vaList.copy();
696                 try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {
697                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
698                     assertEquals((long) VH_BigPoint_y.get(struct.baseAddress()), 16);
699 
700                     VH_BigPoint_x.set(struct.baseAddress(), 0);
701                     VH_BigPoint_y.set(struct.baseAddress(), 0);
702                 }
703 
704                 // should be independent
705                 try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {
706                     assertEquals((long) VH_BigPoint_x.get(struct.baseAddress()), 8);
</pre>
<hr />
<pre>
713                     assertEquals((int) VH_Point_y.get(struct.baseAddress()), 10);
714                 }
715             })},
716             { linkVaListCB(&quot;upcallHugeStruct&quot;), VaListConsumer.mh(vaList -&gt; {
717                 try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {
718                     assertEquals((long) VH_HugePoint_x.get(struct.baseAddress()), 1);
719                     assertEquals((long) VH_HugePoint_y.get(struct.baseAddress()), 2);
720                     assertEquals((long) VH_HugePoint_z.get(struct.baseAddress()), 3);
721                 }
722             })},
723             { linkVaListCB(&quot;upcallFloatStruct&quot;), VaListConsumer.mh(vaList -&gt; {
724                 try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {
725                     assertEquals((float) VH_FloatPoint_x.get(struct.baseAddress()), 1.0f);
726                     assertEquals((float) VH_FloatPoint_y.get(struct.baseAddress()), 2.0f);
727                 }
728             })},
729             { linkVaListCB(&quot;upcallMemoryAddress&quot;), VaListConsumer.mh(vaList -&gt; {
730                 MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);
731                 MemorySegment ms = MemorySegment.ofNativeRestricted(intPtr, C_INT.byteSize(),
732                                                                     Thread.currentThread(), null, null);
<span class="line-modified">733                 int x = MemoryAccess.getInt(ms.baseAddress());</span>
734                 assertEquals(x, 10);
735             })},
736             { linkVaListCB(&quot;upcallDoubles&quot;), VaListConsumer.mh(vaList -&gt; {
737                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);
738                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);
739                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);
740             })},
741             { linkVaListCB(&quot;upcallInts&quot;), VaListConsumer.mh(vaList -&gt; {
742                 assertEquals(vaList.vargAsInt(C_INT), 10);
743                 assertEquals(vaList.vargAsInt(C_INT), 15);
744                 assertEquals(vaList.vargAsInt(C_INT), 20);
745             })},
746             { linkVaListCB(&quot;upcallStack&quot;), VaListConsumer.mh(vaList -&gt; {
747                 // skip all registers
<span class="line-modified">748                 for (long l = 1; l &lt;= 16; l++) {</span>
<span class="line-modified">749                     assertEquals(vaList.vargAsLong(C_LONGLONG), l);</span>
<span class="line-modified">750                 }</span>
<span class="line-modified">751                 for (double d = 1; d &lt;= 16; d++) {</span>
<span class="line-modified">752                     assertEquals(vaList.vargAsDouble(C_DOUBLE), d);</span>
<span class="line-modified">753                 }</span>


























754 
755                 // test some arbitrary values on the stack
756                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);
757                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;a&#39;);
758                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);
759                 assertEquals(vaList.vargAsInt(C_INT), 4);
760                 assertEquals(vaList.vargAsLong(C_LONGLONG), 5L);
761                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);
762                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);
763                 assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);
764                 assertEquals((char) vaList.vargAsInt(C_INT), &#39;b&#39;);
765                 assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);
766                 assertEquals(vaList.vargAsInt(C_INT), 11);
767                 assertEquals(vaList.vargAsLong(C_LONGLONG), 12L);
768                 assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);
769                 assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);
770 
771                 try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {
772                     assertEquals((int) VH_Point_x.get(point.baseAddress()), 5);
773                     assertEquals((int) VH_Point_y.get(point.baseAddress()), 10);
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> <a href="libVaList.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
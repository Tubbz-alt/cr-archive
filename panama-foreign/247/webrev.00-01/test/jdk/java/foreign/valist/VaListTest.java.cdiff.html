<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/jdk/java/foreign/valist/VaListTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> next &gt;</center>    <h2>test/jdk/java/foreign/valist/VaListTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 194,16 ***</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] getInt() {</span>
          Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
              list -&gt; {
                  MemoryAddress ma = list.vargAsAddress(layout);
                  MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
<span class="line-modified">!                         C_INT.byteSize(), Thread.currentThread(), null, null);</span>
                  return MemoryAccess.getInt(accessibleSegment.baseAddress());
              };
          Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
          return new Object[][]{
              { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
<span class="line-new-header">--- 194,16 ---</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] pointers() {</span>
          Function&lt;MemoryLayout, Function&lt;VaList, Integer&gt;&gt; getIntJavaFact = layout -&gt;
              list -&gt; {
                  MemoryAddress ma = list.vargAsAddress(layout);
                  MemorySegment accessibleSegment = MemorySegment.ofNativeRestricted(ma,
<span class="line-modified">!                         4, Thread.currentThread(), null, null);</span>
                  return MemoryAccess.getInt(accessibleSegment.baseAddress());
              };
          Function&lt;VaList, Integer&gt; getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);
          return new Object[][]{
              { winVaListFactory,      getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,18 ***</span>
              { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
              { platformVaListFactory, getIntNative,                            C_POINTER         },
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;getInt&quot;)</span>
      public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
<span class="line-modified">!                                         Function&lt;VaList, Integer&gt; getInt,</span>
                                          MemoryLayout pointerLayout) {
          try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
              MemoryAccess.setInt(msInt.baseAddress(), 10);
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {
<span class="line-modified">!                 int x = getInt.apply(vaList);</span>
                  assertEquals(x, 10);
              }
          }
      }
  
<span class="line-new-header">--- 211,18 ---</span>
              { aarch64VaListFactory,  getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },
              { platformVaListFactory, getIntNative,                            C_POINTER         },
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;pointers&quot;)</span>
      public void testVaListMemoryAddress(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
<span class="line-modified">!                                         Function&lt;VaList, Integer&gt; getFromPointer,</span>
                                          MemoryLayout pointerLayout) {
          try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {
              MemoryAccess.setInt(msInt.baseAddress(), 10);
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromAddress(pointerLayout, msInt.baseAddress()))) {
<span class="line-modified">!                 int x = getFromPointer.apply(vaList);</span>
                  assertEquals(x, 10);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,11 ***</span>
          R apply(S s, T t, U u);
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] winStructByValue() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
              = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(pointLayout);
                      int x = (int) VH_Point_x.get(struct.baseAddress());
<span class="line-new-header">--- 230,11 ---</span>
          R apply(S s, T t, U u);
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] structs() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Integer&gt;&gt; sumStructJavaFact
              = (pointLayout, VH_Point_x, VH_Point_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(pointLayout);
                      int x = (int) VH_Point_x.get(struct.baseAddress());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 264,14 ***</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;winStructByValue&quot;)</span>
<span class="line-modified">!     public void testWinStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                      Function&lt;VaList, Integer&gt; sumStruct,</span>
<span class="line-modified">!                                      MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
              VH_Point_x.set(struct.baseAddress(), 5);
              VH_Point_y.set(struct.baseAddress(), 10);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
<span class="line-new-header">--- 264,14 ---</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_INT, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_INT,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;structs&quot;)</span>
<span class="line-modified">!     public void testStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                            Function&lt;VaList, Integer&gt; sumStruct,</span>
<span class="line-modified">!                            MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {
              VH_Point_x.set(struct.baseAddress(), 5);
              VH_Point_y.set(struct.baseAddress(), 10);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(Point_LAYOUT, struct))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,11 ***</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] winStructByReference() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
              = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
                      long x = (long) VH_BigPoint_x.get(struct.baseAddress());
<span class="line-new-header">--- 281,11 ---</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] bigStructs() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
              = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);
                      long x = (long) VH_BigPoint_x.get(struct.baseAddress());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,14 ***</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;winStructByReference&quot;)</span>
<span class="line-modified">!     public void testWinStructByReference(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                          Function&lt;VaList, Long&gt; sumBigStruct,</span>
<span class="line-modified">!                                          MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
              VH_BigPoint_x.set(struct.baseAddress(), 5);
              VH_BigPoint_y.set(struct.baseAddress(), 10);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
<span class="line-new-header">--- 315,14 ---</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;bigStructs&quot;)</span>
<span class="line-modified">!     public void testBigStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                               Function&lt;VaList, Long&gt; sumBigStruct,</span>
<span class="line-modified">!                               MemoryLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {
              VH_BigPoint_x.set(struct.baseAddress(), 5);
              VH_BigPoint_y.set(struct.baseAddress(), 10);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(BigPoint_LAYOUT, struct))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,11 ***</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] floatStructByValue() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
              = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
                      float x = (float) VH_FloatPoint_x.get(struct.baseAddress());
<span class="line-new-header">--- 332,11 ---</span>
          }
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] floatStructs() {</span>
          TriFunction&lt;MemoryLayout, VarHandle, VarHandle, Function&lt;VaList, Float&gt;&gt; sumStructJavaFact
              = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);
                      float x = (float) VH_FloatPoint_x.get(struct.baseAddress());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,15 ***</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;floatStructByValue&quot;)</span>
<span class="line-modified">!     public void testFloatStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                        Function&lt;VaList, Float&gt; sumFloatStruct,</span>
<span class="line-modified">!                                        MemoryLayout FloatPoint_LAYOUT,</span>
<span class="line-modified">!                                        VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
              VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
              VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
<span class="line-new-header">--- 366,15 ---</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_FLOAT, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_FLOAT,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;floatStructs&quot;)</span>
<span class="line-modified">!     public void testFloatStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                 Function&lt;VaList, Float&gt; sumFloatStruct,</span>
<span class="line-modified">!                                 MemoryLayout FloatPoint_LAYOUT,</span>
<span class="line-modified">!                                 VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {</span>
          try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {
              VH_FloatPoint_x.set(struct.baseAddress(), 1.234f);
              VH_FloatPoint_y.set(struct.baseAddress(), 3.142f);
  
              try (VaList vaList = vaListFactory.apply(b -&gt; b.vargFromSegment(FloatPoint_LAYOUT, struct))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,11 ***</span>
          R apply(T0 t0, T1 t1, T2 t2, T3 t3);
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] hugeStructByValue() {</span>
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
              = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
                      long x = (long) VH_HugePoint_x.get(struct.baseAddress());
<span class="line-new-header">--- 388,11 ---</span>
          R apply(T0 t0, T1 t1, T2 t2, T3 t3);
      }
  
      @DataProvider
      @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified">!     public static Object[][] hugeStructs() {</span>
          QuadFunc&lt;MemoryLayout, VarHandle, VarHandle, VarHandle, Function&lt;VaList, Long&gt;&gt; sumStructJavaFact
              = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) -&gt;
                  list -&gt; {
                      MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);
                      long x = (long) VH_HugePoint_x.get(struct.baseAddress());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,15 ***</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;hugeStructByValue&quot;)</span>
<span class="line-modified">!     public void testHugeStructByValue(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                       Function&lt;VaList, Long&gt; sumHugeStruct,</span>
<span class="line-modified">!                                       MemoryLayout HugePoint_LAYOUT,</span>
<span class="line-modified">!                                       VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {</span>
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
              VH_HugePoint_x.set(struct.baseAddress(), 1);
              VH_HugePoint_y.set(struct.baseAddress(), 2);
<span class="line-new-header">--- 426,15 ---</span>
              argsFact.apply(aarch64VaListFactory,  AArch64.C_LONGLONG, sumStructJavaFact),
              argsFact.apply(platformVaListFactory, C_LONGLONG,         sumStructNativeFact),
          };
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;hugeStructs&quot;)</span>
<span class="line-modified">!     public void testHugeStruct(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,</span>
<span class="line-modified">!                                Function&lt;VaList, Long&gt; sumHugeStruct,</span>
<span class="line-modified">!                                MemoryLayout HugePoint_LAYOUT,</span>
<span class="line-modified">!                                VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {</span>
          // On AArch64 a struct needs to be larger than 16 bytes to be
          // passed by reference.
          try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {
              VH_HugePoint_x.set(struct.baseAddress(), 1);
              VH_HugePoint_y.set(struct.baseAddress(), 2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 562,11 ***</span>
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;winStructByValue&quot;)</span>
      public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                  Function&lt;VaList, Integer&gt; sumStruct, // ignored
                                  MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
<span class="line-new-header">--- 562,11 ---</span>
              listLeaked = list;
          }
          assertFalse(listLeaked.isAlive());
      }
  
<span class="line-modified">!     @Test(dataProvider = &quot;structs&quot;)</span>
      public void testScopeMSRead(Function&lt;Consumer&lt;VaList.Builder&gt;, VaList&gt; vaListFactory,
                                  Function&lt;VaList, Integer&gt; sumStruct, // ignored
                                  MemoryLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {
          MemorySegment pointOut;
          try (NativeScope scope = NativeScope.unboundedScope()) {
</pre>
<center>&lt; prev <a href="../../../../../index.html" target="_top">index</a> next &gt;</center>  </body>
</html>
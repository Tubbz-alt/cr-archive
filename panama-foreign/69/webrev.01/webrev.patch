diff a/README b/README
--- a/README
+++ /dev/null
@@ -1,12 +0,0 @@
-
-Welcome to the JDK!
-===================
-
-For information about building the JDK, including how to retrieve all
-of the source code, please see either of these files:
-
-  * doc/building.html   (html version)
-  * doc/building.md     (markdown version)
-
-See http://openjdk.java.net/ for more information about the OpenJDK
-Community and the JDK.
diff a/README.md b/README.md
--- /dev/null
+++ b/README.md
@@ -0,0 +1,39 @@
+
+Welcome to the JDK!
+===================
+
+For information about building the JDK, including how to retrieve all
+of the source code, please see either of these files:
+
+  * doc/building.html   (html version)
+  * doc/building.md     (markdown version)
+
+See http://openjdk.java.net/ for more information about the OpenJDK
+Community and the JDK.
+
+---
+About Project Panama
+===================
+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of Project Panama. More information can be found at: https://openjdk.java.net/projects/panama/
+
+The Project Panama JBS dashboard can be found at: https://bugs.openjdk.java.net/Dashboard.jspa?selectPageId=18412
+
+Early acccess (EA) binary snapshots can be found at: http://jdk.java.net/panama/
+
+About the panama-foreign repository
+===================
+This repository houses three main branches:
+- **foreign-memaccess**: Contains the developement of the foreign memory access API for [JEP 370](https://openjdk.java.net/jeps/370), which can be used to interact with different kinds of memory resources, including so-called off-heap or native memory.
+- **foreign-abi**: Contains the developement of the foreign function interface (FFI), which can be used to call native code in a .dll/.so/.dylib, or to create a native function pointer to a Java method which can be passed to code in a native library.
+- **foreign-jextract**: Contains the development of an API to parse native headers, which can be used to create an abstract representation (declarations) from a C header file. This branch also provides an accompanying extraction tool (jextract), which is built on top of the API, and can be used to generate Java bindings to access functions and/or structs in a native library described by a given header file.
+
+The foreign-jextract branch depends on the foreign-abi branch, which in turn depends on the foreign-memaccess branch. As such, the foreign-jextract branch is the most complete of the three and therefore the default branch of this repository.
+
+Building notes
+===================
+Jextract requires [LLVM 9.x](https://releases.llvm.org/download.html) as a dependency. So, to build the foreign-jextract branch, the flag `--with-libclang=/path/to/llvm/root` must be supplied when generating a build configuration. Please see [doc/building.md](doc/building.md) for general building instructions.
+
+Samples
+=======
+
+Please see [doc/panama_jextract.md](doc/panama_jextract.md) for examples on how to use `jextract` to work with common native libraries.
diff a/deps.txt b/deps.txt
--- a/deps.txt
+++ b/deps.txt
@@ -1,2 +1,2 @@
-foreign-memaccess
+foreign-abi
 
diff a/doc/panama_jextract.html b/doc/panama_jextract.html
--- /dev/null
+++ b/doc/panama_jextract.html
@@ -0,0 +1,271 @@
+<!DOCTYPE html>
+<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
+<head>
+  <meta charset="utf-8" />
+  <meta name="generator" content="pandoc" />
+  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
+  <title>Using Panama &quot;foreign&quot; JDK</title>
+  <style>
+    code{white-space: pre-wrap;}
+    span.smallcaps{font-variant: small-caps;}
+    span.underline{text-decoration: underline;}
+    div.column{display: inline-block; vertical-align: top; width: 50%;}
+    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
+    ul.task-list{list-style: none;}
+    pre > code.sourceCode { white-space: pre; position: relative; }
+    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
+    pre > code.sourceCode > span:empty { height: 1.2em; }
+    code.sourceCode > span { color: inherit; text-decoration: inherit; }
+    div.sourceCode { margin: 1em 0; }
+    pre.sourceCode { margin: 0; }
+    @media screen {
+    div.sourceCode { overflow: auto; }
+    }
+    @media print {
+    pre > code.sourceCode { white-space: pre-wrap; }
+    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
+    }
+    pre.numberSource code
+      { counter-reset: source-line 0; }
+    pre.numberSource code > span
+      { position: relative; left: -4em; counter-increment: source-line; }
+    pre.numberSource code > span > a:first-child::before
+      { content: counter(source-line);
+        position: relative; left: -1em; text-align: right; vertical-align: baseline;
+        border: none; display: inline-block;
+        -webkit-touch-callout: none; -webkit-user-select: none;
+        -khtml-user-select: none; -moz-user-select: none;
+        -ms-user-select: none; user-select: none;
+        padding: 0 4px; width: 4em;
+        color: #aaaaaa;
+      }
+    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
+    div.sourceCode
+      {   }
+    @media screen {
+    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
+    }
+    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
+    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
+    code span.at { color: #7d9029; } /* Attribute */
+    code span.bn { color: #40a070; } /* BaseN */
+    code span.bu { } /* BuiltIn */
+    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
+    code span.ch { color: #4070a0; } /* Char */
+    code span.cn { color: #880000; } /* Constant */
+    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
+    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
+    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
+    code span.dt { color: #902000; } /* DataType */
+    code span.dv { color: #40a070; } /* DecVal */
+    code span.er { color: #ff0000; font-weight: bold; } /* Error */
+    code span.ex { } /* Extension */
+    code span.fl { color: #40a070; } /* Float */
+    code span.fu { color: #06287e; } /* Function */
+    code span.im { } /* Import */
+    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
+    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
+    code span.op { color: #666666; } /* Operator */
+    code span.ot { color: #007020; } /* Other */
+    code span.pp { color: #bc7a00; } /* Preprocessor */
+    code span.sc { color: #4070a0; } /* SpecialChar */
+    code span.ss { color: #bb6688; } /* SpecialString */
+    code span.st { color: #4070a0; } /* String */
+    code span.va { color: #19177c; } /* Variable */
+    code span.vs { color: #4070a0; } /* VerbatimString */
+    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
+  </style>
+  <link rel="stylesheet" href="../make/data/docs-resources/resources/jdk-default.css" />
+  <!--[if lt IE 9]>
+    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
+  <![endif]-->
+</head>
+<body>
+<header id="title-block-header">
+<h1 class="title">Using Panama "foreign" JDK</h1>
+</header>
+<nav id="TOC" role="doc-toc">
+<ul>
+<li><a href="#using-panama-foreign-jextract-jdk">Using Panama "foreign-jextract" JDK</a>
+<ul>
+<li><a href="#hello-world">Hello World</a>
+<ul>
+<li><a href="#hello-world-c-header-helloworld.h">Hello World C Header (helloworld.h)</a></li>
+<li><a href="#hello-world-c-source-helloworld.c">Hello World C Source (helloworld.c)</a></li>
+<li><a href="#building-hello-world">Building Hello World</a></li>
+<li><a href="#jextract-a-jar-file-for-helloworld.h">jextract a Jar file for helloworld.h</a></li>
+<li><a href="#java-program-that-uses-extracted-helloworld-interface">Java program that uses extracted helloworld interface</a></li>
+<li><a href="#running-the-java-code-that-invokes-helloworld">Running the Java code that invokes helloworld</a></li>
+</ul></li>
+<li><a href="#embedding-python-interpreter-in-your-java-program-mac-os">Embedding Python interpreter in your Java program (Mac OS)</a>
+<ul>
+<li><a href="#jextract-a-jar-file-for-python.h">jextract a Jar file for Python.h</a></li>
+<li><a href="#java-program-that-uses-extracted-python-interface">Java program that uses extracted Python interface</a></li>
+<li><a href="#running-the-java-code-that-calls-python-interpreter">Running the Java code that calls Python interpreter</a></li>
+</ul></li>
+<li><a href="#using-readline-library-from-java-code-mac-os">Using readline library from Java code (Mac OS)</a>
+<ul>
+<li><a href="#jextract-a-jar-file-for-readline.h">jextract a jar file for readline.h</a></li>
+<li><a href="#java-code-that-uses-readline">Java code that uses readline</a></li>
+<li><a href="#running-the-java-code-that-uses-readline">Running the java code that uses readline</a></li>
+</ul></li>
+<li><a href="#using-libcurl-from-java-mac-os">Using libcurl from Java (Mac OS)</a>
+<ul>
+<li><a href="#jextract-a-jar-for-curl.h">jextract a jar for curl.h</a></li>
+<li><a href="#java-code-that-uses-libcurl">Java code that uses libcurl</a></li>
+<li><a href="#running-the-java-code-that-uses-libcurl">Running the java code that uses libcurl</a></li>
+</ul></li>
+</ul></li>
+</ul>
+</nav>
+<?xml version="1.0" encoding="utf-8"?>
+<h1 id="using-panama-foreign-jextract-jdk">Using Panama "foreign-jextract" JDK</h1>
+<p>You can build "foreign-jextract" branch of panama repo <a href="https://github.com/openjdk/panama-foreign">https://github.com/openjdk/panama-foreign</a></p>
+<p>Using foreign function call in Java involves the following two steps:</p>
+<ol type="1">
+<li>Use <strong>jextract</strong> tool to generate java interface for your C header file(s)</li>
+<li>Invoke C functions via the jextracted Java interface</li>
+</ol>
+<h2 id="hello-world">Hello World</h2>
+<h3 id="hello-world-c-header-helloworld.h">Hello World C Header (helloworld.h)</h3>
+<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1"></a></span>
+<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#ifndef helloworld_h</span></span>
+<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#define helloworld_h</span></span>
+<span id="cb1-4"><a href="#cb1-4"></a></span>
+<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">extern</span> <span class="dt">void</span> helloworld(<span class="dt">void</span>);</span>
+<span id="cb1-6"><a href="#cb1-6"></a></span>
+<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#endif </span><span class="co">/* helloworld_h */</span></span>
+<span id="cb1-8"><a href="#cb1-8"></a></span></code></pre></div>
+<h3 id="hello-world-c-source-helloworld.c">Hello World C Source (helloworld.c)</h3>
+<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1"></a></span>
+<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
+<span id="cb2-3"><a href="#cb2-3"></a></span>
+<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&quot;helloworld.h&quot;</span></span>
+<span id="cb2-5"><a href="#cb2-5"></a></span>
+<span id="cb2-6"><a href="#cb2-6"></a><span class="dt">void</span> helloworld(<span class="dt">void</span>) {</span>
+<span id="cb2-7"><a href="#cb2-7"></a>    printf(<span class="st">&quot;Hello World!</span><span class="sc">\n</span><span class="st">&quot;</span>);</span>
+<span id="cb2-8"><a href="#cb2-8"></a>}</span></code></pre></div>
+<h3 id="building-hello-world">Building Hello World</h3>
+<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a></span>
+<span id="cb3-2"><a href="#cb3-2"></a><span class="fu">cc</span> -shared -o libhelloworld.dylib helloworld.c</span></code></pre></div>
+<h3 id="jextract-a-jar-file-for-helloworld.h">jextract a Jar file for helloworld.h</h3>
+<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a></span>
+<span id="cb4-2"><a href="#cb4-2"></a><span class="ex">jextract</span> -t org.hello -lhelloworld helloworld.h</span></code></pre></div>
+<h3 id="java-program-that-uses-extracted-helloworld-interface">Java program that uses extracted helloworld interface</h3>
+<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1"></a></span>
+<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">import static</span><span class="im"> org.hello.helloworld_h.*;</span></span>
+<span id="cb5-3"><a href="#cb5-3"></a></span>
+<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">public</span> <span class="kw">class</span> HelloWorld {</span>
+<span id="cb5-5"><a href="#cb5-5"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
+<span id="cb5-6"><a href="#cb5-6"></a>        <span class="fu">helloworld</span>();</span>
+<span id="cb5-7"><a href="#cb5-7"></a>    }</span>
+<span id="cb5-8"><a href="#cb5-8"></a>}</span></code></pre></div>
+<h3 id="running-the-java-code-that-invokes-helloworld">Running the Java code that invokes helloworld</h3>
+<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a></span>
+<span id="cb6-2"><a href="#cb6-2"></a><span class="ex">java</span> -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign HelloWorld.java</span></code></pre></div>
+<h2 id="embedding-python-interpreter-in-your-java-program-mac-os">Embedding Python interpreter in your Java program (Mac OS)</h2>
+<h3 id="jextract-a-jar-file-for-python.h">jextract a Jar file for Python.h</h3>
+<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a></span>
+<span id="cb7-2"><a href="#cb7-2"></a><span class="ex">jextract</span> -l python2.7 \</span>
+<span id="cb7-3"><a href="#cb7-3"></a>  -I /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include \</span>
+<span id="cb7-4"><a href="#cb7-4"></a>  -I /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/python2.7/ \</span>
+<span id="cb7-5"><a href="#cb7-5"></a>  -t org.python \</span>
+<span id="cb7-6"><a href="#cb7-6"></a>  --filter pythonrun.h \</span>
+<span id="cb7-7"><a href="#cb7-7"></a>  --filter python.h \</span>
+<span id="cb7-8"><a href="#cb7-8"></a>   /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/python2.7/Python.h</span></code></pre></div>
+<h3 id="java-program-that-uses-extracted-python-interface">Java program that uses extracted Python interface</h3>
+<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1"></a></span>
+<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">import</span><span class="im"> jdk.incubator.foreign.Foreign;</span></span>
+<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">import static</span><span class="im"> jdk.incubator.foreign.MemoryAddress.NULL;</span></span>
+<span id="cb8-4"><a href="#cb8-4"></a><span class="co">// import jextracted python &#39;header&#39; class</span></span>
+<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">import static</span><span class="im"> org.python.Python_h.*;</span></span>
+<span id="cb8-6"><a href="#cb8-6"></a></span>
+<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">public</span> <span class="kw">class</span> PythonMain {</span>
+<span id="cb8-8"><a href="#cb8-8"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
+<span id="cb8-9"><a href="#cb8-9"></a>        var f = Foreign.<span class="fu">getInstance</span>();</span>
+<span id="cb8-10"><a href="#cb8-10"></a>        <span class="bu">String</span> script = <span class="st">&quot;print(sum([33, 55, 66])); print(&#39;Hello from Python!&#39;)</span><span class="sc">\n</span><span class="st">&quot;</span>;</span>
+<span id="cb8-11"><a href="#cb8-11"></a></span>
+<span id="cb8-12"><a href="#cb8-12"></a>        <span class="fu">Py_Initialize</span>();</span>
+<span id="cb8-13"><a href="#cb8-13"></a>        <span class="kw">try</span> (var s = f.<span class="fu">toCString</span>(script)) {</span>
+<span id="cb8-14"><a href="#cb8-14"></a>            var str = s.<span class="fu">baseAddress</span>();</span>
+<span id="cb8-15"><a href="#cb8-15"></a>            <span class="fu">PyRun_SimpleStringFlags</span>(str, NULL);</span>
+<span id="cb8-16"><a href="#cb8-16"></a>            <span class="fu">Py_Finalize</span>();</span>
+<span id="cb8-17"><a href="#cb8-17"></a>        }</span>
+<span id="cb8-18"><a href="#cb8-18"></a>    }</span>
+<span id="cb8-19"><a href="#cb8-19"></a>}</span></code></pre></div>
+<h3 id="running-the-java-code-that-calls-python-interpreter">Running the Java code that calls Python interpreter</h3>
+<div class="sourceCode" id="cb9"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a></span>
+<span id="cb9-2"><a href="#cb9-2"></a><span class="ex">java</span> -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign \</span>
+<span id="cb9-3"><a href="#cb9-3"></a>    -Djava.library.path=/System/Library/Frameworks/Python.framework/Versions/2.7/lib PythonMain.java</span></code></pre></div>
+<h2 id="using-readline-library-from-java-code-mac-os">Using readline library from Java code (Mac OS)</h2>
+<h3 id="jextract-a-jar-file-for-readline.h">jextract a jar file for readline.h</h3>
+<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a></span>
+<span id="cb10-2"><a href="#cb10-2"></a><span class="ex">jextract</span> -l readline -t org.unix \</span>
+<span id="cb10-3"><a href="#cb10-3"></a>  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include \</span>
+<span id="cb10-4"><a href="#cb10-4"></a>  --filter readline.h \</span>
+<span id="cb10-5"><a href="#cb10-5"></a>   /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/readline/readline.h</span></code></pre></div>
+<h3 id="java-code-that-uses-readline">Java code that uses readline</h3>
+<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1"></a></span>
+<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">import</span><span class="im"> jdk.incubator.foreign.Foreign;</span></span>
+<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">import static</span><span class="im"> org.unix.readline_h.*;</span></span>
+<span id="cb11-4"><a href="#cb11-4"></a></span>
+<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">public</span> <span class="kw">class</span> Readline {</span>
+<span id="cb11-6"><a href="#cb11-6"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
+<span id="cb11-7"><a href="#cb11-7"></a>        var f = Foreign.<span class="fu">getInstance</span>();</span>
+<span id="cb11-8"><a href="#cb11-8"></a>        <span class="kw">try</span> (var s = f.<span class="fu">toCString</span>(<span class="st">&quot;name? &quot;</span>)) {</span>
+<span id="cb11-9"><a href="#cb11-9"></a>            var pstr = s.<span class="fu">baseAddress</span>();</span>
+<span id="cb11-10"><a href="#cb11-10"></a>            <span class="co">// call &quot;readline&quot; API</span></span>
+<span id="cb11-11"><a href="#cb11-11"></a>            var p = <span class="fu">readline</span>(pstr);</span>
+<span id="cb11-12"><a href="#cb11-12"></a></span>
+<span id="cb11-13"><a href="#cb11-13"></a>            <span class="co">// print char* as is</span></span>
+<span id="cb11-14"><a href="#cb11-14"></a>            <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(p);</span>
+<span id="cb11-15"><a href="#cb11-15"></a>            <span class="co">// convert char* ptr from readline as Java String &amp; print it</span></span>
+<span id="cb11-16"><a href="#cb11-16"></a>            <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Hello, &quot;</span> + f.<span class="fu">toJavaString</span>(p));</span>
+<span id="cb11-17"><a href="#cb11-17"></a>        }</span>
+<span id="cb11-18"><a href="#cb11-18"></a>    }</span>
+<span id="cb11-19"><a href="#cb11-19"></a>}</span></code></pre></div>
+<h3 id="running-the-java-code-that-uses-readline">Running the java code that uses readline</h3>
+<pre><code>java -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign \
+    -Djava.library.path=/usr/local/opt/readline/lib/ Readline.java
+</code></pre>
+<h2 id="using-libcurl-from-java-mac-os">Using libcurl from Java (Mac OS)</h2>
+<h3 id="jextract-a-jar-for-curl.h">jextract a jar for curl.h</h3>
+<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a></span>
+<span id="cb13-2"><a href="#cb13-2"></a><span class="ex">jextract</span> -t org.unix -lcurl \</span>
+<span id="cb13-3"><a href="#cb13-3"></a>  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/ \</span>
+<span id="cb13-4"><a href="#cb13-4"></a>  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/curl/ \</span>
+<span id="cb13-5"><a href="#cb13-5"></a>  --filter easy.h \</span>
+<span id="cb13-6"><a href="#cb13-6"></a>  --filter curl.h \</span>
+<span id="cb13-7"><a href="#cb13-7"></a>  /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/curl/curl.h</span></code></pre></div>
+<h3 id="java-code-that-uses-libcurl">Java code that uses libcurl</h3>
+<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1"></a></span>
+<span id="cb14-2"><a href="#cb14-2"></a><span class="kw">import</span><span class="im"> jdk.incubator.foreign.Foreign;</span></span>
+<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">import static</span><span class="im"> jdk.incubator.foreign.MemoryAddress.NULL;</span></span>
+<span id="cb14-4"><a href="#cb14-4"></a><span class="kw">import static</span><span class="im"> org.unix.curl_h.*;</span></span>
+<span id="cb14-5"><a href="#cb14-5"></a></span>
+<span id="cb14-6"><a href="#cb14-6"></a><span class="kw">public</span> <span class="kw">class</span> CurlMain {</span>
+<span id="cb14-7"><a href="#cb14-7"></a>   <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
+<span id="cb14-8"><a href="#cb14-8"></a>       var f = Foreign.<span class="fu">getInstance</span>();</span>
+<span id="cb14-9"><a href="#cb14-9"></a>       var urlStr = args[<span class="dv">0</span>];</span>
+<span id="cb14-10"><a href="#cb14-10"></a>       <span class="fu">curl_global_init</span>(CURL_GLOBAL_DEFAULT);</span>
+<span id="cb14-11"><a href="#cb14-11"></a>       var curl = <span class="fu">curl_easy_init</span>();</span>
+<span id="cb14-12"><a href="#cb14-12"></a>       <span class="kw">if</span>(!curl.<span class="fu">equals</span>(NULL)) {</span>
+<span id="cb14-13"><a href="#cb14-13"></a>           <span class="kw">try</span> (var s = f.<span class="fu">toCString</span>(urlStr)) {</span>
+<span id="cb14-14"><a href="#cb14-14"></a>               var url = s.<span class="fu">baseAddress</span>();</span>
+<span id="cb14-15"><a href="#cb14-15"></a>               <span class="fu">curl_easy_setopt</span>(curl, CURLOPT_URL, url);</span>
+<span id="cb14-16"><a href="#cb14-16"></a>               <span class="dt">int</span> res = <span class="fu">curl_easy_perform</span>(curl);</span>
+<span id="cb14-17"><a href="#cb14-17"></a>               <span class="kw">if</span> (res != CURLE_OK) {</span>
+<span id="cb14-18"><a href="#cb14-18"></a>                   <span class="fu">curl_easy_cleanup</span>(curl);</span>
+<span id="cb14-19"><a href="#cb14-19"></a>               }</span>
+<span id="cb14-20"><a href="#cb14-20"></a>           }</span>
+<span id="cb14-21"><a href="#cb14-21"></a>       }</span>
+<span id="cb14-22"><a href="#cb14-22"></a>       <span class="fu">curl_global_cleanup</span>();</span>
+<span id="cb14-23"><a href="#cb14-23"></a>   }</span>
+<span id="cb14-24"><a href="#cb14-24"></a>}</span></code></pre></div>
+<h3 id="running-the-java-code-that-uses-libcurl">Running the java code that uses libcurl</h3>
+<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1"></a></span>
+<span id="cb15-2"><a href="#cb15-2"></a><span class="co"># run this shell script by passing a URL as first argument</span></span>
+<span id="cb15-3"><a href="#cb15-3"></a><span class="ex">java</span> -Djdk.incubator.foreign.Foreign=permit --add-modules \</span>
+<span id="cb15-4"><a href="#cb15-4"></a>    jdk.incubator.foreign -Djava.library.path=/usr/lib CurlMain.java <span class="va">$*</span></span></code></pre></div>
+</body>
+</html>
diff a/doc/panama_jextract.md b/doc/panama_jextract.md
--- /dev/null
+++ b/doc/panama_jextract.md
@@ -0,0 +1,232 @@
+% Using Panama "foreign" JDK
+
+<?xml version="1.0" encoding="utf-8"?>
+
+# Using Panama "foreign-jextract" JDK
+
+You can build "foreign-jextract" branch of panama repo [https://github.com/openjdk/panama-foreign](https://github.com/openjdk/panama-foreign)
+
+Using foreign function call in Java involves the following two steps:
+
+1. Use **jextract** tool to generate java interface for your C header file(s)
+2. Invoke C functions via the jextracted Java interface
+
+## Hello World
+
+### Hello World C Header (helloworld.h)
+
+```C
+
+#ifndef helloworld_h
+#define helloworld_h
+
+extern void helloworld(void);
+
+#endif /* helloworld_h */
+
+
+```
+
+### Hello World C Source (helloworld.c)
+
+```C
+
+#include <stdio.h>
+
+#include "helloworld.h"
+
+void helloworld(void) {
+    printf("Hello World!\n");
+}
+
+```
+
+### Building Hello World
+
+```sh
+
+cc -shared -o libhelloworld.dylib helloworld.c
+
+```
+
+
+### jextract a Jar file for helloworld.h
+
+```sh
+
+jextract -t org.hello -lhelloworld helloworld.h
+
+```
+
+### Java program that uses extracted helloworld interface
+
+```java
+
+import static org.hello.helloworld_h.*;
+
+public class HelloWorld {
+    public static void main(String[] args) {
+        helloworld();
+    }
+}
+
+```
+
+### Running the Java code that invokes helloworld
+
+```sh
+
+java -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign HelloWorld.java
+
+```
+
+## Embedding Python interpreter in your Java program (Mac OS)
+
+### jextract a Jar file for Python.h
+
+```sh
+
+jextract -l python2.7 \
+  -I /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include \
+  -I /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/python2.7/ \
+  -t org.python \
+  --filter pythonrun.h \
+  --filter python.h \
+   /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/python2.7/Python.h
+
+```
+
+### Java program that uses extracted Python interface
+
+```java
+
+import jdk.incubator.foreign.Foreign;
+import static jdk.incubator.foreign.MemoryAddress.NULL;
+// import jextracted python 'header' class
+import static org.python.Python_h.*;
+
+public class PythonMain {
+    public static void main(String[] args) {
+        var f = Foreign.getInstance();
+        String script = "print(sum([33, 55, 66])); print('Hello from Python!')\n";
+
+        Py_Initialize();
+        try (var s = f.toCString(script)) {
+            var str = s.baseAddress();
+            PyRun_SimpleStringFlags(str, NULL);
+            Py_Finalize();
+        }
+    }
+}
+
+```
+
+### Running the Java code that calls Python interpreter
+
+```sh
+
+java -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign \
+    -Djava.library.path=/System/Library/Frameworks/Python.framework/Versions/2.7/lib PythonMain.java
+
+```
+
+## Using readline library from Java code (Mac OS)
+
+### jextract a jar file for readline.h
+
+```sh
+
+jextract -l readline -t org.unix \
+  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include \
+  --filter readline.h \
+   /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/readline/readline.h
+
+```
+
+### Java code that uses readline
+
+```java
+
+import jdk.incubator.foreign.Foreign;
+import static org.unix.readline_h.*;
+
+public class Readline {
+    public static void main(String[] args) {
+        var f = Foreign.getInstance();
+        try (var s = f.toCString("name? ")) {
+            var pstr = s.baseAddress();
+            // call "readline" API
+            var p = readline(pstr);
+
+            // print char* as is
+            System.out.println(p);
+            // convert char* ptr from readline as Java String & print it
+            System.out.println("Hello, " + f.toJavaString(p));
+        }
+    }
+}
+
+```
+
+### Running the java code that uses readline
+
+```
+java -Djdk.incubator.foreign.Foreign=permit --add-modules jdk.incubator.foreign \
+    -Djava.library.path=/usr/local/opt/readline/lib/ Readline.java
+
+```
+
+## Using libcurl from Java (Mac OS)
+
+### jextract a jar for curl.h
+
+```sh
+
+jextract -t org.unix -lcurl \
+  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/ \
+  -I /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/curl/ \
+  --filter easy.h \
+  --filter curl.h \
+  /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/include/curl/curl.h
+
+```
+
+### Java code that uses libcurl
+
+```java
+
+import jdk.incubator.foreign.Foreign;
+import static jdk.incubator.foreign.MemoryAddress.NULL;
+import static org.unix.curl_h.*;
+
+public class CurlMain {
+   public static void main(String[] args) {
+       var f = Foreign.getInstance();
+       var urlStr = args[0];
+       curl_global_init(CURL_GLOBAL_DEFAULT);
+       var curl = curl_easy_init();
+       if(!curl.equals(NULL)) {
+           try (var s = f.toCString(urlStr)) {
+               var url = s.baseAddress();
+               curl_easy_setopt(curl, CURLOPT_URL, url);
+               int res = curl_easy_perform(curl);
+               if (res != CURLE_OK) {
+                   curl_easy_cleanup(curl);
+               }
+           }
+       }
+       curl_global_cleanup();
+   }
+}
+
+```
+
+### Running the java code that uses libcurl
+
+```sh
+
+# run this shell script by passing a URL as first argument
+java -Djdk.incubator.foreign.Foreign=permit --add-modules \
+    jdk.incubator.foreign -Djava.library.path=/usr/lib CurlMain.java $*
+
+```
diff a/make/CompileJavaModules.gmk b/make/CompileJavaModules.gmk
--- a/make/CompileJavaModules.gmk
+++ b/make/CompileJavaModules.gmk
@@ -423,10 +423,14 @@
 
 jdk.internal.jvmstat_COPY += aliasmap
 
 ################################################################################
 
+jdk.incubator.jextract_COPY += .properties .template
+
+################################################################################
+
 # -parameters provides method's parameters information in class file,
 # JVMCI compilers make use of that information for various sanity checks.
 # Don't use Indy strings concatenation to have good JVMCI startup performance.
 # The exports are needed since JVMCI is dynamically exported (see
 # jdk.vm.ci.services.internal.ReflectionAccessJDK::openJVMCITo).
diff a/make/autoconf/lib-clang.m4 b/make/autoconf/lib-clang.m4
--- /dev/null
+++ b/make/autoconf/lib-clang.m4
@@ -0,0 +1,203 @@
+#
+# Copyright (c) 2014, 2015, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+################################################################################
+# Setup libclang from llvm project
+################################################################################
+AC_DEFUN_ONCE([LIB_SETUP_LIBCLANG],
+[
+  AC_ARG_WITH([libclang], [AS_HELP_STRING([--with-libclang=<path to llvm>],
+      [Specify path of llvm installation containing libclang. Pre-built llvm
+      binary can be downloaded from http://llvm.org/releases/download.html])])
+  AC_ARG_WITH([libclang-lib], [AS_HELP_STRING([--with-libclang-lib=<path>],
+      [Specify where to find libclang binary, so/dylib/lib ])])
+  AC_ARG_WITH([libclang-include], [AS_HELP_STRING([--with-libclang-include=<path>],
+      [Specify where to find libclang header files, clang-c/Index.h ])])
+  AC_ARG_WITH([libclang-include-aux], [AS_HELP_STRING([--with-libclang-include-aux=<path>],
+      [Specify where to find libclang auxiliary header files, lib/clang/<clang-version>/include/stddef.h ])])
+  AC_ARG_WITH([libclang-bin], [AS_HELP_STRING([--with-libclang-bin=<path>],
+      [Specify where to find clang binary, libclang.dll ])])
+  AC_ARG_WITH([libclang-version], [AS_HELP_STRING([--with-libclang-version=<version>],
+      [Specify which libclang version to use ])])
+
+  if test "x$with_libclang" = "xno"; then
+    AC_MSG_CHECKING([if libclang should be enabled])
+    AC_MSG_RESULT([no, forced])
+    ENABLE_LIBCLANG="false"
+  else
+    if test "x$with_libclang" != "x"; then
+      AC_MSG_CHECKING([if libclang should be enabled])
+      AC_MSG_RESULT([yes, forced])
+      ENABLE_LIBCLANG_FORCED="true"
+    else
+      ENABLE_LIBCLANG_FORCED="false"
+    fi
+    ENABLE_LIBCLANG="true"
+
+    AC_MSG_CHECKING([libclang version to be used])
+    if test "x$with_libclang_version" != "x"; then
+      LIBCLANG_VERSION="$with_libclang_version"
+      AC_MSG_RESULT([$LIBCLANG_VERSION (manually specified)])
+    else
+      LIBCLANG_VERSION="9"
+      AC_MSG_RESULT([$LIBCLANG_VERSION (default)])
+    fi
+
+    if test "x$with_libclang" != "x" -a "x$with_libclang" != "xyes"; then
+      CLANG_LIB_PATH="$with_libclang/lib"
+      CLANG_BIN_PATH="$with_libclang/bin"
+      CLANG_INCLUDE_PATH="$with_libclang/include"
+
+      AC_MSG_CHECKING([libclang auxiliary include path])
+      if test "x$with_libclang_include_aux" != "x"; then
+        CLANG_INCLUDE_AUX_PATH="$with_libclang_include_aux"
+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])
+        if test "x$with_libclang_version" != "x"; then
+          AC_MSG_WARN([--with-libclang-include-aux was specified. Manually specified value of --with-libclang-version was ignored])
+        fi        
+      else 
+        # There may be more than one version of clang matching the specifed version.
+        # Pick the last one if there are more than one versions.
+        VER=`$LS $with_libclang/lib/clang/ | $GREP "^$LIBCLANG_VERSION" | $TAIL -n1`
+        if test "x$VER" = "x"; then
+          AC_MSG_ERROR([Can not find libclang version matching the specified version: '$LIBCLANG_VERSION' in
+            $($FIND $with_libclang/lib/clang/ -mindepth 1 -maxdepth 1)])
+        fi        
+        CLANG_INCLUDE_AUX_PATH="$with_libclang/lib/clang/$VER/include"
+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])
+      fi      
+    fi
+
+    if test "x$with_libclang_lib" != "x"; then
+      CLANG_LIB_PATH="$with_libclang_lib"
+    fi
+    if test "x$with_libclang_include" != "x"; then
+      CLANG_INCLUDE_PATH="$with_libclang_include"
+    fi
+    if test "x$with_libclang_bin" != "x"; then
+      CLANG_BIN_PATH="$with_libclang_bin"
+    fi
+
+    dnl Only for Windows platform now, as we don't need bin yet for other platform
+    if test "x$OPENJDK_TARGET_OS" = xwindows; then
+        UTIL_FIXUP_PATH(CLANG_BIN_PATH)
+    else
+        CLANG_BIN_PATH=""
+    fi
+
+    UTIL_FIXUP_PATH(CLANG_INCLUDE_PATH)
+    UTIL_FIXUP_PATH(CLANG_LIB_PATH)
+    UTIL_FIXUP_PATH(CLANG_INCLUDE_AUX_PATH)
+
+    if test "x$CLANG_INCLUDE_PATH" != "x"; then
+        LIBCLANG_CPPFLAGS="-I$CLANG_INCLUDE_PATH"
+    else
+        LIBCLANG_CPPFLAGS=""
+    fi
+
+    if test "x$CLANG_LIB_PATH" != "x"; then
+      if test "x$TOOLCHAIN_TYPE" = "xmicrosoft"; then
+        LIBCLANG_LDFLAGS="/LIBPATH:$CLANG_LIB_PATH"
+        LIBCLANG_LIBS="$CLANG_LIB_PATH/libclang.lib"
+      else
+        LIBCLANG_LDFLAGS="-L$CLANG_LIB_PATH"
+        LIBCLANG_LIBS="-lclang"
+      fi
+    else
+        LIBCLANG_LDFLAGS=""
+    fi
+
+    OLD_CPPFLAGS=$CPPFLAGS
+    OLD_LDFLAGS=$LDFLAGS
+    OLD_LIBS=$LIBS
+
+    CPPFLAGS="$LIBCLANG_CPPFLAGS"
+    LDFLAGS="$LIBCLANG_LDFLAGS"
+    LIBS=""
+
+    OLD_CXX=$CXX
+    OLD_CXXCPP=$CXXCPP
+    CXX="$FIXPATH $CXX"
+    CXXCPP="$FIXPATH $CXXCPP"
+
+    AC_CHECK_HEADER("clang-c/Index.h", [], [ENABLE_LIBCLANG="false"])
+    if test "x$ENABLE_LIBCLANG" = "xtrue"; then
+      if test "x$TOOLCHAIN_TYPE" = "xmicrosoft" || test "x$COMPILE_TYPE" = "xcross"; then
+        # Just trust the lib is there
+        LIBS=$LIBCLANG_LIBS
+      else
+        AC_CHECK_LIB(clang, clang_getClangVersion, [], [ENABLE_LIBCLANG="false"])
+      fi
+    fi
+
+    CXX=$OLD_CXX
+    CXXCPP=$OLD_CXXCPP
+
+    if test "x$ENABLE_LIBCLANG" = "xfalse"; then
+      if test "x$ENABLE_LIBCLANG_FORCED" = "xtrue"; then
+        AC_MSG_ERROR([Cannot locate libclang or headers at the specified locations:
+            $CLANG_LIB_PATH
+            $CLANG_INCLUDE_PATH])
+      else
+        AC_MSG_CHECKING([if libclang should be enabled])
+        AC_MSG_RESULT([no, not found])
+        AC_MSG_NOTICE([Cannot locate libclang! You can download pre-built llvm
+            binary from http://llvm.org/releases/download.html, then specify the
+            location using --with-libclang])
+      fi
+    fi
+
+    LIBCLANG_LIBS="$LIBS"
+
+    LIBS="$OLD_LIBS"
+    LDFLAGS="$OLD_LDFLAGS"
+    CPPFLAGS="$OLD_CPPFLAGS"
+  fi
+
+  if test "x$ENABLE_LIBCLANG" = "xfalse"; then
+    CLANG_INCLUDE_PATH=""
+    CLANG_INCLUDE_AUX_PATH=""
+    CLANG_LIB_PATH=""
+    LIBCLANG_CPPFLAGS=""
+    LIBCLANG_LDFLAGS=""
+    LIBCLANG_LIBS=""
+  else
+    if test "x$OPENJDK_TARGET_OS" = xwindows; then
+      CLANG_LIBNAME=[$CLANG_BIN_PATH]["/libclang"][$SHARED_LIBRARY_SUFFIX]
+    else
+      CLANG_LIBNAME=[$CLANG_LIB_PATH/$LIBRARY_PREFIX]["clang"][$SHARED_LIBRARY_SUFFIX]
+    fi
+    UTIL_REMOVE_SYMBOLIC_LINKS(CLANG_LIBNAME)
+  fi
+
+  AC_SUBST(ENABLE_LIBCLANG)
+  AC_SUBST(CLANG_INCLUDE_PATH)
+  AC_SUBST(CLANG_INCLUDE_AUX_PATH)
+  AC_SUBST(CLANG_LIB_PATH)
+  AC_SUBST(CLANG_LIBNAME)
+  AC_SUBST(LIBCLANG_CPPFLAGS)
+  AC_SUBST(LIBCLANG_LDFLAGS)
+  AC_SUBST(LIBCLANG_LIBS)
+])
diff a/make/autoconf/libraries.m4 b/make/autoconf/libraries.m4
--- a/make/autoconf/libraries.m4
+++ b/make/autoconf/libraries.m4
@@ -31,10 +31,11 @@
 m4_include([lib-freetype.m4])
 m4_include([lib-std.m4])
 m4_include([lib-x11.m4])
 m4_include([lib-fontconfig.m4])
 m4_include([lib-tests.m4])
+m4_include([lib-clang.m4])
 
 ################################################################################
 # Determine which libraries are needed for this configuration
 ################################################################################
 AC_DEFUN_ONCE([LIB_DETERMINE_DEPENDENCIES],
@@ -101,10 +102,11 @@
   LIB_SETUP_LIBFFI
   LIB_SETUP_BUNDLED_LIBS
   LIB_SETUP_MISC_LIBS
   LIB_SETUP_SOLARIS_STLPORT
   LIB_TESTS_SETUP_GRAALUNIT
+  LIB_SETUP_LIBCLANG
 
   if test "x$TOOLCHAIN_TYPE" = xsolstudio; then
     GLOBAL_LIBS="-lc"
   else
     GLOBAL_LIBS=""
diff a/make/autoconf/spec.gmk.in b/make/autoconf/spec.gmk.in
--- a/make/autoconf/spec.gmk.in
+++ b/make/autoconf/spec.gmk.in
@@ -120,10 +120,19 @@
 RELEASE_FILE_OS_ARCH:=@RELEASE_FILE_OS_ARCH@
 
 LIBM:=@LIBM@
 LIBDL:=@LIBDL@
 
+ENABLE_LIBCLANG:=@ENABLE_LIBCLANG@
+CLANG_LIB_PATH:=@CLANG_LIB_PATH@
+CLANG_INCLUDE_PATH:=@CLANG_INCLUDE_PATH@
+CLANG_INCLUDE_AUX_PATH:=@CLANG_INCLUDE_AUX_PATH@
+CLANG_LIBNAME:=@CLANG_LIBNAME@
+LIBCLANG_CPPFLAGS:=@LIBCLANG_CPPFLAGS@
+LIBCLANG_LDFLAGS:=@LIBCLANG_LDFLAGS@
+LIBCLANG_LIBS:=@LIBCLANG_LIBS@
+
 # colon or semicolon
 PATH_SEP:=@PATH_SEP@
 
 # Save the original path before replacing it with the Visual Studio tools
 ORIGINAL_PATH:=@ORIGINAL_PATH@
@@ -594,10 +603,11 @@
 SHARED_LIBRARY_FLAGS=@SHARED_LIBRARY_FLAGS@
 
 # Set origin using the linker, ie use the relative path to the dependent library to find the dependees.
 # (Note absence of := assignment, because we do not want to evaluate the macro body here)
 SET_SHARED_LIBRARY_ORIGIN=@SET_SHARED_LIBRARY_ORIGIN@
+SET_JCLANG_LIBRARY_ORIGIN=@SET_JCLANG_LIBRARY_ORIGIN@
 SET_EXECUTABLE_ORIGIN=@SET_EXECUTABLE_ORIGIN@
 
 # Different OS:es have different ways of naming shared libraries.
 # The SHARED_LIBRARY macro takes "verify" as and argument and returns:
 #    "libverify.so" or "libverify.dylib" or "verify.dll" depending on platform.
diff a/make/common/Modules.gmk b/make/common/Modules.gmk
--- a/make/common/Modules.gmk
+++ b/make/common/Modules.gmk
@@ -162,10 +162,11 @@
     jdk.jlink \
     jdk.jsobject \
     jdk.jshell \
     jdk.jstatd \
     jdk.incubator.foreign \
+    jdk.incubator.jextract \
     jdk.localedata \
     jdk.management \
     jdk.management.agent \
     jdk.management.jfr \
     jdk.naming.dns \
@@ -188,10 +189,11 @@
     java.compiler \
     jdk.compiler \
     jdk.javadoc \
     jdk.jdeps \
     jdk.jshell \
+    jdk.incubator.jextract \
     #
 
 HOTSPOT_MODULES := \
     jdk.aot \
     jdk.hotspot.agent \
diff a/make/copy/Copy-jdk.incubator.jextract.gmk b/make/copy/Copy-jdk.incubator.jextract.gmk
--- /dev/null
+++ b/make/copy/Copy-jdk.incubator.jextract.gmk
@@ -0,0 +1,55 @@
+#
+# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+include CopyCommon.gmk
+
+################################################################################
+
+ifeq ($(ENABLE_LIBCLANG), true)
+
+  ifeq ($(OPENJDK_BUILD_OS), windows)
+      LIB_PATH := $(CLANG_LIBNAME)
+      LINK_MACRO := install-file
+  else
+      LIB_PATH := $(CLANG_LIB_PATH)/$(LIBRARY_PREFIX)clang$(SHARED_LIBRARY_SUFFIX)
+      LINK_MACRO := link-file-absolute
+  endif
+
+  $(eval $(call SetupCopyFiles, COPY_CLANG_LIB, \
+      FILES := $(wildcard $(LIB_PATH)*), \
+      DEST := $(SUPPORT_OUTPUTDIR)/modules_libs/$(MODULE), \
+      MACRO := $(LINK_MACRO), \
+  ))
+
+  $(eval $(call SetupCopyFiles, COPY_CLANG_HEADERS, \
+      DEST := $(CONF_DST_DIR)/jextract, \
+      FILES := $(wildcard $(CLANG_INCLUDE_AUX_PATH)/*.h), \
+  ))
+
+  TARGETS := $(COPY_CLANG_LIB) $(COPY_CLANG_HEADERS)
+
+endif
+
+################################################################################
diff a/make/devkit/createLibclangBundle.sh b/make/devkit/createLibclangBundle.sh
--- /dev/null
+++ b/make/devkit/createLibclangBundle.sh
@@ -0,0 +1,186 @@
+#!/bin/bash
+#
+# Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# This script generates a libclang bundle. On linux by building it from source
+# using a devkit, which should match the devkit used to build the JDK. On Macos
+# prebuilt binaries are downloaded and repackaged. On Windows, the binary LLVM
+# distribution needs to be downloaded and installed manually first.
+#
+# Set MAKE_ARGS to add parameters to make. Ex:
+#
+# $ MAKE_ARGS=-j32 bash createLibclangBundle.sh
+#
+# The llvm/clang build is very resource intensive at the end so often needs
+# to be restarted a few times before it fully succeeds.
+#
+# The script tries to behave well on multiple invocations, only performing steps
+# not already done. To redo a step, manually delete the target files from that
+# step.
+
+LLVM_VERSION=9.0.0
+
+BUNDLE_NAME=libclang-$LLVM_VERSION.tar.gz
+
+SCRIPT_DIR="$(cd "$(dirname $0)" > /dev/null && pwd)"
+OUTPUT_DIR="${SCRIPT_DIR}/../../build/libclang"
+SRC_DIR="$OUTPUT_DIR/src"
+BUILD_DIR="$OUTPUT_DIR/build"
+DOWNLOAD_DIR="$OUTPUT_DIR/download"
+INSTALL_DIR="$OUTPUT_DIR/install"
+IMAGE_DIR="$OUTPUT_DIR/image"
+
+OS_NAME=$(uname -s)
+case $OS_NAME in
+  Linux)
+    USAGE="$0 <devkit dir>"
+
+    if [ "$1" = "" ]; then
+      echo $USAGE
+      exit 1
+    fi
+    DEVKIT_DIR="$1"
+
+    LIB_SUFFIX=.so
+
+    # Download source distros
+    mkdir -p $DOWNLOAD_DIR
+    cd $DOWNLOAD_DIR
+    LLVM_FILE=llvm-$LLVM_VERSION.src.tar.xz
+    if [ ! -f $LLVM_FILE ]; then
+      wget http://releases.llvm.org/$LLVM_VERSION/$LLVM_FILE
+    fi
+    CLANG_FILE=cfe-$LLVM_VERSION.src.tar.xz
+    if [ ! -f $CLANG_FILE ]; then
+      wget http://releases.llvm.org/$LLVM_VERSION/$CLANG_FILE
+    fi
+
+
+    # Unpack src
+    mkdir -p $SRC_DIR
+    cd $SRC_DIR
+    LLVM_DIRNAME=llvm-$LLVM_VERSION.src
+    LLVM_DIR=$SRC_DIR/$LLVM_DIRNAME
+    if [ ! -d $LLVM_DIRNAME ]; then
+      echo "Unpacking $LLVM_FILE"
+      tar xf $DOWNLOAD_DIR/$LLVM_FILE
+    fi
+    CLANG_DIRNAME=cfe-$LLVM_VERSION.src
+    CLANG_DIR=$LLVM_DIRNAME/tools/$CLANG_DIRNAME
+    if [ ! -d $CLANG_DIR ]; then
+      echo "Unpacking $CLANG_FILE"
+      (cd $LLVM_DIR/tools && tar xf $DOWNLOAD_DIR/$CLANG_FILE)
+    fi
+
+    # Build
+    mkdir -p $BUILD_DIR
+    cd $BUILD_DIR
+
+    #init cmake
+    if [ ! -e cmake ]; then
+      cmake -G 'Unix Makefiles' \
+            -DCMAKE_INSTALL_PREFIX=../install \
+            -DCMAKE_BUILD_TYPE=Release \
+            -DCMAKE_C_COMPILER=$DEVKIT_DIR/bin/gcc \
+            -DCMAKE_CXX_COMPILER=$DEVKIT_DIR/bin/g++ \
+            -DCMAKE_C_FLAGS="-static-libgcc" \
+            -DCMAKE_CXX_FLAGS="-static-libgcc -static-libstdc++" \
+            -DLLVM_ENABLE_TERMINFO=no \
+            $LLVM_DIR
+    fi
+
+    # Run with nice to keep system usable during build.
+    nice make $MAKE_ARGS libclang
+    nice make $MAKE_ARGS install
+    ;;
+  Darwin)
+    LIB_SUFFIX=".dylib"
+
+    # Download binaries
+    mkdir -p $DOWNLOAD_DIR
+    cd $DOWNLOAD_DIR
+    LLVM_FILE=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple.tar.xz
+    if [ ! -f $LLVM_FILE ]; then
+      echo http://releases.llvm.org/$LLVM_VERSION/$LLVM_FILE
+      curl -O http://releases.llvm.org/$LLVM_VERSION/$LLVM_FILE
+    fi
+
+    # Extract binaries
+    cd $OUTPUT_DIR
+    LLVM_DIRNAME=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple
+    LLVM_DIR=$OUTPUT_DIR/$LLVM_DIRNAME
+    INSTALL_DIR=$LLVM_DIR
+    if [ ! -d $LLVM_DIRNAME ]; then
+      echo "Unpacking $LLVM_FILE"
+      tar xf $DOWNLOAD_DIR/$LLVM_FILE
+    fi
+    ;;
+  CYGWIN*)
+    if [ "$1" = "" ]; then
+      echo "Download and install http://releases.llvm.org/$LLVM_VERSION/LLVM-$LLVM_VERSION-win64.exe"
+      echo "Then run: $0 <path to install dir>"
+      exit 1
+    fi
+    INSTALL_DIR="$(cygpath -m -s "$1")"
+    echo "Copying from $INSTALL_DIR"
+    LIB_SUFFIX=".lib"
+
+    if [ ! -e $IMAGE_DIR/bin/libclang.dll ]; then
+      echo "Copying libclang.dll to image"
+      mkdir -p $IMAGE_DIR/bin
+      cp -a $INSTALL_DIR/bin/libclang.* $IMAGE_DIR/bin/
+    fi
+    ;;
+  *)
+    echo " Unsupported OS: $OS_NAME"
+    exit 1
+    ;;
+esac
+
+mkdir -p $IMAGE_DIR
+# Extract what we need into an image
+if [ ! -e $IMAGE_DIR/lib/libclang$LIB_SUFFIX ]; then
+  echo "Copying libclang$LIB_SUFFIX to image"
+  mkdir -p $IMAGE_DIR/lib
+  cp -a $INSTALL_DIR/lib/libclang.* $IMAGE_DIR/lib/
+fi
+if [ ! -e $IMAGE_DIR/include/clang-c ]; then
+  echo "Copying include to image"
+  mkdir -p $IMAGE_DIR/include
+  cp -a $INSTALL_DIR/include/. $IMAGE_DIR/include/
+fi
+if [ ! -e $IMAGE_DIR/lib/clang/$LLVM_VERSION/include/stddef.h ]; then
+  echo "Copying lib/clang/*/include to image"
+  mkdir -p $IMAGE_DIR/lib/clang/$LLVM_VERSION/include
+  cp -a $INSTALL_DIR/lib/clang/$LLVM_VERSION/include/. \
+     $IMAGE_DIR/lib/clang/$LLVM_VERSION/include/
+fi
+
+# Create bundle
+if [ ! -e $OUTPUT_DIR/$BUNDLE_NAME ]; then
+  echo "Creating $OUTPUT_DIR/$BUNDLE_NAME"
+  cd $IMAGE_DIR
+  tar zcf $OUTPUT_DIR/$BUNDLE_NAME *
+fi
diff a/make/launcher/Launcher-jdk.incubator.jextract.gmk b/make/launcher/Launcher-jdk.incubator.jextract.gmk
--- /dev/null
+++ b/make/launcher/Launcher-jdk.incubator.jextract.gmk
@@ -0,0 +1,32 @@
+#
+# Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+include LauncherCommon.gmk
+
+$(eval $(call SetupBuildLauncher, jextract,\
+    CFLAGS := -DENABLE_ARG_FILES, \
+    MAIN_CLASS := jdk.incubator.jextract.tool.Main, \
+))
+
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/Utils.java
@@ -45,10 +45,11 @@
 import java.lang.invoke.MethodHandles;
 import java.lang.constant.Constable;
 import java.lang.reflect.Field;
 import java.lang.invoke.MethodType;
 import java.lang.invoke.VarHandle;
+import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.file.OpenOption;
 import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
diff a/src/jdk.incubator.foreign/share/classes/module-info.java b/src/jdk.incubator.foreign/share/classes/module-info.java
--- a/src/jdk.incubator.foreign/share/classes/module-info.java
+++ b/src/jdk.incubator.foreign/share/classes/module-info.java
@@ -30,6 +30,10 @@
  *
  * @moduleGraph
  */
 module jdk.incubator.foreign {
     exports jdk.incubator.foreign;
+    exports jdk.internal.foreign.abi.aarch64 to jdk.incubator.jextract;
+    exports jdk.internal.foreign.abi.x64.sysv to jdk.incubator.jextract;
+    exports jdk.internal.foreign.abi.x64.windows to jdk.incubator.jextract;
+    exports jdk.internal.foreign to jdk.incubator.jextract;
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Declaration.java
@@ -0,0 +1,525 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.jextract;
+
+import java.lang.constant.Constable;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.internal.jextract.impl.DeclarationImpl;
+
+/**
+ * Instances of this class are used to model declaration elements in the foreign language.
+ * All declarations have a position (see {@link Position}) and a name. Instances of this class
+ * support the <em>visitor</em> pattern (see {@link Declaration#accept(Visitor, Object)} and
+ * {@link Visitor}).
+ */
+public interface Declaration {
+
+    /**
+     * The position associated with this declaration.
+     * @return The position associated with this declaration.
+     */
+    Position pos();
+
+    /**
+     * The name associated with this declaration.
+     * @return The name associated with this declaration.
+     */
+    String name();
+
+    /**
+     * Get a declaration with specified attribute.
+     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute
+     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become
+     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.
+     * @param name The attribute name
+     * @param values More attribute values
+     * @return the Declaration with attributes
+     */
+    Declaration withAttribute(String name, Constable... values);
+
+    /**
+     * Get a declaration without current attributes
+     * @return the Declatation without any attributes
+     */
+    Declaration stripAttributes();
+
+    /**
+     * The values of the specified attribute.
+     * @param name The attribute to retrieve
+     * @return The list of values associate with this attribute
+     */
+    Optional<List<Constable>> getAttribute(String name);
+
+    /**
+     * The attributes associated with this declaration
+     * @return The attributes associated with this declaration
+     */
+    Set<String> attributeNames();
+
+    /**
+     * Entry point for visiting declaration instances.
+     * @param visitor the declaration visitor.
+     * @param data optional data to be passed to the visitor.
+     * @param <R> the visitor's return type.
+     * @param <D> the visitor's argument type.
+     * @return the result of visiting this declaration through the specified declaration visitor.
+     */
+    <R,D> R accept(Visitor<R, D> visitor, D data);
+
+    /**
+     * Compares the specified object with this Declaration for equality.  Returns
+     * {@code true} if and only if the specified object is also a Declaration and both
+     * the declarations are <i>equal</i>.
+     *
+     * @param o the object to be compared for equality with this Declaration
+     * @return {@code true} if the specified object is equal to this Declaration
+     */
+    boolean equals(Object o);
+
+    /**
+     * Returns the hash code value for this Declaration.
+     *
+     * @return the hash code value for this Declaration.
+     */
+    int hashCode();
+
+    /**
+     * A function declaration.
+     */
+    interface Function extends Declaration {
+        /**
+         * The parameters associated with this function declaration.
+         * @return The parameters associated with this function declaration.
+         */
+        List<Variable> parameters();
+
+        /**
+         * The foreign type associated with this function declaration.
+         * @return The foreign type associated with this function declaration.
+         */
+        Type.Function type();
+    }
+
+    /**
+     * A scoped declaration is a container for one or more nested declarations. This declaration can be used to model
+     * several constructs in the foreign languages, such as (but not limited to) structs, unions and structs (see also
+     * {@link Scoped.Kind}).
+     */
+    interface Scoped extends Declaration {
+
+        /**
+         * The scoped declaration kind.
+         */
+        enum Kind {
+            /**
+             * Namespace declaration.
+             */
+            NAMESPACE,
+            /**
+             * Class declaration.
+             */
+            CLASS,
+            /**
+             * Enum declaration.
+             */
+            ENUM,
+            /**
+             * Struct declaration.
+             */
+            STRUCT,
+            /**
+             * Union declaration.
+             */
+            UNION,
+            /**
+             * Bitfields declaration.
+             */
+            BITFIELDS,
+            /**
+             * Type definition declaration.
+             */
+            TYPEDEF,
+            /**
+             * Toplevel declaration.
+             */
+            TOPLEVEL;
+        }
+
+        /**
+         * The member declarations associated with this scoped declaration.
+         * @return The member declarations associated with this scoped declaration.
+         */
+        List<Declaration> members();
+
+        /**
+         * The (optional) layout associated with this scoped declaration.
+         * @return The (optional) layout associated with this scoped declaration.
+         *
+         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},
+         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and</em> if this declaration models an entity in the foreign
+         * language that is associated with a <em>definition</em>.
+         */
+        Optional<MemoryLayout> layout();
+
+        /**
+         * The scoped declaration kind.
+         * @return The scoped declaration kind.
+         */
+        Kind kind();
+    }
+
+    /**
+     * A variable declaration.
+     */
+    interface Variable extends Declaration {
+        /**
+         * The variable declaration kind.
+         */
+        enum Kind {
+            /**
+             * Global variable declaration.
+             */
+            GLOBAL,
+            /**
+             * Field declaration.
+             */
+            FIELD,
+            /**
+             * Bitfield declaration.
+             */
+            BITFIELD,
+            /**
+             * Function parameter declaration.
+             */
+            PARAMETER;
+        }
+
+        /**
+         * The type associated with this variable declaration.
+         * @return The type associated with this variable declaration.
+         */
+        Type type();
+
+        /**
+         * The optional layout associated with this variable declaration.
+         * @return The optional layout associated with this variable declaration.
+         */
+        Optional<MemoryLayout> layout();
+
+        /**
+         * The kind associated with this variable declaration.
+         * @return The kind associated with this variable declaration.
+         */
+        Kind kind();
+    }
+
+    /**
+     * A constant value declaration.
+     */
+    interface Constant extends Declaration {
+        /**
+         * The value associated with this constant declaration.
+         * @return The value associated with this constant declaration.
+         */
+        Object value();
+
+        /**
+         * The type associated with this constant declaration.
+         * @return The type associated with this constant declaration.
+         */
+        Type type();
+    }
+
+    /**
+     * Declaration visitor interface.
+     * @param <R> the visitor's return type.
+     * @param <P> the visitor's parameter type.
+     */
+    interface Visitor<R,P> {
+        /**
+         * Visit a scoped declaration.
+         * @param d the scoped declaration.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given scoped declaration through this visitor object.
+         */
+        default R visitScoped(Scoped d, P p) { return visitDeclaration(d, p); }
+
+        /**
+         * Visit a function declaration.
+         * @param d the function declaration.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given function declaration through this visitor object.
+         */
+        default R visitFunction(Function d, P p) { return visitDeclaration(d, p); }
+
+        /**
+         * Visit a variable declaration.
+         * @param d the variable declaration.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given variable declaration through this visitor object.
+         */
+        default R visitVariable(Variable d, P p) { return visitDeclaration(d, p); }
+
+        /**
+         * Visit a constant declaration.
+         * @param d the constant declaration.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given constant declaration through this visitor object.
+         */
+        default R visitConstant(Constant d, P p) { return visitDeclaration(d, p); }
+
+        /**
+         * Visit a declaration.
+         * @param d the declaration.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given declaration through this visitor object.
+         */
+        default R visitDeclaration(Declaration d, P p) { throw new UnsupportedOperationException(); }
+    }
+
+    /**
+     * Creates a new constant declaration with given name and type.
+     * @param pos the constant declaration position.
+     * @param name the constant declaration name.
+     * @param value the constant declaration value.
+     * @param type the constant declaration type.
+     * @return a new constant declaration with given name and type.
+     */
+    static Declaration.Constant constant(Position pos, String name, Object value, Type type) {
+        return new DeclarationImpl.ConstantImpl(type, value, name, pos);
+    }
+
+    /**
+     * Creates a new global variable declaration with given name and type.
+     * @param pos the global variable declaration position.
+     * @param name the global variable declaration name.
+     * @param type the global variable declaration type.
+     * @return a new global variable declaration with given name and type.
+     */
+    static Declaration.Variable globalVariable(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos);
+    }
+
+    /**
+     * Creates a new field declaration with given name and type.
+     * @param pos the field declaration position.
+     * @param name the field declaration name.
+     * @param type the field declaration type.
+     * @return a new field declaration with given name and type.
+     */
+    static Declaration.Variable field(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos);
+    }
+
+    /**
+     * Creates a new bitfield declaration with given name, type and layout.
+     * @param pos the bitfield declaration position.
+     * @param name the bitfield declaration name.
+     * @param type the bitfield declaration type.
+     * @param layout the bitfield declaration layout.
+     * @return a new bitfield declaration with given name, type and layout.
+     */
+    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {
+        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);
+    }
+
+    /**
+     * Creates a new parameter declaration with given name and type.
+     * @param pos the parameter declaration position.
+     * @param name the parameter declaration name.
+     * @param type the parameter declaration type.
+     * @return a new parameter declaration with given name and type.
+     */
+    static Declaration.Variable parameter(Position pos, String name, Type type) {
+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos);
+    }
+
+    /**
+     * Creates a new toplevel declaration with given member declarations.
+     * @param pos the toplevel declaration position.
+     * @param decls the toplevel declaration member declarations.
+     * @return a new toplevel declaration with given member declarations.
+     */
+    static Declaration.Scoped toplevel(Position pos, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.TOPLEVEL, declList, "<toplevel>", pos);
+    }
+
+    /**
+     * Creates a new namespace declaration with given name and member declarations.
+     * @param pos the namespace declaration position.
+     * @param name the namespace declaration name.
+     * @param decls the namespace declaration member declarations.
+     * @return a new namespace declaration with given name and member declarations.
+     */
+    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);
+    }
+
+    /**
+     * Creates a new bitfields group declaration with given name and layout.
+     * @param pos the bitfields group declaration position.
+     * @param name the bitfields group declaration name.
+     * @param layout the bitfields group declaration layout.
+     * @param bitfields the bitfields group member declarations.
+     * @return a new bitfields group declaration with given name and layout.
+     */
+    static Declaration.Scoped bitfields(Position pos, String name, MemoryLayout layout, Declaration.Variable... bitfields) {
+        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, name, pos);
+    }
+
+    /**
+     * Creates a new struct declaration with given name and member declarations.
+     * @param pos the struct declaration position.
+     * @param name the struct declaration name.
+     * @param decls the struct declaration member declarations.
+     * @return a new struct declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped struct(Position pos, String name, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, declList, name, pos);
+    }
+
+    /**
+     * Creates a new struct declaration with given name, layout and member declarations.
+     * @param pos the struct declaration position.
+     * @param name the struct declaration name.
+     * @param layout the struct declaration layout.
+     * @param decls the struct declaration member declarations.
+     * @return a new struct declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);
+    }
+
+    /**
+     * Creates a new union declaration with given name and member declarations.
+     * @param pos the union declaration position.
+     * @param name the union declaration name.
+     * @param decls the union declaration member declarations.
+     * @return a new union declaration with given name and member declarations.
+     */
+    static Declaration.Scoped union(Position pos, String name, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Scoped.Kind.UNION, declList, name, pos);
+    }
+
+    /**
+     * Creates a new union declaration with given name, layout and member declarations.
+     * @param pos the union declaration position.
+     * @param name the union declaration name.
+     * @param layout the union declaration layout.
+     * @param decls the union declaration member declarations.
+     * @return a new union declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);
+    }
+
+    /**
+     * Creates a new class declaration with given name and member declarations.
+     * @param pos the class declaration position.
+     * @param name the class declaration name.
+     * @param decls the class declaration member declarations.
+     * @return a new class declaration with given name and member declarations.
+     */
+    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);
+    }
+
+    /**
+     * Creates a new class declaration with given name, layout and member declarations.
+     * @param pos the class declaration position.
+     * @param name the class declaration name.
+     * @param layout the class declaration layout.
+     * @param decls the class declaration member declarations.
+     * @return a new class declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);
+    }
+
+    /**
+     * Creates a new enum declaration with given name and member declarations.
+     * @param pos the enum declaration position.
+     * @param name the enum declaration name.
+     * @param decls the enum declaration member declarations.
+     * @return a new enum declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped enum_(Position pos, String name, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, declList, name, pos);
+    }
+
+    /**
+     * Creates a new enum declaration with given name, layout and member declarations.
+     * @param pos the enum declaration position.
+     * @param name the enum declaration name.
+     * @param layout the enum declaration layout.
+     * @param decls the enum declaration member declarations.
+     * @return a new enum declaration with given name, layout and member declarations.
+     */
+    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {
+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());
+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);
+    }
+
+    /**
+     * Creates a new function declaration with given name, type and parameter declarations.
+     * @param pos the function declaration position.
+     * @param name the function declaration name.
+     * @param type the function declaration type.
+     * @param params the function declaration parameter declarations.
+     * @return a new function declaration with given name, type and parameter declarations.
+     */
+    static Declaration.Function function(Position pos, String name, Type.Function type, Declaration.Variable... params) {
+        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());
+        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos);
+    }
+
+    /**
+     * Creates a new typedef declaration with given name and declared type.
+     * @param pos the typedef declaration position.
+     * @param name the typedef declaration name.
+     * @param decl the typedef declared type
+     * @return a new typedef declaration with given name and declared type.
+     */
+    static Declaration.Scoped typedef(Position pos, String name, Declaration decl) {
+        return new DeclarationImpl.ScopedImpl(Scoped.Kind.TYPEDEF, List.of(decl), name, pos);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/JextractTask.java
@@ -0,0 +1,95 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.jextract;
+
+import jdk.internal.jextract.impl.JextractTaskImpl;
+
+import javax.tools.JavaFileObject;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.util.Optional;
+
+/**
+ * This interface models a so called <em>extraction</em> task which aims at generating a suitable Java API from a foreign
+ * library. A new extraction task is obtained using the {@link #newTask(boolean, Path...)} factory. Once an extraction
+ * task has been obtained, the source files of the foreign library can be parsed into a toplevel foreign
+ * declaration (see {@link Declaration}). After parsing, a client can define one or more processing steps
+ * (typically by using type and declaration visitors, see {@link Type.Visitor} and {@link Declaration.Visitor}.
+ * Once processing is complete, the client should generate a list of {@link JavaFileObject} which embody the result
+ * of the API extraction process; such files can be written onto a given destination path using the extraction
+ * task (see {@link #write(Path, JavaFileObject...)}).
+ */
+public interface JextractTask {
+
+    /**
+     * Creates a new extraction task with given input files.
+     * @param compileSources true, if the task should result in the compilation of the generated {@link JavaFileObject}
+     *                       whose kind is set to {@link JavaFileObject.Kind#SOURCE}.
+     * @param inputFiles the input files of the extraction task.
+     * @return a new extraction task with given input files.
+     */
+    static JextractTask newTask(boolean compileSources, Path... inputFiles) {
+        return new JextractTaskImpl(compileSources, inputFiles);
+    }
+
+    /**
+     * A constant parser is an helper object that is used to parse constant values in a foreign language,
+     * and create a corresponding declaration constant, if possible.
+     */
+    interface ConstantParser {
+        /**
+         * Parses a constant at given position, with given name and list of tokens.
+         * @param pos the constant position.
+         * @param name the constant name.
+         * @param tokens the constant tokens.
+         * @return a constant declaration which embeds the parsed constant value, if possible.
+         */
+        Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens);
+    }
+
+    /**
+     * Parse input files into a toplevel declaration with given options.
+     * @param parserOptions options to be passed to the parser.
+     * @return a toplevel declaration.
+     */
+    Declaration.Scoped parse(String... parserOptions);
+
+    /**
+     * Parse input files into a toplevel declaration with given constant parser and options.
+     * @param constantParser the constant parser to evaluate constants.
+     * @param parserOptions options to be passed to the parser.
+     * @return a toplevel declaration.
+     */
+    Declaration.Scoped parse(ConstantParser constantParser, String... parserOptions);
+
+    /**
+     * Write resulting {@link JavaFileObject} instances into specified destination path.
+     * @param dest the destination path.
+     * @param files the {@link JavaFileObject} instances to be written.
+     */
+    void write(Path dest, JavaFileObject... files) throws UncheckedIOException;
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java
@@ -0,0 +1,74 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.jextract;
+
+import java.nio.file.Path;
+
+/**
+ * Instances of this class model are used to model source code positions.
+ */
+public interface Position {
+
+    /**
+     * The input file to which this position refers to.
+     * @return The input file to which this position refers to.
+     */
+    Path path();
+
+    /**
+     * The line number associated with this position.
+     * @return The line number associated with this position.
+     */
+    int line();
+
+    /**
+     * The column number associated with this position.
+     * @return The column number associated with this position.
+     */
+    int col();
+
+    /**
+     * An empty position instance; this can be used to model <em>synthetic</em> program elements which are not
+     * defined in any input file.
+     */
+    Position NO_POSITION = new Position() {
+        @Override
+        public Path path() {
+            return null;
+        }
+
+        @Override
+        public int line() {
+            return 0;
+        }
+
+        @Override
+        public int col() {
+            return 0;
+        }
+    };
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Type.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Type.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Type.java
@@ -0,0 +1,503 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.incubator.jextract;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.internal.jextract.impl.LayoutUtils;
+import jdk.internal.jextract.impl.TypeImpl;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.OptionalLong;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Instances of this class are used to model types in the foreign language.
+ * Instances of this class support the <em>visitor</em> pattern (see {@link Type#accept(Type.Visitor, Object)} and
+ * {@link Type.Visitor}).
+ */
+public interface Type {
+
+    /**
+     * Is this type the erroneous type?
+     * @return true, if this type is the erroneous type.
+     */
+    boolean isErroneous();
+
+    /**
+     * Entry point for visiting type instances.
+     * @param visitor the type visitor.
+     * @param data optional data to be passed to the visitor.
+     * @param <R> the visitor's return type.
+     * @param <D> the visitor's argument type.
+     * @return the result of visiting this type through the specified type visitor.
+     */
+    <R,D> R accept(Visitor<R, D> visitor, D data);
+
+    /**
+     * Compares the specified object with this Type for equality.  Returns
+     * {@code true} if and only if the specified object is also a Type and both
+     * the Types are <i>equal</i>.
+     *
+     * @param o the object to be compared for equality with this Type
+     * @return {@code true} if the specified object is equal to this Type
+     */
+    boolean equals(Object o);
+
+    /**
+     * Returns the hash code value for this Type.
+     *
+     * @return the hash code value for this Type.
+     */
+    int hashCode();
+
+    /**
+     * A primitive type.
+     */
+    interface Primitive extends Type {
+
+        /**
+         * The primitive type kind.
+         */
+        enum Kind {
+            /**
+             * {@code void} type.
+             */
+            Void,
+            /**
+             * {@code Bool} type.
+             */
+            Bool,
+            /**
+             * {@code char} type.
+             */
+            Char,
+            /**
+             * {@code char16} type.
+             */
+            Char16,
+            /**
+             * {@code char32} type.
+             */
+            Char32,
+            /**
+             * {@code short} type.
+             */
+            Short,
+            /**
+             * {@code int} type.
+             */
+            Int,
+            /**
+             * {@code long} type.
+             */
+            Long,
+            /**
+             * {@code long long} type.
+             */
+            LongLong,
+            /**
+             * {@code int128} type.
+             */
+            Int128,
+            /**
+             * {@code float} type.
+             */
+            Float,
+            /**
+             * {@code double} type.
+             */
+            Double,
+            /**
+             * {@code long double} type.
+             */
+            LongDouble,
+            /**
+             * {@code float128} type.
+             */
+            Float128,
+            /**
+             * {@code float16} type.
+             */
+            HalfFloat,
+            /**
+             * {@code wchar} type.
+             */
+            WChar
+        }
+
+        /**
+         * The primitive type kind.
+         * @return The primitive type kind.
+         */
+        Kind kind();
+
+        /**
+         * The primitive type (optional) layout.
+         * @return The primitive type (optional) layout.
+         */
+        Optional<MemoryLayout> layout();
+    }
+
+    /**
+     * Instances of this class are used to model types which are associated to a declaration in the foreign language
+     * (see {@link Declaration}).
+     */
+    interface Declared extends Type {
+        /**
+         * The declaration to this type refers to.
+         * @return The declaration to this type refers to.
+         */
+        Declaration.Scoped tree();
+    }
+
+    /**
+     * A function type.
+     */
+    interface Function extends Type {
+        /**
+         * Is this function type a variable-arity?
+         * @return true, if this function type is a variable-arity.
+         */
+        boolean varargs();
+
+        /**
+         * The function formal parameter types.
+         * @return The function formal parameter types.
+         */
+        List<Type> argumentTypes();
+
+        /**
+         * The function return type.
+         * @return The function return type.
+         */
+        Type returnType();
+    }
+
+    /**
+     * An array type. Array types feature an element type and an optional size. As such they can also be used to
+     * model array types.
+     */
+    interface Array extends Type {
+
+        /**
+         * The array type kind.
+         */
+        enum Kind {
+            /**
+             * Vector kind.
+             */
+            VECTOR,
+            /**
+             * Array kind.
+             */
+            ARRAY,
+            /**
+             * Incomplete array kind.
+             */
+            INCOMPLETE_ARRAY;
+        }
+
+        /**
+         * The array type kind.
+         * @return The array type kind.
+         */
+        Kind kind();
+
+        /**
+         * The (optional) array element count.
+         * @return The (optional) array element count.
+         *
+         * @implSpec an element count is present if the array type kind is one of {@link Kind#VECTOR}, {@link Kind#ARRAY}.
+         */
+        OptionalLong elementCount();
+
+        /**
+         * The array type element type.
+         * @return The array type element type.
+         */
+        Type elementType();
+    }
+
+    /**
+     * A delegated type is used to model a type which contains an indirection to some other underlying type. For instance,
+     * a delegated type can be used to model foreign pointers, where the indirection is used to model the pointee type.
+     */
+    interface Delegated extends Type {
+
+        /**
+         * The delegated type kind.
+         */
+        enum Kind {
+            /**
+             * Type-defined type.
+             */
+            TYPEDEF,
+            /**
+             * Pointer type.
+             */
+            POINTER,
+            /**
+             * Signed type.
+             */
+            SIGNED,
+            /**
+             * Unsigned type.
+             */
+            UNSIGNED,
+            /**
+             * Atomic type.
+             */
+            ATOMIC,
+            /**
+             * Volatile type.
+             */
+            VOLATILE,
+            /**
+             * Complex type.
+             */
+            COMPLEX;
+        }
+
+        /**
+         * The delegated type kind.
+         * @return The delegated type kind.
+         */
+        Kind kind();
+
+        /**
+         * The delegated type (optional) name.
+         * @return The delegated type (optional) name.
+         *
+         * @implSpec an element count is present if the array type kind is one of {@link Kind#TYPEDEF}.
+         */
+        Optional<String> name();
+
+        /**
+         * The delegated type underlying type.
+         * @return The delegated type underlying type.
+         */
+        Type type();
+    }
+
+    /**
+     * Type visitor interface.
+     * @param <R> the visitor's return type.
+     * @param <P> the visitor's parameter type.
+     */
+    interface Visitor<R,P> {
+        /**
+         * Visit a primitive type.
+         * @param t the primitive type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given primitive type through this visitor object.
+         */
+        default R visitPrimitive(Primitive t, P p) { return visitType(t, p); }
+
+        /**
+         * Visit a function type.
+         * @param t the function type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given function type through this visitor object.
+         */
+        default R visitFunction(Function t, P p) { return visitType(t, p); }
+
+        /**
+         * Visit a declared type.
+         * @param t the declared type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given declared type through this visitor object.
+         */
+        default R visitDeclared(Declared t, P p) { return visitType(t, p); }
+
+        /**
+         * Visit a delegated type.
+         * @param t the delegated type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given delegated type through this visitor object.
+         */
+        default R visitDelegated(Delegated t, P p) { return visitType(t, p); }
+
+        /**
+         * Visit an array type.
+         * @param t the array type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given array type through this visitor object.
+         */
+        default R visitArray(Array t, P p) { return visitType(t, p); }
+
+        /**
+         * Visit a type.
+         * @param t the type.
+         * @param p the visitor parameter.
+         * @return the result of visiting the given type through this visitor object.
+         */
+        default R visitType(Type t, P p) { throw new UnsupportedOperationException(); }
+    }
+
+    /**
+     * Compute the layout for a given type.
+     * @param t the type.
+     * @return the layout for given type.
+     */
+    static Optional<MemoryLayout> layoutFor(Type t) {
+        return LayoutUtils.getLayout(t);
+    }
+
+    /**
+     * Compute the function descriptor for a given function type.
+     * @param function the function type.
+     * @return the function descriptor for given function type.
+     */
+    static Optional<FunctionDescriptor> descriptorFor(Function function) {
+        return LayoutUtils.getDescriptor(function);
+    }
+
+    /**
+     * Create the {@code void} type.
+     * @return the {@code void} type.
+     */
+    static Type.Primitive void_() {
+        return new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void);
+    }
+
+    /**
+     * Creates a new primitive type given kind and layout.
+     * @param kind the primitive type kind.
+     * @param layout the primitive type layout.
+     * @return a new primitive type with given kind and layout.
+     */
+    static Type.Primitive primitive(Type.Primitive.Kind kind, MemoryLayout layout) {
+        return new TypeImpl.PrimitiveImpl(kind, layout);
+    }
+
+    /**
+     * Creates a new qualified type given kind and underlying type.
+     * @param kind the qualified type kind.
+     * @param type the qualified type underlying type.
+     * @return a new qualified type with given name and underlying type.
+     */
+    static Type.Delegated qualified(Type.Delegated.Kind kind, Type type) {
+        return new TypeImpl.QualifiedImpl(kind, type);
+    }
+
+    /**
+     * Creates a new typedef type given name and underlying type.
+     * @param name the typedef type name.
+     * @param aliased the typeef type underlying type.
+     * @return a new typedef type with given name and underlying type.
+     */
+    static Type.Delegated typedef(String name, Type aliased) {
+        return new TypeImpl.QualifiedImpl(Delegated.Kind.TYPEDEF, name, aliased);
+    }
+
+    /**
+     * Creates a new pointer type with no associated pointee information.
+     * @return a new pointer type with no associated pointee information.
+     */
+    static Type.Delegated pointer() {
+        return new TypeImpl.PointerImpl(() -> new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void));
+    }
+
+    /**
+     * Creates a new pointer type with given pointee type.
+     * @param pointee the pointee type.
+     * @return a new pointer type with given pointee type.
+     */
+    static Type.Delegated pointer(Type pointee) {
+        return new TypeImpl.PointerImpl(() -> pointee);
+    }
+
+    /**
+     * Creates a new pointer type with given pointee type.
+     * @param pointee factory to (lazily) build the pointee type.
+     * @return a new pointer type with given pointee type (lazily built from factory).
+     */
+    static Type.Delegated pointer(Supplier<Type> pointee) {
+        return new TypeImpl.PointerImpl(pointee);
+    }
+
+    /**
+     * Creates a new function type with given parameter types and return type.
+     * @param varargs is this function type variable-arity?
+     * @param returnType the function type return type.
+     * @param arguments the function type formal parameter types.
+     * @return a new function type with given parameter types and return type.
+     */
+    static Type.Function function(boolean varargs, Type returnType, Type... arguments) {
+        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType);
+    }
+
+    /**
+     * Creates a new declared type with given foreign declaration.
+     * @param tree the foreign declaration the type refers to.
+     * @return  a new declared type with given foreign declaration.
+     */
+    static Type.Declared declared(Declaration.Scoped tree) {
+        return new TypeImpl.DeclaredImpl(tree);
+    }
+
+    /**
+     * Creates a new vector type with given element count and element type.
+     * @param elementCount the vector type element count.
+     * @param elementType the vector type element type.
+     * @return a new vector type with given element count and element type.
+     */
+    static Type.Array vector(long elementCount, Type elementType) {
+        return new TypeImpl.ArrayImpl(Array.Kind.VECTOR, elementCount, elementType);
+    }
+
+    /**
+     * Creates a new array type with given element count and element type.
+     * @param elementCount the array type element count.
+     * @param elementType the array type element type.
+     * @return a new array type with given element count and element type.
+     */
+    static Type.Array array(long elementCount, Type elementType) {
+        return new TypeImpl.ArrayImpl(Array.Kind.ARRAY, elementCount, elementType);
+    }
+
+    /**
+     * Creates a new array type with given element type.
+     * @param elementType the array type element type.
+     * @return a new array type with given element type.
+     */
+    static Type.Array array(Type elementType) {
+        return new TypeImpl.ArrayImpl(Array.Kind.INCOMPLETE_ARRAY, elementType);
+    }
+
+    /**
+     * Creates an erroneous type.
+     * @return an erroneous type.
+     */
+    static Type error() {
+        return TypeImpl.ERROR;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Filter.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+
+public class Filter {
+
+    public static Declaration.Scoped filter(Declaration.Scoped decl, String... validNames) {
+        Declaration[] newMembers = decl.members().stream()
+                .filter(d -> filterDecl(d, validNames))
+                .toArray(Declaration[]::new);
+        return Declaration.toplevel(decl.pos(), newMembers);
+    }
+
+    static boolean filterDecl(Declaration d, String... validNames) {
+        if (d.pos() == Position.NO_POSITION) {
+            return false;
+        } else {
+            for (String s : validNames) {
+                String pathName = d.pos().path().toString();
+                if (pathName.contains(s)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/FunctionalInterfaceScanner.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/FunctionalInterfaceScanner.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/FunctionalInterfaceScanner.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.foreign.FunctionDescriptor;
+
+import java.util.Optional;
+import java.util.Set;
+
+public class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {
+    
+    private final Set<FunctionDescriptor> descriptors;
+
+    public FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {
+        this.descriptors = descriptors;
+    }
+
+    public Declaration.Scoped scan(Declaration.Scoped decl) {
+        decl.accept(this, descriptors);
+        return decl;
+    }
+
+    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {
+        t.accept(new TypeScanner(), functionDescriptors);
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {
+        d.members().forEach(m -> m.accept(this, functionDescriptors));
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type().returnType(), functionDescriptors);
+        d.parameters().forEach(p -> p.accept(this, functionDescriptors));
+        return null;
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type(), functionDescriptors);
+        return null;
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {
+        scanType(d.type(), functionDescriptors);
+        return null;
+    }
+
+    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {
+
+        @Override
+        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {
+            return null;
+        }
+
+        @Override
+        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {
+            return t.type().accept(this, functionDescriptors);
+        }
+
+        @Override
+        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {
+            t.returnType().accept(this, functionDescriptors);
+            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));
+            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);
+            if (descriptor.isPresent()) {
+                functionDescriptors.add(descriptor.get());
+            }
+            return null;
+        }
+
+        @Override
+        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {
+            return null;
+        }
+
+        @Override
+        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {
+            return t.elementType().accept(this, functionDescriptors);
+        }
+
+        @Override
+        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/HandleSourceFactory.java
@@ -0,0 +1,310 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.InternalForeign;
+
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.lang.invoke.MethodType;
+import java.net.URI;
+import java.net.URL;
+import java.net.URISyntaxException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/*
+ * Scan a header file and generate Java source items for entities defined in that header
+ * file. Tree visitor visit methods return true/false depending on whether a
+ * particular Tree is processed or skipped.
+ */
+public class HandleSourceFactory implements Declaration.Visitor<Void, Declaration> {
+    private final Set<String> constants = new HashSet<>();
+    // To detect duplicate Variable and Function declarations.
+    private final Set<Declaration.Variable> variables = new HashSet<>();
+    private final Set<Declaration.Function> functions = new HashSet<>();
+
+    private final Set<String> structsAndVars = new HashSet<>();
+    private final Map<String, String> mangledNames = new HashMap<>();
+
+    protected final JavaSourceBuilder builder = new JavaSourceBuilder();
+    protected final TypeTranslator typeTranslator = new TypeTranslator();
+    private final List<String> libraryNames;
+    private final String clsName;
+    private final String pkgName;
+
+    // have we visited this Variable earlier?
+    protected boolean visitedVariable(Declaration.Variable tree) {
+        return !variables.add(tree);
+    }
+
+    // have we visited this Function earlier?
+    protected boolean visitedFunction(Declaration.Function tree) {
+        return !functions.add(tree);
+    }
+
+    // have we visited a struct/union or a global variable of given name?
+    protected boolean visitedStructOrVariable(String name) {
+        return !structsAndVars.add(name);
+    }
+
+    private void setMangledName(String name, String prefix) {
+        if (!name.isEmpty() && visitedStructOrVariable(name)) {
+            mangledNames.put(name, prefix + name);
+        }
+    }
+
+    protected void setMangledName(Declaration.Scoped d) {
+        switch (d.kind()) {
+            case STRUCT:
+                setMangledName(d.name(), "struct$");
+                break;
+            case UNION:
+                setMangledName(d.name(), "union$");
+                break;
+        }
+    }
+
+    protected void setMangledName(Declaration.Variable v) {
+        setMangledName(v.name(), "var$");
+    }
+
+    protected String getMangledName(Declaration d) {
+        String name = d.name();
+        return name.isEmpty()? name : mangledNames.getOrDefault(name, name);
+    }
+
+    static JavaFileObject[] generateRaw(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
+        return new HandleSourceFactory(clsName, pkgName, libraryNames).generate(decl);
+    }
+
+    static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String clsName, String pkgName, List<String> libraryNames) {
+        return new StaticWrapperSourceFactory(clsName, pkgName, libraryNames).generate(decl);
+    }
+
+    public HandleSourceFactory(String clsName, String pkgName, List<String> libraryNames) {
+        this.libraryNames = libraryNames;
+        this.clsName = clsName;
+        this.pkgName = pkgName;
+    }
+
+    private static String getCLangConstantsHolder() {
+        String prefix = "jdk.incubator.foreign.MemoryLayouts.";
+        String abi = InternalForeign.getInstancePrivileged().getSystemABI().name();
+        switch (abi) {
+            case SystemABI.ABI_SYSV:
+                return prefix + "SysV";
+            case SystemABI.ABI_WINDOWS:
+                return prefix + "WinABI";
+            case SystemABI.ABI_AARCH64:
+                return prefix + "AArch64ABI";
+            default:
+                throw new UnsupportedOperationException("Unsupported ABI: " + abi);
+        }
+    }
+
+    static final String C_LANG_CONSTANTS_HOLDER = getCLangConstantsHolder();
+
+    public JavaFileObject[] generate(Declaration.Scoped decl) {
+        builder.addPackagePrefix(pkgName);
+        builder.classBegin(clsName);
+        builder.addLibraries(libraryNames.toArray(new String[0]));
+        //generate all decls
+        decl.members().forEach(this::generateDecl);
+
+        //generate functional interfaces
+        generateFunctionalInterfaces(decl);
+
+        builder.classEnd();
+        String src = builder.build();
+
+        URL runtimeHelper = HandleSourceFactory.class.getResource("resources/RuntimeHelper.template");
+
+        try {
+            return new JavaFileObject[] {
+                    fileFromString(pkgName, clsName, src),
+                    fileFromString(pkgName,"RuntimeHelper", (pkgName.isEmpty()? "" : "package " + pkgName + ";\n") +
+                            Files.readAllLines(Paths.get(runtimeHelper.toURI()))
+                            .stream().collect(Collectors.joining("\n")).replace("${C_LANG}", C_LANG_CONSTANTS_HOLDER))
+            };
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        } catch (URISyntaxException ex2) {
+            throw new RuntimeException(ex2);
+        }
+    }
+
+    protected void generateFunctionalInterfaces(Declaration.Scoped decl) {
+        //generate functional interfaces
+        Set<FunctionDescriptor> functionalInterfaces = new HashSet<>();
+        new FunctionalInterfaceScanner(functionalInterfaces).scan(decl);
+        functionalInterfaces.forEach(builder::addUpcallFactory);
+    }
+
+    private void generateDecl(Declaration tree) {
+        try {
+            tree.accept(this, null);
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    private JavaFileObject fileFromString(String pkgName, String clsName, String contents) {
+        String pkgPrefix = pkgName.isEmpty() ? "" : pkgName.replaceAll("\\.", "/") + "/";
+        return new SimpleJavaFileObject(URI.create(pkgPrefix + clsName + ".java"), JavaFileObject.Kind.SOURCE) {
+            @Override
+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
+                return contents;
+            }
+        };
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && visitedVariable(tree)) {
+            return null;
+        }
+
+        String fieldName = tree.name();
+        String symbol = tree.name();
+        assert !symbol.isEmpty();
+        assert !fieldName.isEmpty();
+
+        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
+        if (parent == null) {
+            setMangledName(tree);
+            fieldName = getMangledName(tree);
+        }
+
+        Type type = tree.type();
+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
+        if (layout == null) {
+            //no layout - abort
+            return null;
+        }
+        Class<?> clazz = typeTranslator.getJavaType(type);
+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD || clazz == MemoryAddress.class ||
+                clazz == MemorySegment.class || layout.byteSize() > 8) {
+            //skip
+            return null;
+        }
+
+        if (parent != null) {
+            //struct field
+            builder.addVarHandle(fieldName, clazz, getMangledName(parent));
+        } else {
+            builder.addLayout(fieldName, layout);
+            builder.addVarHandle(fieldName, clazz, null);
+            builder.addAddress(fieldName);
+        }
+
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (visitedFunction(funcTree)) {
+            return null;
+        }
+
+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
+        if (descriptor == null) {
+            //abort
+        }
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
+        builder.addMethodHandle(funcTree, mtype, descriptor);
+        return null;
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {
+        if (!constants.add(constant.name())) {
+            //skip
+            return null;
+        }
+
+        builder.addConstant(constant.name(), typeTranslator.getJavaType(constant.type()), constant.value());
+        return null;
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {
+        if (d.kind() == Declaration.Scoped.Kind.TYPEDEF) {
+            return d.members().get(0).accept(this, d);
+        }
+        if (d.layout().isEmpty()) {
+            //skip decl-only
+            return null;
+        }
+        String name = d.name();
+        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
+        if (d.name().isEmpty() && parent != null) {
+            name = getMangledName(parent);
+        } else {
+            setMangledName(d);
+            name = getMangledName(d);
+        }
+        if (!d.name().isEmpty() || !isRecord(parent)) {
+            //only add explicit struct layout if the struct is not to be flattened inside another struct
+            switch (d.kind()) {
+                case STRUCT:
+                case UNION: {
+                    builder.addLayout(name, d.layout().get());
+                    break;
+                }
+            }
+        }
+        d.members().forEach(fieldTree -> fieldTree.accept(this, d.name().isEmpty() ? parent : d));
+        return null;
+    }
+
+    private boolean isRecord(Declaration declaration) {
+        if (declaration == null) {
+            return false;
+        } else if (!(declaration instanceof Declaration.Scoped)) {
+            return false;
+        } else {
+            Declaration.Scoped scope = (Declaration.Scoped)declaration;
+            return scope.kind() == Declaration.Scoped.Kind.CLASS ||
+                    scope.kind() == Declaration.Scoped.Kind.STRUCT ||
+                    scope.kind() == Declaration.Scoped.Kind.UNION;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/JavaSourceBuilder.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SequenceLayout;
+import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ValueLayout;
+import jdk.internal.foreign.InternalForeign;
+
+import java.lang.invoke.MethodType;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+import javax.lang.model.SourceVersion;
+
+import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
+
+/**
+ * A helper class to generate header interface class in source form.
+ * After aggregating various constituents of a .java source, build
+ * method is called to get overall generated source string.
+ */
+class JavaSourceBuilder {
+    private static final String ABI = InternalForeign.getInstancePrivileged().getSystemABI().name();
+    // buffer
+    protected StringBuffer sb;
+    // current line alignment (number of 4-spaces)
+    protected int align;
+
+    JavaSourceBuilder(int align) {
+        this.align = align;
+        this.sb = new StringBuffer();
+    }
+
+    JavaSourceBuilder() {
+        this(0);
+    }
+
+    protected int align() {
+        return align;
+    }
+
+    final String PUB_CLS_MODS = "public final ";
+    final String PUB_MODS = "public static final ";
+    final String PRI_MODS = "private static final ";
+
+    protected void addPackagePrefix(String pkgName) {
+        assert pkgName.indexOf('/') == -1 : "package name invalid: " + pkgName;
+        sb.append("// Generated by jextract\n\n");
+        if (!pkgName.isEmpty()) {
+            sb.append("package ");
+            sb.append(pkgName);
+            sb.append(";\n\n");
+        }
+        addImportSection();
+    }
+
+    protected void addImportSection() {
+        sb.append("import java.lang.invoke.MethodHandle;\n");
+        sb.append("import java.lang.invoke.VarHandle;\n");
+        sb.append("import jdk.incubator.foreign.*;\n");
+        sb.append("import jdk.incubator.foreign.MemoryLayout.PathElement;\n");
+        sb.append("import static ");
+        sb.append(HandleSourceFactory.C_LANG_CONSTANTS_HOLDER);
+        sb.append(".*;\n");
+    }
+
+    protected void classBegin(String name) {
+        indent();
+        sb.append(PUB_CLS_MODS + "class ");
+        sb.append(name);
+        sb.append(" {\n\n");
+    }
+
+    protected void classEnd() {
+        indent();
+        sb.append("}\n\n");
+    }
+
+    protected void addLibraries(String[] libraryNames) {
+        incrAlign();
+        indent();
+        sb.append(PRI_MODS + "LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(");
+        sb.append(stringArray(libraryNames) + ");\n");
+        decrAlign();
+    }
+
+    private String stringArray(String[] elements) {
+        return Stream.of(elements)
+                .map(n -> "\"" + n + "\"")
+                .collect(Collectors.joining(",", "new String[] {", "}"));
+    }
+
+    protected void addLayout(String elementName, MemoryLayout layout) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MemoryLayout " + javaSafeIdentifier(elementName) + "$LAYOUT = ");
+        addLayout(layout);
+        sb.append(";\n");
+        decrAlign();
+    }
+
+    private void addLayout(MemoryLayout l) {
+        if (l instanceof ValueLayout) {
+            SystemABI.Type type = l.attribute(NATIVE_TYPE)
+                                   .map(SystemABI.Type.class::cast)
+                                   .orElseThrow(()->new AssertionError("Should not get here: " + l));
+            sb.append(switch (type) {
+                case BOOL -> "C_BOOL";
+                case SIGNED_CHAR -> "C_SCHAR";
+                case UNSIGNED_CHAR -> "C_UCHAR";
+                case CHAR -> "C_CHAR";
+                case SHORT -> "C_SHORT";
+                case UNSIGNED_SHORT -> "C_USHORT";
+                case INT -> "C_INT";
+                case UNSIGNED_INT -> "C_UINT";
+                case LONG -> "C_LONG";
+                case UNSIGNED_LONG -> "C_ULONG";
+                case LONG_LONG -> "C_LONGLONG";
+                case UNSIGNED_LONG_LONG -> "C_ULONGLONG";
+                case FLOAT -> "C_FLOAT";
+                case DOUBLE -> "C_DOUBLE";
+                case LONG_DOUBLE -> "C_LONGDOUBLE";
+                case POINTER -> "C_POINTER";
+                default -> { throw new RuntimeException("should not reach here: " + type); }
+            });
+        } else if (l instanceof SequenceLayout) {
+            sb.append("MemoryLayout.ofSequence(");
+            if (((SequenceLayout) l).elementCount().isPresent()) {
+                sb.append(((SequenceLayout) l).elementCount().getAsLong() + ", ");
+            }
+            addLayout(((SequenceLayout) l).elementLayout());
+            sb.append(")");
+        } else if (l instanceof GroupLayout) {
+            SystemABI.Type type = l.attribute(NATIVE_TYPE)
+                                   .map(SystemABI.Type.class::cast)
+                                   .orElse(null);
+            if (type == SystemABI.Type.COMPLEX_LONG_DOUBLE) {
+                if (!ABI.equals(SystemABI.ABI_SYSV)) {
+                    throw new RuntimeException("complex long double is supported only for SysV ABI");
+                } else {
+                    sb.append("C_COMPLEX_LONGDOUBLE");
+                }
+            } else {
+                if (((GroupLayout) l).isStruct()) {
+                    sb.append("MemoryLayout.ofStruct(\n");
+                } else {
+                    sb.append("MemoryLayout.ofUnion(\n");
+                }
+                incrAlign();
+                String delim = "";
+                for (MemoryLayout e : ((GroupLayout) l).memberLayouts()) {
+                    sb.append(delim);
+                    indent();
+                    addLayout(e);
+                    delim = ",\n";
+                }
+                sb.append("\n");
+                decrAlign();
+                indent();
+                sb.append(")");
+            }
+        } else {
+            //padding
+            sb.append("MemoryLayout.ofPaddingBits(" + l.bitSize() + ")");
+        }
+        if (l.name().isPresent()) {
+            sb.append(".withName(\"" +  l.name().get() + "\")");
+        }
+    }
+
+    protected void addVarHandle(String name, Class<?> type, String parentName) {
+        incrAlign();
+        indent();
+        parentName = parentName != null? javaSafeIdentifier(parentName) : parentName;
+        name = javaSafeIdentifier(name);
+        String vhName = parentName != null ?
+                parentName + "$" + name : name;
+        sb.append(PUB_MODS + "VarHandle " + vhName + " = ");
+        if (parentName != null) {
+            addHandlePath(type, parentName, name);
+        } else {
+            addHandlePath(type, name);
+        }
+        sb.append(";\n");
+        decrAlign();
+    }
+
+    protected void addHandlePath(Class<?> type, String strName, String fieldName) {
+        String ty = type.getName();
+        if (ty.contains("MemoryAddress")) {
+            ty = "long";
+        }
+        sb.append(strName + "$LAYOUT.varHandle(" + ty + ".class, ");
+        sb.append("PathElement.groupElement(\"" + fieldName +"\")");
+        sb.append(")");
+    }
+
+    protected void addHandlePath(Class<?> type, String varName) {
+        String ty = type.getName();
+        if (ty.contains("MemoryAddress")) {
+            ty = "long";
+        }
+        sb.append(varName + "$LAYOUT.varHandle(" + ty + ".class)");
+    }
+
+    protected void addMethodHandle(Declaration.Function funcTree, MethodType mtype, FunctionDescriptor desc) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MethodHandle " + javaSafeIdentifier(funcTree.name()) + " = ");
+        sb.append("RuntimeHelper.downcallHandle(\n");
+        incrAlign();
+        indent();
+        sb.append("LIBRARIES, \"" + funcTree.name() + "\"");
+        sb.append(",\n");
+        indent();
+        sb.append("\"" + mtype.toMethodDescriptorString() + "\",\n");
+        indent();
+        addFunction(desc);
+        sb.append(",\n");
+        indent();
+        sb.append(funcTree.type().varargs());
+        decrAlign();
+        sb.append("\n");
+        indent();
+        sb.append(");\n");
+        decrAlign();
+    }
+
+    protected void addAddressLookup(String name) {
+        sb.append("RuntimeHelper.lookupGlobalVariable(LIBRARIES, \"" + name + "\")");
+    }
+
+    private void addFunction(FunctionDescriptor f) {
+        final boolean noArgs = f.argumentLayouts().isEmpty();
+        if (f.returnLayout().isPresent()) {
+            sb.append("FunctionDescriptor.of(");
+            addLayout(f.returnLayout().get());
+            if (!noArgs) {
+                sb.append(", ");
+            }
+        } else {
+            sb.append("FunctionDescriptor.ofVoid(");
+        }
+        if (!noArgs) {
+            sb.append("\n");
+            incrAlign();
+            String delim = "";
+            for (MemoryLayout e : f.argumentLayouts()) {
+                sb.append(delim);
+                indent();
+                addLayout(e);
+                delim = ",\n";
+            }
+            sb.append("\n");
+            decrAlign();
+            indent();
+        }
+        sb.append(")");
+    }
+
+    protected void addAddress(String name) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress " + javaSafeIdentifier(name) + "$ADDR" + " = ");
+        addAddressLookup(name);
+        sb.append(";\n");
+        decrAlign();
+    }
+
+    protected void addConstant(String name, Class<?> type, Object value) {
+        incrAlign();
+        indent();
+        if (type == MemoryAddress.class || type == MemorySegment.class) {
+            //todo, skip for now (address constants and string constants)
+        } else {
+            sb.append(PUB_MODS + type.getName() + " " + javaSafeIdentifier(name));
+            sb.append(" = ");
+            if (type == float.class) {
+                float f = ((Number)value).floatValue();
+                if (Float.isNaN(f)) {
+                    sb.append("Float.NaN");
+                } else if (Float.isInfinite(f)) {
+                    sb.append(f > 0? "Float.POSITIVE_INFINITY" : "Float.NEGATIVE_INFINITY");
+                } else {
+                    sb.append(value);
+                    sb.append("f");
+                }
+            } else if (type == long.class) {
+                sb.append(value);
+                sb.append("L");
+            } else if (type == double.class) {
+                double d = ((Number)value).doubleValue();
+                if (Double.isNaN(d)) {
+                    sb.append("Double.NaN");
+                } else if (Double.isInfinite(d)) {
+                    sb.append(d > 0? "Double.POSITIVE_INFINITY" : "Double.NEGATIVE_INFINITY");
+                } else {
+                   sb.append(value);
+                   sb.append("d");
+                }
+            } else {
+                sb.append("(" + type.getName() + ")");
+                sb.append(value + "L");
+            }
+            sb.append(";\n");
+        }
+
+        decrAlign();
+    }
+
+    static int funcIntfCounter = 0;
+
+    protected void addUpcallFactory(FunctionDescriptor desc) {
+        String fnName = "FI" + funcIntfCounter++;
+        incrAlign();
+        indent();
+        sb.append(PRI_MODS + "FunctionDescriptor " + fnName + "$DESC = ");
+        addFunction(desc);
+        sb.append(";\n");
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress " + fnName + "$make(MethodHandle handle) {\n");
+        incrAlign();
+        indent();
+        sb.append("return RuntimeHelper.upcallStub(handle, " + fnName + "$DESC);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    protected void addStaticFunctionWrapper(Declaration.Function f, MethodType mtype) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + mtype.returnType().getName() + " " + javaSafeIdentifier(f.name()) + " (");
+        String delim = "";
+        List<String> pNames = new ArrayList<>();
+        final int numParams = f.parameters().size();
+        for (int i = 0 ; i < numParams; i++) {
+            String pName = f.parameters().get(i).name();
+            if (pName.isEmpty()) {
+                pName = "x" + i;
+            }
+            pName = javaSafeIdentifier(pName);
+            pNames.add(pName);
+            sb.append(delim + mtype.parameterType(i).getName() + " " + pName);
+            delim = ", ";
+        }
+        if (f.type().varargs()) {
+            String lastArg = "x" + numParams;
+            if (numParams > 0) {
+                sb.append(", ");
+            }
+            sb.append("Object... " + lastArg);
+            pNames.add(lastArg);
+        }
+        sb.append(") {\n");
+        incrAlign();
+        indent();
+        sb.append("try {\n");
+        incrAlign();
+        indent();
+        if (!mtype.returnType().equals(void.class)) {
+            sb.append("return (" + mtype.returnType().getName() + ")");
+        }
+        sb.append(f.name() + ".invokeExact(" + String.join(", ", pNames) + ");\n");
+        decrAlign();
+        indent();
+        sb.append("} catch (Throwable ex) {\n");
+        incrAlign();
+        indent();
+        sb.append("throw new AssertionError(ex);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    void addDescriptor(String name, FunctionDescriptor desc) {
+        incrAlign();
+        indent();
+        sb.append(PRI_MODS + "FunctionDescriptor " + name + "$DESC = ");
+        addFunction(desc);
+        sb.append(";\n");
+        decrAlign();
+        indent();
+    }
+
+    void addFunctionalInterface(String name, MethodType mtype) {
+        incrAlign();
+        indent();
+        sb.append("public interface " + javaSafeIdentifier(name) + " {\n");
+        incrAlign();
+        indent();
+        sb.append(mtype.returnType().getName() + " apply(");
+        String delim = "";
+        for (int i = 0 ; i < mtype.parameterCount() ; i++) {
+            sb.append(delim + mtype.parameterType(i).getName() + " x" + i);
+            delim = ", ";
+        }
+        sb.append(");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+        indent();
+    }
+
+    protected void addFunctionalFactory(String name, MethodType mtype) {
+        incrAlign();
+        indent();
+        sb.append(PUB_MODS + "MemoryAddress " + name + "$make(" + name + " fi) {\n");
+        incrAlign();
+        indent();
+        sb.append("return RuntimeHelper.upcallStub(" + name + ".class, fi, " + name + "$DESC, " +
+                "\"" + mtype.toMethodDescriptorString() + "\");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    void addGetter(String name, Class<?> type, String parent) {
+        incrAlign();
+        indent();
+        name = javaSafeIdentifier(name);
+        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
+        String param = parent != null ? (MemorySegment.class.getName() + " seg") : "";
+        sb.append(PUB_MODS + type.getName() + " " + vhName + "$get(" + param + ") {\n");
+        incrAlign();
+        indent();
+        String vhParam = parent != null ?
+                "seg.baseAddress()" : name + "$ADDR";
+        sb.append("return (" + type.getName() + ")" + vhName + ".get(" + vhParam + ");\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    void addSetter(String name, Class<?> type, String parent) {
+        incrAlign();
+        indent();
+        name = javaSafeIdentifier(name);
+        String vhName = (parent != null ? (javaSafeIdentifier(parent) + "$") : "") + name;
+        String param = parent != null ? (MemorySegment.class.getName() + " seg, ") : "";
+        sb.append(PUB_MODS + "void " + vhName + "$set(" + param + type.getName() + " x) {\n");
+        incrAlign();
+        indent();
+        String vhParam = parent != null ?
+                "seg.baseAddress()" : name + "$ADDR";
+        sb.append(vhName + ".set(" + vhParam + ", x);\n");
+        decrAlign();
+        indent();
+        sb.append("}\n");
+        decrAlign();
+    }
+
+    protected String build() {
+        String res = sb.toString();
+        this.sb = null;
+        return res.toString();
+    }
+
+    protected void indent() {
+        for (int i = 0; i < align; i++) {
+            sb.append("    ");
+        }
+    }
+
+    protected void incrAlign() {
+        align++;
+    }
+
+    protected void decrAlign() {
+        align--;
+    }
+
+    protected final String javaSafeIdentifier(String name) {
+        // We never get the problem of Java non-identifiers (like 123, ab-xy) as
+        // C identifiers. But we may have a java keyword used as a C identifier.
+        assert SourceVersion.isIdentifier(name);
+
+        return SourceVersion.isKeyword(name)? (name + "_") : name;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Main.java
@@ -0,0 +1,227 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.JextractTask;
+import jdk.internal.joptsimple.OptionException;
+import jdk.internal.joptsimple.OptionParser;
+import jdk.internal.joptsimple.OptionSet;
+import jdk.internal.joptsimple.util.KeyValuePair;
+
+import javax.tools.JavaFileObject;
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.text.MessageFormat;
+import java.util.List;
+import java.util.Locale;
+import java.util.ResourceBundle;
+import java.util.spi.ToolProvider;
+
+/**
+ * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,
+ * where for each native function a static method is added which calls the underlying native method handles.
+ * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated
+ * on top of the underlying memory access var handles. For each struct, a static layout field is generated.
+ */
+public class Main {
+    private static final String MESSAGES_RESOURCE = "jdk.incubator.jextract.tool.resources.Messages";
+
+    private static final ResourceBundle MESSAGES_BUNDLE;
+    static {
+        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());
+    }
+
+    public static final boolean DEBUG = Boolean.getBoolean("jextract.debug");
+
+    // error codes
+    private static final int SUCCESS       = 0;
+    private static final int OPTION_ERROR  = 1;
+    private static final int INPUT_ERROR   = 2;
+    private static final int OUTPUT_ERROR  = 3;
+    private static final int RUNTIME_ERROR = 4;
+
+    private final PrintWriter out;
+    private final PrintWriter err;
+
+    private static String format(String msgId, Object... args) {
+        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);
+    }
+
+    private Main(PrintWriter out, PrintWriter err) {
+        this.out = out;
+        this.err = err;
+    }
+
+    private int printHelp(OptionParser parser, int exitCode) {
+        try {
+            parser.printHelpOn(err);
+        } catch (IOException ignored) {}
+        return exitCode;
+    }
+
+    public static void main(String[] args) {
+        if (args.length == 0) {
+            System.err.println("Expected a header file");
+            return;
+        }
+
+        Main m = new Main(new PrintWriter(System.out, true), new PrintWriter(System.err, true));
+        System.exit(m.run(args));
+    }
+
+    private int run(String[] args) {
+        OptionParser parser = new OptionParser(false);
+        parser.accepts("C", format("help.C")).withRequiredArg();
+        parser.accepts("I", format("help.I")).withRequiredArg();
+        parser.accepts("d", format("help.d")).withRequiredArg();
+        parser.accepts("filter", format("help.filter")).withRequiredArg();
+        parser.accepts("l", format("help.l")).withRequiredArg();
+        parser.accepts("source", format("help.source"));
+        parser.acceptsAll(List.of("t", "target-package"), format("help.t")).withRequiredArg();
+        parser.acceptsAll(List.of("?", "h", "help"), format("help.h")).forHelp();
+        parser.nonOptions(format("help.non.option"));
+
+        OptionSet optionSet;
+        try {
+            optionSet = parser.parse(args);
+        } catch (OptionException oe) {
+            return printHelp(parser, OPTION_ERROR);
+        }
+
+        if (optionSet.has("h")) {
+            return printHelp(parser, SUCCESS);
+        }
+
+        if (optionSet.nonOptionArguments().size() != 1) {
+            return printHelp(parser, OPTION_ERROR);
+        }
+
+        Options.Builder builder = Options.builder();
+        if (optionSet.has("I")) {
+            optionSet.valuesOf("I").forEach(p -> builder.addClangArg("-I" + p));
+        }
+
+        Path builtinInc = Paths.get(System.getProperty("java.home"), "conf", "jextract");
+        builder.addClangArg("-I" + builtinInc);
+
+        if (optionSet.has("C")) {
+            optionSet.valuesOf("C").forEach(p -> builder.addClangArg((String) p));
+        }
+
+        if (optionSet.has("filter")) {
+            optionSet.valuesOf("filter").forEach(p -> builder.addFilter((String) p));
+        }
+
+        if (optionSet.has("d")) {
+            builder.setOutputDir(optionSet.valueOf("d").toString());
+        }
+
+        if (optionSet.has("source")) {
+            builder.setGenerateSource();
+        }
+
+        boolean librariesSpecified = optionSet.has("l");
+        if (librariesSpecified) {
+            for (Object arg : optionSet.valuesOf("l")) {
+                String lib = (String)arg;
+                if (lib.indexOf(File.separatorChar) != -1) {
+                    err.println(format("l.name.should.not.be.path", lib));
+                    return OPTION_ERROR;
+                }
+                builder.addLibraryName(lib);
+            }
+        }
+
+        String targetPackage = optionSet.has("t") ? (String) optionSet.valueOf("t") : "";
+        builder.setTargetPackage(targetPackage);
+
+        Options options = builder.build();
+
+        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());
+        if (!Files.isReadable(header)) {
+            err.println(format("cannot.read.header.file", header));
+            return INPUT_ERROR;
+        }
+
+        //parse    //generate
+        try {
+            JextractTask jextractTask = JextractTask.newTask(!options.source, header);
+            Declaration.Scoped toplevel = jextractTask.parse(options.clangArgs.toArray(new String[0]));
+
+            //filter
+            if (!options.filters.isEmpty()) {
+                toplevel = Filter.filter(toplevel, options.filters.toArray(new String[0]));
+            }
+
+            if (Main.DEBUG) {
+                System.out.println(toplevel);
+            }
+
+            Path output = Path.of(options.outputDir);
+
+            JavaFileObject[] files = HandleSourceFactory.generateWrapped(
+                toplevel,
+                header.getFileName().toString().replace(".h", "_h"),
+                options.targetPackage,
+                options.libraryNames);
+            jextractTask.write(output, files);
+        } catch (RuntimeException re) {
+            err.println(re);
+            if (Main.DEBUG) {
+                re.printStackTrace(err);
+            }
+            return RUNTIME_ERROR;
+        }
+        return SUCCESS;
+    }
+
+    public static class JextractToolProvider implements ToolProvider {
+        @Override
+        public String name() {
+            return "jextract";
+        }
+
+        @Override
+        public int run(PrintWriter out, PrintWriter err, String... args) {
+            // defensive check to throw security exception early.
+            // Note that the successful run of jextract under security
+            // manager would require far more permissions like loading
+            // library (clang), file system access etc.
+            if (System.getSecurityManager() != null) {
+                System.getSecurityManager().
+                    checkPermission(new RuntimePermission("jextract"));
+            }
+
+            Main instance = new Main(out, err);
+            return instance.run(args);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/Options.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package jdk.incubator.jextract.tool;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Pattern;
+
+public class Options {
+    // The args for parsing C
+    public final List<String> clangArgs;
+    // The list of library names
+    public final List<String> libraryNames;
+    public final List<String> filters;
+    // target package
+    public final String targetPackage;
+    // output directory
+    public final String outputDir;
+    public final boolean source;
+
+    private Options(List<String> clangArgs, List<String> libraryNames,
+            List<String> filters, String targetPackage,
+            String outputDir, boolean source) {
+        this.clangArgs = clangArgs;
+        this.libraryNames = libraryNames;
+        this.filters = filters;
+        this.targetPackage = targetPackage;
+        this.outputDir = outputDir;
+        this.source = source;
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static Options createDefault() {
+        return builder().build();
+    }
+
+    public static class Builder {
+        private final List<String> clangArgs;
+        private final List<String> libraryNames;
+        private final List<String> filters;
+        private String targetPackage;
+        private String outputDir;
+        private boolean source;
+
+        public Builder() {
+            this.clangArgs = new ArrayList<>();
+            this.libraryNames = new ArrayList<>();
+            this.filters = new ArrayList<>();
+            this.targetPackage = "";
+            this.outputDir = ".";
+            this.source = source;
+        }
+
+        public Options build() {
+            return new Options(
+                    Collections.unmodifiableList(clangArgs),
+                    Collections.unmodifiableList(libraryNames),
+                    Collections.unmodifiableList(filters),
+                    targetPackage, outputDir, source
+            );
+        }
+
+        public void addClangArg(String arg) {
+            clangArgs.add(arg);
+        }
+
+        public void addLibraryName(String name) {
+            libraryNames.add(name);
+        }
+
+        public void setOutputDir(String outputDir) {
+            this.outputDir = outputDir;
+        }
+
+        public void setTargetPackage(String pkg) {
+            this.targetPackage = pkg;
+        }
+
+        public void addFilter(String filter) {
+            filters.add(filter);
+        }
+
+        public void setGenerateSource() {
+            source = true;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/StaticWrapperSourceFactory.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract.tool;
+
+import java.lang.invoke.MethodType;
+import java.util.List;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+
+public class StaticWrapperSourceFactory extends HandleSourceFactory {
+    public StaticWrapperSourceFactory(String clsName, String pkgName, List<String> libraryNames) {
+        super(clsName, pkgName, libraryNames);
+    }
+
+    @Override
+    protected void generateFunctionalInterfaces(Declaration.Scoped decl) {
+        //do nothing
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {
+        if (visitedFunction(funcTree)) {
+            return null;
+        }
+
+        MethodType mtype = typeTranslator.getMethodType(funcTree.type());
+        FunctionDescriptor descriptor = Type.descriptorFor(funcTree.type()).orElse(null);
+        if (descriptor == null) {
+            //abort
+            return null;
+        }
+        builder.addMethodHandle(funcTree, mtype, descriptor);
+        //generate static wrapper for function
+        builder.addStaticFunctionWrapper(funcTree, mtype);
+        int i = 0;
+        for (Declaration.Variable param : funcTree.parameters()) {
+            Type.Function f = getAsFunctionPointer(param.type());
+            if (f != null) {
+                String name = funcTree.name() + "$" + (param.name().isEmpty() ? "x" + i : param.name());
+                //add descriptor constant
+                builder.addDescriptor(name, Type.descriptorFor(f).get());
+                //generate functional interface
+                MethodType fitype = typeTranslator.getMethodType(f);
+                builder.addFunctionalInterface(name, fitype);
+                //generate helper
+                builder.addFunctionalFactory(name, fitype);
+                i++;
+            }
+        }
+        return null;
+    }
+
+    Type.Function getAsFunctionPointer(Type type) {
+        if (type instanceof Type.Delegated) {
+            switch (((Type.Delegated) type).kind()) {
+                case POINTER: {
+                    Type pointee = ((Type.Delegated) type).type();
+                    return (pointee instanceof Type.Function) ?
+                        (Type.Function)pointee : null;
+                }
+                default:
+                    return getAsFunctionPointer(((Type.Delegated) type).type());
+            }
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {
+        if (parent == null && visitedVariable(tree)) {
+            return null;
+        }
+
+        String fieldName = tree.name();
+        String symbol = tree.name();
+        assert !symbol.isEmpty();
+        assert !fieldName.isEmpty();
+
+        // FIXME: we need tree transformer. The mangling should be a separate tree transform phase
+        if (parent == null) {
+            setMangledName(tree);
+            fieldName = getMangledName(tree);
+        }
+
+        Type type = tree.type();
+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));
+        if (layout == null) {
+            //no layout - abort
+            return null;
+        }
+        Class<?> clazz = typeTranslator.getJavaType(type);
+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD || clazz == MemoryAddress.class ||
+                clazz == MemorySegment.class || layout.byteSize() > 8) {
+            //skip
+            return null;
+        }
+
+        String parentName = parent != null? getMangledName(parent) : null;
+        if (parent != null) {
+            //struct field
+            builder.addVarHandle(fieldName, clazz, parentName);
+        } else {
+            builder.addLayout(fieldName, layout);
+            builder.addVarHandle(fieldName, clazz, null);
+            builder.addAddress(fieldName);
+        }
+        //add getter and setters
+        builder.addGetter(fieldName, clazz, parentName);
+        builder.addSetter(fieldName, clazz, parentName);
+
+        return null;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/TypeTranslator.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/TypeTranslator.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/TypeTranslator.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.incubator.jextract.tool;
+
+import jdk.incubator.jextract.Type;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+
+import java.lang.invoke.MethodType;
+
+public class TypeTranslator implements Type.Visitor<Class<?>, Void> {
+    @Override
+    public Class<?> visitPrimitive(Type.Primitive t, Void aVoid) {
+        if (t.layout().isEmpty()) {
+            return void.class;
+        } else {
+            return layoutToClass(isFloatingPoint(t), t.layout().orElseThrow(UnsupportedOperationException::new));
+        }
+    }
+
+    private boolean isFloatingPoint(Type.Primitive t) {
+        switch (t.kind()) {
+            case Float:
+            case Float128:
+            case HalfFloat:
+            case Double:
+            case LongDouble:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    private Class<?> layoutToClass(boolean fp, MemoryLayout layout) {
+        switch ((int)layout.bitSize()) {
+            case 8: return byte.class;
+            case 16: return short.class;
+            case 32: return !fp ? int.class : float.class;
+            case 64:
+            case 128: return !fp ? long.class : double.class;
+            default:
+                throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public Class<?> visitDelegated(Type.Delegated t, Void aVoid) {
+        return t.kind() == Type.Delegated.Kind.POINTER ?
+                MemoryAddress.class :
+                t.type().accept(this, null);
+    }
+
+    @Override
+    public Class<?> visitFunction(Type.Function t, Void aVoid) {
+        return MemoryAddress.class; // function pointer
+    }
+
+    @Override
+    public Class<?> visitDeclared(Type.Declared t, Void aVoid) {
+        switch (t.tree().kind()) {
+            case UNION:
+            case STRUCT:
+                return MemorySegment.class;
+            case ENUM:
+                return layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));
+            default:
+                throw new UnsupportedOperationException();
+        }
+    }
+
+    @Override
+    public Class<?> visitArray(Type.Array t, Void aVoid) {
+        if (t.kind() == Type.Array.Kind.VECTOR) {
+            throw new UnsupportedOperationException();
+        } else {
+            return MemorySegment.class;
+        }
+    }
+
+    @Override
+    public Class<?> visitType(Type t, Void aVoid) {
+        throw new UnsupportedOperationException();
+    }
+
+    Class<?> getJavaType(Type t) {
+        return t.accept(this, null);
+    }
+
+    MethodType getMethodType(Type.Function type) {
+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType()));
+        for (Type arg : type.argumentTypes()) {
+            mtype = mtype.appendParameterTypes(getJavaType(arg));
+        }
+        if (type.varargs()) {
+            mtype = mtype.appendParameterTypes(Object[].class);
+        }
+        return mtype;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Messages.properties b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Messages.properties
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/Messages.properties
@@ -0,0 +1,37 @@
+#
+#  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+# 
+#  This code is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU General Public License version 2 only, as
+#  published by the Free Software Foundation.
+# 
+#  This code is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#  version 2 for more details (a copy is included in the LICENSE file that
+#  accompanied this code).
+# 
+#  You should have received a copy of the GNU General Public License version
+#  2 along with this work; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+# 
+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+#  or visit www.oracle.com if you need additional information or have any
+#  questions.
+#
+
+# error message
+cannot.read.header.file=cannot read header file: {0}
+l.name.should.not.be.path=option value for -l option cannot be a path
+
+# help messages for options
+help.C=pass through argument for clang
+help.I=specify include files path
+help.d=specify where to place generated files
+help.filter=header files to filter
+help.h=print help
+help.l=specify a library
+help.source=generate java sources
+help.t=target package for specified header files
+help.non.option=header file
diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.template
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/tool/resources/RuntimeHelper.template
@@ -0,0 +1,196 @@
+// Generated by jextract
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.util.Arrays;
+import java.util.Optional;
+
+import static ${C_LANG}.*;
+
+public class RuntimeHelper {
+
+    private final static SystemABI ABI = Foreign.getInstance().getSystemABI();
+
+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
+
+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
+
+    static final LibraryLookup[] libraries(String[] libNames) {
+        if (libNames.length == 0) {
+            return new LibraryLookup[] { LibraryLookup.ofDefault() };
+        } else {
+            return Arrays.stream(libNames)
+                .map(libName -> LibraryLookup.ofLibrary(MH_LOOKUP, libName))
+                .toArray(LibraryLookup[]::new);
+        }
+    }
+
+    private static final Optional<MemoryAddress> lookup(LibraryLookup[] LIBRARIES, String sym) {
+        for (LibraryLookup l : LIBRARIES) {
+            try {
+                return Optional.of(l.lookup(sym));
+            } catch (Throwable t) {
+            }
+        }
+        try {
+            return Optional.of(LibraryLookup.ofDefault().lookup(sym));
+        } catch (Throwable t) {
+            return Optional.empty();
+        }
+    }
+
+    public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name) {
+        return lookup(LIBRARIES, name).orElse(null);
+    }
+
+    public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {
+        return lookup(LIBRARIES, name).map(
+                addr -> {
+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);
+                    return variadic ?
+                        VarargsInvoker.make(addr, mt, fdesc) :
+                        ABI.downcallHandle(addr, mt, fdesc);
+                }).orElse(null);
+    }
+
+    public static final MemoryAddress upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
+        return ABI.upcallStub(handle, fdesc);
+    }
+
+    public static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
+        try {
+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
+            handle = handle.bindTo(z);
+            return upcallStub(handle, fdesc);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    private static class VarargsInvoker {
+        private static final MethodHandle INVOKE_MH;
+        private final MemoryAddress symbol;
+        private final MethodType varargs;
+        private final FunctionDescriptor function;
+
+        private VarargsInvoker(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+            this.symbol = symbol;
+            this.varargs = type;
+            this.function = function;
+        }
+
+        static {
+            try {
+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, "invoke", MethodType.methodType(Object.class, Object[].class));
+            } catch (ReflectiveOperationException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        static MethodHandle make(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);
+            return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())
+                    .asType(type);
+        }
+
+        private Object invoke(Object[] args) throws Throwable {
+            // one trailing Object[]
+            int nNamedArgs = function.argumentLayouts().size();
+            assert(args.length == nNamedArgs + 1);
+            // The last argument is the array of vararg collector
+            Object[] unnamedArgs = (Object[]) args[args.length - 1];
+
+            int argsCount = nNamedArgs + unnamedArgs.length;
+            Class<?>[] argTypes = new Class<?>[argsCount];
+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];
+
+            int pos = 0;
+            for (pos = 0; pos < nNamedArgs; pos++) {
+                argTypes[pos] = varargs.parameterType(pos);
+                argLayouts[pos] = function.argumentLayouts().get(pos);
+            }
+
+            assert pos == nNamedArgs;
+            for (Object o: unnamedArgs) {
+                argTypes[pos] = normalize(o.getClass());
+                argLayouts[pos] = variadicLayout(argTypes[pos]);
+                pos++;
+            }
+            assert pos == argsCount;
+
+            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);
+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?
+                    FunctionDescriptor.ofVoid(argLayouts) :
+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);
+            MethodHandle mh = Foreign.getInstance().getSystemABI().downcallHandle(symbol, mt, f);
+            // flatten argument list so that it can be passed to an asSpreader MH
+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];
+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);
+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);
+
+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);
+        }
+
+        private static Class<?> unboxIfNeeded(Class<?> clazz) {
+            if (clazz == Boolean.class) {
+                return boolean.class;
+            } else if (clazz == Void.class) {
+                return void.class;
+            } else if (clazz == Byte.class) {
+                return byte.class;
+            } else if (clazz == Character.class) {
+                return char.class;
+            } else if (clazz == Short.class) {
+                return short.class;
+            } else if (clazz == Integer.class) {
+                return int.class;
+            } else if (clazz == Long.class) {
+                return long.class;
+            } else if (clazz == Float.class) {
+                return float.class;
+            } else if (clazz == Double.class) {
+                return double.class;
+            } else {
+                return clazz;
+            }
+        }
+
+        private Class<?> normalize(Class<?> c) {
+            c = unboxIfNeeded(c);
+            if (c.isPrimitive()) {
+                return c;
+            }
+            if (MemoryAddress.class.isAssignableFrom(c)) {
+                return MemoryAddress.class;
+            }
+            if (MemorySegment.class.isAssignableFrom(c)) {
+                return MemorySegment.class;
+            }
+            throw new IllegalArgumentException("Invalid type for ABI: " + c.getTypeName());
+        }
+
+        private MemoryLayout variadicLayout(Class<?> c) {
+            if (c == char.class || c == byte.class || c == short.class || c == int.class || c == long.class) {
+                //it is ok to approximate with a machine word here; numerics arguments in a prototype-less
+                //function call are always rounded up to a register size anyway.
+                return C_LONGLONG;
+            } else if (c == float.class || c == double.class) {
+                return C_DOUBLE;
+            } else if (MemoryAddress.class.isAssignableFrom(c)) {
+                return C_POINTER;
+            } else {
+                throw new IllegalArgumentException("Unhandled variadic argument class: " + c);
+            }
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AccessSpecifier.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AccessSpecifier.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AccessSpecifier.java
@@ -0,0 +1,68 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+/**
+ * Represents the C++ access control level of a member or of a base class.
+ */
+public enum AccessSpecifier {
+    InvalidAccessSpecifier(0),
+    Public(1),
+    Protected(2),
+    Private(3);
+
+    private final int value;
+
+    AccessSpecifier(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, AccessSpecifier> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (AccessSpecifier e: AccessSpecifier.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static AccessSpecifier valueOf(int value) {
+        AccessSpecifier x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("Invalid AccessSpecifier kind value: " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/AllocationScope.java
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemorySegment;
+
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+class AllocationScope implements AutoCloseable {
+    private final Set<MemorySegment> segments = new LinkedHashSet<>();
+
+    MemorySegment track(MemorySegment segment) {
+        if (!segments.add(segment)) {
+            throw new IllegalArgumentException("Attempt to track a memory segment twice");
+        }
+        return segment;
+    }
+
+    void forget(MemorySegment segment) {
+        if (!segments.remove(segment)) {
+            throw new IllegalArgumentException("Attempt to forget a memory segment not tracked by this scope");
+        }
+    }
+
+    @Override
+    public void close() {
+        var currentThread = Thread.currentThread();
+        segments.stream()
+                .filter(ms -> ms.ownerThread() == currentThread)
+                .forEach(MemorySegment::close);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CallingConvention.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CallingConvention.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CallingConvention.java
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public enum CallingConvention {
+
+    Default(0),
+    C(1),
+    X86StdCall(2),
+    X86FastCall(3),
+    X86ThisCall(4),
+    X86Pascal(5),
+    AAPCS(6),
+    AAPCS_VFP(7),
+    PnaclCall(8),
+    IntelOclBicc(9),
+    X86_64Win64(10),
+    X86_64SysV(11),
+    Invalid(100),
+    Unexposed(200);
+
+    private final int value;
+
+    CallingConvention(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, CallingConvention> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (CallingConvention e: CallingConvention.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static CallingConvention valueOf(int value) {
+        CallingConvention x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException();
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Cursor.java
@@ -0,0 +1,390 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+
+import java.util.ArrayList;
+import java.util.stream.Stream;
+
+public final class Cursor {
+
+    private final MemorySegment cursor;
+    private final int kind;
+
+    Cursor(MemorySegment cursor) {
+        this.cursor = cursor;
+        kind = Index_h.clang_getCursorKind(cursor);
+    }
+
+    public boolean isDeclaration() {
+        return Index_h.clang_isDeclaration(kind) != 0;
+    }
+
+    public boolean isPreprocessing() {
+        return Index_h.clang_isPreprocessing(kind) != 0;
+    }
+
+    public boolean isInvalid() {
+        return Index_h.clang_isInvalid(kind) != 0;
+    }
+
+    public boolean isDefinition() {
+        return Index_h.clang_isCursorDefinition(cursor) != 0;
+    }
+
+    public boolean isAttribute() { return Index_h.clang_isAttribute(kind) != 0; }
+
+    public boolean isAnonymousStruct() {
+        return Index_h.clang_Cursor_isAnonymousRecordDecl(cursor) != 0;
+    }
+
+    public boolean isMacroFunctionLike() {
+        return Index_h.clang_Cursor_isMacroFunctionLike(cursor) != 0;
+    }
+
+    public String spelling() {
+        return LibClang.CXStrToString(
+                Index_h.clang_getCursorSpelling(cursor));
+    }
+
+    public String USR() {
+        return LibClang.CXStrToString(
+                Index_h.clang_getCursorUSR(cursor));
+    }
+
+    public String prettyPrinted(PrintingPolicy policy) {
+        return LibClang.CXStrToString(
+                Index_h.clang_getCursorPrettyPrinted(cursor, policy.ptr()));
+    }
+
+    public String prettyPrinted() {
+        try (PrintingPolicy policy = getPrintingPolicy()) {
+            return prettyPrinted(policy);
+        }
+    }
+
+    public String displayName() {
+        return LibClang.CXStrToString(
+                Index_h.clang_getCursorDisplayName(cursor));
+    }
+
+    public boolean equalCursor(Cursor other) {
+        return Index_h.clang_equalCursors(cursor, other.cursor) != 0;
+    }
+
+    public Type type() {
+        return new Type(Index_h.clang_getCursorType(cursor));
+    }
+
+    public Type getEnumDeclIntegerType() {
+        return new Type(Index_h.clang_getEnumDeclIntegerType(cursor));
+    }
+
+    public boolean isEnumDeclScoped() {
+        return Index_h.clang_EnumDecl_isScoped(cursor) != 0;
+    }
+
+    public Cursor getDefinition() {
+        return new Cursor(Index_h.clang_getCursorDefinition(cursor));
+    }
+
+    public SourceLocation getSourceLocation() {
+        MemorySegment loc = Index_h.clang_getCursorLocation(cursor);
+        if (Index_h.clang_equalLocations(loc, Index_h.clang_getNullLocation()) != 0) {
+            return null;
+        }
+        return new SourceLocation(loc);
+    }
+
+    public SourceRange getExtent() {
+        MemorySegment range = Index_h.clang_getCursorExtent(cursor);
+        if (Index_h.clang_Range_isNull(range) != 0) {
+            return null;
+        }
+        return new SourceRange(range);
+    }
+
+    public int numberOfArgs() {
+        return Index_h.clang_Cursor_getNumArguments(cursor);
+    }
+
+    public Cursor getArgument(int idx) {
+        return new Cursor(Index_h.clang_Cursor_getArgument(cursor, idx));
+    }
+
+    public int numberOfTemplateArgs() {
+        return Index_h.clang_Cursor_getNumTemplateArguments(cursor);
+    }
+
+    public TemplateArgumentKind getTemplateArgumentKind(int idx) {
+        int kind = Index_h.clang_Cursor_getTemplateArgumentKind(cursor, idx);
+        return TemplateArgumentKind.valueOf(kind);
+    }
+
+    public Type getTemplateArgumentType(int idx) {
+        return new Type(Index_h.clang_Cursor_getTemplateArgumentType(cursor, idx));
+    }
+
+    public long getTemplateArgumentValue(int idx) {
+        return Index_h.clang_Cursor_getTemplateArgumentValue(cursor, idx);
+    }
+
+    public long getTemplateArgumentUnsignedValue(int idx) {
+        return Index_h.clang_Cursor_getTemplateArgumentUnsignedValue(cursor, idx);
+    }
+
+    public CursorKind getTemplateCursorKind() {
+        return CursorKind.valueOf(Index_h.clang_getTemplateCursorKind(cursor));
+    }
+
+    // C long long, 64-bit
+    public long getEnumConstantValue() {
+        return Index_h.clang_getEnumConstantDeclValue(cursor);
+    }
+
+    // C unsigned long long, 64-bit
+    public long getEnumConstantUnsignedValue() {
+        return Index_h.clang_getEnumConstantDeclUnsignedValue(cursor);
+    }
+
+    public boolean isBitField() {
+        return Index_h.clang_Cursor_isBitField(cursor) != 0;
+    }
+
+    /**
+     * Returns true if the base class specified by this cursor is virtual.
+     */
+    public boolean isVirtualBase() {
+        return Index_h.clang_isVirtualBase(cursor) != 0;
+    }
+
+    public int getBitFieldWidth() {
+        return Index_h.clang_getFieldDeclBitWidth(cursor);
+    }
+
+    public CursorKind kind() {
+        return CursorKind.valueOf(kind);
+    }
+
+    public int kind0() {
+        return kind;
+    }
+
+    /**
+     * Determine if a C++ constructor is a converting constructor.
+     */
+    public boolean isConvertingConstructor() {
+        return Index_h.clang_CXXConstructor_isConvertingConstructor(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ constructor is a copy constructor.
+     */
+    public boolean isCopyConstructor() {
+        return Index_h.clang_CXXConstructor_isCopyConstructor(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ constructor is the default constructor.
+     */
+    public boolean isDefaultConstructor() {
+        return Index_h.clang_CXXConstructor_isDefaultConstructor(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ constructor is a move constructor.
+     */
+    public boolean isMoveConstructor() {
+        return Index_h.clang_CXXConstructor_isMoveConstructor(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ field is declared 'mutable'.
+     */
+    public boolean isMutableField() {
+        return Index_h.clang_CXXField_isMutable(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ method is declared '= default'.
+     */
+    public boolean isDefaultedMethod() {
+        return Index_h.clang_CXXMethod_isDefaulted(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ member function is pure virtual.
+     */
+    public boolean isPureVirtualMethod() {
+        return Index_h.clang_CXXMethod_isPureVirtual(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ member function or member function template is
+     * declared 'static'.
+     */
+    public boolean isStaticMethod() {
+        return Index_h.clang_CXXMethod_isStatic(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ member function is explicitly declared 'virtual'
+     * or if it overrides a virtual method from one of the base classes.
+     */
+    public boolean isVirtualMethod() {
+        return Index_h.clang_CXXMethod_isVirtual(cursor) != 0;
+    }
+
+    public boolean isConstructor() {
+        return kind() == CursorKind.Constructor;
+    }
+
+    public boolean isDestructor() {
+        return kind() == CursorKind.Destructor;
+    }
+
+    /**
+     * Determine if a C++ record is abstract, i.e. whether a class or struct
+     * has a pure virtual member function.
+     */
+    public boolean isAbstractClass() {
+        return Index_h.clang_CXXRecord_isAbstract(cursor) != 0;
+    }
+
+    /**
+     * Determine if a C++ member function or member function template is
+     * declared 'const'.
+     */
+    public boolean isConstMethod() {
+        return Index_h.clang_CXXMethod_isConst(cursor) != 0;
+    }
+
+    public AccessSpecifier accessSpecifier() {
+        int acc = Index_h.clang_getCXXAccessSpecifier(cursor);
+        return AccessSpecifier.valueOf(acc);
+    }
+
+    /**
+     * Determine the number of overloaded declarations referenced by a
+     * \c CursorKind.OverloadedDeclRef cursor.
+     *
+     * \returns The number of overloaded declarations referenced by \c cursor. If it
+     * is not a \c CursorKind.OverloadedDeclRef cursor, returns 0.
+     */
+    public int numberOfOverloadedDecls() {
+        return Index_h.clang_getNumOverloadedDecls(cursor);
+    }
+
+    /**
+     * Retrieve a cursor for one of the overloaded declarations referenced
+     * by a \c CXCursor_OverloadedDeclRef cursor.
+     *
+     *
+     * \param index The zero-based index into the set of overloaded declarations in
+     * the cursor.
+     *
+     * \returns A cursor representing the declaration referenced by the given
+     * \c cursor at the specified \c index. If the cursor does not have an
+     * associated set of overloaded declarations, or if the index is out of bounds,
+     * returns \c clang_getNullCursor();
+     */
+    public Cursor getOverloadedDecl(int index) {
+        return new Cursor(Index_h.clang_getOverloadedDecl(cursor, index));
+    }
+
+    /**
+     * For a cursor that is a reference, retrieve a cursor representing the entity that it references.
+     */
+    public Cursor getCursorReferenced() {
+        return new Cursor(Index_h.clang_getCursorReferenced(cursor));
+    }
+
+    /**
+     * Given a cursor that may represent a specialization or instantiation of a template,
+     * retrieve the cursor that represents the template that it specializes or from which
+     * it was instantiated.
+     */
+    public Cursor getSpecializedCursorTemplate() {
+        return new Cursor(Index_h.clang_getSpecializedCursorTemplate(cursor));
+    }
+
+    public Stream<Cursor> children() {
+        final ArrayList<Cursor> ar = new ArrayList<>();
+        // FIXME: need a way to pass ar down as user data
+        Index_h.clang_visitChildren(cursor, Index_h.clang_visitChildren$visitor$make((c, p, d) -> {
+            Cursor cursor = new Cursor(c);
+            ar.add(cursor);
+            return Index_h.CXChildVisit_Continue;
+        }), MemoryAddress.NULL);
+        return ar.stream();
+    }
+
+    public Stream<Cursor> allChildren() {
+        return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));
+    }
+
+    public String getMangling() {
+        return LibClang.CXStrToString(
+                Index_h.clang_Cursor_getMangling(cursor));
+    }
+
+    public TranslationUnit getTranslationUnit() {
+        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(cursor));
+    }
+
+    private MemoryAddress eval0() {
+        return Index_h.clang_Cursor_Evaluate(cursor);
+    }
+
+    public EvalResult eval() {
+        MemoryAddress ptr = eval0();
+        return ptr == MemoryAddress.NULL ? EvalResult.erroneous : new EvalResult(ptr);
+    }
+
+    public PrintingPolicy getPrintingPolicy() {
+        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(cursor));
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (!(other instanceof Cursor)) {
+            return false;
+        }
+        return (Index_h.clang_equalCursors(cursor, ((Cursor)other).cursor) != 0);
+    }
+
+    @Override
+    public int hashCode() {
+        return spelling().hashCode();
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CursorKind.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CursorKind.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/CursorKind.java
@@ -0,0 +1,300 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public enum CursorKind {
+
+    UnexposedDecl(1),
+    StructDecl(2),
+    UnionDecl(3),
+    ClassDecl(4),
+    EnumDecl(5),
+    FieldDecl(6),
+    EnumConstantDecl(7),
+    FunctionDecl(8),
+    VarDecl(9),
+    ParmDecl(10),
+    ObjCInterfaceDecl(11),
+    ObjCCategoryDecl(12),
+    ObjCProtocolDecl(13),
+    ObjCPropertyDecl(14),
+    ObjCIvarDecl(15),
+    ObjCInstanceMethodDecl(16),
+    ObjCClassMethodDecl(17),
+    ObjCImplementationDecl(18),
+    ObjCCategoryImplDecl(19),
+    TypedefDecl(20),
+    CXXMethod(21),
+    Namespace(22),
+    LinkageSpec(23),
+    Constructor(24),
+    Destructor(25),
+    ConversionFunction(26),
+    TemplateTypeParameter(27),
+    NonTypeTemplateParameter(28),
+    TemplateTemplateParameter(29),
+    FunctionTemplate(30),
+    ClassTemplate(31),
+    ClassTemplatePartialSpecialization(32),
+    NamespaceAlias(33),
+    UsingDirective(34),
+    UsingDeclaration(35),
+    TypeAliasDecl(36),
+    ObjCSynthesizeDecl(37),
+    ObjCDynamicDecl(38),
+    CXXAccessSpecifier(39),
+    ObjCSuperClassRef(40),
+    ObjCProtocolRef(41),
+    ObjCClassRef(42),
+    TypeRef(43),
+    CXXBaseSpecifier(44),
+    TemplateRef(45),
+    NamespaceRef(46),
+    MemberRef(47),
+    LabelRef(48),
+    OverloadedDeclRef(49),
+    VariableRef(50),
+    InvalidFile(70),
+    NoDeclFound(71),
+    NotImplemented(72),
+    InvalidCode(73),
+    UnexposedExpr(100),
+    DeclRefExpr(101),
+    MemberRefExpr(102),
+    CallExpr(103),
+    ObjCMessageExpr(104),
+    BlockExpr(105),
+    IntegerLiteral(106),
+    FloatingLiteral(107),
+    ImaginaryLiteral(108),
+    StringLiteral(109),
+    CharacterLiteral(110),
+    ParenExpr(111),
+    UnaryOperator(112),
+    ArraySubscriptExpr(113),
+    BinaryOperator(114),
+    CompoundAssignOperator(115),
+    ConditionalOperator(116),
+    CStyleCastExpr(117),
+    CompoundLiteralExpr(118),
+    InitListExpr(119),
+    AddrLabelExpr(120),
+    StmtExpr(121),
+    GenericSelectionExpr(122),
+    GNUNullExpr(123),
+    CXXStaticCastExpr(124),
+    CXXDynamicCastExpr(125),
+    CXXReinterpretCastExpr(126),
+    CXXConstCastExpr(127),
+    CXXFunctionalCastExpr(128),
+    CXXTypeidExpr(129),
+    CXXBoolLiteralExpr(130),
+    CXXNullPtrLiteralExpr(131),
+    CXXThisExpr(132),
+    CXXThrowExpr(133),
+    CXXNewExpr(134),
+    CXXDeleteExpr(135),
+    UnaryExpr(136),
+    ObjCStringLiteral(137),
+    ObjCEncodeExpr(138),
+    ObjCSelectorExpr(139),
+    ObjCProtocolExpr(140),
+    ObjCBridgedCastExpr(141),
+    PackExpansionExpr(142),
+    SizeOfPackExpr(143),
+    LambdaExpr(144),
+    ObjCBoolLiteralExpr(145),
+    ObjCSelfExpr(146),
+    OMPArraySectionExpr(147),
+    ObjCAvailabilityCheckExpr(148),
+    FixedPointLiteral(149),
+    UnexposedStmt(200),
+    LabelStmt(201),
+    CompoundStmt(202),
+    CaseStmt(203),
+    DefaultStmt(204),
+    IfStmt(205),
+    SwitchStmt(206),
+    WhileStmt(207),
+    DoStmt(208),
+    ForStmt(209),
+    GotoStmt(210),
+    IndirectGotoStmt(211),
+    ContinueStmt(212),
+    BreakStmt(213),
+    ReturnStmt(214),
+    GCCAsmStmt(215),
+    AsmStmt(215),
+    ObjCAtTryStmt(216),
+    ObjCAtCatchStmt(217),
+    ObjCAtFinallyStmt(218),
+    ObjCAtThrowStmt(219),
+    ObjCAtSynchronizedStmt(220),
+    ObjCAutoreleasePoolStmt(221),
+    ObjCForCollectionStmt(222),
+    CXXCatchStmt(223),
+    CXXTryStmt(224),
+    CXXForRangeStmt(225),
+    SEHTryStmt(226),
+    SEHExceptStmt(227),
+    SEHFinallyStmt(228),
+    MSAsmStmt(229),
+    NullStmt(230),
+    DeclStmt(231),
+    OMPParallelDirective(232),
+    OMPSimdDirective(233),
+    OMPForDirective(234),
+    OMPSectionsDirective(235),
+    OMPSectionDirective(236),
+    OMPSingleDirective(237),
+    OMPParallelForDirective(238),
+    OMPParallelSectionsDirective(239),
+    OMPTaskDirective(240),
+    OMPMasterDirective(241),
+    OMPCriticalDirective(242),
+    OMPTaskyieldDirective(243),
+    OMPBarrierDirective(244),
+    OMPTaskwaitDirective(245),
+    OMPFlushDirective(246),
+    SEHLeaveStmt(247),
+    OMPOrderedDirective(248),
+    OMPAtomicDirective(249),
+    OMPForSimdDirective(250),
+    OMPParallelForSimdDirective(251),
+    OMPTargetDirective(252),
+    OMPTeamsDirective(253),
+    OMPTaskgroupDirective(254),
+    OMPCancellationPointDirective(255),
+    OMPCancelDirective(256),
+    OMPTargetDataDirective(257),
+    OMPTaskLoopDirective(258),
+    OMPTaskLoopSimdDirective(259),
+    OMPDistributeDirective(260),
+    OMPTargetEnterDataDirective(261),
+    OMPTargetExitDataDirective(262),
+    OMPTargetParallelDirective(263),
+    OMPTargetParallelForDirective(264),
+    OMPTargetUpdateDirective(265),
+    OMPDistributeParallelForDirective(266),
+    OMPDistributeParallelForSimdDirective(267),
+    OMPDistributeSimdDirective(268),
+    OMPTargetParallelForSimdDirective(269),
+    OMPTargetSimdDirective(270),
+    OMPTeamsDistributeDirective(271),
+    OMPTeamsDistributeSimdDirective(272),
+    OMPTeamsDistributeParallelForSimdDirective(273),
+    OMPTeamsDistributeParallelForDirective(274),
+    OMPTargetTeamsDirective(275),
+    OMPTargetTeamsDistributeDirective(276),
+    OMPTargetTeamsDistributeParallelForDirective(277),
+    OMPTargetTeamsDistributeParallelForSimdDirective(278),
+    OMPTargetTeamsDistributeSimdDirective(279),
+    BuiltinBitCastExpr(280),
+    TranslationUnit(300),
+    UnexposedAttr(400),
+    IBActionAttr(401),
+    IBOutletAttr(402),
+    IBOutletCollectionAttr(403),
+    CXXFinalAttr(404),
+    CXXOverrideAttr(405),
+    AnnotateAttr(406),
+    AsmLabelAttr(407),
+    PackedAttr(408),
+    PureAttr(409),
+    ConstAttr(410),
+    NoDuplicateAttr(411),
+    CUDAConstantAttr(412),
+    CUDADeviceAttr(413),
+    CUDAGlobalAttr(414),
+    CUDAHostAttr(415),
+    CUDASharedAttr(416),
+    VisibilityAttr(417),
+    DLLExport(418),
+    DLLImport(419),
+    NSReturnsRetained(420),
+    NSReturnsNotRetained(421),
+    NSReturnsAutoreleased(422),
+    NSConsumesSelf(423),
+    NSConsumed(424),
+    ObjCException(425),
+    ObjCNSObject(426),
+    ObjCIndependentClass(427),
+    ObjCPreciseLifetime(428),
+    ObjCReturnsInnerPointer(429),
+    ObjCRequiresSuper(430),
+    ObjCRootClass(431),
+    ObjCSubclassingRestricted(432),
+    ObjCExplicitProtocolImpl(433),
+    ObjCDesignatedInitializer(434),
+    ObjCRuntimeVisible(435),
+    ObjCBoxable(436),
+    FlagEnum(437),
+    ConvergentAttr(438),
+    WarnUnusedAttr(439),
+    WarnUnusedResultAttr(440),
+    AlignedAttr(441),
+    PreprocessingDirective(500),
+    MacroDefinition(501),
+    MacroExpansion(502),
+    MacroInstantiation(502),
+    InclusionDirective(503),
+    ModuleImportDecl(600),
+    TypeAliasTemplateDecl(601),
+    StaticAssert(602),
+    FriendDecl(603),
+    OverloadCandidate(700);
+
+    private final int value;
+
+    CursorKind(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, CursorKind> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (CursorKind e: CursorKind.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static CursorKind valueOf(int value) {
+        CursorKind x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("Invalid Cursor kind value: " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Diagnostic.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Diagnostic.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Diagnostic.java
@@ -0,0 +1,93 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.internal.clang.libclang.Index_h;
+
+public class Diagnostic {
+    final MemoryAddress ptr;
+
+    // Various Diagnostic severity levels - from Clang enum CXDiagnosticSeverity
+
+    /**
+     * A diagnostic that has been suppressed, e.g., by a command-line
+     * option.
+     */
+    public static final int CXDiagnostic_Ignored = 0;
+
+    /**
+     * This diagnostic is a note that should be attached to the
+     * previous (non-note) diagnostic.
+     */
+    public static final int CXDiagnostic_Note    = 1;
+
+    /**
+     * This diagnostic indicates suspicious code that may not be
+     * wrong.
+     */
+    public static final int CXDiagnostic_Warning = 2;
+
+    /**
+     * This diagnostic indicates that the code is ill-formed.
+     */
+    public static final int CXDiagnostic_Error   = 3;
+
+    /**
+     * This diagnostic indicates that the code is ill-formed such
+     * that future parser recovery is unlikely to produce useful
+     * results.
+     */
+    public static final int CXDiagnostic_Fatal   = 4;
+
+    Diagnostic(MemoryAddress ptr) {
+        this.ptr = ptr;
+    }
+
+    public int severity() {
+        return Index_h.clang_getDiagnosticSeverity(ptr);
+    }
+
+    public SourceLocation location() {
+        return new SourceLocation(Index_h.clang_getDiagnosticLocation(ptr));
+    }
+
+    public String spelling() {
+        return LibClang.CXStrToString(
+                Index_h.clang_getDiagnosticSpelling(ptr));
+    }
+
+    public void dispose() {
+        Index_h.clang_disposeDiagnostic(ptr);
+    }
+
+    @Override
+    public String toString() {
+        return LibClang.CXStrToString(
+                Index_h.clang_formatDiagnostic(ptr,
+                    Index_h.clang_defaultDiagnosticDisplayOptions()));
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/ErrorCode.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/ErrorCode.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/ErrorCode.java
@@ -0,0 +1,63 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import java.util.Arrays;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.function.Function;
+
+import static java.util.stream.Collectors.toMap;
+import static jdk.internal.clang.libclang.Index_h.CXError_ASTReadError;
+import static jdk.internal.clang.libclang.Index_h.CXError_Crashed;
+import static jdk.internal.clang.libclang.Index_h.CXError_Failure;
+import static jdk.internal.clang.libclang.Index_h.CXError_InvalidArguments;
+import static jdk.internal.clang.libclang.Index_h.CXError_Success;
+
+public enum ErrorCode {
+    Success(CXError_Success),
+    Failue(CXError_Failure),
+    Crashed(CXError_Crashed),
+    InvalidArguments(CXError_InvalidArguments),
+    ASTReadError(CXError_ASTReadError);
+
+    private final int code;
+
+    ErrorCode(int code) {
+        this.code = code;
+    }
+
+    public int code() {
+        return code;
+    }
+
+    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())
+            .collect(toMap(ErrorCode::code, Function.identity()));
+
+    public static ErrorCode valueOf(int code) {
+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException("No ErrorCode with code: " + k); });
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/EvalResult.java
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.internal.clang.libclang.Index_h;
+
+public class EvalResult implements AutoCloseable {
+    private MemoryAddress ptr;
+
+    public EvalResult(MemoryAddress ptr) {
+        this.ptr = ptr;
+    }
+
+    public enum Kind {
+        Integral,
+        FloatingPoint,
+        StrLiteral,
+        Erroneous,
+        Unknown
+    }
+
+    private int getKind0() {
+        return Index_h.clang_EvalResult_getKind(ptr);
+    }
+
+    public Kind getKind() {
+        int code = getKind0();
+        switch (code) {
+            case 1: return Kind.Integral;
+            case 2: return Kind.FloatingPoint;
+            case 3: case 4: case 5:
+                return Kind.StrLiteral;
+            default:
+                return Kind.Unknown;
+        }
+    }
+
+    private long getAsInt0() {
+        return Index_h.clang_EvalResult_getAsLongLong(ptr);
+    }
+
+    public long getAsInt() {
+        Kind kind = getKind();
+        switch (kind) {
+            case Integral:
+                return getAsInt0();
+            default:
+                throw new IllegalStateException("Unexpected kind: " + kind);
+        }
+    }
+
+    private double getAsFloat0() {
+        return Index_h.clang_EvalResult_getAsDouble(ptr);
+    }
+
+    public double getAsFloat() {
+        Kind kind = getKind();
+        switch (kind) {
+            case FloatingPoint:
+                return getAsFloat0();
+            default:
+                throw new IllegalStateException("Unexpected kind: " + kind);
+        }
+    }
+
+    private String getAsString0() {
+        MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);
+        return Utils.toJavaString(value);
+    }
+
+    public String getAsString() {
+        Kind kind = getKind();
+        switch (kind) {
+            case StrLiteral:
+                return getAsString0();
+            default:
+                throw new IllegalStateException("Unexpected kind: " + kind);
+        }
+    }
+
+    @Override
+    public void close() {
+        if (ptr != MemoryAddress.NULL) {
+            Index_h.clang_EvalResult_dispose(ptr);
+            ptr = MemoryAddress.NULL;
+        }
+    }
+
+    final static EvalResult erroneous = new EvalResult(MemoryAddress.NULL) {
+        @Override
+        public Kind getKind() {
+            return Kind.Erroneous;
+        }
+
+        @Override
+        public void close() {
+            //do nothing
+        }
+    };
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Index.java
@@ -0,0 +1,142 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+
+import java.lang.invoke.VarHandle;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+import static jdk.internal.jextract.impl.LayoutUtils.C_POINTER;
+
+public class Index implements AutoCloseable {
+    // Pointer to CXIndex
+    private MemoryAddress ptr;
+    // Set of TranslationUnit
+    public final List<TranslationUnit> translationUnits;
+
+    Index(MemoryAddress ptr) {
+        this.ptr = ptr;
+        translationUnits = new ArrayList<>();
+    }
+
+    public static class UnsavedFile {
+        final String file;
+        final String contents;
+
+        private UnsavedFile(Path path, String contents) {
+            this.file = path.toAbsolutePath().toString();
+            this.contents = contents;
+        }
+
+        public static UnsavedFile of(Path path, String contents) {
+            return new UnsavedFile(path, contents);
+        }
+    }
+
+    public static class ParsingFailedException extends RuntimeException {
+        private static final long serialVersionUID = -1L;
+        private final Path srcFile;
+        private final ErrorCode code;
+
+        public ParsingFailedException(Path srcFile, ErrorCode code) {
+            super("Failed to parse " + srcFile.toAbsolutePath().toString() + ": " + code);
+            this.srcFile = srcFile;
+            this.code = code;
+        }
+    }
+
+    private static final VarHandle VH_MemoryAddress = C_POINTER.varHandle(MemoryAddress.class);
+
+    public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)
+    throws ParsingFailedException {
+        try (MemorySegment src = Utils.toNativeString(file) ;
+             MemorySegment cargs = Utils.toNativeStringArray(args);
+             MemorySegment outAddress = MemorySegment.allocateNative(C_POINTER)) {
+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(
+                    ptr,
+                    src.baseAddress(),
+                    cargs == null ? MemoryAddress.NULL : cargs.baseAddress(),
+                    args.length, MemoryAddress.NULL,
+                    0,
+                    options,
+                    outAddress.baseAddress()));
+
+            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress.baseAddress());
+            TranslationUnit rv = new TranslationUnit(tu);
+            // even if we failed to parse, we might still have diagnostics
+            rv.processDiagnostics(dh);
+
+            if (code != ErrorCode.Success) {
+                throw new ParsingFailedException(Path.of(file).toAbsolutePath(), code);
+            }
+
+            translationUnits.add(rv);
+            return rv;
+        }
+    }
+
+    private int defaultOptions(boolean detailedPreprocessorRecord) {
+        int rv = Index_h.CXTranslationUnit_ForSerialization;
+        rv |= Index_h.CXTranslationUnit_SkipFunctionBodies;
+        if (detailedPreprocessorRecord) {
+            rv |= Index_h.CXTranslationUnit_DetailedPreprocessingRecord;
+        }
+        return rv;
+    }
+
+    public TranslationUnit parse(String file, Consumer<Diagnostic> dh, boolean detailedPreprocessorRecord, String... args)
+    throws ParsingFailedException {
+        return parseTU(file, dh, defaultOptions(detailedPreprocessorRecord), args);
+    }
+
+    public TranslationUnit parse(String file, boolean detailedPreprocessorRecord, String... args)
+    throws ParsingFailedException {
+        return parse(file, dh -> {}, detailedPreprocessorRecord, args);
+    }
+
+    @Override
+    public void close() {
+        dispose();
+    }
+
+    public void dispose() {
+        for (TranslationUnit tu: translationUnits) {
+            tu.dispose();
+        }
+        if (ptr != MemoryAddress.NULL) {
+            Index_h.clang_disposeIndex(ptr);
+        }
+        ptr = MemoryAddress.NULL;
+    }
+
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/LibClang.java
@@ -0,0 +1,84 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.clang.libclang.Index_h;
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.jextract.impl.LayoutUtils;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+
+public class LibClang {
+    private static final boolean DEBUG = Boolean.getBoolean("libclang.debug");
+    private static final boolean CRASH_RECOVERY = Boolean.getBoolean("libclang.crash_recovery");
+
+    private final static MemorySegment disableCrashRecovery =
+            Utils.toNativeString("LIBCLANG_DISABLE_CRASH_RECOVERY=" + CRASH_RECOVERY)
+                .withAccessModes(MemorySegment.READ);
+
+    static {
+        if (!CRASH_RECOVERY) {
+            //this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the
+            //first call to createIndex.
+            try {
+                SystemABI abi = InternalForeign.getInstancePrivileged().getSystemABI();
+                String putenv = abi.name().equals(SystemABI.ABI_WINDOWS) ?
+                        "_putenv" : "putenv";
+                MethodHandle PUT_ENV = abi.downcallHandle(LibraryLookup.ofDefault().lookup(putenv),
+                                MethodType.methodType(int.class, MemoryAddress.class),
+                                FunctionDescriptor.of(LayoutUtils.C_INT, LayoutUtils.C_POINTER));
+                int res = (int) PUT_ENV.invokeExact(disableCrashRecovery.baseAddress());
+            } catch (Throwable ex) {
+                throw new ExceptionInInitializerError(ex);
+            }
+        }
+    }
+
+    public static Index createIndex(boolean local) {
+        Index index = new Index(Index_h.clang_createIndex(local ? 1 : 0, 0));
+        if (DEBUG) {
+            System.err.println("LibClang crash recovery " + (CRASH_RECOVERY ? "enabled" : "disabled"));
+        }
+        return index;
+    }
+
+    public static String CXStrToString(MemorySegment cxstr) {
+        MemoryAddress buf = Index_h.clang_getCString(cxstr);
+        String str = Utils.toJavaString(buf);
+        Index_h.clang_disposeString(cxstr);
+        return str;
+    }
+
+    public static String version() {
+        return CXStrToString(Index_h.clang_getClangVersion());
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicy.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicy.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicy.java
@@ -0,0 +1,62 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.internal.clang.libclang.Index_h;
+
+public final class PrintingPolicy implements AutoCloseable {
+    private MemoryAddress policy;
+
+    PrintingPolicy(MemoryAddress policy) {
+        this.policy = policy;
+    }
+
+    MemoryAddress ptr() {
+        return policy;
+    }
+
+    @Override
+    public void close() {
+        dispose();
+    }
+
+    public void dispose() {
+        if (policy != MemoryAddress.NULL) {
+            Index_h.clang_PrintingPolicy_dispose(policy);
+            policy = MemoryAddress.NULL;
+        }
+    }
+
+    public boolean getProperty(PrintingPolicyProperty prop) {
+        return Index_h.clang_PrintingPolicy_getProperty(policy, prop.value()) != 0;
+    }
+
+    public void setProperty(PrintingPolicyProperty prop, boolean value) {
+        Index_h.clang_PrintingPolicy_setProperty(policy, prop.value(), value? 1 : 0);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicyProperty.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicyProperty.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/PrintingPolicyProperty.java
@@ -0,0 +1,88 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public enum PrintingPolicyProperty {
+    Indentation(0),
+    SuppressSpecifiers(1),
+    SuppressTagKeyword(2),
+    IncludeTagDefinition(3),
+    SuppressScope(4),
+    SuppressUnwrittenScope(5),
+    SuppressInitializers(6),
+    ConstantArraySizeAsWritten(7),
+    AnonymousTagLocations(8),
+    SuppressStrongLifetime(9),
+    SuppressLifetimeQualifiers(10),
+    SuppressTemplateArgsInCXXConstructors(11),
+    Bool(12),
+    Restrict(13),
+    Alignof(14),
+    UnderscoreAlignof(15),
+    UseVoidForZeroParams(16),
+    TerseOutput(17),
+    PolishForDeclaration(18),
+    Half(19),
+    MSWChar(20),
+    IncludeNewlines(21),
+    MSVCFormatting(22),
+    ConstantsAsWritten(23),
+    SuppressImplicitBase(24),
+    FullyQualifiedName(25),
+    LastProperty(25);
+
+    private final int value;
+
+    PrintingPolicyProperty(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, PrintingPolicyProperty> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (PrintingPolicyProperty e: PrintingPolicyProperty.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static PrintingPolicyProperty valueOf(int value) {
+        PrintingPolicyProperty x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("Invalid PrintingPolicyProperty value: " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/RefQualifierKind.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/RefQualifierKind.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/RefQualifierKind.java
@@ -0,0 +1,67 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public enum RefQualifierKind {
+    /** No ref-qualifier was provided. */
+    CXRefQualifier_None(0),
+    /** An lvalue ref-qualifier was provided (\c &). */
+    CXRefQualifier_LValue(1),
+    /** An rvalue ref-qualifier was provided (\c &&). */
+    CXRefQualifier_RValue(2);
+
+    private final int value;
+
+    RefQualifierKind(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, RefQualifierKind> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (RefQualifierKind e: RefQualifierKind.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static RefQualifierKind valueOf(int value) {
+        RefQualifierKind x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("Invalid RefQualifierKind kind value: " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SaveError.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SaveError.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SaveError.java
@@ -0,0 +1,61 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import java.util.Arrays;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.function.Function;
+
+import static java.util.stream.Collectors.toMap;
+import static jdk.internal.clang.libclang.Index_h.CXSaveError_InvalidTU;
+import static jdk.internal.clang.libclang.Index_h.CXSaveError_None;
+import static jdk.internal.clang.libclang.Index_h.CXSaveError_TranslationErrors;
+import static jdk.internal.clang.libclang.Index_h.CXSaveError_Unknown;
+
+public enum SaveError {
+    None(CXSaveError_None),
+    Unknown(CXSaveError_Unknown),
+    TranslationErrors(CXSaveError_TranslationErrors),
+    InvalidTU(CXSaveError_InvalidTU);
+
+    private final int code;
+
+    SaveError(int code) {
+        this.code = code;
+    }
+
+    public int code() {
+        return code;
+    }
+
+    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())
+            .collect(toMap(SaveError::code, Function.identity()));
+
+    public static SaveError valueOf(int code) {
+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException("No SaveError with code: " + k); });
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceLocation.java
@@ -0,0 +1,157 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+import jdk.internal.jextract.impl.LayoutUtils;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Objects;
+
+public class SourceLocation {
+
+    private final MemorySegment loc;
+
+    SourceLocation(MemorySegment loc) {
+        this.loc = loc;
+    }
+
+    @FunctionalInterface
+    private interface LocationFactory {
+        void get(MemorySegment loc, MemoryAddress file,
+                 MemoryAddress line, MemoryAddress column, MemoryAddress offset);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Location getLocation(LocationFactory fn) {
+        try (MemorySegment file = MemorySegment.allocateNative(LayoutUtils.C_POINTER);
+             MemorySegment line = MemorySegment.allocateNative(LayoutUtils.C_INT);
+             MemorySegment col = MemorySegment.allocateNative(LayoutUtils.C_INT);
+             MemorySegment offset = MemorySegment.allocateNative(LayoutUtils.C_INT)) {
+
+            fn.get(loc, file.baseAddress(), line.baseAddress(), col.baseAddress(), offset.baseAddress());
+            MemoryAddress fname = Utils.getPointer(file.baseAddress());
+
+
+            String str = fname == MemoryAddress.NULL ?
+                    null :
+                    LibClang.CXStrToString(Index_h.clang_getFileName(fname));
+
+            return new Location(str, Utils.getInt(line.baseAddress()),
+                Utils.getInt(col.baseAddress()), Utils.getInt(offset.baseAddress()));
+        }
+    }
+
+    public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }
+    public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }
+    public Location getSpellingLocation() { return getLocation(Index_h::clang_getSpellingLocation); }
+    public boolean isInSystemHeader() {
+        return Index_h.clang_Location_isInSystemHeader(loc) != 0;
+    }
+
+    public boolean isFromMainFile() {
+        return Index_h.clang_Location_isFromMainFile(loc) != 0;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (!(other instanceof SourceLocation)) {
+            return false;
+        }
+        SourceLocation sloc = (SourceLocation)other;
+        return Objects.equals(getFileLocation(), sloc.getFileLocation());
+    }
+
+    @Override
+    public int hashCode() {
+        return getFileLocation().hashCode();
+    }
+
+    public final static class Location {
+        private final Path path;
+        private final int line;
+        private final int column;
+        private final int offset;
+
+        private Location(String filename, int line, int column, int offset) {
+            if (filename == null || filename.isEmpty()) {
+                this.path = null;
+            } else {
+                this.path = Paths.get(filename);
+            }
+
+            this.line = line;
+            this.column = column;
+            this.offset = offset;
+        }
+
+        public Path path() {
+            return path;
+        }
+
+        public int line() {
+            return line;
+        }
+
+        public int column() {
+            return column;
+        }
+
+        public int offset() {
+            return offset;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (this == other) {
+                return true;
+            }
+            if (!(other instanceof Location)) {
+                return false;
+            }
+            Location loc = (Location)other;
+            return Objects.equals(path, loc.path) &&
+                line == loc.line && column == loc.column &&
+                offset == loc.offset;
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hashCode(path) ^ line ^ column ^ offset;
+        }
+
+        @Override
+        public String toString() {
+            return Objects.toString(path) + ":" + line + ":" + column + ":" + offset;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceRange.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceRange.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/SourceRange.java
@@ -0,0 +1,47 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+
+public class SourceRange {
+    final MemorySegment range;
+
+    SourceRange(MemorySegment range) {
+        this.range = range;
+    }
+
+    public SourceLocation getBegin() {
+        MemorySegment loc = Index_h.clang_getRangeStart(range);
+        return new SourceLocation(loc);
+    }
+
+    public SourceLocation getEnd() {
+        MemorySegment loc = Index_h.clang_getRangeEnd(range);
+        return new SourceLocation(loc);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TemplateArgumentKind.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TemplateArgumentKind.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TemplateArgumentKind.java
@@ -0,0 +1,75 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+/**
+ * Describes the kind of a template argument.
+ */
+public enum TemplateArgumentKind {
+    Null(0),
+    Type(1),
+    Declaration(2),
+    NullPtr(3),
+    Integral(4),
+    Template(5),
+    TemplateExpansion(6),
+    Expression(7),
+    Pack(8),
+    /* Indicates an error case, preventing the kind from being deduced. */
+    Invalid(9);
+
+    private final int value;
+
+    TemplateArgumentKind(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, TemplateArgumentKind> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (TemplateArgumentKind e: TemplateArgumentKind.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static TemplateArgumentKind valueOf(int value) {
+        TemplateArgumentKind x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("Invalid TemplateArgumentKind kind value: " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TranslationUnit.java
@@ -0,0 +1,223 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.Foreign;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.jextract.impl.LayoutUtils;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.Objects;
+import java.util.function.Consumer;
+
+public class TranslationUnit implements AutoCloseable {
+    private static final Foreign FOREIGN = InternalForeign.getInstancePrivileged();
+
+    private MemoryAddress tu;
+
+    TranslationUnit(MemoryAddress tu) {
+        this.tu = tu;
+    }
+
+    public Cursor getCursor() {
+        return new Cursor(Index_h.clang_getTranslationUnitCursor(tu));
+    }
+
+    public Diagnostic[] getDiagnostics() {
+        int cntDiags = Index_h.clang_getNumDiagnostics(tu);
+        Diagnostic[] rv = new Diagnostic[cntDiags];
+        for (int i = 0; i < cntDiags; i++) {
+            MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);
+            rv[i] = new Diagnostic(diag);
+        }
+
+        return rv;
+    }
+
+    public final void save(Path path) throws TranslationUnitSaveException {
+        try (MemorySegment pathStr = Utils.toNativeString(path.toAbsolutePath().toString())) {
+            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr.baseAddress(), 0));
+            if (res != SaveError.None) {
+                throw new TranslationUnitSaveException(path, res);
+            }
+        }
+    }
+
+    void processDiagnostics(Consumer<Diagnostic> dh) {
+        Objects.requireNonNull(dh);
+        for (Diagnostic diag : getDiagnostics()) {
+            dh.accept(diag);
+        }
+    }
+
+    static long FILENAME_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement("Filename")) / 8;
+    static long CONTENTS_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement("Contents")) / 8;
+    static long LENGTH_OFFSET = Index_h.CXUnsavedFile$LAYOUT.offset(MemoryLayout.PathElement.groupElement("Length")) / 8;
+
+    public void reparse(Index.UnsavedFile... inMemoryFiles) {
+        try (AllocationScope scope = new AllocationScope()) {
+            MemorySegment files = inMemoryFiles.length == 0 ?
+                    null :
+                    scope.track(MemorySegment.allocateNative(MemoryLayout.ofSequence(inMemoryFiles.length, Index_h.CXUnsavedFile$LAYOUT)));
+            for (int i = 0; i < inMemoryFiles.length; i++) {
+                MemoryAddress start = files.baseAddress().addOffset(i * Index_h.CXUnsavedFile$LAYOUT.byteSize());
+                Utils.setPointer(start.addOffset(FILENAME_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].file)).baseAddress());
+                Utils.setPointer(start.addOffset(CONTENTS_OFFSET), scope.track(Utils.toNativeString(inMemoryFiles[i].contents)).baseAddress());
+                Utils.setLong(start.addOffset(LENGTH_OFFSET), inMemoryFiles[i].contents.length());
+            }
+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(
+                        tu,
+                        inMemoryFiles.length,
+                        files == null ? MemoryAddress.NULL : files.baseAddress(),
+                        Index_h.clang_defaultReparseOptions(tu)));
+
+            if (code != ErrorCode.Success) {
+                throw new IllegalStateException("Re-parsing failed: " + code);
+            }
+        }
+    }
+
+    public void reparse(Consumer<Diagnostic> dh, Index.UnsavedFile... inMemoryFiles) {
+        reparse(inMemoryFiles);
+        processDiagnostics(dh);
+    }
+
+    public String[] tokens(SourceRange range) {
+        Tokens tokens = tokenize(range);
+        String rv[] = new String[tokens.size()];
+        for (int i = 0; i < rv.length; i++) {
+            rv[i] = tokens.getToken(i).spelling();
+        }
+        return rv;
+    }
+
+    public Tokens tokenize(SourceRange range) {
+        MemorySegment p = MemorySegment.allocateNative(LayoutUtils.C_POINTER);
+        MemorySegment pCnt = MemorySegment.allocateNative(LayoutUtils.C_INT);
+        Index_h.clang_tokenize(tu, range.range, p.baseAddress(), pCnt.baseAddress());
+        Tokens rv = new Tokens(Utils.getPointer(p.baseAddress()), Utils.getInt(pCnt.baseAddress()));
+        return rv;
+    }
+
+    @Override
+    public void close() {
+        dispose();
+    }
+
+    public void dispose() {
+        if (tu != MemoryAddress.NULL) {
+            Index_h.clang_disposeTranslationUnit(tu);
+            tu = MemoryAddress.NULL;
+        }
+    }
+
+    public class Tokens {
+        private final MemoryAddress ar;
+        private final int size;
+
+        Tokens(MemoryAddress ar, int size) {
+            this.ar = ar;
+            this.size = size;
+        }
+
+        public void dispose() {
+            Index_h.clang_disposeTokens(tu, ar, size);
+        }
+
+        public int size() {
+            return size;
+        }
+
+        public MemorySegment getTokenSegment(int idx) {
+            MemoryAddress p = ar.addOffset(idx * Index_h.CXToken$LAYOUT.byteSize());
+            return FOREIGN.ofNativeUnchecked(p, Index_h.CXToken$LAYOUT.byteSize());
+        }
+
+        public Token getToken(int index) {
+            return new Token(getTokenSegment(index));
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+            for (int i = 0; i < size; i++) {
+                MemorySegment s = Index_h.clang_getTokenSpelling(tu, getTokenSegment(i));
+                sb.append("Token[");
+                sb.append(i);
+                sb.append("]=");
+                sb.append(LibClang.CXStrToString(s));
+                sb.append("\n");
+            }
+            return sb.toString();
+        }
+    }
+
+    public class Token {
+        final MemorySegment token;
+
+        Token(MemorySegment token) {
+            this.token = token;
+        }
+
+        public int kind() {
+            return Index_h.clang_getTokenKind(token);
+        }
+
+        public String spelling() {
+            MemorySegment s = Index_h.clang_getTokenSpelling(
+                    tu, token);
+            return LibClang.CXStrToString(s);
+        }
+
+        public SourceLocation getLocation() {
+            return new SourceLocation(Index_h.clang_getTokenLocation(
+                    tu, token));
+        }
+
+        public SourceRange getExtent() {
+            return new SourceRange(Index_h.clang_getTokenExtent(
+                    tu, token));
+        }
+    }
+
+    public static class TranslationUnitSaveException extends IOException {
+
+        static final long serialVersionUID = 1L;
+
+        private final SaveError error;
+
+        TranslationUnitSaveException(Path path, SaveError error) {
+            super("Cannot save translation unit to: " + path.toAbsolutePath() + ". Error: " + error);
+            this.error = error;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Type.java
@@ -0,0 +1,233 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.MemorySegment;
+import jdk.internal.clang.libclang.Index_h;
+
+
+public final class Type {
+    private final MemorySegment type;
+    Type(MemorySegment type) {
+        this.type = type;
+    }
+
+    public boolean isInvalid() {
+        return kind() == TypeKind.Invalid;
+    }
+
+    // Function Types
+    public boolean isVariadic() {
+        return Index_h.clang_isFunctionTypeVariadic(type) != 0;
+    }
+    public Type resultType() {
+        return new Type(Index_h.clang_getResultType(type));
+    }
+    public int numberOfArgs() {
+        return Index_h.clang_getNumArgTypes(type);
+    }
+    public Type argType(int idx) {
+        return new Type(Index_h.clang_getArgType(type, idx));
+    }
+    private int getCallingConvention0() {
+        return Index_h.clang_getFunctionTypeCallingConv(type);
+    }
+
+    public CallingConvention getCallingConvention() {
+        int v = getCallingConvention0();
+        return CallingConvention.valueOf(v);
+    }
+
+    /**
+     * Retrieve the ref-qualifier kind of a function or method.
+     *
+     * The ref-qualifier is returned for C++ functions or methods. For other types
+     * or non-C++ declarations, CXRefQualifier_None is returned.
+     */
+    public RefQualifierKind getRefQualifier() {
+        int refKind = Index_h.clang_Type_getCXXRefQualifier(type);
+        return RefQualifierKind.valueOf(refKind);
+    }
+
+    public boolean isPointer() {
+        var kind = kind();
+        return kind == TypeKind.Pointer ||
+            kind == TypeKind.BlockPointer || kind == TypeKind.MemberPointer;
+    }
+
+    public boolean isReference() {
+        var kind = kind();
+        return kind == TypeKind.LValueReference || kind == TypeKind.RValueReference;
+    }
+
+    public boolean isArray() {
+        var kind = kind();
+        return kind == TypeKind.ConstantArray ||
+           kind == TypeKind.IncompleteArray ||
+           kind == TypeKind.VariableArray ||
+           kind == TypeKind.DependentSizedArray;
+    }
+
+    // Pointer type
+    public Type getPointeeType() {
+        return new Type(Index_h.clang_getPointeeType(type));
+    }
+
+    // array/vector type
+    public Type getElementType() {
+        return new Type(Index_h.clang_getElementType(type));
+    }
+
+    public long getNumberOfElements() {
+        return Index_h.clang_getNumElements(type);
+    }
+
+    // Struct/RecordType
+    private long getOffsetOf0(String fieldName) {
+        try (MemorySegment cfname = Utils.toNativeString(fieldName)) {
+            return Index_h.clang_Type_getOffsetOf(type, cfname.baseAddress());
+        }
+    }
+
+    public long getOffsetOf(String fieldName) {
+        long res = getOffsetOf0(fieldName);
+        if(TypeLayoutError.isError(res)) {
+            throw new TypeLayoutError(res, String.format("type: %s, fieldName: %s", this, fieldName));
+        }
+        return res;
+    }
+
+    // Typedef
+    /**
+     * Return the canonical type for a Type.
+     *
+     * Clang's type system explicitly models typedefs and all the ways
+     * a specific type can be represented.  The canonical type is the underlying
+     * type with all the "sugar" removed.  For example, if 'T' is a typedef
+     * for 'int', the canonical type for 'T' would be 'int'.
+     */
+    public Type canonicalType() {
+        return new Type(Index_h.clang_getCanonicalType(type));
+    }
+
+    /**
+     * Determine whether a Type has the "const" qualifier set,
+     * without looking through typedefs that may have added "const" at a
+     * different level.
+     */
+    public boolean isConstQualifierdType() {
+        return Index_h.clang_isConstQualifiedType(type) != 0;
+    }
+
+    /**
+     * Determine whether a Type has the "volatile" qualifier set,
+     * without looking through typedefs that may have added "volatile" at
+     * a different level.
+     */
+    public boolean isVolatileQualified() {
+        return Index_h.clang_isVolatileQualifiedType(type) != 0;
+    }
+
+    /**
+     * Return true if the Type is a POD (plain old data) type, and false
+     * otherwise.
+     */
+    public boolean isPODType() {
+        return Index_h.clang_isPODType(type) != 0;
+    }
+
+    // Template support
+    /**
+     * Returns the number of template arguments for given template
+     * specialization, or -1 if type \c T is not a template specialization.
+     */
+    public int numberOfTemplateArgs() {
+        return Index_h.clang_Type_getNumTemplateArguments(type);
+    }
+
+    /**
+     * Returns the type template argument of a template class specialization
+     * at given index.
+     *
+     * This function only returns template type arguments and does not handle
+     * template template arguments or variadic packs.
+     */
+    public Type templateArgAsType(int idx) {
+        return new Type(Index_h.clang_Type_getTemplateArgumentAsType(type, idx));
+    }
+
+    public String spelling() {
+        return LibClang.CXStrToString(Index_h.clang_getTypeSpelling(type));
+    }
+
+    public int kind0() {
+        return Index_h.CXType$kind$get(type);
+    }
+
+    private long size0() {
+        return Index_h.clang_Type_getSizeOf(type);
+    }
+
+    public long size() {
+        long res = size0();
+        if(TypeLayoutError.isError(res)) {
+            throw new TypeLayoutError(res, String.format("type: %s", this));
+        }
+        return res;
+    }
+
+    public TypeKind kind() {
+        int v = kind0();
+        TypeKind rv = TypeKind.valueOf(v);
+        // TODO: Atomic type doesn't work
+        return rv;
+    }
+
+    public Cursor getDeclarationCursor() {
+        return new Cursor(Index_h.clang_getTypeDeclaration(type));
+    }
+
+    public boolean equalType(Type other) {
+        return Index_h.clang_equalTypes(type, other.type) != 0;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        if (this == other) {
+            return true;
+        }
+        if (!(other instanceof Type)) {
+            return false;
+        }
+        return equalType((Type) other);
+    }
+
+    @Override
+    public int hashCode() {
+        return spelling().hashCode();
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeKind.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeKind.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeKind.java
@@ -0,0 +1,178 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public enum TypeKind {
+
+    Invalid(0),
+    Unexposed(1),
+    Void(2),
+    Bool(3),
+    Char_U(4),
+    UChar(5),
+    Char16(6),
+    Char32(7),
+    UShort(8),
+    UInt(9),
+    ULong(10),
+    ULongLong(11),
+    UInt128(12),
+    Char_S(13),
+    SChar(14),
+    WChar(15),
+    Short(16),
+    Int(17),
+    Long(18),
+    LongLong(19),
+    Int128(20),
+    Float(21),
+    Double(22),
+    LongDouble(23),
+    NullPtr(24),
+    Overload(25),
+    Dependent(26),
+    ObjCId(27),
+    ObjCClass(28),
+    ObjCSel(29),
+    Float128(30),
+    Half(31),
+    Float16(32),
+    ShortAccum(33),
+    Accum(34),
+    LongAccum(35),
+    UShortAccum(36),
+    UAccum(37),
+    ULongAccum(38),
+    Complex(100),
+    Pointer(101),
+    BlockPointer(102),
+    LValueReference(103),
+    RValueReference(104),
+    Record(105),
+    Enum(106),
+    Typedef(107),
+    ObjCInterface(108),
+    ObjCObjectPointer(109),
+    FunctionNoProto(110),
+    FunctionProto(111),
+    ConstantArray(112),
+    Vector(113),
+    IncompleteArray(114),
+    VariableArray(115),
+    DependentSizedArray(116),
+    MemberPointer(117),
+    Auto(118),
+    Elaborated(119),
+    Pipe(120),
+    OCLImage1dRO(121),
+    OCLImage1dArrayRO(122),
+    OCLImage1dBufferRO(123),
+    OCLImage2dRO(124),
+    OCLImage2dArrayRO(125),
+    OCLImage2dDepthRO(126),
+    OCLImage2dArrayDepthRO(127),
+    OCLImage2dMSAARO(128),
+    OCLImage2dArrayMSAARO(129),
+    OCLImage2dMSAADepthRO(130),
+    OCLImage2dArrayMSAADepthRO(131),
+    OCLImage3dRO(132),
+    OCLImage1dWO(133),
+    OCLImage1dArrayWO(134),
+    OCLImage1dBufferWO(135),
+    OCLImage2dWO(136),
+    OCLImage2dArrayWO(137),
+    OCLImage2dDepthWO(138),
+    OCLImage2dArrayDepthWO(139),
+    OCLImage2dMSAAWO(140),
+    OCLImage2dArrayMSAAWO(141),
+    OCLImage2dMSAADepthWO(142),
+    OCLImage2dArrayMSAADepthWO(143),
+    OCLImage3dWO(144),
+    OCLImage1dRW(145),
+    OCLImage1dArrayRW(146),
+    OCLImage1dBufferRW(147),
+    OCLImage2dRW(148),
+    OCLImage2dArrayRW(149),
+    OCLImage2dDepthRW(150),
+    OCLImage2dArrayDepthRW(151),
+    OCLImage2dMSAARW(152),
+    OCLImage2dArrayMSAARW(153),
+    OCLImage2dMSAADepthRW(154),
+    OCLImage2dArrayMSAADepthRW(155),
+    OCLImage3dRW(156),
+    OCLSampler(157),
+    OCLEvent(158),
+    OCLQueue(159),
+    OCLReserveID(160),
+    ObjCObject(161),
+    ObjCTypeParam(162),
+    Attributed(163),
+    OCLIntelSubgroupAVCMcePayload(164),
+    OCLIntelSubgroupAVCImePayload(165),
+    OCLIntelSubgroupAVCRefPayload(166),
+    OCLIntelSubgroupAVCSicPayload(167),
+    OCLIntelSubgroupAVCMceResult(168),
+    OCLIntelSubgroupAVCImeResult(169),
+    OCLIntelSubgroupAVCRefResult(170),
+    OCLIntelSubgroupAVCSicResult(171),
+    OCLIntelSubgroupAVCImeResultSingleRefStreamout(172),
+    OCLIntelSubgroupAVCImeResultDualRefStreamout(173),
+    OCLIntelSubgroupAVCImeSingleRefStreamin(174),
+    OCLIntelSubgroupAVCImeDualRefStreamin(175),
+    ExtVector(176),
+    Atomic(177);
+
+    private final int value;
+
+    TypeKind(int value) {
+        this.value = value;
+    }
+
+    public int value() {
+        return value;
+    }
+
+    private final static Map<Integer, TypeKind> lookup;
+
+    static {
+        lookup = new HashMap<>();
+        for (TypeKind e: TypeKind.values()) {
+            lookup.put(e.value(), e);
+        }
+    }
+
+    public final static TypeKind valueOf(int value) {
+        TypeKind x = lookup.get(value);
+        if (null == x) {
+            throw new NoSuchElementException("kind = " + value);
+        }
+        return x;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeLayoutError.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeLayoutError.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/TypeLayoutError.java
@@ -0,0 +1,86 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NoSuchElementException;
+
+public class TypeLayoutError extends IllegalStateException {
+
+    private static final long serialVersionUID = 0L;
+
+    private final Kind kind;
+
+    public TypeLayoutError(long value, String message) {
+        super(Kind.valueOf(value) + ". " + message);
+        this.kind = Kind.valueOf(value);
+    }
+
+    public Kind kind() {
+        return kind;
+    }
+
+    public static boolean isError(long value) {
+        return Kind.isError(value);
+    }
+
+    public enum Kind {
+        Invalid(-1),
+        Incomplete(-2),
+        Dependent(-3),
+        NotConstantSize(-4),
+        InvalidFieldName(-5);
+
+        private final long value;
+
+        Kind(long value) {
+            this.value = value;
+        }
+
+        private final static Map<Long, Kind> lookup;
+
+        static {
+            lookup = new HashMap<>();
+            for (Kind e: Kind.values()) {
+                lookup.put(e.value, e);
+            }
+        }
+
+        public final static Kind valueOf(long value) {
+            Kind x = lookup.get(value);
+            if (null == x) {
+                throw new NoSuchElementException("TypeLayoutError = " + value);
+            }
+            return x;
+        }
+
+        public static boolean isError(long value) {
+            return lookup.containsKey(value);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/Utils.java
@@ -0,0 +1,156 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryHandles;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.jextract.impl.LayoutUtils;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+
+public class Utils {
+    public static final VarHandle BYTE_VH = LayoutUtils.C_CHAR.varHandle(byte.class);
+    public static final VarHandle BYTE_ARR_VH = MemoryHandles.withStride(BYTE_VH, 1);
+    public static final VarHandle INT_VH = LayoutUtils.C_INT.varHandle(int.class);
+    public static final VarHandle LONG_VH = LayoutUtils.C_LONGLONG.varHandle(long.class);
+    public static final VarHandle POINTER_VH = LayoutUtils.C_POINTER.varHandle(MemoryAddress.class);
+    public static final VarHandle POINTER_ARR_VH = MemoryHandles.withStride(POINTER_VH, 8);
+
+    private static final MethodHandle STRLEN;
+    private static final MethodHandle STRCPY;
+
+    static {
+        try {
+            STRLEN = InternalForeign.getInstancePrivileged().getSystemABI().downcallHandle(
+                    LibraryLookup.ofDefault().lookup("strlen"),
+                    MethodType.methodType(int.class, MemoryAddress.class),
+                    FunctionDescriptor.of(LayoutUtils.C_INT, LayoutUtils.C_POINTER));
+
+            STRCPY = InternalForeign.getInstancePrivileged().getSystemABI().downcallHandle(
+                    LibraryLookup.ofDefault().lookup("strcpy"),
+                    MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),
+                    FunctionDescriptor.of(LayoutUtils.C_POINTER, LayoutUtils.C_POINTER, LayoutUtils.C_POINTER));
+        } catch (Throwable ex) {
+            throw new ExceptionInInitializerError(ex);
+        }
+    }
+
+    static int getInt(MemoryAddress addr) {
+        return (int)INT_VH.get(addr);
+    }
+
+    static void setInt(MemoryAddress addr, int i) {
+        INT_VH.set(addr, i);
+    }
+
+    static int getLong(MemoryAddress addr) {
+        return (int)LONG_VH.get(addr);
+    }
+
+    static void setLong(MemoryAddress addr, long i) {
+        LONG_VH.set(addr, i);
+    }
+
+    static byte getByte(MemoryAddress addr) {
+        return (byte)BYTE_VH.get(addr);
+    }
+
+    static MemoryAddress getPointer(MemoryAddress addr) {
+        return (MemoryAddress)POINTER_VH.get(addr);
+    }
+
+    static void setPointer(MemoryAddress addr, MemoryAddress ptr) {
+        POINTER_VH.set(addr, ptr);
+    }
+
+    static MemorySegment toNativeString(String value) {
+        return toNativeString(value, value.length() + 1);
+    }
+
+    static MemorySegment toNativeString(String value, int length) {
+        MemoryLayout strLayout = MemoryLayout.ofSequence(length, LayoutUtils.C_CHAR);
+        MemorySegment segment = MemorySegment.allocateNative(strLayout);
+        MemoryAddress addr = segment.baseAddress();
+        for (int i = 0 ; i < value.length() ; i++) {
+            BYTE_ARR_VH.set(addr, i, (byte)value.charAt(i));
+        }
+        BYTE_ARR_VH.set(addr, (long)value.length(), (byte)0);
+        return segment;
+    }
+
+    static int strlen(MemoryAddress str) {
+        try {
+            return (int)STRLEN.invokeExact(str);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    static MemoryAddress strcpy(MemoryAddress dest, MemoryAddress src) {
+        try {
+            return (MemoryAddress)STRCPY.invokeExact(dest, src);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+
+    static String toJavaString(MemoryAddress address) {
+        try (MemorySegment str = MemorySegment.allocateNative(strlen(address) + 1)) {
+            strcpy(str.baseAddress(), address);
+            StringBuilder buf = new StringBuilder();
+            byte curr = (byte)BYTE_ARR_VH.get(str.baseAddress(), 0);
+            long offset = 0;
+            while (curr != 0) {
+                buf.append((char)curr);
+                curr = (byte)BYTE_ARR_VH.get(str.baseAddress(), ++offset);
+            }
+            return buf.toString();
+        }
+    }
+
+    static MemorySegment toNativeStringArray(String[] ar) {
+        if (ar.length == 0) {
+            return null;
+        }
+
+        MemorySegment segment = MemorySegment.allocateNative(MemoryLayout.ofSequence(ar.length, LayoutUtils.C_POINTER));
+        for (int i = 0; i < ar.length; i++) {
+            POINTER_ARR_VH.set(segment.baseAddress(), i, toNativeString(ar[i]).baseAddress());
+        }
+
+        return segment;
+    }
+
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/Index_h.java
@@ -0,0 +1,7292 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+// Generated by jextract
+
+package jdk.internal.clang.libclang;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import jdk.incubator.foreign.MemorySegment;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.VarHandle;
+
+import static jdk.internal.jextract.impl.LayoutUtils.*; 
+        
+public final class Index_h {
+
+    private static String libName() {
+        if (System.getProperty("os.name").startsWith("Windows")) {
+            return "libclang";
+        }
+        return "clang";
+    }
+
+    private static final LibraryLookup[] LIBRARIES = RuntimeHelper.libraries(new String[] {libName()}, new String[] {});
+    public static final long NULL = 0L;
+    public static final int CINDEX_VERSION_MAJOR = (int)0L;
+    public static final int CINDEX_VERSION_MINOR = (int)59L;
+    public static final int CINDEX_VERSION = (int)59L;
+    public static final int CXError_Success = (int)0L;
+    public static final int CXError_Failure = (int)1L;
+    public static final int CXError_Crashed = (int)2L;
+    public static final int CXError_InvalidArguments = (int)3L;
+    public static final int CXError_ASTReadError = (int)4L;
+    public static final MemoryLayout CXString$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("data"),
+        C_INT.withName("private_flags"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXString$private_flags = CXString$LAYOUT.varHandle(int.class, PathElement.groupElement("private_flags"));
+    public static final int CXString$private_flags$get(MemorySegment seg) {
+        return (int)CXString$private_flags.get(seg.baseAddress());
+    }
+    public static final void CXString$private_flags$set(MemorySegment seg, int x) {
+        CXString$private_flags.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXStringSet$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("Strings"),
+        C_INT.withName("Count"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXStringSet$Count = CXStringSet$LAYOUT.varHandle(int.class, PathElement.groupElement("Count"));
+    public static final int CXStringSet$Count$get(MemorySegment seg) {
+        return (int)CXStringSet$Count.get(seg.baseAddress());
+    }
+    public static final void CXStringSet$Count$set(MemorySegment seg, int x) {
+        CXStringSet$Count.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getCString = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCString",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("private_flags"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemoryAddress clang_getCString (MemorySegment string) {
+        try {
+            return (MemoryAddress)clang_getCString.invokeExact(string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeString = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeString",
+        "(Ljdk/incubator/foreign/MemorySegment;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("private_flags"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final void clang_disposeString (MemorySegment string) {
+        try {
+            clang_disposeString.invokeExact(string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeStringSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeStringSet",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeStringSet (MemoryAddress set) {
+        try {
+            clang_disposeStringSet.invokeExact(set);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getBuildSessionTimestamp = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getBuildSessionTimestamp",
+        "()J",
+        FunctionDescriptor.of(C_LONGLONG)
+    );
+    public static final long clang_getBuildSessionTimestamp () {
+        try {
+            return (long)clang_getBuildSessionTimestamp.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_VirtualFileOverlay_create = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_VirtualFileOverlay_create",
+        "(I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_VirtualFileOverlay_create (int options) {
+        try {
+            return (MemoryAddress)clang_VirtualFileOverlay_create.invokeExact(options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_VirtualFileOverlay_addFileMapping = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_VirtualFileOverlay_addFileMapping",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_VirtualFileOverlay_addFileMapping (MemoryAddress x0, MemoryAddress virtualPath, MemoryAddress realPath) {
+        try {
+            return (int)clang_VirtualFileOverlay_addFileMapping.invokeExact(x0, virtualPath, realPath);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_VirtualFileOverlay_setCaseSensitivity = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_VirtualFileOverlay_setCaseSensitivity",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_VirtualFileOverlay_setCaseSensitivity (MemoryAddress x0, int caseSensitive) {
+        try {
+            return (int)clang_VirtualFileOverlay_setCaseSensitivity.invokeExact(x0, caseSensitive);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_VirtualFileOverlay_writeToBuffer = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_VirtualFileOverlay_writeToBuffer",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_VirtualFileOverlay_writeToBuffer (MemoryAddress x0, int options, MemoryAddress out_buffer_ptr, MemoryAddress out_buffer_size) {
+        try {
+            return (int)clang_VirtualFileOverlay_writeToBuffer.invokeExact(x0, options, out_buffer_ptr, out_buffer_size);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_free = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_free",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_free (MemoryAddress buffer) {
+        try {
+            clang_free.invokeExact(buffer);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_VirtualFileOverlay_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_VirtualFileOverlay_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_VirtualFileOverlay_dispose (MemoryAddress x0) {
+        try {
+            clang_VirtualFileOverlay_dispose.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_ModuleMapDescriptor_create = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_ModuleMapDescriptor_create",
+        "(I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_ModuleMapDescriptor_create (int options) {
+        try {
+            return (MemoryAddress)clang_ModuleMapDescriptor_create.invokeExact(options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_ModuleMapDescriptor_setFrameworkModuleName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_ModuleMapDescriptor_setFrameworkModuleName",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_ModuleMapDescriptor_setFrameworkModuleName (MemoryAddress x0, MemoryAddress name) {
+        try {
+            return (int)clang_ModuleMapDescriptor_setFrameworkModuleName.invokeExact(x0, name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_ModuleMapDescriptor_setUmbrellaHeader = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_ModuleMapDescriptor_setUmbrellaHeader",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_ModuleMapDescriptor_setUmbrellaHeader (MemoryAddress x0, MemoryAddress name) {
+        try {
+            return (int)clang_ModuleMapDescriptor_setUmbrellaHeader.invokeExact(x0, name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_ModuleMapDescriptor_writeToBuffer = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_ModuleMapDescriptor_writeToBuffer",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_ModuleMapDescriptor_writeToBuffer (MemoryAddress x0, int options, MemoryAddress out_buffer_ptr, MemoryAddress out_buffer_size) {
+        try {
+            return (int)clang_ModuleMapDescriptor_writeToBuffer.invokeExact(x0, options, out_buffer_ptr, out_buffer_size);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_ModuleMapDescriptor_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_ModuleMapDescriptor_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_ModuleMapDescriptor_dispose (MemoryAddress x0) {
+        try {
+            clang_ModuleMapDescriptor_dispose.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXUnsavedFile$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("Filename"),
+        C_POINTER.withName("Contents"),
+        C_LONGLONG.withName("Length")
+    ).withName("CXUnsavedFile");
+    public static final VarHandle CXUnsavedFile$Length = CXUnsavedFile$LAYOUT.varHandle(long.class, PathElement.groupElement("Length"));
+    public static final long CXUnsavedFile$Length$get(MemorySegment seg) {
+        return (long)CXUnsavedFile$Length.get(seg.baseAddress());
+    }
+    public static final void CXUnsavedFile$Length$set(MemorySegment seg, long x) {
+        CXUnsavedFile$Length.set(seg.baseAddress(), x);
+    }
+    public static final int CXAvailability_Available = (int)0L;
+    public static final int CXAvailability_Deprecated = (int)1L;
+    public static final int CXAvailability_NotAvailable = (int)2L;
+    public static final int CXAvailability_NotAccessible = (int)3L;
+    public static final MemoryLayout CXVersion$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("Major"),
+        C_INT.withName("Minor"),
+        C_INT.withName("Subminor")
+    ).withName("CXVersion");
+    public static final VarHandle CXVersion$Major = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Major"));
+    public static final int CXVersion$Major$get(MemorySegment seg) {
+        return (int)CXVersion$Major.get(seg.baseAddress());
+    }
+    public static final void CXVersion$Major$set(MemorySegment seg, int x) {
+        CXVersion$Major.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXVersion$Minor = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Minor"));
+    public static final int CXVersion$Minor$get(MemorySegment seg) {
+        return (int)CXVersion$Minor.get(seg.baseAddress());
+    }
+    public static final void CXVersion$Minor$set(MemorySegment seg, int x) {
+        CXVersion$Minor.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXVersion$Subminor = CXVersion$LAYOUT.varHandle(int.class, PathElement.groupElement("Subminor"));
+    public static final int CXVersion$Subminor$get(MemorySegment seg) {
+        return (int)CXVersion$Subminor.get(seg.baseAddress());
+    }
+    public static final void CXVersion$Subminor$set(MemorySegment seg, int x) {
+        CXVersion$Subminor.set(seg.baseAddress(), x);
+    }
+    public static final int CXCursor_ExceptionSpecificationKind_None = (int)0L;
+    public static final int CXCursor_ExceptionSpecificationKind_DynamicNone = (int)1L;
+    public static final int CXCursor_ExceptionSpecificationKind_Dynamic = (int)2L;
+    public static final int CXCursor_ExceptionSpecificationKind_MSAny = (int)3L;
+    public static final int CXCursor_ExceptionSpecificationKind_BasicNoexcept = (int)4L;
+    public static final int CXCursor_ExceptionSpecificationKind_ComputedNoexcept = (int)5L;
+    public static final int CXCursor_ExceptionSpecificationKind_Unevaluated = (int)6L;
+    public static final int CXCursor_ExceptionSpecificationKind_Uninstantiated = (int)7L;
+    public static final int CXCursor_ExceptionSpecificationKind_Unparsed = (int)8L;
+    public static final int CXCursor_ExceptionSpecificationKind_NoThrow = (int)9L;
+    public static final MethodHandle clang_createIndex = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_createIndex",
+        "(II)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_createIndex (int excludeDeclarationsFromPCH, int displayDiagnostics) {
+        try {
+            return (MemoryAddress)clang_createIndex.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeIndex = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeIndex",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeIndex (MemoryAddress index) {
+        try {
+            clang_disposeIndex.invokeExact(index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXGlobalOpt_None = (int)0L;
+    public static final int CXGlobalOpt_ThreadBackgroundPriorityForIndexing = (int)1L;
+    public static final int CXGlobalOpt_ThreadBackgroundPriorityForEditing = (int)2L;
+    public static final int CXGlobalOpt_ThreadBackgroundPriorityForAll = (int)3L;
+    public static final MethodHandle clang_CXIndex_setGlobalOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXIndex_setGlobalOptions",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final void clang_CXIndex_setGlobalOptions (MemoryAddress x0, int options) {
+        try {
+            clang_CXIndex_setGlobalOptions.invokeExact(x0, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXIndex_getGlobalOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXIndex_getGlobalOptions",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_CXIndex_getGlobalOptions (MemoryAddress x0) {
+        try {
+            return (int)clang_CXIndex_getGlobalOptions.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXIndex_setInvocationEmissionPathOption = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXIndex_setInvocationEmissionPathOption",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_CXIndex_setInvocationEmissionPathOption (MemoryAddress x0, MemoryAddress Path) {
+        try {
+            clang_CXIndex_setInvocationEmissionPathOption.invokeExact(x0, Path);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFileName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFileName",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getFileName (MemoryAddress SFile) {
+        try {
+            return (MemorySegment)clang_getFileName.invokeExact(SFile);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFileTime = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFileTime",
+        "(Ljdk/incubator/foreign/MemoryAddress;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            C_POINTER
+        )
+    );
+    public static final long clang_getFileTime (MemoryAddress SFile) {
+        try {
+            return (long)clang_getFileTime.invokeExact(SFile);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXFileUniqueID$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofSequence(3, C_LONGLONG).withName("data")
+    );
+    public static final MethodHandle clang_getFileUniqueID = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFileUniqueID",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_getFileUniqueID (MemoryAddress file, MemoryAddress outID) {
+        try {
+            return (int)clang_getFileUniqueID.invokeExact(file, outID);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isFileMultipleIncludeGuarded = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isFileMultipleIncludeGuarded",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_isFileMultipleIncludeGuarded (MemoryAddress tu, MemoryAddress file) {
+        try {
+            return (int)clang_isFileMultipleIncludeGuarded.invokeExact(tu, file);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getFile (MemoryAddress tu, MemoryAddress file_name) {
+        try {
+            return (MemoryAddress)clang_getFile.invokeExact(tu, file_name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFileContents = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFileContents",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getFileContents (MemoryAddress tu, MemoryAddress file, MemoryAddress size) {
+        try {
+            return (MemoryAddress)clang_getFileContents.invokeExact(tu, file, size);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_File_isEqual = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_File_isEqual",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_File_isEqual (MemoryAddress file1, MemoryAddress file2) {
+        try {
+            return (int)clang_File_isEqual.invokeExact(file1, file2);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_File_tryGetRealPathName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_File_tryGetRealPathName",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_File_tryGetRealPathName (MemoryAddress file) {
+        try {
+            return (MemorySegment)clang_File_tryGetRealPathName.invokeExact(file);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXSourceLocation$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+        C_INT.withName("int_data"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXSourceLocation$int_data = CXSourceLocation$LAYOUT.varHandle(int.class, PathElement.groupElement("int_data"));
+    public static final int CXSourceLocation$int_data$get(MemorySegment seg) {
+        return (int)CXSourceLocation$int_data.get(seg.baseAddress());
+    }
+    public static final void CXSourceLocation$int_data$set(MemorySegment seg, int x) {
+        CXSourceLocation$int_data.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXSourceRange$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+        C_INT.withName("begin_int_data"),
+        C_INT.withName("end_int_data")
+    );
+    public static final VarHandle CXSourceRange$begin_int_data = CXSourceRange$LAYOUT.varHandle(int.class, PathElement.groupElement("begin_int_data"));
+    public static final int CXSourceRange$begin_int_data$get(MemorySegment seg) {
+        return (int)CXSourceRange$begin_int_data.get(seg.baseAddress());
+    }
+    public static final void CXSourceRange$begin_int_data$set(MemorySegment seg, int x) {
+        CXSourceRange$begin_int_data.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXSourceRange$end_int_data = CXSourceRange$LAYOUT.varHandle(int.class, PathElement.groupElement("end_int_data"));
+    public static final int CXSourceRange$end_int_data$get(MemorySegment seg) {
+        return (int)CXSourceRange$end_int_data.get(seg.baseAddress());
+    }
+    public static final void CXSourceRange$end_int_data$set(MemorySegment seg, int x) {
+        CXSourceRange$end_int_data.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getNullLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNullLocation",
+        "()Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ))
+    );
+    public static final MemorySegment clang_getNullLocation () {
+        try {
+            return (MemorySegment)clang_getNullLocation.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_equalLocations = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_equalLocations",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final int clang_equalLocations (MemorySegment loc1, MemorySegment loc2) {
+        try {
+            return (int)clang_equalLocations.invokeExact(loc1, loc2);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getLocation",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;II)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getLocation (MemoryAddress tu, MemoryAddress file, int line, int column) {
+        try {
+            return (MemorySegment)clang_getLocation.invokeExact(tu, file, line, column);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getLocationForOffset = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getLocationForOffset",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getLocationForOffset (MemoryAddress tu, MemoryAddress file, int offset) {
+        try {
+            return (MemorySegment)clang_getLocationForOffset.invokeExact(tu, file, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Location_isInSystemHeader = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Location_isInSystemHeader",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final int clang_Location_isInSystemHeader (MemorySegment location) {
+        try {
+            return (int)clang_Location_isInSystemHeader.invokeExact(location);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Location_isFromMainFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Location_isFromMainFile",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final int clang_Location_isFromMainFile (MemorySegment location) {
+        try {
+            return (int)clang_Location_isFromMainFile.invokeExact(location);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNullRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNullRange",
+        "()Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ))
+    );
+    public static final MemorySegment clang_getNullRange () {
+        try {
+            return (MemorySegment)clang_getNullRange.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getRange",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_getRange (MemorySegment begin, MemorySegment end) {
+        try {
+            return (MemorySegment)clang_getRange.invokeExact(begin, end);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_equalRanges = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_equalRanges",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            )
+        )
+    );
+    public static final int clang_equalRanges (MemorySegment range1, MemorySegment range2) {
+        try {
+            return (int)clang_equalRanges.invokeExact(range1, range2);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Range_isNull = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Range_isNull",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            )
+        )
+    );
+    public static final int clang_Range_isNull (MemorySegment range) {
+        try {
+            return (int)clang_Range_isNull.invokeExact(range);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getExpansionLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getExpansionLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getExpansionLocation (MemorySegment location, MemoryAddress file, MemoryAddress line, MemoryAddress column, MemoryAddress offset) {
+        try {
+            clang_getExpansionLocation.invokeExact(location, file, line, column, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getPresumedLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getPresumedLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getPresumedLocation (MemorySegment location, MemoryAddress filename, MemoryAddress line, MemoryAddress column) {
+        try {
+            clang_getPresumedLocation.invokeExact(location, filename, line, column);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getInstantiationLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getInstantiationLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getInstantiationLocation (MemorySegment location, MemoryAddress file, MemoryAddress line, MemoryAddress column, MemoryAddress offset) {
+        try {
+            clang_getInstantiationLocation.invokeExact(location, file, line, column, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getSpellingLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getSpellingLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getSpellingLocation (MemorySegment location, MemoryAddress file, MemoryAddress line, MemoryAddress column, MemoryAddress offset) {
+        try {
+            clang_getSpellingLocation.invokeExact(location, file, line, column, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFileLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFileLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getFileLocation (MemorySegment location, MemoryAddress file, MemoryAddress line, MemoryAddress column, MemoryAddress offset) {
+        try {
+            clang_getFileLocation.invokeExact(location, file, line, column, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getRangeStart = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getRangeStart",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getRangeStart (MemorySegment range) {
+        try {
+            return (MemorySegment)clang_getRangeStart.invokeExact(range);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getRangeEnd = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getRangeEnd",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getRangeEnd (MemorySegment range) {
+        try {
+            return (MemorySegment)clang_getRangeEnd.invokeExact(range);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXSourceRangeList$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("count"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("ranges")
+    );
+    public static final VarHandle CXSourceRangeList$count = CXSourceRangeList$LAYOUT.varHandle(int.class, PathElement.groupElement("count"));
+    public static final int CXSourceRangeList$count$get(MemorySegment seg) {
+        return (int)CXSourceRangeList$count.get(seg.baseAddress());
+    }
+    public static final void CXSourceRangeList$count$set(MemorySegment seg, int x) {
+        CXSourceRangeList$count.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getSkippedRanges = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getSkippedRanges",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getSkippedRanges (MemoryAddress tu, MemoryAddress file) {
+        try {
+            return (MemoryAddress)clang_getSkippedRanges.invokeExact(tu, file);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getAllSkippedRanges = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getAllSkippedRanges",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getAllSkippedRanges (MemoryAddress tu) {
+        try {
+            return (MemoryAddress)clang_getAllSkippedRanges.invokeExact(tu);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeSourceRangeList = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeSourceRangeList",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeSourceRangeList (MemoryAddress ranges) {
+        try {
+            clang_disposeSourceRangeList.invokeExact(ranges);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXDiagnostic_Ignored = (int)0L;
+    public static final int CXDiagnostic_Note = (int)1L;
+    public static final int CXDiagnostic_Warning = (int)2L;
+    public static final int CXDiagnostic_Error = (int)3L;
+    public static final int CXDiagnostic_Fatal = (int)4L;
+    public static final MethodHandle clang_getNumDiagnosticsInSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumDiagnosticsInSet",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getNumDiagnosticsInSet (MemoryAddress Diags) {
+        try {
+            return (int)clang_getNumDiagnosticsInSet.invokeExact(Diags);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticInSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticInSet",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_getDiagnosticInSet (MemoryAddress Diags, int Index) {
+        try {
+            return (MemoryAddress)clang_getDiagnosticInSet.invokeExact(Diags, Index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXLoadDiag_None = (int)0L;
+    public static final int CXLoadDiag_Unknown = (int)1L;
+    public static final int CXLoadDiag_CannotLoad = (int)2L;
+    public static final int CXLoadDiag_InvalidFile = (int)3L;
+    public static final MethodHandle clang_loadDiagnostics = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_loadDiagnostics",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_loadDiagnostics (MemoryAddress file, MemoryAddress error, MemoryAddress errorString) {
+        try {
+            return (MemoryAddress)clang_loadDiagnostics.invokeExact(file, error, errorString);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeDiagnosticSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeDiagnosticSet",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeDiagnosticSet (MemoryAddress Diags) {
+        try {
+            clang_disposeDiagnosticSet.invokeExact(Diags);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getChildDiagnostics = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getChildDiagnostics",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getChildDiagnostics (MemoryAddress D) {
+        try {
+            return (MemoryAddress)clang_getChildDiagnostics.invokeExact(D);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNumDiagnostics = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumDiagnostics",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getNumDiagnostics (MemoryAddress Unit) {
+        try {
+            return (int)clang_getNumDiagnostics.invokeExact(Unit);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnostic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnostic",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_getDiagnostic (MemoryAddress Unit, int Index) {
+        try {
+            return (MemoryAddress)clang_getDiagnostic.invokeExact(Unit, Index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticSetFromTU = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticSetFromTU",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getDiagnosticSetFromTU (MemoryAddress Unit) {
+        try {
+            return (MemoryAddress)clang_getDiagnosticSetFromTU.invokeExact(Unit);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeDiagnostic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeDiagnostic",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeDiagnostic (MemoryAddress Diagnostic) {
+        try {
+            clang_disposeDiagnostic.invokeExact(Diagnostic);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXDiagnostic_DisplaySourceLocation = (int)1L;
+    public static final int CXDiagnostic_DisplayColumn = (int)2L;
+    public static final int CXDiagnostic_DisplaySourceRanges = (int)4L;
+    public static final int CXDiagnostic_DisplayOption = (int)8L;
+    public static final int CXDiagnostic_DisplayCategoryId = (int)16L;
+    public static final int CXDiagnostic_DisplayCategoryName = (int)32L;
+    public static final MethodHandle clang_formatDiagnostic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_formatDiagnostic",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_formatDiagnostic (MemoryAddress Diagnostic, int Options) {
+        try {
+            return (MemorySegment)clang_formatDiagnostic.invokeExact(Diagnostic, Options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_defaultDiagnosticDisplayOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_defaultDiagnosticDisplayOptions",
+        "()I",
+        FunctionDescriptor.of(C_INT)
+    );
+    public static final int clang_defaultDiagnosticDisplayOptions () {
+        try {
+            return (int)clang_defaultDiagnosticDisplayOptions.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticSeverity = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticSeverity",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getDiagnosticSeverity (MemoryAddress x0) {
+        try {
+            return (int)clang_getDiagnosticSeverity.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticLocation",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticLocation (MemoryAddress x0) {
+        try {
+            return (MemorySegment)clang_getDiagnosticLocation.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticSpelling",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticSpelling (MemoryAddress x0) {
+        try {
+            return (MemorySegment)clang_getDiagnosticSpelling.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticOption = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticOption",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticOption (MemoryAddress Diag, MemoryAddress Disable) {
+        try {
+            return (MemorySegment)clang_getDiagnosticOption.invokeExact(Diag, Disable);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticCategory = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticCategory",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getDiagnosticCategory (MemoryAddress x0) {
+        try {
+            return (int)clang_getDiagnosticCategory.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticCategoryName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticCategoryName",
+        "(I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticCategoryName (int Category) {
+        try {
+            return (MemorySegment)clang_getDiagnosticCategoryName.invokeExact(Category);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticCategoryText = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticCategoryText",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticCategoryText (MemoryAddress x0) {
+        try {
+            return (MemorySegment)clang_getDiagnosticCategoryText.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticNumRanges = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticNumRanges",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getDiagnosticNumRanges (MemoryAddress x0) {
+        try {
+            return (int)clang_getDiagnosticNumRanges.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticRange",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticRange (MemoryAddress Diagnostic, int Range) {
+        try {
+            return (MemorySegment)clang_getDiagnosticRange.invokeExact(Diagnostic, Range);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticNumFixIts = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticNumFixIts",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getDiagnosticNumFixIts (MemoryAddress Diagnostic) {
+        try {
+            return (int)clang_getDiagnosticNumFixIts.invokeExact(Diagnostic);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDiagnosticFixIt = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDiagnosticFixIt",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getDiagnosticFixIt (MemoryAddress Diagnostic, int FixIt, MemoryAddress ReplacementRange) {
+        try {
+            return (MemorySegment)clang_getDiagnosticFixIt.invokeExact(Diagnostic, FixIt, ReplacementRange);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTranslationUnitSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTranslationUnitSpelling",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getTranslationUnitSpelling (MemoryAddress CTUnit) {
+        try {
+            return (MemorySegment)clang_getTranslationUnitSpelling.invokeExact(CTUnit);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_createTranslationUnitFromSourceFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_createTranslationUnitFromSourceFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_createTranslationUnitFromSourceFile (MemoryAddress CIdx, MemoryAddress source_filename, int num_clang_command_line_args, MemoryAddress clang_command_line_args, int num_unsaved_files, MemoryAddress unsaved_files) {
+        try {
+            return (MemoryAddress)clang_createTranslationUnitFromSourceFile.invokeExact(CIdx, source_filename, num_clang_command_line_args, clang_command_line_args, num_unsaved_files, unsaved_files);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_createTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_createTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_createTranslationUnit (MemoryAddress CIdx, MemoryAddress ast_filename) {
+        try {
+            return (MemoryAddress)clang_createTranslationUnit.invokeExact(CIdx, ast_filename);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_createTranslationUnit2 = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_createTranslationUnit2",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_createTranslationUnit2 (MemoryAddress CIdx, MemoryAddress ast_filename, MemoryAddress out_TU) {
+        try {
+            return (int)clang_createTranslationUnit2.invokeExact(CIdx, ast_filename, out_TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTranslationUnit_None = (int)0L;
+    public static final int CXTranslationUnit_DetailedPreprocessingRecord = (int)1L;
+    public static final int CXTranslationUnit_Incomplete = (int)2L;
+    public static final int CXTranslationUnit_PrecompiledPreamble = (int)4L;
+    public static final int CXTranslationUnit_CacheCompletionResults = (int)8L;
+    public static final int CXTranslationUnit_ForSerialization = (int)16L;
+    public static final int CXTranslationUnit_CXXChainedPCH = (int)32L;
+    public static final int CXTranslationUnit_SkipFunctionBodies = (int)64L;
+    public static final int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = (int)128L;
+    public static final int CXTranslationUnit_CreatePreambleOnFirstParse = (int)256L;
+    public static final int CXTranslationUnit_KeepGoing = (int)512L;
+    public static final int CXTranslationUnit_SingleFileParse = (int)1024L;
+    public static final int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble = (int)2048L;
+    public static final int CXTranslationUnit_IncludeAttributedTypes = (int)4096L;
+    public static final int CXTranslationUnit_VisitImplicitAttributes = (int)8192L;
+    public static final int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles = (int)16384L;
+    public static final MethodHandle clang_defaultEditingTranslationUnitOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_defaultEditingTranslationUnitOptions",
+        "()I",
+        FunctionDescriptor.of(C_INT)
+    );
+    public static final int clang_defaultEditingTranslationUnitOptions () {
+        try {
+            return (int)clang_defaultEditingTranslationUnitOptions.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_parseTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_parseTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;II)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_parseTranslationUnit (MemoryAddress CIdx, MemoryAddress source_filename, MemoryAddress command_line_args, int num_command_line_args, MemoryAddress unsaved_files, int num_unsaved_files, int options) {
+        try {
+            return (MemoryAddress)clang_parseTranslationUnit.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_parseTranslationUnit2 = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_parseTranslationUnit2",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_parseTranslationUnit2 (MemoryAddress CIdx, MemoryAddress source_filename, MemoryAddress command_line_args, int num_command_line_args, MemoryAddress unsaved_files, int num_unsaved_files, int options, MemoryAddress out_TU) {
+        try {
+            return (int)clang_parseTranslationUnit2.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_parseTranslationUnit2FullArgv = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_parseTranslationUnit2FullArgv",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_parseTranslationUnit2FullArgv (MemoryAddress CIdx, MemoryAddress source_filename, MemoryAddress command_line_args, int num_command_line_args, MemoryAddress unsaved_files, int num_unsaved_files, int options, MemoryAddress out_TU) {
+        try {
+            return (int)clang_parseTranslationUnit2FullArgv.invokeExact(CIdx, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, options, out_TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXSaveTranslationUnit_None = (int)0L;
+    public static final MethodHandle clang_defaultSaveOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_defaultSaveOptions",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_defaultSaveOptions (MemoryAddress TU) {
+        try {
+            return (int)clang_defaultSaveOptions.invokeExact(TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXSaveError_None = (int)0L;
+    public static final int CXSaveError_Unknown = (int)1L;
+    public static final int CXSaveError_TranslationErrors = (int)2L;
+    public static final int CXSaveError_InvalidTU = (int)3L;
+    public static final MethodHandle clang_saveTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_saveTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_saveTranslationUnit (MemoryAddress TU, MemoryAddress FileName, int options) {
+        try {
+            return (int)clang_saveTranslationUnit.invokeExact(TU, FileName, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_suspendTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_suspendTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_suspendTranslationUnit (MemoryAddress x0) {
+        try {
+            return (int)clang_suspendTranslationUnit.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeTranslationUnit (MemoryAddress x0) {
+        try {
+            clang_disposeTranslationUnit.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXReparse_None = (int)0L;
+    public static final MethodHandle clang_defaultReparseOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_defaultReparseOptions",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_defaultReparseOptions (MemoryAddress TU) {
+        try {
+            return (int)clang_defaultReparseOptions.invokeExact(TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_reparseTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_reparseTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_reparseTranslationUnit (MemoryAddress TU, int num_unsaved_files, MemoryAddress unsaved_files, int options) {
+        try {
+            return (int)clang_reparseTranslationUnit.invokeExact(TU, num_unsaved_files, unsaved_files, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTUResourceUsage_AST = (int)1L;
+    public static final int CXTUResourceUsage_Identifiers = (int)2L;
+    public static final int CXTUResourceUsage_Selectors = (int)3L;
+    public static final int CXTUResourceUsage_GlobalCompletionResults = (int)4L;
+    public static final int CXTUResourceUsage_SourceManagerContentCache = (int)5L;
+    public static final int CXTUResourceUsage_AST_SideTables = (int)6L;
+    public static final int CXTUResourceUsage_SourceManager_Membuffer_Malloc = (int)7L;
+    public static final int CXTUResourceUsage_SourceManager_Membuffer_MMap = (int)8L;
+    public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = (int)9L;
+    public static final int CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = (int)10L;
+    public static final int CXTUResourceUsage_Preprocessor = (int)11L;
+    public static final int CXTUResourceUsage_PreprocessingRecord = (int)12L;
+    public static final int CXTUResourceUsage_SourceManager_DataStructures = (int)13L;
+    public static final int CXTUResourceUsage_Preprocessor_HeaderSearch = (int)14L;
+    public static final int CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = (int)1L;
+    public static final int CXTUResourceUsage_MEMORY_IN_BYTES_END = (int)14L;
+    public static final int CXTUResourceUsage_First = (int)1L;
+    public static final int CXTUResourceUsage_Last = (int)14L;
+    public static final MethodHandle clang_getTUResourceUsageName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTUResourceUsageName",
+        "(I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_getTUResourceUsageName (int kind) {
+        try {
+            return (MemoryAddress)clang_getTUResourceUsageName.invokeExact(kind);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXTUResourceUsageEntry$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        MemoryLayout.ofPaddingBits(32),
+        C_LONGLONG.withName("amount")
+    ).withName("CXTUResourceUsageEntry");
+    public static final VarHandle CXTUResourceUsageEntry$kind = CXTUResourceUsageEntry$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXTUResourceUsageEntry$kind$get(MemorySegment seg) {
+        return (int)CXTUResourceUsageEntry$kind.get(seg.baseAddress());
+    }
+    public static final void CXTUResourceUsageEntry$kind$set(MemorySegment seg, int x) {
+        CXTUResourceUsageEntry$kind.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXTUResourceUsageEntry$amount = CXTUResourceUsageEntry$LAYOUT.varHandle(long.class, PathElement.groupElement("amount"));
+    public static final long CXTUResourceUsageEntry$amount$get(MemorySegment seg) {
+        return (long)CXTUResourceUsageEntry$amount.get(seg.baseAddress());
+    }
+    public static final void CXTUResourceUsageEntry$amount$set(MemorySegment seg, long x) {
+        CXTUResourceUsageEntry$amount.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXTUResourceUsage$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("data"),
+        C_INT.withName("numEntries"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("entries")
+    ).withName("CXTUResourceUsage");
+    public static final VarHandle CXTUResourceUsage$numEntries = CXTUResourceUsage$LAYOUT.varHandle(int.class, PathElement.groupElement("numEntries"));
+    public static final int CXTUResourceUsage$numEntries$get(MemorySegment seg) {
+        return (int)CXTUResourceUsage$numEntries.get(seg.baseAddress());
+    }
+    public static final void CXTUResourceUsage$numEntries$set(MemorySegment seg, int x) {
+        CXTUResourceUsage$numEntries.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getCXTUResourceUsage = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCXTUResourceUsage",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("numEntries"),
+            MemoryLayout.ofPaddingBits(32),
+            C_POINTER.withName("entries")
+        ).withName("CXTUResourceUsage"),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getCXTUResourceUsage (MemoryAddress TU) {
+        try {
+            return (MemorySegment)clang_getCXTUResourceUsage.invokeExact(TU);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeCXTUResourceUsage = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeCXTUResourceUsage",
+        "(Ljdk/incubator/foreign/MemorySegment;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("numEntries"),
+                MemoryLayout.ofPaddingBits(32),
+                C_POINTER.withName("entries")
+            ).withName("CXTUResourceUsage")
+        )
+    );
+    public static final void clang_disposeCXTUResourceUsage (MemorySegment usage) {
+        try {
+            clang_disposeCXTUResourceUsage.invokeExact(usage);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTranslationUnitTargetInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTranslationUnitTargetInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getTranslationUnitTargetInfo (MemoryAddress CTUnit) {
+        try {
+            return (MemoryAddress)clang_getTranslationUnitTargetInfo.invokeExact(CTUnit);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_TargetInfo_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_TargetInfo_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_TargetInfo_dispose (MemoryAddress Info) {
+        try {
+            clang_TargetInfo_dispose.invokeExact(Info);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_TargetInfo_getTriple = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_TargetInfo_getTriple",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_TargetInfo_getTriple (MemoryAddress Info) {
+        try {
+            return (MemorySegment)clang_TargetInfo_getTriple.invokeExact(Info);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_TargetInfo_getPointerWidth = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_TargetInfo_getPointerWidth",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_TargetInfo_getPointerWidth (MemoryAddress Info) {
+        try {
+            return (int)clang_TargetInfo_getPointerWidth.invokeExact(Info);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXCursor_UnexposedDecl = (int)1L;
+    public static final int CXCursor_StructDecl = (int)2L;
+    public static final int CXCursor_UnionDecl = (int)3L;
+    public static final int CXCursor_ClassDecl = (int)4L;
+    public static final int CXCursor_EnumDecl = (int)5L;
+    public static final int CXCursor_FieldDecl = (int)6L;
+    public static final int CXCursor_EnumConstantDecl = (int)7L;
+    public static final int CXCursor_FunctionDecl = (int)8L;
+    public static final int CXCursor_VarDecl = (int)9L;
+    public static final int CXCursor_ParmDecl = (int)10L;
+    public static final int CXCursor_ObjCInterfaceDecl = (int)11L;
+    public static final int CXCursor_ObjCCategoryDecl = (int)12L;
+    public static final int CXCursor_ObjCProtocolDecl = (int)13L;
+    public static final int CXCursor_ObjCPropertyDecl = (int)14L;
+    public static final int CXCursor_ObjCIvarDecl = (int)15L;
+    public static final int CXCursor_ObjCInstanceMethodDecl = (int)16L;
+    public static final int CXCursor_ObjCClassMethodDecl = (int)17L;
+    public static final int CXCursor_ObjCImplementationDecl = (int)18L;
+    public static final int CXCursor_ObjCCategoryImplDecl = (int)19L;
+    public static final int CXCursor_TypedefDecl = (int)20L;
+    public static final int CXCursor_CXXMethod = (int)21L;
+    public static final int CXCursor_Namespace = (int)22L;
+    public static final int CXCursor_LinkageSpec = (int)23L;
+    public static final int CXCursor_Constructor = (int)24L;
+    public static final int CXCursor_Destructor = (int)25L;
+    public static final int CXCursor_ConversionFunction = (int)26L;
+    public static final int CXCursor_TemplateTypeParameter = (int)27L;
+    public static final int CXCursor_NonTypeTemplateParameter = (int)28L;
+    public static final int CXCursor_TemplateTemplateParameter = (int)29L;
+    public static final int CXCursor_FunctionTemplate = (int)30L;
+    public static final int CXCursor_ClassTemplate = (int)31L;
+    public static final int CXCursor_ClassTemplatePartialSpecialization = (int)32L;
+    public static final int CXCursor_NamespaceAlias = (int)33L;
+    public static final int CXCursor_UsingDirective = (int)34L;
+    public static final int CXCursor_UsingDeclaration = (int)35L;
+    public static final int CXCursor_TypeAliasDecl = (int)36L;
+    public static final int CXCursor_ObjCSynthesizeDecl = (int)37L;
+    public static final int CXCursor_ObjCDynamicDecl = (int)38L;
+    public static final int CXCursor_CXXAccessSpecifier = (int)39L;
+    public static final int CXCursor_FirstDecl = (int)1L;
+    public static final int CXCursor_LastDecl = (int)39L;
+    public static final int CXCursor_FirstRef = (int)40L;
+    public static final int CXCursor_ObjCSuperClassRef = (int)40L;
+    public static final int CXCursor_ObjCProtocolRef = (int)41L;
+    public static final int CXCursor_ObjCClassRef = (int)42L;
+    public static final int CXCursor_TypeRef = (int)43L;
+    public static final int CXCursor_CXXBaseSpecifier = (int)44L;
+    public static final int CXCursor_TemplateRef = (int)45L;
+    public static final int CXCursor_NamespaceRef = (int)46L;
+    public static final int CXCursor_MemberRef = (int)47L;
+    public static final int CXCursor_LabelRef = (int)48L;
+    public static final int CXCursor_OverloadedDeclRef = (int)49L;
+    public static final int CXCursor_VariableRef = (int)50L;
+    public static final int CXCursor_LastRef = (int)50L;
+    public static final int CXCursor_FirstInvalid = (int)70L;
+    public static final int CXCursor_InvalidFile = (int)70L;
+    public static final int CXCursor_NoDeclFound = (int)71L;
+    public static final int CXCursor_NotImplemented = (int)72L;
+    public static final int CXCursor_InvalidCode = (int)73L;
+    public static final int CXCursor_LastInvalid = (int)73L;
+    public static final int CXCursor_FirstExpr = (int)100L;
+    public static final int CXCursor_UnexposedExpr = (int)100L;
+    public static final int CXCursor_DeclRefExpr = (int)101L;
+    public static final int CXCursor_MemberRefExpr = (int)102L;
+    public static final int CXCursor_CallExpr = (int)103L;
+    public static final int CXCursor_ObjCMessageExpr = (int)104L;
+    public static final int CXCursor_BlockExpr = (int)105L;
+    public static final int CXCursor_IntegerLiteral = (int)106L;
+    public static final int CXCursor_FloatingLiteral = (int)107L;
+    public static final int CXCursor_ImaginaryLiteral = (int)108L;
+    public static final int CXCursor_StringLiteral = (int)109L;
+    public static final int CXCursor_CharacterLiteral = (int)110L;
+    public static final int CXCursor_ParenExpr = (int)111L;
+    public static final int CXCursor_UnaryOperator = (int)112L;
+    public static final int CXCursor_ArraySubscriptExpr = (int)113L;
+    public static final int CXCursor_BinaryOperator = (int)114L;
+    public static final int CXCursor_CompoundAssignOperator = (int)115L;
+    public static final int CXCursor_ConditionalOperator = (int)116L;
+    public static final int CXCursor_CStyleCastExpr = (int)117L;
+    public static final int CXCursor_CompoundLiteralExpr = (int)118L;
+    public static final int CXCursor_InitListExpr = (int)119L;
+    public static final int CXCursor_AddrLabelExpr = (int)120L;
+    public static final int CXCursor_StmtExpr = (int)121L;
+    public static final int CXCursor_GenericSelectionExpr = (int)122L;
+    public static final int CXCursor_GNUNullExpr = (int)123L;
+    public static final int CXCursor_CXXStaticCastExpr = (int)124L;
+    public static final int CXCursor_CXXDynamicCastExpr = (int)125L;
+    public static final int CXCursor_CXXReinterpretCastExpr = (int)126L;
+    public static final int CXCursor_CXXConstCastExpr = (int)127L;
+    public static final int CXCursor_CXXFunctionalCastExpr = (int)128L;
+    public static final int CXCursor_CXXTypeidExpr = (int)129L;
+    public static final int CXCursor_CXXBoolLiteralExpr = (int)130L;
+    public static final int CXCursor_CXXNullPtrLiteralExpr = (int)131L;
+    public static final int CXCursor_CXXThisExpr = (int)132L;
+    public static final int CXCursor_CXXThrowExpr = (int)133L;
+    public static final int CXCursor_CXXNewExpr = (int)134L;
+    public static final int CXCursor_CXXDeleteExpr = (int)135L;
+    public static final int CXCursor_UnaryExpr = (int)136L;
+    public static final int CXCursor_ObjCStringLiteral = (int)137L;
+    public static final int CXCursor_ObjCEncodeExpr = (int)138L;
+    public static final int CXCursor_ObjCSelectorExpr = (int)139L;
+    public static final int CXCursor_ObjCProtocolExpr = (int)140L;
+    public static final int CXCursor_ObjCBridgedCastExpr = (int)141L;
+    public static final int CXCursor_PackExpansionExpr = (int)142L;
+    public static final int CXCursor_SizeOfPackExpr = (int)143L;
+    public static final int CXCursor_LambdaExpr = (int)144L;
+    public static final int CXCursor_ObjCBoolLiteralExpr = (int)145L;
+    public static final int CXCursor_ObjCSelfExpr = (int)146L;
+    public static final int CXCursor_OMPArraySectionExpr = (int)147L;
+    public static final int CXCursor_ObjCAvailabilityCheckExpr = (int)148L;
+    public static final int CXCursor_FixedPointLiteral = (int)149L;
+    public static final int CXCursor_LastExpr = (int)149L;
+    public static final int CXCursor_FirstStmt = (int)200L;
+    public static final int CXCursor_UnexposedStmt = (int)200L;
+    public static final int CXCursor_LabelStmt = (int)201L;
+    public static final int CXCursor_CompoundStmt = (int)202L;
+    public static final int CXCursor_CaseStmt = (int)203L;
+    public static final int CXCursor_DefaultStmt = (int)204L;
+    public static final int CXCursor_IfStmt = (int)205L;
+    public static final int CXCursor_SwitchStmt = (int)206L;
+    public static final int CXCursor_WhileStmt = (int)207L;
+    public static final int CXCursor_DoStmt = (int)208L;
+    public static final int CXCursor_ForStmt = (int)209L;
+    public static final int CXCursor_GotoStmt = (int)210L;
+    public static final int CXCursor_IndirectGotoStmt = (int)211L;
+    public static final int CXCursor_ContinueStmt = (int)212L;
+    public static final int CXCursor_BreakStmt = (int)213L;
+    public static final int CXCursor_ReturnStmt = (int)214L;
+    public static final int CXCursor_GCCAsmStmt = (int)215L;
+    public static final int CXCursor_AsmStmt = (int)215L;
+    public static final int CXCursor_ObjCAtTryStmt = (int)216L;
+    public static final int CXCursor_ObjCAtCatchStmt = (int)217L;
+    public static final int CXCursor_ObjCAtFinallyStmt = (int)218L;
+    public static final int CXCursor_ObjCAtThrowStmt = (int)219L;
+    public static final int CXCursor_ObjCAtSynchronizedStmt = (int)220L;
+    public static final int CXCursor_ObjCAutoreleasePoolStmt = (int)221L;
+    public static final int CXCursor_ObjCForCollectionStmt = (int)222L;
+    public static final int CXCursor_CXXCatchStmt = (int)223L;
+    public static final int CXCursor_CXXTryStmt = (int)224L;
+    public static final int CXCursor_CXXForRangeStmt = (int)225L;
+    public static final int CXCursor_SEHTryStmt = (int)226L;
+    public static final int CXCursor_SEHExceptStmt = (int)227L;
+    public static final int CXCursor_SEHFinallyStmt = (int)228L;
+    public static final int CXCursor_MSAsmStmt = (int)229L;
+    public static final int CXCursor_NullStmt = (int)230L;
+    public static final int CXCursor_DeclStmt = (int)231L;
+    public static final int CXCursor_OMPParallelDirective = (int)232L;
+    public static final int CXCursor_OMPSimdDirective = (int)233L;
+    public static final int CXCursor_OMPForDirective = (int)234L;
+    public static final int CXCursor_OMPSectionsDirective = (int)235L;
+    public static final int CXCursor_OMPSectionDirective = (int)236L;
+    public static final int CXCursor_OMPSingleDirective = (int)237L;
+    public static final int CXCursor_OMPParallelForDirective = (int)238L;
+    public static final int CXCursor_OMPParallelSectionsDirective = (int)239L;
+    public static final int CXCursor_OMPTaskDirective = (int)240L;
+    public static final int CXCursor_OMPMasterDirective = (int)241L;
+    public static final int CXCursor_OMPCriticalDirective = (int)242L;
+    public static final int CXCursor_OMPTaskyieldDirective = (int)243L;
+    public static final int CXCursor_OMPBarrierDirective = (int)244L;
+    public static final int CXCursor_OMPTaskwaitDirective = (int)245L;
+    public static final int CXCursor_OMPFlushDirective = (int)246L;
+    public static final int CXCursor_SEHLeaveStmt = (int)247L;
+    public static final int CXCursor_OMPOrderedDirective = (int)248L;
+    public static final int CXCursor_OMPAtomicDirective = (int)249L;
+    public static final int CXCursor_OMPForSimdDirective = (int)250L;
+    public static final int CXCursor_OMPParallelForSimdDirective = (int)251L;
+    public static final int CXCursor_OMPTargetDirective = (int)252L;
+    public static final int CXCursor_OMPTeamsDirective = (int)253L;
+    public static final int CXCursor_OMPTaskgroupDirective = (int)254L;
+    public static final int CXCursor_OMPCancellationPointDirective = (int)255L;
+    public static final int CXCursor_OMPCancelDirective = (int)256L;
+    public static final int CXCursor_OMPTargetDataDirective = (int)257L;
+    public static final int CXCursor_OMPTaskLoopDirective = (int)258L;
+    public static final int CXCursor_OMPTaskLoopSimdDirective = (int)259L;
+    public static final int CXCursor_OMPDistributeDirective = (int)260L;
+    public static final int CXCursor_OMPTargetEnterDataDirective = (int)261L;
+    public static final int CXCursor_OMPTargetExitDataDirective = (int)262L;
+    public static final int CXCursor_OMPTargetParallelDirective = (int)263L;
+    public static final int CXCursor_OMPTargetParallelForDirective = (int)264L;
+    public static final int CXCursor_OMPTargetUpdateDirective = (int)265L;
+    public static final int CXCursor_OMPDistributeParallelForDirective = (int)266L;
+    public static final int CXCursor_OMPDistributeParallelForSimdDirective = (int)267L;
+    public static final int CXCursor_OMPDistributeSimdDirective = (int)268L;
+    public static final int CXCursor_OMPTargetParallelForSimdDirective = (int)269L;
+    public static final int CXCursor_OMPTargetSimdDirective = (int)270L;
+    public static final int CXCursor_OMPTeamsDistributeDirective = (int)271L;
+    public static final int CXCursor_OMPTeamsDistributeSimdDirective = (int)272L;
+    public static final int CXCursor_OMPTeamsDistributeParallelForSimdDirective = (int)273L;
+    public static final int CXCursor_OMPTeamsDistributeParallelForDirective = (int)274L;
+    public static final int CXCursor_OMPTargetTeamsDirective = (int)275L;
+    public static final int CXCursor_OMPTargetTeamsDistributeDirective = (int)276L;
+    public static final int CXCursor_OMPTargetTeamsDistributeParallelForDirective = (int)277L;
+    public static final int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective = (int)278L;
+    public static final int CXCursor_OMPTargetTeamsDistributeSimdDirective = (int)279L;
+    public static final int CXCursor_BuiltinBitCastExpr = (int)280L;
+    public static final int CXCursor_LastStmt = (int)280L;
+    public static final int CXCursor_TranslationUnit = (int)300L;
+    public static final int CXCursor_FirstAttr = (int)400L;
+    public static final int CXCursor_UnexposedAttr = (int)400L;
+    public static final int CXCursor_IBActionAttr = (int)401L;
+    public static final int CXCursor_IBOutletAttr = (int)402L;
+    public static final int CXCursor_IBOutletCollectionAttr = (int)403L;
+    public static final int CXCursor_CXXFinalAttr = (int)404L;
+    public static final int CXCursor_CXXOverrideAttr = (int)405L;
+    public static final int CXCursor_AnnotateAttr = (int)406L;
+    public static final int CXCursor_AsmLabelAttr = (int)407L;
+    public static final int CXCursor_PackedAttr = (int)408L;
+    public static final int CXCursor_PureAttr = (int)409L;
+    public static final int CXCursor_ConstAttr = (int)410L;
+    public static final int CXCursor_NoDuplicateAttr = (int)411L;
+    public static final int CXCursor_CUDAConstantAttr = (int)412L;
+    public static final int CXCursor_CUDADeviceAttr = (int)413L;
+    public static final int CXCursor_CUDAGlobalAttr = (int)414L;
+    public static final int CXCursor_CUDAHostAttr = (int)415L;
+    public static final int CXCursor_CUDASharedAttr = (int)416L;
+    public static final int CXCursor_VisibilityAttr = (int)417L;
+    public static final int CXCursor_DLLExport = (int)418L;
+    public static final int CXCursor_DLLImport = (int)419L;
+    public static final int CXCursor_NSReturnsRetained = (int)420L;
+    public static final int CXCursor_NSReturnsNotRetained = (int)421L;
+    public static final int CXCursor_NSReturnsAutoreleased = (int)422L;
+    public static final int CXCursor_NSConsumesSelf = (int)423L;
+    public static final int CXCursor_NSConsumed = (int)424L;
+    public static final int CXCursor_ObjCException = (int)425L;
+    public static final int CXCursor_ObjCNSObject = (int)426L;
+    public static final int CXCursor_ObjCIndependentClass = (int)427L;
+    public static final int CXCursor_ObjCPreciseLifetime = (int)428L;
+    public static final int CXCursor_ObjCReturnsInnerPointer = (int)429L;
+    public static final int CXCursor_ObjCRequiresSuper = (int)430L;
+    public static final int CXCursor_ObjCRootClass = (int)431L;
+    public static final int CXCursor_ObjCSubclassingRestricted = (int)432L;
+    public static final int CXCursor_ObjCExplicitProtocolImpl = (int)433L;
+    public static final int CXCursor_ObjCDesignatedInitializer = (int)434L;
+    public static final int CXCursor_ObjCRuntimeVisible = (int)435L;
+    public static final int CXCursor_ObjCBoxable = (int)436L;
+    public static final int CXCursor_FlagEnum = (int)437L;
+    public static final int CXCursor_ConvergentAttr = (int)438L;
+    public static final int CXCursor_WarnUnusedAttr = (int)439L;
+    public static final int CXCursor_WarnUnusedResultAttr = (int)440L;
+    public static final int CXCursor_AlignedAttr = (int)441L;
+    public static final int CXCursor_LastAttr = (int)441L;
+    public static final int CXCursor_PreprocessingDirective = (int)500L;
+    public static final int CXCursor_MacroDefinition = (int)501L;
+    public static final int CXCursor_MacroExpansion = (int)502L;
+    public static final int CXCursor_MacroInstantiation = (int)502L;
+    public static final int CXCursor_InclusionDirective = (int)503L;
+    public static final int CXCursor_FirstPreprocessing = (int)500L;
+    public static final int CXCursor_LastPreprocessing = (int)503L;
+    public static final int CXCursor_ModuleImportDecl = (int)600L;
+    public static final int CXCursor_TypeAliasTemplateDecl = (int)601L;
+    public static final int CXCursor_StaticAssert = (int)602L;
+    public static final int CXCursor_FriendDecl = (int)603L;
+    public static final int CXCursor_FirstExtraDecl = (int)600L;
+    public static final int CXCursor_LastExtraDecl = (int)603L;
+    public static final int CXCursor_OverloadCandidate = (int)700L;
+    public static final MemoryLayout CXCursor$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        C_INT.withName("xdata"),
+        MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+    );
+    public static final VarHandle CXCursor$kind = CXCursor$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXCursor$kind$get(MemorySegment seg) {
+        return (int)CXCursor$kind.get(seg.baseAddress());
+    }
+    public static final void CXCursor$kind$set(MemorySegment seg, int x) {
+        CXCursor$kind.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXCursor$xdata = CXCursor$LAYOUT.varHandle(int.class, PathElement.groupElement("xdata"));
+    public static final int CXCursor$xdata$get(MemorySegment seg) {
+        return (int)CXCursor$xdata.get(seg.baseAddress());
+    }
+    public static final void CXCursor$xdata$set(MemorySegment seg, int x) {
+        CXCursor$xdata.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getNullCursor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNullCursor",
+        "()Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ))
+    );
+    public static final MemorySegment clang_getNullCursor () {
+        try {
+            return (MemorySegment)clang_getNullCursor.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTranslationUnitCursor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTranslationUnitCursor",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getTranslationUnitCursor (MemoryAddress x0) {
+        try {
+            return (MemorySegment)clang_getTranslationUnitCursor.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_equalCursors = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_equalCursors",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_equalCursors (MemorySegment x0, MemorySegment x1) {
+        try {
+            return (int)clang_equalCursors.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isNull = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isNull",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isNull (MemorySegment cursor) {
+        try {
+            return (int)clang_Cursor_isNull.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_hashCursor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_hashCursor",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_hashCursor (MemorySegment x0) {
+        try {
+            return (int)clang_hashCursor.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorKind",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorKind (MemorySegment x0) {
+        try {
+            return (int)clang_getCursorKind.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isDeclaration = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isDeclaration",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isDeclaration (int x0) {
+        try {
+            return (int)clang_isDeclaration.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isInvalidDeclaration = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isInvalidDeclaration",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isInvalidDeclaration (MemorySegment x0) {
+        try {
+            return (int)clang_isInvalidDeclaration.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isReference = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isReference",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isReference (int x0) {
+        try {
+            return (int)clang_isReference.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isExpression = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isExpression",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isExpression (int x0) {
+        try {
+            return (int)clang_isExpression.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isStatement = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isStatement",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isStatement (int x0) {
+        try {
+            return (int)clang_isStatement.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isAttribute = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isAttribute",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isAttribute (int x0) {
+        try {
+            return (int)clang_isAttribute.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_hasAttrs = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_hasAttrs",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_hasAttrs (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_hasAttrs.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isInvalid = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isInvalid",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isInvalid (int x0) {
+        try {
+            return (int)clang_isInvalid.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isTranslationUnit",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isTranslationUnit (int x0) {
+        try {
+            return (int)clang_isTranslationUnit.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isPreprocessing = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isPreprocessing",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isPreprocessing (int x0) {
+        try {
+            return (int)clang_isPreprocessing.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isUnexposed = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isUnexposed",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_isUnexposed (int x0) {
+        try {
+            return (int)clang_isUnexposed.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXLinkage_Invalid = (int)0L;
+    public static final int CXLinkage_NoLinkage = (int)1L;
+    public static final int CXLinkage_Internal = (int)2L;
+    public static final int CXLinkage_UniqueExternal = (int)3L;
+    public static final int CXLinkage_External = (int)4L;
+    public static final MethodHandle clang_getCursorLinkage = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorLinkage",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorLinkage (MemorySegment cursor) {
+        try {
+            return (int)clang_getCursorLinkage.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXVisibility_Invalid = (int)0L;
+    public static final int CXVisibility_Hidden = (int)1L;
+    public static final int CXVisibility_Protected = (int)2L;
+    public static final int CXVisibility_Default = (int)3L;
+    public static final MethodHandle clang_getCursorVisibility = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorVisibility",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorVisibility (MemorySegment cursor) {
+        try {
+            return (int)clang_getCursorVisibility.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorAvailability = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorAvailability",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorAvailability (MemorySegment cursor) {
+        try {
+            return (int)clang_getCursorAvailability.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXPlatformAvailability$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("Platform"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("Major"),
+            C_INT.withName("Minor"),
+            C_INT.withName("Subminor")
+        ).withName("Introduced"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("Major"),
+            C_INT.withName("Minor"),
+            C_INT.withName("Subminor")
+        ).withName("Deprecated"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("Major"),
+            C_INT.withName("Minor"),
+            C_INT.withName("Subminor")
+        ).withName("Obsoleted"),
+        C_INT.withName("Unavailable"),
+        MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("Message")
+    ).withName("CXPlatformAvailability");
+    public static final VarHandle CXPlatformAvailability$Unavailable = CXPlatformAvailability$LAYOUT.varHandle(int.class, PathElement.groupElement("Unavailable"));
+    public static final int CXPlatformAvailability$Unavailable$get(MemorySegment seg) {
+        return (int)CXPlatformAvailability$Unavailable.get(seg.baseAddress());
+    }
+    public static final void CXPlatformAvailability$Unavailable$set(MemorySegment seg, int x) {
+        CXPlatformAvailability$Unavailable.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getCursorPlatformAvailability = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorPlatformAvailability",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_getCursorPlatformAvailability (MemorySegment cursor, MemoryAddress always_deprecated, MemoryAddress deprecated_message, MemoryAddress always_unavailable, MemoryAddress unavailable_message, MemoryAddress availability, int availability_size) {
+        try {
+            return (int)clang_getCursorPlatformAvailability.invokeExact(cursor, always_deprecated, deprecated_message, always_unavailable, unavailable_message, availability, availability_size);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeCXPlatformAvailability = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeCXPlatformAvailability",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeCXPlatformAvailability (MemoryAddress availability) {
+        try {
+            clang_disposeCXPlatformAvailability.invokeExact(availability);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXLanguage_Invalid = (int)0L;
+    public static final int CXLanguage_C = (int)1L;
+    public static final int CXLanguage_ObjC = (int)2L;
+    public static final int CXLanguage_CPlusPlus = (int)3L;
+    public static final MethodHandle clang_getCursorLanguage = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorLanguage",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorLanguage (MemorySegment cursor) {
+        try {
+            return (int)clang_getCursorLanguage.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTLS_None = (int)0L;
+    public static final int CXTLS_Dynamic = (int)1L;
+    public static final int CXTLS_Static = (int)2L;
+    public static final MethodHandle clang_getCursorTLSKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorTLSKind",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorTLSKind (MemorySegment cursor) {
+        try {
+            return (int)clang_getCursorTLSKind.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getTranslationUnit",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_Cursor_getTranslationUnit (MemorySegment x0) {
+        try {
+            return (MemoryAddress)clang_Cursor_getTranslationUnit.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_createCXCursorSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_createCXCursorSet",
+        "()Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER)
+    );
+    public static final MemoryAddress clang_createCXCursorSet () {
+        try {
+            return (MemoryAddress)clang_createCXCursorSet.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeCXCursorSet = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeCXCursorSet",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeCXCursorSet (MemoryAddress cset) {
+        try {
+            clang_disposeCXCursorSet.invokeExact(cset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXCursorSet_contains = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXCursorSet_contains",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXCursorSet_contains (MemoryAddress cset, MemorySegment cursor) {
+        try {
+            return (int)clang_CXCursorSet_contains.invokeExact(cset, cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXCursorSet_insert = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXCursorSet_insert",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXCursorSet_insert (MemoryAddress cset, MemorySegment cursor) {
+        try {
+            return (int)clang_CXCursorSet_insert.invokeExact(cset, cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorSemanticParent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorSemanticParent",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorSemanticParent (MemorySegment cursor) {
+        try {
+            return (MemorySegment)clang_getCursorSemanticParent.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorLexicalParent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorLexicalParent",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorLexicalParent (MemorySegment cursor) {
+        try {
+            return (MemorySegment)clang_getCursorLexicalParent.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getOverriddenCursors = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getOverriddenCursors",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getOverriddenCursors (MemorySegment cursor, MemoryAddress overridden, MemoryAddress num_overridden) {
+        try {
+            clang_getOverriddenCursors.invokeExact(cursor, overridden, num_overridden);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeOverriddenCursors = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeOverriddenCursors",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeOverriddenCursors (MemoryAddress overridden) {
+        try {
+            clang_disposeOverriddenCursors.invokeExact(overridden);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getIncludedFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getIncludedFile",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_getIncludedFile (MemorySegment cursor) {
+        try {
+            return (MemoryAddress)clang_getIncludedFile.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursor",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursor (MemoryAddress x0, MemorySegment x1) {
+        try {
+            return (MemorySegment)clang_getCursor.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorLocation (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorLocation.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorExtent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorExtent",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorExtent (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorExtent.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXType_Invalid = (int)0L;
+    public static final int CXType_Unexposed = (int)1L;
+    public static final int CXType_Void = (int)2L;
+    public static final int CXType_Bool = (int)3L;
+    public static final int CXType_Char_U = (int)4L;
+    public static final int CXType_UChar = (int)5L;
+    public static final int CXType_Char16 = (int)6L;
+    public static final int CXType_Char32 = (int)7L;
+    public static final int CXType_UShort = (int)8L;
+    public static final int CXType_UInt = (int)9L;
+    public static final int CXType_ULong = (int)10L;
+    public static final int CXType_ULongLong = (int)11L;
+    public static final int CXType_UInt128 = (int)12L;
+    public static final int CXType_Char_S = (int)13L;
+    public static final int CXType_SChar = (int)14L;
+    public static final int CXType_WChar = (int)15L;
+    public static final int CXType_Short = (int)16L;
+    public static final int CXType_Int = (int)17L;
+    public static final int CXType_Long = (int)18L;
+    public static final int CXType_LongLong = (int)19L;
+    public static final int CXType_Int128 = (int)20L;
+    public static final int CXType_Float = (int)21L;
+    public static final int CXType_Double = (int)22L;
+    public static final int CXType_LongDouble = (int)23L;
+    public static final int CXType_NullPtr = (int)24L;
+    public static final int CXType_Overload = (int)25L;
+    public static final int CXType_Dependent = (int)26L;
+    public static final int CXType_ObjCId = (int)27L;
+    public static final int CXType_ObjCClass = (int)28L;
+    public static final int CXType_ObjCSel = (int)29L;
+    public static final int CXType_Float128 = (int)30L;
+    public static final int CXType_Half = (int)31L;
+    public static final int CXType_Float16 = (int)32L;
+    public static final int CXType_ShortAccum = (int)33L;
+    public static final int CXType_Accum = (int)34L;
+    public static final int CXType_LongAccum = (int)35L;
+    public static final int CXType_UShortAccum = (int)36L;
+    public static final int CXType_UAccum = (int)37L;
+    public static final int CXType_ULongAccum = (int)38L;
+    public static final int CXType_FirstBuiltin = (int)2L;
+    public static final int CXType_LastBuiltin = (int)38L;
+    public static final int CXType_Complex = (int)100L;
+    public static final int CXType_Pointer = (int)101L;
+    public static final int CXType_BlockPointer = (int)102L;
+    public static final int CXType_LValueReference = (int)103L;
+    public static final int CXType_RValueReference = (int)104L;
+    public static final int CXType_Record = (int)105L;
+    public static final int CXType_Enum = (int)106L;
+    public static final int CXType_Typedef = (int)107L;
+    public static final int CXType_ObjCInterface = (int)108L;
+    public static final int CXType_ObjCObjectPointer = (int)109L;
+    public static final int CXType_FunctionNoProto = (int)110L;
+    public static final int CXType_FunctionProto = (int)111L;
+    public static final int CXType_ConstantArray = (int)112L;
+    public static final int CXType_Vector = (int)113L;
+    public static final int CXType_IncompleteArray = (int)114L;
+    public static final int CXType_VariableArray = (int)115L;
+    public static final int CXType_DependentSizedArray = (int)116L;
+    public static final int CXType_MemberPointer = (int)117L;
+    public static final int CXType_Auto = (int)118L;
+    public static final int CXType_Elaborated = (int)119L;
+    public static final int CXType_Pipe = (int)120L;
+    public static final int CXType_OCLImage1dRO = (int)121L;
+    public static final int CXType_OCLImage1dArrayRO = (int)122L;
+    public static final int CXType_OCLImage1dBufferRO = (int)123L;
+    public static final int CXType_OCLImage2dRO = (int)124L;
+    public static final int CXType_OCLImage2dArrayRO = (int)125L;
+    public static final int CXType_OCLImage2dDepthRO = (int)126L;
+    public static final int CXType_OCLImage2dArrayDepthRO = (int)127L;
+    public static final int CXType_OCLImage2dMSAARO = (int)128L;
+    public static final int CXType_OCLImage2dArrayMSAARO = (int)129L;
+    public static final int CXType_OCLImage2dMSAADepthRO = (int)130L;
+    public static final int CXType_OCLImage2dArrayMSAADepthRO = (int)131L;
+    public static final int CXType_OCLImage3dRO = (int)132L;
+    public static final int CXType_OCLImage1dWO = (int)133L;
+    public static final int CXType_OCLImage1dArrayWO = (int)134L;
+    public static final int CXType_OCLImage1dBufferWO = (int)135L;
+    public static final int CXType_OCLImage2dWO = (int)136L;
+    public static final int CXType_OCLImage2dArrayWO = (int)137L;
+    public static final int CXType_OCLImage2dDepthWO = (int)138L;
+    public static final int CXType_OCLImage2dArrayDepthWO = (int)139L;
+    public static final int CXType_OCLImage2dMSAAWO = (int)140L;
+    public static final int CXType_OCLImage2dArrayMSAAWO = (int)141L;
+    public static final int CXType_OCLImage2dMSAADepthWO = (int)142L;
+    public static final int CXType_OCLImage2dArrayMSAADepthWO = (int)143L;
+    public static final int CXType_OCLImage3dWO = (int)144L;
+    public static final int CXType_OCLImage1dRW = (int)145L;
+    public static final int CXType_OCLImage1dArrayRW = (int)146L;
+    public static final int CXType_OCLImage1dBufferRW = (int)147L;
+    public static final int CXType_OCLImage2dRW = (int)148L;
+    public static final int CXType_OCLImage2dArrayRW = (int)149L;
+    public static final int CXType_OCLImage2dDepthRW = (int)150L;
+    public static final int CXType_OCLImage2dArrayDepthRW = (int)151L;
+    public static final int CXType_OCLImage2dMSAARW = (int)152L;
+    public static final int CXType_OCLImage2dArrayMSAARW = (int)153L;
+    public static final int CXType_OCLImage2dMSAADepthRW = (int)154L;
+    public static final int CXType_OCLImage2dArrayMSAADepthRW = (int)155L;
+    public static final int CXType_OCLImage3dRW = (int)156L;
+    public static final int CXType_OCLSampler = (int)157L;
+    public static final int CXType_OCLEvent = (int)158L;
+    public static final int CXType_OCLQueue = (int)159L;
+    public static final int CXType_OCLReserveID = (int)160L;
+    public static final int CXType_ObjCObject = (int)161L;
+    public static final int CXType_ObjCTypeParam = (int)162L;
+    public static final int CXType_Attributed = (int)163L;
+    public static final int CXType_OCLIntelSubgroupAVCMcePayload = (int)164L;
+    public static final int CXType_OCLIntelSubgroupAVCImePayload = (int)165L;
+    public static final int CXType_OCLIntelSubgroupAVCRefPayload = (int)166L;
+    public static final int CXType_OCLIntelSubgroupAVCSicPayload = (int)167L;
+    public static final int CXType_OCLIntelSubgroupAVCMceResult = (int)168L;
+    public static final int CXType_OCLIntelSubgroupAVCImeResult = (int)169L;
+    public static final int CXType_OCLIntelSubgroupAVCRefResult = (int)170L;
+    public static final int CXType_OCLIntelSubgroupAVCSicResult = (int)171L;
+    public static final int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout = (int)172L;
+    public static final int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout = (int)173L;
+    public static final int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin = (int)174L;
+    public static final int CXType_OCLIntelSubgroupAVCImeDualRefStreamin = (int)175L;
+    public static final int CXType_ExtVector = (int)176L;
+    public static final int CXCallingConv_Default = (int)0L;
+    public static final int CXCallingConv_C = (int)1L;
+    public static final int CXCallingConv_X86StdCall = (int)2L;
+    public static final int CXCallingConv_X86FastCall = (int)3L;
+    public static final int CXCallingConv_X86ThisCall = (int)4L;
+    public static final int CXCallingConv_X86Pascal = (int)5L;
+    public static final int CXCallingConv_AAPCS = (int)6L;
+    public static final int CXCallingConv_AAPCS_VFP = (int)7L;
+    public static final int CXCallingConv_X86RegCall = (int)8L;
+    public static final int CXCallingConv_IntelOclBicc = (int)9L;
+    public static final int CXCallingConv_Win64 = (int)10L;
+    public static final int CXCallingConv_X86_64Win64 = (int)10L;
+    public static final int CXCallingConv_X86_64SysV = (int)11L;
+    public static final int CXCallingConv_X86VectorCall = (int)12L;
+    public static final int CXCallingConv_Swift = (int)13L;
+    public static final int CXCallingConv_PreserveMost = (int)14L;
+    public static final int CXCallingConv_PreserveAll = (int)15L;
+    public static final int CXCallingConv_AArch64VectorCall = (int)16L;
+    public static final int CXCallingConv_Invalid = (int)100L;
+    public static final int CXCallingConv_Unexposed = (int)200L;
+    public static final MemoryLayout CXType$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        MemoryLayout.ofPaddingBits(32),
+        MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+    );
+    public static final VarHandle CXType$kind = CXType$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXType$kind$get(MemorySegment seg) {
+        return (int)CXType$kind.get(seg.baseAddress());
+    }
+    public static final void CXType$kind$set(MemorySegment seg, int x) {
+        CXType$kind.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getCursorType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorType (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getCursorType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTypeSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTypeSpelling",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTypeSpelling (MemorySegment CT) {
+        try {
+            return (MemorySegment)clang_getTypeSpelling.invokeExact(CT);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTypedefDeclUnderlyingType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTypedefDeclUnderlyingType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTypedefDeclUnderlyingType (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getTypedefDeclUnderlyingType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getEnumDeclIntegerType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getEnumDeclIntegerType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getEnumDeclIntegerType (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getEnumDeclIntegerType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getEnumConstantDeclValue = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getEnumConstantDeclValue",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_getEnumConstantDeclValue (MemorySegment C) {
+        try {
+            return (long)clang_getEnumConstantDeclValue.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getEnumConstantDeclUnsignedValue = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getEnumConstantDeclUnsignedValue",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_getEnumConstantDeclUnsignedValue (MemorySegment C) {
+        try {
+            return (long)clang_getEnumConstantDeclUnsignedValue.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFieldDeclBitWidth = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFieldDeclBitWidth",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getFieldDeclBitWidth (MemorySegment C) {
+        try {
+            return (int)clang_getFieldDeclBitWidth.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getNumArguments = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getNumArguments",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_getNumArguments (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_getNumArguments.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getArgument = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getArgument",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Cursor_getArgument (MemorySegment C, int i) {
+        try {
+            return (MemorySegment)clang_Cursor_getArgument.invokeExact(C, i);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTemplateArgumentKind_Null = (int)0L;
+    public static final int CXTemplateArgumentKind_Type = (int)1L;
+    public static final int CXTemplateArgumentKind_Declaration = (int)2L;
+    public static final int CXTemplateArgumentKind_NullPtr = (int)3L;
+    public static final int CXTemplateArgumentKind_Integral = (int)4L;
+    public static final int CXTemplateArgumentKind_Template = (int)5L;
+    public static final int CXTemplateArgumentKind_TemplateExpansion = (int)6L;
+    public static final int CXTemplateArgumentKind_Expression = (int)7L;
+    public static final int CXTemplateArgumentKind_Pack = (int)8L;
+    public static final int CXTemplateArgumentKind_Invalid = (int)9L;
+    public static final MethodHandle clang_Cursor_getNumTemplateArguments = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getNumTemplateArguments",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_getNumTemplateArguments (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_getNumTemplateArguments.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getTemplateArgumentKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getTemplateArgumentKind",
+        "(Ljdk/incubator/foreign/MemorySegment;I)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final int clang_Cursor_getTemplateArgumentKind (MemorySegment C, int I) {
+        try {
+            return (int)clang_Cursor_getTemplateArgumentKind.invokeExact(C, I);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getTemplateArgumentType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getTemplateArgumentType",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Cursor_getTemplateArgumentType (MemorySegment C, int I) {
+        try {
+            return (MemorySegment)clang_Cursor_getTemplateArgumentType.invokeExact(C, I);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getTemplateArgumentValue = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getTemplateArgumentValue",
+        "(Ljdk/incubator/foreign/MemorySegment;I)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final long clang_Cursor_getTemplateArgumentValue (MemorySegment C, int I) {
+        try {
+            return (long)clang_Cursor_getTemplateArgumentValue.invokeExact(C, I);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getTemplateArgumentUnsignedValue = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getTemplateArgumentUnsignedValue",
+        "(Ljdk/incubator/foreign/MemorySegment;I)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final long clang_Cursor_getTemplateArgumentUnsignedValue (MemorySegment C, int I) {
+        try {
+            return (long)clang_Cursor_getTemplateArgumentUnsignedValue.invokeExact(C, I);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_equalTypes = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_equalTypes",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_equalTypes (MemorySegment A, MemorySegment B) {
+        try {
+            return (int)clang_equalTypes.invokeExact(A, B);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCanonicalType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCanonicalType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCanonicalType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getCanonicalType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isConstQualifiedType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isConstQualifiedType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isConstQualifiedType (MemorySegment T) {
+        try {
+            return (int)clang_isConstQualifiedType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isMacroFunctionLike = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isMacroFunctionLike",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isMacroFunctionLike (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isMacroFunctionLike.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isMacroBuiltin = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isMacroBuiltin",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isMacroBuiltin (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isMacroBuiltin.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isFunctionInlined = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isFunctionInlined",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isFunctionInlined (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isFunctionInlined.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isVolatileQualifiedType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isVolatileQualifiedType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isVolatileQualifiedType (MemorySegment T) {
+        try {
+            return (int)clang_isVolatileQualifiedType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isRestrictQualifiedType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isRestrictQualifiedType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isRestrictQualifiedType (MemorySegment T) {
+        try {
+            return (int)clang_isRestrictQualifiedType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getAddressSpace = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getAddressSpace",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getAddressSpace (MemorySegment T) {
+        try {
+            return (int)clang_getAddressSpace.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTypedefName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTypedefName",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTypedefName (MemorySegment CT) {
+        try {
+            return (MemorySegment)clang_getTypedefName.invokeExact(CT);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getPointeeType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getPointeeType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getPointeeType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getPointeeType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTypeDeclaration = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTypeDeclaration",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTypeDeclaration (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getTypeDeclaration.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDeclObjCTypeEncoding = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDeclObjCTypeEncoding",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getDeclObjCTypeEncoding (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getDeclObjCTypeEncoding.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getObjCEncoding = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getObjCEncoding",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Type_getObjCEncoding (MemorySegment type) {
+        try {
+            return (MemorySegment)clang_Type_getObjCEncoding.invokeExact(type);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTypeKindSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTypeKindSpelling",
+        "(I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getTypeKindSpelling (int K) {
+        try {
+            return (MemorySegment)clang_getTypeKindSpelling.invokeExact(K);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getFunctionTypeCallingConv = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getFunctionTypeCallingConv",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getFunctionTypeCallingConv (MemorySegment T) {
+        try {
+            return (int)clang_getFunctionTypeCallingConv.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getResultType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getResultType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getResultType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getResultType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getExceptionSpecificationType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getExceptionSpecificationType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getExceptionSpecificationType (MemorySegment T) {
+        try {
+            return (int)clang_getExceptionSpecificationType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNumArgTypes = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumArgTypes",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getNumArgTypes (MemorySegment T) {
+        try {
+            return (int)clang_getNumArgTypes.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getArgType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getArgType",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getArgType (MemorySegment T, int i) {
+        try {
+            return (MemorySegment)clang_getArgType.invokeExact(T, i);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getObjCObjectBaseType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getObjCObjectBaseType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Type_getObjCObjectBaseType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_Type_getObjCObjectBaseType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getNumObjCProtocolRefs = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getNumObjCProtocolRefs",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_getNumObjCProtocolRefs (MemorySegment T) {
+        try {
+            return (int)clang_Type_getNumObjCProtocolRefs.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getObjCProtocolDecl = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getObjCProtocolDecl",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Type_getObjCProtocolDecl (MemorySegment T, int i) {
+        try {
+            return (MemorySegment)clang_Type_getObjCProtocolDecl.invokeExact(T, i);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getNumObjCTypeArgs = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getNumObjCTypeArgs",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_getNumObjCTypeArgs (MemorySegment T) {
+        try {
+            return (int)clang_Type_getNumObjCTypeArgs.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getObjCTypeArg = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getObjCTypeArg",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Type_getObjCTypeArg (MemorySegment T, int i) {
+        try {
+            return (MemorySegment)clang_Type_getObjCTypeArg.invokeExact(T, i);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isFunctionTypeVariadic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isFunctionTypeVariadic",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isFunctionTypeVariadic (MemorySegment T) {
+        try {
+            return (int)clang_isFunctionTypeVariadic.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorResultType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorResultType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorResultType (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getCursorResultType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorExceptionSpecificationType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorExceptionSpecificationType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCursorExceptionSpecificationType (MemorySegment C) {
+        try {
+            return (int)clang_getCursorExceptionSpecificationType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isPODType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isPODType",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isPODType (MemorySegment T) {
+        try {
+            return (int)clang_isPODType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getElementType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getElementType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getElementType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getElementType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNumElements = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumElements",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_getNumElements (MemorySegment T) {
+        try {
+            return (long)clang_getNumElements.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getArrayElementType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getArrayElementType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getArrayElementType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_getArrayElementType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getArraySize = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getArraySize",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_getArraySize (MemorySegment T) {
+        try {
+            return (long)clang_getArraySize.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getNamedType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getNamedType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Type_getNamedType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_Type_getNamedType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_isTransparentTagTypedef = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_isTransparentTagTypedef",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_isTransparentTagTypedef (MemorySegment T) {
+        try {
+            return (int)clang_Type_isTransparentTagTypedef.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTypeNullability_NonNull = (int)0L;
+    public static final int CXTypeNullability_Nullable = (int)1L;
+    public static final int CXTypeNullability_Unspecified = (int)2L;
+    public static final int CXTypeNullability_Invalid = (int)3L;
+    public static final MethodHandle clang_Type_getNullability = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getNullability",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_getNullability (MemorySegment T) {
+        try {
+            return (int)clang_Type_getNullability.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXTypeLayoutError_Invalid = (int)-1L;
+    public static final int CXTypeLayoutError_Incomplete = (int)-2L;
+    public static final int CXTypeLayoutError_Dependent = (int)-3L;
+    public static final int CXTypeLayoutError_NotConstantSize = (int)-4L;
+    public static final int CXTypeLayoutError_InvalidFieldName = (int)-5L;
+    public static final int CXTypeLayoutError_Undeduced = (int)-6L;
+    public static final MethodHandle clang_Type_getAlignOf = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getAlignOf",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_Type_getAlignOf (MemorySegment T) {
+        try {
+            return (long)clang_Type_getAlignOf.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getClassType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getClassType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Type_getClassType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_Type_getClassType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getSizeOf = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getSizeOf",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_Type_getSizeOf (MemorySegment T) {
+        try {
+            return (long)clang_Type_getSizeOf.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getOffsetOf = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getOffsetOf",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_POINTER
+        )
+    );
+    public static final long clang_Type_getOffsetOf (MemorySegment T, MemoryAddress S) {
+        try {
+            return (long)clang_Type_getOffsetOf.invokeExact(T, S);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getModifiedType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getModifiedType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Type_getModifiedType (MemorySegment T) {
+        try {
+            return (MemorySegment)clang_Type_getModifiedType.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getOffsetOfField = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getOffsetOfField",
+        "(Ljdk/incubator/foreign/MemorySegment;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final long clang_Cursor_getOffsetOfField (MemorySegment C) {
+        try {
+            return (long)clang_Cursor_getOffsetOfField.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isAnonymous = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isAnonymous",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isAnonymous (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isAnonymous.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isAnonymousRecordDecl = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isAnonymousRecordDecl",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isAnonymousRecordDecl (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isAnonymousRecordDecl.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isInlineNamespace = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isInlineNamespace",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isInlineNamespace (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isInlineNamespace.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXRefQualifier_None = (int)0L;
+    public static final int CXRefQualifier_LValue = (int)1L;
+    public static final int CXRefQualifier_RValue = (int)2L;
+    public static final MethodHandle clang_Type_getNumTemplateArguments = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getNumTemplateArguments",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_getNumTemplateArguments (MemorySegment T) {
+        try {
+            return (int)clang_Type_getNumTemplateArguments.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getTemplateArgumentAsType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getTemplateArgumentAsType",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Type_getTemplateArgumentAsType (MemorySegment T, int i) {
+        try {
+            return (MemorySegment)clang_Type_getTemplateArgumentAsType.invokeExact(T, i);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_getCXXRefQualifier = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_getCXXRefQualifier",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Type_getCXXRefQualifier (MemorySegment T) {
+        try {
+            return (int)clang_Type_getCXXRefQualifier.invokeExact(T);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isBitField = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isBitField",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isBitField (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isBitField.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isVirtualBase = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isVirtualBase",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isVirtualBase (MemorySegment x0) {
+        try {
+            return (int)clang_isVirtualBase.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CX_CXXInvalidAccessSpecifier = (int)0L;
+    public static final int CX_CXXPublic = (int)1L;
+    public static final int CX_CXXProtected = (int)2L;
+    public static final int CX_CXXPrivate = (int)3L;
+    public static final MethodHandle clang_getCXXAccessSpecifier = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCXXAccessSpecifier",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getCXXAccessSpecifier (MemorySegment x0) {
+        try {
+            return (int)clang_getCXXAccessSpecifier.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CX_SC_Invalid = (int)0L;
+    public static final int CX_SC_None = (int)1L;
+    public static final int CX_SC_Extern = (int)2L;
+    public static final int CX_SC_Static = (int)3L;
+    public static final int CX_SC_PrivateExtern = (int)4L;
+    public static final int CX_SC_OpenCLWorkGroupLocal = (int)5L;
+    public static final int CX_SC_Auto = (int)6L;
+    public static final int CX_SC_Register = (int)7L;
+    public static final MethodHandle clang_Cursor_getStorageClass = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getStorageClass",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_getStorageClass (MemorySegment x0) {
+        try {
+            return (int)clang_Cursor_getStorageClass.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNumOverloadedDecls = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumOverloadedDecls",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getNumOverloadedDecls (MemorySegment cursor) {
+        try {
+            return (int)clang_getNumOverloadedDecls.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getOverloadedDecl = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getOverloadedDecl",
+        "(Ljdk/incubator/foreign/MemorySegment;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getOverloadedDecl (MemorySegment cursor, int index) {
+        try {
+            return (MemorySegment)clang_getOverloadedDecl.invokeExact(cursor, index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getIBOutletCollectionType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getIBOutletCollectionType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getIBOutletCollectionType (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getIBOutletCollectionType.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXChildVisit_Break = (int)0L;
+    public static final int CXChildVisit_Continue = (int)1L;
+    public static final int CXChildVisit_Recurse = (int)2L;
+    public static final MethodHandle clang_visitChildren = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_visitChildren",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_visitChildren (MemorySegment parent, MemoryAddress visitor, MemoryAddress client_data) {
+        try {
+            return (int)clang_visitChildren.invokeExact(parent, visitor, client_data);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    private static final FunctionDescriptor clang_visitChildren$visitor$DESC = FunctionDescriptor.of(C_INT,
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+        C_POINTER
+    );
+    public interface clang_visitChildren$visitor {
+        int apply(MemorySegment x0, MemorySegment x1, MemoryAddress x2);
+    }
+    public static final MemoryAddress clang_visitChildren$visitor$make(clang_visitChildren$visitor fi) {
+        return RuntimeHelper.upcallStub(clang_visitChildren$visitor.class, fi, clang_visitChildren$visitor$DESC, "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;)I");
+    }
+    public static final MethodHandle clang_getCursorUSR = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorUSR",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorUSR (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorUSR.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCClass = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCClass",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCClass (MemoryAddress class_name) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCClass.invokeExact(class_name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCCategory = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCCategory",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCCategory (MemoryAddress class_name, MemoryAddress category_name) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCCategory.invokeExact(class_name, category_name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCProtocol = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCProtocol",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCProtocol (MemoryAddress protocol_name) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCProtocol.invokeExact(protocol_name);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCIvar = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCIvar",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("private_flags"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCIvar (MemoryAddress name, MemorySegment classUSR) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCIvar.invokeExact(name, classUSR);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCMethod = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCMethod",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("private_flags"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCMethod (MemoryAddress name, int isInstanceMethod, MemorySegment classUSR) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCMethod.invokeExact(name, isInstanceMethod, classUSR);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_constructUSR_ObjCProperty = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_constructUSR_ObjCProperty",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("data"),
+                C_INT.withName("private_flags"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_constructUSR_ObjCProperty (MemoryAddress property, MemorySegment classUSR) {
+        try {
+            return (MemorySegment)clang_constructUSR_ObjCProperty.invokeExact(property, classUSR);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorSpelling",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorSpelling (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorSpelling.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getSpellingNameRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getSpellingNameRange",
+        "(Ljdk/incubator/foreign/MemorySegment;II)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_Cursor_getSpellingNameRange (MemorySegment x0, int pieceIndex, int options) {
+        try {
+            return (MemorySegment)clang_Cursor_getSpellingNameRange.invokeExact(x0, pieceIndex, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXPrintingPolicy_Indentation = (int)0L;
+    public static final int CXPrintingPolicy_SuppressSpecifiers = (int)1L;
+    public static final int CXPrintingPolicy_SuppressTagKeyword = (int)2L;
+    public static final int CXPrintingPolicy_IncludeTagDefinition = (int)3L;
+    public static final int CXPrintingPolicy_SuppressScope = (int)4L;
+    public static final int CXPrintingPolicy_SuppressUnwrittenScope = (int)5L;
+    public static final int CXPrintingPolicy_SuppressInitializers = (int)6L;
+    public static final int CXPrintingPolicy_ConstantArraySizeAsWritten = (int)7L;
+    public static final int CXPrintingPolicy_AnonymousTagLocations = (int)8L;
+    public static final int CXPrintingPolicy_SuppressStrongLifetime = (int)9L;
+    public static final int CXPrintingPolicy_SuppressLifetimeQualifiers = (int)10L;
+    public static final int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors = (int)11L;
+    public static final int CXPrintingPolicy_Bool = (int)12L;
+    public static final int CXPrintingPolicy_Restrict = (int)13L;
+    public static final int CXPrintingPolicy_Alignof = (int)14L;
+    public static final int CXPrintingPolicy_UnderscoreAlignof = (int)15L;
+    public static final int CXPrintingPolicy_UseVoidForZeroParams = (int)16L;
+    public static final int CXPrintingPolicy_TerseOutput = (int)17L;
+    public static final int CXPrintingPolicy_PolishForDeclaration = (int)18L;
+    public static final int CXPrintingPolicy_Half = (int)19L;
+    public static final int CXPrintingPolicy_MSWChar = (int)20L;
+    public static final int CXPrintingPolicy_IncludeNewlines = (int)21L;
+    public static final int CXPrintingPolicy_MSVCFormatting = (int)22L;
+    public static final int CXPrintingPolicy_ConstantsAsWritten = (int)23L;
+    public static final int CXPrintingPolicy_SuppressImplicitBase = (int)24L;
+    public static final int CXPrintingPolicy_FullyQualifiedName = (int)25L;
+    public static final int CXPrintingPolicy_LastProperty = (int)25L;
+    public static final MethodHandle clang_PrintingPolicy_getProperty = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_PrintingPolicy_getProperty",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_PrintingPolicy_getProperty (MemoryAddress Policy, int Property) {
+        try {
+            return (int)clang_PrintingPolicy_getProperty.invokeExact(Policy, Property);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_PrintingPolicy_setProperty = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_PrintingPolicy_setProperty",
+        "(Ljdk/incubator/foreign/MemoryAddress;II)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_INT,
+            C_INT
+        )
+    );
+    public static final void clang_PrintingPolicy_setProperty (MemoryAddress Policy, int Property, int Value) {
+        try {
+            clang_PrintingPolicy_setProperty.invokeExact(Policy, Property, Value);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorPrintingPolicy = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorPrintingPolicy",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_getCursorPrintingPolicy (MemorySegment x0) {
+        try {
+            return (MemoryAddress)clang_getCursorPrintingPolicy.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_PrintingPolicy_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_PrintingPolicy_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_PrintingPolicy_dispose (MemoryAddress Policy) {
+        try {
+            clang_PrintingPolicy_dispose.invokeExact(Policy);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorPrettyPrinted = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorPrettyPrinted",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getCursorPrettyPrinted (MemorySegment Cursor, MemoryAddress Policy) {
+        try {
+            return (MemorySegment)clang_getCursorPrettyPrinted.invokeExact(Cursor, Policy);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorDisplayName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorDisplayName",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorDisplayName (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorDisplayName.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorReferenced = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorReferenced",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorReferenced (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorReferenced.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorDefinition = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorDefinition",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCursorDefinition (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCursorDefinition.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_isCursorDefinition = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_isCursorDefinition",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_isCursorDefinition (MemorySegment x0) {
+        try {
+            return (int)clang_isCursorDefinition.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCanonicalCursor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCanonicalCursor",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getCanonicalCursor (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_getCanonicalCursor.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getObjCSelectorIndex = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCSelectorIndex",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_getObjCSelectorIndex (MemorySegment x0) {
+        try {
+            return (int)clang_Cursor_getObjCSelectorIndex.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isDynamicCall = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isDynamicCall",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isDynamicCall (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isDynamicCall.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getReceiverType = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getReceiverType",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            MemoryLayout.ofPaddingBits(32),
+            MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getReceiverType (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getReceiverType.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXObjCPropertyAttr_noattr = (int)0L;
+    public static final int CXObjCPropertyAttr_readonly = (int)1L;
+    public static final int CXObjCPropertyAttr_getter = (int)2L;
+    public static final int CXObjCPropertyAttr_assign = (int)4L;
+    public static final int CXObjCPropertyAttr_readwrite = (int)8L;
+    public static final int CXObjCPropertyAttr_retain = (int)16L;
+    public static final int CXObjCPropertyAttr_copy = (int)32L;
+    public static final int CXObjCPropertyAttr_nonatomic = (int)64L;
+    public static final int CXObjCPropertyAttr_setter = (int)128L;
+    public static final int CXObjCPropertyAttr_atomic = (int)256L;
+    public static final int CXObjCPropertyAttr_weak = (int)512L;
+    public static final int CXObjCPropertyAttr_strong = (int)1024L;
+    public static final int CXObjCPropertyAttr_unsafe_unretained = (int)2048L;
+    public static final int CXObjCPropertyAttr_class = (int)4096L;
+    public static final MethodHandle clang_Cursor_getObjCPropertyAttributes = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCPropertyAttributes",
+        "(Ljdk/incubator/foreign/MemorySegment;I)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT
+        )
+    );
+    public static final int clang_Cursor_getObjCPropertyAttributes (MemorySegment C, int reserved) {
+        try {
+            return (int)clang_Cursor_getObjCPropertyAttributes.invokeExact(C, reserved);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getObjCPropertyGetterName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCPropertyGetterName",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getObjCPropertyGetterName (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getObjCPropertyGetterName.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getObjCPropertySetterName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCPropertySetterName",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getObjCPropertySetterName (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getObjCPropertySetterName.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXObjCDeclQualifier_None = (int)0L;
+    public static final int CXObjCDeclQualifier_In = (int)1L;
+    public static final int CXObjCDeclQualifier_Inout = (int)2L;
+    public static final int CXObjCDeclQualifier_Out = (int)4L;
+    public static final int CXObjCDeclQualifier_Bycopy = (int)8L;
+    public static final int CXObjCDeclQualifier_Byref = (int)16L;
+    public static final int CXObjCDeclQualifier_Oneway = (int)32L;
+    public static final MethodHandle clang_Cursor_getObjCDeclQualifiers = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCDeclQualifiers",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_getObjCDeclQualifiers (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_getObjCDeclQualifiers.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isObjCOptional = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isObjCOptional",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isObjCOptional (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isObjCOptional.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isVariadic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isVariadic",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_Cursor_isVariadic (MemorySegment C) {
+        try {
+            return (int)clang_Cursor_isVariadic.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_isExternalSymbol = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_isExternalSymbol",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_Cursor_isExternalSymbol (MemorySegment C, MemoryAddress language, MemoryAddress definedIn, MemoryAddress isGenerated) {
+        try {
+            return (int)clang_Cursor_isExternalSymbol.invokeExact(C, language, definedIn, isGenerated);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getCommentRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getCommentRange",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getCommentRange (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getCommentRange.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getRawCommentText = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getRawCommentText",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getRawCommentText (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getRawCommentText.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getBriefCommentText = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getBriefCommentText",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getBriefCommentText (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_Cursor_getBriefCommentText.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getMangling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getMangling",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_Cursor_getMangling (MemorySegment x0) {
+        try {
+            return (MemorySegment)clang_Cursor_getMangling.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getCXXManglings = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getCXXManglings",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_Cursor_getCXXManglings (MemorySegment x0) {
+        try {
+            return (MemoryAddress)clang_Cursor_getCXXManglings.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getObjCManglings = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getObjCManglings",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_Cursor_getObjCManglings (MemorySegment x0) {
+        try {
+            return (MemoryAddress)clang_Cursor_getObjCManglings.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Cursor_getModule = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_getModule",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_Cursor_getModule (MemorySegment C) {
+        try {
+            return (MemoryAddress)clang_Cursor_getModule.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getModuleForFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getModuleForFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getModuleForFile (MemoryAddress x0, MemoryAddress x1) {
+        try {
+            return (MemoryAddress)clang_getModuleForFile.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getASTFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getASTFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_Module_getASTFile (MemoryAddress Module) {
+        try {
+            return (MemoryAddress)clang_Module_getASTFile.invokeExact(Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getParent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getParent",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_Module_getParent (MemoryAddress Module) {
+        try {
+            return (MemoryAddress)clang_Module_getParent.invokeExact(Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getName",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_Module_getName (MemoryAddress Module) {
+        try {
+            return (MemorySegment)clang_Module_getName.invokeExact(Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getFullName = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getFullName",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_Module_getFullName (MemoryAddress Module) {
+        try {
+            return (MemorySegment)clang_Module_getFullName.invokeExact(Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_isSystem = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_isSystem",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_Module_isSystem (MemoryAddress Module) {
+        try {
+            return (int)clang_Module_isSystem.invokeExact(Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getNumTopLevelHeaders = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getNumTopLevelHeaders",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_Module_getNumTopLevelHeaders (MemoryAddress x0, MemoryAddress Module) {
+        try {
+            return (int)clang_Module_getNumTopLevelHeaders.invokeExact(x0, Module);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Module_getTopLevelHeader = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Module_getTopLevelHeader",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_Module_getTopLevelHeader (MemoryAddress x0, MemoryAddress Module, int Index) {
+        try {
+            return (MemoryAddress)clang_Module_getTopLevelHeader.invokeExact(x0, Module, Index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXConstructor_isConvertingConstructor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXConstructor_isConvertingConstructor",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXConstructor_isConvertingConstructor (MemorySegment C) {
+        try {
+            return (int)clang_CXXConstructor_isConvertingConstructor.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXConstructor_isCopyConstructor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXConstructor_isCopyConstructor",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXConstructor_isCopyConstructor (MemorySegment C) {
+        try {
+            return (int)clang_CXXConstructor_isCopyConstructor.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXConstructor_isDefaultConstructor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXConstructor_isDefaultConstructor",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXConstructor_isDefaultConstructor (MemorySegment C) {
+        try {
+            return (int)clang_CXXConstructor_isDefaultConstructor.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXConstructor_isMoveConstructor = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXConstructor_isMoveConstructor",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXConstructor_isMoveConstructor (MemorySegment C) {
+        try {
+            return (int)clang_CXXConstructor_isMoveConstructor.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXField_isMutable = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXField_isMutable",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXField_isMutable (MemorySegment C) {
+        try {
+            return (int)clang_CXXField_isMutable.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXMethod_isDefaulted = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXMethod_isDefaulted",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXMethod_isDefaulted (MemorySegment C) {
+        try {
+            return (int)clang_CXXMethod_isDefaulted.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXMethod_isPureVirtual = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXMethod_isPureVirtual",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXMethod_isPureVirtual (MemorySegment C) {
+        try {
+            return (int)clang_CXXMethod_isPureVirtual.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXMethod_isStatic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXMethod_isStatic",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXMethod_isStatic (MemorySegment C) {
+        try {
+            return (int)clang_CXXMethod_isStatic.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXMethod_isVirtual = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXMethod_isVirtual",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXMethod_isVirtual (MemorySegment C) {
+        try {
+            return (int)clang_CXXMethod_isVirtual.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXRecord_isAbstract = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXRecord_isAbstract",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXRecord_isAbstract (MemorySegment C) {
+        try {
+            return (int)clang_CXXRecord_isAbstract.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EnumDecl_isScoped = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EnumDecl_isScoped",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_EnumDecl_isScoped (MemorySegment C) {
+        try {
+            return (int)clang_EnumDecl_isScoped.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_CXXMethod_isConst = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_CXXMethod_isConst",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_CXXMethod_isConst (MemorySegment C) {
+        try {
+            return (int)clang_CXXMethod_isConst.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTemplateCursorKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTemplateCursorKind",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final int clang_getTemplateCursorKind (MemorySegment C) {
+        try {
+            return (int)clang_getTemplateCursorKind.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getSpecializedCursorTemplate = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getSpecializedCursorTemplate",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getSpecializedCursorTemplate (MemorySegment C) {
+        try {
+            return (MemorySegment)clang_getSpecializedCursorTemplate.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorReferenceNameRange = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorReferenceNameRange",
+        "(Ljdk/incubator/foreign/MemorySegment;II)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getCursorReferenceNameRange (MemorySegment C, int NameFlags, int PieceIndex) {
+        try {
+            return (MemorySegment)clang_getCursorReferenceNameRange.invokeExact(C, NameFlags, PieceIndex);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXNameRange_WantQualifier = (int)1L;
+    public static final int CXNameRange_WantTemplateArgs = (int)2L;
+    public static final int CXNameRange_WantSinglePiece = (int)4L;
+    public static final int CXToken_Punctuation = (int)0L;
+    public static final int CXToken_Keyword = (int)1L;
+    public static final int CXToken_Identifier = (int)2L;
+    public static final int CXToken_Literal = (int)3L;
+    public static final int CXToken_Comment = (int)4L;
+    public static final MemoryLayout CXToken$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofSequence(4, C_INT).withName("int_data"),
+        C_POINTER.withName("ptr_data")
+    );
+    public static final MethodHandle clang_getToken = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getToken",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemoryAddress clang_getToken (MemoryAddress TU, MemorySegment Location) {
+        try {
+            return (MemoryAddress)clang_getToken.invokeExact(TU, Location);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTokenKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTokenKind",
+        "(Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(4, C_INT).withName("int_data"),
+                C_POINTER.withName("ptr_data")
+            )
+        )
+    );
+    public static final int clang_getTokenKind (MemorySegment x0) {
+        try {
+            return (int)clang_getTokenKind.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTokenSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTokenSpelling",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(4, C_INT).withName("int_data"),
+                C_POINTER.withName("ptr_data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTokenSpelling (MemoryAddress x0, MemorySegment x1) {
+        try {
+            return (MemorySegment)clang_getTokenSpelling.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTokenLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTokenLocation",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(4, C_INT).withName("int_data"),
+                C_POINTER.withName("ptr_data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTokenLocation (MemoryAddress x0, MemorySegment x1) {
+        try {
+            return (MemorySegment)clang_getTokenLocation.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getTokenExtent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getTokenExtent",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("begin_int_data"),
+            C_INT.withName("end_int_data")
+        ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(4, C_INT).withName("int_data"),
+                C_POINTER.withName("ptr_data")
+            )
+        )
+    );
+    public static final MemorySegment clang_getTokenExtent (MemoryAddress x0, MemorySegment x1) {
+        try {
+            return (MemorySegment)clang_getTokenExtent.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_tokenize = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_tokenize",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("begin_int_data"),
+                C_INT.withName("end_int_data")
+            ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_tokenize (MemoryAddress TU, MemorySegment Range, MemoryAddress Tokens, MemoryAddress NumTokens) {
+        try {
+            clang_tokenize.invokeExact(TU, Range, Tokens, NumTokens);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_annotateTokens = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_annotateTokens",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final void clang_annotateTokens (MemoryAddress TU, MemoryAddress Tokens, int NumTokens, MemoryAddress Cursors) {
+        try {
+            clang_annotateTokens.invokeExact(TU, Tokens, NumTokens, Cursors);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeTokens = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeTokens",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final void clang_disposeTokens (MemoryAddress TU, MemoryAddress Tokens, int NumTokens) {
+        try {
+            clang_disposeTokens.invokeExact(TU, Tokens, NumTokens);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorKindSpelling = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorKindSpelling",
+        "(I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getCursorKindSpelling (int Kind) {
+        try {
+            return (MemorySegment)clang_getCursorKindSpelling.invokeExact(Kind);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getDefinitionSpellingAndExtent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getDefinitionSpellingAndExtent",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getDefinitionSpellingAndExtent (MemorySegment x0, MemoryAddress startBuf, MemoryAddress endBuf, MemoryAddress startLine, MemoryAddress startColumn, MemoryAddress endLine, MemoryAddress endColumn) {
+        try {
+            clang_getDefinitionSpellingAndExtent.invokeExact(x0, startBuf, endBuf, startLine, startColumn, endLine, endColumn);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_enableStackTraces = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_enableStackTraces",
+        "()V",
+        FunctionDescriptor.ofVoid()
+    );
+    public static final void clang_enableStackTraces () {
+        try {
+            clang_enableStackTraces.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_executeOnThread = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_executeOnThread",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;I)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final void clang_executeOnThread (MemoryAddress fn, MemoryAddress user_data, int stack_size) {
+        try {
+            clang_executeOnThread.invokeExact(fn, user_data, stack_size);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    private static final FunctionDescriptor clang_executeOnThread$fn$DESC = FunctionDescriptor.ofVoid(
+        C_POINTER
+    );
+    public interface clang_executeOnThread$fn {
+        void apply(MemoryAddress x0);
+    }
+    public static final MemoryAddress clang_executeOnThread$fn$make(clang_executeOnThread$fn fi) {
+        return RuntimeHelper.upcallStub(clang_executeOnThread$fn.class, fi, clang_executeOnThread$fn$DESC, "(Ljdk/incubator/foreign/MemoryAddress;)V");
+    }
+    public static final MemoryLayout CXCompletionResult$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("CursorKind"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("CompletionString")
+    );
+    public static final VarHandle CXCompletionResult$CursorKind = CXCompletionResult$LAYOUT.varHandle(int.class, PathElement.groupElement("CursorKind"));
+    public static final int CXCompletionResult$CursorKind$get(MemorySegment seg) {
+        return (int)CXCompletionResult$CursorKind.get(seg.baseAddress());
+    }
+    public static final void CXCompletionResult$CursorKind$set(MemorySegment seg, int x) {
+        CXCompletionResult$CursorKind.set(seg.baseAddress(), x);
+    }
+    public static final int CXCompletionChunk_Optional = (int)0L;
+    public static final int CXCompletionChunk_TypedText = (int)1L;
+    public static final int CXCompletionChunk_Text = (int)2L;
+    public static final int CXCompletionChunk_Placeholder = (int)3L;
+    public static final int CXCompletionChunk_Informative = (int)4L;
+    public static final int CXCompletionChunk_CurrentParameter = (int)5L;
+    public static final int CXCompletionChunk_LeftParen = (int)6L;
+    public static final int CXCompletionChunk_RightParen = (int)7L;
+    public static final int CXCompletionChunk_LeftBracket = (int)8L;
+    public static final int CXCompletionChunk_RightBracket = (int)9L;
+    public static final int CXCompletionChunk_LeftBrace = (int)10L;
+    public static final int CXCompletionChunk_RightBrace = (int)11L;
+    public static final int CXCompletionChunk_LeftAngle = (int)12L;
+    public static final int CXCompletionChunk_RightAngle = (int)13L;
+    public static final int CXCompletionChunk_Comma = (int)14L;
+    public static final int CXCompletionChunk_ResultType = (int)15L;
+    public static final int CXCompletionChunk_Colon = (int)16L;
+    public static final int CXCompletionChunk_SemiColon = (int)17L;
+    public static final int CXCompletionChunk_Equal = (int)18L;
+    public static final int CXCompletionChunk_HorizontalSpace = (int)19L;
+    public static final int CXCompletionChunk_VerticalSpace = (int)20L;
+    public static final MethodHandle clang_getCompletionChunkKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionChunkKind",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_getCompletionChunkKind (MemoryAddress completion_string, int chunk_number) {
+        try {
+            return (int)clang_getCompletionChunkKind.invokeExact(completion_string, chunk_number);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionChunkText = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionChunkText",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getCompletionChunkText (MemoryAddress completion_string, int chunk_number) {
+        try {
+            return (MemorySegment)clang_getCompletionChunkText.invokeExact(completion_string, chunk_number);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionChunkCompletionString = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionChunkCompletionString",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_getCompletionChunkCompletionString (MemoryAddress completion_string, int chunk_number) {
+        try {
+            return (MemoryAddress)clang_getCompletionChunkCompletionString.invokeExact(completion_string, chunk_number);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getNumCompletionChunks = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getNumCompletionChunks",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getNumCompletionChunks (MemoryAddress completion_string) {
+        try {
+            return (int)clang_getNumCompletionChunks.invokeExact(completion_string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionPriority = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionPriority",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getCompletionPriority (MemoryAddress completion_string) {
+        try {
+            return (int)clang_getCompletionPriority.invokeExact(completion_string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionAvailability = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionAvailability",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getCompletionAvailability (MemoryAddress completion_string) {
+        try {
+            return (int)clang_getCompletionAvailability.invokeExact(completion_string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionNumAnnotations = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionNumAnnotations",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_getCompletionNumAnnotations (MemoryAddress completion_string) {
+        try {
+            return (int)clang_getCompletionNumAnnotations.invokeExact(completion_string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionAnnotation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionAnnotation",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemorySegment clang_getCompletionAnnotation (MemoryAddress completion_string, int annotation_number) {
+        try {
+            return (MemorySegment)clang_getCompletionAnnotation.invokeExact(completion_string, annotation_number);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionParent = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionParent",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getCompletionParent (MemoryAddress completion_string, MemoryAddress kind) {
+        try {
+            return (MemorySegment)clang_getCompletionParent.invokeExact(completion_string, kind);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionBriefComment = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionBriefComment",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getCompletionBriefComment (MemoryAddress completion_string) {
+        try {
+            return (MemorySegment)clang_getCompletionBriefComment.invokeExact(completion_string);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCursorCompletionString = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCursorCompletionString",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_getCursorCompletionString (MemorySegment cursor) {
+        try {
+            return (MemoryAddress)clang_getCursorCompletionString.invokeExact(cursor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXCodeCompleteResults$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("Results"),
+        C_INT.withName("NumResults"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXCodeCompleteResults$NumResults = CXCodeCompleteResults$LAYOUT.varHandle(int.class, PathElement.groupElement("NumResults"));
+    public static final int CXCodeCompleteResults$NumResults$get(MemorySegment seg) {
+        return (int)CXCodeCompleteResults$NumResults.get(seg.baseAddress());
+    }
+    public static final void CXCodeCompleteResults$NumResults$set(MemorySegment seg, int x) {
+        CXCodeCompleteResults$NumResults.set(seg.baseAddress(), x);
+    }
+    public static final MethodHandle clang_getCompletionNumFixIts = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionNumFixIts",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_getCompletionNumFixIts (MemoryAddress results, int completion_index) {
+        try {
+            return (int)clang_getCompletionNumFixIts.invokeExact(results, completion_index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getCompletionFixIt = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getCompletionFixIt",
+        "(Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_getCompletionFixIt (MemoryAddress results, int completion_index, int fixit_index, MemoryAddress replacement_range) {
+        try {
+            return (MemorySegment)clang_getCompletionFixIt.invokeExact(results, completion_index, fixit_index, replacement_range);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXCodeComplete_IncludeMacros = (int)1L;
+    public static final int CXCodeComplete_IncludeCodePatterns = (int)2L;
+    public static final int CXCodeComplete_IncludeBriefComments = (int)4L;
+    public static final int CXCodeComplete_SkipPreamble = (int)8L;
+    public static final int CXCodeComplete_IncludeCompletionsWithFixIts = (int)16L;
+    public static final int CXCompletionContext_Unexposed = (int)0L;
+    public static final int CXCompletionContext_AnyType = (int)1L;
+    public static final int CXCompletionContext_AnyValue = (int)2L;
+    public static final int CXCompletionContext_ObjCObjectValue = (int)4L;
+    public static final int CXCompletionContext_ObjCSelectorValue = (int)8L;
+    public static final int CXCompletionContext_CXXClassTypeValue = (int)16L;
+    public static final int CXCompletionContext_DotMemberAccess = (int)32L;
+    public static final int CXCompletionContext_ArrowMemberAccess = (int)64L;
+    public static final int CXCompletionContext_ObjCPropertyAccess = (int)128L;
+    public static final int CXCompletionContext_EnumTag = (int)256L;
+    public static final int CXCompletionContext_UnionTag = (int)512L;
+    public static final int CXCompletionContext_StructTag = (int)1024L;
+    public static final int CXCompletionContext_ClassTag = (int)2048L;
+    public static final int CXCompletionContext_Namespace = (int)4096L;
+    public static final int CXCompletionContext_NestedNameSpecifier = (int)8192L;
+    public static final int CXCompletionContext_ObjCInterface = (int)16384L;
+    public static final int CXCompletionContext_ObjCProtocol = (int)32768L;
+    public static final int CXCompletionContext_ObjCCategory = (int)65536L;
+    public static final int CXCompletionContext_ObjCInstanceMessage = (int)131072L;
+    public static final int CXCompletionContext_ObjCClassMessage = (int)262144L;
+    public static final int CXCompletionContext_ObjCSelectorName = (int)524288L;
+    public static final int CXCompletionContext_MacroName = (int)1048576L;
+    public static final int CXCompletionContext_NaturalLanguage = (int)2097152L;
+    public static final int CXCompletionContext_IncludedFile = (int)4194304L;
+    public static final int CXCompletionContext_Unknown = (int)8388607L;
+    public static final MethodHandle clang_defaultCodeCompleteOptions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_defaultCodeCompleteOptions",
+        "()I",
+        FunctionDescriptor.of(C_INT)
+    );
+    public static final int clang_defaultCodeCompleteOptions () {
+        try {
+            return (int)clang_defaultCodeCompleteOptions.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteAt = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteAt",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;II)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_codeCompleteAt (MemoryAddress TU, MemoryAddress complete_filename, int complete_line, int complete_column, MemoryAddress unsaved_files, int num_unsaved_files, int options) {
+        try {
+            return (MemoryAddress)clang_codeCompleteAt.invokeExact(TU, complete_filename, complete_line, complete_column, unsaved_files, num_unsaved_files, options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_sortCodeCompletionResults = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_sortCodeCompletionResults",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final void clang_sortCodeCompletionResults (MemoryAddress Results, int NumResults) {
+        try {
+            clang_sortCodeCompletionResults.invokeExact(Results, NumResults);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_disposeCodeCompleteResults = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_disposeCodeCompleteResults",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_disposeCodeCompleteResults (MemoryAddress Results) {
+        try {
+            clang_disposeCodeCompleteResults.invokeExact(Results);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetNumDiagnostics = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetNumDiagnostics",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_codeCompleteGetNumDiagnostics (MemoryAddress Results) {
+        try {
+            return (int)clang_codeCompleteGetNumDiagnostics.invokeExact(Results);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetDiagnostic = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetDiagnostic",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_codeCompleteGetDiagnostic (MemoryAddress Results, int Index) {
+        try {
+            return (MemoryAddress)clang_codeCompleteGetDiagnostic.invokeExact(Results, Index);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetContexts = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetContexts",
+        "(Ljdk/incubator/foreign/MemoryAddress;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            C_POINTER
+        )
+    );
+    public static final long clang_codeCompleteGetContexts (MemoryAddress Results) {
+        try {
+            return (long)clang_codeCompleteGetContexts.invokeExact(Results);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetContainerKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetContainerKind",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_codeCompleteGetContainerKind (MemoryAddress Results, MemoryAddress IsIncomplete) {
+        try {
+            return (int)clang_codeCompleteGetContainerKind.invokeExact(Results, IsIncomplete);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetContainerUSR = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetContainerUSR",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_codeCompleteGetContainerUSR (MemoryAddress Results) {
+        try {
+            return (MemorySegment)clang_codeCompleteGetContainerUSR.invokeExact(Results);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_codeCompleteGetObjCSelector = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_codeCompleteGetObjCSelector",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            C_POINTER
+        )
+    );
+    public static final MemorySegment clang_codeCompleteGetObjCSelector (MemoryAddress Results) {
+        try {
+            return (MemorySegment)clang_codeCompleteGetObjCSelector.invokeExact(Results);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getClangVersion = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getClangVersion",
+        "()Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            C_POINTER.withName("data"),
+            C_INT.withName("private_flags"),
+            MemoryLayout.ofPaddingBits(32)
+        ))
+    );
+    public static final MemorySegment clang_getClangVersion () {
+        try {
+            return (MemorySegment)clang_getClangVersion.invokeExact();
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_toggleCrashRecovery = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_toggleCrashRecovery",
+        "(I)V",
+        FunctionDescriptor.ofVoid(
+            C_INT
+        )
+    );
+    public static final void clang_toggleCrashRecovery (int isEnabled) {
+        try {
+            clang_toggleCrashRecovery.invokeExact(isEnabled);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getInclusions = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getInclusions",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_getInclusions (MemoryAddress tu, MemoryAddress visitor, MemoryAddress client_data) {
+        try {
+            clang_getInclusions.invokeExact(tu, visitor, client_data);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    private static final FunctionDescriptor clang_getInclusions$visitor$DESC = FunctionDescriptor.ofVoid(
+        C_POINTER,
+        C_POINTER,
+        C_INT,
+        C_POINTER
+    );
+    public interface clang_getInclusions$visitor {
+        void apply(MemoryAddress x0, MemoryAddress x1, int x2, MemoryAddress x3);
+    }
+    public static final MemoryAddress clang_getInclusions$visitor$make(clang_getInclusions$visitor fi) {
+        return RuntimeHelper.upcallStub(clang_getInclusions$visitor.class, fi, clang_getInclusions$visitor$DESC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;)V");
+    }
+    public static final int CXEval_Int = (int)1L;
+    public static final int CXEval_Float = (int)2L;
+    public static final int CXEval_ObjCStrLiteral = (int)3L;
+    public static final int CXEval_StrLiteral = (int)4L;
+    public static final int CXEval_CFStr = (int)5L;
+    public static final int CXEval_Other = (int)6L;
+    public static final int CXEval_UnExposed = (int)0L;
+    public static final MethodHandle clang_Cursor_Evaluate = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Cursor_Evaluate",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            )
+        )
+    );
+    public static final MemoryAddress clang_Cursor_Evaluate (MemorySegment C) {
+        try {
+            return (MemoryAddress)clang_Cursor_Evaluate.invokeExact(C);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getKind",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_EvalResult_getKind (MemoryAddress E) {
+        try {
+            return (int)clang_EvalResult_getKind.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getAsInt = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getAsInt",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_EvalResult_getAsInt (MemoryAddress E) {
+        try {
+            return (int)clang_EvalResult_getAsInt.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getAsLongLong = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getAsLongLong",
+        "(Ljdk/incubator/foreign/MemoryAddress;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            C_POINTER
+        )
+    );
+    public static final long clang_EvalResult_getAsLongLong (MemoryAddress E) {
+        try {
+            return (long)clang_EvalResult_getAsLongLong.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_isUnsignedInt = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_isUnsignedInt",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_EvalResult_isUnsignedInt (MemoryAddress E) {
+        try {
+            return (int)clang_EvalResult_isUnsignedInt.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getAsUnsigned = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getAsUnsigned",
+        "(Ljdk/incubator/foreign/MemoryAddress;)J",
+        FunctionDescriptor.of(C_LONGLONG,
+            C_POINTER
+        )
+    );
+    public static final long clang_EvalResult_getAsUnsigned (MemoryAddress E) {
+        try {
+            return (long)clang_EvalResult_getAsUnsigned.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getAsDouble = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getAsDouble",
+        "(Ljdk/incubator/foreign/MemoryAddress;)D",
+        FunctionDescriptor.of(C_DOUBLE,
+            C_POINTER
+        )
+    );
+    public static final double clang_EvalResult_getAsDouble (MemoryAddress E) {
+        try {
+            return (double)clang_EvalResult_getAsDouble.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_getAsStr = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_getAsStr",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_EvalResult_getAsStr (MemoryAddress E) {
+        try {
+            return (MemoryAddress)clang_EvalResult_getAsStr.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_EvalResult_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_EvalResult_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_EvalResult_dispose (MemoryAddress E) {
+        try {
+            clang_EvalResult_dispose.invokeExact(E);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getRemappings = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getRemappings",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_getRemappings (MemoryAddress path) {
+        try {
+            return (MemoryAddress)clang_getRemappings.invokeExact(path);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_getRemappingsFromFileList = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_getRemappingsFromFileList",
+        "(Ljdk/incubator/foreign/MemoryAddress;I)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final MemoryAddress clang_getRemappingsFromFileList (MemoryAddress filePaths, int numFiles) {
+        try {
+            return (MemoryAddress)clang_getRemappingsFromFileList.invokeExact(filePaths, numFiles);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_remap_getNumFiles = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_remap_getNumFiles",
+        "(Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_remap_getNumFiles (MemoryAddress x0) {
+        try {
+            return (int)clang_remap_getNumFiles.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_remap_getFilenames = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_remap_getFilenames",
+        "(Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_remap_getFilenames (MemoryAddress x0, int index, MemoryAddress original, MemoryAddress transformed) {
+        try {
+            clang_remap_getFilenames.invokeExact(x0, index, original, transformed);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_remap_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_remap_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_remap_dispose (MemoryAddress x0) {
+        try {
+            clang_remap_dispose.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXVisit_Break = (int)0L;
+    public static final int CXVisit_Continue = (int)1L;
+    public static final MemoryLayout CXCursorAndRangeVisitor$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("context"),
+        C_POINTER.withName("visit")
+    ).withName("CXCursorAndRangeVisitor");
+    public static final int CXResult_Success = (int)0L;
+    public static final int CXResult_Invalid = (int)1L;
+    public static final int CXResult_VisitBreak = (int)2L;
+    public static final MethodHandle clang_findReferencesInFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_findReferencesInFile",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                C_INT.withName("xdata"),
+                MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("context"),
+                C_POINTER.withName("visit")
+            ).withName("CXCursorAndRangeVisitor")
+        )
+    );
+    public static final int clang_findReferencesInFile (MemorySegment cursor, MemoryAddress file, MemorySegment visitor) {
+        try {
+            return (int)clang_findReferencesInFile.invokeExact(cursor, file, visitor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_findIncludesInFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_findIncludesInFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemorySegment;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            MemoryLayout.ofStruct(
+                C_POINTER.withName("context"),
+                C_POINTER.withName("visit")
+            ).withName("CXCursorAndRangeVisitor")
+        )
+    );
+    public static final int clang_findIncludesInFile (MemoryAddress TU, MemoryAddress file, MemorySegment visitor) {
+        try {
+            return (int)clang_findIncludesInFile.invokeExact(TU, file, visitor);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MemoryLayout CXIdxLoc$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+        C_INT.withName("int_data"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxLoc$int_data = CXIdxLoc$LAYOUT.varHandle(int.class, PathElement.groupElement("int_data"));
+    public static final int CXIdxLoc$int_data$get(MemorySegment seg) {
+        return (int)CXIdxLoc$int_data.get(seg.baseAddress());
+    }
+    public static final void CXIdxLoc$int_data$set(MemorySegment seg, int x) {
+        CXIdxLoc$int_data.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxIncludedFileInfo$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("hashLoc"),
+        C_POINTER.withName("filename"),
+        C_POINTER.withName("file"),
+        C_INT.withName("isImport"),
+        C_INT.withName("isAngled"),
+        C_INT.withName("isModuleImport"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxIncludedFileInfo$isImport = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImport"));
+    public static final int CXIdxIncludedFileInfo$isImport$get(MemorySegment seg) {
+        return (int)CXIdxIncludedFileInfo$isImport.get(seg.baseAddress());
+    }
+    public static final void CXIdxIncludedFileInfo$isImport$set(MemorySegment seg, int x) {
+        CXIdxIncludedFileInfo$isImport.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxIncludedFileInfo$isAngled = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isAngled"));
+    public static final int CXIdxIncludedFileInfo$isAngled$get(MemorySegment seg) {
+        return (int)CXIdxIncludedFileInfo$isAngled.get(seg.baseAddress());
+    }
+    public static final void CXIdxIncludedFileInfo$isAngled$set(MemorySegment seg, int x) {
+        CXIdxIncludedFileInfo$isAngled.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxIncludedFileInfo$isModuleImport = CXIdxIncludedFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isModuleImport"));
+    public static final int CXIdxIncludedFileInfo$isModuleImport$get(MemorySegment seg) {
+        return (int)CXIdxIncludedFileInfo$isModuleImport.get(seg.baseAddress());
+    }
+    public static final void CXIdxIncludedFileInfo$isModuleImport$set(MemorySegment seg, int x) {
+        CXIdxIncludedFileInfo$isModuleImport.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxImportedASTFileInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("file"),
+        C_POINTER.withName("module"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc"),
+        C_INT.withName("isImplicit"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxImportedASTFileInfo$isImplicit = CXIdxImportedASTFileInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImplicit"));
+    public static final int CXIdxImportedASTFileInfo$isImplicit$get(MemorySegment seg) {
+        return (int)CXIdxImportedASTFileInfo$isImplicit.get(seg.baseAddress());
+    }
+    public static final void CXIdxImportedASTFileInfo$isImplicit$set(MemorySegment seg, int x) {
+        CXIdxImportedASTFileInfo$isImplicit.set(seg.baseAddress(), x);
+    }
+    public static final int CXIdxEntity_Unexposed = (int)0L;
+    public static final int CXIdxEntity_Typedef = (int)1L;
+    public static final int CXIdxEntity_Function = (int)2L;
+    public static final int CXIdxEntity_Variable = (int)3L;
+    public static final int CXIdxEntity_Field = (int)4L;
+    public static final int CXIdxEntity_EnumConstant = (int)5L;
+    public static final int CXIdxEntity_ObjCClass = (int)6L;
+    public static final int CXIdxEntity_ObjCProtocol = (int)7L;
+    public static final int CXIdxEntity_ObjCCategory = (int)8L;
+    public static final int CXIdxEntity_ObjCInstanceMethod = (int)9L;
+    public static final int CXIdxEntity_ObjCClassMethod = (int)10L;
+    public static final int CXIdxEntity_ObjCProperty = (int)11L;
+    public static final int CXIdxEntity_ObjCIvar = (int)12L;
+    public static final int CXIdxEntity_Enum = (int)13L;
+    public static final int CXIdxEntity_Struct = (int)14L;
+    public static final int CXIdxEntity_Union = (int)15L;
+    public static final int CXIdxEntity_CXXClass = (int)16L;
+    public static final int CXIdxEntity_CXXNamespace = (int)17L;
+    public static final int CXIdxEntity_CXXNamespaceAlias = (int)18L;
+    public static final int CXIdxEntity_CXXStaticVariable = (int)19L;
+    public static final int CXIdxEntity_CXXStaticMethod = (int)20L;
+    public static final int CXIdxEntity_CXXInstanceMethod = (int)21L;
+    public static final int CXIdxEntity_CXXConstructor = (int)22L;
+    public static final int CXIdxEntity_CXXDestructor = (int)23L;
+    public static final int CXIdxEntity_CXXConversionFunction = (int)24L;
+    public static final int CXIdxEntity_CXXTypeAlias = (int)25L;
+    public static final int CXIdxEntity_CXXInterface = (int)26L;
+    public static final int CXIdxEntityLang_None = (int)0L;
+    public static final int CXIdxEntityLang_C = (int)1L;
+    public static final int CXIdxEntityLang_ObjC = (int)2L;
+    public static final int CXIdxEntityLang_CXX = (int)3L;
+    public static final int CXIdxEntityLang_Swift = (int)4L;
+    public static final int CXIdxEntity_NonTemplate = (int)0L;
+    public static final int CXIdxEntity_Template = (int)1L;
+    public static final int CXIdxEntity_TemplatePartialSpecialization = (int)2L;
+    public static final int CXIdxEntity_TemplateSpecialization = (int)3L;
+    public static final int CXIdxAttr_Unexposed = (int)0L;
+    public static final int CXIdxAttr_IBAction = (int)1L;
+    public static final int CXIdxAttr_IBOutlet = (int)2L;
+    public static final int CXIdxAttr_IBOutletCollection = (int)3L;
+    public static final MemoryLayout CXIdxAttrInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        MemoryLayout.ofPaddingBits(32),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc")
+    );
+    public static final VarHandle CXIdxAttrInfo$kind = CXIdxAttrInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXIdxAttrInfo$kind$get(MemorySegment seg) {
+        return (int)CXIdxAttrInfo$kind.get(seg.baseAddress());
+    }
+    public static final void CXIdxAttrInfo$kind$set(MemorySegment seg, int x) {
+        CXIdxAttrInfo$kind.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxEntityInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        C_INT.withName("templateKind"),
+        C_INT.withName("lang"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("name"),
+        C_POINTER.withName("USR"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        C_POINTER.withName("attributes"),
+        C_INT.withName("numAttributes"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxEntityInfo$kind = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXIdxEntityInfo$kind$get(MemorySegment seg) {
+        return (int)CXIdxEntityInfo$kind.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityInfo$kind$set(MemorySegment seg, int x) {
+        CXIdxEntityInfo$kind.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxEntityInfo$templateKind = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("templateKind"));
+    public static final int CXIdxEntityInfo$templateKind$get(MemorySegment seg) {
+        return (int)CXIdxEntityInfo$templateKind.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityInfo$templateKind$set(MemorySegment seg, int x) {
+        CXIdxEntityInfo$templateKind.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxEntityInfo$lang = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("lang"));
+    public static final int CXIdxEntityInfo$lang$get(MemorySegment seg) {
+        return (int)CXIdxEntityInfo$lang.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityInfo$lang$set(MemorySegment seg, int x) {
+        CXIdxEntityInfo$lang.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxEntityInfo$numAttributes = CXIdxEntityInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numAttributes"));
+    public static final int CXIdxEntityInfo$numAttributes$get(MemorySegment seg) {
+        return (int)CXIdxEntityInfo$numAttributes.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityInfo$numAttributes$set(MemorySegment seg, int x) {
+        CXIdxEntityInfo$numAttributes.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxContainerInfo$LAYOUT = MemoryLayout.ofStruct(
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor")
+    );
+    public static final MemoryLayout CXIdxIBOutletCollectionAttrInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("attrInfo"),
+        C_POINTER.withName("objcClass"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("classCursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("classLoc")
+    );
+    public static final int CXIdxDeclFlag_Skipped = (int)1L;
+    public static final MemoryLayout CXIdxDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("entityInfo"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc"),
+        C_POINTER.withName("semanticContainer"),
+        C_POINTER.withName("lexicalContainer"),
+        C_INT.withName("isRedeclaration"),
+        C_INT.withName("isDefinition"),
+        C_INT.withName("isContainer"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("declAsContainer"),
+        C_INT.withName("isImplicit"),
+        MemoryLayout.ofPaddingBits(32),
+        C_POINTER.withName("attributes"),
+        C_INT.withName("numAttributes"),
+        C_INT.withName("flags")
+    );
+    public static final VarHandle CXIdxDeclInfo$isRedeclaration = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isRedeclaration"));
+    public static final int CXIdxDeclInfo$isRedeclaration$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$isRedeclaration.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$isRedeclaration$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$isRedeclaration.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxDeclInfo$isDefinition = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isDefinition"));
+    public static final int CXIdxDeclInfo$isDefinition$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$isDefinition.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$isDefinition$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$isDefinition.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxDeclInfo$isContainer = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isContainer"));
+    public static final int CXIdxDeclInfo$isContainer$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$isContainer.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$isContainer$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$isContainer.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxDeclInfo$isImplicit = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("isImplicit"));
+    public static final int CXIdxDeclInfo$isImplicit$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$isImplicit.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$isImplicit$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$isImplicit.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxDeclInfo$numAttributes = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numAttributes"));
+    public static final int CXIdxDeclInfo$numAttributes$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$numAttributes.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$numAttributes$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$numAttributes.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxDeclInfo$flags = CXIdxDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("flags"));
+    public static final int CXIdxDeclInfo$flags$get(MemorySegment seg) {
+        return (int)CXIdxDeclInfo$flags.get(seg.baseAddress());
+    }
+    public static final void CXIdxDeclInfo$flags$set(MemorySegment seg, int x) {
+        CXIdxDeclInfo$flags.set(seg.baseAddress(), x);
+    }
+    public static final int CXIdxObjCContainer_ForwardRef = (int)0L;
+    public static final int CXIdxObjCContainer_Interface = (int)1L;
+    public static final int CXIdxObjCContainer_Implementation = (int)2L;
+    public static final MemoryLayout CXIdxObjCContainerDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("declInfo"),
+        C_INT.withName("kind"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxObjCContainerDeclInfo$kind = CXIdxObjCContainerDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXIdxObjCContainerDeclInfo$kind$get(MemorySegment seg) {
+        return (int)CXIdxObjCContainerDeclInfo$kind.get(seg.baseAddress());
+    }
+    public static final void CXIdxObjCContainerDeclInfo$kind$set(MemorySegment seg, int x) {
+        CXIdxObjCContainerDeclInfo$kind.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxBaseClassInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("base"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc")
+    );
+    public static final MemoryLayout CXIdxObjCProtocolRefInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("protocol"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc")
+    );
+    public static final MemoryLayout CXIdxObjCProtocolRefListInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("protocols"),
+        C_INT.withName("numProtocols"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxObjCProtocolRefListInfo$numProtocols = CXIdxObjCProtocolRefListInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numProtocols"));
+    public static final int CXIdxObjCProtocolRefListInfo$numProtocols$get(MemorySegment seg) {
+        return (int)CXIdxObjCProtocolRefListInfo$numProtocols.get(seg.baseAddress());
+    }
+    public static final void CXIdxObjCProtocolRefListInfo$numProtocols$set(MemorySegment seg, int x) {
+        CXIdxObjCProtocolRefListInfo$numProtocols.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout CXIdxObjCInterfaceDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("containerInfo"),
+        C_POINTER.withName("superInfo"),
+        C_POINTER.withName("protocols")
+    );
+    public static final MemoryLayout CXIdxObjCCategoryDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("containerInfo"),
+        C_POINTER.withName("objcClass"),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("classCursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("classLoc"),
+        C_POINTER.withName("protocols")
+    );
+    public static final MemoryLayout CXIdxObjCPropertyDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("declInfo"),
+        C_POINTER.withName("getter"),
+        C_POINTER.withName("setter")
+    );
+    public static final MemoryLayout CXIdxCXXClassDeclInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("declInfo"),
+        C_POINTER.withName("bases"),
+        C_INT.withName("numBases"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxCXXClassDeclInfo$numBases = CXIdxCXXClassDeclInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("numBases"));
+    public static final int CXIdxCXXClassDeclInfo$numBases$get(MemorySegment seg) {
+        return (int)CXIdxCXXClassDeclInfo$numBases.get(seg.baseAddress());
+    }
+    public static final void CXIdxCXXClassDeclInfo$numBases$set(MemorySegment seg, int x) {
+        CXIdxCXXClassDeclInfo$numBases.set(seg.baseAddress(), x);
+    }
+    public static final int CXIdxEntityRef_Direct = (int)1L;
+    public static final int CXIdxEntityRef_Implicit = (int)2L;
+    public static final int CXSymbolRole_None = (int)0L;
+    public static final int CXSymbolRole_Declaration = (int)1L;
+    public static final int CXSymbolRole_Definition = (int)2L;
+    public static final int CXSymbolRole_Reference = (int)4L;
+    public static final int CXSymbolRole_Read = (int)8L;
+    public static final int CXSymbolRole_Write = (int)16L;
+    public static final int CXSymbolRole_Call = (int)32L;
+    public static final int CXSymbolRole_Dynamic = (int)64L;
+    public static final int CXSymbolRole_AddressOf = (int)128L;
+    public static final int CXSymbolRole_Implicit = (int)256L;
+    public static final MemoryLayout CXIdxEntityRefInfo$LAYOUT = MemoryLayout.ofStruct(
+        C_INT.withName("kind"),
+        MemoryLayout.ofPaddingBits(32),
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ).withName("cursor"),
+        MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ).withName("loc"),
+        C_POINTER.withName("referencedEntity"),
+        C_POINTER.withName("parentEntity"),
+        C_POINTER.withName("container"),
+        C_INT.withName("role"),
+        MemoryLayout.ofPaddingBits(32)
+    );
+    public static final VarHandle CXIdxEntityRefInfo$kind = CXIdxEntityRefInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("kind"));
+    public static final int CXIdxEntityRefInfo$kind$get(MemorySegment seg) {
+        return (int)CXIdxEntityRefInfo$kind.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityRefInfo$kind$set(MemorySegment seg, int x) {
+        CXIdxEntityRefInfo$kind.set(seg.baseAddress(), x);
+    }
+    public static final VarHandle CXIdxEntityRefInfo$role = CXIdxEntityRefInfo$LAYOUT.varHandle(int.class, PathElement.groupElement("role"));
+    public static final int CXIdxEntityRefInfo$role$get(MemorySegment seg) {
+        return (int)CXIdxEntityRefInfo$role.get(seg.baseAddress());
+    }
+    public static final void CXIdxEntityRefInfo$role$set(MemorySegment seg, int x) {
+        CXIdxEntityRefInfo$role.set(seg.baseAddress(), x);
+    }
+    public static final MemoryLayout IndexerCallbacks$LAYOUT = MemoryLayout.ofStruct(
+        C_POINTER.withName("abortQuery"),
+        C_POINTER.withName("diagnostic"),
+        C_POINTER.withName("enteredMainFile"),
+        C_POINTER.withName("ppIncludedFile"),
+        C_POINTER.withName("importedASTFile"),
+        C_POINTER.withName("startedTranslationUnit"),
+        C_POINTER.withName("indexDeclaration"),
+        C_POINTER.withName("indexEntityReference")
+    );
+    public static final MethodHandle clang_index_isEntityObjCContainerKind = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_isEntityObjCContainerKind",
+        "(I)I",
+        FunctionDescriptor.of(C_INT,
+            C_INT
+        )
+    );
+    public static final int clang_index_isEntityObjCContainerKind (int x0) {
+        try {
+            return (int)clang_index_isEntityObjCContainerKind.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getObjCContainerDeclInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getObjCContainerDeclInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getObjCContainerDeclInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getObjCContainerDeclInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getObjCInterfaceDeclInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getObjCInterfaceDeclInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getObjCInterfaceDeclInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getObjCInterfaceDeclInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getObjCCategoryDeclInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getObjCCategoryDeclInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getObjCCategoryDeclInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getObjCCategoryDeclInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getObjCProtocolRefListInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getObjCProtocolRefListInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getObjCProtocolRefListInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getObjCProtocolRefListInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getObjCPropertyDeclInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getObjCPropertyDeclInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getObjCPropertyDeclInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getObjCPropertyDeclInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getIBOutletCollectionAttrInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getIBOutletCollectionAttrInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getIBOutletCollectionAttrInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getIBOutletCollectionAttrInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getCXXClassDeclInfo = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getCXXClassDeclInfo",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getCXXClassDeclInfo (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getCXXClassDeclInfo.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getClientContainer = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getClientContainer",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getClientContainer (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getClientContainer.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_setClientContainer = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_setClientContainer",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_index_setClientContainer (MemoryAddress x0, MemoryAddress x1) {
+        try {
+            clang_index_setClientContainer.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_getClientEntity = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_getClientEntity",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_index_getClientEntity (MemoryAddress x0) {
+        try {
+            return (MemoryAddress)clang_index_getClientEntity.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_index_setClientEntity = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_index_setClientEntity",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_index_setClientEntity (MemoryAddress x0, MemoryAddress x1) {
+        try {
+            clang_index_setClientEntity.invokeExact(x0, x1);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_IndexAction_create = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_IndexAction_create",
+        "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/MemoryAddress;",
+        FunctionDescriptor.of(C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final MemoryAddress clang_IndexAction_create (MemoryAddress CIdx) {
+        try {
+            return (MemoryAddress)clang_IndexAction_create.invokeExact(CIdx);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_IndexAction_dispose = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_IndexAction_dispose",
+        "(Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            C_POINTER
+        )
+    );
+    public static final void clang_IndexAction_dispose (MemoryAddress x0) {
+        try {
+            clang_IndexAction_dispose.invokeExact(x0);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final int CXIndexOpt_None = (int)0L;
+    public static final int CXIndexOpt_SuppressRedundantRefs = (int)1L;
+    public static final int CXIndexOpt_IndexFunctionLocalSymbols = (int)2L;
+    public static final int CXIndexOpt_IndexImplicitTemplateInstantiations = (int)4L;
+    public static final int CXIndexOpt_SuppressWarnings = (int)8L;
+    public static final int CXIndexOpt_SkipParsedBodiesInSession = (int)16L;
+    public static final MethodHandle clang_indexSourceFile = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_indexSourceFile",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_indexSourceFile (MemoryAddress x0, MemoryAddress client_data, MemoryAddress index_callbacks, int index_callbacks_size, int index_options, MemoryAddress source_filename, MemoryAddress command_line_args, int num_command_line_args, MemoryAddress unsaved_files, int num_unsaved_files, MemoryAddress out_TU, int TU_options) {
+        try {
+            return (int)clang_indexSourceFile.invokeExact(x0, client_data, index_callbacks, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, out_TU, TU_options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_indexSourceFileFullArgv = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_indexSourceFileFullArgv",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;ILjdk/incubator/foreign/MemoryAddress;I)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT,
+            C_POINTER,
+            C_INT
+        )
+    );
+    public static final int clang_indexSourceFileFullArgv (MemoryAddress x0, MemoryAddress client_data, MemoryAddress index_callbacks, int index_callbacks_size, int index_options, MemoryAddress source_filename, MemoryAddress command_line_args, int num_command_line_args, MemoryAddress unsaved_files, int num_unsaved_files, MemoryAddress out_TU, int TU_options) {
+        try {
+            return (int)clang_indexSourceFileFullArgv.invokeExact(x0, client_data, index_callbacks, index_callbacks_size, index_options, source_filename, command_line_args, num_command_line_args, unsaved_files, num_unsaved_files, out_TU, TU_options);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_indexTranslationUnit = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_indexTranslationUnit",
+        "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;IILjdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_INT,
+            C_INT,
+            C_POINTER
+        )
+    );
+    public static final int clang_indexTranslationUnit (MemoryAddress x0, MemoryAddress client_data, MemoryAddress index_callbacks, int index_callbacks_size, int index_options, MemoryAddress x5) {
+        try {
+            return (int)clang_indexTranslationUnit.invokeExact(x0, client_data, index_callbacks, index_callbacks_size, index_options, x5);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_indexLoc_getFileLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_indexLoc_getFileLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V",
+        FunctionDescriptor.ofVoid(
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            ),
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final void clang_indexLoc_getFileLocation (MemorySegment loc, MemoryAddress indexFile, MemoryAddress file, MemoryAddress line, MemoryAddress column, MemoryAddress offset) {
+        try {
+            clang_indexLoc_getFileLocation.invokeExact(loc, indexFile, file, line, column, offset);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_indexLoc_getCXSourceLocation = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_indexLoc_getCXSourceLocation",
+        "(Ljdk/incubator/foreign/MemorySegment;)Ljdk/incubator/foreign/MemorySegment;",
+        FunctionDescriptor.of(MemoryLayout.ofStruct(
+            MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+            C_INT.withName("int_data"),
+            MemoryLayout.ofPaddingBits(32)
+        ),
+            MemoryLayout.ofStruct(
+                MemoryLayout.ofSequence(2, C_POINTER).withName("ptr_data"),
+                C_INT.withName("int_data"),
+                MemoryLayout.ofPaddingBits(32)
+            )
+        )
+    );
+    public static final MemorySegment clang_indexLoc_getCXSourceLocation (MemorySegment loc) {
+        try {
+            return (MemorySegment)clang_indexLoc_getCXSourceLocation.invokeExact(loc);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    public static final MethodHandle clang_Type_visitFields = RuntimeHelper.downcallHandle(
+        LIBRARIES, "clang_Type_visitFields",
+        "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I",
+        FunctionDescriptor.of(C_INT,
+            MemoryLayout.ofStruct(
+                C_INT.withName("kind"),
+                MemoryLayout.ofPaddingBits(32),
+                MemoryLayout.ofSequence(2, C_POINTER).withName("data")
+            ),
+            C_POINTER,
+            C_POINTER
+        )
+    );
+    public static final int clang_Type_visitFields (MemorySegment T, MemoryAddress visitor, MemoryAddress client_data) {
+        try {
+            return (int)clang_Type_visitFields.invokeExact(T, visitor, client_data);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+    private static final FunctionDescriptor clang_Type_visitFields$visitor$DESC = FunctionDescriptor.of(C_INT,
+        MemoryLayout.ofStruct(
+            C_INT.withName("kind"),
+            C_INT.withName("xdata"),
+            MemoryLayout.ofSequence(3, C_POINTER).withName("data")
+        ),
+        C_POINTER
+    );
+    public interface clang_Type_visitFields$visitor {
+        int apply(MemorySegment x0, MemoryAddress x1);
+    }
+    public static final MemoryAddress clang_Type_visitFields$visitor$make(clang_Type_visitFields$visitor fi) {
+        return RuntimeHelper.upcallStub(clang_Type_visitFields$visitor.class, fi, clang_Type_visitFields$visitor$DESC, "(Ljdk/incubator/foreign/MemorySegment;Ljdk/incubator/foreign/MemoryAddress;)I");
+    }
+}
+
+
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/clang/libclang/RuntimeHelper.java
@@ -0,0 +1,112 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.clang.libclang;
+// Generated by jextract
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.LibraryLookup;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.SystemABI;
+import jdk.internal.foreign.InternalForeign;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Arrays;
+import java.util.Optional;
+
+public class RuntimeHelper {
+
+    private final static SystemABI ABI = InternalForeign.getInstancePrivileged().getSystemABI();
+
+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();
+
+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();
+
+    static final LibraryLookup[] libraries(String[] libNames, String[] libPaths) {
+        if (libNames.length == 0) {
+            return new LibraryLookup[]{LibraryLookup.ofDefault()};
+        } else {
+            Path[] paths = Arrays.stream(libPaths).map(Paths::get).toArray(Path[]::new);
+            return Arrays.stream(libNames).map(libName -> {
+                Optional<Path> absPath = findLibraryPath(paths, libName);
+                return absPath.isPresent() ?
+                        LibraryLookup.ofPath(MH_LOOKUP, absPath.get().toString()) :
+                        LibraryLookup.ofLibrary(MH_LOOKUP, libName);
+            }).toArray(LibraryLookup[]::new);
+        }
+    }
+
+    private static final Optional<Path> findLibraryPath(Path[] paths, String libName) {
+        return Arrays.stream(paths).
+                map(p -> p.resolve(System.mapLibraryName(libName))).
+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
+    }
+
+    private static final Optional<MemoryAddress> lookup(LibraryLookup[] LIBRARIES, String sym) {
+        for (LibraryLookup l : LIBRARIES) {
+            try {
+                return Optional.of(l.lookup(sym));
+            } catch (Throwable t) {
+            }
+        }
+        try {
+            return Optional.of(LibraryLookup.ofDefault().lookup(sym));
+        } catch (Throwable t) {
+            return Optional.empty();
+        }
+    }
+
+    public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name) {
+        return lookup(LIBRARIES, name).orElse(null);
+    }
+
+    public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc) {
+        return lookup(LIBRARIES, name).map(
+                addr -> ABI.downcallHandle(addr,
+                                           MethodType.fromMethodDescriptorString(desc, LOADER),
+                                           fdesc)).orElse(null);
+    }
+
+    public static final MemoryAddress upcallStub(MethodHandle handle, FunctionDescriptor fdesc) {
+        return ABI.upcallStub(handle, fdesc);
+    }
+
+    public static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {
+        try {
+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, "apply",
+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));
+            handle = handle.bindTo(z);
+            return upcallStub(handle, fdesc);
+        } catch (Throwable ex) {
+            throw new AssertionError(ex);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/DeclarationImpl.java
@@ -0,0 +1,348 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import java.lang.constant.Constable;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Set;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+import jdk.incubator.jextract.Type;
+
+public abstract class DeclarationImpl implements Declaration {
+
+    private final String name;
+    private final Position pos;
+    private final Optional<Map<String, List<Constable>>> attributes;
+
+    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {
+        this.name = name;
+        this.pos = pos;
+        this.attributes = Optional.ofNullable(attrs);
+    }
+
+    public String toString() {
+        return new PrettyPrinter().print(this);
+    }
+
+    public String name() {
+        return name;
+    }
+
+    @Override
+    public Position pos() {
+        return pos;
+    }
+
+    @Override
+    public Optional<List<Constable>> getAttribute(String name) {
+        return attributes.map(attrs -> attrs.get(name));
+    }
+
+    @Override
+    public Set<String> attributeNames() { return Collections.unmodifiableSet(
+            attributes.map(Map::keySet).orElse(Collections.emptySet()));
+    }
+
+    @Override
+    public Declaration withAttribute(String name, Constable... values) {
+        if (values == null || values.length == 0) {
+            return withAttributes(null);
+        }
+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);
+        attrs.put(name, List.of(values));
+        return withAttributes(attrs);
+    }
+
+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Declaration)) return false;
+        Declaration decl = (Declaration) o;
+        return name().equals(decl.name());
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name);
+    }
+
+    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {
+
+        final Variable.Kind kind;
+        final Type type;
+        final Optional<MemoryLayout> layout;
+
+        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {
+            super(name, pos, attrs);
+            this.kind = Objects.requireNonNull(kind);
+            this.type = Objects.requireNonNull(type);
+            this.layout = Objects.requireNonNull(layout);
+        }
+
+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {
+            this(type, LayoutUtils.getLayout(type), kind, name, pos, null);
+        }
+
+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {
+            this(type, Optional.of(layout), kind, name, pos, null);
+        }
+
+        @Override
+        public Kind kind() {
+            return kind;
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitVariable(this, data);
+        }
+
+        @Override
+        public Type type() {
+            return type;
+        }
+
+        @Override
+        public Optional<MemoryLayout> layout() {
+            return layout;
+        }
+
+        @Override
+        public Variable withAttributes(Map<String, List<Constable>> attrs) {
+            return new VariableImpl(type, layout, kind, name(), pos(), attrs);
+        }
+
+        @Override
+        public Variable stripAttributes() {
+            return new VariableImpl(type, layout, kind, name(), pos(), null);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Declaration.Variable)) return false;
+            if (!super.equals(o)) return false;
+            Declaration.Variable variable = (Declaration.Variable) o;
+            return kind == variable.kind() &&
+                    type.equals(variable.type());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), kind, type);
+        }
+    }
+
+    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {
+
+        final List<Variable> params;
+        final Type.Function type;
+
+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {
+            this(type, params, name, pos, null);
+        }
+
+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {
+            super(name, pos, attrs);
+            this.params = Objects.requireNonNull(params);
+            this.type = Objects.requireNonNull(type);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitFunction(this, data);
+        }
+
+        @Override
+        public List<Variable> parameters() {
+            return params;
+        }
+
+        @Override
+        public Type.Function type() {
+            return type;
+        }
+
+        @Override
+        public Function withAttributes(Map<String, List<Constable>> attrs) {
+            return new FunctionImpl(type, params, name(), pos(), attrs);
+        }
+
+        @Override
+        public Function stripAttributes() {
+            return new FunctionImpl(type, params, name(), pos(), null);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Declaration.Function)) return false;
+            if (!super.equals(o)) return false;
+
+            Declaration.Function function = (Declaration.Function) o;
+            return type.equals(function.type());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), type);
+        }
+    }
+
+    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {
+
+        private final Scoped.Kind kind;
+        private final List<Declaration> declarations;
+        private final Optional<MemoryLayout> optLayout;
+
+        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {
+            this(kind, Optional.of(layout), declarations, name, pos, null);
+        }
+
+        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {
+            this(kind, Optional.empty(), declarations, name, pos, null);
+        }
+
+        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,
+                String name, Position pos, Map<String, List<Constable>> attrs) {
+            super(name, pos, attrs);
+            this.kind = Objects.requireNonNull(kind);
+            this.declarations = Objects.requireNonNull(declarations);
+            this.optLayout = Objects.requireNonNull(optLayout);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitScoped(this, data);
+        }
+
+        @Override
+        public List<Declaration> members() {
+            return declarations;
+        }
+
+        @Override
+        public Optional<MemoryLayout> layout() {
+            return optLayout;
+        }
+
+        @Override
+        public Kind kind() {
+            return kind;
+        }
+
+        @Override
+        public Scoped withAttributes(Map<String, List<Constable>> attrs) {
+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);
+        }
+
+        @Override
+        public Scoped stripAttributes() {
+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Declaration.Scoped)) return false;
+            if (!super.equals(o)) return false;
+            Declaration.Scoped scoped = (Declaration.Scoped) o;
+            return kind == scoped.kind() &&
+                    declarations.equals(scoped.members());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), kind, declarations);
+        }
+    }
+
+    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {
+
+        final Object value;
+        final Type type;
+
+        public ConstantImpl(Type type, Object value, String name, Position pos) {
+            this(type, value, name, pos, null);
+        }
+
+        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {
+            super(name, pos, attrs);
+            this.value = Objects.requireNonNull(value);
+            this.type = Objects.requireNonNull(type);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitConstant(this, data);
+        }
+
+        @Override
+        public Object value() {
+            return value;
+        }
+
+        @Override
+        public Type type() {
+            return type;
+        }
+
+        @Override
+        public Constant withAttributes(Map<String, List<Constable>> attrs) {
+            return new ConstantImpl(type, value, name(), pos(), attrs);
+        }
+
+        @Override
+        public Constant stripAttributes() {
+            return new ConstantImpl(type, value, name(), pos(), null);
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Declaration.Constant)) return false;
+            if (!super.equals(o)) return false;
+            Declaration.Constant constant = (Declaration.Constant) o;
+            return value.equals(constant.value()) &&
+                    type.equals(constant.type());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(super.hashCode(), value, type);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/InMemoryJavaCompiler.java
@@ -0,0 +1,93 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.jextract.impl;
+
+import javax.tools.FileObject;
+import javax.tools.ForwardingJavaFileManager;
+import javax.tools.JavaCompiler;
+import javax.tools.JavaFileManager;
+import javax.tools.JavaFileObject;
+import javax.tools.SimpleJavaFileObject;
+import javax.tools.ToolProvider;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+final class InMemoryJavaCompiler {
+    private InMemoryJavaCompiler() {}
+
+    static List<JavaFileObject> compile(List<JavaFileObject> files,
+                                        String... options) {
+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
+        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));
+
+        Writer writer = new StringWriter();
+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();
+        if (!exitCode) {
+            throw new RuntimeException("In memory compilation failed: " + writer.toString());
+        }
+        return fileManager.getCompiledFiles();
+    }
+
+    // Wraper for class byte array
+    private static class ClassFile extends SimpleJavaFileObject {
+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+
+        protected ClassFile(String name) {
+            super(URI.create("memo:///" + name.replace('.', '/') + Kind.CLASS.extension), Kind.CLASS);
+        }
+
+        @Override
+        public ByteArrayOutputStream openOutputStream() { return this.baos; }
+
+        byte[] toByteArray() { return baos.toByteArray(); }
+    }
+
+    // File manager which spawns ClassFile instances on demand
+    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {
+        private final List<JavaFileObject> compiled = new ArrayList<>();
+
+        protected FileManager(JavaFileManager fileManager) {
+            super(fileManager);
+        }
+
+        @Override
+        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {
+            JavaFileObject out = super.getJavaFileForOutput(location, name, kind, source);
+            compiled.add(out);
+            return out;
+        }
+
+        public List<JavaFileObject> getCompiledFiles() {
+            return compiled;
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/JextractTaskImpl.java
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.JextractTask;
+
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class JextractTaskImpl implements JextractTask {
+
+    private final boolean compileSources;
+    private final List<Path> headers;
+    static final boolean VERBOSE = Boolean.getBoolean("jextract.verbose");
+
+    public JextractTaskImpl(boolean compileSources, Path... headers) {
+        this.compileSources = compileSources;
+        this.headers = Stream.of(headers).collect(Collectors.toList());
+    }
+
+    @Override
+    public Declaration.Scoped parse(String... options) {
+        return parse(null, options);
+    }
+
+    @Override
+    public Declaration.Scoped parse(JextractTask.ConstantParser constantParser, String... options) {
+        Path source = headers.size() > 1? generateTmpSource() : headers.iterator().next();
+        return new Parser(constantParser).parse(source, Stream.of(options).collect(Collectors.toList()));
+    }
+
+    @Override
+    public void write(Path dest, JavaFileObject... files) {
+        try {
+            new Writer(dest, Stream.of(files).collect(Collectors.toList())).writeAll(compileSources);
+        } catch (IOException ex) {
+            throw new UncheckedIOException(ex);
+        }
+    }
+
+    private Path generateTmpSource() {
+        assert headers.size() > 1;
+        try {
+            Path tmpFile = Files.createTempFile("jextract", ".h");
+            tmpFile.toFile().deleteOnExit();
+            Files.write(tmpFile, headers.stream().
+                map(src -> "#include \"" + src + "\"").
+                collect(Collectors.toList()));
+            return tmpFile;
+        } catch (IOException ioExp) {
+            throw new UncheckedIOException(ioExp);
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/LayoutUtils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/LayoutUtils.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/LayoutUtils.java
@@ -0,0 +1,306 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.FunctionDescriptor;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.foreign.MemoryLayouts.SysV;
+import jdk.incubator.foreign.SequenceLayout;
+import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.ValueLayout;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.Type;
+import jdk.internal.clang.TypeKind;
+import jdk.internal.foreign.InternalForeign;
+import jdk.internal.foreign.abi.aarch64.AArch64ABI;
+import jdk.internal.foreign.abi.x64.sysv.SysVx64ABI;
+import jdk.internal.foreign.abi.x64.windows.Windowsx64ABI;
+
+import java.util.Optional;
+
+/**
+ * General Layout utility functions
+ */
+public final class LayoutUtils {
+    private static SystemABI abi = InternalForeign.getInstancePrivileged().getSystemABI();
+    private LayoutUtils() {}
+
+    public static String getName(Type type) {
+        Cursor c = type.getDeclarationCursor();
+        if (c.isInvalid()) {
+            return type.spelling();
+        }
+        return getName(c);
+    }
+
+    public static String getName(Cursor cursor) {
+        return cursor.spelling();
+    }
+
+    public static MemoryLayout getLayout(Type t) {
+        switch(t.kind()) {
+            case UChar, Char_U:
+                return C_UCHAR;
+            case SChar, Char_S:
+                return C_SCHAR;
+            case Short:
+                return C_SHORT;
+            case UShort:
+                return C_USHORT;
+            case Int:
+                return C_INT;
+            case UInt:
+                return C_UINT;
+            case ULong:
+                return C_ULONG;
+            case Long:
+                return C_LONG;
+            case ULongLong:
+                return C_ULONGLONG;
+            case LongLong:
+                return C_LONGLONG;
+            case UInt128:
+            case Int128:
+                throw new UnsupportedOperationException();
+            case Enum:
+                return valueLayoutForSize(t.size() * 8);
+            case Bool:
+                return C_BOOL;
+            case Float:
+                return C_FLOAT;
+            case Double:
+                return C_DOUBLE;
+            case LongDouble:
+                return C_LONGDOUBLE;
+            case Complex:
+                if (!abi.name().equals(SystemABI.ABI_SYSV)) {
+                    throw new UnsupportedOperationException("unsupported: " + t.kind());
+                }
+                return SysV.C_COMPLEX_LONGDOUBLE;
+            case Record:
+                return getRecordLayout(t);
+            case Vector:
+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));
+            case ConstantArray:
+                return MemoryLayout.ofSequence(t.getNumberOfElements(), getLayout(t.getElementType()));
+            case IncompleteArray:
+                return MemoryLayout.ofSequence(getLayout(t.getElementType()));
+            case Unexposed:
+                Type canonical = t.canonicalType();
+                if (canonical.equalType(t)) {
+                    throw new IllegalStateException("Unknown type with same canonical type: " + t.spelling());
+                }
+                return getLayout(canonical);
+            case Typedef:
+            case Elaborated:
+                return getLayout(t.canonicalType());
+            case Pointer:
+            case BlockPointer:
+                return C_POINTER;
+            default:
+                throw new UnsupportedOperationException("unsupported: " + t.kind());
+        }
+    }
+
+    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {
+        try {
+            return Optional.of(getLayoutInternal(t));
+        } catch (Throwable ex) {
+            return Optional.empty();
+        }
+    }
+
+    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {
+        return t.accept(layoutMaker, null);
+    }
+
+    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {
+        @Override
+        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {
+            return t.layout().orElseThrow(UnsupportedOperationException::new);
+        }
+
+        @Override
+        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {
+            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {
+                return C_POINTER;
+            } else {
+                return t.type().accept(this, null);
+            }
+        }
+
+        @Override
+        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {
+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);
+        }
+
+        @Override
+        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {
+            MemoryLayout elem = t.elementType().accept(this, null);
+            if (t.elementCount().isPresent()) {
+                return MemoryLayout.ofSequence(t.elementCount().getAsLong(), elem);
+            } else {
+                return MemoryLayout.ofSequence(elem);
+            }
+        }
+
+        @Override
+        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {
+            throw new UnsupportedOperationException();
+        }
+    };
+
+    static MemoryLayout getRecordLayout(Type type) {
+        return RecordLayoutComputer.compute(0, type, type);
+    }
+
+    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {
+        try {
+            MemoryLayout[] args = t.argumentTypes().stream()
+                    .map(LayoutUtils::getLayoutInternal)
+                    .toArray(MemoryLayout[]::new);
+            if (t.returnType() instanceof jdk.incubator.jextract.Type.Primitive &&
+                    ((jdk.incubator.jextract.Type.Primitive) t.returnType()).kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void) {
+                return Optional.of(FunctionDescriptor.ofVoid(args));
+            } else {
+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(t.returnType()), args));
+            }
+        } catch (Throwable ex) {
+            return Optional.empty();
+        }
+    }
+
+    public static ValueLayout valueLayoutForSize(long size) {
+        switch ((int)size) {
+            case 8: return INT8;
+            case 16: return INT16;
+            case 32: return INT32;
+            case 64: return INT64;
+            default:
+                throw new IllegalStateException("Cannot infer container layout");
+        }
+    }
+
+    // platform-dependent layouts
+
+    public static final ValueLayout C_BOOL;
+    public static final ValueLayout C_CHAR;
+    public static final ValueLayout C_UCHAR;
+    public static final ValueLayout C_SCHAR;
+    public static final ValueLayout C_SHORT;
+    public static final ValueLayout C_USHORT;
+    public static final ValueLayout C_INT;
+    public static final ValueLayout C_UINT;
+    public static final ValueLayout C_LONG;
+    public static final ValueLayout C_ULONG;
+    public static final ValueLayout C_LONGLONG;
+    public static final ValueLayout C_ULONGLONG;
+    public static final ValueLayout C_FLOAT;
+    public static final ValueLayout C_DOUBLE;
+    public static final ValueLayout C_LONGDOUBLE;
+    public static final ValueLayout C_POINTER;
+
+    public static final ValueLayout INT8;
+    public static final ValueLayout INT16;
+    public static final ValueLayout INT32;
+    public static final ValueLayout INT64;
+
+    static {
+        if (abi instanceof SysVx64ABI) {
+            C_BOOL = MemoryLayouts.SysV.C_BOOL;
+            C_CHAR = MemoryLayouts.SysV.C_CHAR;
+            C_UCHAR = MemoryLayouts.SysV.C_UCHAR;
+            C_SCHAR = MemoryLayouts.SysV.C_SCHAR;
+            C_SHORT = MemoryLayouts.SysV.C_SHORT;
+            C_USHORT = MemoryLayouts.SysV.C_USHORT;
+            C_INT = MemoryLayouts.SysV.C_INT;
+            C_UINT = MemoryLayouts.SysV.C_UINT;
+            C_LONG = MemoryLayouts.SysV.C_LONG;
+            C_ULONG = MemoryLayouts.SysV.C_ULONG;
+            C_LONGLONG = MemoryLayouts.SysV.C_LONGLONG;
+            C_ULONGLONG = MemoryLayouts.SysV.C_ULONGLONG;
+            C_FLOAT = MemoryLayouts.SysV.C_FLOAT;
+            C_DOUBLE = MemoryLayouts.SysV.C_DOUBLE;
+            C_LONGDOUBLE = MemoryLayouts.SysV.C_LONGDOUBLE;
+            C_POINTER = MemoryLayouts.SysV.C_POINTER;
+            INT8 = C_BOOL;
+            INT16 = C_SHORT;
+            INT32 = C_INT;
+            INT64 = C_LONG;
+        } else if (abi instanceof Windowsx64ABI) {
+            C_BOOL = MemoryLayouts.WinABI.C_BOOL;
+            C_CHAR = MemoryLayouts.WinABI.C_CHAR;
+            C_UCHAR = MemoryLayouts.WinABI.C_UCHAR;
+            C_SCHAR = MemoryLayouts.WinABI.C_SCHAR;
+            C_SHORT = MemoryLayouts.WinABI.C_SHORT;
+            C_USHORT = MemoryLayouts.WinABI.C_USHORT;
+            C_INT = MemoryLayouts.WinABI.C_INT;
+            C_UINT = MemoryLayouts.WinABI.C_UINT;
+            C_LONG = MemoryLayouts.WinABI.C_LONG;
+            C_ULONG = MemoryLayouts.WinABI.C_ULONG;
+            C_LONGLONG = MemoryLayouts.WinABI.C_LONGLONG;
+            C_ULONGLONG = MemoryLayouts.WinABI.C_ULONGLONG;
+            C_FLOAT = MemoryLayouts.WinABI.C_FLOAT;
+            C_DOUBLE = MemoryLayouts.WinABI.C_DOUBLE;
+            C_LONGDOUBLE = MemoryLayouts.WinABI.C_LONGDOUBLE;
+            C_POINTER = MemoryLayouts.WinABI.C_POINTER;
+            INT8 = C_BOOL;
+            INT16 = C_SHORT;
+            INT32 = C_INT;
+            INT64 = C_LONGLONG;
+        } else if (abi instanceof AArch64ABI) {
+            C_BOOL = MemoryLayouts.AArch64ABI.C_BOOL;
+            C_CHAR = MemoryLayouts.AArch64ABI.C_CHAR;
+            C_UCHAR = MemoryLayouts.AArch64ABI.C_UCHAR;
+            C_SCHAR = MemoryLayouts.AArch64ABI.C_SCHAR;
+            C_SHORT = MemoryLayouts.AArch64ABI.C_SHORT;
+            C_USHORT = MemoryLayouts.AArch64ABI.C_USHORT;
+            C_INT = MemoryLayouts.AArch64ABI.C_INT;
+            C_UINT = MemoryLayouts.AArch64ABI.C_UINT;
+            C_LONG = MemoryLayouts.AArch64ABI.C_LONG;
+            C_ULONG = MemoryLayouts.AArch64ABI.C_ULONG;
+            C_LONGLONG = MemoryLayouts.AArch64ABI.C_LONGLONG;
+            C_ULONGLONG = MemoryLayouts.AArch64ABI.C_ULONGLONG;
+            C_FLOAT = MemoryLayouts.AArch64ABI.C_FLOAT;
+            C_DOUBLE = MemoryLayouts.AArch64ABI.C_DOUBLE;
+            C_LONGDOUBLE = MemoryLayouts.AArch64ABI.C_LONGDOUBLE;
+            C_POINTER = MemoryLayouts.AArch64ABI.C_POINTER;
+            INT8 = C_BOOL;
+            INT16 = C_SHORT;
+            INT32 = C_INT;
+            INT64 = C_LONG;
+        } else {
+            throw new ExceptionInInitializerError();
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/MacroParserImpl.java
@@ -0,0 +1,263 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Type;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.Diagnostic;
+import jdk.internal.clang.EvalResult;
+import jdk.internal.clang.Index;
+import jdk.internal.clang.LibClang;
+import jdk.internal.clang.TranslationUnit;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collection;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+class MacroParserImpl {
+
+    private Reparser reparser;
+    TypeMaker typeMaker = new TypeMaker(null);
+
+    public MacroParserImpl(TranslationUnit tu, Collection<String> args) {
+        try {
+            this.reparser = new ClangReparser(tu, args);
+        } catch (IOException | Index.ParsingFailedException ex) {
+            this.reparser = Reparser.DUMMY;
+        }
+    }
+
+    /**
+     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made
+     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.
+     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall
+     * back to use clang evaluation support.
+     */
+    Optional<Macro> eval(String macroName, String... tokens) {
+        if (tokens.length == 2) {
+            //check for fast path
+            Integer num = toNumber(tokens[1]);
+            if (num != null) {
+                return Optional.of(Macro.longMacro(Type.primitive(Type.Primitive.Kind.Int, LayoutUtils.C_INT), num));
+            }
+        }
+        //slow path
+        try {
+            //step one, parse constant as is
+            MacroResult result = reparse(constantDecl(macroName, false));
+            if (!result.success()) {
+                //step two, attempt parsing pointer constant, by forcing it to uintptr_t
+                result = reparse(constantDecl(macroName, true)).asType(result.type);
+            }
+            return result.success() ?
+                    Optional.of((Macro)result) :
+                    Optional.empty();
+        } catch (BadMacroException ex) {
+            if (JextractTaskImpl.VERBOSE) {
+                System.err.println("Failed to handle macro " + macroName);
+                ex.printStackTrace(System.err);
+            }
+            return Optional.empty();
+        }
+    }
+
+    MacroResult reparse(String snippet) {
+        MacroResult rv = reparser.reparse(snippet)
+                .filter(c -> c.kind() == CursorKind.VarDecl &&
+                        c.spelling().contains("jextract$"))
+                .map(c -> compute(c))
+                .findAny().get();
+        typeMaker.resolveTypeReferences();
+        return rv;
+    }
+
+    private Integer toNumber(String str) {
+        try {
+            // Integer.decode supports '#' hex literals which is not valid in C.
+            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;
+        } catch (NumberFormatException nfe) {
+            return null;
+        }
+    }
+
+    String constantDecl(String macroName, boolean forcePtr) {
+        //we use __auto_type, so that clang will also do type inference for us
+        return (forcePtr) ?
+                "#include <stdint.h> \n __auto_type jextract$macro$ptr$" + macroName + " = (uintptr_t)" + macroName + ";" :
+                "__auto_type jextract$macro$" + macroName + " = " + macroName + ";";
+    }
+
+    MacroResult compute(Cursor decl) {
+        try (EvalResult result = decl.eval()) {
+            switch (result.getKind()) {
+                case Integral: {
+                    long value = result.getAsInt();
+                    return Macro.longMacro(typeMaker.makeType(decl.type()), value);
+                }
+                case FloatingPoint: {
+                    double value = result.getAsFloat();
+                    return Macro.doubleMacro(typeMaker.makeType(decl.type()), value);
+                }
+                case StrLiteral: {
+                    String value = result.getAsString();
+                    return Macro.stringMacro(typeMaker.makeType(decl.type()), value);
+                }
+                default:
+                    return new Failure(typeMaker.makeType(decl.type()));
+            }
+        }
+    }
+
+    static abstract class MacroResult {
+        private final Type type;
+
+        MacroResult(Type type) {
+            this.type = type;
+        }
+
+        public Type type() {
+            return type;
+        }
+
+        abstract boolean success();
+
+        abstract MacroResult asType(Type type);
+    }
+
+    static class Failure extends MacroResult {
+
+        public Failure(Type type) {
+            super(type);
+        }
+
+        @Override
+        boolean success() {
+            return false;
+        }
+
+        @Override
+        MacroResult asType(Type type) {
+            return new Failure(type);
+        }
+    }
+
+    public static class Macro extends MacroResult {
+        Object value;
+
+        private Macro(Type type, Object value) {
+            super(type);
+            this.value = value;
+        }
+
+        @Override
+        boolean success() {
+            return true;
+        }
+
+        public Object value() {
+            return value;
+        }
+
+        @Override
+        MacroResult asType(Type type) {
+            return new Macro(type, value);
+        }
+
+        static Macro longMacro(Type type, long value) {
+            return new Macro(type, value);
+        }
+
+        static Macro doubleMacro(Type type, double value) {
+            return new Macro(type, value);
+        }
+
+        static Macro stringMacro(Type type, String value) {
+            return new Macro(type, value);
+        }
+    }
+
+    interface Reparser {
+        Stream<Cursor> reparse(String snippet);
+
+        Reparser DUMMY = s -> Stream.empty();
+    }
+
+    /**
+     * This class allows client to reparse a snippet of code against a given set of include files.
+     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled
+     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.
+     */
+    class ClangReparser implements Reparser {
+        final Path macro;
+        final Index macroIndex = LibClang.createIndex(true);
+        final TranslationUnit macroUnit;
+
+        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {
+            Path precompiled = Files.createTempFile("jextract$", ".pch");
+            precompiled.toFile().deleteOnExit();
+            tu.save(precompiled);
+            this.macro = Files.createTempFile("jextract$", ".h");
+            this.macro.toFile().deleteOnExit();
+            String[] patchedArgs = Stream.concat(
+                Stream.of(
+                    // Avoid system search path, use bundled instead
+                    "-nostdinc",
+                    // precompiled header
+                    "-include-pch", precompiled.toAbsolutePath().toString()),
+                args.stream()).toArray(String[]::new);
+            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),
+                    d -> processDiagnostics(null, d),
+                    false, //add serialization support (needed for macros)
+                    patchedArgs);
+        }
+
+        @Override
+        public Stream<Cursor> reparse(String snippet) {
+            macroUnit.reparse(d -> processDiagnostics(snippet, d),
+                    Index.UnsavedFile.of(macro, snippet));
+            return macroUnit.getCursor().children();
+        }
+
+        void processDiagnostics(String snippet, Diagnostic diag) {
+            if (diag.severity() > Diagnostic.CXDiagnostic_Warning) {
+                throw new BadMacroException(diag);
+            }
+        }
+    }
+
+    private static class BadMacroException extends RuntimeException {
+        static final long serialVersionUID = 1L;
+
+        public BadMacroException(Diagnostic diag) {
+            super(diag.toString());
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
@@ -0,0 +1,138 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.JextractTask;
+import jdk.incubator.jextract.Position;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.Diagnostic;
+import jdk.internal.clang.Index;
+import jdk.internal.clang.LibClang;
+import jdk.internal.clang.SourceLocation;
+import jdk.internal.clang.SourceRange;
+import jdk.internal.clang.TranslationUnit;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+
+class Parser {
+    private final TreeMaker treeMaker;
+    private final JextractTask.ConstantParser constantParser;
+
+    public Parser(JextractTask.ConstantParser constantParser) {
+        this.treeMaker = new TreeMaker();
+        this.constantParser = constantParser;
+    }
+
+    public Declaration.Scoped parse(Path path, Collection<String> args) {
+        final Index index = LibClang.createIndex(false);
+
+        TranslationUnit tu = index.parse(path.toString(),
+            d -> {
+                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {
+                    throw new RuntimeException(d.toString());
+                }
+            },
+            true, args.toArray(new String[0]));
+
+        JextractTask.ConstantParser constantParser = this.constantParser != null ?
+                this.constantParser : new DefaultConstantParser(new MacroParserImpl(tu, args));
+
+        List<Declaration> decls = new ArrayList<>();
+        Cursor tuCursor = tu.getCursor();
+        tuCursor.children().
+            forEach(c -> {
+                SourceLocation loc = c.getSourceLocation();
+                if (loc == null) {
+                    return;
+                }
+
+                SourceLocation.Location src = loc.getFileLocation();
+                if (src == null) {
+                    return;
+                }
+
+
+                if (c.isDeclaration()) {
+                    if (c.kind() == CursorKind.UnexposedDecl ||
+                        c.kind() == CursorKind.Namespace) {
+                        c.children().map(treeMaker::createTree)
+                                .filter(t -> t != null)
+                                .forEach(decls::add);
+                    } else {
+                        Declaration decl = treeMaker.createTree(c);
+                        if (decl != null) {
+                            decls.add(treeMaker.createTree(c));
+                        }
+                    }
+                } else if (isMacro(c) && src.path() != null) {
+                    SourceRange range = c.getExtent();
+                    String[] tokens = c.getTranslationUnit().tokens(range);
+                    Optional<Declaration.Constant> constant = constantParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);
+                    if (constant.isPresent()) {
+                        decls.add(constant.get());
+                    }
+                }
+            });
+
+        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);
+        treeMaker.freeze();
+        index.close();
+        return rv;
+    }
+
+    private boolean isMacro(Cursor c) {
+        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;
+    }
+
+    class DefaultConstantParser implements JextractTask.ConstantParser {
+
+        final MacroParserImpl macroParser;
+
+        public DefaultConstantParser(MacroParserImpl macroParser) {
+            this.macroParser = macroParser;
+        }
+
+        @Override
+        public Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {
+            if (!(pos instanceof TreeMaker.CursorPosition)) {
+                return Optional.empty();
+            } else {
+                Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();
+                if (cursor.isMacroFunctionLike()) {
+                    return Optional.empty();
+                } else {
+                    return Optional.ofNullable(treeMaker.createMacro(cursor, macroParser.eval(name, tokens)));
+                }
+            }
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
@@ -0,0 +1,175 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import java.lang.constant.Constable;
+import java.util.Set;
+import java.util.stream.Collectors;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+import jdk.incubator.jextract.Type;
+
+class PrettyPrinter implements Declaration.Visitor<Void, Void> {
+
+    int align = 0;
+
+    void incr() {
+        align += 4;
+    }
+
+    void decr() {
+        align -= 4;
+    }
+
+    void indent() {
+        builder.append("                                                                                           ".substring(0, align));
+    }
+    
+    StringBuilder builder = new StringBuilder();
+
+    private void getAttributes(Declaration decl) {
+        Set<String> attrs = decl.attributeNames();
+        if (attrs.isEmpty()) {
+            return;
+        }
+        incr();
+        indent();
+        for (String k: attrs) {
+            builder.append("Attr: ");
+            builder.append(k);
+            builder.append(" -> [");
+            builder.append(decl.getAttribute(k).get().stream()
+                .map(Constable::toString)
+                .collect(Collectors.joining(", ")));
+            builder.append("]\n");
+        }
+        decr();
+    }
+
+    public String print(Declaration decl) {
+        decl.accept(this, null);
+        return builder.toString();
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {
+        indent();
+        builder.append("Scoped: " + d.kind() + " " + d.name() + d.layout().map(l -> " layout = " + l).orElse(""));
+        builder.append("\n");
+        getAttributes(d);
+        incr();
+        d.members().forEach(m -> m.accept(this, null));
+        decr();
+        return null;
+    }
+
+    @Override
+    public Void visitFunction(Declaration.Function d, Void aVoid) {
+        indent();
+        builder.append("Function: " + d.name() + " type = " + d.type().accept(typeVisitor, null));
+        builder.append("\n");
+        getAttributes(d);
+        incr();
+        d.parameters().forEach(m -> m.accept(this, null));
+        decr();
+        return null;
+    }
+
+    @Override
+    public Void visitVariable(Declaration.Variable d, Void aVoid) {
+        indent();
+        builder.append("Variable: " + d.kind() + " " + d.name() + " type = " + d.type().accept(typeVisitor, null) + ", layout = " + d.layout());
+        builder.append("\n");
+        getAttributes(d);
+        return null;
+    }
+
+    @Override
+    public Void visitConstant(Declaration.Constant d, Void aVoid) {
+        indent();
+        builder.append("Constant: " + d.name() + " " + d.value() + " type = " + d.type().accept(typeVisitor, null));
+        builder.append("\n");
+        getAttributes(d);
+        return null;
+    }
+
+    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {
+        @Override
+        public String visitPrimitive(Type.Primitive t, Void aVoid) {
+            return t.kind().toString() + t.layout().map(l -> "(layout = " + l + ")").orElse("");
+        }
+
+        @Override
+        public String visitDelegated(Type.Delegated t, Void aVoid) {
+            switch (t.kind()) {
+                case TYPEDEF:
+                    return "typedef " + t.name() + " = " + t.type().accept(this, null);
+                case POINTER:
+                    return "(" + t.type().accept(this, null) + ")*";
+                default:
+                    return t.kind() + " = " + t.type().accept(this, null);
+            }
+        }
+
+        @Override
+        public String visitFunction(Type.Function t, Void aVoid) {
+            String res = t.returnType().accept(this, null);
+            String args = t.argumentTypes().stream()
+                    .map(a -> a.accept(this, null))
+                    .collect(Collectors.joining(",", "(", ")"));
+            return res + args;
+        }
+
+        @Override
+        public String visitDeclared(Type.Declared t, Void aVoid) {
+            return "Declared(" + t.tree().layout().map(MemoryLayout::toString).orElse("") + ")";
+        }
+
+        @Override
+        public String visitArray(Type.Array t, Void aVoid) {
+            String brackets = String.format("%s[%s]", t.kind() == Type.Array.Kind.VECTOR ? "v" : "",
+                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : "");
+            return t.elementType().accept(this, null) + brackets;
+        }
+
+        @Override
+        public String visitType(Type t, Void aVoid) {
+            return "Unknown type: " + t.getClass().getName();
+        }
+    };
+
+    public static String type(Type type) {
+        return type.accept(typeVisitor, null);
+    }
+
+    public static String position(Position pos) {
+        return String.format("%s:%d:%d",
+                pos.path() == null ? "N/A" : pos.path().toString(),
+                pos.line(), pos.col());
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/RecordLayoutComputer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/RecordLayoutComputer.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/RecordLayoutComputer.java
@@ -0,0 +1,143 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.ValueLayout;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.Type;
+
+import java.nio.ByteOrder;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * Base class for C struct, union MemoryLayout computer helper classes.
+ */
+abstract class RecordLayoutComputer {
+    // enclosing struct type (or this struct type for top level structs)
+    final Type parent;
+    // this struct type
+    final Type type;
+    // cursor of this struct
+    final Cursor cursor;
+    final List<MemoryLayout> fieldLayouts;
+
+    RecordLayoutComputer(Type parent, Type type) {
+        this.parent = parent;
+        this.type = type;
+        this.cursor = type.getDeclarationCursor().getDefinition();
+        this.fieldLayouts = new ArrayList<>();
+    }
+
+    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {
+        Cursor cursor = type.getDeclarationCursor().getDefinition();
+        if (cursor.isInvalid()) {
+            return MemoryLayout.ofPaddingBits(64);
+        }
+
+        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;
+        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :
+                new StructLayoutComputer(offsetInParent, parent, type).compute();
+    }
+
+    final MemoryLayout compute() {
+        if (Utils.hasIncompleteArray(cursor)) {
+            //for now do this - incomplete arrays not supported well in clang
+            return MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(cursor.type().size() * 8));
+        }
+        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);
+        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {
+            /*
+             * Ignore bitfields of zero width.
+             *
+             * struct Foo {
+             *     int i:0;
+             * }
+             *
+             * And bitfields without a name.
+             * (padding is computed automatically)
+             */
+            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {
+                continue;
+            }
+
+            processField(fc);
+        }
+
+        return finishLayout();
+    }
+
+    abstract void processField(Cursor c);
+    abstract MemoryLayout finishLayout();
+
+    void addFieldLayout(MemoryLayout MemoryLayout) {
+        fieldLayouts.add(MemoryLayout);
+    }
+
+    void addFieldLayout(long offset, Type parent, Cursor c) {
+        MemoryLayout MemoryLayout = c.isAnonymousStruct()?
+            compute(offset, parent, c.type()) :
+            fieldLayout(c);
+        addFieldLayout(MemoryLayout);
+    }
+
+    MemoryLayout fieldLayout(Cursor c) {
+        MemoryLayout l = LayoutUtils.getLayout(c.type());
+        String name = LayoutUtils.getName(c);
+        if (c.isBitField()) {
+            MemoryLayout sublayout = MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder());
+            return sublayout.withName(name);
+        } else {
+            return l.withName(name);
+        }
+    }
+
+    long fieldSize(Cursor c) {
+        return c.isBitField()? c.getBitFieldWidth() : c.type().size() * 8;
+    }
+
+    //Todo: fixme
+    ValueLayout bitfield(ValueLayout v, List<MemoryLayout> sublayouts) {
+        return Utils.addContents(v, MemoryLayout.ofStruct(sublayouts.toArray(new MemoryLayout[0])));
+    }
+
+    long offsetOf(Type parent, Cursor c) {
+        if (c.kind() == CursorKind.FieldDecl) {
+            return parent.getOffsetOf(c.spelling());
+        } else {
+            return Utils.flattenableChildren(c)
+                    .mapToLong(child -> offsetOf(parent, child))
+                    .findFirst()
+                    .orElseThrow(() -> new IllegalStateException(
+                            "Can not find offset of: " + c + ", in: " + parent));
+        }
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructLayoutComputer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructLayoutComputer.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/StructLayoutComputer.java
@@ -0,0 +1,166 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.Type;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * MemoryLayout computer for C structs.
+ */
+final class StructLayoutComputer extends RecordLayoutComputer {
+    private long offset;
+    private long actualSize = 0L;
+    // List to collect bitfield fields to process later, may be null
+    private List<MemoryLayout> bitfieldLayouts;
+
+    StructLayoutComputer(long offsetInParent, Type parent, Type type) {
+        super(parent, type);
+        this.offset = offsetInParent;
+    }
+
+    @Override
+    void addFieldLayout(MemoryLayout MemoryLayout) {
+        if (bitfieldLayouts != null) {
+            bitfieldLayouts.add(MemoryLayout);
+        } else {
+            fieldLayouts.add(MemoryLayout);
+        }
+    }
+
+    @Override
+    void processField(Cursor c) {
+        boolean isBitfield = c.isBitField();
+        long expectedOffset = offsetOf(parent, c);
+        if (expectedOffset > offset) {
+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedOffset - offset));
+            actualSize += (expectedOffset - offset);
+            offset = expectedOffset;
+        }
+
+        if (isBitfield) {
+            /*
+             * In a struct, a bitfield field is seen after a non-bitfield.
+             * Initialize bitfieldLayouts list to collect this and subsequent
+             * bitfield layouts.
+             */
+             if (bitfieldLayouts == null) {
+                 bitfieldLayouts = new ArrayList<>();
+             }
+        } else { // !isBitfield
+            /*
+             * We may be crossing from bit fields to non-bitfield field.
+             *
+             * struct Foo {
+             *     int i:12;
+             *     int j:20;
+             *     int k; // <-- processing this
+             *     int m;
+             * }
+             */
+             handleBitfields();
+        }
+
+        addFieldLayout(offset, parent, c);
+        long size = fieldSize(c);
+        offset += size;
+        actualSize += size;
+    }
+
+    @Override
+    MemoryLayout finishLayout() {
+        // pad at the end, if any
+        long expectedSize = type.size() * 8;
+        if (actualSize < expectedSize) {
+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize - actualSize));
+        }
+
+        /*
+         * Handle bitfields at the end, if any.
+         *
+         * struct Foo {
+         *     int i,j, k;
+         *     int f:10;
+         *     int pad:12;
+         * }
+         */
+        handleBitfields();
+
+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);
+        GroupLayout g = MemoryLayout.ofStruct(fields);
+        String name = LayoutUtils.getName(cursor);
+        return name.isEmpty() ?
+                g : g.withName(name);
+    }
+
+    // process bitfields if any and clear bitfield layouts
+    private void handleBitfields() {
+        if (bitfieldLayouts != null) {
+            fieldLayouts.addAll(convertBitfields(bitfieldLayouts));
+            bitfieldLayouts = null;
+        }
+    }
+
+    private List<MemoryLayout> convertBitfields(List<MemoryLayout> layouts) {
+        long storageSize = storageSize(layouts);
+        long offset = 0L;
+        List<MemoryLayout> newFields = new ArrayList<>();
+        List<MemoryLayout> pendingFields = new ArrayList<>();
+        for (MemoryLayout l : layouts) {
+            offset += l.bitSize();
+            pendingFields.add(l);
+            if (!pendingFields.isEmpty() && offset == storageSize) {
+                //emit new
+                newFields.add(bitfield(LayoutUtils.valueLayoutForSize(storageSize), pendingFields));
+                pendingFields.clear();
+                offset = 0L;
+            } else if (offset > storageSize) {
+                throw new IllegalStateException("Crossing storage unit boundaries");
+            }
+        }
+        if (!pendingFields.isEmpty()) {
+            throw new IllegalStateException("Partially used storage unit");
+        }
+        return newFields;
+    }
+
+    private long storageSize(List<MemoryLayout> layouts) {
+        long size = layouts.stream().mapToLong(MemoryLayout::bitSize).sum();
+        int[] sizes = { 64, 32, 16, 8 };
+        for (int s : sizes) {
+            if (size % s == 0) {
+                return s;
+            }
+        }
+        throw new IllegalStateException("Cannot infer storage size");
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
@@ -0,0 +1,313 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.jextract.impl;
+
+import java.lang.constant.Constable;
+import java.nio.ByteOrder;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+import jdk.incubator.jextract.Type;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.SourceLocation;
+
+class TreeMaker {
+    private final Map<Cursor, Declaration> treeCache = new HashMap<>();
+
+    public TreeMaker() {}
+
+    TypeMaker typeMaker = new TypeMaker(this);
+
+    public void freeze() {
+        typeMaker.resolveTypeReferences();
+    }
+
+    private Declaration checkCache(Cursor c, Supplier<Declaration> factory) {
+        // The supplier function may lead to adding some other type, which will cause CME using computeIfAbsent.
+        // This implementation relax the constraint a bit only check for same key
+        Declaration rv;
+        if (treeCache.containsKey(c)) {
+            rv = treeCache.get(c);
+        } else {
+            rv = factory.get();
+            if (null != rv && treeCache.put(c, rv) != null) {
+                throw new ConcurrentModificationException();
+            }
+        }
+        return rv;
+    }
+
+    interface ScopedFactoryLayout {
+        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);
+    }
+
+    interface ScopedFactoryNoLayout {
+        Declaration.Scoped make(Position pos, String name, Declaration... decls);
+    }
+
+    interface VarFactoryNoLayout {
+        Declaration.Variable make(Position pos, String name, Type type);
+    }
+
+    Map<String, List<Constable>> collectAttributes(Cursor c) {
+        return c.children().filter(Cursor::isAttribute)
+                .collect(Collectors.groupingBy(
+                        attr -> attr.kind().name(),
+                        Collectors.mapping(Cursor::spelling, Collectors.toList())
+                ));
+    }
+
+    public Declaration createTree(Cursor c) {
+        Objects.requireNonNull(c);
+        return checkCache(c, () -> {
+            var rv = (DeclarationImpl) createTreeInternal(c);
+            return (rv == null) ? null : rv.withAttributes(collectAttributes(c));
+        });
+    }
+
+    private Declaration createTreeInternal(Cursor c) {
+        switch (c.kind()) {
+            case EnumDecl:
+                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);
+            case EnumConstantDecl:
+                return createEnumConstant(c);
+            case FieldDecl:
+                return createVar(c.isBitField() ?
+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);
+            case ParmDecl:
+                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);
+            case FunctionDecl:
+                return createFunction(c);
+            case StructDecl:
+                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);
+            case UnionDecl:
+                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);
+            case TypedefDecl: {
+                return createTypedef(c);
+            }
+            case VarDecl:
+                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);
+            default:
+                return null;
+        }
+    }
+
+    Position toPos(Cursor cursor) {
+        SourceLocation loc = cursor.getSourceLocation();
+        if (loc == null) {
+            return Position.NO_POSITION;
+        }
+        SourceLocation.Location sloc = loc.getFileLocation();
+        if (sloc == null) {
+            return Position.NO_POSITION;
+        }
+        return new CursorPosition(cursor);
+    }
+
+    static class CursorPosition implements Position {
+        private final Cursor cursor;
+        private final Path path;
+        private final int line;
+        private final int column;
+
+        CursorPosition(Cursor cursor) {
+            this.cursor = cursor;
+            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();
+            this.path = loc.path();
+            this.line = loc.line();
+            this.column = loc.column();
+        }
+
+        @Override
+        public Path path() {
+            return path;
+        }
+
+        @Override
+        public int line() {
+            return line;
+        }
+
+        @Override
+        public int col() {
+            return column;
+        }
+
+        public Cursor cursor() {
+            return cursor;
+        }
+
+        @Override
+        public String toString() {
+            return PrettyPrinter.position(this);
+        }
+    }
+
+    public Declaration.Function createFunction(Cursor c) {
+        checkCursor(c, CursorKind.FunctionDecl);
+        List<Declaration.Variable> params = new ArrayList<>();
+        for (int i = 0 ; i < c.numberOfArgs() ; i++) {
+            params.add((Declaration.Variable)createTree(c.getArgument(i)));
+        }
+        return Declaration.function(toPos(c), c.spelling(), (Type.Function)toType(c),
+                params.toArray(new Declaration.Variable[0]));
+    }
+
+    public Declaration.Constant createMacro(Cursor c, Optional<MacroParserImpl.Macro> macro) {
+        checkCursorAny(c, CursorKind.MacroDefinition);
+        if (macro.isEmpty()) {
+            return null;
+        } else {
+            MacroParserImpl.Macro parsedMacro = macro.get();
+            return Declaration.constant(toPos(c), c.spelling(), parsedMacro.value, parsedMacro.type());
+        }
+    }
+
+    public Declaration.Constant createEnumConstant(Cursor c) {
+        return Declaration.constant(toPos(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));
+    }
+
+    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {
+        return Declaration.toplevel(toPos(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));
+    }
+
+    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {
+        List<Declaration> decls = filterNestedDeclarations(c.children()
+                .map(this::createTree).collect(Collectors.toList()));
+        if (c.isDefinition()) {
+            //just a declaration AND definition, we have a layout
+            MemoryLayout layout = LayoutUtils.getLayout(c.type());
+            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?
+                    collectBitfields(layout, decls) :
+                    decls;
+            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));
+        } else {
+            //just a declaration
+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||
+                    scopeKind == Declaration.Scoped.Kind.UNION ||
+                    scopeKind == Declaration.Scoped.Kind.ENUM ||
+                    scopeKind == Declaration.Scoped.Kind.CLASS) {
+                //if there's a real definition somewhere else, skip this redundant declaration
+                if (!c.getDefinition().isInvalid()) {
+                    return null;
+                }
+            }
+            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));
+        }
+    }
+
+    private static boolean isEnum(Declaration d) {
+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;
+    }
+
+    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {
+        return declarations.stream()
+                .filter(Objects::nonNull)
+                .filter(d -> isEnum(d) || !d.name().isEmpty() || ((CursorPosition)d.pos()).cursor.isAnonymousStruct())
+                .collect(Collectors.toList());
+    }
+
+    private Declaration.Scoped createTypedef(Cursor c) {
+        Optional<Cursor> decl = c.children().findFirst();
+        if (decl.isPresent() && decl.get().isDefinition() && decl.get().spelling().isEmpty()) {
+            Declaration def = createTree(decl.get());
+            if (def instanceof Declaration.Scoped) {
+                return Declaration.typedef(toPos(c), c.spelling(), def);
+            }
+        }
+        return null;
+    }
+
+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {
+        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);
+        if (c.isBitField()) {
+            return Declaration.bitfield(toPos(c), c.spelling(), toType(c),
+                    MemoryLayout.ofValueBits(c.getBitFieldWidth(), ByteOrder.nativeOrder()));
+        } else {
+            return varFactory.make(toPos(c), c.spelling(), toType(c));
+        }
+    }
+
+    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {
+        List<Declaration> newDecls = new ArrayList<>();
+        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {
+            Optional<GroupLayout> contents = Utils.getContents(e);
+            if (contents.isPresent()) {
+                List<Declaration.Variable> bfDecls = new ArrayList<>();
+                outer: for (MemoryLayout bitfield : contents.get().memberLayouts()) {
+                    if (bitfield.name().isPresent()) {
+                        Iterator<Declaration> declIt = declarations.iterator();
+                        while (declIt.hasNext()) {
+                            Declaration d = declIt.next();
+                            if (d.name().equals(bitfield.name().get())) {
+                                bfDecls.add((Declaration.Variable)d);
+                                declIt.remove();
+                                continue outer;
+                            }
+                        }
+                        throw new IllegalStateException("No matching declaration found for bitfield: " + bitfield);
+                    }
+                }
+                newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), "", contents.get(), bfDecls.toArray(new Declaration.Variable[0])));
+            }
+        }
+        newDecls.addAll(declarations);
+        return newDecls;
+    }
+
+    private Type toType(Cursor c) {
+        return typeMaker.makeType(c.type());
+    }
+
+    private void checkCursor(Cursor c, CursorKind k) {
+        if (c.kind() != k) {
+            throw new IllegalArgumentException("Invalid cursor kind");
+        }
+    }
+
+    private void checkCursorAny(Cursor c, CursorKind... kinds) {
+        CursorKind expected = Objects.requireNonNull(c.kind());
+        for (CursorKind k : kinds) {
+            if (k == expected) {
+                return;
+            }
+        }
+        throw new IllegalArgumentException("Invalid cursor kind");
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeImpl.java
@@ -0,0 +1,359 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import java.util.List;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.OptionalLong;
+import java.util.function.Supplier;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+
+public abstract class TypeImpl implements Type {
+
+    @Override
+    public boolean isErroneous() {
+        return false;
+    }
+
+    static boolean equals(Type t1, Type.Delegated t2) {
+        assert t1 != null;
+        assert t2 != null;
+
+        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());
+    }
+
+    public static final TypeImpl ERROR = new TypeImpl() {
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitType(this, data);
+        }
+
+        @Override
+        public boolean isErroneous() {
+            return true;
+        }
+    };
+
+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {
+
+        private final Primitive.Kind kind;
+        private final Optional<MemoryLayout> layoutOpt;
+
+        public PrimitiveImpl(Kind kind, MemoryLayout layout) {
+            this(kind, Optional.of(layout));
+        }
+
+        public PrimitiveImpl(Kind kind) {
+            this(kind, Optional.empty());
+        }
+
+        private PrimitiveImpl(Kind kind, Optional<MemoryLayout> layoutOpt) {
+            super();
+            this.kind = Objects.requireNonNull(kind);
+            this.layoutOpt = Objects.requireNonNull(layoutOpt);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitPrimitive(this, data);
+        }
+
+        @Override
+        public Kind kind() {
+            return kind;
+        }
+
+        @Override
+        public Optional<MemoryLayout> layout() {
+            return layoutOpt;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Primitive)) {
+                return (o instanceof Delegated) && equals(this, (Delegated)o);
+            }
+            Type.Primitive primitive = (Type.Primitive) o;
+            return kind == primitive.kind();
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind);
+        }
+    }
+
+    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {
+        Delegated.Kind kind;
+        Optional<String> name;
+
+        DelegatedBase(Kind kind, Optional<String> name) {
+            this.kind = Objects.requireNonNull(kind);
+            this.name = Objects.requireNonNull(name);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitDelegated(this, data);
+        }
+
+        @Override
+        public final Delegated.Kind kind() {
+            return kind;
+        }
+
+        @Override
+        public final Optional<String> name() {
+            return name;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Delegated)) {
+                return (o instanceof Type) && equals((Type)o, this);
+            }
+            Type.Delegated that = (Type.Delegated) o;
+            return kind == that.kind() &&
+                    name.equals(that.name());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, name);
+        }
+    }
+
+    public static final class QualifiedImpl extends DelegatedBase {
+        private final Type type;
+
+        public QualifiedImpl(Kind kind, Type type) {
+            this(kind, Optional.empty(), type);
+        }
+
+        public QualifiedImpl(Kind kind, String name, Type type) {
+            this(kind, Optional.of(name), type);
+        }
+
+        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {
+            super(kind, name);
+            this.type = type;
+        }
+
+        @Override
+        public Type type() {
+            return type;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Delegated)) return false;
+            if (!super.equals(o)) {
+                return (o instanceof Delegated) && equals(this, (Delegated) o);
+            }
+            Type.Delegated qualified = (Type.Delegated) o;
+            return Objects.equals(type, qualified.type());
+        }
+
+        @Override
+        public int hashCode() {
+            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);
+        }
+    }
+
+    public static final class PointerImpl extends DelegatedBase {
+        private final Supplier<Type> pointeeFactory;
+
+        public PointerImpl(Supplier<Type> pointeeFactory) {
+            super(Kind.POINTER, Optional.empty());
+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);
+        }
+
+        public PointerImpl(Type pointee) {
+            this(() -> pointee);
+        }
+
+        @Override
+        public Type type() {
+            return pointeeFactory.get();
+        }
+    }
+
+    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {
+
+        private final Declaration.Scoped declaration;
+
+        public DeclaredImpl(Declaration.Scoped declaration) {
+            super();
+            this.declaration = Objects.requireNonNull(declaration);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitDeclared(this, data);
+        }
+
+        @Override
+        public Declaration.Scoped tree() {
+            return declaration;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Declared)) {
+                return (o instanceof Delegated) && equals(this, (Delegated) o);
+            }
+            Type.Declared declared = (Type.Declared) o;
+            return declaration.equals(declared.tree());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(declaration);
+        }
+    }
+
+    public static final class FunctionImpl extends TypeImpl implements Type.Function {
+
+        private final boolean varargs;
+        private final List<Type> argtypes;
+        private final Type restype;
+
+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {
+            super();
+            this.varargs = varargs;
+            this.argtypes = Objects.requireNonNull(argtypes);
+            this.restype = Objects.requireNonNull(restype);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitFunction(this, data);
+        }
+
+        @Override
+        public boolean varargs() {
+            return varargs;
+        }
+
+        @Override
+        public List<Type> argumentTypes() {
+            return argtypes;
+        }
+
+        @Override
+        public Type returnType() {
+            return restype;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Function)) {
+                return (o instanceof Delegated) && equals(this, (Delegated) o);
+            }
+            Type.Function function = (Type.Function) o;
+            return varargs == function.varargs() &&
+                    argtypes.equals(function.argumentTypes()) &&
+                    restype.equals(function.returnType());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(varargs, argtypes, restype);
+        }
+    }
+
+    public static final class ArrayImpl extends TypeImpl implements Type.Array {
+
+        private final Kind kind;
+        private final OptionalLong elemCount;
+        private final Type elemType;
+
+        public ArrayImpl(Kind kind, long count, Type elemType) {
+            this(kind, elemType, OptionalLong.of(count));
+        }
+
+        public ArrayImpl(Kind kind, Type elemType) {
+            this(kind, elemType, OptionalLong.empty());
+        }
+
+        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {
+            super();
+            this.kind = Objects.requireNonNull(kind);
+            this.elemCount = Objects.requireNonNull(elemCount);
+            this.elemType = Objects.requireNonNull(elemType);
+        }
+
+        @Override
+        public <R, D> R accept(Visitor<R, D> visitor, D data) {
+            return visitor.visitArray(this, data);
+        }
+
+        @Override
+        public OptionalLong elementCount() {
+            return elemCount;
+        }
+
+        @Override
+        public Type elementType() {
+            return elemType;
+        }
+
+        @Override
+        public Kind kind() {
+            return kind;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (!(o instanceof Type.Array)) {
+                return (o instanceof Delegated) && equals(this, (Delegated) o);
+            }
+            Type.Array array = (Type.Array) o;
+            return kind == array.kind() &&
+                    elemType.equals(array.elementType());
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(kind, elemType);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return PrettyPrinter.type(this);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeMaker.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypeMaker.java
@@ -0,0 +1,234 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+
+import java.util.ArrayList;
+import java.util.ConcurrentModificationException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Supplier;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import jdk.incubator.jextract.Type.Delegated;
+import jdk.incubator.jextract.Type.Primitive;
+
+class TypeMaker {
+
+    TreeMaker treeMaker;
+    private final Map<jdk.internal.clang.Type, Type> typeCache = new HashMap<>();
+    private List<ClangTypeReference> unresolved = new ArrayList<>();
+
+    private class ClangTypeReference implements Supplier<Type> {
+        jdk.internal.clang.Type origin;
+        Type derived;
+
+        private ClangTypeReference(jdk.internal.clang.Type origin) {
+            this.origin = origin;
+            derived = typeCache.get(origin);
+        }
+
+        public boolean isUnresolved() {
+            return null == derived;
+        }
+
+        public void resolve() {
+            derived = makeType(origin);
+            Objects.requireNonNull(derived, "Clang type cannot be resolved: " + origin.spelling());
+        }
+
+        public Type get() {
+            Objects.requireNonNull(derived, "Type is not yet resolved.");
+            return derived;
+        }
+    }
+
+    private ClangTypeReference reference(jdk.internal.clang.Type type) {
+        ClangTypeReference ref = new ClangTypeReference(type);
+        if (ref.isUnresolved()) {
+            unresolved.add(ref);
+        }
+        return ref;
+    }
+
+    public TypeMaker(TreeMaker treeMaker) {
+        this.treeMaker = treeMaker;
+    }
+
+    /**
+     * Resolve all type references. This method should be called before discard clang cursors/types
+     */
+    void resolveTypeReferences() {
+        List<ClangTypeReference> resolving = unresolved;
+        unresolved = new ArrayList<>();
+        while (! resolving.isEmpty()) {
+            resolving.forEach(ClangTypeReference::resolve);
+            resolving = unresolved;
+            unresolved = new ArrayList<>();
+        }
+    }
+
+    Type makeType(jdk.internal.clang.Type t) {
+        Type rv = typeCache.get(t);
+        if (rv != null) {
+            return rv;
+        }
+        rv = makeTypeInternal(t);
+        if (null != rv && typeCache.put(t, rv) != null) {
+            throw new ConcurrentModificationException();
+        }
+        return rv;
+    }
+
+    Type makeTypeInternal(jdk.internal.clang.Type t) {
+        switch(t.kind()) {
+            case Auto:
+                return makeType(t.canonicalType());
+            case Void:
+                return Type.void_();
+            case Char_S:
+            case Char_U:
+                return Type.primitive(Primitive.Kind.Char, LayoutUtils.C_CHAR);
+            case Short:
+                return Type.primitive(Primitive.Kind.Short, LayoutUtils.C_SHORT);
+            case Int:
+                return Type.primitive(Primitive.Kind.Int, LayoutUtils.C_INT);
+            case Long:
+                return Type.primitive(Primitive.Kind.Long, LayoutUtils.C_LONG);
+            case LongLong:
+                return Type.primitive(Primitive.Kind.LongLong, LayoutUtils.C_LONGLONG);
+            case SChar: {
+                Type chType = Type.primitive(Primitive.Kind.Char, LayoutUtils.C_SCHAR);
+                return Type.qualified(Delegated.Kind.SIGNED, chType);
+            }
+            case UShort: {
+                Type chType = Type.primitive(Primitive.Kind.Short, LayoutUtils.C_USHORT);
+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);
+            }
+            case UInt: {
+                Type chType = Type.primitive(Primitive.Kind.Int, LayoutUtils.C_UINT);
+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);
+            }
+            case ULong: {
+                Type chType = Type.primitive(Primitive.Kind.Long, LayoutUtils.C_ULONG);
+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);
+            }
+            case ULongLong: {
+                Type chType = Type.primitive(Primitive.Kind.LongLong, LayoutUtils.C_ULONGLONG);
+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);
+            }
+            case UChar: {
+                Type chType = Type.primitive(Primitive.Kind.Char, LayoutUtils.C_UCHAR);
+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);
+            }
+
+            case Bool:
+                return Type.primitive(Primitive.Kind.Bool, LayoutUtils.C_BOOL);
+            case Double:
+                return Type.primitive(Primitive.Kind.Double, LayoutUtils.C_DOUBLE);
+            case LongDouble:
+                return Type.primitive(Primitive.Kind.LongDouble, LayoutUtils.C_LONGDOUBLE);
+            case Float:
+                return Type.primitive(Primitive.Kind.Float, LayoutUtils.C_FLOAT);
+            case Unexposed:
+            case Elaborated:
+                jdk.internal.clang.Type canonical = t.canonicalType();
+                if (canonical.equalType(t)) {
+                    throw new IllegalStateException("Unknown type with same canonical type: " + t.spelling());
+                }
+                return makeType(canonical);
+            case ConstantArray: {
+                Type elem = makeType(t.getElementType());
+                return Type.array(t.getNumberOfElements(), elem);
+            }
+            case IncompleteArray: {
+                Type elem = makeType(t.getElementType());
+                return Type.array(elem);
+            }
+            case FunctionProto:
+            case FunctionNoProto: {
+                List<Type> args = new ArrayList<>();
+                for (int i = 0; i < t.numberOfArgs(); i++) {
+                    // argument could be function pointer declared locally
+                    args.add(lowerFunctionType(t.argType(i)));
+                }
+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));
+            }
+            case Enum:
+            case Record: {
+                if (treeMaker == null) {
+                    // Macro evaluation, type is meaningless as this can only be pointer and we only care value
+                    return Type.void_();
+                }
+                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));
+            }
+            case BlockPointer:
+            case Pointer: {
+                // TODO: We can always erase type for macro evaluation, should we?
+                return new TypeImpl.PointerImpl(reference(t.getPointeeType()));
+            }
+            case Typedef: {
+                Type __type = makeType(t.canonicalType());
+                return Type.typedef(t.spelling(), __type);
+            }
+            case Complex: {
+                Type __type = makeType(t.getElementType());
+                return Type.qualified(Delegated.Kind.COMPLEX, __type);
+            }
+            case Vector: {
+                Type __type = makeType(t.getElementType());
+                return Type.vector(t.getNumberOfElements(), __type);
+            }
+            case WChar: //unsupported
+            case Char16: //unsupported
+            case Half: //unsupported
+            case Int128: //unsupported
+            case UInt128: //unsupported
+            default:
+                return TypeImpl.ERROR;
+        }
+    }
+
+    private Type lowerFunctionType(jdk.internal.clang.Type t) {
+        Type t2 = makeType(t);
+        return t2.accept(lowerFunctionType, null);
+    }
+
+    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {
+        @Override
+        public Type visitArray(Type.Array t, Void aVoid) {
+            return Type.pointer(t.elementType());
+        }
+
+        @Override
+        public Type visitType(Type t, Void aVoid) {
+            return t;
+        }
+    };
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypedefHandler.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypedefHandler.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TypedefHandler.java
@@ -0,0 +1,91 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.jextract.Declaration;
+import jdk.internal.clang.Cursor;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * This visitor handles certain typedef declarations.
+ *
+ * 1. Remove redundant typedefs.
+ * 2. Rename typedef'ed anonymous type definitions like
+ *        typedef struct { int x; int y; } Point;
+ */
+final class TypedefHandler implements Declaration.Visitor<Void, Void> {
+
+    TreeMaker maker;
+
+    public TypedefHandler(TreeMaker maker) {
+        this.maker = maker;
+    }
+
+    // Potential Tree instances that will go into transformed HeaderTree
+    // are collected in this list.
+    private List<Declaration> decls = new ArrayList<>();
+
+    // Tree instances that are to be replaced from "decls" list are
+    // saved in the following Map. One or more Trees can replace a Tree.
+    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();
+
+    public Declaration.Scoped transform(Declaration.Scoped ht) {
+        // Process all header declarations are collect potential
+        // declarations that will go into transformed HeaderTree
+        // into the this.decls field.
+        ht.accept(this, null);
+
+//        // Replace trees from this.decls with Trees found in this.replacements.
+//        // We need this two step process so that named StructTree instances
+//        // will replace with original unnamed StructTree instances.
+//        List<Declaration> newDecls = decls.stream().flatMap(tx -> {
+//            if (replacements.containsKey(tx.cursor())) {
+//                return replacements.get(tx.cursor()).stream();
+//            } else {
+//                return Stream.of(tx);
+//            }
+//        }).collect(Collectors.toList());
+//
+//        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);
+        return ht;
+    }
+
+    @Override
+    public Void visitDeclaration(Declaration d, Void aVoid) {
+        decls.add(d);
+        return null;
+    }
+
+    @Override
+    public Void visitScoped(Declaration.Scoped ht, Void v) {
+        ht.members().forEach(decl -> decl.accept(this, null));
+        return null;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/UnionLayoutComputer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/UnionLayoutComputer.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/UnionLayoutComputer.java
@@ -0,0 +1,89 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.ValueLayout;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.Type;
+
+import java.util.List;
+
+/**
+ * MemoryLayout computer for C unions.
+ */
+final class UnionLayoutComputer extends RecordLayoutComputer {
+    private final long offset;
+    private long actualSize = 0L;
+
+    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {
+        super(parent, type);
+        this.offset = offsetInParent;
+    }
+
+    @Override
+    void processField(Cursor c) {
+        long expectedOffset = offsetOf(parent, c);
+        if (expectedOffset > offset) {
+            throw new IllegalStateException("No padding in union elements!");
+        }
+
+        addFieldLayout(offset, parent, c);
+        actualSize = Math.max(actualSize, fieldSize(c));
+    }
+
+    @Override
+    MemoryLayout fieldLayout(Cursor c) {
+        if (c.isBitField()) {
+            MemoryLayout layout = LayoutUtils.getLayout(c.type());
+            return bitfield((ValueLayout) layout, List.of(super.fieldLayout(c)));
+        } else {
+            return super.fieldLayout(c);
+        }
+    }
+
+    @Override
+    long fieldSize(Cursor c) {
+        return c.type().size() * 8;
+    }
+
+    @Override
+    MemoryLayout finishLayout() {
+        // size mismatch indicates anonymous bitfield used for padding
+        long expectedSize = type.size() * 8;
+        if (actualSize < expectedSize) {
+            addFieldLayout(MemoryLayout.ofPaddingBits(expectedSize));
+        }
+
+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);
+        GroupLayout g = MemoryLayout.ofUnion(fields);
+        String name = LayoutUtils.getName(cursor);
+        return name.isEmpty() ?
+                g : g.withName(name);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Utils.java
@@ -0,0 +1,291 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.SourceLocation;
+import jdk.internal.clang.Type;
+import jdk.internal.clang.TypeKind;
+
+import javax.lang.model.SourceVersion;
+import java.lang.reflect.Method;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+/**
+ * General utility functions
+ */
+class Utils {
+    public static void validSimpleIdentifier(String name) {
+        int length = name.length();
+        if (length == 0) {
+            throw new IllegalArgumentException();
+        }
+
+        int ch = name.codePointAt(0);
+        if (length == 1 && ch == '_') {
+            throw new IllegalArgumentException("'_' is no longer valid identifier.");
+        }
+
+        if (!Character.isJavaIdentifierStart(ch)) {
+            throw new IllegalArgumentException("Invalid start character for an identifier: " + ch);
+        }
+
+        for (int i = 1; i < length; i++) {
+            ch = name.codePointAt(i);
+            if (!Character.isJavaIdentifierPart(ch)) {
+                throw new IllegalArgumentException("Invalid character for an identifier: " + ch);
+            }
+        }
+    }
+
+    public static void validPackageName(String name) {
+        if (name.isEmpty()) {
+            throw new IllegalArgumentException();
+        }
+        int idx = name.lastIndexOf('.');
+        if (idx == -1) {
+           validSimpleIdentifier(name);
+        } else {
+            validSimpleIdentifier(name.substring(idx + 1));
+            validPackageName(name.substring(0, idx));
+        }
+    }
+
+    public static String toJavaIdentifier(String str) {
+        final int size = str.length();
+        StringBuilder sb = new StringBuilder(size);
+        if (! Character.isJavaIdentifierStart(str.charAt(0))) {
+            sb.append('_');
+        }
+        for (int i = 0; i < size; i++) {
+            char ch = str.charAt(i);
+            if (Character.isJavaIdentifierPart(ch)) {
+                sb.append(ch);
+            } else {
+                sb.append('_');
+            }
+        }
+        return sb.toString();
+    }
+
+    private static String toSafeName(String name) {
+        StringBuilder sb = new StringBuilder(name.length());
+        name = toJavaIdentifier(name);
+        sb.append(name);
+        if (SourceVersion.isKeyword(name)) {
+            sb.append("$");
+        }
+        return sb.toString();
+    }
+
+    public static String toClassName(String cname) {
+        return toSafeName(cname);
+    }
+
+    public static String toMacroName(String mname) {
+        return toSafeName(mname);
+    }
+
+    public static String toInternalName(String pkg, String name, String... nested) {
+        if ((pkg == null || pkg.isEmpty()) && nested == null) {
+            return name;
+        }
+
+        StringBuilder sb = new StringBuilder();
+        if (pkg != null && ! pkg.isEmpty()) {
+            sb.append(pkg.replace('.', '/'));
+            if (sb.charAt(sb.length() - 1) != '/') {
+                sb.append('/');
+            }
+        }
+        sb.append(name);
+        for (String n: nested) {
+            sb.append('$');
+            sb.append(n);
+        }
+        return sb.toString();
+    }
+
+    public static String getName(Type type) {
+        return LayoutUtils.getName(type);
+    }
+
+    public static Stream<Cursor> flattenableChildren(Cursor c) {
+        return c.children()
+                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);
+    }
+
+    public static Optional<Cursor> lastChild(Cursor c) {
+        List<Cursor> children = flattenableChildren(c)
+                .collect(Collectors.toList());
+        return children.isEmpty() ? Optional.empty() : Optional.of(children.get(children.size() - 1));
+    }
+
+    public static boolean hasIncompleteArray(Cursor c) {
+        switch (c.kind()) {
+            case FieldDecl:
+                return c.type().kind() == TypeKind.IncompleteArray;
+            case UnionDecl:
+                return flattenableChildren(c)
+                        .anyMatch(Utils::hasIncompleteArray);
+            case StructDecl:
+                return lastChild(c).map(Utils::hasIncompleteArray).orElse(false);
+            default:
+                throw new IllegalStateException("Unhandled cursor kind: " + c.kind());
+        }
+    }
+
+    // return builtin Record types accessible from the given Type
+    public static Stream<Cursor> getBuiltinRecordTypes(Type type) {
+        List<Cursor> recordTypes = new ArrayList<>();
+        fillBuiltinRecordTypes(type, recordTypes);
+        return recordTypes.stream().distinct();
+    }
+
+    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {
+        Type canonicalType = type.canonicalType();
+        switch (canonicalType.kind()) {
+            case ConstantArray:
+            case IncompleteArray:
+                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);
+                break;
+
+            case FunctionProto:
+            case FunctionNoProto: {
+                final int numArgs = canonicalType.numberOfArgs();
+                for (int i = 0; i < numArgs; i++) {
+                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);
+                }
+                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);
+            }
+            break;
+
+            case Record: {
+                Cursor c = canonicalType.getDeclarationCursor();
+                if (c.isDefinition()) {
+                    SourceLocation sloc = c.getSourceLocation();
+                    if (sloc != null && sloc.getFileLocation().path() == null) {
+                        recordTypes.add(c);
+                    }
+                }
+            }
+            break;
+
+            case BlockPointer:
+            case Pointer:
+                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);
+                break;
+
+            case Unexposed:
+                if (! canonicalType.equalType(type)) {
+                    fillBuiltinRecordTypes(canonicalType, recordTypes);
+                }
+                break;
+
+            case Elaborated:
+            case Typedef:
+                fillBuiltinRecordTypes(canonicalType, recordTypes);
+                break;
+
+            default: // nothing to do
+        }
+    }
+
+    // return the absolute path of the library of given name by searching
+    // in the given array of paths.
+    public static Optional<Path> findLibraryPath(Path[] paths, String libName) {
+        return Arrays.stream(paths).
+                map(p -> p.resolve(System.mapLibraryName(libName))).
+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();
+    }
+
+    /*
+     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit
+     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'
+     * are from javac source. See also com.sun.tools.javac.util.Convert.java.
+     */
+
+    /**
+     * Escapes each character in a string that has an escape sequence or
+     * is non-printable ASCII.  Leaves non-ASCII characters alone.
+     */
+    public static String quote(String s) {
+        StringBuilder buf = new StringBuilder();
+        for (int i = 0; i < s.length(); i++) {
+            buf.append(quote(s.charAt(i)));
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Escapes a character if it has an escape sequence or is
+     * non-printable ASCII.  Leaves non-ASCII characters alone.
+     */
+    public static String quote(char ch) {
+        switch (ch) {
+        case '\b':  return "\\b";
+        case '\f':  return "\\f";
+        case '\n':  return "\\n";
+        case '\r':  return "\\r";
+        case '\t':  return "\\t";
+        case '\'':  return "\\'";
+        case '\"':  return "\\\"";
+        case '\\':  return "\\\\";
+        default:
+            return (isPrintableAscii(ch))
+                ? String.valueOf(ch)
+                : String.format("\\u%04x", (int) ch);
+        }
+    }
+
+    /**
+     * Is a character printable ASCII?
+     */
+    private static boolean isPrintableAscii(char ch) {
+        return ch >= ' ' && ch <= '~';
+    }
+
+    public static Optional<GroupLayout> getContents(MemoryLayout layout) {
+        return layout.attribute("contents").map(GroupLayout.class::cast);
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <Z extends MemoryLayout> Z addContents(Z layout, GroupLayout contents) {
+        return (Z) layout.withAttribute("contents", contents);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Writer.java
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ *  This code is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 only, as
+ *  published by the Free Software Foundation.  Oracle designates this
+ *  particular file as subject to the "Classpath" exception as provided
+ *  by Oracle in the LICENSE file that accompanied this code.
+ *
+ *  This code is distributed in the hope that it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  version 2 for more details (a copy is included in the LICENSE file that
+ *  accompanied this code).
+ *
+ *  You should have received a copy of the GNU General Public License version
+ *  2 along with this work; if not, write to the Free Software Foundation,
+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ *  or visit www.oracle.com if you need additional information or have any
+ *  questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import javax.tools.JavaFileObject;
+import java.io.IOException;
+import java.nio.file.FileAlreadyExistsException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.stream.Collectors;
+
+public final class Writer {
+
+    private final List<? extends JavaFileObject> files;
+    private final Path dest;
+
+    Writer(Path dest, List<? extends JavaFileObject> files) {
+        this.files = files;
+        this.dest = dest;
+    }
+
+    private List<JavaFileObject> ensureSourcesCompiled() {
+        List<JavaFileObject> sources = sources();
+        if (sources.isEmpty()) {
+            return List.of();
+        } else {
+            return InMemoryJavaCompiler.compile(sources, 
+                "--add-modules", "jdk.incubator.foreign",
+                "-d", dest.toAbsolutePath().toString());
+        }
+    }
+
+    void writeAll(boolean compileSources) throws IOException {
+        writeClassFiles(resources());
+        writeClassFiles(classes());
+        if (compileSources) {
+            writeClassFiles(ensureSourcesCompiled());
+        } else {
+            writeSourceFiles();
+        }
+    }
+
+    void writeClassFiles(List<JavaFileObject> files) throws IOException {
+        Path destDir = createOutputDir();
+        for (var entry : files) {
+            String path = entry.getName();
+            Path fullPath = destDir.resolve(path).normalize();
+            Files.createDirectories(fullPath.getParent());
+            Files.write(fullPath, entry.openInputStream().readAllBytes());
+        }
+    }
+
+    void writeSourceFiles() throws IOException {
+        Path destDir = createOutputDir();
+        for (var entry : sources()) {
+            String srcPath = entry.getName();
+            Path fullPath = destDir.resolve(srcPath).normalize();
+            Path dir = fullPath.getParent();
+            // In case the folder exist and is a link to a folder, this should be OK
+            // Case in point, /tmp on MacOS link to /private/tmp
+            if (Files.exists(dir)) {
+                if (!Files.isDirectory(dir)) {
+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());
+                }
+            } else {
+                Files.createDirectories(fullPath.getParent());
+            }
+            Files.write(fullPath, List.of(entry.getCharContent(false)));
+        }
+    }
+
+    private List<JavaFileObject> sources() {
+        return files.stream()
+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)
+                .collect(Collectors.toList());
+    }
+
+    private List<JavaFileObject> classes() {
+        return files.stream()
+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)
+                .collect(Collectors.toList());
+    }
+
+    private List<JavaFileObject> resources() {
+        return files.stream()
+                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))
+                .collect(Collectors.toList());
+    }
+
+    private Path createOutputDir() throws IOException {
+        Path absDest = dest.toAbsolutePath();
+        if (!Files.exists(absDest)) {
+            Files.createDirectories(absDest);
+        }
+        if (!Files.isDirectory(absDest)) {
+            throw new IOException("Not a directory: " + dest);
+        }
+        return absDest;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/module-info.java b/src/jdk.incubator.jextract/share/classes/module-info.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/module-info.java
@@ -0,0 +1,9 @@
+module jdk.incubator.jextract {
+    requires transitive java.compiler;
+    requires transitive jdk.incubator.foreign;
+    requires jdk.internal.opt;
+    exports jdk.incubator.jextract;
+
+    provides java.util.spi.ToolProvider with
+        jdk.incubator.jextract.tool.Main.JextractToolProvider;
+}
diff a/src/jdk.internal.opt/share/classes/module-info.java b/src/jdk.internal.opt/share/classes/module-info.java
--- a/src/jdk.internal.opt/share/classes/module-info.java
+++ b/src/jdk.internal.opt/share/classes/module-info.java
@@ -27,7 +27,13 @@
  * Internal option processing API
  *
  * @since 9
  */
 module jdk.internal.opt {
-    exports jdk.internal.joptsimple to jdk.jlink, jdk.jshell;
+    exports jdk.internal.joptsimple to
+        jdk.incubator.jextract,
+        jdk.jlink,
+        jdk.jshell;
+
+    exports jdk.internal.joptsimple.util to
+        jdk.incubator.jextract;
 }
diff a/test/jdk/TEST.groups b/test/jdk/TEST.groups
--- a/test/jdk/TEST.groups
+++ b/test/jdk/TEST.groups
@@ -39,10 +39,11 @@
 
 tier1_part3 = \
     :jdk_math \
     :jdk_svc_sanity \
     :jdk_foreign \
+    :jdk_jextract \
     java/nio/Buffer \
     com/sun/crypto/provider/Cipher \
     sun/nio/cs/ISO8859x.java
 
 # When adding tests to tier2, make sure they end up in one of the tier2_partX groups
@@ -334,10 +335,14 @@
     :svc_tools
 
 jdk_foreign = \
     java/foreign
 
+jdk_jextract = \
+    java/jextract \
+    tools/jextract
+
 #############################
 
 #
 # Client area groups
 #
diff a/test/jdk/java/jextract/JextractApiTestBase.java b/test/jdk/java/jextract/JextractApiTestBase.java
--- /dev/null
+++ b/test/jdk/java/jextract/JextractApiTestBase.java
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.Optional;
+import java.util.function.Predicate;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.JextractTask;
+import jdk.incubator.jextract.Type;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+public class JextractApiTestBase {
+    static final boolean isMacOSX =
+            System.getProperty("os.name", "unknown").contains("OS X");
+    static final boolean isWindows =
+            System.getProperty("os.name", "unknown").startsWith("Windows");
+
+    public static  Declaration.Scoped parse(String headerFilename, String... parseOptions) {
+        Path header = Paths.get(System.getProperty("test.src.path", "."), headerFilename);
+        var task = JextractTask.newTask(false, header);
+        Path builtinInc = Paths.get(System.getProperty("java.home"), "conf", "jextract");
+        return task.parse(parseOptions);
+    }
+
+    public static Declaration.Scoped checkScoped(Declaration.Scoped toplevel, String name, Declaration.Scoped.Kind kind,  String... fields) {
+        Declaration.Scoped scoped = findDecl(toplevel, name, Declaration.Scoped.class);
+        assertEquals(scoped.members().size(), fields.length);
+        assertTrue(scoped.kind() == kind);
+        for (int i = 0; i < fields.length; i++) {
+            assertEquals(scoped.members().get(i).name(), fields[i]);
+        }
+        return scoped;
+    }
+
+    public static Declaration.Scoped checkStruct(Declaration.Scoped toplevel, String name, String... fields) {
+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.STRUCT, fields);
+    }
+
+    public static Declaration.Scoped checkBitfields(Declaration.Scoped toplevel, String name, String... fields) {
+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.BITFIELDS, fields);
+    }
+
+    public static Declaration.Scoped checkUnion(Declaration.Scoped toplevel, String name, String... fields) {
+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.UNION, fields);
+    }
+
+    public static Declaration.Variable checkConstant(Declaration.Scoped scope, String name, Type type) {
+        Declaration.Variable var = findDecl(scope, name, Declaration.Variable.class);
+        assertTypeEquals(type, var.type());
+        return var;
+    }
+
+    public static Declaration.Variable checkGlobal(Declaration.Scoped toplevel, String name, Type type) {
+        Declaration.Variable global = checkConstant(toplevel, name, type);
+        assertEquals(global.kind(), Declaration.Variable.Kind.GLOBAL);
+        return global;
+    }
+
+    public static Declaration.Variable checkField(Declaration.Scoped record, String name, Type type) {
+        Declaration.Variable global = checkConstant(record, name, type);
+        assertEquals(global.kind(), Declaration.Variable.Kind.FIELD);
+        return global;
+    }
+
+    public static Declaration.Variable checkBitField(Declaration.Scoped record, String name, Type type, int size) {
+        Declaration.Variable global = checkConstant(record, name, type);
+        assertEquals(global.kind(), Declaration.Variable.Kind.BITFIELD);
+        assertEquals(global.layout().get().bitSize(), size);
+        return global;
+    }
+
+    public static void checkFunction(Declaration.Function function, Type ret, Type... params) {
+        assertTypeEquals(ret, function.type().returnType());
+        assertEquals(function.parameters().size(), params.length);
+        for (int i = 0 ; i < params.length ; i++) {
+            assertTypeEquals(params[i], function.type().argumentTypes().get(i));
+            Type paramType = function.parameters().get(i).type();
+            if (paramType instanceof Type.Array) {
+                assertTypeEquals(params[i], Type.pointer(((Type.Array) paramType).elementType()));
+            } else {
+                assertTypeEquals(params[i], function.parameters().get(i).type());
+            }
+        }
+    }
+
+    public static Declaration.Function checkFunction(Declaration.Scoped toplevel,String name , Type ret, Type... params) {
+        Declaration.Function function = findDecl(toplevel, name, Declaration.Function.class);
+        checkFunction(function, ret,params);
+        return function;
+    }
+
+    public static Declaration.Constant checkConstant(Declaration.Scoped toplevel, String name, Type type, Object value) {
+        Declaration.Constant constant = findDecl(toplevel, name, Declaration.Constant.class);
+        assertTypeEquals(type, constant.type());
+        assertEquals(value, constant.value());
+        return constant;
+    }
+
+    public static Predicate<Declaration> byName(final String name) {
+        return d -> d.name().equals(name);
+    }
+
+    public static Predicate<Declaration> byNameAndType(final String name, Class<? extends Declaration> declType) {
+        return d -> declType.isAssignableFrom(d.getClass()) && d.name().equals(name);
+    }
+
+    public static Optional<Declaration> findDecl(Declaration.Scoped toplevel, Predicate<Declaration> filter) {
+        return toplevel.members().stream().filter(filter).findAny();
+    }
+
+    @SuppressWarnings("unchecked")
+    public static <D extends Declaration> D findDecl(Declaration.Scoped toplevel, String name, Class<D> declType) {
+        Optional<Declaration> d = findDecl(toplevel, byNameAndType(name, declType));
+        if (d.isEmpty()) {
+            fail("No declaration with name " + name + " found in " + toplevel);
+            return null;
+        }
+        return (D) d.get();
+    }
+
+    public static void assertTypeEquals(Type expected, Type found) {
+        assertEquals(expected.getClass(), found.getClass());
+        if (expected instanceof Type.Primitive) {
+            assertEquals(((Type.Primitive)expected).kind(), ((Type.Primitive)found).kind());
+            assertEquals(((Type.Primitive)expected).layout(), ((Type.Primitive)found).layout());
+        } else if (expected instanceof Type.Delegated) {
+            assertEquals(((Type.Delegated)expected).kind(), ((Type.Delegated)found).kind());
+            assertTypeEquals(((Type.Delegated)expected).type(), ((Type.Delegated)found).type());
+        } else if (expected instanceof Type.Array) {
+            assertEquals(((Type.Array)expected).kind(), ((Type.Array)found).kind());
+            assertEquals(((Type.Array)expected).elementCount(), ((Type.Array)found).elementCount());
+            assertTypeEquals(((Type.Array)expected).elementType(), ((Type.Array)found).elementType());
+        } else if (expected instanceof Type.Declared) {
+            assertEquals(((Type.Declared)expected).tree(), ((Type.Declared)found).tree());
+        } else if (expected instanceof Type.Function) {
+            assertTypeEquals(((Type.Function)expected).returnType(), ((Type.Function)found).returnType());
+            assertEquals(((Type.Function)expected).argumentTypes().size(), ((Type.Function)found).argumentTypes().size());
+            assertEquals(((Type.Function)expected).varargs(), ((Type.Function)found).varargs());
+            for (int i = 0 ; i < ((Type.Function)expected).argumentTypes().size() ; i++) {
+                assertTypeEquals(((Type.Function)expected).argumentTypes().get(i), ((Type.Function)found).argumentTypes().get(i));
+            }
+        }
+    }
+}
diff a/test/jdk/java/jextract/SmokeTest.java b/test/jdk/java/jextract/SmokeTest.java
--- /dev/null
+++ b/test/jdk/java/jextract/SmokeTest.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng SmokeTest
+ */
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+
+public class SmokeTest extends JextractApiTestBase {
+
+    @Test
+    public void testParser() {
+        Declaration.Scoped d = parse("smoke.h");
+        Declaration.Scoped pointDecl = checkStruct(d, "Point", "x", "y");
+        Type intType = ((Declaration.Variable)pointDecl.members().get(0)).type();
+        checkGlobal(d, "p", Type.declared(pointDecl));
+        checkFunction(d, "distance", intType, Type.declared(pointDecl), Type.declared(pointDecl));
+        Declaration.Variable ch_ptr_ptr = findDecl(d, "ch_ptr_ptr", Declaration.Variable.class);
+        checkFunction(d, "pointers", ch_ptr_ptr.type(), ch_ptr_ptr.type(), ch_ptr_ptr.type());
+        checkConstant(d, "ZERO", intType, 0L);
+    }
+}
diff a/test/jdk/java/jextract/TEST.properties b/test/jdk/java/jextract/TEST.properties
--- /dev/null
+++ b/test/jdk/java/jextract/TEST.properties
@@ -0,0 +1,24 @@
+#
+# Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+modules = jdk.incubator.jextract
diff a/test/jdk/java/jextract/Test8238712.h b/test/jdk/java/jextract/Test8238712.h
--- /dev/null
+++ b/test/jdk/java/jextract/Test8238712.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+// Forward reference of struct to cause ConcurrentModificationException
+struct foo;
+
+// Declaration above is required, without it, the argument s cause
+// a C warning as struct foo only visible to the function.
+int withRecordTypeArg(int n, struct foo s);
+struct foo returnRecordType(void);
+
+// Improper header may write such with definition in other file
+struct bar returnBar(void);
+void withBar(struct bar s);
+
+struct bar *nextBar(struct bar *current);
+
+struct foo {
+    int n;
+    struct foo *ptr;
+};
diff a/test/jdk/java/jextract/Test8238712.java b/test/jdk/java/jextract/Test8238712.java
--- /dev/null
+++ b/test/jdk/java/jextract/Test8238712.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng Test8238712
+ */
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertTrue;
+
+public class Test8238712 extends JextractApiTestBase {
+    @Test
+    public void test8238712() {
+        Declaration.Scoped d = parse("Test8238712.h");
+        Declaration.Scoped structFoo = checkStruct(d, "foo", "n", "ptr");
+        Type intType = ((Declaration.Variable) structFoo.members().get(0)).type();
+        Type fooType = Type.declared(structFoo);
+        checkFunction(d, "withRecordTypeArg", intType, intType, fooType);
+        checkFunction(d, "returnRecordType", fooType);
+        // Opaque struct, have no field
+        Declaration.Scoped structBar = checkStruct(d, "bar");
+        assertTrue(structBar.layout().isEmpty());
+        Type barType = Type.declared(structBar);
+        // Function with opaque struct won't work but should have cursor for tool to handle
+        checkFunction(d, "returnBar", barType);
+        checkFunction(d, "withBar", Type.void_(), barType);
+        // Function use pointer to opaque struct should be OK
+        Type barPointer = Type.pointer(barType);
+        checkFunction(d, "nextBar", barPointer, barPointer);
+    }
+}
diff a/test/jdk/java/jextract/Test8239490.h b/test/jdk/java/jextract/Test8239490.h
--- /dev/null
+++ b/test/jdk/java/jextract/Test8239490.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+struct Foo {
+    unsigned int a:1;
+    unsigned int b:1;
+    unsigned int c:30;
+};
+
+struct Bar {
+    unsigned int x:1;
+    unsigned int y:31;
+    struct Foo z[1];
+};
diff a/test/jdk/java/jextract/Test8239490.java b/test/jdk/java/jextract/Test8239490.java
--- /dev/null
+++ b/test/jdk/java/jextract/Test8239490.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng Test8239490
+ */
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.*;
+
+public class Test8239490 extends JextractApiTestBase {
+    @Test
+    public void test8239490() {
+        Declaration.Scoped d = parse("Test8239490.h");
+        // check Foo
+        String[] fooBitfieldNames = { "a", "b", "c" };
+        int[] fooBitfieldSizes = { 1, 1, 30 };
+        Declaration.Scoped structFoo = checkStruct(d, "Foo", "");
+        Declaration.Scoped bitfieldsFoo = checkBitfields(structFoo, "", "a", "b", "c");
+        Type intType = ((Declaration.Variable)bitfieldsFoo.members().get(0)).type();
+        for (int i = 0 ; i < fooBitfieldNames.length ; i++) {
+            checkBitField(bitfieldsFoo, fooBitfieldNames[i], intType, fooBitfieldSizes[i]);
+        }
+        // check Bar
+        String[] barBitfieldNames = { "x", "y" };
+        int[] barBitfieldSizes = { 1, 31 };
+        Declaration.Scoped structBar = checkStruct(d, "Bar", "", "z");
+        Declaration.Scoped bitfieldsBar = checkBitfields(structBar, "", "x", "y");
+        for (int i = 0 ; i < barBitfieldNames.length ; i++) {
+            checkBitField(bitfieldsBar, barBitfieldNames[i], intType, barBitfieldSizes[i]);
+        }
+        checkField(structBar, "z", Type.array(1, Type.declared(structFoo)));
+    }
+}
diff a/test/jdk/java/jextract/Test8240372.h b/test/jdk/java/jextract/Test8240372.h
--- /dev/null
+++ b/test/jdk/java/jextract/Test8240372.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+typedef void CB(int);
+void func_cb(CB cb);
diff a/test/jdk/java/jextract/Test8240372.java b/test/jdk/java/jextract/Test8240372.java
--- /dev/null
+++ b/test/jdk/java/jextract/Test8240372.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng Test8240372
+ */
+
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+
+import static jdk.incubator.foreign.MemoryLayouts.C_INT;
+
+public class Test8240372 extends JextractApiTestBase {
+    @Test
+    public void test8239490() {
+        Declaration.Scoped d = parse("Test8240372.h");
+
+        Type funcType = Type.function(false, Type.void_(), Type.primitive(Type.Primitive.Kind.Int, C_INT));
+        Type typedefType = Type.typedef("CB", funcType);
+        checkFunction(d, "func_cb", Type.void_(), typedefType);
+    }
+}
diff a/test/jdk/java/jextract/Test8240853.h b/test/jdk/java/jextract/Test8240853.h
--- /dev/null
+++ b/test/jdk/java/jextract/Test8240853.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+union Foo {
+    int i;
+    long l;
+};
diff a/test/jdk/java/jextract/Test8240853.java b/test/jdk/java/jextract/Test8240853.java
--- /dev/null
+++ b/test/jdk/java/jextract/Test8240853.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng Test8239490
+ */
+
+import jdk.incubator.jextract.Declaration;
+import org.testng.annotations.Test;
+
+public class Test8240853 extends JextractApiTestBase {
+    @Test
+    public void test8240853() {
+        Declaration.Scoped d = parse("Test8240853.h");
+        // check Foo
+        checkUnion(d, "Foo", "i", "l");
+    }
+}
diff a/test/jdk/java/jextract/TestAttributes.java b/test/jdk/java/jextract/TestAttributes.java
--- /dev/null
+++ b/test/jdk/java/jextract/TestAttributes.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8239808
+ * @build JextractApiTestBase
+ * @run testng TestAttributes
+ */
+
+import java.lang.constant.Constable;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertTrue;
+
+public class TestAttributes extends JextractApiTestBase {
+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int, MemoryLayouts.C_INT);
+    private final static String ASMLABEL = "AsmLabelAttr";
+
+    private void validateAsmLabel(Declaration d, boolean isAdd) {
+        var attrs = d.getAttribute(ASMLABEL).get();
+        String value = isMacOSX ? "_" : "";
+        value += d.name();
+        value += isAdd ? "A" : "B";
+        assertEquals(attrs.get(0), value);
+    }
+
+    private void validateHeader(Declaration.Scoped top, boolean isAdd) {
+        if (isWindows) {
+            // TODO: add Windows validation
+            // Simply dump declaration for now
+            System.out.println(top);
+            return;
+        }
+        var list = top.members().stream()
+                .filter(byNameAndType("foo", Declaration.Variable.class))
+                .map(Declaration.Variable.class::cast)
+                .collect(Collectors.toList());
+        assertEquals(list.size(), 3);
+        int hasAttrs = 0;
+        for (Declaration.Variable foo: list) {
+            assertEquals(Declaration.Variable.Kind.GLOBAL, foo.kind());
+            assertTypeEquals(C_INT, foo.type());
+            if (foo.getAttribute(ASMLABEL).isPresent()) {
+                hasAttrs++;
+                validateAsmLabel(foo, isAdd);
+            }
+        }
+        assertEquals(hasAttrs, 2);
+        var listFunc = top.members().stream()
+                .filter(byNameAndType("func", Declaration.Function.class))
+                .map(Declaration.Function.class::cast)
+                .collect(Collectors.toList());
+        assertEquals(listFunc.size(), 3);
+        hasAttrs = 0;
+        for (Declaration.Function func: listFunc) {
+            checkFunction(func, C_INT, C_INT, C_INT);
+            if (func.getAttribute(ASMLABEL).isPresent()) {
+                hasAttrs++;
+                validateAsmLabel(func, isAdd);
+            }
+        }
+        assertEquals(hasAttrs, 2);
+    }
+
+    @Test
+    public void testA() {
+        Declaration.Scoped d = parse("libAsmSymbol.h", "-DADD");
+        validateHeader(d, true);
+    }
+
+    @Test
+    public void testB() {
+        Declaration.Scoped d = parse("libAsmSymbol.h");
+        validateHeader(d, false);
+    }
+
+    private static  Constable getSingleValue(Declaration d, String name) {
+        List<Constable> values = d.getAttribute(name).get();
+        assertEquals(1, values.size());
+        return values.get(0);
+    }
+
+    @Test
+    public void testAddAttribute() {
+        final String ts = "timestamp";
+        Declaration.Scoped d = parse("libAsmSymbol.h");
+        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);
+        Declaration withAttrs = d.withAttribute("header", d.name())
+                .withAttribute(ts, timestamp);
+
+        assertEquals(getSingleValue(withAttrs, "header"), d.name());
+        assertEquals(getSingleValue(withAttrs, ts), timestamp);
+
+        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
+        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);
+        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);
+
+        // Make sure original Declaration is not altered
+        assertEquals(getSingleValue(withAttrs, ts), timestamp);
+
+        // Add more value to same attribute
+        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(
+                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),
+                Stream.of(timestamp2)
+            ).toArray(Constable[]::new));
+        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));
+        assertEquals(getSingleValue(withNewAttrs,"header"), d.name());
+
+        // Remove attribute
+        withAttrs = withNewAttrs.withAttribute(ts);
+        assertTrue(withAttrs.getAttribute(ts).isEmpty());
+
+        // Strip attribute
+        withNewAttrs = withNewAttrs.stripAttributes();
+        assertTrue(withNewAttrs.attributeNames().isEmpty());
+    }
+
+    @Test
+    public void replaceFunctionSymbol() {
+        Declaration.Scoped d = parse("libAsmSymbol.h", "-DADD");
+        validateHeader(d, true);
+
+        var members = d.members().stream()
+            .map(m -> m.getAttribute(ASMLABEL)
+                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))
+                    .orElse(m))
+            .toArray(Declaration[]::new);
+        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);
+        validateHeader(patched, false);
+    }
+}
diff a/test/jdk/java/jextract/TestMacros.java b/test/jdk/java/jextract/TestMacros.java
--- /dev/null
+++ b/test/jdk/java/jextract/TestMacros.java
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8239128
+ * @build JextractApiTestBase
+ * @run testng TestMacros
+ */
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.BeforeClass;
+import org.testng.annotations.Test;
+
+public class TestMacros extends JextractApiTestBase {
+    Declaration.Scoped badMacro;
+    Declaration.Scoped foo;
+    Declaration.Scoped bar;
+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int, MemoryLayouts.C_INT);
+
+    @BeforeClass
+    public void parse() {
+        // We need stdint.h for pointer macro, otherwise evaluation failed and Constant declaration is not created
+        Path builtinInc = Paths.get(System.getProperty("java.home"), "conf", "jextract");
+        badMacro = parse("badMacros.h", "-I", builtinInc.toString());
+
+        foo = checkStruct(badMacro, "foo", "ptrFoo", "ptrBar");
+        bar = checkStruct(badMacro, "bar", "ptrFoo", "arFooPtr");
+    }
+
+    @Test
+    public void testBadMacros() {
+        checkConstant(badMacro, "INVALID_INT_CONSUMER",
+            Type.pointer(Type.function(false, Type.void_(), C_INT)),
+            0L);
+        // Record type in macro definition are erased to void
+        checkConstant(badMacro, "NO_FOO", Type.pointer(Type.void_()), 0L);
+        checkConstant(badMacro, "INVALID_INT_ARRAY_PTR", Type.pointer(Type.pointer(C_INT)), 0L);
+    }
+
+    @Test
+    public void verifyFunctions() {
+        checkFunction(badMacro, "func", Type.void_(),
+            Type.pointer(Type.declared(bar)), Type.pointer(Type.declared(foo)));
+        checkFunction(badMacro, "withArray", Type.void_(),
+            Type.pointer(Type.typedef("foo_t", Type.pointer(Type.declared(foo)))));
+    }
+
+    @Test
+    public void verifyGlobals() {
+        checkGlobal(badMacro, "op", Type.pointer(
+                Type.function(false, Type.void_(), C_INT, Type.pointer(C_INT))));
+    }
+
+    @Test
+    public void verifyFields() {
+        Type foo_t = Type.typedef("foo_t", Type.pointer(Type.declared(foo)));
+        checkField(foo, "ptrFoo", foo_t);
+        checkField(foo, "ptrBar", Type.pointer(Type.declared(bar)));
+        checkField(bar, "ptrFoo", foo_t);
+        checkField(bar, "arFooPtr", Type.pointer(foo_t));
+    }
+}
diff a/test/jdk/java/jextract/badMacros.h b/test/jdk/java/jextract/badMacros.h
--- /dev/null
+++ b/test/jdk/java/jextract/badMacros.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+// Macro of constant function pointer
+#define INVALID_INT_CONSUMER         (void (*)(int))0
+
+struct foo;
+typedef struct foo *foo_t;
+struct bar;
+
+// Macro of constant struct pointer
+#define NO_FOO ((foo_t)0)
+
+// Cases where resolving introduce new type references
+// Pointer to pointer in macro
+#define INVALID_INT_ARRAY_PTR (int**) 0
+// Function pointer with pointer type argument
+void (*op)(int cnt, int* operands);
+void func(struct bar *pBar, struct foo *pFoo);
+
+// Cyclic struct pointer within struct definitions
+struct foo {
+    foo_t ptrFoo;
+    struct bar *ptrBar;
+};
+
+struct bar {
+    foo_t ptrFoo;
+    foo_t *arFooPtr;
+};
+
+// Function with array to pointer
+void withArray(foo_t ar[2]);
diff a/test/jdk/java/jextract/libAsmSymbol.h b/test/jdk/java/jextract/libAsmSymbol.h
--- /dev/null
+++ b/test/jdk/java/jextract/libAsmSymbol.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef _WIN64
+  #ifdef IMPL
+    #define EXPORT __declspec(dllexport)
+  #else
+    #define EXPORT __declspec(dllimport)
+  #endif // IMPL
+#else
+#define EXPORT
+#endif //_WIN64
+
+#ifdef _WIN32
+// Windows doesn't really support asm symbol, this is similar approach for C code to
+// achieve similar, but this won't work with Panama until we support such Macro
+#ifdef ADD
+#define foo fooA
+#define func funcA
+#else
+#define foo fooB
+#define func funcB
+#endif //ADD
+#define ALIAS(sym)
+
+#elif __APPLE__
+#define ALIAS(sym) __asm("_" #sym)
+#else
+#define ALIAS(sym) __asm__(#sym)
+#endif // _WIN32
+
+// We do 3 declarations to make sure we will pick up alias no matter the sequence of encounter
+// Without alias
+EXPORT extern int foo;
+EXPORT int func (int x, int y);
+
+// With alias
+#ifdef ADD
+
+EXPORT extern int foo ALIAS(fooA);
+EXPORT int func (int x, int y) ALIAS(funcA);
+
+#else
+
+EXPORT extern int foo ALIAS(fooB);
+EXPORT int func (int x, int y) ALIAS(funcB);
+
+#endif // ADD
+
+// Without alias again
+EXPORT extern int foo;
+EXPORT int func (int x, int y);
+
diff a/test/jdk/java/jextract/smoke.h b/test/jdk/java/jextract/smoke.h
--- /dev/null
+++ b/test/jdk/java/jextract/smoke.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+//simple struct
+struct Point {
+    int x;
+    int y;
+};
+
+//global
+struct Point p;
+
+//function
+int distance(struct Point p1, struct Point p2);
+
+//function with arrays
+char ** ch_ptr_ptr;
+char** pointers(char* arr1[], char* arr2[]);
+
+//and a constant
+#define ZERO 0
diff a/test/jdk/tools/jextract/BadBitfieldTest.java b/test/jdk/tools/jextract/BadBitfieldTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/BadBitfieldTest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @requires os.family != "windows"
+ * @modules jdk.incubator.jextract
+ * @build BadBitfieldTest
+ * @run testng BadBitfieldTest
+ */
+
+/*
+ * Not running on Windows since MSVC will not cross storage unit boundaries.
+ * Resulting struct on SysV is 16 bytes, but 24 on MSx64
+ *
+ * MSVC: (/d1reportSingleClassLayoutFoo)
+ * class Foo    size(24):
+ *      +---
+ *  0.    | a (bitstart=0,nbits=45)
+ *  8.    | b (bitstart=0,nbits=24)
+ *  8.    | c (bitstart=24,nbits=1)
+ * 16.    | d (bitstart=0,nbits=58)
+ *      +---
+ *
+ * SysV: (PAHole)
+ * struct Foo {
+ *     long long int a:45;                0:19   8
+ *     long long int b:24;                0:251  8
+ *     XXX 251 bits hole, try to pack
+ *     long long int c:1;                 8:58   8
+ *     long long int d:58;                8: 0   8
+ *
+ *     size: 16, cachelines: 1, members: 4
+ *     bit holes: 1, sum bit holes: 251 bits
+ *     bit_padding: 5 bits
+ *     last cacheline: 16 bytes
+ * };
+ *
+ */
+
+import org.testng.annotations.Test;
+
+public class BadBitfieldTest extends JextractToolRunner {
+    @Test
+    public void testBadBitfield() {
+        run("-d", getOutputFilePath("badBitfieldsGen").toString(),
+                getInputFilePath("badBitfields.h").toString())
+            .checkFailure()
+            .checkContainsOutput("Crossing storage unit boundaries");
+    }
+}
diff a/test/jdk/tools/jextract/ConstantsTest.java b/test/jdk/tools/jextract/ConstantsTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/ConstantsTest.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.AfterTest;
+import org.testng.annotations.BeforeTest;
+import org.testng.annotations.DataProvider;
+import org.testng.annotations.Test;
+import java.nio.file.Path;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.SystemABI.Type;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build ConstantsTest
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit ConstantsTest
+ */
+public class ConstantsTest extends JextractToolRunner {
+    private Class<?> constants;
+    private Path dirPath;
+    private Loader loader;
+
+    @BeforeTest
+    public void setup() {
+        dirPath = getOutputFilePath("ConstantsTest_output");
+        run( "-d", dirPath.toString(), getInputFilePath("constants.h").toString()).checkSuccess();
+        loader = classLoader(dirPath);
+        constants = loader.loadClass("constants_h");
+    }
+
+    @AfterTest
+    public void cleanup() {
+        constants = null;
+        loader.close();
+        deleteDir(dirPath);
+    }
+
+
+    @Test(dataProvider = "definedConstants")
+    public void checkConstantsSignatures(String name, Class<?> type, Object value) {
+        var f = findField(constants, name);
+        assertNotNull(f);
+        assertTrue(f.getType() == type);
+    }
+
+    @Test(dataProvider = "definedConstants")
+    public void checkConstantsValues(String name, Class<?> type, Predicate<Object> checker) throws ReflectiveOperationException {
+        Object actual = findField(constants, name).get(null);
+        assertTrue(checker.test(actual));
+    }
+
+    @Test(dataProvider = "missingConstants")
+    public void checkMissingConstants(String name) {
+        assertTrue(Stream.of(constants.getDeclaredFields())
+                .noneMatch(m -> m.getName().equals(name)));
+    }
+
+    @DataProvider
+    public static Object[][] definedConstants() {
+        return new Object[][] {
+                { "SUP", int.class, equalsTo(5) },
+                { "ZERO", int.class, equalsTo(0) },
+                { "ONE", int.class, equalsTo(1) },
+                { "TWO", int.class, equalsTo(2) },
+                { "THREE", int.class, equalsTo(3) },
+                { "FOUR", long.class, equalsTo(4L) },
+                { "FIVE", long.class, equalsTo(5L) },
+                { "SIX", int.class, equalsTo(6) },
+                { "FLOAT_VALUE", float.class, equalsTo(1.32f) },
+                { "DOUBLE_VALUE", double.class, equalsTo(1.32) },
+                { "CHAR_VALUE", int.class, equalsTo(104) }, //integer char constants have type int
+                { "MULTICHAR_VALUE", int.class, equalsTo(26728) },  //integer char constants have type int
+                { "BOOL_VALUE", byte.class, equalsTo((byte)1) },
+                { "SUB", int.class, equalsTo( 7 ) }
+        };
+    }
+
+    static Predicate<Object> equalsTo(Object that) {
+        return o -> o.equals(that);
+    }
+
+    @DataProvider
+    public static Object[][] missingConstants() {
+        return new Object[][] {
+                { "ID" },
+                { "SUM" },
+                { "BLOCK_BEGIN" },
+                { "BLOCK_END" },
+                { "INTEGER_MAX_VALUE" },
+                { "CYCLIC_1" },
+                { "CYCLIC_2" },
+                { "UNUSED" },
+                // pointer type values
+                { "STR" },
+                { "QUOTE" },
+                { "ZERO_PTR" },
+                { "F_PTR" }
+        };
+    }
+}
diff a/test/jdk/tools/jextract/JextractToolProviderTest.java b/test/jdk/tools/jextract/JextractToolProviderTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/JextractToolProviderTest.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import jdk.incubator.foreign.MemoryAddress;
+
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertFalse;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @bug 8240181
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit -Duser.language=en --add-modules jdk.incubator.jextract JextractToolProviderTest
+ */
+public class JextractToolProviderTest extends JextractToolRunner {
+    @Test
+    public void testHelp() {
+        run().checkFailure(); // no options
+        run("--help").checkSuccess();
+        run("-h").checkSuccess();
+        run("-?").checkSuccess();
+    }
+
+    // error for non-existent header file
+    @Test
+    public void testNonExistentHeader() {
+        run(getInputFilePath("non_existent.h").toString())
+            .checkFailure()
+            .checkContainsOutput("cannot read header file");
+    }
+
+    @Test
+    public void testOutputClass() {
+        Path helloOutput = getOutputFilePath("hellogen");
+        Path helloH = getInputFilePath("hello.h");
+        run("-d", helloOutput.toString(), helloH.toString()).checkSuccess();
+        try(Loader loader = classLoader(helloOutput)) {
+            Class<?> cls = loader.loadClass("hello_h");
+            // check a method for "void func(int)"
+            assertNotNull(findMethod(cls, "func", int.class));
+            // check a method for "int printf(MemoryAddress, Object[])"
+            assertNotNull(findMethod(cls, "printf", MemoryAddress.class, Object[].class));
+        } finally {
+            deleteDir(helloOutput);
+        }
+    }
+
+    private void testTargetPackage(String targetPkgOption) {
+        Path helloOutput = getOutputFilePath("hellogen");
+        Path helloH = getInputFilePath("hello.h");
+        run(targetPkgOption, "com.acme", "-d",
+            helloOutput.toString(), helloH.toString()).checkSuccess();
+        try(Loader loader = classLoader(helloOutput)) {
+            Class<?> cls = loader.loadClass("com.acme.hello_h");
+            // check a method for "void func(int)"
+            assertNotNull(findMethod(cls, "func", int.class));
+            // check a method for "int printf(MemoryAddress, Object[])"
+            assertNotNull(findMethod(cls, "printf", MemoryAddress.class, Object[].class));
+        } finally {
+            deleteDir(helloOutput);
+        }
+    }
+
+    @Test
+    public void testTargetPackageOption() {
+        testTargetPackage("-t");
+    }
+
+    @Test
+    public void testTargetPackageLongOption() {
+        testTargetPackage("--target-package");
+    }
+}
diff a/test/jdk/tools/jextract/JextractToolRunner.java b/test/jdk/tools/jextract/JextractToolRunner.java
--- /dev/null
+++ b/test/jdk/tools/jextract/JextractToolRunner.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.Objects;
+import java.util.spi.ToolProvider;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.SystemABI.Type;
+
+import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
+
+public class JextractToolRunner {
+    private static String safeFileName(String filename) {
+        int ext = filename.lastIndexOf('.');
+        return ext != -1 ? filename.substring(0, ext) : filename;
+    }
+
+    private static final ToolProvider JEXTRACT_TOOL = ToolProvider.findFirst("jextract")
+            .orElseThrow(() ->
+                    new RuntimeException("jextract tool not found")
+            );
+
+    private final Path inputDir;
+    private final Path outputDir;
+
+    protected JextractToolRunner() {
+        this(null, null);
+    }
+
+    protected JextractToolRunner(Path input, Path output) {
+        inputDir = (input != null) ? input :
+                Paths.get(System.getProperty("test.src", "."));
+        outputDir = (output != null) ? output :
+                Paths.get(System.getProperty("test.classes", "."));
+    }
+
+    protected Path getInputFilePath(String fileName) {
+        return inputDir.resolve(fileName).toAbsolutePath();
+    }
+
+    protected Path getOutputFilePath(String fileName) {
+        return outputDir.resolve(fileName).toAbsolutePath();
+    }
+
+    protected static class JextractResult {
+        private int exitCode;
+        private String output;
+
+        JextractResult(int exitCode, String output) {
+            this.exitCode = exitCode;
+            this.output = output;
+        }
+
+        protected JextractResult checkSuccess() {
+            assertEquals(exitCode, 0, "Sucess excepted, failed: " + exitCode);
+            return this;
+        }
+
+        protected JextractResult checkFailure() {
+            assertNotEquals(exitCode, 0, "Failure excepted, succeeded!");
+            return this;
+        }
+
+        protected JextractResult checkContainsOutput(String expected) {
+            Objects.requireNonNull(expected);
+            assertTrue(output.contains(expected), "Output does not contain string: " + expected);
+            return this;
+        }
+
+        protected JextractResult checkMatchesOutput(String regex) {
+            Objects.requireNonNull(regex);
+            assertTrue(output.trim().matches(regex), "Output does not match regex: " + regex);
+            return this;
+        }
+    }
+
+    protected static JextractResult run(String... options) {
+        StringWriter writer = new StringWriter();
+        PrintWriter pw = new PrintWriter(writer);
+        String[] args = new String[options.length + 1];
+        int result = JEXTRACT_TOOL.run(pw, pw, options);
+        String output = writer.toString();
+        System.err.println(output);
+        return new JextractResult(result, output);
+    }
+
+    protected static void deleteFile(Path path) {
+        try {
+            Files.deleteIfExists(path);
+        } catch (IOException ioExp) {
+            throw new RuntimeException(ioExp);
+        }
+    }
+
+    protected static void deleteDir(Path path) {
+        try {
+            Files.walkFileTree(path, new SimpleFileVisitor<>() {
+                @Override
+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
+                    deleteFile(file);
+                    return FileVisitResult.CONTINUE;
+                }
+
+                @Override
+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
+                    deleteFile(dir);
+                    return FileVisitResult.CONTINUE;
+                }
+            });
+        } catch (IOException ioExp) {
+            throw new RuntimeException(ioExp);
+        }
+    }
+
+    protected static Loader classLoader(Path... paths) {
+        try {
+            URL[] urls = new URL[paths.length];
+            for (int i = 0; i < paths.length; i++) {
+                urls[i] = paths[i].toUri().toURL();
+            }
+            URLClassLoader ucl = new URLClassLoader(urls, null);
+            return new Loader(ucl);
+        } catch (RuntimeException re) {
+            throw re;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    protected static Field findField(Class<?> cls, String name) {
+        try {
+            return cls.getField(name);
+        } catch (Exception e) {
+            System.err.println(e);
+            return null;
+        }
+    }
+
+    protected Field checkIntField(Class<?> cls, String name, int value) {
+        Field field = findField(cls, name);
+        assertNotNull(field);
+        assertEquals(field.getType(), int.class);
+        try {
+            assertEquals((int)field.get(null), value);
+        } catch (Exception exp) {
+            System.err.println(exp);
+            assertTrue(false, "should not reach here");
+        }
+        return field;
+    }
+
+    protected static Method findMethod(Class<?> cls, String name, Class<?>... argTypes) {
+        try {
+            return cls.getMethod(name, argTypes);
+        } catch (Exception e) {
+            System.err.println(e);
+            return null;
+        }
+    }
+
+    protected static Method findFirstMethod(Class<?> cls, String name) {
+        try {
+            for (Method m : cls.getMethods()) {
+                if (name.equals(m.getName())) {
+                    return m;
+                }
+            }
+            return null;
+        } catch (Exception e) {
+            System.err.println(e);
+            return null;
+        }
+    }
+
+    protected Class<?> findClass(Class<?>[] clz, String name) {
+        for (Class<?> cls: clz) {
+            if (cls.getSimpleName().equals(name)) {
+                return cls;
+            }
+        }
+        return null;
+    }
+
+    protected Method checkMethod(Class<?> cls, String name, Class<?> returnType, Class<?>... args) {
+        try {
+            Method m = cls.getDeclaredMethod(name, args);
+            assertTrue(m.getReturnType() == returnType);
+            return m;
+        } catch (NoSuchMethodException nsme) {
+            fail("Expect method " + name);
+        }
+        return null;
+    }
+
+    protected MemoryLayout findLayout(Class<?> cls, String name) {
+        Field field = findField(cls, name + "$LAYOUT");
+        assertNotNull(field);
+        assertEquals(field.getType(), MemoryLayout.class);
+        try {
+            return (MemoryLayout)field.get(null);
+        } catch (Exception exp) {
+            System.err.println(exp);
+            assertTrue(false, "should not reach here");
+        }
+        return null;
+    }
+
+    protected static void checkFieldABIType(MemoryLayout layout, String fieldName, Type expected) {
+        assertEquals(layout.select(PathElement.groupElement(fieldName)).attribute(NATIVE_TYPE)
+                                                                       .map(SystemABI.Type.class::cast)
+                                                                       .orElseThrow(), expected);
+    }
+
+    protected static class Loader implements AutoCloseable {
+
+        private final URLClassLoader loader;
+
+        public Loader(URLClassLoader loader) {
+            this.loader = loader;
+        }
+
+        public Class<?> loadClass(String className) {
+            try {
+                return Class.forName(className, false, loader);
+            } catch (ClassNotFoundException e) {
+                // return null so caller can check if class loading
+                // was successful with assertNotNull/assertNull
+                return null;
+            }
+        }
+
+        @Override
+        public void close() {
+            try {
+                loader.close();
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+}
diff a/test/jdk/tools/jextract/JtregJextract.java b/test/jdk/tools/jextract/JtregJextract.java
--- /dev/null
+++ b/test/jdk/tools/jextract/JtregJextract.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class JtregJextract {
+    private final Path inputDir;
+    private final Path outputDir;
+
+    JtregJextract() {
+        this(null, null);
+    }
+
+    JtregJextract(Path input, Path output) {
+        inputDir = (input != null) ? input :
+                Paths.get(System.getProperty("test.src", "."));
+        outputDir = (output != null) ? output :
+                Paths.get(System.getProperty("test.classes", "."));
+
+    }
+
+    protected String[] processArgs(String... args) {
+        Pattern sysPropPattern = Pattern.compile("'?\\$\\((.*)\\)'?");
+        ArrayList<String> jextrOpts = new ArrayList<>();
+
+        jextrOpts.clear();
+        jextrOpts.add("-C-nostdinc");
+        jextrOpts.add("-I");
+        jextrOpts.add(inputDir.toAbsolutePath().toString());
+        jextrOpts.add("-d");
+        jextrOpts.add(outputDir.toAbsolutePath().toString());
+
+        int i = 0;
+        while (i < args.length) {
+            String opt = args[i++];
+            if ("--".equals(opt)) {
+                break;
+            }
+
+            if ("-d".equals(opt)) {
+                i++;
+                continue;
+            }
+            // Pattern $(system.property.name) is replaced with the
+            // value of the System property of that name.
+            Matcher m = sysPropPattern.matcher(opt);
+            if (m.matches()) {
+                jextrOpts.add(System.getProperty(m.group(1)));
+            } else {
+                jextrOpts.add(opt);
+            }
+        }
+
+        while (i < args.length) {
+            jextrOpts.add(getInputFilePath(args[i++]).toString());
+        }
+
+        return jextrOpts.toArray(String[]::new);
+    }
+
+    protected int jextract(String... options) {
+        String[] args = processArgs(options);
+        String[] commands = new String[args.length + 1];
+        commands[0] = Paths.get(System.getProperty("test.jdk"), "bin", "jextract").toString();
+        System.arraycopy(args, 0, commands, 1, args.length);
+        try {
+            Process proc = new ProcessBuilder(commands).inheritIO().start();
+            int result = proc.waitFor();
+            if (result != 0) {
+                throw new RuntimeException("jextract returns non-zero value");
+            }
+            return result;
+        } catch (IOException ioExp) {
+            throw new UncheckedIOException(ioExp);
+        } catch (InterruptedException intExp) {
+            throw new RuntimeException(intExp);
+        }
+    }
+
+    private Path getInputFilePath(String filename) {
+        return inputDir.resolve(filename).toAbsolutePath();
+    }
+
+    public static int main(String[] args) {
+        JtregJextract jj =  new JtregJextract();
+        return jj.jextract(args);
+    }
+}
diff a/test/jdk/tools/jextract/RepeatedDeclsTest.java b/test/jdk/tools/jextract/RepeatedDeclsTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/RepeatedDeclsTest.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+
+import java.lang.reflect.Method;
+import java.nio.file.Path;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.MemorySegment;
+import jdk.incubator.foreign.SystemABI.Type;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @bug 8240300
+ * @summary jextract produces non compilable code with repeated declarations
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit RepeatedDeclsTest
+ */
+public class RepeatedDeclsTest extends JextractToolRunner {
+    @Test
+    public void repeatedDecls() {
+        Path repeatedDeclsOutput = getOutputFilePath("repeatedDeclsgen");
+        Path repeatedDeclsH = getInputFilePath("repeatedDecls.h");
+        run("-d", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();
+        try(Loader loader = classLoader(repeatedDeclsOutput)) {
+            Class<?> cls = loader.loadClass("repeatedDecls_h");
+            // check a method for "void func(int)"
+            assertNotNull(findMethod(cls, "func", int.class));
+
+            // check a method for "void func2(int)"
+            assertNotNull(findMethod(cls, "func2", int.class));
+
+            // check a method for "void func3(int*)"
+            assertNotNull(findMethod(cls, "func3", MemoryAddress.class));
+
+            // check a method for "void func4(int*)"
+            assertNotNull(findMethod(cls, "func4", MemoryAddress.class));
+
+            // check a method for "void func5(int)"
+            assertNotNull(findMethod(cls, "func5", int.class));
+
+            // check a method for "double distance(struct Point)"
+            assertNotNull(findMethod(cls, "distance", MemorySegment.class));
+
+            // check a getter method for "i"
+            assertNotNull(findMethod(cls, "i$get"));
+
+            // check a setter method for "i"
+            assertNotNull(findMethod(cls, "i$set", int.class));
+
+            // make sure that enum constants are generated fine
+            checkIntField(cls, "R", 0);
+            checkIntField(cls, "G", 1);
+            checkIntField(cls, "B", 2);
+            checkIntField(cls, "C", 0);
+            checkIntField(cls, "M", 1);
+            checkIntField(cls, "Y", 2);
+
+            // check Point layout
+            MemoryLayout pointLayout = findLayout(cls, "Point");
+            assertNotNull(pointLayout);
+            assertTrue(((GroupLayout)pointLayout).isStruct());
+            checkFieldABIType(pointLayout, "i",  Type.INT);
+            checkFieldABIType(pointLayout, "j",  Type.INT);
+
+            // check Point3D layout
+            MemoryLayout point3DLayout = findLayout(cls, "Point3D");
+            assertNotNull(point3DLayout);
+            assertTrue(((GroupLayout)point3DLayout).isStruct());
+            checkFieldABIType(point3DLayout, "i",  Type.INT);
+            checkFieldABIType(point3DLayout, "j",  Type.INT);
+            checkFieldABIType(point3DLayout, "k",  Type.INT);
+        } finally {
+            deleteDir(repeatedDeclsOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/Test8240181.java b/test/jdk/tools/jextract/Test8240181.java
--- /dev/null
+++ b/test/jdk/tools/jextract/Test8240181.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.nio.file.Path;
+import org.testng.annotations.Test;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @bug 8240181
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit -Duser.language=en --add-modules jdk.incubator.jextract Test8240181
+ */
+public class Test8240181 extends JextractToolRunner {
+    @Test
+    public void testAnonymousEnum() {
+        Path anonenumOutput = getOutputFilePath("anonenumgen");
+        Path anonenumH = getInputFilePath("anonenum.h");
+        run("-d", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();
+        try(Loader loader = classLoader(anonenumOutput)) {
+            Class<?> cls = loader.loadClass("anonenum_h");
+            checkIntField(cls, "RED", 0xff0000);
+            checkIntField(cls, "GREEN", 0x00ff00);
+            checkIntField(cls, "BLUE", 0x0000ff);
+            checkIntField(cls, "Java", 0);
+            checkIntField(cls, "C", 1);
+            checkIntField(cls, "CPP", 2);
+            checkIntField(cls, "Python", 3);
+            checkIntField(cls, "Ruby", 4);
+            checkIntField(cls, "ONE", 1);
+            checkIntField(cls, "TWO", 2);
+        } finally {
+            deleteDir(anonenumOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/Test8240657.java b/test/jdk/tools/jextract/Test8240657.java
--- /dev/null
+++ b/test/jdk/tools/jextract/Test8240657.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.nio.file.Path;
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertNotNull;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @bug 8240657
+ * @summary when Java keywords are used as identifiers in C header, jextract generates non-compilable java code
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit Test8240657
+ */
+public class Test8240657 extends JextractToolRunner {
+    @Test
+    public void testKeywordIdentifiers() {
+        Path exportsOutput = getOutputFilePath("exportsgen");
+        Path exportsH = getInputFilePath("exports.h");
+        run("-d", exportsOutput.toString(), exportsH.toString()).checkSuccess();
+        try(Loader loader = classLoader(exportsOutput)) {
+            Class<?> cls = loader.loadClass("exports_h");
+            assertNotNull(cls);
+        } finally {
+            deleteDir(exportsOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/Test8240752.java b/test/jdk/tools/jextract/Test8240752.java
--- /dev/null
+++ b/test/jdk/tools/jextract/Test8240752.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.lang.reflect.Field;
+import java.nio.file.Path;
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @bug 8240752
+ * @summary jextract generates non-compilable code for special floating point values
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit Test8240752
+ */
+public class Test8240752 extends JextractToolRunner {
+    private float getFloatConstant(Class<?> cls, String name) {
+        Field field = findField(cls, name);
+        assertNotNull(field);
+        assertEquals(field.getType(), float.class);
+        try {
+            return (float)field.get(null);
+        } catch (Exception exp) {
+            System.err.println(exp);
+            assertTrue(false, "should not reach here");
+        }
+        return 0.0f;
+    }
+
+    private double getDoubleConstant(Class<?> cls, String name) {
+        Field field = findField(cls, name);
+        assertNotNull(field);
+        assertEquals(field.getType(), double.class);
+        try {
+            return (double)field.get(null);
+        } catch (Exception exp) {
+            System.err.println(exp);
+            assertTrue(false, "should not reach here");
+        }
+        return 0.0d;
+    }
+
+    @Test
+    public void testConstants() {
+        Path floatConstsOutput = getOutputFilePath("floatconstsgen");
+        Path floatConstsH = getInputFilePath("float_constants.h");
+        run("-d", floatConstsOutput.toString(), floatConstsH.toString()).checkSuccess();
+        try(Loader loader = classLoader(floatConstsOutput)) {
+            Class<?> cls = loader.loadClass("float_constants_h");
+            assertNotNull(cls);
+
+            double d = getDoubleConstant(cls, "NAN");
+            assertTrue(Double.isNaN(d));
+            d = getDoubleConstant(cls, "PINFINITY");
+            assertTrue(Double.isInfinite(d) && d > 0);
+            d = getDoubleConstant(cls, "NINFINITY");
+            assertTrue(Double.isInfinite(d) && d < 0);
+
+            float f = getFloatConstant(cls, "NANF");
+            assertTrue(Float.isNaN(f));
+            f = getFloatConstant(cls, "PINFINITYF");
+            assertTrue(Float.isInfinite(f) && f > 0);
+            f = getFloatConstant(cls, "NINFINITYF");
+            assertTrue(Float.isInfinite(f) && f < 0);
+        } finally {
+            deleteDir(floatConstsOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/Test8240811.java b/test/jdk/tools/jextract/Test8240811.java
--- /dev/null
+++ b/test/jdk/tools/jextract/Test8240811.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.nio.file.Path;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryLayout;
+import jdk.incubator.foreign.SystemABI.Type;
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @bug 8240811
+ * @summary jextract generates non-compilable code for name collision between a struct and a global variable
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit Test8240811
+ */
+public class Test8240811 extends JextractToolRunner {
+    @Test
+    public void testNameCollision() {
+        Path nameCollisionOutput = getOutputFilePath("name_collision_gen");
+        Path nameCollisionH = getInputFilePath("name_collision.h");
+        run("-d", nameCollisionOutput.toString(), nameCollisionH.toString()).checkSuccess();
+        try(Loader loader = classLoader(nameCollisionOutput)) {
+            Class<?> cls = loader.loadClass("name_collision_h");
+            assertNotNull(cls);
+
+            // check foo layout
+            MemoryLayout fooLayout = findLayout(cls, "foo");
+            assertNotNull(fooLayout);
+            assertTrue(((GroupLayout)fooLayout).isStruct());
+            checkFieldABIType(fooLayout, "x",  Type.INT);
+            checkFieldABIType(fooLayout, "y",  Type.INT);
+            checkFieldABIType(fooLayout, "z",  Type.INT);
+
+            MemoryLayout fooVarLayout = findLayout(cls, "var$foo");
+            assertNotNull(fooVarLayout);
+
+            // check foo2 layout
+            MemoryLayout foo2Layout = findLayout(cls, "foo2");
+            assertNotNull(foo2Layout);
+            assertTrue(((GroupLayout)foo2Layout).isUnion());
+            checkFieldABIType(foo2Layout, "i",  Type.INT);
+            checkFieldABIType(foo2Layout, "l",  Type.LONG);
+
+            MemoryLayout foo2VarLayout = findLayout(cls, "var$foo2");
+            assertNotNull(foo2VarLayout);
+
+            MemoryLayout barVarLayout = findLayout(cls, "bar");
+            assertNotNull(barVarLayout);
+
+            // check bar layout
+            MemoryLayout barLayout = findLayout(cls, "struct$bar");
+            assertNotNull(barLayout);
+            assertTrue(((GroupLayout)barLayout).isStruct());
+            checkFieldABIType(barLayout, "f1",  Type.FLOAT);
+            checkFieldABIType(barLayout, "f2",  Type.FLOAT);
+
+            MemoryLayout bar2VarLayout = findLayout(cls, "bar2");
+            assertNotNull(bar2VarLayout);
+
+            // check bar layout
+            MemoryLayout bar2Layout = findLayout(cls, "union$bar2");
+            assertNotNull(bar2Layout);
+            assertTrue(((GroupLayout)bar2Layout).isUnion());
+            checkFieldABIType(bar2Layout, "f",  Type.FLOAT);
+            checkFieldABIType(bar2Layout, "d",  Type.DOUBLE);
+        } finally {
+            deleteDir(nameCollisionOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/Test8241650.java b/test/jdk/tools/jextract/Test8241650.java
--- /dev/null
+++ b/test/jdk/tools/jextract/Test8241650.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import jdk.incubator.jextract.Declaration;
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @bug 8241650
+ * @summary jextract module should be mapped to application class loader
+ * @run testng Test8241650
+ */
+public class Test8241650 {
+    @Test
+    public void testClassLoader() {
+        assertTrue(ClassLoader.getSystemClassLoader() == Declaration.class.getClassLoader());
+    }
+}
diff a/test/jdk/tools/jextract/UniondeclTest.java b/test/jdk/tools/jextract/UniondeclTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/UniondeclTest.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+import java.nio.file.Path;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.MemoryAddress;
+import jdk.incubator.foreign.SystemABI.Type;
+import static org.testng.Assert.assertNotNull;
+import static org.testng.Assert.assertTrue;
+
+/*
+ * @test
+ * @modules jdk.incubator.jextract
+ * @build JextractToolRunner
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit UniondeclTest
+ */
+public class UniondeclTest extends JextractToolRunner {
+    @Test
+    public void unionDecl() {
+        Path uniondeclOutput = getOutputFilePath("uniondecl.h");
+        Path uniondeclH = getInputFilePath("uniondecl.h");
+        run("-d", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();
+        try(Loader loader = classLoader(uniondeclOutput)) {
+            Class<?> cls = loader.loadClass("uniondecl_h");
+            // check a method for "void func(IntOrFloat*)"
+            assertNotNull(findMethod(cls, "func", MemoryAddress.class));
+            // check Point layout
+            GroupLayout intOrFloatLayout = (GroupLayout)findLayout(cls, "IntOrFloat");
+            assertNotNull(intOrFloatLayout);
+            assertTrue(intOrFloatLayout.isUnion());
+            checkFieldABIType(intOrFloatLayout, "i",  Type.INT);
+            checkFieldABIType(intOrFloatLayout, "f",  Type.FLOAT);
+        } finally {
+            deleteDir(uniondeclOutput);
+        }
+    }
+}
diff a/test/jdk/tools/jextract/anonenum.h b/test/jdk/tools/jextract/anonenum.h
--- /dev/null
+++ b/test/jdk/tools/jextract/anonenum.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+enum {
+    RED = 0xff0000,
+    GREEN = 0x00ff00,
+    BLUE = 0x0000ff
+};
+
+typedef enum {
+   Java,
+   C,
+   CPP,
+   Python,
+   Ruby
+} codetype_t;
+
+enum SIZE {
+   XS,
+   S,
+   M,
+   L,
+   XL,
+   XXL
+};
+
+typedef enum temp {
+   ONE = 1,
+   TWO
+} temp_t;
diff a/test/jdk/tools/jextract/badBitfields.h b/test/jdk/tools/jextract/badBitfields.h
--- /dev/null
+++ b/test/jdk/tools/jextract/badBitfields.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#pragma pack(1)
+struct Foo {
+    long  a         : 45;
+    long  b         : 24;
+    long  c         : 1;
+    long  d         : 58;
+};
diff a/test/jdk/tools/jextract/constants.h b/test/jdk/tools/jextract/constants.h
--- /dev/null
+++ b/test/jdk/tools/jextract/constants.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "constants_aux.h"
+
+#define ZERO 0
+#define ONE ZERO + 1 //backward ref
+#define THREE ONE + TWO /* forward ref */
+#define TWO ONE + ONE
+
+#define FOUR (long long)0x1L + THREE //hack: force long carrier
+#define FIVE (long long)0x1UL + FOUR //hack: force long carrier
+
+#define SIX ONE +\
+              TWO +\
+              THREE
+
+#define STR "Hello" // a string
+
+#define ID(x) x //function-like
+#define SUM(x,y) x + y //function-like
+
+#define BLOCK_BEGIN { //not a constant
+#define BLOCK_END } //not a constant
+
+#define INTEGER_MAX_VALUE Integer.MAX_VALUE //constant in Java, not in C
+#define QUOTE "QUOTE" //should be ok
+
+#define FLOAT_VALUE 1.32F;
+#define DOUBLE_VALUE 1.32;
+
+#define CYCLIC_1 1 + CYCLIC_1 //cycle
+
+#define CYCLIC_2 1 + TEMP //indirect cycle
+#define TEMP 1 + CYCLIC_2
+
+#define CHAR_VALUE 'h'
+#define MULTICHAR_VALUE 'hh'
+
+#define BOOL_VALUE (_Bool)1
+//we should have tests for char and shorts, but these are likely to be platform dependent
+
+#define SUB SUP + 2 //dependency
+
+#define ZERO_PTR (void*)0;
+#define F_PTR (void*) 0xFFFFFFFFFFFFFFFFLL; // all 1s
diff a/test/jdk/tools/jextract/constants_aux.h b/test/jdk/tools/jextract/constants_aux.h
--- /dev/null
+++ b/test/jdk/tools/jextract/constants_aux.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#define SUP 5 //this is used by the main test header file
+
+#define UNUSED "unused" //this should not be used
diff a/test/jdk/tools/jextract/exports.h b/test/jdk/tools/jextract/exports.h
--- /dev/null
+++ b/test/jdk/tools/jextract/exports.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+void foo(int boolean);
+
+int finally;
+
+struct abstract {
+    short is;
+    short throws;
+} abstract;
+
+typedef char Byte;
+void func(Byte byte, Byte* out);
+
+#define byte 1
+#define content byte + 1
+
+typedef struct {
+    short s1;
+    short s2;
+} Long;
+
+long twoShorts(Long s, Long* out, long* rv);
diff a/test/jdk/tools/jextract/float_constants.h b/test/jdk/tools/jextract/float_constants.h
--- /dev/null
+++ b/test/jdk/tools/jextract/float_constants.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#define NANF (0.0f/0.0f)
+#define PINFINITYF (1.0f/0.0f)
+#define NINFINITYF (-1.0f/0.0f)
+
+#define NAN (0.0/0.0)
+#define PINFINITY (1.0/0.0)
+#define NINFINITY (-1.0/0.0)
diff a/test/jdk/tools/jextract/hello.h b/test/jdk/tools/jextract/hello.h
--- /dev/null
+++ b/test/jdk/tools/jextract/hello.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* make sure compiler built-in headers can be included */
+#include <stddef.h>
+
+void func(int);
+int printf(char* fmt, ...);
+void f();
diff a/test/jdk/tools/jextract/name_collision.h b/test/jdk/tools/jextract/name_collision.h
--- /dev/null
+++ b/test/jdk/tools/jextract/name_collision.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+struct foo {
+  int x;
+  int y;
+  int z;
+};
+
+// variable name clashing with struct name declared earlier
+long foo;
+
+union foo2 {
+   int i;
+   long l;
+};
+
+// variable name clashing with union name declared earlier
+char foo2;
+
+int bar;
+
+// struct name clashing with variable name declared earlier
+struct bar {
+   float f1;
+   float f2;
+};
+
+int bar2;
+
+// union name clashing with variable name declared earlier
+union bar2 {
+   float f;
+   double d;
+};
diff a/test/jdk/tools/jextract/repeatedDecls.h b/test/jdk/tools/jextract/repeatedDecls.h
--- /dev/null
+++ b/test/jdk/tools/jextract/repeatedDecls.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+struct Point;
+struct Point;
+
+int i;
+int i;
+
+void func(int);
+void func(int abc);
+void func(int xyz);
+void func2(int);
+void func2(int abc);
+void func2(int xyz);
+
+typedef int INT;
+void func(INT);
+void func(INT abc);
+void func(INT xyz);
+void func2(INT);
+void func2(INT abc);
+void func2(INT xyz);
+
+typedef int* INTPTR;
+void func3(INTPTR x);
+void func3(int* x);
+void func4(INTPTR x);
+void func4(int* x);
+
+typedef int Integer;
+void func(Integer x);
+void func5(int x);
+void func5(Integer x);
+void func5(INT x);
+
+struct Point;
+struct Point {
+   int i;
+   int j;
+};
+
+typedef struct Point POINT;
+double distance(struct Point p);
+double distance(POINT p);
+
+struct Point3D {
+    int i;
+    int j;
+    int k;
+};
+struct Point3D;
+
+enum RGBColor;
+enum RGBColor {
+   R, G, B
+};
+
+enum CMYColor {
+  C, M, Y
+};
+enum CMYColor;
diff a/test/jdk/tools/jextract/test8239918/LibTest8239918Test.java b/test/jdk/tools/jextract/test8239918/LibTest8239918Test.java
--- /dev/null
+++ b/test/jdk/tools/jextract/test8239918/LibTest8239918Test.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.testng.annotations.Test;
+import static org.testng.Assert.assertEquals;
+import static test.jextract.test8239918.test8239918_h.*;
+
+/*
+ * @test
+ * @library ..
+ * @modules jdk.incubator.jextract
+ * @bug 8239918
+ * @summary jextract generates uncompilable code for no argument C function
+ * @run driver JtregJextract -l Test8239918 -t test.jextract.test8239918 -- test8239918.h
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit LibTest8239918Test
+ */
+public class LibTest8239918Test {
+    @Test
+    public void testRand() {
+        assertEquals(rand(), 1729);
+    }
+}
diff a/test/jdk/tools/jextract/test8239918/libTest8239918.c b/test/jdk/tools/jextract/test8239918/libTest8239918.c
--- /dev/null
+++ b/test/jdk/tools/jextract/test8239918/libTest8239918.c
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "test8239918.h"
+
+EXPORT int rand(void) {
+    return 1729;
+}
diff a/test/jdk/tools/jextract/test8239918/test8239918.h b/test/jdk/tools/jextract/test8239918/test8239918.h
--- /dev/null
+++ b/test/jdk/tools/jextract/test8239918/test8239918.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+EXPORT int rand(void);
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
diff a/test/jdk/tools/jextract/testStruct/LibStructTest.java b/test/jdk/tools/jextract/testStruct/LibStructTest.java
--- /dev/null
+++ b/test/jdk/tools/jextract/testStruct/LibStructTest.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import jdk.incubator.foreign.MemoryLayout.PathElement;
+import jdk.incubator.foreign.GroupLayout;
+import jdk.incubator.foreign.SystemABI;
+import jdk.incubator.foreign.SystemABI.Type;
+import org.testng.annotations.Test;
+
+import static jdk.incubator.foreign.SystemABI.NATIVE_TYPE;
+import static org.testng.Assert.assertEquals;
+import static test.jextract.struct.struct_h.*;
+
+/*
+ * @test
+ * @library ..
+ * @modules jdk.incubator.jextract
+ * @run driver JtregJextract -l Struct -t test.jextract.struct -- struct.h
+ * @run testng/othervm -Djdk.incubator.foreign.Foreign=permit LibStructTest
+ */
+public class LibStructTest {
+    @Test
+    public void testMakePoint() {
+        try (var seg = makePoint(42, -39)) {
+            assertEquals(Point$x$get(seg), 42);
+            assertEquals(Point$y$get(seg), -39);
+        }
+    }
+
+    private static void checkFieldABIType(GroupLayout group, String fieldName, Type expected) {
+        assertEquals(group.select(PathElement.groupElement(fieldName)).attribute(NATIVE_TYPE)
+                                                                      .map(SystemABI.Type.class::cast)
+                                                                      .orElseThrow(), expected);
+    }
+
+    @Test
+    public void testFieldTypes() {
+        GroupLayout g = (GroupLayout)AllTypes$LAYOUT;
+        checkFieldABIType(g, "sc",  Type.SIGNED_CHAR);
+        checkFieldABIType(g, "uc",  Type.UNSIGNED_CHAR);
+        checkFieldABIType(g, "s",   Type.SHORT);
+        checkFieldABIType(g, "us",  Type.UNSIGNED_SHORT);
+        checkFieldABIType(g, "i",   Type.INT);
+        checkFieldABIType(g, "ui",  Type.UNSIGNED_INT);
+        checkFieldABIType(g, "l",   Type.LONG);
+        checkFieldABIType(g, "ul",  Type.UNSIGNED_LONG);
+        checkFieldABIType(g, "ll",  Type.LONG_LONG);
+        checkFieldABIType(g, "ull", Type.UNSIGNED_LONG_LONG);
+        checkFieldABIType(g, "f", Type.FLOAT);
+        checkFieldABIType(g, "d", Type.DOUBLE);
+        checkFieldABIType(g, "ld", Type.LONG_DOUBLE);
+    }
+}
diff a/test/jdk/tools/jextract/testStruct/libStruct.c b/test/jdk/tools/jextract/testStruct/libStruct.c
--- /dev/null
+++ b/test/jdk/tools/jextract/testStruct/libStruct.c
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "struct.h"
+
+EXPORT Point makePoint(int x, int y) {
+    Point pt = { x, y };
+    return pt;
+}
diff a/test/jdk/tools/jextract/testStruct/struct.h b/test/jdk/tools/jextract/testStruct/struct.h
--- /dev/null
+++ b/test/jdk/tools/jextract/testStruct/struct.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif // __cplusplus
+
+#ifdef _WIN64
+#define EXPORT __declspec(dllexport)
+#else
+#define EXPORT
+#endif
+
+typedef struct Point {
+    int x;
+    int y;
+} Point;
+
+EXPORT Point makePoint(int x, int y);
+
+struct AllTypes {
+    signed char sc;
+    unsigned char uc;
+    short s;
+    unsigned short us;
+    int i;
+    unsigned int ui;
+    long l;
+    unsigned long ul;
+    long long ll;
+    unsigned long long ull;
+    float f;
+    double d;
+    long double ld;
+};
+
+#ifdef __cplusplus
+}
+#endif // __cplusplus
diff a/test/jdk/tools/jextract/uniondecl.h b/test/jdk/tools/jextract/uniondecl.h
--- /dev/null
+++ b/test/jdk/tools/jextract/uniondecl.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+typedef union {
+    int i;
+    float f;
+} IntOrFloat;
+
+void func(IntOrFloat* value);
diff a/test/jdk/tools/launcher/HelpFlagsTest.java b/test/jdk/tools/launcher/HelpFlagsTest.java
--- a/test/jdk/tools/launcher/HelpFlagsTest.java
+++ b/test/jdk/tools/launcher/HelpFlagsTest.java
@@ -150,10 +150,12 @@
         new ToolHelpSpec("rmic",        0,   0,   0,   0,         0,    0,     1),     // none, prints help message anyways.
         new ToolHelpSpec("rmid",        0,   0,   0,   0,         0,    0,     1),     // none, prints help message anyways.
         new ToolHelpSpec("rmiregistry", 0,   0,   0,   0,         0,    0,     1),     // none, prints help message anyways.
         new ToolHelpSpec("serialver",   0,   0,   0,   0,         0,    0,     1),     // none, prints help message anyways.
         new ToolHelpSpec("jpackage",    0,   1,   1,   0,         0,    1,     1),     //     -h, --help,
+        // Panama
+        new ToolHelpSpec("jextract"    ,1,   1,   1,   0,         1,    1,   1),       // -?, -h, --help -help, Documents -help
     };
 
     // Returns corresponding object from jdkTools array.
     static ToolHelpSpec getToolHelpSpec(String tool) {
         for (ToolHelpSpec x : jdkTools) {

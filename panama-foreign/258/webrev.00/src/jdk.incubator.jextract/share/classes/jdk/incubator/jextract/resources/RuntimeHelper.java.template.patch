diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/resources/RuntimeHelper.java.template
@@ -1,7 +1,8 @@
 // Generated by jextract
 
+import jdk.incubator.foreign.Addressable;
 import jdk.incubator.foreign.CSupport;
 import jdk.incubator.foreign.ForeignLinker;
 import jdk.incubator.foreign.FunctionDescriptor;
 import jdk.incubator.foreign.LibraryLookup;
 import jdk.incubator.foreign.MemoryAddress;
@@ -40,11 +41,11 @@
                  })
                 .toArray(LibraryLookup[]::new);
         }
     }
 
-    private static final Optional<MemoryAddress> lookup(LibraryLookup[] LIBRARIES, String sym) {
+    private static final Optional<LibraryLookup.Symbol> lookup(LibraryLookup[] LIBRARIES, String sym) {
         for (LibraryLookup l : LIBRARIES) {
             try {
                 return Optional.of(l.lookup(sym));
             } catch (Throwable t) {
             }
@@ -57,11 +58,11 @@
     }
 
     public static final MemoryAddress lookupGlobalVariable(LibraryLookup[] LIBRARIES, String name, MemoryLayout layout) {
         return lookup(LIBRARIES, name).map(a ->
             MemorySegment.ofNativeRestricted(
-                 a, layout.byteSize(), null, null, a
+                 a.address(), layout.byteSize(), null, null, a
             ).withAccessModes(MemorySegment.READ | MemorySegment.WRITE).address()).orElse(null);
     }
 
     public static final MethodHandle downcallHandle(LibraryLookup[] LIBRARIES, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {
         return lookup(LIBRARIES, name).map(
@@ -101,15 +102,15 @@
         return seg.asSlice(addr.segmentOffset(), numElements * layout.byteSize()).address();
     }
 
     private static class VarargsInvoker {
         private static final MethodHandle INVOKE_MH;
-        private final MemoryAddress symbol;
+        private final Addressable symbol;
         private final MethodType varargs;
         private final FunctionDescriptor function;
 
-        private VarargsInvoker(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {
             this.symbol = symbol;
             this.varargs = type;
             this.function = function;
         }
 
@@ -119,11 +120,11 @@
             } catch (ReflectiveOperationException e) {
                 throw new RuntimeException(e);
             }
         }
 
-        static MethodHandle make(MemoryAddress symbol, MethodType type, FunctionDescriptor function) {
+        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {
             VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);
             return INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount())
                     .asType(type);
         }
 

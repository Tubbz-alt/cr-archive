diff a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java
@@ -193,38 +193,10 @@
      */
     static <S extends MemorySegment> Spliterator<S> spliterator(S segment, SequenceLayout layout) {
         return AbstractMemorySegmentImpl.spliterator(segment, layout);
     }
 
-    /**
-     * Fills a value into the given memory segment.
-     * <p>
-     * More specifically, the given value is filled into each address of the
-     * segment. Equivalent to (but likely more efficient than) the following code:
-     *
-     * <blockquote><pre>
-     * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
-     *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
-     * for (long l = 0; l < segment.byteSize(); l++) {
-     *     byteHandle.set(segment.baseAddress(), l, value);
-     * }</pre></blockquote>
-     * without any regard or guarantees on the ordering of particular memory
-     * elements being set.
-     * <p>
-     * Fill can be useful to initialize or reset the memory of a segment.
-     *
-     * @param segment the segment to fill
-     * @param value the value to fill into the segment
-     * @throws IllegalStateException if the segment is not <em>alive</em>, or if access occurs from a thread other than the
-     * thread owning this segment
-     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode
-     * @throws NullPointerException if {@code segment == null}
-     */
-    static void fill(MemorySegment segment, byte value) {
-        AbstractMemorySegmentImpl.fill(segment, value);
-    }
-
     /**
      * The thread owning this segment.
      * @return the thread owning this segment.
      */
     Thread ownerThread();
@@ -309,10 +281,35 @@
      * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
      */
     void close();
 
+    /**
+     * Fills a value into this memory segment.
+     * <p>
+     * More specifically, the given value is filled into each address of this
+     * segment. Equivalent to (but likely more efficient than) the following code:
+     *
+     * <blockquote><pre>
+     * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
+     *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
+     * for (long l = 0; l < segment.byteSize(); l++) {
+     *     byteHandle.set(segment.baseAddress(), l, value);
+     * }</pre></blockquote>
+     * without any regard or guarantees on the ordering of particular memory
+     * elements being set.
+     * <p>
+     * Fill can be useful to initialize or reset the memory of a segment.
+     *
+     * @param value the value to fill into this segment
+     * @return this memory segment
+     * @throws IllegalStateException if this segment is not <em>alive</em>, or if access occurs from a thread other than the
+     * thread owning this segment
+     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode
+     */
+    MemorySegment fill(byte value);
+
     /**
      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
      * the properties of this segment. For instance, if this segment is <em>immutable</em>
      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is <em>read-only</em>
      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -114,14 +114,15 @@
         }
         return (Spliterator<S>)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() & ~CLOSE));
     }
 
-    public static void fill(MemorySegment segment, byte value) {
-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl) segment;
-        segmentImpl.checkRange(0, segmentImpl.length, true);
-        UNSAFE.setMemory(segmentImpl.base(), segmentImpl.min(), segmentImpl.length, value);
+    @Override
+    public final MemorySegment fill(byte value){
+        checkRange(0, length, true);
+        UNSAFE.setMemory(base(), min(), length, value);
+        return this;
     }
 
     @Override
     @ForceInline
     public final MemoryAddress baseAddress() {
diff a/test/jdk/java/foreign/TestSegments.java b/test/jdk/java/foreign/TestSegments.java
--- a/test/jdk/java/foreign/TestSegments.java
+++ b/test/jdk/java/foreign/TestSegments.java
@@ -184,18 +184,21 @@
         VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
                 .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
 
         for (byte value : new byte[] {(byte) 0xFF, (byte) 0x00, (byte) 0x45}) {
             try (MemorySegment segment = memorySegmentSupplier.get()) {
-                MemorySegment.fill(segment, value);
+                segment.fill(value);
                 for (long l = 0; l < segment.byteSize(); l++) {
                     assertEquals((byte) byteHandle.get(segment.baseAddress(), l), value);
                 }
 
                 // fill a slice
-                MemorySegment sliceSegment = segment.asSlice(1, segment.byteSize() - 2);
-                MemorySegment.fill(sliceSegment, (byte) ~value);
+                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);
+                for (long l = 0; l < sliceSegment.byteSize(); l++) {
+                    assertEquals((byte) byteHandle.get(sliceSegment.baseAddress(), l), ~value);
+                }
+                // assert enclosing slice
                 assertEquals((byte) byteHandle.get(segment.baseAddress(), 0L), value);
                 for (long l = 1; l < segment.byteSize() - 2; l++) {
                     assertEquals((byte) byteHandle.get(segment.baseAddress(), l), (byte) ~value);
                 }
                 assertEquals((byte) byteHandle.get(segment.baseAddress(), segment.byteSize() - 1L), value);
@@ -205,28 +208,27 @@
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = IllegalStateException.class)
     public void testFillClosed(Supplier<MemorySegment> memorySegmentSupplier) {
         MemorySegment segment = memorySegmentSupplier.get();
         segment.close();
-        MemorySegment.fill(segment, (byte) 0xFF);
+        segment.fill((byte) 0xFF);
     }
 
     @Test(dataProvider = "segmentFactories", expectedExceptions = UnsupportedOperationException.class)
     public void testFillIllegalAccessMode(Supplier<MemorySegment> memorySegmentSupplier) {
         try (MemorySegment segment = memorySegmentSupplier.get()) {
-            var readOnlySegment = segment.withAccessModes(segment.accessModes() & ~WRITE);
-            MemorySegment.fill(readOnlySegment, (byte) 0xFF);
+            segment.withAccessModes(segment.accessModes() & ~WRITE).fill((byte) 0xFF);
         }
     }
 
     @Test(dataProvider = "segmentFactories")
     public void testFillThread(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {
         try (MemorySegment segment = memorySegmentSupplier.get()) {
             AtomicReference<RuntimeException> exception = new AtomicReference<>();
             Runnable action = () -> {
                 try {
-                    MemorySegment.fill(segment, (byte) 0xBA);
+                    segment.fill((byte) 0xBA);
                 } catch (RuntimeException e) {
                     exception.set(e);
                 }
             };
             Thread thread = new Thread(action);
@@ -240,24 +242,13 @@
         }
     }
 
     @Test
     public void testFillEmpty() {
-        try (MemorySegment segment = MemorySegment.ofArray(new byte[] { })) {
-            MemorySegment.fill(segment, (byte) 0xFF);
-        }
-        try (MemorySegment segment = MemorySegment.ofArray(new byte[2]).asSlice(0, 0)) {
-            MemorySegment.fill(segment, (byte) 0xFF);
-        }
-        try (MemorySegment segment = MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0))) {
-            MemorySegment.fill(segment, (byte) 0xFF);
-        }
-    }
-
-    @Test(expectedExceptions = NullPointerException.class)
-    public void testFillNull() {
-        MemorySegment.fill(null, (byte) 0xFF);
+        MemorySegment.ofArray(new byte[] { }).fill((byte) 0xFF);
+        MemorySegment.ofArray(new byte[2]).asSlice(0, 0).fill((byte) 0xFF);
+        MemorySegment.ofByteBuffer(ByteBuffer.allocateDirect(0)).fill((byte) 0xFF);
     }
 
     @Test(expectedExceptions = IllegalArgumentException.class)
     public void testBadWithAccessModes() {
         int[] arr = new int[1];
@@ -327,10 +318,11 @@
         final Method method;
         final Object[] params;
 
         final static List<String> CONFINED_NAMES = List.of(
                 "close",
+                "fill",
                 "toByteArray",
                 "withOwnerThread"
         );
 
         public SegmentMember(Method method, Object[] params) {

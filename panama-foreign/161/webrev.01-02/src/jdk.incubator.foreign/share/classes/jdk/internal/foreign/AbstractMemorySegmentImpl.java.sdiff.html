<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestSegments.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 99     @Override
100     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
101         checkBounds(offset, newSize);
102         return asSliceNoCheck(offset, newSize);
103     }
104 
105     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
106         return dup(offset, newSize, mask, owner, scope);
107     }
108 
109     @SuppressWarnings(&quot;unchecked&quot;)
110     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
111         ((AbstractMemorySegmentImpl)segment).checkValidState();
112         if (sequenceLayout.byteSize() != segment.byteSize()) {
113             throw new IllegalArgumentException();
114         }
115         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
116                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
117     }
118 
<span class="line-modified">119     public static void fill(MemorySegment segment, byte value) {</span>
<span class="line-modified">120         AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl) segment;</span>
<span class="line-modified">121         segmentImpl.checkRange(0, segmentImpl.length, true);</span>
<span class="line-modified">122         UNSAFE.setMemory(segmentImpl.base(), segmentImpl.min(), segmentImpl.length, value);</span>

123     }
124 
125     @Override
126     @ForceInline
127     public final MemoryAddress baseAddress() {
128         return new MemoryAddressImpl(this, 0);
129     }
130 
131     @Override
132     public final ByteBuffer asByteBuffer() {
133         if (!isSet(READ)) {
134             throw unsupportedAccessMode(READ);
135         }
136         checkIntSize(&quot;ByteBuffer&quot;);
137         ByteBuffer _bb = makeByteBuffer();
138         if (!isSet(WRITE)) {
139             //scope is IMMUTABLE - obtain a RO byte buffer
140             _bb = _bb.asReadOnlyBuffer();
141         }
142         return _bb;
</pre>
</td>
<td>
<hr />
<pre>
 99     @Override
100     public AbstractMemorySegmentImpl asSlice(long offset, long newSize) {
101         checkBounds(offset, newSize);
102         return asSliceNoCheck(offset, newSize);
103     }
104 
105     private AbstractMemorySegmentImpl asSliceNoCheck(long offset, long newSize) {
106         return dup(offset, newSize, mask, owner, scope);
107     }
108 
109     @SuppressWarnings(&quot;unchecked&quot;)
110     public static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout sequenceLayout) {
111         ((AbstractMemorySegmentImpl)segment).checkValidState();
112         if (sequenceLayout.byteSize() != segment.byteSize()) {
113             throw new IllegalArgumentException();
114         }
115         return (Spliterator&lt;S&gt;)new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),
116                 (AbstractMemorySegmentImpl)segment.withAccessModes(segment.accessModes() &amp; ~CLOSE));
117     }
118 
<span class="line-modified">119     @Override</span>
<span class="line-modified">120     public final MemorySegment fill(byte value){</span>
<span class="line-modified">121         checkRange(0, length, true);</span>
<span class="line-modified">122         UNSAFE.setMemory(base(), min(), length, value);</span>
<span class="line-added">123         return this;</span>
124     }
125 
126     @Override
127     @ForceInline
128     public final MemoryAddress baseAddress() {
129         return new MemoryAddressImpl(this, 0);
130     }
131 
132     @Override
133     public final ByteBuffer asByteBuffer() {
134         if (!isSet(READ)) {
135             throw unsupportedAccessMode(READ);
136         }
137         checkIntSize(&quot;ByteBuffer&quot;);
138         ByteBuffer _bb = makeByteBuffer();
139         if (!isSet(WRITE)) {
140             //scope is IMMUTABLE - obtain a RO byte buffer
141             _bb = _bb.asReadOnlyBuffer();
142         }
143         return _bb;
</pre>
</td>
</tr>
</table>
<center><a href="../../incubator/foreign/MemorySegment.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/jdk/java/foreign/TestSegments.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
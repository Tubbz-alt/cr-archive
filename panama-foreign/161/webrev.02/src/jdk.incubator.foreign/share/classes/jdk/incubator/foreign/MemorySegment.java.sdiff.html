<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
266 
267     /**
268      * Is this segment alive?
269      * @return true, if the segment is alive.
270      * @see MemorySegment#close()
271      */
272     boolean isAlive();
273 
274     /**
275      * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,
276      * or to access the memory associated with the segment will fail with {@link IllegalStateException}. Depending on
277      * the kind of memory segment being closed, calling this method further trigger deallocation of all the resources
278      * associated with the memory segment.
279      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
280      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
281      * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
282      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
283      */
284     void close();
285 

























286     /**
287      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
288      * the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt;
289      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt;
290      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
291      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
292      * &lt;p&gt;
293      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
294      * is closed (see {@link MemorySegment#close()}, accessing the returned
295      * buffer will throw an {@link IllegalStateException}.
296      * &lt;p&gt;
297      * The resulting buffer&#39;s byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
298      * {@link ByteBuffer#order(java.nio.ByteOrder)}.
299      *
300      * @return a {@link ByteBuffer} view of this memory segment.
301      * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,
302      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
303      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
304      */
305     ByteBuffer asByteBuffer();
</pre>
</td>
<td>
<hr />
<pre>
266 
267     /**
268      * Is this segment alive?
269      * @return true, if the segment is alive.
270      * @see MemorySegment#close()
271      */
272     boolean isAlive();
273 
274     /**
275      * Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,
276      * or to access the memory associated with the segment will fail with {@link IllegalStateException}. Depending on
277      * the kind of memory segment being closed, calling this method further trigger deallocation of all the resources
278      * associated with the memory segment.
279      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
280      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
281      * thread (see {@link #spliterator(MemorySegment, SequenceLayout)}).
282      * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.
283      */
284     void close();
285 
<span class="line-added">286     /**</span>
<span class="line-added">287      * Fills a value into this memory segment.</span>
<span class="line-added">288      * &lt;p&gt;</span>
<span class="line-added">289      * More specifically, the given value is filled into each address of this</span>
<span class="line-added">290      * segment. Equivalent to (but likely more efficient than) the following code:</span>
<span class="line-added">291      *</span>
<span class="line-added">292      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">293      * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)</span>
<span class="line-added">294      *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-added">295      * for (long l = 0; l &lt; segment.byteSize(); l++) {</span>
<span class="line-added">296      *     byteHandle.set(segment.baseAddress(), l, value);</span>
<span class="line-added">297      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">298      * without any regard or guarantees on the ordering of particular memory</span>
<span class="line-added">299      * elements being set.</span>
<span class="line-added">300      * &lt;p&gt;</span>
<span class="line-added">301      * Fill can be useful to initialize or reset the memory of a segment.</span>
<span class="line-added">302      *</span>
<span class="line-added">303      * @param value the value to fill into this segment</span>
<span class="line-added">304      * @return this memory segment</span>
<span class="line-added">305      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the</span>
<span class="line-added">306      * thread owning this segment</span>
<span class="line-added">307      * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode</span>
<span class="line-added">308      */</span>
<span class="line-added">309     MemorySegment fill(byte value);</span>
<span class="line-added">310 </span>
311     /**
312      * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to
313      * the properties of this segment. For instance, if this segment is &lt;em&gt;immutable&lt;/em&gt;
314      * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is &lt;em&gt;read-only&lt;/em&gt;
315      * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is
316      * &lt;em&gt;direct&lt;/em&gt; (see {@link ByteBuffer#isDirect()}).
317      * &lt;p&gt;
318      * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
319      * is closed (see {@link MemorySegment#close()}, accessing the returned
320      * buffer will throw an {@link IllegalStateException}.
321      * &lt;p&gt;
322      * The resulting buffer&#39;s byte order is {@link java.nio.ByteOrder#BIG_ENDIAN}; this can be changed using
323      * {@link ByteBuffer#order(java.nio.ByteOrder)}.
324      *
325      * @return a {@link ByteBuffer} view of this memory segment.
326      * @throws UnsupportedOperationException if this segment cannot be mapped onto a {@link ByteBuffer} instance,
327      * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater
328      * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.
329      */
330     ByteBuffer asByteBuffer();
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.incubator.foreign/share/classes/jdk/incubator/foreign/MemorySegment.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
178      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
179      * As such, splitting is possible as long as {@code N &gt;= 2}.
180      * &lt;p&gt;
181      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
182      * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
183      * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
184      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
185      * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
186      * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
187      * @param segment the segment to be used for splitting.
188      * @param layout the layout to be used for splitting.
189      * @param &lt;S&gt; the memory segment type
190      * @return the element spliterator for this segment
191      * @throws IllegalStateException if the segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
192      * thread owning this segment
193      */
194     static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout layout) {
195         return AbstractMemorySegmentImpl.spliterator(segment, layout);
196     }
197 




























198     /**
199      * The thread owning this segment.
200      * @return the thread owning this segment.
201      */
202     Thread ownerThread();
203 
204     /**
205      * Obtains a new memory segment backed by the same underlying memory region as this segment,
206      * but with different owner thread. As a side-effect, this segment will be marked as &lt;em&gt;not alive&lt;/em&gt;,
207      * and subsequent operations on this segment will result in runtime errors.
208      * &lt;p&gt;
209      * Write accesses to the segment&#39;s content &lt;a href=&quot;../../../java/util/concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;
210      * hand-over from the current owner thread to the new owner thread, which in turn &lt;i&gt;happens before&lt;/i&gt; read accesses to the segment&#39;s contents on
211      * the new owner thread.
212      *
213      * @param newOwner the new owner thread.
214      * @return a new memory segment backed by the same underlying memory region as this segment,
215      *      owned by {@code newOwner}.
216      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
217      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
</pre>
</td>
<td>
<hr />
<pre>
178      * will result in a spliterator serving approximatively {@code N/2} elements (depending on whether N is even or not).
179      * As such, splitting is possible as long as {@code N &gt;= 2}.
180      * &lt;p&gt;
181      * The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
182      * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).
183      * While closing the segment (see {@link #close()}) during pending concurrent execution will generally
184      * fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
185      * is actively working on it using {@link Spliterator#tryAdvance(Consumer)}; in such cases, any subsequent call
186      * to {@link Spliterator#tryAdvance(Consumer)} will fail with an exception.
187      * @param segment the segment to be used for splitting.
188      * @param layout the layout to be used for splitting.
189      * @param &lt;S&gt; the memory segment type
190      * @return the element spliterator for this segment
191      * @throws IllegalStateException if the segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
192      * thread owning this segment
193      */
194     static &lt;S extends MemorySegment&gt; Spliterator&lt;S&gt; spliterator(S segment, SequenceLayout layout) {
195         return AbstractMemorySegmentImpl.spliterator(segment, layout);
196     }
197 
<span class="line-added">198     /**</span>
<span class="line-added">199      * Fills a value into the given memory segment.</span>
<span class="line-added">200      * &lt;p&gt;</span>
<span class="line-added">201      * More specifically, the given value is filled into each address of the</span>
<span class="line-added">202      * segment. Equivalent to (but likely more efficient than) the following code:</span>
<span class="line-added">203      *</span>
<span class="line-added">204      * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">205      * byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)</span>
<span class="line-added">206      *         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());</span>
<span class="line-added">207      * for (long l = 0; l &lt; segment.byteSize(); l++) {</span>
<span class="line-added">208      *     byteHandle.set(segment.baseAddress(), l, value);</span>
<span class="line-added">209      * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">210      * without any regard or guarantees on the ordering of particular memory</span>
<span class="line-added">211      * elements being set.</span>
<span class="line-added">212      * &lt;p&gt;</span>
<span class="line-added">213      * Fill can be useful to initialize or reset the memory of a segment.</span>
<span class="line-added">214      *</span>
<span class="line-added">215      * @param segment the segment to fill</span>
<span class="line-added">216      * @param value the value to fill into the segment</span>
<span class="line-added">217      * @throws IllegalStateException if the segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the</span>
<span class="line-added">218      * thread owning this segment</span>
<span class="line-added">219      * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode</span>
<span class="line-added">220      * @throws NullPointerException if {@code segment == null}</span>
<span class="line-added">221      */</span>
<span class="line-added">222     static void fill(MemorySegment segment, byte value) {</span>
<span class="line-added">223         AbstractMemorySegmentImpl.fill(segment, value);</span>
<span class="line-added">224     }</span>
<span class="line-added">225 </span>
226     /**
227      * The thread owning this segment.
228      * @return the thread owning this segment.
229      */
230     Thread ownerThread();
231 
232     /**
233      * Obtains a new memory segment backed by the same underlying memory region as this segment,
234      * but with different owner thread. As a side-effect, this segment will be marked as &lt;em&gt;not alive&lt;/em&gt;,
235      * and subsequent operations on this segment will result in runtime errors.
236      * &lt;p&gt;
237      * Write accesses to the segment&#39;s content &lt;a href=&quot;../../../java/util/concurrent/package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happens-before&lt;/i&gt;&lt;/a&gt;
238      * hand-over from the current owner thread to the new owner thread, which in turn &lt;i&gt;happens before&lt;/i&gt; read accesses to the segment&#39;s contents on
239      * the new owner thread.
240      *
241      * @param newOwner the new owner thread.
242      * @return a new memory segment backed by the same underlying memory region as this segment,
243      *      owned by {@code newOwner}.
244      * @throws IllegalStateException if this segment is not &lt;em&gt;alive&lt;/em&gt;, or if access occurs from a thread other than the
245      * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../internal/foreign/AbstractMemorySegmentImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
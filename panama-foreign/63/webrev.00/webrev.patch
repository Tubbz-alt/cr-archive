diff a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/incubator/jextract/Position.java
@@ -49,10 +49,25 @@
      * The column number associated with this position.
      * @return The column number associated with this position.
      */
     int col();
 
+    /**
+     * The origin position lead to inclusion of this position. Return NO_POSITION if this position is root.
+     * @return The origin position
+     * @apiNote The origin() chain should never form a loop.
+     */
+    Position origin();
+
+    default int depth() {
+        int depth = 0;
+        for (Position p = this; p != Position.NO_POSITION; p = p.origin()) {
+            depth++;
+        }
+        return depth;
+    }
+
     /**
      * An empty position instance; this can be used to model <em>synthetic</em> program elements which are not
      * defined in any input file.
      */
     Position NO_POSITION = new Position() {
@@ -68,7 +83,17 @@
 
         @Override
         public int col() {
             return 0;
         }
+
+        @Override
+        public Position origin() {
+            throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public String toString() {
+            return "N/A";
+        }
     };
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/CursorPosition.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/CursorPosition.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/CursorPosition.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import java.nio.file.Path;
+import java.util.function.Function;
+import java.util.Objects;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.SourceLocation;
+import jdk.incubator.jextract.Position;
+
+final class CursorPosition implements Position {
+    private final Cursor cursor;
+    private final Path path;
+    private final int line;
+    private final int column;
+    private final Function<Path, Position> whereFrom;
+
+    CursorPosition(Cursor cursor, Function<Path, Position> whereFrom) {
+        Objects.requireNonNull(cursor);
+        SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();
+        this.cursor = cursor;
+        this.path = loc.path();
+        this.line = loc.line();
+        this.column = loc.column();
+        this.whereFrom = whereFrom;
+    }
+
+    @Override
+    public Path path() { return path; }
+
+    @Override
+    public int line() { return line; }
+
+    @Override
+    public int col() { return column; }
+
+    @Override
+    public Position origin() {
+        return whereFrom.apply(path);
+    }
+
+    public Cursor cursor() { return cursor; }
+
+    @Override
+    public String toString() {
+        return PrettyPrinter.position(this);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(this);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o instanceof CursorPosition) {
+            CursorPosition other = (CursorPosition) o;
+            return (path().equals(other.path()) && line() == other.line() && col() == other.col()
+                    && origin().equals(other.origin()));
+        }
+        return false;
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/Parser.java
@@ -23,10 +23,15 @@
  *  questions.
  *
  */
 package jdk.internal.jextract.impl;
 
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.JextractTask;
 import jdk.incubator.jextract.Position;
 import jdk.internal.clang.Cursor;
 import jdk.internal.clang.CursorKind;
@@ -35,22 +40,18 @@
 import jdk.internal.clang.LibClang;
 import jdk.internal.clang.SourceLocation;
 import jdk.internal.clang.SourceRange;
 import jdk.internal.clang.TranslationUnit;
 
-import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Optional;
-
 class Parser {
     private final TreeMaker treeMaker;
     private final JextractTask.ConstantParser constantParser;
+    private final PositionTracker tracker;
 
     public Parser(JextractTask.ConstantParser constantParser) {
-        this.treeMaker = new TreeMaker();
+        this.tracker = new PositionTracker();
+        this.treeMaker = new TreeMaker(tracker);
         this.constantParser = constantParser;
     }
 
     public Declaration.Scoped parse(Path path, Collection<String> args) {
         final Index index = LibClang.createIndex(false);
@@ -66,23 +67,24 @@
         JextractTask.ConstantParser constantParser = this.constantParser != null ?
                 this.constantParser : new DefaultConstantParser(new MacroParserImpl(tu, args));
 
         List<Declaration> decls = new ArrayList<>();
         Cursor tuCursor = tu.getCursor();
+        tracker.start(path);
         tuCursor.children().
             forEach(c -> {
+                tracker.track(c);
                 SourceLocation loc = c.getSourceLocation();
                 if (loc == null) {
                     return;
                 }
 
                 SourceLocation.Location src = loc.getFileLocation();
                 if (src == null) {
                     return;
                 }
 
-
                 if (c.isDeclaration()) {
                     if (c.kind() == CursorKind.UnexposedDecl ||
                         c.kind() == CursorKind.Namespace) {
                         c.children().map(treeMaker::createTree)
                                 .filter(t -> t != null)
@@ -121,14 +123,14 @@
             this.macroParser = macroParser;
         }
 
         @Override
         public Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {
-            if (!(pos instanceof TreeMaker.CursorPosition)) {
+            if (!(pos instanceof CursorPosition)) {
                 return Optional.empty();
             } else {
-                Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();
+                Cursor cursor = ((CursorPosition)pos).cursor();
                 if (cursor.isMacroFunctionLike()) {
                     return Optional.empty();
                 } else {
                     return Optional.ofNullable(treeMaker.createMacro(cursor, macroParser.eval(name, tokens)));
                 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PositionTracker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PositionTracker.java
--- /dev/null
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PositionTracker.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+package jdk.internal.jextract.impl;
+
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Supplier;
+import jdk.incubator.jextract.Position;
+import jdk.internal.clang.Cursor;
+import jdk.internal.clang.CursorKind;
+import jdk.internal.clang.SourceLocation;
+
+public class PositionTracker {
+    // The included source path map to the shallowest position of include directive
+    private final Map<Path, Origin> origins = new HashMap<>();
+    // The partial path from the include directive to resolved path by clang
+    private final Map<String, Path> realPaths = new HashMap<>();
+    // The chain of include directive leads to current file, not include current file
+    private LinkedList<Path> stack;
+    // The position of the latest include directive
+    private Origin pending = null;
+    // The file to be included next, used to resolve the real path
+    private String file = null;
+    private boolean preprocessing;
+
+    private static final boolean isMacOS = System.getProperty("os.name", "").contains("OS X");
+    private static final boolean DEBUG = System.getProperty("position.debug", "false").equals("true");
+
+    private void debug(Supplier<String> msg){
+        if (DEBUG) {
+            System.out.println(msg.get());
+        }
+    }
+    private void debug(String msg){
+        if (DEBUG) {
+            System.out.println(msg);
+        }
+    }
+
+    private String currentStack() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("New include: ").append(file).append("\n");
+        for (int i = stack.size() - 1; i >= 0; i--) {
+            Path tmp = stack.get(i);
+            for (int j = i + 1; j < stack.size() ; j++) sb.append(' ');
+            sb.append(tmp);
+            sb.append("\n");
+        }
+        return sb.toString();
+    }
+
+    private String showOrigins() {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Current origins table:\n");
+        origins.entrySet().stream().forEach(e -> {
+            sb.append(e.getKey());
+            sb.append(" -> ");
+            sb.append(e.getValue());
+            sb.append("\n");
+        });
+        return sb.toString();
+    }
+
+    static class Origin {
+        private final Position pos;
+        private final int depth;
+        final static Origin TOP = new Origin(0, Position.NO_POSITION);
+
+        Origin(int depth, Position pos) {
+            this.depth = depth;
+            this.pos = pos;
+        }
+
+        boolean deeperThan(Origin other) {
+            return depth >= other.depth;
+        }
+
+        @Override
+        public String toString() {
+            return String.format("%s@%d", pos.toString(), depth);
+        }
+    }
+
+    public void start(Path root) {
+        preprocessing = true;
+        stack = new LinkedList<>();
+        pending = Origin.TOP;
+        file = root.toString();
+    }
+
+    private int setOrigin(Path path, Origin origin) {
+        Objects.requireNonNull(path);
+        Objects.requireNonNull(origin);
+        Origin existing = origins.get(path);
+        if (null != existing) {
+            // Update existing postion if this is closer to the top
+            if (origin.deeperThan(existing)) {
+                debug(String.format(
+                    "Ignore %s from %s is deeper than existing %s", path.toString(), origin.toString(), existing.toString()));
+                return existing.depth;
+            } else {
+                debug(String.format("Update %s origin to %s from %s",
+                    path.toString(), origin.toString(), existing.toString()));
+            }
+        } else {
+            debug(String.format("Set %s origin to %s", path.toString(), origin.toString()));
+        }
+        origins.put(path, origin);
+        return origin.depth;
+    }
+
+    private boolean pathEndsWithFile(Path fullpath, String subpath) {
+        if (fullpath.endsWith(subpath)) {
+            return true;
+        }
+        if (isMacOS) {
+            // https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html
+            // The system identifies a framework by the .framework extension on its directory name
+            Path target = Paths.get(subpath);
+            return (target.getNameCount() > 1 &&
+                    fullpath.endsWith(target.subpath(1, target.getNameCount())) &&
+                    fullpath.toString().contains(target.getName(0).toString() + ".framework"));
+        }
+        return false;
+    }
+
+    private Position getOrigin(Path p) {
+        return (p == null) ? Position.NO_POSITION : origins.getOrDefault(p, Origin.TOP).pos;
+    }
+
+    private void reconcileStack(Path current) {
+        int index = stack.indexOf(current);
+        if (pending != null && pathEndsWithFile(current, file)) {
+            if (index == -1) {
+                stack.push(current);
+                realPaths.put(file, current);
+                setOrigin(current, pending);
+            } else {
+                debug("Circular inclusion detected");
+                debug(this::currentStack);
+                debug(this::showOrigins);
+                assert origins.get(current).depth == (stack.size() - index - 1);
+                // ignore this one, as whatever comes in in the file will be same and deeper then earlier
+                // when go back up, the stack will be reconcile properly
+            }
+            pending = null;
+        } else if (pending != null) {
+            // Not from the included file, meaning the included file procduce no cursor during preprocessing
+            debug("Expecting " + file + ", but get " + current);
+            // Trying to figure out real path of the included file, the stack could be shorter
+            Path tmp = realPaths.get(file);
+            if (tmp != null) {
+                setOrigin(tmp, pending);
+            } else {
+                debug("Don't know the real path for include file: " + file);
+            }
+            pending = null;
+        }
+        assert pending == null;
+
+        if (index > 0) {
+            // rewind stack
+            stack.subList(0, index).clear();
+            debug("Roll back stack to " + stack.get(0));
+            debug(this::currentStack);
+        }
+    }
+
+    public int track(Cursor cursor) {
+        SourceLocation.Location loc;
+        try {
+            loc = cursor.getSourceLocation().getFileLocation();
+        } catch (NullPointerException npe) {
+            // Ignore cursor without location
+            return 0;
+        }
+        assert (loc != null);
+        Path current = loc.path();
+        if (current == null) {
+            // Built-in macro instantiation
+            assert stack.isEmpty();
+            return 0;
+        }
+
+        if (cursor.isDeclaration()) {
+            if (preprocessing) {
+                // Preprocessing is done, we should have depth figured out
+                // unless there is no #include at all, this is the file
+                if (origins.isEmpty()) {
+                    setOrigin(current, Origin.TOP);
+                    return 1;
+                }
+                debug(this::showOrigins);
+                preprocessing = false;
+            }
+            assert origins.get(current) != null : "Cannot find origin for " + current;
+            return origins.get(current).depth;
+        }
+
+        // Make sure current file is the top of stack
+        reconcileStack(current);
+
+        if (cursor.kind() == CursorKind.InclusionDirective) {
+            pending = new Origin(stack.size(), toPos(cursor));
+            file = cursor.spelling();
+            debug(this::currentStack);
+        }
+        return stack.size();
+    }
+
+    public Position toPos(Cursor cursor) {
+        SourceLocation loc = cursor.getSourceLocation();
+        if (loc == null) {
+            return Position.NO_POSITION;
+        }
+        SourceLocation.Location sloc = loc.getFileLocation();
+        if (sloc == null) {
+            return Position.NO_POSITION;
+        }
+        return new CursorPosition(cursor, this::getOrigin);
+    }
+}
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PrettyPrinter.java
@@ -47,29 +47,30 @@
     }
 
     void indent() {
         builder.append("                                                                                           ".substring(0, align));
     }
-    
+
     StringBuilder builder = new StringBuilder();
 
     private void getAttributes(Declaration decl) {
         Set<String> attrs = decl.attributeNames();
-        if (attrs.isEmpty()) {
-            return;
-        }
         incr();
-        indent();
-        for (String k: attrs) {
-            builder.append("Attr: ");
-            builder.append(k);
-            builder.append(" -> [");
-            builder.append(decl.getAttribute(k).get().stream()
-                .map(Constable::toString)
-                .collect(Collectors.joining(", ")));
-            builder.append("]\n");
+        if (! attrs.isEmpty()) {
+            indent();
+            for (String k: attrs) {
+                builder.append("Attr: ");
+                builder.append(k);
+                builder.append(" -> [");
+                builder.append(decl.getAttribute(k).get().stream()
+                    .map(Constable::toString)
+                    .collect(Collectors.joining(", ")));
+                builder.append("]\n");
+            }
         }
+        indent();
+        builder.append("Position: " + decl.pos() + "\n");
         decr();
     }
 
     public String print(Declaration decl) {
         decl.accept(this, null);
@@ -166,10 +167,10 @@
     public static String type(Type type) {
         return type.accept(typeVisitor, null);
     }
 
     public static String position(Position pos) {
-        return String.format("%s:%d:%d",
+        return String.format("%s:%d:%d@%d",
                 pos.path() == null ? "N/A" : pos.path().toString(),
-                pos.line(), pos.col());
+                pos.line(), pos.col(), pos.depth());
     }
 }
diff a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
--- a/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
+++ b/src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/TreeMaker.java
@@ -25,11 +25,10 @@
  */
 package jdk.internal.jextract.impl;
 
 import java.lang.constant.Constable;
 import java.nio.ByteOrder;
-import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.ConcurrentModificationException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
@@ -43,18 +42,19 @@
 import jdk.incubator.jextract.Declaration;
 import jdk.incubator.jextract.Position;
 import jdk.incubator.jextract.Type;
 import jdk.internal.clang.Cursor;
 import jdk.internal.clang.CursorKind;
-import jdk.internal.clang.SourceLocation;
 
 class TreeMaker {
     private final Map<Cursor, Declaration> treeCache = new HashMap<>();
+    private final PositionTracker tracker;
+    private final TypeMaker typeMaker = new TypeMaker(this);
 
-    public TreeMaker() {}
-
-    TypeMaker typeMaker = new TypeMaker(this);
+    public TreeMaker(PositionTracker tracker) {
+        this.tracker = tracker;
+    }
 
     public void freeze() {
         typeMaker.resolveTypeReferences();
     }
 
@@ -126,59 +126,12 @@
             default:
                 return null;
         }
     }
 
-    Position toPos(Cursor cursor) {
-        SourceLocation loc = cursor.getSourceLocation();
-        if (loc == null) {
-            return Position.NO_POSITION;
-        }
-        SourceLocation.Location sloc = loc.getFileLocation();
-        if (sloc == null) {
-            return Position.NO_POSITION;
-        }
-        return new CursorPosition(cursor);
-    }
-
-    static class CursorPosition implements Position {
-        private final Cursor cursor;
-        private final Path path;
-        private final int line;
-        private final int column;
-
-        CursorPosition(Cursor cursor) {
-            this.cursor = cursor;
-            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();
-            this.path = loc.path();
-            this.line = loc.line();
-            this.column = loc.column();
-        }
-
-        @Override
-        public Path path() {
-            return path;
-        }
-
-        @Override
-        public int line() {
-            return line;
-        }
-
-        @Override
-        public int col() {
-            return column;
-        }
-
-        public Cursor cursor() {
-            return cursor;
-        }
-
-        @Override
-        public String toString() {
-            return PrettyPrinter.position(this);
-        }
+    Position toPos(Cursor c) {
+        return tracker.toPos(c);
     }
 
     public Declaration.Function createFunction(Cursor c) {
         checkCursor(c, CursorKind.FunctionDecl);
         List<Declaration.Variable> params = new ArrayList<>();
@@ -237,11 +190,12 @@
     }
 
     private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {
         return declarations.stream()
                 .filter(Objects::nonNull)
-                .filter(d -> isEnum(d) || !d.name().isEmpty() || ((CursorPosition)d.pos()).cursor.isAnonymousStruct())
+                .filter(d -> isEnum(d) || !d.name().isEmpty() ||
+                    ((CursorPosition) d.pos()).cursor().isAnonymousStruct())
                 .collect(Collectors.toList());
     }
 
     private Declaration.Scoped createTypedef(Cursor c) {
         Optional<Cursor> decl = c.children().findFirst();
diff a/test/jdk/java/jextract/TestDepth.java b/test/jdk/java/jextract/TestDepth.java
--- /dev/null
+++ b/test/jdk/java/jextract/TestDepth.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @build JextractApiTestBase
+ * @run testng/othervm -ea TestDepth
+ */
+
+import java.io.ByteArrayOutputStream;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+
+import jdk.incubator.foreign.MemoryLayouts;
+import jdk.incubator.jextract.Declaration;
+import jdk.incubator.jextract.Position;
+import jdk.incubator.jextract.Type;
+import org.testng.annotations.Test;
+import static org.testng.Assert.*;
+
+public class TestDepth extends JextractApiTestBase {
+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int, MemoryLayouts.C_INT);
+    // We need stdint.h for pointer macro, otherwise evaluation failed and Constant declaration is not created
+    String BUILTIN_INCLUDE = Paths.get(System.getProperty("java.home"), "conf", "jextract").toString();
+
+    private void assertOrigin(Position target, String filename, int depth) {
+        assertTrue(target.origin().path().endsWith(filename));
+        assertEquals(target.depth(), depth);
+    }
+
+    private String getSysRoot() {
+        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {
+            Process xcrun = new ProcessBuilder("xcrun", "--show-sdk-path").start();
+            xcrun.waitFor();
+            xcrun.getInputStream().transferTo(output);
+            String sysroot = output.toString();
+            // Trim tailing \n
+            sysroot = sysroot.substring(0, sysroot.length() - 1);
+            return sysroot;
+        } catch (Throwable t) {
+            t.printStackTrace();
+            return "";
+        }
+    }
+
+    @Test
+    public void parseEmpty() {
+        Declaration.Scoped root = parse("empty.h");
+        assertTrue(root.members().isEmpty());
+    }
+
+    @Test
+    public void parseMacFramework() {
+        if (!isMacOSX) {
+            return;
+        }
+
+        Declaration.Scoped root = parse("macos.h", "-isysroot", getSysRoot(), "-I", BUILTIN_INCLUDE);
+        // FIXME: kCFNotFound is not generated
+        // static const CFIndex kCFNotFound = -1;
+        Declaration.Constant cf = checkConstant(root, "__COREFOUNDATION_CFBASE__", C_INT, 1L);
+        assertTrue(cf.pos().path().endsWith("CFBase.h"));
+        assertOrigin(cf.pos(), "CoreFoundation.h", 3);
+    }
+
+    @Test
+    public void parseDepth1() {
+        Declaration.Scoped root = parse("depth1.h", "-I", BUILTIN_INCLUDE);
+        Declaration.Function fn = checkFunction(root, "depth1", C_INT);
+        assertEquals(fn.pos().origin(), Position.NO_POSITION);
+        assertEquals(fn.pos().depth(), 1);
+
+        fn = checkFunction(root, "depth2", C_INT);
+        assertOrigin(fn.pos(), "depth1.h", 2);
+
+        Declaration.Variable global = checkGlobal(root, "depth2and3", C_INT);
+        assertOrigin(global.pos(), "depth1.h", 2);
+
+        global = checkGlobal(root, "foo", C_INT);
+        assertTrue(global.pos().path().endsWith("libAsmSymbol.h"));
+        assertOrigin(global.pos(), "depth2.h", 3);
+
+        Declaration.Constant zero = checkConstant(root, "ZERO", C_INT, 0L);
+        assertTrue(zero.pos().path().endsWith("smoke.h"));
+        assertOrigin(zero.pos(), "depth2and3.h", 3);
+    }
+}
diff a/test/jdk/java/jextract/common_def.h b/test/jdk/java/jextract/common_def.h
--- /dev/null
+++ b/test/jdk/java/jextract/common_def.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef _COMMON_DEF_H_
+#define _COMMON_DEF_H_
+
+#ifdef _WIN64
+  #ifdef IMPL
+    #define EXPORT __declspec(dllexport)
+  #else
+    #define EXPORT __declspec(dllimport)
+  #endif // IMPL
+#else
+#define EXPORT
+#endif //_WIN64
+
+#ifdef _WIN32
+#define ALIAS(sym)
+#elif __APPLE__
+#define ALIAS(sym) __asm("_" #sym)
+#else
+#define ALIAS(sym) __asm__(#sym)
+#endif // _WIN32
+
+#endif // _COMMON_DEF_H_
diff a/test/jdk/java/jextract/depth1.h b/test/jdk/java/jextract/depth1.h
--- /dev/null
+++ b/test/jdk/java/jextract/depth1.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "common_def.h"
+#include "empty.h"
+#include "depth2.h"
+#include "depth2and3.h"
+
+EXPORT int depth1();
diff a/test/jdk/java/jextract/depth2.h b/test/jdk/java/jextract/depth2.h
--- /dev/null
+++ b/test/jdk/java/jextract/depth2.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "common_def.h"
+#include "libAsmSymbol.h"
+
+EXPORT int depth2();
+
+#include "depth2and3.h"
diff a/test/jdk/java/jextract/depth2and3.h b/test/jdk/java/jextract/depth2and3.h
--- /dev/null
+++ b/test/jdk/java/jextract/depth2and3.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef _DEPTH_2_3_H_
+#define _DEPTH_2_3_H_
+
+#include "common_def.h"
+
+EXPORT int depth2and3;
+
+#include "smoke.h"
+#include "empty.h"
+
+#include "loopinDepth2.h"
+
+#endif // _DEPTH_2_3_H
diff a/make/langtools/test/TEST.ROOT b/test/jdk/java/jextract/empty.h
--- a/make/langtools/test/TEST.ROOT
+++ b/test/jdk/java/jextract/empty.h
diff a/test/jdk/java/jextract/libAsmSymbol.h b/test/jdk/java/jextract/libAsmSymbol.h
--- a/test/jdk/java/jextract/libAsmSymbol.h
+++ b/test/jdk/java/jextract/libAsmSymbol.h
@@ -19,19 +19,11 @@
  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
 
-#ifdef _WIN64
-  #ifdef IMPL
-    #define EXPORT __declspec(dllexport)
-  #else
-    #define EXPORT __declspec(dllimport)
-  #endif // IMPL
-#else
-#define EXPORT
-#endif //_WIN64
+#include "common_def.h"
 
 #ifdef _WIN32
 // Windows doesn't really support asm symbol, this is similar approach for C code to
 // achieve similar, but this won't work with Panama until we support such Macro
 #ifdef ADD
@@ -39,16 +31,10 @@
 #define func funcA
 #else
 #define foo fooB
 #define func funcB
 #endif //ADD
-#define ALIAS(sym)
-
-#elif __APPLE__
-#define ALIAS(sym) __asm("_" #sym)
-#else
-#define ALIAS(sym) __asm__(#sym)
 #endif // _WIN32
 
 // We do 3 declarations to make sure we will pick up alias no matter the sequence of encounter
 // Without alias
 EXPORT extern int foo;
diff a/test/jdk/java/jextract/loopinDepth2.h b/test/jdk/java/jextract/loopinDepth2.h
--- /dev/null
+++ b/test/jdk/java/jextract/loopinDepth2.h
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "depth2.h"
diff a/test/jdk/java/jextract/macos.h b/test/jdk/java/jextract/macos.h
--- /dev/null
+++ b/test/jdk/java/jextract/macos.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifdef __APPLE__
+#include <CoreFoundation/CoreFoundation.h>
+#endif

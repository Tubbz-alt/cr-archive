<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jextract/share/classes/jdk/internal/jextract/impl/PositionTracker.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  *
 25  */
 26 
 27 package jdk.internal.jextract.impl;
 28 
 29 import java.nio.file.Path;
 30 import java.nio.file.Paths;
 31 import java.util.HashMap;
 32 import java.util.LinkedList;
 33 import java.util.Map;
 34 import java.util.Objects;
 35 import java.util.function.Supplier;
 36 import jdk.incubator.jextract.Position;
 37 import jdk.internal.clang.Cursor;
 38 import jdk.internal.clang.CursorKind;
 39 import jdk.internal.clang.SourceLocation;
 40 
 41 public class PositionTracker {
 42     // The included source path map to the shallowest position of include directive
 43     private final Map&lt;Path, Origin&gt; origins = new HashMap&lt;&gt;();
 44     // The partial path from the include directive to resolved path by clang
 45     private final Map&lt;String, Path&gt; realPaths = new HashMap&lt;&gt;();
 46     // The chain of include directive leads to current file, not include current file
 47     private LinkedList&lt;Path&gt; stack;
 48     // The position of the latest include directive
 49     private Origin pending = null;
 50     // The file to be included next, used to resolve the real path
 51     private String file = null;
 52     private boolean preprocessing;
 53 
 54     private static final boolean isMacOS = System.getProperty(&quot;os.name&quot;, &quot;&quot;).contains(&quot;OS X&quot;);
 55     private static final boolean DEBUG = System.getProperty(&quot;position.debug&quot;, &quot;false&quot;).equals(&quot;true&quot;);
 56 
 57     private void debug(Supplier&lt;String&gt; msg){
 58         if (DEBUG) {
 59             System.out.println(msg.get());
 60         }
 61     }
 62     private void debug(String msg){
 63         if (DEBUG) {
 64             System.out.println(msg);
 65         }
 66     }
 67 
 68     private String currentStack() {
 69         StringBuilder sb = new StringBuilder();
 70         sb.append(&quot;New include: &quot;).append(file).append(&quot;\n&quot;);
 71         for (int i = stack.size() - 1; i &gt;= 0; i--) {
 72             Path tmp = stack.get(i);
 73             for (int j = i + 1; j &lt; stack.size() ; j++) sb.append(&#39; &#39;);
 74             sb.append(tmp);
 75             sb.append(&quot;\n&quot;);
 76         }
 77         return sb.toString();
 78     }
 79 
 80     private String showOrigins() {
 81         StringBuilder sb = new StringBuilder();
 82         sb.append(&quot;Current origins table:\n&quot;);
 83         origins.entrySet().stream().forEach(e -&gt; {
 84             sb.append(e.getKey());
 85             sb.append(&quot; -&gt; &quot;);
 86             sb.append(e.getValue());
 87             sb.append(&quot;\n&quot;);
 88         });
 89         return sb.toString();
 90     }
 91 
 92     static class Origin {
 93         private final Position pos;
 94         private final int depth;
 95         final static Origin TOP = new Origin(0, Position.NO_POSITION);
 96 
 97         Origin(int depth, Position pos) {
 98             this.depth = depth;
 99             this.pos = pos;
100         }
101 
102         boolean deeperThan(Origin other) {
103             return depth &gt;= other.depth;
104         }
105 
106         @Override
107         public String toString() {
108             return String.format(&quot;%s@%d&quot;, pos.toString(), depth);
109         }
110     }
111 
112     public void start(Path root) {
113         preprocessing = true;
114         stack = new LinkedList&lt;&gt;();
115         pending = Origin.TOP;
116         file = root.toString();
117     }
118 
119     private int setOrigin(Path path, Origin origin) {
120         Objects.requireNonNull(path);
121         Objects.requireNonNull(origin);
122         Origin existing = origins.get(path);
123         if (null != existing) {
124             // Update existing postion if this is closer to the top
125             if (origin.deeperThan(existing)) {
126                 debug(String.format(
127                     &quot;Ignore %s from %s is deeper than existing %s&quot;, path.toString(), origin.toString(), existing.toString()));
128                 return existing.depth;
129             } else {
130                 debug(String.format(&quot;Update %s origin to %s from %s&quot;,
131                     path.toString(), origin.toString(), existing.toString()));
132             }
133         } else {
134             debug(String.format(&quot;Set %s origin to %s&quot;, path.toString(), origin.toString()));
135         }
136         origins.put(path, origin);
137         return origin.depth;
138     }
139 
140     private boolean pathEndsWithFile(Path fullpath, String subpath) {
141         if (fullpath.endsWith(subpath)) {
142             return true;
143         }
144         if (isMacOS) {
145             // https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Concepts/FrameworkAnatomy.html
146             // The system identifies a framework by the .framework extension on its directory name
147             Path target = Paths.get(subpath);
148             return (target.getNameCount() &gt; 1 &amp;&amp;
149                     fullpath.endsWith(target.subpath(1, target.getNameCount())) &amp;&amp;
150                     fullpath.toString().contains(target.getName(0).toString() + &quot;.framework&quot;));
151         }
152         return false;
153     }
154 
155     private Position getOrigin(Path p) {
156         return (p == null) ? Position.NO_POSITION : origins.getOrDefault(p, Origin.TOP).pos;
157     }
158 
159     private void reconcileStack(Path current) {
160         int index = stack.indexOf(current);
161         if (pending != null &amp;&amp; pathEndsWithFile(current, file)) {
162             if (index == -1) {
163                 stack.push(current);
164                 realPaths.put(file, current);
165                 setOrigin(current, pending);
166             } else {
167                 debug(&quot;Circular inclusion detected&quot;);
168                 debug(this::currentStack);
169                 debug(this::showOrigins);
170                 assert origins.get(current).depth == (stack.size() - index - 1);
171                 // ignore this one, as whatever comes in in the file will be same and deeper then earlier
172                 // when go back up, the stack will be reconcile properly
173             }
174             pending = null;
175         } else if (pending != null) {
176             // Not from the included file, meaning the included file procduce no cursor during preprocessing
177             debug(&quot;Expecting &quot; + file + &quot;, but get &quot; + current);
178             // Trying to figure out real path of the included file, the stack could be shorter
179             Path tmp = realPaths.get(file);
180             if (tmp != null) {
181                 setOrigin(tmp, pending);
182             } else {
183                 debug(&quot;Don&#39;t know the real path for include file: &quot; + file);
184             }
185             pending = null;
186         }
187         assert pending == null;
188 
189         if (index &gt; 0) {
190             // rewind stack
191             stack.subList(0, index).clear();
192             debug(&quot;Roll back stack to &quot; + stack.get(0));
193             debug(this::currentStack);
194         }
195     }
196 
197     public int track(Cursor cursor) {
198         SourceLocation.Location loc;
199         try {
200             loc = cursor.getSourceLocation().getFileLocation();
201         } catch (NullPointerException npe) {
202             // Ignore cursor without location
203             return 0;
204         }
205         assert (loc != null);
206         Path current = loc.path();
207         if (current == null) {
208             // Built-in macro instantiation
209             assert stack.isEmpty();
210             return 0;
211         }
212 
213         if (cursor.isDeclaration()) {
214             if (preprocessing) {
215                 // Preprocessing is done, we should have depth figured out
216                 // unless there is no #include at all, this is the file
217                 if (origins.isEmpty()) {
218                     setOrigin(current, Origin.TOP);
219                     return 1;
220                 }
221                 debug(this::showOrigins);
222                 preprocessing = false;
223             }
224             assert origins.get(current) != null : &quot;Cannot find origin for &quot; + current;
225             return origins.get(current).depth;
226         }
227 
228         // Make sure current file is the top of stack
229         reconcileStack(current);
230 
231         if (cursor.kind() == CursorKind.InclusionDirective) {
232             pending = new Origin(stack.size(), toPos(cursor));
233             file = cursor.spelling();
234             debug(this::currentStack);
235         }
236         return stack.size();
237     }
238 
239     public Position toPos(Cursor cursor) {
240         SourceLocation loc = cursor.getSourceLocation();
241         if (loc == null) {
242             return Position.NO_POSITION;
243         }
244         SourceLocation.Location sloc = loc.getFileLocation();
245         if (sloc == null) {
246             return Position.NO_POSITION;
247         }
248         return new CursorPosition(cursor, this::getOrigin);
249     }
250 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/HandshakeFailureTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../jextract/SmokeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../nio/channels/spi/SelectorProvider/inheritedChannel/libInheritedChannel.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/HandshakeFailureTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import static java.lang.System.out;
 25 import static java.net.http.HttpResponse.BodyHandlers.discarding;
 26 
 27 import java.io.DataInputStream;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.ServerSocket;
 33 import java.net.Socket;
<span class="line-removed"> 34 import java.net.SocketException;</span>
 35 import java.net.URI;
 36 import java.net.http.HttpClient;
 37 import java.net.http.HttpClient.Version;
 38 import java.net.http.HttpRequest;
 39 import java.net.http.HttpResponse;
 40 import java.util.List;

 41 import java.util.concurrent.CompletableFuture;
 42 import java.util.concurrent.CompletionException;
 43 
 44 import javax.net.ServerSocketFactory;
 45 import javax.net.ssl.SSLContext;
 46 import javax.net.ssl.SSLHandshakeException;
 47 import javax.net.ssl.SSLParameters;
 48 import javax.net.ssl.SSLSocket;
 49 
 50 /**
 51  * @test
<span class="line-modified"> 52  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.2</span>
<span class="line-modified"> 53  * @run main/othervm -Djdk.internal.httpclient.debug=false HandshakeFailureTest TLSv1.3</span>
 54  * @summary Verify SSLHandshakeException is received when the handshake fails,
 55  * either because the server closes (EOF) the connection during handshaking,
 56  * or no cipher suite can be negotiated (TLSv1.2) or no available authentication
 57  * scheme (TLSv1.3).
 58  */
 59 // To switch on debugging use:
 60 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 61 public class HandshakeFailureTest {
 62 
 63     // The number of iterations each testXXXClient performs. Can be increased
 64     // when running standalone testing.
 65     static final int TIMES = 10;
 66 
 67     private static String tlsProtocol;











































 68 
 69     public static void main(String[] args) throws Exception {
 70         tlsProtocol = args[0];




 71 
 72         HandshakeFailureTest test = new HandshakeFailureTest();
 73         List&lt;AbstractServer&gt; servers = List.of(new PlainServer(), new SSLServer());
 74 
 75         for (AbstractServer server : servers) {
 76             try (server) {
 77                 out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
<span class="line-modified"> 78                 URI uri = new URI(&quot;https://localhost:&quot; + server.getPort() + &quot;/&quot;);</span>
 79 
 80                 test.testSyncSameClient(uri, Version.HTTP_1_1);
 81                 test.testSyncSameClient(uri, Version.HTTP_2);
 82                 test.testSyncDiffClient(uri, Version.HTTP_1_1);
 83                 test.testSyncDiffClient(uri, Version.HTTP_2);
 84 
 85                 test.testAsyncSameClient(uri, Version.HTTP_1_1);
 86                 test.testAsyncSameClient(uri, Version.HTTP_2);
 87                 test.testAsyncDiffClient(uri, Version.HTTP_1_1);
 88                 test.testAsyncDiffClient(uri, Version.HTTP_2);
 89             }
 90         }
 91     }
 92 
 93     static HttpClient getClient() {
 94         SSLParameters params = new SSLParameters();
 95         params.setProtocols(new String[] { tlsProtocol });
 96         return HttpClient.newBuilder()
 97                 .sslParameters(params)
 98                 .build();
 99     }
100 
101     void testSyncSameClient(URI uri, Version version) throws Exception {
102         out.printf(&quot;%n--- testSyncSameClient %s ---%n&quot;, version);
103         HttpClient client = getClient();

104         for (int i = 0; i &lt; TIMES; i++) {
105             out.printf(&quot;iteration %d%n&quot;, i);
106             HttpRequest request = HttpRequest.newBuilder(uri)
107                                              .version(version)
108                                              .build();
109             try {
110                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
111                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
112                 throw new RuntimeException(msg);
113             } catch (IOException expected) {
114                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">115                 checkExceptionOrCause(expected);</span>
116             }
117         }

118     }
119 
120     void testSyncDiffClient(URI uri, Version version) throws Exception {
121         out.printf(&quot;%n--- testSyncDiffClient %s ---%n&quot;, version);

122         for (int i = 0; i &lt; TIMES; i++) {
123             out.printf(&quot;iteration %d%n&quot;, i);
124             // a new client each time
125             HttpClient client = getClient();
126             HttpRequest request = HttpRequest.newBuilder(uri)
127                                              .version(version)
128                                              .build();
129             try {
130                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
131                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
132                 throw new RuntimeException(msg);
133             } catch (IOException expected) {
134                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">135                 checkExceptionOrCause(expected);</span>
136             }
137         }

138     }
139 
140     void testAsyncSameClient(URI uri, Version version) throws Exception {
141         out.printf(&quot;%n--- testAsyncSameClient %s ---%n&quot;, version);
142         HttpClient client = getClient();

143         for (int i = 0; i &lt; TIMES; i++) {
144             out.printf(&quot;iteration %d%n&quot;, i);
145             HttpRequest request = HttpRequest.newBuilder(uri)
146                                              .version(version)
147                                              .build();
148             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
149                         client.sendAsync(request, discarding());
150             try {
151                 response.join();
152                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
153                 throw new RuntimeException(msg);
154             } catch (CompletionException ce) {
155                 Throwable expected = ce.getCause();
156                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">157                 checkExceptionOrCause(expected);</span>
158             }
159         }

160     }
161 
162     void testAsyncDiffClient(URI uri, Version version) throws Exception {
163         out.printf(&quot;%n--- testAsyncDiffClient %s ---%n&quot;, version);

164         for (int i = 0; i &lt; TIMES; i++) {
165             out.printf(&quot;iteration %d%n&quot;, i);
166             // a new client each time
167             HttpClient client = getClient();
168             HttpRequest request = HttpRequest.newBuilder(uri)
169                                              .version(version)
170                                              .build();
171             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
172                     client.sendAsync(request, discarding());
173             try {
174                 response.join();
175                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
176                 throw new RuntimeException(msg);
177             } catch (CompletionException ce) {
178                 ce.printStackTrace(out);
179                 Throwable expected = ce.getCause();
180                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">181                 checkExceptionOrCause(expected);</span>
182             }
183         }







184     }
185 
<span class="line-modified">186     static void checkExceptionOrCause(Throwable t) {</span>



187         final Throwable original = t;
188         do {
<span class="line-modified">189             if (SSLHandshakeException.class.isInstance(t)</span>
<span class="line-modified">190                     // For TLSv1.3, possibly the server is (being) closed when</span>
<span class="line-modified">191                     // the client read the input alert. In this case, the client</span>
<span class="line-modified">192                     // just gets SocketException instead of SSLHandshakeException.</span>
<span class="line-removed">193                     || (tlsProtocol.equalsIgnoreCase(&quot;TLSv1.3&quot;)</span>
<span class="line-removed">194                             &amp;&amp; SocketException.class.isInstance(t))) {</span>
195                 System.out.println(&quot;Found expected exception/cause: &quot; + t);
<span class="line-modified">196                 return; // found</span>




197             }
198         } while ((t = t.getCause()) != null);
199         original.printStackTrace(System.out);
200         throw new RuntimeException(
<span class="line-modified">201                 &quot;Not found expected SSLHandshakeException or SocketException in &quot;</span>
202                         + original);
203     }
204 
205     /** Common super type for PlainServer and SSLServer. */
206     static abstract class AbstractServer extends Thread implements AutoCloseable {
207         protected final ServerSocket ss;
208         protected volatile boolean closed;
209 
210         AbstractServer(String name, ServerSocket ss) throws IOException {
211             super(name);
212             ss.setReuseAddress(false);
213             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
214             this.ss = ss;
215             this.start();
216         }
217 
218         int getPort() { return ss.getLocalPort(); }
219 






220         @Override
221         public void close() {
222             if (closed)
223                 return;
224             closed = true;
225             try {
226                 ss.close();
227             } catch (IOException e) {
228                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
229             }
230         }
231     }
232 
233     /** Emulates a server-side, using plain cleartext Sockets, that just closes
234      * the connection, after a small variable delay. */
235     static class PlainServer extends AbstractServer {
236         private volatile int count;
237 
238         PlainServer() throws IOException {
239             super(&quot;PlainServer&quot;, new ServerSocket());
</pre>
<hr />
<pre>
260                         ProtocolVersion version;
261                         uint16 length;
262                         opaque fragment[SSLPlaintext.length];
263                     } SSLPlaintext;   */
264                     DataInputStream din =  new DataInputStream(s.getInputStream());
265                     int contentType = din.read();
266                     out.println(&quot;ContentType:&quot; + contentType);
267                     int majorVersion = din.read();
268                     out.println(&quot;Major:&quot; + majorVersion);
269                     int minorVersion = din.read();
270                     out.println(&quot;Minor:&quot; + minorVersion);
271                     int length = din.readShort();
272                     out.println(&quot;length:&quot; + length);
273                     byte[] ba = new byte[length];
274                     din.readFully(ba);
275 
276                     // simulate various delays in response
277                     Thread.sleep(10 * (count % 10));
278                     s.close(); // close without giving any reply
279                 } catch (IOException e) {
<span class="line-modified">280                     if (!closed)</span>
<span class="line-modified">281                         out.println(&quot;Unexpected&quot; + e);</span>


282                 } catch (InterruptedException e) {
<span class="line-modified">283                     throw new RuntimeException(e);</span>












284                 }
285             }
286         }
287     }
288 
289     /** Emulates a server-side, using SSL Sockets, that will fail during
290      * handshaking, as there are no cipher suites in common (TLSv1.2)
291      * or no available authentication scheme (TLSv1.3). */
292     static class SSLServer extends AbstractServer {
293         static final SSLContext sslContext = createUntrustingContext();
294         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
295 
296         static SSLContext createUntrustingContext() {
297             try {
298                 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
299                 sslContext.init(null, null, null);
300                 return sslContext;
301             } catch (Throwable t) {
302                 throw new AssertionError(t);
303             }
304         }
305 
306         SSLServer() throws IOException {
307             super(&quot;SSLServer&quot;, factory.createServerSocket());
308         }
309 
310         @Override
311         public void run() {
312             while (!closed) {
313                 try (SSLSocket s = (SSLSocket)ss.accept()) {
314                     s.getInputStream().read();  // will throw SHE here
315 
316                     throw new AssertionError(&quot;Should not reach here&quot;);
317                 } catch (SSLHandshakeException expected) {
318                     // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)
319                     // or no available authentication scheme (TLSv1.3)
<span class="line-modified">320                     out.printf(&quot;Server: caught expected exception: %s%n&quot;, expected);</span>
321                 } catch (IOException e) {
<span class="line-modified">322                     if (!closed)</span>
<span class="line-modified">323                         out.printf(&quot;UNEXPECTED %s&quot;, e);</span>









324                 }
325             }
326         }
327     }
328 }
</pre>
</td>
<td>
<hr />
<pre>
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import static java.lang.System.out;
 25 import static java.net.http.HttpResponse.BodyHandlers.discarding;
 26 
 27 import java.io.DataInputStream;
 28 import java.io.IOException;
 29 import java.io.UncheckedIOException;
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.ServerSocket;
 33 import java.net.Socket;

 34 import java.net.URI;
 35 import java.net.http.HttpClient;
 36 import java.net.http.HttpClient.Version;
 37 import java.net.http.HttpRequest;
 38 import java.net.http.HttpResponse;
 39 import java.util.List;
<span class="line-added"> 40 import java.util.Locale;</span>
 41 import java.util.concurrent.CompletableFuture;
 42 import java.util.concurrent.CompletionException;
 43 
 44 import javax.net.ServerSocketFactory;
 45 import javax.net.ssl.SSLContext;
 46 import javax.net.ssl.SSLHandshakeException;
 47 import javax.net.ssl.SSLParameters;
 48 import javax.net.ssl.SSLSocket;
 49 
 50 /**
 51  * @test
<span class="line-modified"> 52  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest TLSv1.2</span>
<span class="line-modified"> 53  * @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest TLSv1.3</span>
 54  * @summary Verify SSLHandshakeException is received when the handshake fails,
 55  * either because the server closes (EOF) the connection during handshaking,
 56  * or no cipher suite can be negotiated (TLSv1.2) or no available authentication
 57  * scheme (TLSv1.3).
 58  */
 59 // To switch on debugging use:
 60 // @run main/othervm -Djdk.internal.httpclient.debug=true HandshakeFailureTest
 61 public class HandshakeFailureTest {
 62 
 63     // The number of iterations each testXXXClient performs. Can be increased
 64     // when running standalone testing.
 65     static final int TIMES = 10;
 66 
 67     private static String tlsProtocol;
<span class="line-added"> 68     private static int maxWsaeConnAborted;</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     // On Microsoft Windows, a WSAECONNABORTED error could be raised</span>
<span class="line-added"> 71     // if the client side fails to retransmit a TCP packet.</span>
<span class="line-added"> 72     // This could happen if for instance, the server stops reading and</span>
<span class="line-added"> 73     // close the socket while the client is still trying to push</span>
<span class="line-added"> 74     // data through.</span>
<span class="line-added"> 75     // With TLSv1.3, and our dummy SSLServer implementation below,</span>
<span class="line-added"> 76     // this can occur quite often.</span>
<span class="line-added"> 77     // Our HTTP stack should automatically wrap such exceptions</span>
<span class="line-added"> 78     // in SSLHandshakeException if they are raised while the handshake</span>
<span class="line-added"> 79     // in progress. So it would be an error to receive WSAECONNABORTED</span>
<span class="line-added"> 80     // here. This test has some special code to handle WSAECONNABORTED</span>
<span class="line-added"> 81     // and fail if they reach the test code.</span>
<span class="line-added"> 82     public static final String WSAECONNABORTED_MSG =</span>
<span class="line-added"> 83             &quot;An established connection was aborted by the software in your host machine&quot;;</span>
<span class="line-added"> 84     public static final boolean isWindows = System.getProperty(&quot;os.name&quot;, &quot;&quot;)</span>
<span class="line-added"> 85             .toLowerCase(Locale.ROOT).contains(&quot;win&quot;);</span>
<span class="line-added"> 86     public enum ExpectedExceptionType {</span>
<span class="line-added"> 87         HANDSHAKE_FAILURE,</span>
<span class="line-added"> 88         WSAECONNABORTED</span>
<span class="line-added"> 89     }</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91     // The exception checker is used to record how many WSAECONNABORTED</span>
<span class="line-added"> 92     // have reached the test code. There should be none:</span>
<span class="line-added"> 93     // (usually max should be 0)</span>
<span class="line-added"> 94     static final class ExceptionChecker {</span>
<span class="line-added"> 95         int count;</span>
<span class="line-added"> 96         Throwable aborted = null;</span>
<span class="line-added"> 97         public void check(Throwable expected) {</span>
<span class="line-added"> 98             if (ExpectedExceptionType.WSAECONNABORTED == checkExceptionOrCause(expected)) {</span>
<span class="line-added"> 99                 count++;</span>
<span class="line-added">100                 aborted = expected;</span>
<span class="line-added">101             }</span>
<span class="line-added">102         }</span>
<span class="line-added">103         public void check(int max) {</span>
<span class="line-added">104             if (count &gt; max) {</span>
<span class="line-added">105                 out.println(&quot;WSAECONNABORTED received too many times: &quot; + count);</span>
<span class="line-added">106                 aborted.printStackTrace(out);</span>
<span class="line-added">107                 throw new AssertionError(&quot;WSAECONNABORTED received too many times: &quot; + count, aborted);</span>
<span class="line-added">108             }</span>
<span class="line-added">109         }</span>
<span class="line-added">110     }</span>
111 
112     public static void main(String[] args) throws Exception {
113         tlsProtocol = args[0];
<span class="line-added">114         // At this time, all WSAECONNABORTED exception raised during</span>
<span class="line-added">115         // the handshake should have been wrapped in SSLHandshakeException,</span>
<span class="line-added">116         // so we allow none to reach here.</span>
<span class="line-added">117         maxWsaeConnAborted = 0;</span>
118 
119         HandshakeFailureTest test = new HandshakeFailureTest();
120         List&lt;AbstractServer&gt; servers = List.of(new PlainServer(), new SSLServer());
121 
122         for (AbstractServer server : servers) {
123             try (server) {
124                 out.format(&quot;%n%n------ Testing with server:%s ------%n&quot;, server);
<span class="line-modified">125                 URI uri = new URI(&quot;https://&quot; + server.getAuthority() + &quot;/&quot;);</span>
126 
127                 test.testSyncSameClient(uri, Version.HTTP_1_1);
128                 test.testSyncSameClient(uri, Version.HTTP_2);
129                 test.testSyncDiffClient(uri, Version.HTTP_1_1);
130                 test.testSyncDiffClient(uri, Version.HTTP_2);
131 
132                 test.testAsyncSameClient(uri, Version.HTTP_1_1);
133                 test.testAsyncSameClient(uri, Version.HTTP_2);
134                 test.testAsyncDiffClient(uri, Version.HTTP_1_1);
135                 test.testAsyncDiffClient(uri, Version.HTTP_2);
136             }
137         }
138     }
139 
140     static HttpClient getClient() {
141         SSLParameters params = new SSLParameters();
142         params.setProtocols(new String[] { tlsProtocol });
143         return HttpClient.newBuilder()
144                 .sslParameters(params)
145                 .build();
146     }
147 
148     void testSyncSameClient(URI uri, Version version) throws Exception {
149         out.printf(&quot;%n--- testSyncSameClient %s ---%n&quot;, version);
150         HttpClient client = getClient();
<span class="line-added">151         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
152         for (int i = 0; i &lt; TIMES; i++) {
153             out.printf(&quot;iteration %d%n&quot;, i);
154             HttpRequest request = HttpRequest.newBuilder(uri)
155                                              .version(version)
156                                              .build();
157             try {
158                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
159                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
160                 throw new RuntimeException(msg);
161             } catch (IOException expected) {
162                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">163                 exceptionChecker.check(expected);</span>
164             }
165         }
<span class="line-added">166         exceptionChecker.check(maxWsaeConnAborted);</span>
167     }
168 
169     void testSyncDiffClient(URI uri, Version version) throws Exception {
170         out.printf(&quot;%n--- testSyncDiffClient %s ---%n&quot;, version);
<span class="line-added">171         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
172         for (int i = 0; i &lt; TIMES; i++) {
173             out.printf(&quot;iteration %d%n&quot;, i);
174             // a new client each time
175             HttpClient client = getClient();
176             HttpRequest request = HttpRequest.newBuilder(uri)
177                                              .version(version)
178                                              .build();
179             try {
180                 HttpResponse&lt;Void&gt; response = client.send(request, discarding());
181                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
182                 throw new RuntimeException(msg);
183             } catch (IOException expected) {
184                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">185                 exceptionChecker.check(expected);</span>
186             }
187         }
<span class="line-added">188         exceptionChecker.check(maxWsaeConnAborted);</span>
189     }
190 
191     void testAsyncSameClient(URI uri, Version version) throws Exception {
192         out.printf(&quot;%n--- testAsyncSameClient %s ---%n&quot;, version);
193         HttpClient client = getClient();
<span class="line-added">194         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
195         for (int i = 0; i &lt; TIMES; i++) {
196             out.printf(&quot;iteration %d%n&quot;, i);
197             HttpRequest request = HttpRequest.newBuilder(uri)
198                                              .version(version)
199                                              .build();
200             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
201                         client.sendAsync(request, discarding());
202             try {
203                 response.join();
204                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
205                 throw new RuntimeException(msg);
206             } catch (CompletionException ce) {
207                 Throwable expected = ce.getCause();
208                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">209                 exceptionChecker.check(expected);</span>
210             }
211         }
<span class="line-added">212         exceptionChecker.check(maxWsaeConnAborted);</span>
213     }
214 
215     void testAsyncDiffClient(URI uri, Version version) throws Exception {
216         out.printf(&quot;%n--- testAsyncDiffClient %s ---%n&quot;, version);
<span class="line-added">217         ExceptionChecker exceptionChecker = new ExceptionChecker();</span>
218         for (int i = 0; i &lt; TIMES; i++) {
219             out.printf(&quot;iteration %d%n&quot;, i);
220             // a new client each time
221             HttpClient client = getClient();
222             HttpRequest request = HttpRequest.newBuilder(uri)
223                                              .version(version)
224                                              .build();
225             CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt; response =
226                     client.sendAsync(request, discarding());
227             try {
228                 response.join();
229                 String msg = String.format(&quot;UNEXPECTED response=%s%n&quot;, response);
230                 throw new RuntimeException(msg);
231             } catch (CompletionException ce) {
232                 ce.printStackTrace(out);
233                 Throwable expected = ce.getCause();
234                 out.printf(&quot;Client: caught expected exception: %s%n&quot;, expected);
<span class="line-modified">235                 exceptionChecker.check(expected);</span>
236             }
237         }
<span class="line-added">238         exceptionChecker.check(maxWsaeConnAborted);</span>
<span class="line-added">239     }</span>
<span class="line-added">240 </span>
<span class="line-added">241     // Tells whether this exception was raised from a WSAECONNABORTED</span>
<span class="line-added">242     // error raised in the native code.</span>
<span class="line-added">243     static boolean isWsaeConnAborted(Throwable t) {</span>
<span class="line-added">244         return t instanceof IOException &amp;&amp; WSAECONNABORTED_MSG.equalsIgnoreCase(t.getMessage());</span>
245     }
246 
<span class="line-modified">247     // We might allow some spurious WSAECONNABORTED exception.</span>
<span class="line-added">248     // The decision whether to allow such errors or not is taken by</span>
<span class="line-added">249     // the ExceptionChecker</span>
<span class="line-added">250     static ExpectedExceptionType checkExceptionOrCause(Throwable t) {</span>
251         final Throwable original = t;
252         do {
<span class="line-modified">253             if (SSLHandshakeException.class.isInstance(t)) {</span>
<span class="line-modified">254                 // For TLSv1.3, possibly the server is (being) closed when</span>
<span class="line-modified">255                 // the client read the input alert. In this case, the client</span>
<span class="line-modified">256                 // just gets SocketException instead of SSLHandshakeException.</span>


257                 System.out.println(&quot;Found expected exception/cause: &quot; + t);
<span class="line-modified">258                 return ExpectedExceptionType.HANDSHAKE_FAILURE;</span>
<span class="line-added">259             }</span>
<span class="line-added">260             if (isWindows &amp;&amp; isWsaeConnAborted(t)) {</span>
<span class="line-added">261                 System.out.println(&quot;Found WSAECONNABORTED: &quot; + t);</span>
<span class="line-added">262                 return ExpectedExceptionType.WSAECONNABORTED;</span>
263             }
264         } while ((t = t.getCause()) != null);
265         original.printStackTrace(System.out);
266         throw new RuntimeException(
<span class="line-modified">267                 &quot;Not found expected SSLHandshakeException in &quot;</span>
268                         + original);
269     }
270 
271     /** Common super type for PlainServer and SSLServer. */
272     static abstract class AbstractServer extends Thread implements AutoCloseable {
273         protected final ServerSocket ss;
274         protected volatile boolean closed;
275 
276         AbstractServer(String name, ServerSocket ss) throws IOException {
277             super(name);
278             ss.setReuseAddress(false);
279             ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
280             this.ss = ss;
281             this.start();
282         }
283 
284         int getPort() { return ss.getLocalPort(); }
285 
<span class="line-added">286         String getAuthority() {</span>
<span class="line-added">287             String address = ss.getInetAddress().getHostAddress();</span>
<span class="line-added">288             if (address.contains(&quot;:&quot;)) address = &quot;[&quot; + address + &quot;]&quot;;</span>
<span class="line-added">289             return address + &quot;:&quot; + ss.getLocalPort();</span>
<span class="line-added">290         }</span>
<span class="line-added">291 </span>
292         @Override
293         public void close() {
294             if (closed)
295                 return;
296             closed = true;
297             try {
298                 ss.close();
299             } catch (IOException e) {
300                 throw new UncheckedIOException(&quot;Unexpected&quot;, e);
301             }
302         }
303     }
304 
305     /** Emulates a server-side, using plain cleartext Sockets, that just closes
306      * the connection, after a small variable delay. */
307     static class PlainServer extends AbstractServer {
308         private volatile int count;
309 
310         PlainServer() throws IOException {
311             super(&quot;PlainServer&quot;, new ServerSocket());
</pre>
<hr />
<pre>
332                         ProtocolVersion version;
333                         uint16 length;
334                         opaque fragment[SSLPlaintext.length];
335                     } SSLPlaintext;   */
336                     DataInputStream din =  new DataInputStream(s.getInputStream());
337                     int contentType = din.read();
338                     out.println(&quot;ContentType:&quot; + contentType);
339                     int majorVersion = din.read();
340                     out.println(&quot;Major:&quot; + majorVersion);
341                     int minorVersion = din.read();
342                     out.println(&quot;Minor:&quot; + minorVersion);
343                     int length = din.readShort();
344                     out.println(&quot;length:&quot; + length);
345                     byte[] ba = new byte[length];
346                     din.readFully(ba);
347 
348                     // simulate various delays in response
349                     Thread.sleep(10 * (count % 10));
350                     s.close(); // close without giving any reply
351                 } catch (IOException e) {
<span class="line-modified">352                     if (!closed) {</span>
<span class="line-modified">353                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">354                         e.printStackTrace(out);</span>
<span class="line-added">355                     }</span>
356                 } catch (InterruptedException e) {
<span class="line-modified">357                     if (!closed) {</span>
<span class="line-added">358                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">359                         e.printStackTrace(out);</span>
<span class="line-added">360                         throw new RuntimeException(e);</span>
<span class="line-added">361                     }</span>
<span class="line-added">362                     break;</span>
<span class="line-added">363                 } catch (Error | RuntimeException e) {</span>
<span class="line-added">364                     if (!closed) {</span>
<span class="line-added">365                         out.println(&quot;PlainServer: unexpected &quot; + e);</span>
<span class="line-added">366                         e.printStackTrace(out);</span>
<span class="line-added">367                         throw new RuntimeException(e);</span>
<span class="line-added">368                     }</span>
<span class="line-added">369                     break;</span>
370                 }
371             }
372         }
373     }
374 
375     /** Emulates a server-side, using SSL Sockets, that will fail during
376      * handshaking, as there are no cipher suites in common (TLSv1.2)
377      * or no available authentication scheme (TLSv1.3). */
378     static class SSLServer extends AbstractServer {
379         static final SSLContext sslContext = createUntrustingContext();
380         static final ServerSocketFactory factory = sslContext.getServerSocketFactory();
381 
382         static SSLContext createUntrustingContext() {
383             try {
384                 SSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);
385                 sslContext.init(null, null, null);
386                 return sslContext;
387             } catch (Throwable t) {
388                 throw new AssertionError(t);
389             }
390         }
391 
392         SSLServer() throws IOException {
393             super(&quot;SSLServer&quot;, factory.createServerSocket());
394         }
395 
396         @Override
397         public void run() {
398             while (!closed) {
399                 try (SSLSocket s = (SSLSocket)ss.accept()) {
400                     s.getInputStream().read();  // will throw SHE here
401 
402                     throw new AssertionError(&quot;Should not reach here&quot;);
403                 } catch (SSLHandshakeException expected) {
404                     // Expected: SSLHandshakeException: no cipher suites in common (TLSv1.2)
405                     // or no available authentication scheme (TLSv1.3)
<span class="line-modified">406                     out.printf(&quot;SSLServer: caught expected exception: %s%n&quot;, expected);</span>
407                 } catch (IOException e) {
<span class="line-modified">408                     if (!closed) {</span>
<span class="line-modified">409                         out.println(&quot;SSLServer: unexpected &quot; + e);</span>
<span class="line-added">410                         e.printStackTrace(out);</span>
<span class="line-added">411                     }</span>
<span class="line-added">412                 } catch (Error | RuntimeException e) {</span>
<span class="line-added">413                     if (!closed) {</span>
<span class="line-added">414                         out.println(&quot;SSLServer: unexpected &quot; + e);</span>
<span class="line-added">415                         e.printStackTrace(out);</span>
<span class="line-added">416                         throw new RuntimeException(e);</span>
<span class="line-added">417                     }</span>
<span class="line-added">418                     break;</span>
419                 }
420             }
421         }
422     }
423 }
</pre>
</td>
</tr>
</table>
<center><a href="../../jextract/SmokeTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../nio/channels/spi/SelectorProvider/inheritedChannel/libInheritedChannel.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
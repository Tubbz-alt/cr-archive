<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/PointerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeIntrinsificationProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  67 import org.graalvm.compiler.nodes.FixedNode;
  68 import org.graalvm.compiler.nodes.FixedWithNextNode;
  69 import org.graalvm.compiler.nodes.IfNode;
  70 import org.graalvm.compiler.nodes.LogicNode;
  71 import org.graalvm.compiler.nodes.MergeNode;
  72 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  73 import org.graalvm.compiler.nodes.NodeView;
  74 import org.graalvm.compiler.nodes.PhiNode;
  75 import org.graalvm.compiler.nodes.PiNode;
  76 import org.graalvm.compiler.nodes.StructuredGraph;
  77 import org.graalvm.compiler.nodes.ValueNode;
  78 import org.graalvm.compiler.nodes.ValuePhiNode;
  79 import org.graalvm.compiler.nodes.calc.AddNode;
  80 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  81 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  82 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  84 import org.graalvm.compiler.nodes.calc.IsNullNode;
  85 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  86 import org.graalvm.compiler.nodes.calc.NarrowNode;

  87 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  88 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  89 import org.graalvm.compiler.nodes.calc.SubNode;
  90 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  91 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  92 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  93 import org.graalvm.compiler.nodes.extended.BoxNode;
  94 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  95 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  96 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  97 import org.graalvm.compiler.nodes.extended.GuardingNode;
  98 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  99 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 100 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 101 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 102 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 103 import org.graalvm.compiler.nodes.extended.MembarNode;
 104 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 105 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 106 import org.graalvm.compiler.nodes.extended.UnboxNode;
</pre>
<hr />
<pre>
 110 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 111 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 112 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 113 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 114 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 115 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 116 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 117 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 118 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 119 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 120 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 121 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 122 import org.graalvm.compiler.nodes.java.NewArrayNode;
 123 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 124 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 125 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 126 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 127 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 128 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 129 import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
<span class="line-modified"> 130 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
 131 import org.graalvm.compiler.nodes.memory.ReadNode;
 132 import org.graalvm.compiler.nodes.memory.VolatileReadNode;
 133 import org.graalvm.compiler.nodes.memory.WriteNode;
 134 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 135 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 136 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="line-removed"> 137 import org.graalvm.compiler.nodes.spi.GCProvider;</span>
 138 import org.graalvm.compiler.nodes.spi.Lowerable;
 139 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 140 import org.graalvm.compiler.nodes.spi.LoweringTool;

 141 import org.graalvm.compiler.nodes.type.StampTool;
 142 import org.graalvm.compiler.nodes.util.GraphUtil;
 143 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 144 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 145 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
 146 import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
 147 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 148 import org.graalvm.compiler.options.OptionValues;
 149 import org.graalvm.compiler.phases.util.Providers;
 150 import org.graalvm.compiler.replacements.SnippetLowerableMemoryNode.SnippetLowering;
 151 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 152 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 153 import jdk.internal.vm.compiler.word.LocationIdentity;
 154 
 155 import jdk.vm.ci.code.CodeUtil;
 156 import jdk.vm.ci.code.MemoryBarriers;
 157 import jdk.vm.ci.code.TargetDescription;
 158 import jdk.vm.ci.meta.DeoptimizationAction;
 159 import jdk.vm.ci.meta.DeoptimizationReason;
 160 import jdk.vm.ci.meta.JavaConstant;
</pre>
<hr />
<pre>
 356             return;
 357         }
 358         ResolvedJavaMethod method = math.graph().method();
 359         if (method != null) {
 360             if (method.getName().equalsIgnoreCase(math.getOperation().name()) &amp;&amp; tool.getMetaAccess().lookupJavaType(Math.class).equals(method.getDeclaringClass())) {
 361                 // A root compilation of the intrinsic method should emit the full assembly
 362                 // implementation.
 363                 return;
 364             }
 365         }
 366         StructuredGraph graph = math.graph();
 367         ForeignCallNode call = math.graph().add(new ForeignCallNode(foreignCalls, math.getOperation().foreignCallDescriptor, math.getValue()));
 368         graph.addAfterFixed(tool.lastFixedNode(), call);
 369         math.replaceAtUsages(call);
 370     }
 371 
 372     protected void lowerVerifyHeap(VerifyHeapNode n) {
 373         GraphUtil.removeFixedWithUnusedInputs(n);
 374     }
 375 
<span class="line-modified"> 376     protected AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {</span>
 377         ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
 378         return graph.unique(new OffsetAddressNode(object, o));
 379     }
 380 
<span class="line-modified"> 381     protected AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {</span>
 382         int offset = fieldOffset(field);
 383         if (offset &gt;= 0) {
 384             return createOffsetAddress(graph, object, offset);
 385         } else {
 386             return null;
 387         }
 388     }
 389 
 390     protected abstract JavaKind getStorageKind(ResolvedJavaField field);
 391 
 392     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 393         assert loadField.getStackKind() != JavaKind.Illegal;
 394         StructuredGraph graph = loadField.graph();
 395         ResolvedJavaField field = loadField.field();
 396         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 397         object = createNullCheckedValue(object, loadField, tool);
 398         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 399 
 400         AddressNode address = createFieldAddress(graph, object, field);
 401         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
</pre>
<hr />
<pre>
 599         ValueNode nullHub = ConstantNode.forConstant(hubStamp.asAlwaysNull(), JavaConstant.NULL_POINTER, tool.getMetaAccess(), graph);
 600         final ValueNode nonNullValue = graph.addOrUniqueWithInputs(PiNode.create(value, stamp.asNonNull(), ifNode.falseSuccessor()));
 601         ValueNode hub = createReadHub(graph, nonNullValue, tool);
 602         ValueNode[] values = new ValueNode[]{nullHub, hub};
 603         final PhiNode hubPhi = graph.unique(new ValuePhiNode(hubStamp, merge, values));
 604         final FixedNode oldNext = predecessor.next();
 605         predecessor.setNext(ifNode);
 606         merge.setNext(oldNext);
 607         loadHubOrNullNode.replaceAtUsagesAndDelete(hubPhi);
 608     }
 609 
 610     protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
 611         StructuredGraph graph = loadHub.graph();
 612         ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
 613         graph.replaceFixed(loadHub, hub);
 614     }
 615 
 616     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 617         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 618         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
<span class="line-modified"> 619         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId()));</span>
 620         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 621         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 622         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 623     }
 624 
 625     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 626         StructuredGraph graph = cas.graph();
 627         JavaKind valueKind = cas.getValueKind();
 628 
 629         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 630         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 631 
 632         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 633         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
 634         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));
 635         atomicNode.setStateAfter(cas.stateAfter());
 636         graph.replaceFixedWithFixed(cas, atomicNode);
 637     }
 638 
 639     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
</pre>
<hr />
<pre>
 657         JavaKind valueKind = n.getValueKind();
 658 
 659         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 660 
 661         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
 662         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
 663         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
 664         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));
 665         memoryRead.setStateAfter(n.stateAfter());
 666 
 667         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 668         n.stateAfter().replaceFirstInput(n, memoryRead);
 669         n.replaceAtUsages(readValue);
 670         graph.replaceFixedWithFixed(n, memoryRead);
 671     }
 672 
 673     /**
 674      * @param tool utility for performing the lowering
 675      */
 676     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="line-modified"> 677         GCProvider gc = tool.getProviders().getGC();</span>
 678         StructuredGraph graph = load.graph();
 679         if (load instanceof GuardedUnsafeLoadNode) {
 680             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 681             GuardingNode guard = guardedLoad.getGuard();
 682             if (guard == null) {
 683                 // can float freely if the guard folded away
 684                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 685                 memoryRead.setForceFixed(false);
 686                 graph.replaceFixedWithFixed(load, memoryRead);
 687             } else {
 688                 // must be guarded, but flows below the guard
 689                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);
 690                 graph.replaceFixedWithFixed(load, memoryRead);
 691             }
 692         } else {
 693             // never had a guarding condition so it must be fixed, creation of the read will force
 694             // it to be fixed
 695             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 696             graph.replaceFixedWithFixed(load, memoryRead);
 697         }
 698     }
 699 
 700     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 701         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 702             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 703         } else {
 704             return graph.unique(new OffsetAddressNode(object, offset));
 705         }
 706     }
 707 
<span class="line-modified"> 708     protected ReadNode createUnsafeRead(GCProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 709         boolean compressible = load.accessKind() == JavaKind.Object;
 710         JavaKind readKind = load.accessKind();
 711         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 712         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
 713         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));
 714         if (guard == null) {
 715             // An unsafe read must not float otherwise it may float above
 716             // a test guaranteeing the read is safe.
 717             memoryRead.setForceFixed(true);
 718         } else {
 719             memoryRead.setGuard(guard);
 720         }
 721         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 722         load.replaceAtUsages(readValue);
 723         return memoryRead;
 724     }
 725 
 726     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 727         StructuredGraph graph = load.graph();
 728         JavaKind readKind = load.getKind();
</pre>
<hr />
<pre>
 819                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects
 820                     newObject.clearEmitMemoryBarrier();
 821 
 822                     recursiveLowerings.add(newObject);
 823                     graph.addBeforeFixed(commit, newObject);
 824                     allocations[objIndex] = newObject;
 825                     for (int i = 0; i &lt; entryCount; i++) {
 826                         ValueNode value = commit.getValues().get(valuePos);
 827                         if (value instanceof VirtualObjectNode) {
 828                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 829                         }
 830                         if (value == null) {
 831                             omittedValues.set(valuePos);
 832                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 833                             // Constant.illegal is always the defaultForKind, so it is skipped
 834                             JavaKind valueKind = value.getStackKind();
 835                             JavaKind entryKind = virtual.entryKind(i);
 836 
 837                             // Truffle requires some leniency in terms of what can be put where:
 838                             assert valueKind.getStackKind() == entryKind.getStackKind() ||
<span class="line-modified"> 839                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode));</span>

 840                             AddressNode address = null;
 841                             BarrierType barrierType = null;
 842                             if (virtual instanceof VirtualInstanceNode) {
 843                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 844                                 long offset = fieldOffset(field);
 845                                 if (offset &gt;= 0) {
 846                                     address = createOffsetAddress(graph, newObject, offset);
 847                                     barrierType = fieldInitializationBarrier(entryKind);
 848                                 }
 849                             } else {
 850                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
 851                                 barrierType = arrayInitializationBarrier(entryKind);
 852                             }
 853                             if (address != null) {
<span class="line-modified"> 854                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType, false);</span>
 855                                 graph.addAfterFixed(newObject, graph.add(write));
 856                             }
 857                         }
 858                         valuePos++;
 859                     }
 860                 }
 861             }
 862             valuePos = 0;
 863 
 864             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 865                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 866                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 867                     int entryCount = virtual.entryCount();
 868                     ValueNode newObject = allocations[objIndex];
 869                     for (int i = 0; i &lt; entryCount; i++) {
 870                         if (omittedValues.get(valuePos)) {
 871                             ValueNode value = commit.getValues().get(valuePos);
 872                             assert value instanceof VirtualObjectNode;
 873                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 874                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
</pre>
<hr />
<pre>
 877                                 BarrierType barrierType;
 878                                 if (virtual instanceof VirtualInstanceNode) {
 879                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
 880                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));
 881                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));
 882                                 } else {
 883                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
 884                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));
 885                                 }
 886                                 if (address != null) {
 887                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);
 888                                     graph.addBeforeFixed(commit, graph.add(write));
 889                                 }
 890                             }
 891                         }
 892                         valuePos++;
 893                     }
 894                 }
 895             }
 896 
<span class="line-modified"> 897             finishAllocatedObjects(tool, commit, allocations);</span>
 898             graph.removeFixed(commit);
 899 
 900             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 901                 recursiveLowering.lower(tool);
 902             }
 903         }
 904 
 905     }
 906 
 907     public NewInstanceNode createNewInstanceFromVirtual(VirtualObjectNode virtual) {
 908         return new NewInstanceNode(virtual.type(), true);
 909     }
 910 
 911     protected NewArrayNode createNewArrayFromVirtual(VirtualObjectNode virtual, ValueNode length) {
 912         return new NewArrayNode(((VirtualArrayNode) virtual).componentType(), length, true);
 913     }
 914 
<span class="line-modified"> 915     public void finishAllocatedObjects(LoweringTool tool, CommitAllocationNode commit, ValueNode[] allocations) {</span>

 916         StructuredGraph graph = commit.graph();
 917         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 918             FixedValueAnchorNode anchor = graph.add(new FixedValueAnchorNode(allocations[objIndex]));
 919             allocations[objIndex] = anchor;
<span class="line-modified"> 920             graph.addBeforeFixed(commit, anchor);</span>

 921         }
 922         /*
 923          * Note that the FrameState that is assigned to these MonitorEnterNodes isn&#39;t the correct
 924          * state. It will be the state from before the allocation occurred instead of a valid state
 925          * after the locking is performed. In practice this should be fine since these are newly
 926          * allocated objects. The bytecodes themselves permit allocating an object, doing a
 927          * monitorenter and then dropping all references to the object which would produce the same
 928          * state, though that would normally produce an IllegalMonitorStateException. In HotSpot
 929          * some form of fast path locking should always occur so the FrameState should never
 930          * actually be used.
 931          */
 932         ArrayList&lt;MonitorEnterNode&gt; enters = null;
 933         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 934             List&lt;MonitorIdNode&gt; locks = commit.getLocks(objIndex);
 935             if (locks.size() &gt; 1) {
 936                 // Ensure that the lock operations are performed in lock depth order
 937                 ArrayList&lt;MonitorIdNode&gt; newList = new ArrayList&lt;&gt;(locks);
 938                 newList.sort((a, b) -&gt; Integer.compare(a.getLockDepth(), b.getLockDepth()));
 939                 locks = newList;
 940             }
 941             int lastDepth = -1;
 942             for (MonitorIdNode monitorId : locks) {
 943                 assert lastDepth &lt; monitorId.getLockDepth();
 944                 lastDepth = monitorId.getLockDepth();
 945                 MonitorEnterNode enter = graph.add(new MonitorEnterNode(allocations[objIndex], monitorId));
<span class="line-modified"> 946                 graph.addBeforeFixed(commit, enter);</span>

 947                 if (enters == null) {
 948                     enters = new ArrayList&lt;&gt;();
 949                 }
 950                 enters.add(enter);
 951             }
 952         }
 953         for (Node usage : commit.usages().snapshot()) {
 954             if (usage instanceof AllocatedObjectNode) {
 955                 AllocatedObjectNode addObject = (AllocatedObjectNode) usage;
 956                 int index = commit.getVirtualObjects().indexOf(addObject.getVirtualObject());
 957                 addObject.replaceAtUsagesAndDelete(allocations[index]);
 958             } else {
 959                 assert enters != null;
 960                 commit.replaceAtUsages(InputType.Memory, enters.get(enters.size() - 1));
 961             }
 962         }
 963         if (enters != null) {
 964             for (MonitorEnterNode enter : enters) {
 965                 enter.lower(tool);
 966             }
 967         }
 968         assert commit.hasNoUsages();
<span class="line-modified"> 969         insertAllocationBarrier(commit, graph);</span>
 970     }
 971 
 972     /**
 973      * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
 974      * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
 975      * are being written, as if {@link FinalFieldBarrierNode} were emitted.
 976      */
<span class="line-modified"> 977     private static void insertAllocationBarrier(CommitAllocationNode commit, StructuredGraph graph) {</span>
 978         int barrier = MemoryBarriers.STORE_STORE;
 979         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 980             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 981                 if (field.isFinal()) {
 982                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 983                     break outer;
 984                 }
 985             }
 986         }
<span class="line-modified"> 987         graph.addAfterFixed(commit, graph.add(new MembarNode(barrier, LocationIdentity.init())));</span>
 988     }
 989 
 990     /**
 991      * @param field the field whose barrier type should be returned
 992      */
<span class="line-modified"> 993     protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
 994         return BarrierType.NONE;
 995     }
 996 
<span class="line-modified"> 997     protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
 998         if (getStorageKind(field) == JavaKind.Object) {
 999             return BarrierType.FIELD;
1000         }
1001         return BarrierType.NONE;
1002     }
1003 
<span class="line-modified">1004     protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
1005         if (elementKind == JavaKind.Object) {
1006             return BarrierType.ARRAY;
1007         }
1008         return BarrierType.NONE;
1009     }
1010 
1011     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
1012         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;
1013     }
1014 
1015     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
1016         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;
1017     }
1018 
1019     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
1020         if (!store.needsBarrier()) {
1021             return BarrierType.NONE;
1022         }
1023         return guessStoreBarrierType(store.object(), store.value());
1024     }
</pre>
<hr />
<pre>
1098 
1099     /**
1100      * @param compressible whether the convert should be compressible
1101      */
1102     protected ValueNode implicitLoadConvert(JavaKind kind, ValueNode value, boolean compressible) {
1103         if (useCompressedOops(kind, compressible)) {
1104             return newCompressionNode(CompressionOp.Uncompress, value);
1105         }
1106 
1107         switch (kind) {
1108             case Byte:
1109             case Short:
1110                 return new SignExtendNode(value, 32);
1111             case Boolean:
1112             case Char:
1113                 return new ZeroExtendNode(value, 32);
1114         }
1115         return value;
1116     }
1117 






























1118     public final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value) {
1119         return implicitStoreConvert(graph, kind, value, true);
1120     }
1121 
1122     public ValueNode implicitStoreConvert(JavaKind kind, ValueNode value) {
1123         return implicitStoreConvert(kind, value, true);
1124     }
1125 
1126     protected final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value, boolean compressible) {
1127         ValueNode ret = implicitStoreConvert(kind, value, compressible);
1128         if (!ret.isAlive()) {
1129             ret = graph.addOrUnique(ret);
1130         }
1131         return ret;
1132     }
1133 
1134     /**
1135      * @param compressible whether the covert should be compressible
1136      */
1137     protected ValueNode implicitStoreConvert(JavaKind kind, ValueNode value, boolean compressible) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  67 import org.graalvm.compiler.nodes.FixedNode;
  68 import org.graalvm.compiler.nodes.FixedWithNextNode;
  69 import org.graalvm.compiler.nodes.IfNode;
  70 import org.graalvm.compiler.nodes.LogicNode;
  71 import org.graalvm.compiler.nodes.MergeNode;
  72 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  73 import org.graalvm.compiler.nodes.NodeView;
  74 import org.graalvm.compiler.nodes.PhiNode;
  75 import org.graalvm.compiler.nodes.PiNode;
  76 import org.graalvm.compiler.nodes.StructuredGraph;
  77 import org.graalvm.compiler.nodes.ValueNode;
  78 import org.graalvm.compiler.nodes.ValuePhiNode;
  79 import org.graalvm.compiler.nodes.calc.AddNode;
  80 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  81 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  82 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  84 import org.graalvm.compiler.nodes.calc.IsNullNode;
  85 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  86 import org.graalvm.compiler.nodes.calc.NarrowNode;
<span class="line-added">  87 import org.graalvm.compiler.nodes.calc.ReinterpretNode;</span>
  88 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  89 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  90 import org.graalvm.compiler.nodes.calc.SubNode;
  91 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  92 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  93 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  94 import org.graalvm.compiler.nodes.extended.BoxNode;
  95 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  96 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  97 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  98 import org.graalvm.compiler.nodes.extended.GuardingNode;
  99 import org.graalvm.compiler.nodes.extended.JavaReadNode;
 100 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 101 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 102 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 103 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 104 import org.graalvm.compiler.nodes.extended.MembarNode;
 105 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 106 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 107 import org.graalvm.compiler.nodes.extended.UnboxNode;
</pre>
<hr />
<pre>
 111 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 112 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 113 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 114 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 115 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 116 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 117 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 118 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 119 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 120 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 121 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 122 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 123 import org.graalvm.compiler.nodes.java.NewArrayNode;
 124 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 125 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 126 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 127 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 128 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 129 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 130 import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
<span class="line-modified"> 131 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>
 132 import org.graalvm.compiler.nodes.memory.ReadNode;
 133 import org.graalvm.compiler.nodes.memory.VolatileReadNode;
 134 import org.graalvm.compiler.nodes.memory.WriteNode;
 135 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 136 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 137 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;

 138 import org.graalvm.compiler.nodes.spi.Lowerable;
 139 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 140 import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="line-added"> 141 import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;</span>
 142 import org.graalvm.compiler.nodes.type.StampTool;
 143 import org.graalvm.compiler.nodes.util.GraphUtil;
 144 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 145 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 146 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
 147 import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
 148 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 149 import org.graalvm.compiler.options.OptionValues;
 150 import org.graalvm.compiler.phases.util.Providers;
 151 import org.graalvm.compiler.replacements.SnippetLowerableMemoryNode.SnippetLowering;
 152 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 153 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 154 import jdk.internal.vm.compiler.word.LocationIdentity;
 155 
 156 import jdk.vm.ci.code.CodeUtil;
 157 import jdk.vm.ci.code.MemoryBarriers;
 158 import jdk.vm.ci.code.TargetDescription;
 159 import jdk.vm.ci.meta.DeoptimizationAction;
 160 import jdk.vm.ci.meta.DeoptimizationReason;
 161 import jdk.vm.ci.meta.JavaConstant;
</pre>
<hr />
<pre>
 357             return;
 358         }
 359         ResolvedJavaMethod method = math.graph().method();
 360         if (method != null) {
 361             if (method.getName().equalsIgnoreCase(math.getOperation().name()) &amp;&amp; tool.getMetaAccess().lookupJavaType(Math.class).equals(method.getDeclaringClass())) {
 362                 // A root compilation of the intrinsic method should emit the full assembly
 363                 // implementation.
 364                 return;
 365             }
 366         }
 367         StructuredGraph graph = math.graph();
 368         ForeignCallNode call = math.graph().add(new ForeignCallNode(foreignCalls, math.getOperation().foreignCallDescriptor, math.getValue()));
 369         graph.addAfterFixed(tool.lastFixedNode(), call);
 370         math.replaceAtUsages(call);
 371     }
 372 
 373     protected void lowerVerifyHeap(VerifyHeapNode n) {
 374         GraphUtil.removeFixedWithUnusedInputs(n);
 375     }
 376 
<span class="line-modified"> 377     public AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {</span>
 378         ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
 379         return graph.unique(new OffsetAddressNode(object, o));
 380     }
 381 
<span class="line-modified"> 382     public AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {</span>
 383         int offset = fieldOffset(field);
 384         if (offset &gt;= 0) {
 385             return createOffsetAddress(graph, object, offset);
 386         } else {
 387             return null;
 388         }
 389     }
 390 
 391     protected abstract JavaKind getStorageKind(ResolvedJavaField field);
 392 
 393     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 394         assert loadField.getStackKind() != JavaKind.Illegal;
 395         StructuredGraph graph = loadField.graph();
 396         ResolvedJavaField field = loadField.field();
 397         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 398         object = createNullCheckedValue(object, loadField, tool);
 399         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 400 
 401         AddressNode address = createFieldAddress(graph, object, field);
 402         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
</pre>
<hr />
<pre>
 600         ValueNode nullHub = ConstantNode.forConstant(hubStamp.asAlwaysNull(), JavaConstant.NULL_POINTER, tool.getMetaAccess(), graph);
 601         final ValueNode nonNullValue = graph.addOrUniqueWithInputs(PiNode.create(value, stamp.asNonNull(), ifNode.falseSuccessor()));
 602         ValueNode hub = createReadHub(graph, nonNullValue, tool);
 603         ValueNode[] values = new ValueNode[]{nullHub, hub};
 604         final PhiNode hubPhi = graph.unique(new ValuePhiNode(hubStamp, merge, values));
 605         final FixedNode oldNext = predecessor.next();
 606         predecessor.setNext(ifNode);
 607         merge.setNext(oldNext);
 608         loadHubOrNullNode.replaceAtUsagesAndDelete(hubPhi);
 609     }
 610 
 611     protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
 612         StructuredGraph graph = loadHub.graph();
 613         ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
 614         graph.replaceFixed(loadHub, hub);
 615     }
 616 
 617     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 618         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 619         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
<span class="line-modified"> 620         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId(), monitorEnter.isBiasable()));</span>
 621         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 622         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 623         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 624     }
 625 
 626     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 627         StructuredGraph graph = cas.graph();
 628         JavaKind valueKind = cas.getValueKind();
 629 
 630         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 631         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 632 
 633         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 634         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
 635         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));
 636         atomicNode.setStateAfter(cas.stateAfter());
 637         graph.replaceFixedWithFixed(cas, atomicNode);
 638     }
 639 
 640     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
</pre>
<hr />
<pre>
 658         JavaKind valueKind = n.getValueKind();
 659 
 660         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 661 
 662         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
 663         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
 664         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
 665         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));
 666         memoryRead.setStateAfter(n.stateAfter());
 667 
 668         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 669         n.stateAfter().replaceFirstInput(n, memoryRead);
 670         n.replaceAtUsages(readValue);
 671         graph.replaceFixedWithFixed(n, memoryRead);
 672     }
 673 
 674     /**
 675      * @param tool utility for performing the lowering
 676      */
 677     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="line-modified"> 678         PlatformConfigurationProvider gc = tool.getProviders().getPlatformConfigurationProvider();</span>
 679         StructuredGraph graph = load.graph();
 680         if (load instanceof GuardedUnsafeLoadNode) {
 681             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 682             GuardingNode guard = guardedLoad.getGuard();
 683             if (guard == null) {
 684                 // can float freely if the guard folded away
 685                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 686                 memoryRead.setForceFixed(false);
 687                 graph.replaceFixedWithFixed(load, memoryRead);
 688             } else {
 689                 // must be guarded, but flows below the guard
 690                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);
 691                 graph.replaceFixedWithFixed(load, memoryRead);
 692             }
 693         } else {
 694             // never had a guarding condition so it must be fixed, creation of the read will force
 695             // it to be fixed
 696             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 697             graph.replaceFixedWithFixed(load, memoryRead);
 698         }
 699     }
 700 
 701     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 702         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 703             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 704         } else {
 705             return graph.unique(new OffsetAddressNode(object, offset));
 706         }
 707     }
 708 
<span class="line-modified"> 709     protected ReadNode createUnsafeRead(PlatformConfigurationProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 710         boolean compressible = load.accessKind() == JavaKind.Object;
 711         JavaKind readKind = load.accessKind();
 712         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 713         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
 714         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));
 715         if (guard == null) {
 716             // An unsafe read must not float otherwise it may float above
 717             // a test guaranteeing the read is safe.
 718             memoryRead.setForceFixed(true);
 719         } else {
 720             memoryRead.setGuard(guard);
 721         }
 722         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 723         load.replaceAtUsages(readValue);
 724         return memoryRead;
 725     }
 726 
 727     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 728         StructuredGraph graph = load.graph();
 729         JavaKind readKind = load.getKind();
</pre>
<hr />
<pre>
 820                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects
 821                     newObject.clearEmitMemoryBarrier();
 822 
 823                     recursiveLowerings.add(newObject);
 824                     graph.addBeforeFixed(commit, newObject);
 825                     allocations[objIndex] = newObject;
 826                     for (int i = 0; i &lt; entryCount; i++) {
 827                         ValueNode value = commit.getValues().get(valuePos);
 828                         if (value instanceof VirtualObjectNode) {
 829                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 830                         }
 831                         if (value == null) {
 832                             omittedValues.set(valuePos);
 833                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 834                             // Constant.illegal is always the defaultForKind, so it is skipped
 835                             JavaKind valueKind = value.getStackKind();
 836                             JavaKind entryKind = virtual.entryKind(i);
 837 
 838                             // Truffle requires some leniency in terms of what can be put where:
 839                             assert valueKind.getStackKind() == entryKind.getStackKind() ||
<span class="line-modified"> 840                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode) ||</span>
<span class="line-added"> 841                                                             (valueKind == JavaKind.Float &amp;&amp; virtual instanceof VirtualArrayNode));</span>
 842                             AddressNode address = null;
 843                             BarrierType barrierType = null;
 844                             if (virtual instanceof VirtualInstanceNode) {
 845                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 846                                 long offset = fieldOffset(field);
 847                                 if (offset &gt;= 0) {
 848                                     address = createOffsetAddress(graph, newObject, offset);
 849                                     barrierType = fieldInitializationBarrier(entryKind);
 850                                 }
 851                             } else {
 852                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
 853                                 barrierType = arrayInitializationBarrier(entryKind);
 854                             }
 855                             if (address != null) {
<span class="line-modified"> 856                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), arrayImplicitStoreConvert(graph, entryKind, value, commit, virtual, valuePos), barrierType, false);</span>
 857                                 graph.addAfterFixed(newObject, graph.add(write));
 858                             }
 859                         }
 860                         valuePos++;
 861                     }
 862                 }
 863             }
 864             valuePos = 0;
 865 
 866             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 867                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 868                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 869                     int entryCount = virtual.entryCount();
 870                     ValueNode newObject = allocations[objIndex];
 871                     for (int i = 0; i &lt; entryCount; i++) {
 872                         if (omittedValues.get(valuePos)) {
 873                             ValueNode value = commit.getValues().get(valuePos);
 874                             assert value instanceof VirtualObjectNode;
 875                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 876                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
</pre>
<hr />
<pre>
 879                                 BarrierType barrierType;
 880                                 if (virtual instanceof VirtualInstanceNode) {
 881                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
 882                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));
 883                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));
 884                                 } else {
 885                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
 886                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));
 887                                 }
 888                                 if (address != null) {
 889                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);
 890                                     graph.addBeforeFixed(commit, graph.add(write));
 891                                 }
 892                             }
 893                         }
 894                         valuePos++;
 895                     }
 896                 }
 897             }
 898 
<span class="line-modified"> 899             finishAllocatedObjects(tool, commit, commit, allocations);</span>
 900             graph.removeFixed(commit);
 901 
 902             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 903                 recursiveLowering.lower(tool);
 904             }
 905         }
 906 
 907     }
 908 
 909     public NewInstanceNode createNewInstanceFromVirtual(VirtualObjectNode virtual) {
 910         return new NewInstanceNode(virtual.type(), true);
 911     }
 912 
 913     protected NewArrayNode createNewArrayFromVirtual(VirtualObjectNode virtual, ValueNode length) {
 914         return new NewArrayNode(((VirtualArrayNode) virtual).componentType(), length, true);
 915     }
 916 
<span class="line-modified"> 917     public void finishAllocatedObjects(LoweringTool tool, FixedWithNextNode insertAfter, CommitAllocationNode commit, ValueNode[] allocations) {</span>
<span class="line-added"> 918         FixedWithNextNode insertionPoint = insertAfter;</span>
 919         StructuredGraph graph = commit.graph();
 920         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 921             FixedValueAnchorNode anchor = graph.add(new FixedValueAnchorNode(allocations[objIndex]));
 922             allocations[objIndex] = anchor;
<span class="line-modified"> 923             graph.addAfterFixed(insertionPoint, anchor);</span>
<span class="line-added"> 924             insertionPoint = anchor;</span>
 925         }
 926         /*
 927          * Note that the FrameState that is assigned to these MonitorEnterNodes isn&#39;t the correct
 928          * state. It will be the state from before the allocation occurred instead of a valid state
 929          * after the locking is performed. In practice this should be fine since these are newly
 930          * allocated objects. The bytecodes themselves permit allocating an object, doing a
 931          * monitorenter and then dropping all references to the object which would produce the same
 932          * state, though that would normally produce an IllegalMonitorStateException. In HotSpot
 933          * some form of fast path locking should always occur so the FrameState should never
 934          * actually be used.
 935          */
 936         ArrayList&lt;MonitorEnterNode&gt; enters = null;
 937         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 938             List&lt;MonitorIdNode&gt; locks = commit.getLocks(objIndex);
 939             if (locks.size() &gt; 1) {
 940                 // Ensure that the lock operations are performed in lock depth order
 941                 ArrayList&lt;MonitorIdNode&gt; newList = new ArrayList&lt;&gt;(locks);
 942                 newList.sort((a, b) -&gt; Integer.compare(a.getLockDepth(), b.getLockDepth()));
 943                 locks = newList;
 944             }
 945             int lastDepth = -1;
 946             for (MonitorIdNode monitorId : locks) {
 947                 assert lastDepth &lt; monitorId.getLockDepth();
 948                 lastDepth = monitorId.getLockDepth();
 949                 MonitorEnterNode enter = graph.add(new MonitorEnterNode(allocations[objIndex], monitorId));
<span class="line-modified"> 950                 graph.addAfterFixed(insertionPoint, enter);</span>
<span class="line-added"> 951                 insertionPoint = enter;</span>
 952                 if (enters == null) {
 953                     enters = new ArrayList&lt;&gt;();
 954                 }
 955                 enters.add(enter);
 956             }
 957         }
 958         for (Node usage : commit.usages().snapshot()) {
 959             if (usage instanceof AllocatedObjectNode) {
 960                 AllocatedObjectNode addObject = (AllocatedObjectNode) usage;
 961                 int index = commit.getVirtualObjects().indexOf(addObject.getVirtualObject());
 962                 addObject.replaceAtUsagesAndDelete(allocations[index]);
 963             } else {
 964                 assert enters != null;
 965                 commit.replaceAtUsages(InputType.Memory, enters.get(enters.size() - 1));
 966             }
 967         }
 968         if (enters != null) {
 969             for (MonitorEnterNode enter : enters) {
 970                 enter.lower(tool);
 971             }
 972         }
 973         assert commit.hasNoUsages();
<span class="line-modified"> 974         insertAllocationBarrier(insertAfter, commit, graph);</span>
 975     }
 976 
 977     /**
 978      * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
 979      * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
 980      * are being written, as if {@link FinalFieldBarrierNode} were emitted.
 981      */
<span class="line-modified"> 982     private static void insertAllocationBarrier(FixedWithNextNode insertAfter, CommitAllocationNode commit, StructuredGraph graph) {</span>
 983         int barrier = MemoryBarriers.STORE_STORE;
 984         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 985             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 986                 if (field.isFinal()) {
 987                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 988                     break outer;
 989                 }
 990             }
 991         }
<span class="line-modified"> 992         graph.addAfterFixed(insertAfter, graph.add(new MembarNode(barrier, LocationIdentity.init())));</span>
 993     }
 994 
 995     /**
 996      * @param field the field whose barrier type should be returned
 997      */
<span class="line-modified"> 998     public BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
 999         return BarrierType.NONE;
1000     }
1001 
<span class="line-modified">1002     public BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
1003         if (getStorageKind(field) == JavaKind.Object) {
1004             return BarrierType.FIELD;
1005         }
1006         return BarrierType.NONE;
1007     }
1008 
<span class="line-modified">1009     public BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
1010         if (elementKind == JavaKind.Object) {
1011             return BarrierType.ARRAY;
1012         }
1013         return BarrierType.NONE;
1014     }
1015 
1016     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
1017         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;
1018     }
1019 
1020     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
1021         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;
1022     }
1023 
1024     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
1025         if (!store.needsBarrier()) {
1026             return BarrierType.NONE;
1027         }
1028         return guessStoreBarrierType(store.object(), store.value());
1029     }
</pre>
<hr />
<pre>
1103 
1104     /**
1105      * @param compressible whether the convert should be compressible
1106      */
1107     protected ValueNode implicitLoadConvert(JavaKind kind, ValueNode value, boolean compressible) {
1108         if (useCompressedOops(kind, compressible)) {
1109             return newCompressionNode(CompressionOp.Uncompress, value);
1110         }
1111 
1112         switch (kind) {
1113             case Byte:
1114             case Short:
1115                 return new SignExtendNode(value, 32);
1116             case Boolean:
1117             case Char:
1118                 return new ZeroExtendNode(value, 32);
1119         }
1120         return value;
1121     }
1122 
<span class="line-added">1123     public ValueNode arrayImplicitStoreConvert(StructuredGraph graph,</span>
<span class="line-added">1124                     JavaKind entryKind,</span>
<span class="line-added">1125                     ValueNode value,</span>
<span class="line-added">1126                     CommitAllocationNode commit,</span>
<span class="line-added">1127                     VirtualObjectNode virtual,</span>
<span class="line-added">1128                     int valuePos) {</span>
<span class="line-added">1129         if (!virtual.isVirtualByteArray()) {</span>
<span class="line-added">1130             return implicitStoreConvert(graph, entryKind, value);</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         // A virtual entry in a byte array can span multiple bytes. This shortens the entry to fit</span>
<span class="line-added">1133         // in its declared size.</span>
<span class="line-added">1134         int entryIndex = valuePos + 1;</span>
<span class="line-added">1135         int bytes = 1;</span>
<span class="line-added">1136         while (entryIndex &lt; commit.getValues().size() &amp;&amp; commit.getValues().get(entryIndex).isIllegalConstant()) {</span>
<span class="line-added">1137             bytes++;</span>
<span class="line-added">1138             entryIndex++;</span>
<span class="line-added">1139         }</span>
<span class="line-added">1140         assert bytes &lt;= value.getStackKind().getByteCount();</span>
<span class="line-added">1141         ValueNode entry = value;</span>
<span class="line-added">1142         if (value.getStackKind() == JavaKind.Float) {</span>
<span class="line-added">1143             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Int, entry, NodeView.DEFAULT));</span>
<span class="line-added">1144         } else if (value.getStackKind() == JavaKind.Double) {</span>
<span class="line-added">1145             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Long, entry, NodeView.DEFAULT));</span>
<span class="line-added">1146         }</span>
<span class="line-added">1147         if (bytes &lt; value.getStackKind().getByteCount()) {</span>
<span class="line-added">1148             entry = graph.unique(new NarrowNode(entry, bytes &lt;&lt; 3));</span>
<span class="line-added">1149         }</span>
<span class="line-added">1150         return entry;</span>
<span class="line-added">1151     }</span>
<span class="line-added">1152 </span>
1153     public final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value) {
1154         return implicitStoreConvert(graph, kind, value, true);
1155     }
1156 
1157     public ValueNode implicitStoreConvert(JavaKind kind, ValueNode value) {
1158         return implicitStoreConvert(kind, value, true);
1159     }
1160 
1161     protected final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value, boolean compressible) {
1162         ValueNode ret = implicitStoreConvert(kind, value, compressible);
1163         if (!ret.isAlive()) {
1164             ret = graph.addOrUnique(ret);
1165         }
1166         return ret;
1167     }
1168 
1169     /**
1170      * @param compressible whether the covert should be compressible
1171      */
1172     protected ValueNode implicitStoreConvert(JavaKind kind, ValueNode value, boolean compressible) {
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/PointerTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeIntrinsificationProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
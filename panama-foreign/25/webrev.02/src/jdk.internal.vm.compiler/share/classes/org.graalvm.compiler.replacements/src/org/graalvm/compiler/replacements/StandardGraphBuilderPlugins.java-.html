<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/StandardGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.code.MemoryBarriers.LOAD_LOAD;
  32 import static jdk.vm.ci.code.MemoryBarriers.LOAD_STORE;
  33 import static jdk.vm.ci.code.MemoryBarriers.STORE_LOAD;
  34 import static jdk.vm.ci.code.MemoryBarriers.STORE_STORE;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.OFF_HEAP_LOCATION;
  36 
  37 import java.lang.reflect.Array;
  38 import java.lang.reflect.Field;
  39 import java.util.Arrays;
  40 
  41 import org.graalvm.compiler.api.directives.GraalDirectives;
  42 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  43 import org.graalvm.compiler.core.common.calc.Condition;
  44 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
  45 import org.graalvm.compiler.core.common.calc.UnsignedMath;
  46 import org.graalvm.compiler.core.common.type.ObjectStamp;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.core.common.type.StampFactory;
  49 import org.graalvm.compiler.core.common.type.TypeReference;
  50 import org.graalvm.compiler.debug.GraalError;
  51 import org.graalvm.compiler.graph.Edges;
  52 import org.graalvm.compiler.graph.Node;
  53 import org.graalvm.compiler.graph.NodeList;
  54 import org.graalvm.compiler.nodes.AbstractBeginNode;
  55 import org.graalvm.compiler.nodes.BeginNode;
  56 import org.graalvm.compiler.nodes.ConstantNode;
  57 import org.graalvm.compiler.nodes.DeoptimizeNode;
  58 import org.graalvm.compiler.nodes.EndNode;
  59 import org.graalvm.compiler.nodes.FixedGuardNode;
  60 import org.graalvm.compiler.nodes.FixedWithNextNode;
  61 import org.graalvm.compiler.nodes.IfNode;
  62 import org.graalvm.compiler.nodes.LogicNode;
  63 import org.graalvm.compiler.nodes.MergeNode;
  64 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  65 import org.graalvm.compiler.nodes.NodeView;
  66 import org.graalvm.compiler.nodes.StateSplit;
  67 import org.graalvm.compiler.nodes.StructuredGraph;
  68 import org.graalvm.compiler.nodes.ValueNode;
  69 import org.graalvm.compiler.nodes.ValuePhiNode;
  70 import org.graalvm.compiler.nodes.calc.AbsNode;
  71 import org.graalvm.compiler.nodes.calc.CompareNode;
  72 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  73 import org.graalvm.compiler.nodes.calc.FloatEqualsNode;
  74 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  75 import org.graalvm.compiler.nodes.calc.IsNullNode;
  76 import org.graalvm.compiler.nodes.calc.NarrowNode;
  77 import org.graalvm.compiler.nodes.calc.ReinterpretNode;
  78 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  79 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  80 import org.graalvm.compiler.nodes.calc.SqrtNode;
  81 import org.graalvm.compiler.nodes.calc.UnsignedDivNode;
  82 import org.graalvm.compiler.nodes.calc.UnsignedRemNode;
  83 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  84 import org.graalvm.compiler.nodes.debug.BindToRegisterNode;
  85 import org.graalvm.compiler.nodes.debug.BlackholeNode;
  86 import org.graalvm.compiler.nodes.debug.ControlFlowAnchorNode;
  87 import org.graalvm.compiler.nodes.debug.SideEffectNode;
  88 import org.graalvm.compiler.nodes.debug.SpillRegistersNode;
  89 import org.graalvm.compiler.nodes.extended.BoxNode;
  90 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
  91 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
  92 import org.graalvm.compiler.nodes.extended.GetClassNode;
  93 import org.graalvm.compiler.nodes.extended.GuardingNode;
  94 import org.graalvm.compiler.nodes.extended.JavaReadNode;
  95 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
  96 import org.graalvm.compiler.nodes.extended.MembarNode;
  97 import org.graalvm.compiler.nodes.extended.OpaqueNode;
  98 import org.graalvm.compiler.nodes.extended.RawLoadNode;
  99 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 100 import org.graalvm.compiler.nodes.extended.UnboxNode;
 101 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 102 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 103 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 104 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 105 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 106 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 107 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 108 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
 109 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
 110 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
 111 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 112 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 113 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 114 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 115 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 116 import org.graalvm.compiler.nodes.memory.HeapAccess;
 117 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 118 import org.graalvm.compiler.nodes.spi.Replacements;
 119 import org.graalvm.compiler.nodes.type.StampTool;
 120 import org.graalvm.compiler.nodes.util.GraphUtil;
 121 import org.graalvm.compiler.nodes.virtual.EnsureVirtualizedNode;
 122 import org.graalvm.compiler.replacements.nodes.ProfileBooleanNode;
 123 import org.graalvm.compiler.replacements.nodes.ReverseBytesNode;
 124 import org.graalvm.compiler.replacements.nodes.VirtualizableInvokeMacroNode;
 125 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactNode;
 126 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactOverflowNode;
 127 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerAddExactSplitNode;
 128 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerExactArithmeticSplitNode;
 129 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactNode;
 130 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactOverflowNode;
 131 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerMulExactSplitNode;
 132 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactNode;
 133 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactOverflowNode;
 134 import org.graalvm.compiler.replacements.nodes.arithmetic.IntegerSubExactSplitNode;
 135 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 136 import org.graalvm.compiler.serviceprovider.SpeculationReasonGroup;
 137 import jdk.internal.vm.compiler.word.LocationIdentity;
 138 
 139 import jdk.vm.ci.code.BytecodePosition;
 140 import jdk.vm.ci.meta.DeoptimizationAction;
 141 import jdk.vm.ci.meta.DeoptimizationReason;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.MetaAccessProvider;
 145 import jdk.vm.ci.meta.ResolvedJavaField;
 146 import jdk.vm.ci.meta.ResolvedJavaMethod;
 147 import jdk.vm.ci.meta.ResolvedJavaType;
 148 import jdk.vm.ci.meta.SpeculationLog;
 149 import jdk.vm.ci.meta.SpeculationLog.Speculation;
 150 import jdk.vm.ci.meta.SpeculationLog.SpeculationReason;
 151 import sun.misc.Unsafe;
 152 
 153 /**
 154  * Provides non-runtime specific {@link InvocationPlugin}s.
 155  */
 156 public class StandardGraphBuilderPlugins {
 157 
 158     public static void registerInvocationPlugins(MetaAccessProvider metaAccess, SnippetReflectionProvider snippetReflection, InvocationPlugins plugins, Replacements replacements,
 159                     boolean allowDeoptimization, boolean explicitUnsafeNullChecks, boolean arrayEqualsSubstitution) {
 160         registerObjectPlugins(plugins);
 161         registerClassPlugins(plugins);
 162         registerMathPlugins(plugins, allowDeoptimization);
 163         registerStrictMathPlugins(plugins);
 164         registerUnsignedMathPlugins(plugins);
 165         registerStringPlugins(plugins, replacements, snippetReflection, arrayEqualsSubstitution);
 166         registerCharacterPlugins(plugins);
 167         registerShortPlugins(plugins);
 168         registerIntegerLongPlugins(plugins, JavaKind.Int);
 169         registerIntegerLongPlugins(plugins, JavaKind.Long);
 170         registerFloatPlugins(plugins);
 171         registerDoublePlugins(plugins);
 172         if (arrayEqualsSubstitution) {
 173             registerArraysPlugins(plugins, replacements);
 174         }
 175         registerArrayPlugins(plugins, replacements);
 176         registerUnsafePlugins(plugins, replacements, explicitUnsafeNullChecks);
 177         registerEdgesPlugins(metaAccess, plugins);
 178         registerGraalDirectivesPlugins(plugins);
 179         registerBoxingPlugins(plugins);
 180         registerJMHBlackholePlugins(plugins, replacements);
 181         registerJFRThrowablePlugins(plugins, replacements);
 182         registerMethodHandleImplPlugins(plugins, snippetReflection, replacements);
 183         registerJcovCollectPlugins(plugins, replacements);
 184     }
 185 
 186     private static final Field STRING_VALUE_FIELD;
 187     private static final Field STRING_CODER_FIELD;
 188 
 189     static {
 190         Field coder = null;
 191         try {
 192             STRING_VALUE_FIELD = String.class.getDeclaredField(&quot;value&quot;);
 193             if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 194                 coder = String.class.getDeclaredField(&quot;coder&quot;);
 195             }
 196         } catch (NoSuchFieldException e) {
 197             throw new GraalError(e);
 198         }
 199         STRING_CODER_FIELD = coder;
 200     }
 201 
 202     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements, SnippetReflectionProvider snippetReflection, boolean arrayEqualsSubstitution) {
 203         final Registration r = new Registration(plugins, String.class, replacements);
 204         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
 205             @Override
 206             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 207                 if (receiver.isConstant()) {
 208                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 209                     if (s != null) {
 210                         b.addPush(JavaKind.Int, b.add(ConstantNode.forInt(s.hashCode())));
 211                         return true;
 212                     }
 213                 }
 214                 return false;
 215             }
 216         });
 217         r.register1(&quot;intern&quot;, Receiver.class, new InvocationPlugin() {
 218             @Override
 219             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 220                 if (receiver.isConstant()) {
 221                     String s = snippetReflection.asObject(String.class, (JavaConstant) receiver.get().asConstant());
 222                     if (s != null) {
 223                         JavaConstant interned = snippetReflection.forObject(s.intern());
 224                         b.addPush(JavaKind.Object, b.add(ConstantNode.forConstant(interned, b.getMetaAccess(), b.getGraph())));
 225                         return true;
 226                     }
 227                 }
 228                 return false;
 229             }
 230         });
 231 
 232         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
 233             if (arrayEqualsSubstitution) {
 234                 r.registerMethodSubstitution(StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 235             }
 236 
 237             r.register7(&quot;indexOf&quot;, char[].class, int.class, int.class, char[].class, int.class, int.class, int.class, new StringIndexOfConstantPlugin());
 238 
 239             Registration sr = new Registration(plugins, StringSubstitutions.class);
 240             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 241                 @Override
 242                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 243                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 244                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 245                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 246                     return true;
 247                 }
 248             });
 249         } else {
 250             if (arrayEqualsSubstitution) {
 251                 r.registerMethodSubstitution(JDK9StringSubstitutions.class, &quot;equals&quot;, Receiver.class, Object.class);
 252             }
 253             Registration utf16sub = new Registration(plugins, StringUTF16Substitutions.class, replacements);
 254             utf16sub.register2(&quot;getCharDirect&quot;, byte[].class, int.class, new InvocationPlugin() {
 255                 @Override
 256                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2) {
 257                     b.addPush(JavaKind.Char, new JavaReadNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte),
 258                                     HeapAccess.BarrierType.NONE, false));
 259                     return true;
 260                 }
 261             });
 262             utf16sub.register3(&quot;putCharDirect&quot;, byte[].class, int.class, int.class, new InvocationPlugin() {
 263                 @Override
 264                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode arg1, ValueNode arg2, ValueNode arg3) {
 265                     b.add(new JavaWriteNode(JavaKind.Char, new IndexAddressNode(arg1, arg2, JavaKind.Byte), NamedLocationIdentity.getArrayLocation(JavaKind.Byte), arg3,
 266                                     HeapAccess.BarrierType.NONE, false));
 267                     return true;
 268                 }
 269             });
 270 
 271             final Registration latin1r = new Registration(plugins, &quot;java.lang.StringLatin1&quot;, replacements);
 272             latin1r.register5(&quot;indexOf&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringLatin1IndexOfConstantPlugin());
 273 
 274             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
 275             utf16r.register5(&quot;indexOfUnsafe&quot;, byte[].class, int.class, byte[].class, int.class, int.class, new StringUTF16IndexOfConstantPlugin());
 276             utf16r.setAllowOverwrite(true);
 277             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChar&quot;, byte[].class, int.class);
 278             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;putChar&quot;, byte[].class, int.class, int.class);
 279 
 280             Registration sr = new Registration(plugins, JDK9StringSubstitutions.class);
 281             sr.register1(&quot;getValue&quot;, String.class, new InvocationPlugin() {
 282                 @Override
 283                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 284                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_VALUE_FIELD);
 285                     b.addPush(JavaKind.Object, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 286                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 287                     return true;
 288                 }
 289             });
 290             sr.register1(&quot;getCoder&quot;, String.class, new InvocationPlugin() {
 291                 @Override
 292                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 293                     ResolvedJavaField field = b.getMetaAccess().lookupJavaField(STRING_CODER_FIELD);
 294                     b.addPush(JavaKind.Int, LoadFieldNode.create(b.getConstantFieldProvider(), b.getConstantReflection(), b.getMetaAccess(),
 295                                     b.getOptions(), b.getAssumptions(), value, field, false, false));
 296                     return true;
 297                 }
 298             });
 299         }
 300     }
 301 
 302     private static void registerArraysPlugins(InvocationPlugins plugins, Replacements replacements) {
 303         Registration r = new Registration(plugins, Arrays.class, replacements);
 304         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, boolean[].class, boolean[].class);
 305         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, byte[].class, byte[].class);
 306         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, short[].class, short[].class);
 307         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, char[].class, char[].class);
 308         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, int[].class, int[].class);
 309         r.registerMethodSubstitution(ArraysSubstitutions.class, &quot;equals&quot;, long[].class, long[].class);
 310     }
 311 
 312     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
 313         Registration r = new Registration(plugins, Array.class, replacements);
 314         r.register2(&quot;newInstance&quot;, Class.class, int.class, new InvocationPlugin() {
 315             @Override
 316             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unused, ValueNode componentType, ValueNode length) {
 317                 b.addPush(JavaKind.Object, new DynamicNewArrayNode(componentType, length, true));
 318                 return true;
 319             }
 320         });
 321         r.registerMethodSubstitution(ArraySubstitutions.class, &quot;getLength&quot;, Object.class);
 322     }
 323 
 324     /**
 325      * The intrinsic for {@link Math#sqrt(double)} is shared with {@link StrictMath#sqrt(double)}.
 326      *
 327      * @see &quot;http://hg.openjdk.java.net/jdk/jdk/file/621efe32eb0b/src/hotspot/share/oops/method.cpp#l1504&quot;
 328      */
 329     static final class MathSqrtPlugin implements InvocationPlugin {
 330         @Override
 331         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 332             b.push(JavaKind.Double, b.append(SqrtNode.create(value, NodeView.DEFAULT)));
 333             return true;
 334         }
 335     }
 336 
 337     private abstract static class UnsafeCompareAndUpdatePluginsRegistrar {
 338         public void register(Registration r, String casPrefix, boolean explicitUnsafeNullChecks, JavaKind[] compareAndSwapTypes, boolean java11OrEarlier) {
 339             for (JavaKind kind : compareAndSwapTypes) {
 340                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 341                 String kindName = (kind == JavaKind.Object &amp;&amp; !java11OrEarlier) ? &quot;Reference&quot; : kind.name();
 342                 r.register5(casPrefix + kindName, Receiver.class, Object.class, long.class, javaClass, javaClass, new UnsafeAccessPlugin(returnKind(kind), explicitUnsafeNullChecks) {
 343                     @Override
 344                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode expected, ValueNode x) {
 345                         // Emits a null-check for the otherwise unused receiver
 346                         unsafe.get();
 347                         createUnsafeAccess(object, b, (obj, loc) -&gt; UnsafeCompareAndUpdatePluginsRegistrar.this.createNode(obj, offset, expected, x, kind, loc));
 348                         return true;
 349                     }
 350                 });
 351             }
 352         }
 353 
 354         public abstract FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity);
 355 
 356         public abstract JavaKind returnKind(JavaKind accessKind);
 357     }
 358 
 359     private static class UnsafeCompareAndSwapPluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 360         @Override
 361         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 362             return new UnsafeCompareAndSwapNode(object, offset, expected, newValue, kind, identity);
 363         }
 364 
 365         @Override
 366         public JavaKind returnKind(JavaKind accessKind) {
 367             return JavaKind.Boolean.getStackKind();
 368         }
 369     }
 370 
 371     private static UnsafeCompareAndSwapPluginsRegistrar unsafeCompareAndSwapPluginsRegistrar = new UnsafeCompareAndSwapPluginsRegistrar();
 372 
 373     private static class UnsafeCompareAndExchangePluginsRegistrar extends UnsafeCompareAndUpdatePluginsRegistrar {
 374         @Override
 375         public FixedWithNextNode createNode(ValueNode object, ValueNode offset, ValueNode expected, ValueNode newValue, JavaKind kind, LocationIdentity identity) {
 376             return new UnsafeCompareAndExchangeNode(object, offset, expected, newValue, kind, identity);
 377         }
 378 
 379         @Override
 380         public JavaKind returnKind(JavaKind accessKind) {
 381             if (accessKind.isNumericInteger()) {
 382                 return accessKind.getStackKind();
 383             } else {
 384                 return accessKind;
 385             }
 386         }
 387     }
 388 
 389     private static UnsafeCompareAndExchangePluginsRegistrar unsafeCompareAndExchangePluginsRegistrar = new UnsafeCompareAndExchangePluginsRegistrar();
 390 
 391     public static void registerPlatformSpecificUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks, JavaKind[] supportedCasKinds) {
 392         registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 393         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 394             registerPlatformSpecificUnsafePlugins(supportedCasKinds, new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);
 395         }
 396 
 397     }
 398 
 399     private static void registerPlatformSpecificUnsafePlugins(JavaKind[] supportedCasKinds, Registration r, boolean java8OrEarlier, boolean explicitUnsafeNullChecks) {
 400         if (java8OrEarlier) {
 401             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSwap&quot;, explicitUnsafeNullChecks, new JavaKind[]{JavaKind.Int, JavaKind.Long, JavaKind.Object}, true);
 402         } else {
 403             unsafeCompareAndSwapPluginsRegistrar.register(r, &quot;compareAndSet&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);
 404             unsafeCompareAndExchangePluginsRegistrar.register(r, &quot;compareAndExchange&quot;, explicitUnsafeNullChecks, supportedCasKinds, JavaVersionUtil.JAVA_SPEC &lt;= 11);
 405         }
 406     }
 407 
 408     private static void registerUnsafePlugins(InvocationPlugins plugins, Replacements replacements, boolean explicitUnsafeNullChecks) {
 409         registerUnsafePlugins(new Registration(plugins, Unsafe.class), true, explicitUnsafeNullChecks);
 410         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
 411             registerUnsafePlugins(new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements), false, explicitUnsafeNullChecks);
 412         }
 413     }
 414 
 415     private static void registerUnsafePlugins(Registration r, boolean sunMiscUnsafe, boolean explicitUnsafeNullChecks) {
 416         for (JavaKind kind : JavaKind.values()) {
 417             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
 418                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
 419                 String kindName = (kind == JavaKind.Object &amp;&amp; !sunMiscUnsafe &amp;&amp; !(JavaVersionUtil.JAVA_SPEC &lt;= 11)) ? &quot;Reference&quot; : kind.name();
 420                 String getName = &quot;get&quot; + kindName;
 421                 String putName = &quot;put&quot; + kindName;
 422                 // Object-based accesses
 423                 r.register3(getName, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 424                 r.register4(putName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 425                 // Volatile object-based accesses
 426                 r.register3(getName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 427                 r.register4(putName + &quot;Volatile&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.VOLATILE, explicitUnsafeNullChecks));
 428                 // Ordered object-based accesses
 429                 if (sunMiscUnsafe) {
 430                     if (kind == JavaKind.Int || kind == JavaKind.Long || kind == JavaKind.Object) {
 431                         r.register4(&quot;putOrdered&quot; + kindName, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 432                     }
 433                 } else {
 434                     r.register4(&quot;put&quot; + kindName + &quot;Release&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 435                     r.register3(&quot;get&quot; + kindName + &quot;Acquire&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.RELEASE_ACQUIRE, explicitUnsafeNullChecks));
 436                     r.register4(&quot;put&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, javaClass, new UnsafePutPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 437                     r.register3(&quot;get&quot; + kindName + &quot;Opaque&quot;, Receiver.class, Object.class, long.class, new UnsafeGetPlugin(kind, AccessKind.OPAQUE, explicitUnsafeNullChecks));
 438                 }
 439                 if (kind != JavaKind.Boolean &amp;&amp; kind != JavaKind.Object) {
 440                     // Raw accesses to memory addresses
 441                     r.register2(getName, Receiver.class, long.class, new UnsafeGetPlugin(kind, explicitUnsafeNullChecks));
 442                     r.register3(putName, Receiver.class, long.class, kind.toJavaClass(), new UnsafePutPlugin(kind, explicitUnsafeNullChecks));
 443                 }
 444             }
 445         }
 446 
 447         // Accesses to native memory addresses.
 448         r.register2(&quot;getAddress&quot;, Receiver.class, long.class, new UnsafeGetPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 449         r.register3(&quot;putAddress&quot;, Receiver.class, long.class, long.class, new UnsafePutPlugin(JavaKind.Long, explicitUnsafeNullChecks));
 450 
 451         r.register2(&quot;allocateInstance&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 452 
 453             @Override
 454             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode clazz) {
 455                 // Emits a null-check for the otherwise unused receiver
 456                 unsafe.get();
 457                 b.addPush(JavaKind.Object, new DynamicNewInstanceNode(b.nullCheckedValue(clazz, DeoptimizationAction.None), true));
 458                 return true;
 459             }
 460 
 461         });
 462 
 463         r.register1(&quot;loadFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | LOAD_STORE));
 464         r.register1(&quot;storeFence&quot;, Receiver.class, new UnsafeFencePlugin(STORE_STORE | LOAD_STORE));
 465         r.register1(&quot;fullFence&quot;, Receiver.class, new UnsafeFencePlugin(LOAD_LOAD | STORE_STORE | LOAD_STORE | STORE_LOAD));
 466     }
 467 
 468     private static void registerIntegerLongPlugins(InvocationPlugins plugins, JavaKind kind) {
 469         Class&lt;?&gt; declaringClass = kind.toBoxedJavaClass();
 470         Class&lt;?&gt; type = kind.toJavaClass();
 471         Registration r = new Registration(plugins, declaringClass);
 472         r.register1(&quot;reverseBytes&quot;, type, new InvocationPlugin() {
 473             @Override
 474             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 475                 b.push(kind, b.append(new ReverseBytesNode(value).canonical(null)));
 476                 return true;
 477             }
 478         });
 479         r.register2(&quot;divideUnsigned&quot;, type, type, new InvocationPlugin() {
 480             @Override
 481             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 482                 b.push(kind, b.append(UnsignedDivNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 483                 return true;
 484             }
 485         });
 486         r.register2(&quot;remainderUnsigned&quot;, type, type, new InvocationPlugin() {
 487             @Override
 488             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode dividend, ValueNode divisor) {
 489                 b.push(kind, b.append(UnsignedRemNode.create(dividend, divisor, null, NodeView.DEFAULT)));
 490                 return true;
 491             }
 492         });
 493     }
 494 
 495     private static void registerCharacterPlugins(InvocationPlugins plugins) {
 496         Registration r = new Registration(plugins, Character.class);
 497         r.register1(&quot;reverseBytes&quot;, char.class, new InvocationPlugin() {
 498             @Override
 499             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 500                 // return (char) (Integer.reverse(i) &gt;&gt; 16);
 501                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 502                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 503                 ZeroExtendNode charCast = b.add(new ZeroExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 504                 b.push(JavaKind.Char, b.append(charCast.canonical(null)));
 505                 return true;
 506             }
 507         });
 508     }
 509 
 510     private static void registerShortPlugins(InvocationPlugins plugins) {
 511         Registration r = new Registration(plugins, Short.class);
 512         r.register1(&quot;reverseBytes&quot;, short.class, new InvocationPlugin() {
 513             @Override
 514             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 515                 // return (short) (Integer.reverse(i) &gt;&gt; 16);
 516                 ReverseBytesNode reverse = b.add(new ReverseBytesNode(value));
 517                 RightShiftNode rightShift = b.add(new RightShiftNode(reverse, b.add(ConstantNode.forInt(16))));
 518                 SignExtendNode charCast = b.add(new SignExtendNode(b.add(new NarrowNode(rightShift, 16)), 32));
 519                 b.push(JavaKind.Short, b.append(charCast.canonical(null)));
 520                 return true;
 521             }
 522         });
 523     }
 524 
 525     private static void registerFloatPlugins(InvocationPlugins plugins) {
 526         Registration r = new Registration(plugins, Float.class);
 527         r.register1(&quot;floatToRawIntBits&quot;, float.class, new InvocationPlugin() {
 528             @Override
 529             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 530                 b.push(JavaKind.Int, b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT)));
 531                 return true;
 532             }
 533         });
 534         r.register1(&quot;floatToIntBits&quot;, float.class, new InvocationPlugin() {
 535             @Override
 536             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 537                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 538                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Int, value, NodeView.DEFAULT));
 539                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forInt(0x7fc00000), NodeView.DEFAULT));
 540                 b.push(JavaKind.Int, result);
 541                 return true;
 542             }
 543         });
 544         r.register1(&quot;intBitsToFloat&quot;, int.class, new InvocationPlugin() {
 545             @Override
 546             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 547                 b.push(JavaKind.Float, b.append(ReinterpretNode.create(JavaKind.Float, value, NodeView.DEFAULT)));
 548                 return true;
 549             }
 550         });
 551     }
 552 
 553     private static void registerDoublePlugins(InvocationPlugins plugins) {
 554         Registration r = new Registration(plugins, Double.class);
 555         r.register1(&quot;doubleToRawLongBits&quot;, double.class, new InvocationPlugin() {
 556             @Override
 557             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 558                 b.push(JavaKind.Long, b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT)));
 559                 return true;
 560             }
 561         });
 562         r.register1(&quot;doubleToLongBits&quot;, double.class, new InvocationPlugin() {
 563             @Override
 564             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 565                 LogicNode notNan = b.append(FloatEqualsNode.create(value, value, NodeView.DEFAULT));
 566                 ValueNode raw = b.append(ReinterpretNode.create(JavaKind.Long, value, NodeView.DEFAULT));
 567                 ValueNode result = b.append(ConditionalNode.create(notNan, raw, ConstantNode.forLong(0x7ff8000000000000L), NodeView.DEFAULT));
 568                 b.push(JavaKind.Long, result);
 569                 return true;
 570             }
 571         });
 572         r.register1(&quot;longBitsToDouble&quot;, long.class, new InvocationPlugin() {
 573             @Override
 574             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 575                 b.push(JavaKind.Double, b.append(ReinterpretNode.create(JavaKind.Double, value, NodeView.DEFAULT)));
 576                 return true;
 577             }
 578         });
 579     }
 580 
 581     public enum IntegerExactOp {
 582         INTEGER_ADD_EXACT,
 583         INTEGER_INCREMENT_EXACT,
 584         INTEGER_SUBTRACT_EXACT,
 585         INTEGER_DECREMENT_EXACT,
 586         INTEGER_MULTIPLY_EXACT
 587     }
 588 
 589     private static GuardingNode createIntegerExactArithmeticGuardNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 590         LogicNode overflowCheck;
 591         switch (op) {
 592             case INTEGER_ADD_EXACT:
 593             case INTEGER_INCREMENT_EXACT: {
 594                 overflowCheck = new IntegerAddExactOverflowNode(x, y);
 595                 break;
 596             }
 597             case INTEGER_SUBTRACT_EXACT:
 598             case INTEGER_DECREMENT_EXACT: {
 599                 overflowCheck = new IntegerSubExactOverflowNode(x, y);
 600                 break;
 601             }
 602             case INTEGER_MULTIPLY_EXACT: {
 603                 overflowCheck = new IntegerMulExactOverflowNode(x, y);
 604                 break;
 605             }
 606             default:
 607                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 608         }
 609         return b.add(new FixedGuardNode(overflowCheck, DeoptimizationReason.ArithmeticException, DeoptimizationAction.InvalidateRecompile, true));
 610     }
 611 
 612     private static ValueNode createIntegerExactArithmeticNode(GraphBuilderContext b, ValueNode x, ValueNode y, IntegerExactOp op) {
 613         switch (op) {
 614             case INTEGER_ADD_EXACT:
 615             case INTEGER_INCREMENT_EXACT:
 616                 return new IntegerAddExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 617             case INTEGER_SUBTRACT_EXACT:
 618             case INTEGER_DECREMENT_EXACT:
 619                 return new IntegerSubExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 620             case INTEGER_MULTIPLY_EXACT:
 621                 return new IntegerMulExactNode(x, y, createIntegerExactArithmeticGuardNode(b, x, y, op));
 622             default:
 623                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 624         }
 625     }
 626 
 627     private static IntegerExactArithmeticSplitNode createIntegerExactSplit(ValueNode x, ValueNode y, AbstractBeginNode exceptionEdge, IntegerExactOp op) {
 628         switch (op) {
 629             case INTEGER_ADD_EXACT:
 630             case INTEGER_INCREMENT_EXACT:
 631                 return new IntegerAddExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 632             case INTEGER_SUBTRACT_EXACT:
 633             case INTEGER_DECREMENT_EXACT:
 634                 return new IntegerSubExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 635             case INTEGER_MULTIPLY_EXACT:
 636                 return new IntegerMulExactSplitNode(x.stamp(NodeView.DEFAULT).unrestricted(), x, y, null, exceptionEdge);
 637             default:
 638                 throw GraalError.shouldNotReachHere(&quot;Unknown integer exact operation.&quot;);
 639         }
 640     }
 641 
 642     private static void createIntegerExactOperation(GraphBuilderContext b, JavaKind kind, ValueNode x, ValueNode y, IntegerExactOp op) {
 643         if (b.needsExplicitException()) {
 644             BytecodeExceptionKind exceptionKind = kind == JavaKind.Int ? BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW : BytecodeExceptionKind.LONG_EXACT_OVERFLOW;
 645             AbstractBeginNode exceptionEdge = b.genExplicitExceptionEdge(exceptionKind);
 646             IntegerExactArithmeticSplitNode split = b.addPush(kind, createIntegerExactSplit(x, y, exceptionEdge, op));
 647             split.setNext(b.add(new BeginNode()));
 648         } else {
 649             b.addPush(kind, createIntegerExactArithmeticNode(b, x, y, op));
 650         }
 651     }
 652 
 653     private static void registerMathPlugins(InvocationPlugins plugins, boolean allowDeoptimization) {
 654         Registration r = new Registration(plugins, Math.class);
 655         if (allowDeoptimization) {
 656             for (JavaKind kind : new JavaKind[]{JavaKind.Int, JavaKind.Long}) {
 657                 Class&lt;?&gt; type = kind.toJavaClass();
 658                 r.register1(&quot;decrementExact&quot;, type, new InvocationPlugin() {
 659                     @Override
 660                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 661                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 662                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_DECREMENT_EXACT);
 663                         return true;
 664                     }
 665                 });
 666 
 667                 r.register1(&quot;incrementExact&quot;, type, new InvocationPlugin() {
 668                     @Override
 669                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x) {
 670                         ConstantNode y = b.add(ConstantNode.forIntegerKind(kind, 1));
 671                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_INCREMENT_EXACT);
 672                         return true;
 673                     }
 674                 });
 675                 r.register2(&quot;addExact&quot;, type, type, new InvocationPlugin() {
 676                     @Override
 677                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 678                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_ADD_EXACT);
 679                         return true;
 680                     }
 681                 });
 682                 r.register2(&quot;subtractExact&quot;, type, type, new InvocationPlugin() {
 683                     @Override
 684                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 685                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_SUBTRACT_EXACT);
 686                         return true;
 687                     }
 688                 });
 689 
 690                 r.register2(&quot;multiplyExact&quot;, type, type, new InvocationPlugin() {
 691                     @Override
 692                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 693                         createIntegerExactOperation(b, kind, x, y, IntegerExactOp.INTEGER_MULTIPLY_EXACT);
 694                         return true;
 695                     }
 696                 });
 697             }
 698         }
 699         r.register1(&quot;abs&quot;, Float.TYPE, new InvocationPlugin() {
 700 
 701             @Override
 702             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 703                 b.push(JavaKind.Float, b.append(new AbsNode(value).canonical(null)));
 704                 return true;
 705             }
 706         });
 707         r.register1(&quot;abs&quot;, Double.TYPE, new InvocationPlugin() {
 708             @Override
 709             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 710                 b.push(JavaKind.Double, b.append(new AbsNode(value).canonical(null)));
 711                 return true;
 712             }
 713         });
 714         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 715     }
 716 
 717     private static void registerStrictMathPlugins(InvocationPlugins plugins) {
 718         Registration r = new Registration(plugins, StrictMath.class);
 719         r.register1(&quot;sqrt&quot;, Double.TYPE, new MathSqrtPlugin());
 720     }
 721 
 722     public static final class StringIndexOfConstantPlugin implements InvocationPlugin {
 723         @Override
 724         public boolean inlineOnly() {
 725             return true;
 726         }
 727 
 728         @Override
 729         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver, ValueNode source, ValueNode sourceOffset, ValueNode sourceCount,
 730                         ValueNode target, ValueNode targetOffset, ValueNode targetCount, ValueNode origFromIndex) {
 731             if (target.isConstant()) {
 732                 b.addPush(JavaKind.Int, new StringIndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), source, sourceOffset, sourceCount,
 733                                 target, targetOffset, targetCount, origFromIndex));
 734                 return true;
 735             }
 736             return false;
 737         }
 738     }
 739 
 740     public static final class StringLatin1IndexOfConstantPlugin implements InvocationPlugin {
 741         @Override
 742         public boolean inlineOnly() {
 743             return true;
 744         }
 745 
 746         @Override
 747         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 748                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 749             if (target.isConstant()) {
 750                 b.addPush(JavaKind.Int, new StringLatin1IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 751                                 source, sourceCount, target, targetCount, origFromIndex));
 752                 return true;
 753             }
 754             return false;
 755         }
 756     }
 757 
 758     public static final class StringUTF16IndexOfConstantPlugin implements InvocationPlugin {
 759         @Override
 760         public boolean inlineOnly() {
 761             return true;
 762         }
 763 
 764         @Override
 765         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, InvocationPlugin.Receiver receiver,
 766                         ValueNode source, ValueNode sourceCount, ValueNode target, ValueNode targetCount, ValueNode origFromIndex) {
 767             if (target.isConstant()) {
 768                 b.addPush(JavaKind.Int, new StringUTF16IndexOfNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()),
 769                                 source, sourceCount, target, targetCount, origFromIndex));
 770                 return true;
 771             }
 772             return false;
 773         }
 774     }
 775 
 776     public static class UnsignedMathPlugin implements InvocationPlugin {
 777         private final Condition condition;
 778 
 779         public UnsignedMathPlugin(Condition condition) {
 780             this.condition = condition;
 781         }
 782 
 783         @Override
 784         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode x, ValueNode y) {
 785             CanonicalizedCondition canonical = condition.canonicalize();
 786             StructuredGraph graph = b.getGraph();
 787 
 788             ValueNode lhs = canonical.mustMirror() ? y : x;
 789             ValueNode rhs = canonical.mustMirror() ? x : y;
 790 
 791             ValueNode trueValue = ConstantNode.forBoolean(!canonical.mustNegate(), graph);
 792             ValueNode falseValue = ConstantNode.forBoolean(canonical.mustNegate(), graph);
 793 
 794             LogicNode compare = CompareNode.createCompareNode(graph, b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, canonical.getCanonicalCondition(), lhs, rhs, NodeView.DEFAULT);
 795             b.addPush(JavaKind.Boolean, new ConditionalNode(compare, trueValue, falseValue));
 796             return true;
 797         }
 798     }
 799 
 800     private static void registerUnsignedMathPlugins(InvocationPlugins plugins) {
 801         Registration r = new Registration(plugins, UnsignedMath.class);
 802         r.register2(&quot;aboveThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AT));
 803         r.register2(&quot;aboveThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AT));
 804         r.register2(&quot;belowThan&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BT));
 805         r.register2(&quot;belowThan&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BT));
 806         r.register2(&quot;aboveOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.AE));
 807         r.register2(&quot;aboveOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.AE));
 808         r.register2(&quot;belowOrEqual&quot;, int.class, int.class, new UnsignedMathPlugin(Condition.BE));
 809         r.register2(&quot;belowOrEqual&quot;, long.class, long.class, new UnsignedMathPlugin(Condition.BE));
 810     }
 811 
 812     protected static void registerBoxingPlugins(InvocationPlugins plugins) {
 813         for (JavaKind kind : JavaKind.values()) {
 814             if (kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) {
 815                 new BoxPlugin(kind).register(plugins);
 816                 new UnboxPlugin(kind).register(plugins);
 817             }
 818         }
 819     }
 820 
 821     private static void registerObjectPlugins(InvocationPlugins plugins) {
 822         Registration r = new Registration(plugins, Object.class);
 823         r.register1(&quot;&lt;init&gt;&quot;, Receiver.class, new InvocationPlugin() {
 824             @Override
 825             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 826                 /*
 827                  * Object.&lt;init&gt; is a common instrumentation point so only perform this rewrite if
 828                  * the current definition is the normal empty method with a single return bytecode.
 829                  * The finalizer registration will instead be performed by the BytecodeParser.
 830                  */
 831                 if (targetMethod.getCodeSize() == 1) {
 832                     ValueNode object = receiver.get();
 833                     if (RegisterFinalizerNode.mayHaveFinalizer(object, b.getAssumptions())) {
 834                         b.add(new RegisterFinalizerNode(object));
 835                     }
 836                     return true;
 837                 }
 838                 return false;
 839             }
 840         });
 841         r.register1(&quot;getClass&quot;, Receiver.class, new InvocationPlugin() {
 842             @Override
 843             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 844                 ValueNode object = receiver.get();
 845                 ValueNode folded = GetClassNode.tryFold(b.getMetaAccess(), b.getConstantReflection(), NodeView.DEFAULT, GraphUtil.originalValue(object, true));
 846                 if (folded != null) {
 847                     b.addPush(JavaKind.Object, folded);
 848                 } else {
 849                     Stamp stamp = StampFactory.objectNonNull(TypeReference.createTrusted(b.getAssumptions(), b.getMetaAccess().lookupJavaType(Class.class)));
 850                     b.addPush(JavaKind.Object, new GetClassNode(stamp, object));
 851                 }
 852                 return true;
 853             }
 854         });
 855     }
 856 
 857     private static void registerClassPlugins(InvocationPlugins plugins) {
 858         Registration r = new Registration(plugins, Class.class);
 859         r.register2(&quot;isInstance&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 860             @Override
 861             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode object) {
 862                 LogicNode condition = b.append(InstanceOfDynamicNode.create(b.getAssumptions(), b.getConstantReflection(), type.get(), object, false));
 863                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 864                 return true;
 865             }
 866         });
 867         r.register2(&quot;isAssignableFrom&quot;, Receiver.class, Class.class, new InvocationPlugin() {
 868             @Override
 869             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver type, ValueNode otherType) {
 870                 ClassIsAssignableFromNode condition = b.append(new ClassIsAssignableFromNode(type.get(), otherType));
 871                 b.push(JavaKind.Boolean, b.append(new ConditionalNode(condition).canonical(null)));
 872                 return true;
 873             }
 874         });
 875 
 876         r.register2(&quot;cast&quot;, Receiver.class, Object.class, new InvocationPlugin() {
 877             @Override
 878             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
 879                 b.genCheckcastDynamic(object, receiver.get());
 880                 return true;
 881             }
 882 
 883             @Override
 884             public boolean inlineOnly() {
 885                 return true;
 886             }
 887         });
 888     }
 889 
 890     /**
 891      * Substitutions for improving the performance of some critical methods in {@link Edges}. These
 892      * substitutions improve the performance by forcing the relevant methods to be inlined
 893      * (intrinsification being a special form of inlining) and removing a checked cast.
 894      */
 895     private static void registerEdgesPlugins(MetaAccessProvider metaAccess, InvocationPlugins plugins) {
 896         Registration r = new Registration(plugins, Edges.class);
 897         for (Class&lt;?&gt; c : new Class&lt;?&gt;[]{Node.class, NodeList.class}) {
 898             r.register2(&quot;get&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, new InvocationPlugin() {
 899                 @Override
 900                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset) {
 901                     ObjectStamp stamp = StampFactory.object(TypeReference.createTrusted(b.getAssumptions(), metaAccess.lookupJavaType(c)));
 902                     RawLoadNode value = b.add(new RawLoadNode(stamp, node, offset, LocationIdentity.any(), JavaKind.Object));
 903                     b.addPush(JavaKind.Object, value);
 904                     return true;
 905                 }
 906             });
 907             r.register3(&quot;put&quot; + c.getSimpleName() + &quot;Unsafe&quot;, Node.class, long.class, c, new InvocationPlugin() {
 908                 @Override
 909                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode node, ValueNode offset, ValueNode value) {
 910                     b.add(new RawStoreNode(node, offset, value, JavaKind.Object, LocationIdentity.any()));
 911                     return true;
 912                 }
 913             });
 914         }
 915     }
 916 
 917     public static class BoxPlugin implements InvocationPlugin {
 918 
 919         private final JavaKind kind;
 920 
 921         BoxPlugin(JavaKind kind) {
 922             this.kind = kind;
 923         }
 924 
 925         @Override
 926         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
 927             if (b.parsingIntrinsic()) {
 928                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 929                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 930                     // Disable invocation plugins for boxing snippets so that the
 931                     // original JDK methods are inlined
 932                     return false;
 933                 }
 934             }
 935             ResolvedJavaType resultType = b.getMetaAccess().lookupJavaType(kind.toBoxedJavaClass());
 936             b.addPush(JavaKind.Object, new BoxNode(value, resultType, kind));
 937             return true;
 938         }
 939 
 940         void register(InvocationPlugins plugins) {
 941             plugins.register(this, kind.toBoxedJavaClass(), &quot;valueOf&quot;, kind.toJavaClass());
 942         }
 943     }
 944 
 945     public static class UnboxPlugin implements InvocationPlugin {
 946 
 947         private final JavaKind kind;
 948 
 949         UnboxPlugin(JavaKind kind) {
 950             this.kind = kind;
 951         }
 952 
 953         @Override
 954         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
 955             if (b.parsingIntrinsic()) {
 956                 ResolvedJavaMethod rootMethod = b.getGraph().method();
 957                 if (b.getMetaAccess().lookupJavaType(BoxingSnippets.class).isAssignableFrom(rootMethod.getDeclaringClass())) {
 958                     // Disable invocation plugins for unboxing snippets so that the
 959                     // original JDK methods are inlined
 960                     return false;
 961                 }
 962             }
 963             ValueNode valueNode = UnboxNode.create(b.getMetaAccess(), b.getConstantReflection(), receiver.get(), kind);
 964             b.addPush(kind, valueNode);
 965             return true;
 966         }
 967 
 968         void register(InvocationPlugins plugins) {
 969             String name = kind.toJavaClass().getSimpleName() + &quot;Value&quot;;
 970             plugins.register(this, kind.toBoxedJavaClass(), name, Receiver.class);
 971         }
 972     }
 973 
 974     /**
 975      * The new memory order modes (JDK9+) are defined with cumulative effect, from weakest to
 976      * strongest: Plain, Opaque, Release/Acquire, and Volatile. The existing Plain and Volatile
 977      * modes are defined compatibly with their pre-JDK 9 forms. Any guaranteed property of a weaker
 978      * mode, plus more, holds for a stronger mode. (Conversely, implementations are allowed to use a
 979      * stronger mode than requested for any access.) In JDK 9, these are provided without a full
 980      * formal specification.
 981      */
 982     enum AccessKind {
 983         PLAIN(0, 0, 0, 0, false),
 984         /**
 985          * Opaque accesses are wrapped by dummy membars to avoid floating/hoisting, this is stronger
 986          * than required since Opaque mode does not directly impose any ordering constraints with
 987          * respect to other variables beyond Plain mode.
 988          */
 989         OPAQUE(0, 0, 0, 0, true),
 990         RELEASE_ACQUIRE(0, LOAD_LOAD | LOAD_STORE, LOAD_STORE | STORE_STORE, 0, true),
 991         VOLATILE(JMM_PRE_VOLATILE_READ, JMM_POST_VOLATILE_READ, JMM_PRE_VOLATILE_WRITE, JMM_POST_VOLATILE_WRITE, true);
 992 
 993         public final boolean emitBarriers;
 994         public final int preReadBarriers;
 995         public final int postReadBarriers;
 996         public final int preWriteBarriers;
 997         public final int postWriteBarriers;
 998 
 999         AccessKind(int preReadBarriers, int postReadBarriers, int preWriteBarriers, int postWriteBarriers, boolean emitBarriers) {
1000             this.emitBarriers = emitBarriers;
1001             this.preReadBarriers = preReadBarriers;
1002             this.postReadBarriers = postReadBarriers;
1003             this.preWriteBarriers = preWriteBarriers;
1004             this.postWriteBarriers = postWriteBarriers;
1005         }
1006     }
1007 
1008     /**
1009      * Unsafe access relative to null object is an access to off-heap memory. As linear pointer
1010      * compression uses non-zero null, here null object must be replaced with zero constant.
1011      */
1012     public abstract static class UnsafeAccessPlugin implements InvocationPlugin {
1013         @FunctionalInterface
1014         public interface UnsafeNodeConstructor {
1015             FixedWithNextNode create(ValueNode value, LocationIdentity location);
1016         }
1017 
1018         protected final JavaKind unsafeAccessKind;
1019         private final boolean explicitUnsafeNullChecks;
1020 
1021         public UnsafeAccessPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1022             unsafeAccessKind = kind;
1023             this.explicitUnsafeNullChecks = explicitUnsafeNullChecks;
1024         }
1025 
1026         private static FixedWithNextNode createObjectAccessNode(ValueNode value, UnsafeNodeConstructor nodeConstructor) {
1027             return nodeConstructor.create(value, LocationIdentity.ANY_LOCATION);
1028         }
1029 
1030         private static FixedWithNextNode createMemoryAccessNode(StructuredGraph graph, UnsafeNodeConstructor nodeConstructor) {
1031             return nodeConstructor.create(ConstantNode.forLong(0L, graph), OFF_HEAP_LOCATION);
1032         }
1033 
1034         private static boolean isLoad(ValueNode node) {
1035             return node.getStackKind() != JavaKind.Void;
1036         }
1037 
1038         private void setResult(ValueNode node, GraphBuilderContext b) {
1039             if (isLoad(node)) {
1040                 b.addPush(unsafeAccessKind, node);
1041             } else {
1042                 b.add(node);
1043             }
1044         }
1045 
1046         protected final void createUnsafeAccess(ValueNode value, GraphBuilderContext b, UnsafeNodeConstructor nodeConstructor) {
1047             StructuredGraph graph = b.getGraph();
1048             graph.markUnsafeAccess();
1049             /* For unsafe access object pointers can only be stored in the heap */
1050             if (unsafeAccessKind == JavaKind.Object) {
1051                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1052             } else if (StampTool.isPointerAlwaysNull(value)) {
1053                 setResult(createMemoryAccessNode(graph, nodeConstructor), b);
1054             } else if (!explicitUnsafeNullChecks || StampTool.isPointerNonNull(value)) {
1055                 setResult(createObjectAccessNode(value, nodeConstructor), b);
1056             } else {
1057                 FixedWithNextNode objectAccess = graph.add(createObjectAccessNode(value, nodeConstructor));
1058                 FixedWithNextNode memoryAccess = graph.add(createMemoryAccessNode(graph, nodeConstructor));
1059                 FixedWithNextNode[] accessNodes = new FixedWithNextNode[]{objectAccess, memoryAccess};
1060 
1061                 LogicNode condition = graph.addOrUniqueWithInputs(IsNullNode.create(value));
1062                 b.add(new IfNode(condition, memoryAccess, objectAccess, 0.5));
1063 
1064                 MergeNode merge = b.append(new MergeNode());
1065                 for (FixedWithNextNode node : accessNodes) {
1066                     EndNode endNode = graph.add(new EndNode());
1067                     node.setNext(endNode);
1068                     if (node instanceof StateSplit) {
1069                         if (isLoad(node)) {
1070                             /*
1071                              * Temporarily push the access node so that the frame state has the node
1072                              * on the expression stack.
1073                              */
1074                             b.push(unsafeAccessKind, node);
1075                         }
1076                         b.setStateAfter((StateSplit) node);
1077                         if (isLoad(node)) {
1078                             ValueNode popped = b.pop(unsafeAccessKind);
1079                             assert popped == node;
1080                         }
1081                     }
1082                     merge.addForwardEnd(endNode);
1083                 }
1084 
1085                 if (isLoad(objectAccess)) {
1086                     ValuePhiNode phi = new ValuePhiNode(objectAccess.stamp(NodeView.DEFAULT), merge, accessNodes);
1087                     b.push(unsafeAccessKind, graph.addOrUnique(phi));
1088                 }
1089                 b.setStateAfter(merge);
1090             }
1091         }
1092     }
1093 
1094     public static class UnsafeGetPlugin extends UnsafeAccessPlugin {
1095         private final AccessKind accessKind;
1096 
1097         public UnsafeGetPlugin(JavaKind returnKind, boolean explicitUnsafeNullChecks) {
1098             this(returnKind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1099         }
1100 
1101         public UnsafeGetPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1102             super(kind, explicitUnsafeNullChecks);
1103             this.accessKind = accessKind;
1104         }
1105 
1106         @Override
1107         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address) {
1108             // Emits a null-check for the otherwise unused receiver
1109             unsafe.get();
1110             b.addPush(unsafeAccessKind, new UnsafeMemoryLoadNode(address, unsafeAccessKind, OFF_HEAP_LOCATION));
1111             b.getGraph().markUnsafeAccess();
1112             return true;
1113         }
1114 
1115         @Override
1116         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset) {
1117             // Opaque mode does not directly impose any ordering constraints with respect to other
1118             // variables beyond Plain mode.
1119             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {
1120                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.
1121                 return apply(b, targetMethod, unsafe, offset);
1122             }
1123             // Emits a null-check for the otherwise unused receiver
1124             unsafe.get();
1125             if (accessKind.emitBarriers) {
1126                 b.add(new MembarNode(accessKind.preReadBarriers));
1127             }
1128             // Raw accesses can be turned into floatable field accesses, the membars preserve the
1129             // access mode. In the case of opaque access, and only for opaque, the location of the
1130             // wrapping membars can be refined to the field location.
1131             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawLoadNode(obj, offset, unsafeAccessKind, loc));
1132             if (accessKind.emitBarriers) {
1133                 b.add(new MembarNode(accessKind.postReadBarriers));
1134             }
1135             return true;
1136         }
1137     }
1138 
1139     public static class UnsafePutPlugin extends UnsafeAccessPlugin {
1140         private final AccessKind accessKind;
1141 
1142         public UnsafePutPlugin(JavaKind kind, boolean explicitUnsafeNullChecks) {
1143             this(kind, AccessKind.PLAIN, explicitUnsafeNullChecks);
1144         }
1145 
1146         private UnsafePutPlugin(JavaKind kind, AccessKind accessKind, boolean explicitUnsafeNullChecks) {
1147             super(kind, explicitUnsafeNullChecks);
1148             this.accessKind = accessKind;
1149         }
1150 
1151         @Override
1152         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode address, ValueNode value) {
1153             assert !accessKind.emitBarriers : &quot;Barriers for address based Unsafe put is not supported.&quot;;
1154             // Emits a null-check for the otherwise unused receiver
1155             unsafe.get();
1156             b.add(new UnsafeMemoryStoreNode(address, value, unsafeAccessKind, OFF_HEAP_LOCATION));
1157             b.getGraph().markUnsafeAccess();
1158             return true;
1159         }
1160 
1161         @Override
1162         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe, ValueNode object, ValueNode offset, ValueNode value) {
1163             // Opaque mode does not directly impose any ordering constraints with respect to other
1164             // variables beyond Plain mode.
1165             if (accessKind == AccessKind.OPAQUE &amp;&amp; StampTool.isPointerAlwaysNull(object)) {
1166                 // OFF_HEAP_LOCATION accesses are not floatable =&gt; no membars needed for opaque.
1167                 return apply(b, targetMethod, unsafe, offset, value);
1168             }
1169             // Emits a null-check for the otherwise unused receiver
1170             unsafe.get();
1171             if (accessKind.emitBarriers) {
1172                 b.add(new MembarNode(accessKind.preWriteBarriers));
1173             }
1174             ValueNode maskedValue = b.maskSubWordValue(value, unsafeAccessKind);
1175             // Raw accesses can be turned into floatable field accesses, the membars preserve the
1176             // access mode. In the case of opaque access, and only for opaque, the location of the
1177             // wrapping membars can be refined to the field location.
1178             createUnsafeAccess(object, b, (obj, loc) -&gt; new RawStoreNode(obj, offset, maskedValue, unsafeAccessKind, loc));
1179             if (accessKind.emitBarriers) {
1180                 b.add(new MembarNode(accessKind.postWriteBarriers));
1181             }
1182             return true;
1183         }
1184     }
1185 
1186     public static class UnsafeFencePlugin implements InvocationPlugin {
1187 
1188         private final int barriers;
1189 
1190         public UnsafeFencePlugin(int barriers) {
1191             this.barriers = barriers;
1192         }
1193 
1194         @Override
1195         public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver unsafe) {
1196             // Emits a null-check for the otherwise unused receiver
1197             unsafe.get();
1198             b.add(new MembarNode(barriers));
1199             return true;
1200         }
1201     }
1202 
1203     private static final SpeculationReasonGroup DIRECTIVE_SPECULATIONS = new SpeculationReasonGroup(&quot;GraalDirective&quot;, BytecodePosition.class);
1204 
1205     private static void registerGraalDirectivesPlugins(InvocationPlugins plugins) {
1206         Registration r = new Registration(plugins, GraalDirectives.class);
1207         r.register0(&quot;deoptimize&quot;, new InvocationPlugin() {
1208             @Override
1209             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1210                 b.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1211                 return true;
1212             }
1213         });
1214 
1215         r.register0(&quot;deoptimizeAndInvalidate&quot;, new InvocationPlugin() {
1216             @Override
1217             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1218                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1219                 return true;
1220             }
1221         });
1222 
1223         r.register0(&quot;deoptimizeAndInvalidateWithSpeculation&quot;, new InvocationPlugin() {
1224             @Override
1225             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1226                 GraalError.guarantee(b.getGraph().getSpeculationLog() != null, &quot;A speculation log is needed to use `deoptimizeAndInvalidateWithSpeculation`&quot;);
1227                 BytecodePosition pos = new BytecodePosition(null, b.getMethod(), b.bci());
1228                 SpeculationReason reason = DIRECTIVE_SPECULATIONS.createSpeculationReason(pos);
1229                 Speculation speculation;
1230                 if (b.getGraph().getSpeculationLog().maySpeculate(reason)) {
1231                     speculation = b.getGraph().getSpeculationLog().speculate(reason);
1232                 } else {
1233                     speculation = SpeculationLog.NO_SPECULATION;
1234                 }
1235                 b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter, speculation));
1236                 return true;
1237             }
1238         });
1239 
1240         r.register0(&quot;inCompiledCode&quot;, new InvocationPlugin() {
1241             @Override
1242             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1243                 b.addPush(JavaKind.Boolean, ConstantNode.forBoolean(true));
1244                 return true;
1245             }
1246         });
1247 
1248         r.register0(&quot;controlFlowAnchor&quot;, new InvocationPlugin() {
1249             @Override
1250             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1251                 b.add(new ControlFlowAnchorNode());
1252                 return true;
1253             }
1254         });
1255         r.register0(&quot;sideEffect&quot;, new InvocationPlugin() {
1256             @Override
1257             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1258                 b.add(new SideEffectNode());
1259                 return true;
1260             }
1261         });
1262         r.register1(&quot;sideEffect&quot;, int.class, new InvocationPlugin() {
1263             @Override
1264             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode a) {
1265                 b.addPush(JavaKind.Int, new SideEffectNode(a));
1266                 return true;
1267             }
1268         });
1269         r.register2(&quot;injectBranchProbability&quot;, double.class, boolean.class, new InvocationPlugin() {
1270             @Override
1271             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode probability, ValueNode condition) {
1272                 b.addPush(JavaKind.Boolean, new BranchProbabilityNode(probability, condition));
1273                 return true;
1274             }
1275         });
1276 
1277         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1278             @Override
1279             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1280                 b.add(new BlackholeNode(value));
1281                 return true;
1282             }
1283         };
1284 
1285         InvocationPlugin bindToRegisterPlugin = new InvocationPlugin() {
1286             @Override
1287             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1288                 b.add(new BindToRegisterNode(value));
1289                 return true;
1290             }
1291         };
1292         for (JavaKind kind : JavaKind.values()) {
1293             if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1294                 Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1295                 r.register1(&quot;blackhole&quot;, javaClass, blackholePlugin);
1296                 r.register1(&quot;bindToRegister&quot;, javaClass, bindToRegisterPlugin);
1297 
1298                 r.register1(&quot;opaque&quot;, javaClass, new InvocationPlugin() {
1299                     @Override
1300                     public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1301                         b.addPush(kind, new OpaqueNode(value));
1302                         return true;
1303                     }
1304                 });
1305             }
1306         }
1307 
1308         InvocationPlugin spillPlugin = new InvocationPlugin() {
1309             @Override
1310             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
1311                 b.add(new SpillRegistersNode());
1312                 return true;
1313             }
1314         };
1315         r.register0(&quot;spillRegisters&quot;, spillPlugin);
1316 
1317         r.register1(&quot;guardingNonNull&quot;, Object.class, new InvocationPlugin() {
1318             @Override
1319             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode value) {
1320                 b.addPush(value.getStackKind(), b.nullCheckedValue(value));
1321                 return true;
1322             }
1323         });
1324 
1325         r.register1(&quot;ensureVirtualized&quot;, Object.class, new InvocationPlugin() {
1326             @Override
1327             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1328                 b.add(new EnsureVirtualizedNode(object, false));
1329                 return true;
1330             }
1331         });
1332         r.register1(&quot;ensureVirtualizedHere&quot;, Object.class, new InvocationPlugin() {
1333             @Override
1334             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1335                 b.add(new EnsureVirtualizedNode(object, true));
1336                 return true;
1337             }
1338         });
1339     }
1340 
1341     private static void registerJMHBlackholePlugins(InvocationPlugins plugins, Replacements replacements) {
1342         InvocationPlugin blackholePlugin = new InvocationPlugin() {
1343             @Override
1344             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver blackhole, ValueNode value) {
1345                 blackhole.get();
1346                 b.add(new BlackholeNode(value));
1347                 return true;
1348             }
1349 
1350             @Override
1351             public boolean isDecorator() {
1352                 return true;
1353             }
1354         };
1355         String[] names = {&quot;org.openjdk.jmh.infra.Blackhole&quot;, &quot;org.openjdk.jmh.logic.BlackHole&quot;};
1356         for (String name : names) {
1357             Registration r = new Registration(plugins, name, replacements);
1358             for (JavaKind kind : JavaKind.values()) {
1359                 if ((kind.isPrimitive() &amp;&amp; kind != JavaKind.Void) || kind == JavaKind.Object) {
1360                     Class&lt;?&gt; javaClass = kind == JavaKind.Object ? Object.class : kind.toJavaClass();
1361                     r.registerOptional2(&quot;consume&quot;, Receiver.class, javaClass, blackholePlugin);
1362                 }
1363             }
1364             r.registerOptional2(&quot;consume&quot;, Receiver.class, Object[].class, blackholePlugin);
1365         }
1366     }
1367 
1368     private static void registerJFRThrowablePlugins(InvocationPlugins plugins, Replacements replacements) {
1369         Registration r = new Registration(plugins, &quot;oracle.jrockit.jfr.jdkevents.ThrowableTracer&quot;, replacements);
1370         r.register2(&quot;traceThrowable&quot;, Throwable.class, String.class, new InvocationPlugin() {
1371             @Override
1372             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode throwable, ValueNode message) {
1373                 b.add(new VirtualizableInvokeMacroNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), throwable, message));
1374                 return true;
1375             }
1376 
1377             @Override
1378             public boolean inlineOnly() {
1379                 return true;
1380             }
1381         });
1382     }
1383 
1384     private static void registerMethodHandleImplPlugins(InvocationPlugins plugins, SnippetReflectionProvider snippetReflection, Replacements replacements) {
1385         Registration r = new Registration(plugins, &quot;java.lang.invoke.MethodHandleImpl&quot;, replacements);
1386         // In later JDKs this no longer exists and the usage is replace by Class.cast which is
1387         // already an intrinsic
1388         r.registerOptional2(&quot;castReference&quot;, Class.class, Object.class, new InvocationPlugin() {
1389             @Override
1390             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode javaClass, ValueNode object) {
1391                 b.genCheckcastDynamic(object, javaClass);
1392                 return true;
1393             }
1394 
1395             @Override
1396             public boolean inlineOnly() {
1397                 return true;
1398             }
1399         });
1400         r.register2(&quot;profileBoolean&quot;, boolean.class, int[].class, new InvocationPlugin() {
1401             @Override
1402             public boolean inlineOnly() {
1403                 return true;
1404             }
1405 
1406             @Override
1407             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode result, ValueNode counters) {
1408                 if (result.isConstant()) {
1409                     b.push(JavaKind.Boolean, result);
1410                     return true;
1411                 }
1412                 if (counters.isConstant()) {
1413                     ValueNode newResult = result;
1414                     int[] ctrs = snippetReflection.asObject(int[].class, (JavaConstant) counters.asConstant());
1415                     if (ctrs != null &amp;&amp; ctrs.length == 2) {
1416                         int falseCount = ctrs[0];
1417                         int trueCount = ctrs[1];
1418                         int totalCount = trueCount + falseCount;
1419 
1420                         if (totalCount == 0) {
1421                             b.add(new DeoptimizeNode(DeoptimizationAction.InvalidateReprofile, DeoptimizationReason.TransferToInterpreter));
1422                         } else if (falseCount == 0 || trueCount == 0) {
1423                             boolean expected = falseCount == 0;
1424                             LogicNode condition = b.add(
1425                                             IntegerEqualsNode.create(b.getConstantReflection(), b.getMetaAccess(), b.getOptions(), null, result, b.add(ConstantNode.forBoolean(!expected)),
1426                                                             NodeView.DEFAULT));
1427                             b.append(new FixedGuardNode(condition, DeoptimizationReason.UnreachedCode, DeoptimizationAction.InvalidateReprofile, true));
1428                             newResult = b.add(ConstantNode.forBoolean(expected));
1429                         } else {
1430                             // We cannot use BranchProbabilityNode here since there&#39;s no guarantee
1431                             // the result of MethodHandleImpl.profileBoolean() is used as the
1432                             // test in an `if` statement (as required by BranchProbabilityNode).
1433                         }
1434                     }
1435                     b.addPush(JavaKind.Boolean, newResult);
1436                     return true;
1437                 }
1438                 b.addPush(JavaKind.Boolean,
1439                                 new ProfileBooleanNode(snippetReflection, b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), result, counters));
1440                 return true;
1441             }
1442         });
1443     }
1444 
1445     /**
1446      * Registers a plugin to ignore {@code com.sun.tdk.jcov.runtime.Collect.hit} within an
1447      * intrinsic.
1448      */
1449     private static void registerJcovCollectPlugins(InvocationPlugins plugins, Replacements replacements) {
1450         Registration r = new Registration(plugins, &quot;com.sun.tdk.jcov.runtime.Collect&quot;, replacements);
1451         r.register1(&quot;hit&quot;, int.class, new InvocationPlugin() {
1452             @Override
1453             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
1454                 if (b.parsingIntrinsic()) {
1455                     return true;
1456                 }
1457                 return false;
1458             }
1459         });
1460     }
1461 }
    </pre>
  </body>
</html>
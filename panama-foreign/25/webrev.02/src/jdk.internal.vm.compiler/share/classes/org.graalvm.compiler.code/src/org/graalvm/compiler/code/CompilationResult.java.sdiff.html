<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.code/src/org/graalvm/compiler/code/CompilationResult.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AVXKind.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HexCodeFile.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.code/src/org/graalvm/compiler/code/CompilationResult.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.code;
 26 
 27 import static java.util.Collections.emptyList;
 28 import static java.util.Collections.unmodifiableList;
 29 import static jdk.vm.ci.meta.MetaUtil.identityHashCodeString;
 30 
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Collection;
 34 import java.util.Collections;
 35 import java.util.List;
 36 import java.util.Objects;

 37 
 38 import jdk.internal.vm.compiler.collections.EconomicSet;
 39 import org.graalvm.compiler.core.common.CompilationIdentifier;
 40 import org.graalvm.compiler.graph.NodeSourcePosition;
 41 
 42 import jdk.vm.ci.code.DebugInfo;
 43 import jdk.vm.ci.code.StackSlot;
 44 import jdk.vm.ci.code.site.Call;
 45 import jdk.vm.ci.code.site.ConstantReference;
 46 import jdk.vm.ci.code.site.DataPatch;
 47 import jdk.vm.ci.code.site.DataSectionReference;
 48 import jdk.vm.ci.code.site.ExceptionHandler;
 49 import jdk.vm.ci.code.site.Infopoint;
 50 import jdk.vm.ci.code.site.InfopointReason;
 51 import jdk.vm.ci.code.site.Mark;
 52 import jdk.vm.ci.code.site.Reference;
 53 import jdk.vm.ci.code.site.Site;
 54 import jdk.vm.ci.meta.Assumptions.Assumption;
 55 import jdk.vm.ci.meta.InvokeTarget;
 56 import jdk.vm.ci.meta.ResolvedJavaField;
 57 import jdk.vm.ci.meta.ResolvedJavaMethod;
 58 import jdk.vm.ci.meta.SpeculationLog;
 59 
 60 /**
 61  * Represents the output from compiling a method, including the compiled machine code, associated
 62  * data and references, relocation information, deoptimization information, etc.
 63  */
 64 public class CompilationResult {
 65 
 66     /**
 67      * Provides extra information about instructions or data at specific positions in
 68      * {@link CompilationResult#getTargetCode()}. This is optional information that can be used to
 69      * enhance a disassembly of the code.
 70      */
 71     public abstract static class CodeAnnotation {
 72 
<span class="line-modified"> 73         public final int position;</span>
 74 
 75         public CodeAnnotation(int position) {
 76             this.position = position;
 77         }
 78 
 79         @Override
 80         public final int hashCode() {
 81             throw new UnsupportedOperationException(&quot;hashCode&quot;);
 82         }
 83 
 84         @Override
 85         public String toString() {
 86             return identityHashCodeString(this);
 87         }
 88 
 89         @Override
 90         public abstract boolean equals(Object obj);








 91     }
 92 
 93     /**
 94      * A string comment about one or more instructions at a specific position in the code.
 95      */
 96     public static final class CodeComment extends CodeAnnotation {
 97 
 98         public final String value;
 99 
100         public CodeComment(int position, String comment) {
101             super(position);
102             this.value = comment;
103         }
104 
105         @Override
106         public boolean equals(Object obj) {
107             if (this == obj) {
108                 return true;
109             }
110             if (obj instanceof CodeComment) {
111                 CodeComment that = (CodeComment) obj;
<span class="line-modified">112                 if (this.position == that.position &amp;&amp; this.value.equals(that.value)) {</span>
113                     return true;
114                 }
115             }
116             return false;
117         }
118 
119         @Override
120         public String toString() {
<span class="line-modified">121             return getClass().getSimpleName() + &quot;@&quot; + position + &quot;: &quot; + value;</span>
122         }
123     }
124 
125     /**
126      * Describes a table of signed offsets embedded in the code. The offsets are relative to the
127      * starting address of the table. This type of table maybe generated when translating a
128      * multi-way branch based on a key value from a dense value set (e.g. the {@code tableswitch}
129      * JVM instruction).
130      *
131      * The table is indexed by the contiguous range of integers from {@link #low} to {@link #high}
132      * inclusive.
133      */
134     public static final class JumpTable extends CodeAnnotation {
135 
136         /**
137          * The low value in the key range (inclusive).
138          */
139         public final int low;
140 
141         /**
</pre>
<hr />
<pre>
145 
146         /**
147          * The size (in bytes) of each table entry.
148          */
149         public final int entrySize;
150 
151         public JumpTable(int position, int low, int high, int entrySize) {
152             super(position);
153             this.low = low;
154             this.high = high;
155             this.entrySize = entrySize;
156         }
157 
158         @Override
159         public boolean equals(Object obj) {
160             if (this == obj) {
161                 return true;
162             }
163             if (obj instanceof JumpTable) {
164                 JumpTable that = (JumpTable) obj;
<span class="line-modified">165                 if (this.position == that.position &amp;&amp; this.entrySize == that.entrySize &amp;&amp; this.low == that.low &amp;&amp; this.high == that.high) {</span>
166                     return true;
167                 }
168             }
169             return false;
170         }
171 
172         @Override
173         public String toString() {
<span class="line-modified">174             return getClass().getSimpleName() + &quot;@&quot; + position + &quot;: [&quot; + low + &quot; .. &quot; + high + &quot;]&quot;;</span>
175         }
176     }
177 
178     private boolean closed;
179 
180     private int entryBCI = -1;
181 
182     private final DataSection dataSection = new DataSection();
183 
184     private final List&lt;Infopoint&gt; infopoints = new ArrayList&lt;&gt;();
185     private final List&lt;SourceMapping&gt; sourceMapping = new ArrayList&lt;&gt;();
186     private final List&lt;DataPatch&gt; dataPatches = new ArrayList&lt;&gt;();
187     private final List&lt;ExceptionHandler&gt; exceptionHandlers = new ArrayList&lt;&gt;();
188     private final List&lt;Mark&gt; marks = new ArrayList&lt;&gt;();
189 
190     private int totalFrameSize = -1;
191     private int maxInterpreterFrameSize = -1;
192 
193     private StackSlot customStackArea = null;
194 
</pre>
<hr />
<pre>
750     public void clearExceptionHandlers() {
751         exceptionHandlers.clear();
752     }
753 
754     private void checkOpen() {
755         if (closed) {
756             throw new IllegalStateException();
757         }
758     }
759 
760     /**
761      * Closes this compilation result to future updates.
762      */
763     public void close() {
764         if (closed) {
765             throw new IllegalStateException(&quot;Cannot re-close compilation result &quot; + this);
766         }
767         dataSection.close();
768         closed = true;
769     }































770 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.code;
 26 
 27 import static java.util.Collections.emptyList;
 28 import static java.util.Collections.unmodifiableList;
 29 import static jdk.vm.ci.meta.MetaUtil.identityHashCodeString;
 30 
 31 import java.util.ArrayList;
 32 import java.util.Arrays;
 33 import java.util.Collection;
 34 import java.util.Collections;
 35 import java.util.List;
 36 import java.util.Objects;
<span class="line-added"> 37 import java.util.function.Function;</span>
 38 
 39 import jdk.internal.vm.compiler.collections.EconomicSet;
 40 import org.graalvm.compiler.core.common.CompilationIdentifier;
 41 import org.graalvm.compiler.graph.NodeSourcePosition;
 42 
 43 import jdk.vm.ci.code.DebugInfo;
 44 import jdk.vm.ci.code.StackSlot;
 45 import jdk.vm.ci.code.site.Call;
 46 import jdk.vm.ci.code.site.ConstantReference;
 47 import jdk.vm.ci.code.site.DataPatch;
 48 import jdk.vm.ci.code.site.DataSectionReference;
 49 import jdk.vm.ci.code.site.ExceptionHandler;
 50 import jdk.vm.ci.code.site.Infopoint;
 51 import jdk.vm.ci.code.site.InfopointReason;
 52 import jdk.vm.ci.code.site.Mark;
 53 import jdk.vm.ci.code.site.Reference;
 54 import jdk.vm.ci.code.site.Site;
 55 import jdk.vm.ci.meta.Assumptions.Assumption;
 56 import jdk.vm.ci.meta.InvokeTarget;
 57 import jdk.vm.ci.meta.ResolvedJavaField;
 58 import jdk.vm.ci.meta.ResolvedJavaMethod;
 59 import jdk.vm.ci.meta.SpeculationLog;
 60 
 61 /**
 62  * Represents the output from compiling a method, including the compiled machine code, associated
 63  * data and references, relocation information, deoptimization information, etc.
 64  */
 65 public class CompilationResult {
 66 
 67     /**
 68      * Provides extra information about instructions or data at specific positions in
 69      * {@link CompilationResult#getTargetCode()}. This is optional information that can be used to
 70      * enhance a disassembly of the code.
 71      */
 72     public abstract static class CodeAnnotation {
 73 
<span class="line-modified"> 74         private int position;</span>
 75 
 76         public CodeAnnotation(int position) {
 77             this.position = position;
 78         }
 79 
 80         @Override
 81         public final int hashCode() {
 82             throw new UnsupportedOperationException(&quot;hashCode&quot;);
 83         }
 84 
 85         @Override
 86         public String toString() {
 87             return identityHashCodeString(this);
 88         }
 89 
 90         @Override
 91         public abstract boolean equals(Object obj);
<span class="line-added"> 92 </span>
<span class="line-added"> 93         public int getPosition() {</span>
<span class="line-added"> 94             return position;</span>
<span class="line-added"> 95         }</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97         void setPosition(int position) {</span>
<span class="line-added"> 98             this.position = position;</span>
<span class="line-added"> 99         }</span>
100     }
101 
102     /**
103      * A string comment about one or more instructions at a specific position in the code.
104      */
105     public static final class CodeComment extends CodeAnnotation {
106 
107         public final String value;
108 
109         public CodeComment(int position, String comment) {
110             super(position);
111             this.value = comment;
112         }
113 
114         @Override
115         public boolean equals(Object obj) {
116             if (this == obj) {
117                 return true;
118             }
119             if (obj instanceof CodeComment) {
120                 CodeComment that = (CodeComment) obj;
<span class="line-modified">121                 if (this.getPosition() == that.getPosition() &amp;&amp; this.value.equals(that.value)) {</span>
122                     return true;
123                 }
124             }
125             return false;
126         }
127 
128         @Override
129         public String toString() {
<span class="line-modified">130             return getClass().getSimpleName() + &quot;@&quot; + getPosition() + &quot;: &quot; + value;</span>
131         }
132     }
133 
134     /**
135      * Describes a table of signed offsets embedded in the code. The offsets are relative to the
136      * starting address of the table. This type of table maybe generated when translating a
137      * multi-way branch based on a key value from a dense value set (e.g. the {@code tableswitch}
138      * JVM instruction).
139      *
140      * The table is indexed by the contiguous range of integers from {@link #low} to {@link #high}
141      * inclusive.
142      */
143     public static final class JumpTable extends CodeAnnotation {
144 
145         /**
146          * The low value in the key range (inclusive).
147          */
148         public final int low;
149 
150         /**
</pre>
<hr />
<pre>
154 
155         /**
156          * The size (in bytes) of each table entry.
157          */
158         public final int entrySize;
159 
160         public JumpTable(int position, int low, int high, int entrySize) {
161             super(position);
162             this.low = low;
163             this.high = high;
164             this.entrySize = entrySize;
165         }
166 
167         @Override
168         public boolean equals(Object obj) {
169             if (this == obj) {
170                 return true;
171             }
172             if (obj instanceof JumpTable) {
173                 JumpTable that = (JumpTable) obj;
<span class="line-modified">174                 if (this.getPosition() == that.getPosition() &amp;&amp; this.entrySize == that.entrySize &amp;&amp; this.low == that.low &amp;&amp; this.high == that.high) {</span>
175                     return true;
176                 }
177             }
178             return false;
179         }
180 
181         @Override
182         public String toString() {
<span class="line-modified">183             return getClass().getSimpleName() + &quot;@&quot; + getPosition() + &quot;: [&quot; + low + &quot; .. &quot; + high + &quot;]&quot;;</span>
184         }
185     }
186 
187     private boolean closed;
188 
189     private int entryBCI = -1;
190 
191     private final DataSection dataSection = new DataSection();
192 
193     private final List&lt;Infopoint&gt; infopoints = new ArrayList&lt;&gt;();
194     private final List&lt;SourceMapping&gt; sourceMapping = new ArrayList&lt;&gt;();
195     private final List&lt;DataPatch&gt; dataPatches = new ArrayList&lt;&gt;();
196     private final List&lt;ExceptionHandler&gt; exceptionHandlers = new ArrayList&lt;&gt;();
197     private final List&lt;Mark&gt; marks = new ArrayList&lt;&gt;();
198 
199     private int totalFrameSize = -1;
200     private int maxInterpreterFrameSize = -1;
201 
202     private StackSlot customStackArea = null;
203 
</pre>
<hr />
<pre>
759     public void clearExceptionHandlers() {
760         exceptionHandlers.clear();
761     }
762 
763     private void checkOpen() {
764         if (closed) {
765             throw new IllegalStateException();
766         }
767     }
768 
769     /**
770      * Closes this compilation result to future updates.
771      */
772     public void close() {
773         if (closed) {
774             throw new IllegalStateException(&quot;Cannot re-close compilation result &quot; + this);
775         }
776         dataSection.close();
777         closed = true;
778     }
<span class="line-added">779 </span>
<span class="line-added">780     public void shiftCodePatch(int pos, int bytesToShift) {</span>
<span class="line-added">781         iterateAndReplace(infopoints, pos, site -&gt; {</span>
<span class="line-added">782             if (site instanceof Call) {</span>
<span class="line-added">783                 Call call = (Call) site;</span>
<span class="line-added">784                 return new Call(call.target, site.pcOffset + bytesToShift, call.size, call.direct, call.debugInfo);</span>
<span class="line-added">785             } else {</span>
<span class="line-added">786                 return new Infopoint(site.pcOffset + bytesToShift, site.debugInfo, site.reason);</span>
<span class="line-added">787             }</span>
<span class="line-added">788         });</span>
<span class="line-added">789         iterateAndReplace(dataPatches, pos, site -&gt; new DataPatch(site.pcOffset + bytesToShift, site.reference, site.note));</span>
<span class="line-added">790         iterateAndReplace(exceptionHandlers, pos, site -&gt; new ExceptionHandler(site.pcOffset + bytesToShift, site.handlerPos));</span>
<span class="line-added">791         iterateAndReplace(marks, pos, site -&gt; new Mark(site.pcOffset + bytesToShift, site.id));</span>
<span class="line-added">792         if (annotations != null) {</span>
<span class="line-added">793             for (CodeAnnotation annotation : annotations) {</span>
<span class="line-added">794                 int annotationPos = annotation.position;</span>
<span class="line-added">795                 if (pos &lt;= annotationPos) {</span>
<span class="line-added">796                     annotation.setPosition(annotationPos + bytesToShift);</span>
<span class="line-added">797                 }</span>
<span class="line-added">798             }</span>
<span class="line-added">799         }</span>
<span class="line-added">800     }</span>
<span class="line-added">801 </span>
<span class="line-added">802     private static &lt;T extends Site&gt; void iterateAndReplace(List&lt;T&gt; sites, int pos, Function&lt;T, T&gt; replacement) {</span>
<span class="line-added">803         for (int i = 0; i &lt; sites.size(); i++) {</span>
<span class="line-added">804             T site = sites.get(i);</span>
<span class="line-added">805             if (pos &lt;= site.pcOffset) {</span>
<span class="line-added">806                 sites.set(i, replacement.apply(site));</span>
<span class="line-added">807             }</span>
<span class="line-added">808         }</span>
<span class="line-added">809     }</span>
810 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.asm.amd64/src/org/graalvm/compiler/asm/amd64/AVXKind.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HexCodeFile.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
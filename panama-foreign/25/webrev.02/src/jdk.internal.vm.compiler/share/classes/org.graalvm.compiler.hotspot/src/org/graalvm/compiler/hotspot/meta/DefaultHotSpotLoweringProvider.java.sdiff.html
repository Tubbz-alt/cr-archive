<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../SymbolicSnippetEncoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 62 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 63 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 64 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 65 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 66 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;
 67 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 68 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 69 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 70 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 71 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 72 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 73 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 74 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 75 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 76 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 77 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 78 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;

 79 import org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets;
 80 import org.graalvm.compiler.hotspot.replacements.HotSpotSerialWriteBarrierSnippets;
 81 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 82 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 83 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 84 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 85 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 86 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
<span class="line-removed"> 87 import org.graalvm.compiler.hotspot.replacements.NewObjectSnippets;</span>
 88 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.ObjectSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
 91 import org.graalvm.compiler.hotspot.replacements.UnsafeCopyMemoryNode;
 92 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;
 93 import org.graalvm.compiler.hotspot.replacements.UnsafeSnippets;
 94 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 95 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 96 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 97 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 98 import org.graalvm.compiler.hotspot.word.KlassPointer;
 99 import org.graalvm.compiler.nodes.AbstractBeginNode;
100 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
101 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
102 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
103 import org.graalvm.compiler.nodes.ConstantNode;
104 import org.graalvm.compiler.nodes.FixedNode;
105 import org.graalvm.compiler.nodes.GetObjectAddressNode;
106 import org.graalvm.compiler.nodes.Invoke;
107 import org.graalvm.compiler.nodes.LogicNode;
</pre>
<hr />
<pre>
136 import org.graalvm.compiler.nodes.gc.G1ArrayRangePreWriteBarrier;
137 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;
138 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;
139 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;
140 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;
141 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
142 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
143 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
144 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
145 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
146 import org.graalvm.compiler.nodes.java.InstanceOfNode;
147 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
148 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
149 import org.graalvm.compiler.nodes.java.MonitorExitNode;
150 import org.graalvm.compiler.nodes.java.MonitorIdNode;
151 import org.graalvm.compiler.nodes.java.NewArrayNode;
152 import org.graalvm.compiler.nodes.java.NewInstanceNode;
153 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
154 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
155 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
<span class="line-modified">156 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
157 import org.graalvm.compiler.nodes.memory.ReadNode;
158 import org.graalvm.compiler.nodes.memory.WriteNode;
159 import org.graalvm.compiler.nodes.memory.address.AddressNode;
160 import org.graalvm.compiler.nodes.spi.LoweringProvider;
161 import org.graalvm.compiler.nodes.spi.LoweringTool;
162 import org.graalvm.compiler.nodes.spi.StampProvider;
163 import org.graalvm.compiler.nodes.type.StampTool;
164 import org.graalvm.compiler.nodes.util.GraphUtil;
165 import org.graalvm.compiler.options.OptionValues;
166 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
167 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
168 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
169 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithDelayedLoweringNode;
170 import org.graalvm.compiler.replacements.nodes.AssertionNode;
171 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
172 import jdk.internal.vm.compiler.word.LocationIdentity;
173 
174 import jdk.vm.ci.code.TargetDescription;
175 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
176 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
177 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
178 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
179 import jdk.vm.ci.meta.JavaConstant;
180 import jdk.vm.ci.meta.JavaKind;
181 import jdk.vm.ci.meta.JavaType;
182 import jdk.vm.ci.meta.MetaAccessProvider;
183 import jdk.vm.ci.meta.ResolvedJavaField;
184 import jdk.vm.ci.meta.ResolvedJavaType;
185 
186 /**
187  * HotSpot implementation of {@link LoweringProvider}.
188  */
189 public abstract class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {
190 
191     protected final HotSpotGraalRuntimeProvider runtime;
192     protected final HotSpotRegistersProvider registers;
193     protected final HotSpotConstantReflectionProvider constantReflection;
194 
195     protected InstanceOfSnippets.Templates instanceofSnippets;
<span class="line-modified">196     protected NewObjectSnippets.Templates newObjectSnippets;</span>
197     protected MonitorSnippets.Templates monitorSnippets;
198     protected HotSpotSerialWriteBarrierSnippets.Templates serialWriteBarrierSnippets;
199     protected HotSpotG1WriteBarrierSnippets.Templates g1WriteBarrierSnippets;
200     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
201     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
202     protected AssertionSnippets.Templates assertionSnippets;
203     protected ArrayCopySnippets.Templates arraycopySnippets;
204     protected StringToBytesSnippets.Templates stringToBytesSnippets;
205     protected HashCodeSnippets.Templates hashCodeSnippets;
206     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
207     protected ProfileSnippets.Templates profileSnippets;
208     protected ObjectSnippets.Templates objectSnippets;
209     protected UnsafeSnippets.Templates unsafeSnippets;
210     protected ObjectCloneSnippets.Templates objectCloneSnippets;
211     protected ForeignCallSnippets.Templates foreignCallSnippets;
212 
213     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
214                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
215         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
216         this.runtime = runtime;
217         this.registers = registers;
218         this.constantReflection = constantReflection;
219 
220     }
221 
222     @Override
223     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
224         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
225 
226         assert target == providers.getCodeCache().getTarget();
227         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
<span class="line-modified">228         newObjectSnippets = new NewObjectSnippets.Templates(options, factories, runtime, providers, target, config);</span>
229         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
230         g1WriteBarrierSnippets = new HotSpotG1WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
231         serialWriteBarrierSnippets = new HotSpotSerialWriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
232         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
233         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
234         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
235         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
236         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
237         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
238         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
239         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
240         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
241         objectSnippets = new ObjectSnippets.Templates(options, factories, providers, target);
242         unsafeSnippets = new UnsafeSnippets.Templates(options, factories, providers, target);
243         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
244             // AOT only introduced in JDK 9
245             profileSnippets = null;
246         } else {
247             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);
248         }
</pre>
<hr />
<pre>
293                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
294                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
295                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
296                         instanceOfDynamicNode.setMirror(classGetHub);
297                     }
298 
299                     if (instanceOfDynamicNode.allowsNull()) {
300                         ValueNode object = instanceOfDynamicNode.getObject();
301                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(
302                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
303                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
304                         instanceOfDynamicNode.replaceAndDelete(newNode);
305                     }
306                 }
307             } else if (n instanceof ClassIsAssignableFromNode) {
308                 if (graph.getGuardsStage().areDeoptsFixed()) {
309                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
310                 }
311             } else if (n instanceof NewInstanceNode) {
312                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">313                     newObjectSnippets.lower((NewInstanceNode) n, registers, tool);</span>
314                 }
315             } else if (n instanceof DynamicNewInstanceNode) {
316                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
317                 if (newInstanceNode.getClassClass() == null) {
318                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
319                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
320                     newInstanceNode.setClassClass(classClass);
321                 }
322                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">323                     newObjectSnippets.lower(newInstanceNode, registers, tool);</span>
324                 }
325             } else if (n instanceof NewArrayNode) {
326                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">327                     newObjectSnippets.lower((NewArrayNode) n, registers, tool);</span>
328                 }
329             } else if (n instanceof DynamicNewArrayNode) {
330                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
331                 if (dynamicNewArrayNode.getVoidClass() == null) {
332                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
333                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
334                     dynamicNewArrayNode.setVoidClass(voidClass);
335                 }
336                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">337                     newObjectSnippets.lower(dynamicNewArrayNode, registers, tool);</span>
338                 }
339             } else if (n instanceof VerifyHeapNode) {
340                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">341                     newObjectSnippets.lower((VerifyHeapNode) n, registers, tool);</span>
342                 }
343             } else if (n instanceof RawMonitorEnterNode) {
344                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
345                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
346                 }
347             } else if (n instanceof MonitorExitNode) {
348                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
349                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
350                 }
351             } else if (n instanceof ArrayCopyNode) {
352                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
353             } else if (n instanceof ArrayCopyWithDelayedLoweringNode) {
354                 arraycopySnippets.lower((ArrayCopyWithDelayedLoweringNode) n, tool);
355             } else if (n instanceof G1PreWriteBarrier) {
356                 g1WriteBarrierSnippets.lower((G1PreWriteBarrier) n, tool);
357             } else if (n instanceof G1PostWriteBarrier) {
358                 g1WriteBarrierSnippets.lower((G1PostWriteBarrier) n, tool);
359             } else if (n instanceof G1ReferentFieldReadBarrier) {
360                 g1WriteBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, tool);
361             } else if (n instanceof SerialWriteBarrier) {
362                 serialWriteBarrierSnippets.lower((SerialWriteBarrier) n, tool);
363             } else if (n instanceof SerialArrayRangeWriteBarrier) {
364                 serialWriteBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);
365             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
366                 g1WriteBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, tool);
367             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
368                 g1WriteBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, tool);
369             } else if (n instanceof NewMultiArrayNode) {
370                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">371                     newObjectSnippets.lower((NewMultiArrayNode) n, tool);</span>
372                 }
373             } else if (n instanceof LoadExceptionObjectNode) {
374                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
375             } else if (n instanceof AssertionNode) {
376                 assertionSnippets.lower((AssertionNode) n, tool);
377             } else if (n instanceof StringToBytesNode) {
378                 if (graph.getGuardsStage().areDeoptsFixed()) {
379                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
380                 }
381             } else if (n instanceof IntegerDivRemNode) {
382                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
383                 // zero and the MIN_VALUE / -1 cases.
384             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
385                 /* No lowering, we generate LIR directly for these nodes. */
386             } else if (n instanceof ClassGetHubNode) {
387                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
388             } else if (n instanceof HubGetClassNode) {
389                 lowerHubGetClassNode((HubGetClassNode) n, tool);
390             } else if (n instanceof KlassLayoutHelperNode) {
391                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
</pre>
<hr />
<pre>
397                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
398             } else if (n instanceof ResolveDynamicConstantNode) {
399                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
400                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
401                 }
402             } else if (n instanceof ResolveConstantNode) {
403                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
404                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
405                 }
406             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
407                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
408                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
409                 }
410             } else if (n instanceof InitializeKlassNode) {
411                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
412                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
413                 }
414             } else if (n instanceof ProfileNode) {
415                 profileSnippets.lower((ProfileNode) n, tool);
416             } else if (n instanceof KlassBeingInitializedCheckNode) {
<span class="line-modified">417                 newObjectSnippets.lower((KlassBeingInitializedCheckNode) n, registers, tool);</span>
418             } else if (n instanceof FastNotifyNode) {
419                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
420                     objectSnippets.lower(n, tool);
421                 }
422             } else if (n instanceof UnsafeCopyMemoryNode) {
423                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
424                     unsafeSnippets.lower((UnsafeCopyMemoryNode) n, tool);
425                 }
426             } else {
427                 super.lower(n, tool);
428             }
429         }
430 
431     }
432 
433     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
434         /*
435          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
436          * potential safepoints and above it&#39;s uses.
437          */
</pre>
<hr />
<pre>
764         if (runtime.getVMConfig().useCompressedClassPointers) {
765             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
766         } else {
767             return memoryRead;
768         }
769     }
770 
771     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
772         assert !object.isConstant() || object.asConstant().isDefaultForKind();
773 
774         ValueNode writeValue = value;
775         if (runtime.getVMConfig().useCompressedClassPointers) {
776             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
777         }
778 
779         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
780         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE, false));
781     }
782 
783     @Override
<span class="line-modified">784     protected BarrierType fieldLoadBarrierType(ResolvedJavaField f) {</span>
785         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
786         if (loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;
787                         loadField.getName().equals(&quot;referent&quot;)) {
788             return BarrierType.WEAK_FIELD;
789         }
790         return super.fieldLoadBarrierType(f);
791     }
792 
793     @Override
794     public int fieldOffset(ResolvedJavaField f) {
795         return f.getOffset();
796     }
797 
798     @Override
799     public int arrayLengthOffset() {
800         return runtime.getVMConfig().arrayOopDescLengthOffset();
801     }
802 
803     @Override
804     protected final JavaKind getStorageKind(ResolvedJavaField field) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 59 import org.graalvm.compiler.graph.NodeInputList;
 60 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 61 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 62 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 63 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 64 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 65 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 66 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;
 67 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 68 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 69 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 70 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 71 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 72 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 73 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 74 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 75 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 76 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 77 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 78 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;
<span class="line-added"> 79 import org.graalvm.compiler.hotspot.replacements.HotSpotAllocationSnippets;</span>
 80 import org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets;
 81 import org.graalvm.compiler.hotspot.replacements.HotSpotSerialWriteBarrierSnippets;
 82 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 83 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 84 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 85 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 86 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 87 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;

 88 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.ObjectSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
 91 import org.graalvm.compiler.hotspot.replacements.UnsafeCopyMemoryNode;
 92 import org.graalvm.compiler.hotspot.replacements.UnsafeLoadSnippets;
 93 import org.graalvm.compiler.hotspot.replacements.UnsafeSnippets;
 94 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 95 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 96 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 97 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 98 import org.graalvm.compiler.hotspot.word.KlassPointer;
 99 import org.graalvm.compiler.nodes.AbstractBeginNode;
100 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
101 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
102 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
103 import org.graalvm.compiler.nodes.ConstantNode;
104 import org.graalvm.compiler.nodes.FixedNode;
105 import org.graalvm.compiler.nodes.GetObjectAddressNode;
106 import org.graalvm.compiler.nodes.Invoke;
107 import org.graalvm.compiler.nodes.LogicNode;
</pre>
<hr />
<pre>
136 import org.graalvm.compiler.nodes.gc.G1ArrayRangePreWriteBarrier;
137 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;
138 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;
139 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;
140 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;
141 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
142 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
143 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
144 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
145 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
146 import org.graalvm.compiler.nodes.java.InstanceOfNode;
147 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
148 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
149 import org.graalvm.compiler.nodes.java.MonitorExitNode;
150 import org.graalvm.compiler.nodes.java.MonitorIdNode;
151 import org.graalvm.compiler.nodes.java.NewArrayNode;
152 import org.graalvm.compiler.nodes.java.NewInstanceNode;
153 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
154 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
155 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
<span class="line-modified">156 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>
157 import org.graalvm.compiler.nodes.memory.ReadNode;
158 import org.graalvm.compiler.nodes.memory.WriteNode;
159 import org.graalvm.compiler.nodes.memory.address.AddressNode;
160 import org.graalvm.compiler.nodes.spi.LoweringProvider;
161 import org.graalvm.compiler.nodes.spi.LoweringTool;
162 import org.graalvm.compiler.nodes.spi.StampProvider;
163 import org.graalvm.compiler.nodes.type.StampTool;
164 import org.graalvm.compiler.nodes.util.GraphUtil;
165 import org.graalvm.compiler.options.OptionValues;
166 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
167 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
168 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
169 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithDelayedLoweringNode;
170 import org.graalvm.compiler.replacements.nodes.AssertionNode;
171 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
172 import jdk.internal.vm.compiler.word.LocationIdentity;
173 
174 import jdk.vm.ci.code.TargetDescription;
175 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
176 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
177 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
178 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
179 import jdk.vm.ci.meta.JavaConstant;
180 import jdk.vm.ci.meta.JavaKind;
181 import jdk.vm.ci.meta.JavaType;
182 import jdk.vm.ci.meta.MetaAccessProvider;
183 import jdk.vm.ci.meta.ResolvedJavaField;
184 import jdk.vm.ci.meta.ResolvedJavaType;
185 
186 /**
187  * HotSpot implementation of {@link LoweringProvider}.
188  */
189 public abstract class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {
190 
191     protected final HotSpotGraalRuntimeProvider runtime;
192     protected final HotSpotRegistersProvider registers;
193     protected final HotSpotConstantReflectionProvider constantReflection;
194 
195     protected InstanceOfSnippets.Templates instanceofSnippets;
<span class="line-modified">196     protected HotSpotAllocationSnippets.Templates allocationSnippets;</span>
197     protected MonitorSnippets.Templates monitorSnippets;
198     protected HotSpotSerialWriteBarrierSnippets.Templates serialWriteBarrierSnippets;
199     protected HotSpotG1WriteBarrierSnippets.Templates g1WriteBarrierSnippets;
200     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
201     protected UnsafeLoadSnippets.Templates unsafeLoadSnippets;
202     protected AssertionSnippets.Templates assertionSnippets;
203     protected ArrayCopySnippets.Templates arraycopySnippets;
204     protected StringToBytesSnippets.Templates stringToBytesSnippets;
205     protected HashCodeSnippets.Templates hashCodeSnippets;
206     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
207     protected ProfileSnippets.Templates profileSnippets;
208     protected ObjectSnippets.Templates objectSnippets;
209     protected UnsafeSnippets.Templates unsafeSnippets;
210     protected ObjectCloneSnippets.Templates objectCloneSnippets;
211     protected ForeignCallSnippets.Templates foreignCallSnippets;
212 
213     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
214                     HotSpotConstantReflectionProvider constantReflection, TargetDescription target) {
215         super(metaAccess, foreignCalls, target, runtime.getVMConfig().useCompressedOops);
216         this.runtime = runtime;
217         this.registers = registers;
218         this.constantReflection = constantReflection;
219 
220     }
221 
222     @Override
223     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
224         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
225 
226         assert target == providers.getCodeCache().getTarget();
227         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
<span class="line-modified">228         allocationSnippets = new HotSpotAllocationSnippets.Templates(options, factories, runtime, providers, target, config);</span>
229         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
230         g1WriteBarrierSnippets = new HotSpotG1WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
231         serialWriteBarrierSnippets = new HotSpotSerialWriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
232         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
233         unsafeLoadSnippets = new UnsafeLoadSnippets.Templates(options, factories, providers, target);
234         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
235         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
236         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
237         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
238         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
239         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
240         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
241         objectSnippets = new ObjectSnippets.Templates(options, factories, providers, target);
242         unsafeSnippets = new UnsafeSnippets.Templates(options, factories, providers, target);
243         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
244             // AOT only introduced in JDK 9
245             profileSnippets = null;
246         } else {
247             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);
248         }
</pre>
<hr />
<pre>
293                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
294                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
295                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
296                         instanceOfDynamicNode.setMirror(classGetHub);
297                     }
298 
299                     if (instanceOfDynamicNode.allowsNull()) {
300                         ValueNode object = instanceOfDynamicNode.getObject();
301                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(
302                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
303                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
304                         instanceOfDynamicNode.replaceAndDelete(newNode);
305                     }
306                 }
307             } else if (n instanceof ClassIsAssignableFromNode) {
308                 if (graph.getGuardsStage().areDeoptsFixed()) {
309                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
310                 }
311             } else if (n instanceof NewInstanceNode) {
312                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">313                     allocationSnippets.lower((NewInstanceNode) n, tool);</span>
314                 }
315             } else if (n instanceof DynamicNewInstanceNode) {
316                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
317                 if (newInstanceNode.getClassClass() == null) {
318                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
319                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
320                     newInstanceNode.setClassClass(classClass);
321                 }
322                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">323                     allocationSnippets.lower(newInstanceNode, tool);</span>
324                 }
325             } else if (n instanceof NewArrayNode) {
326                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">327                     allocationSnippets.lower((NewArrayNode) n, tool);</span>
328                 }
329             } else if (n instanceof DynamicNewArrayNode) {
330                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
331                 if (dynamicNewArrayNode.getVoidClass() == null) {
332                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
333                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
334                     dynamicNewArrayNode.setVoidClass(voidClass);
335                 }
336                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">337                     allocationSnippets.lower(dynamicNewArrayNode, tool);</span>
338                 }
339             } else if (n instanceof VerifyHeapNode) {
340                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">341                     allocationSnippets.lower((VerifyHeapNode) n, tool);</span>
342                 }
343             } else if (n instanceof RawMonitorEnterNode) {
344                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
345                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
346                 }
347             } else if (n instanceof MonitorExitNode) {
348                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
349                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
350                 }
351             } else if (n instanceof ArrayCopyNode) {
352                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
353             } else if (n instanceof ArrayCopyWithDelayedLoweringNode) {
354                 arraycopySnippets.lower((ArrayCopyWithDelayedLoweringNode) n, tool);
355             } else if (n instanceof G1PreWriteBarrier) {
356                 g1WriteBarrierSnippets.lower((G1PreWriteBarrier) n, tool);
357             } else if (n instanceof G1PostWriteBarrier) {
358                 g1WriteBarrierSnippets.lower((G1PostWriteBarrier) n, tool);
359             } else if (n instanceof G1ReferentFieldReadBarrier) {
360                 g1WriteBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, tool);
361             } else if (n instanceof SerialWriteBarrier) {
362                 serialWriteBarrierSnippets.lower((SerialWriteBarrier) n, tool);
363             } else if (n instanceof SerialArrayRangeWriteBarrier) {
364                 serialWriteBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);
365             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
366                 g1WriteBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, tool);
367             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
368                 g1WriteBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, tool);
369             } else if (n instanceof NewMultiArrayNode) {
370                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
<span class="line-modified">371                     allocationSnippets.lower((NewMultiArrayNode) n, tool);</span>
372                 }
373             } else if (n instanceof LoadExceptionObjectNode) {
374                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
375             } else if (n instanceof AssertionNode) {
376                 assertionSnippets.lower((AssertionNode) n, tool);
377             } else if (n instanceof StringToBytesNode) {
378                 if (graph.getGuardsStage().areDeoptsFixed()) {
379                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
380                 }
381             } else if (n instanceof IntegerDivRemNode) {
382                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
383                 // zero and the MIN_VALUE / -1 cases.
384             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
385                 /* No lowering, we generate LIR directly for these nodes. */
386             } else if (n instanceof ClassGetHubNode) {
387                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
388             } else if (n instanceof HubGetClassNode) {
389                 lowerHubGetClassNode((HubGetClassNode) n, tool);
390             } else if (n instanceof KlassLayoutHelperNode) {
391                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
</pre>
<hr />
<pre>
397                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
398             } else if (n instanceof ResolveDynamicConstantNode) {
399                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
400                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
401                 }
402             } else if (n instanceof ResolveConstantNode) {
403                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
404                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
405                 }
406             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
407                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
408                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
409                 }
410             } else if (n instanceof InitializeKlassNode) {
411                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
412                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
413                 }
414             } else if (n instanceof ProfileNode) {
415                 profileSnippets.lower((ProfileNode) n, tool);
416             } else if (n instanceof KlassBeingInitializedCheckNode) {
<span class="line-modified">417                 allocationSnippets.lower((KlassBeingInitializedCheckNode) n, tool);</span>
418             } else if (n instanceof FastNotifyNode) {
419                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
420                     objectSnippets.lower(n, tool);
421                 }
422             } else if (n instanceof UnsafeCopyMemoryNode) {
423                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
424                     unsafeSnippets.lower((UnsafeCopyMemoryNode) n, tool);
425                 }
426             } else {
427                 super.lower(n, tool);
428             }
429         }
430 
431     }
432 
433     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
434         /*
435          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
436          * potential safepoints and above it&#39;s uses.
437          */
</pre>
<hr />
<pre>
764         if (runtime.getVMConfig().useCompressedClassPointers) {
765             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
766         } else {
767             return memoryRead;
768         }
769     }
770 
771     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
772         assert !object.isConstant() || object.asConstant().isDefaultForKind();
773 
774         ValueNode writeValue = value;
775         if (runtime.getVMConfig().useCompressedClassPointers) {
776             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
777         }
778 
779         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
780         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE, false));
781     }
782 
783     @Override
<span class="line-modified">784     public BarrierType fieldLoadBarrierType(ResolvedJavaField f) {</span>
785         HotSpotResolvedJavaField loadField = (HotSpotResolvedJavaField) f;
786         if (loadField.getJavaKind() == JavaKind.Object &amp;&amp; metaAccess.lookupJavaType(Reference.class).equals(loadField.getDeclaringClass()) &amp;&amp;
787                         loadField.getName().equals(&quot;referent&quot;)) {
788             return BarrierType.WEAK_FIELD;
789         }
790         return super.fieldLoadBarrierType(f);
791     }
792 
793     @Override
794     public int fieldOffset(ResolvedJavaField f) {
795         return f.getOffset();
796     }
797 
798     @Override
799     public int arrayLengthOffset() {
800         return runtime.getVMConfig().arrayOopDescLengthOffset();
801     }
802 
803     @Override
804     protected final JavaKind getStorageKind(ResolvedJavaField field) {
</pre>
</td>
</tr>
</table>
<center><a href="../SymbolicSnippetEncoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="HotSpotGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
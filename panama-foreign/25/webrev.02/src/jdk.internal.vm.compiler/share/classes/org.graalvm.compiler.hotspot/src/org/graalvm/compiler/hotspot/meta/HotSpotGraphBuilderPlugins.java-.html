<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 28 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 30 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 31 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 33 
 34 import java.lang.invoke.ConstantCallSite;
 35 import java.lang.invoke.MutableCallSite;
 36 import java.lang.invoke.VolatileCallSite;
 37 import java.lang.reflect.Array;
 38 import java.lang.reflect.Type;
 39 import java.math.BigInteger;
 40 import java.util.zip.CRC32;
 41 
 42 import jdk.internal.vm.compiler.collections.Pair;
 43 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 44 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 45 import org.graalvm.compiler.core.common.type.ObjectStamp;
 46 import org.graalvm.compiler.core.common.type.StampFactory;
 47 import org.graalvm.compiler.core.common.type.TypeReference;
 48 import org.graalvm.compiler.debug.GraalError;
 49 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 50 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 51 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 52 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 53 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 54 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 55 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 57 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 58 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 59 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 60 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 61 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
 62 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 63 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 64 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 65 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 66 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
 67 import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
 68 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 69 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 70 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 71 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 72 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 73 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 74 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 75 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 76 import org.graalvm.compiler.nodes.ConstantNode;
 77 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 78 import org.graalvm.compiler.nodes.NodeView;
 79 import org.graalvm.compiler.nodes.ValueNode;
 80 import org.graalvm.compiler.nodes.calc.AddNode;
 81 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
 82 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 83 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 89 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 90 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 91 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
 92 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;
 93 import org.graalvm.compiler.nodes.memory.ReadNode;
 94 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 95 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 96 import org.graalvm.compiler.nodes.spi.Replacements;
 97 import org.graalvm.compiler.nodes.util.GraphUtil;
 98 import org.graalvm.compiler.options.OptionValues;
 99 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
100 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
101 import org.graalvm.compiler.replacements.MethodHandlePlugin;
102 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
103 import org.graalvm.compiler.replacements.ReplacementsImpl;
104 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
105 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
106 import org.graalvm.compiler.serviceprovider.GraalServices;
107 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
108 import org.graalvm.compiler.word.WordOperationPlugin;
109 import org.graalvm.compiler.word.WordTypes;
110 import jdk.internal.vm.compiler.word.LocationIdentity;
111 
112 import jdk.vm.ci.code.CodeUtil;
113 import jdk.vm.ci.code.TargetDescription;
114 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
115 import jdk.vm.ci.meta.ConstantReflectionProvider;
116 import jdk.vm.ci.meta.DeoptimizationAction;
117 import jdk.vm.ci.meta.JavaKind;
118 import jdk.vm.ci.meta.MetaAccessProvider;
119 import jdk.vm.ci.meta.ResolvedJavaMethod;
120 import jdk.vm.ci.services.Services;
121 import sun.misc.Unsafe;
122 
123 /**
124  * Defines the {@link Plugins} used when running on HotSpot.
125  */
126 public class HotSpotGraphBuilderPlugins {
127 
128     /**
129      * Creates a {@link Plugins} object that should be used when running on HotSpot.
130      *
131      * @param constantReflection
132      * @param snippetReflection
133      * @param foreignCalls
134      * @param options
135      * @param target
136      */
137     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,
138                     CompilerConfiguration compilerConfiguration,
139                     GraalHotSpotVMConfig config,
140                     HotSpotWordTypes wordTypes,
141                     MetaAccessProvider metaAccess,
142                     ConstantReflectionProvider constantReflection,
143                     SnippetReflectionProvider snippetReflection,
144                     ForeignCallsProvider foreignCalls,
145                     ReplacementsImpl replacements,
146                     OptionValues options, TargetDescription target) {
147         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);
148 
149         Plugins plugins = new Plugins(invocationPlugins);
150         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);
151         HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
152         HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
153 
154         plugins.appendTypePlugin(nodePlugin);
155         plugins.appendNodePlugin(nodePlugin);
156         if (!GeneratePIC.getValue(options)) {
157             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
158         }
159         plugins.appendInlineInvokePlugin(replacements);
160         if (InlineDuringParsing.getValue(options)) {
161             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
162         }
163 
164         if (GeneratePIC.getValue(options)) {
165             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());
166             if (TieredAOT.getValue(options)) {
167                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
168             }
169         } else {
170             if (config.instanceKlassInitThreadOffset != -1) {
171                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());
172             }
173         }
174 
175         invocationPlugins.defer(new Runnable() {
176 
177             @Override
178             public void run() {
179                 registerObjectPlugins(invocationPlugins, options, config, replacements);
180                 registerClassPlugins(plugins, config, replacements);
181                 registerSystemPlugins(invocationPlugins, foreignCalls);
182                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);
183                 if (!GeneratePIC.getValue(options)) {
184                     registerCallSitePlugins(invocationPlugins);
185                 }
186                 registerReflectionPlugins(invocationPlugins, replacements);
187                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacements);
188                 registerAESPlugins(invocationPlugins, config, replacements);
189                 registerCRC32Plugins(invocationPlugins, config, replacements);
190                 registerCRC32CPlugins(invocationPlugins, config, replacements);
191                 registerBigIntegerPlugins(invocationPlugins, config, replacements);
192                 registerSHAPlugins(invocationPlugins, config, replacements);
193                 registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
194                 registerCounterModePlugins(invocationPlugins, config, replacements);
195                 registerBase64Plugins(invocationPlugins, config, metaAccess, foreignCalls);
196                 registerUnsafePlugins(invocationPlugins, config, replacements);
197                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);
198                 registerArrayPlugins(invocationPlugins, replacements);
199                 registerStringPlugins(invocationPlugins, replacements);
200                 registerArraysSupportPlugins(invocationPlugins, config, replacements);
201 
202                 for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
203                     factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
204                 }
205             }
206         });
207         return plugins;
208     }
209 
210     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {
211         Registration r = new Registration(plugins, Object.class, replacements);
212         if (!GeneratePIC.getValue(options)) {
213             // FIXME: clone() requires speculation and requires a fix in here (to check that
214             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
215             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
216             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
217             // settings from the root compile instead. So, for now, I&#39;m disabling it for
218             // GeneratePIC.
219             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
220                 @Override
221                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
222                     ValueNode object = receiver.get();
223                     b.addPush(JavaKind.Object, new ObjectCloneNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), object));
224                     return true;
225                 }
226 
227                 @Override
228                 public boolean inlineOnly() {
229                     return true;
230                 }
231             });
232         }
233         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
234             @Override
235             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
236                 ValueNode object = receiver.get();
237                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));
238                 return true;
239             }
240 
241             @Override
242             public boolean inlineOnly() {
243                 return true;
244             }
245         });
246         if (config.inlineNotify()) {
247             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {
248                 @Override
249                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
250                     ValueNode object = receiver.get();
251                     b.add(new FastNotifyNode(object, false, b.bci()));
252                     return true;
253                 }
254 
255                 @Override
256                 public boolean inlineOnly() {
257                     return true;
258                 }
259             });
260         }
261         if (config.inlineNotifyAll()) {
262             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {
263                 @Override
264                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
265                     ValueNode object = receiver.get();
266                     b.add(new FastNotifyNode(object, true, b.bci()));
267                     return true;
268                 }
269 
270                 @Override
271                 public boolean inlineOnly() {
272                     return true;
273                 }
274             });
275         }
276     }
277 
278     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
279         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);
280 
281         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
282         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
283         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
284         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
285         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
286 
287         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE) != Integer.MAX_VALUE) {
288             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
289         }
290     }
291 
292     private static void registerCallSitePlugins(InvocationPlugins plugins) {
293         InvocationPlugin plugin = new InvocationPlugin() {
294             @Override
295             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
296                 ValueNode callSite = receiver.get();
297                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());
298                 if (folded != null) {
299                     b.addPush(JavaKind.Object, folded);
300                 } else {
301                     b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
302                 }
303                 return true;
304             }
305 
306             @Override
307             public boolean inlineOnly() {
308                 return true;
309             }
310         };
311         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
312         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
313         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
314     }
315 
316     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {
317         Registration r = new Registration(plugins, reflectionClass, replacements);
318         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
319             @Override
320             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
321                 b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
322                 return true;
323             }
324 
325             @Override
326             public boolean inlineOnly() {
327                 return true;
328             }
329         });
330         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
331     }
332 
333     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
334         Registration r;
335         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
336             r = new Registration(plugins, Unsafe.class, replacements);
337         } else {
338             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);
339         }
340         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;
341         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,
342                         long.class, long.class);
343     }
344 
345     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
346     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
347 
348     /**
349      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the
350      * {@code constantPoolOop} field in a ConstantPool value.
351      *
352      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
353      * @return a node representing the metaspace {@code ConstantPool} pointer associated with
354      *         {@code constantPoolOop}
355      */
356     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {
357         // ConstantPool.constantPoolOop is in fact the holder class.
358         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);
359         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));
360 
361         boolean notCompressible = false;
362         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));
363         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);
364     }
365 
366     /**
367      * Emits a node representing an element in a metaspace {@code ConstantPool}.
368      *
369      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
370      */
371     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {
372         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
373         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());
374         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));
375         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));
376         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));
377         boolean notCompressible = false;
378         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
379         b.addPush(elementKind, elementValue);
380         return true;
381     }
382 
383     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
384         Registration r = new Registration(plugins, constantPoolClass, replacements);
385 
386         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
387             @Override
388             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
389                 boolean notCompressible = false;
390                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
391                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));
392                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);
393                 b.addPush(JavaKind.Int, length);
394                 return true;
395             }
396         });
397 
398         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
399             @Override
400             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
401                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);
402             }
403         });
404         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
405             @Override
406             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
407                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Long, wordTypes, config);
408             }
409         });
410         r.register3(&quot;getFloatAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
411             @Override
412             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
413                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Float, wordTypes, config);
414             }
415         });
416         r.register3(&quot;getDoubleAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
417             @Override
418             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
419                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Double, wordTypes, config);
420             }
421         });
422     }
423 
424     private static void registerSystemPlugins(InvocationPlugins plugins, ForeignCallsProvider foreignCalls) {
425         Registration r = new Registration(plugins, System.class);
426         r.register0(&quot;currentTimeMillis&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_MILLIS));
427         r.register0(&quot;nanoTime&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_NANOS));
428         r.register1(&quot;identityHashCode&quot;, Object.class, new InvocationPlugin() {
429             @Override
430             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
431                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));
432                 return true;
433             }
434 
435             @Override
436             public boolean inlineOnly() {
437                 return true;
438             }
439         });
440         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
441             @Override
442             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
443                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
444                 return true;
445             }
446 
447             @Override
448             public boolean inlineOnly() {
449                 return true;
450             }
451         });
452     }
453 
454     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
455         Registration r = new Registration(plugins, Array.class, replacements);
456         r.setAllowOverwrite(true);
457         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
458     }
459 
460     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {
461         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
462             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
463             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
464             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
465         }
466     }
467 
468     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
469         Registration r = new Registration(plugins, Thread.class, replacements);
470         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
471             @Override
472             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
473                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
474                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
475                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
476                 // JavaThread::_threadObj is never compressed
477                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
478                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
479                 return true;
480             }
481         });
482 
483         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {
484             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);
485         }
486 
487     }
488 
489     public static final String reflectionClass;
490     public static final String constantPoolClass;
491 
492     static {
493         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
494             reflectionClass = &quot;sun.reflect.Reflection&quot;;
495             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
496         } else {
497             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
498             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
499         }
500     }
501 
502     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
503         return selectIntrinsicName(config, className, name1, name2).getLeft();
504     }
505 
506     /**
507      * Returns a pair of Strings where the left one represents the matched intrinsic name and the
508      * right one represents the mismatched intrinsic name.
509      */
510     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
511         boolean foundName1 = false;
512         boolean foundName2 = false;
513         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
514             if (className.equals(intrinsic.declaringClass)) {
515                 if (name1.equals(intrinsic.name)) {
516                     foundName1 = true;
517                 } else if (name2.equals(intrinsic.name)) {
518                     foundName2 = true;
519                 }
520             }
521         }
522         if (foundName1 &amp;&amp; !foundName2) {
523             return Pair.create(name1, name2);
524         } else if (foundName2 &amp;&amp; !foundName1) {
525             return Pair.create(name2, name1);
526         }
527         throw GraalError.shouldNotReachHere();
528     }
529 
530     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {
531         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
532             if (className.equals(intrinsic.declaringClass)) {
533                 if (name.equals(intrinsic.name)) {
534                     return true;
535                 }
536             }
537         }
538         return false;
539     }
540 
541     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
542         if (config.useAESIntrinsics) {
543             assert config.aescryptEncryptBlockStub != 0L;
544             assert config.aescryptDecryptBlockStub != 0L;
545             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
546             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
547             String arch = config.osArch;
548             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
549 
550             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);
551 
552             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
553             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,
554                             byte[].class, int.class);
555 
556             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
557             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,
558                             byte[].class, int.class);
559 
560             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);
561 
562             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
563             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);
564 
565             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
566             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);
567         }
568     }
569 
570     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {
571         try {
572             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);
573         } catch (NoSuchMethodError e) {
574             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
575                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
576         }
577     }
578 
579     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {
580         try {
581             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);
582         } catch (NoSuchMethodError e) {
583             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
584                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
585         }
586     }
587 
588     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
589         Registration r = new Registration(plugins, BigInteger.class, replacements);
590         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;
591         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
592             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
593                             int.class, int[].class);
594         } else {
595             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
596                             int.class, int[].class);
597         }
598         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);
599         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,
600                         long.class, int[].class);
601         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,
602                         int[].class);
603         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);
604     }
605 
606     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
607         boolean useSha1 = config.useSHA1Intrinsics();
608         boolean useSha256 = config.useSHA256Intrinsics();
609         boolean useSha512 = config.useSHA512Intrinsics();
610 
611         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {
612             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);
613             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
614         }
615 
616         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);
617         if (useSha1) {
618             assert config.sha1ImplCompress != 0L;
619             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);
620             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
621         }
622         if (useSha256) {
623             assert config.sha256ImplCompress != 0L;
624             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);
625             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
626         }
627         if (useSha512) {
628             assert config.sha512ImplCompress != 0L;
629             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);
630             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
631         }
632     }
633 
634     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
635         if (config.useGHASHIntrinsics()) {
636             assert config.ghashProcessBlocks != 0L;
637             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
638             r.register5(&quot;processBlocks&quot;,
639                             byte[].class,
640                             int.class,
641                             int.class,
642                             long[].class,
643                             long[].class,
644                             new InvocationPlugin() {
645                                 @Override
646                                 public boolean apply(GraphBuilderContext b,
647                                                 ResolvedJavaMethod targetMethod,
648                                                 Receiver receiver,
649                                                 ValueNode data,
650                                                 ValueNode inOffset,
651                                                 ValueNode blocks,
652                                                 ValueNode state,
653                                                 ValueNode hashSubkey) {
654                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
655                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
656                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
657                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
658                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
659                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
660                                     b.add(new ForeignCallNode(foreignCalls, GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
661                                     return true;
662                                 }
663                             });
664         }
665     }
666 
667     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
668         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
669             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;
670             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);
671             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,
672                             int.class);
673         }
674     }
675 
676     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
677         if (config.useBase64Intrinsics()) {
678             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);
679             r.register7(&quot;encodeBlock&quot;,
680                             Receiver.class,
681                             byte[].class,
682                             int.class,
683                             int.class,
684                             byte[].class,
685                             int.class,
686                             boolean.class,
687                             new InvocationPlugin() {
688                                 @Override
689                                 public boolean apply(GraphBuilderContext b,
690                                                 ResolvedJavaMethod targetMethod,
691                                                 Receiver receiver,
692                                                 ValueNode src,
693                                                 ValueNode sp,
694                                                 ValueNode sl,
695                                                 ValueNode dst,
696                                                 ValueNode dp,
697                                                 ValueNode isURL) {
698                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
699                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));
700                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));
701                                     b.add(new ForeignCallNode(foreignCalls, BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));
702                                     return true;
703                                 }
704                             });
705         }
706     }
707 
708     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
709         Registration r = new Registration(plugins, CRC32.class, replacements);
710         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);
711         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
712             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
713             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);
714         } else {
715             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);
716             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);
717         }
718     }
719 
720     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
721         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
722             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);
723             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
724             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);
725         }
726     }
727 
728     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
729         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
730             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);
731             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,
732                             int.class, int.class);
733         }
734     }
735 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotAllocationSnippets.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
 28 import static jdk.vm.ci.meta.DeoptimizationAction.None;
 29 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
 30 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 31 import static org.graalvm.compiler.core.common.GraalOptions.MinimalBulkZeroingSize;
 32 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_OPTIONVALUES;
 33 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 34 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY;
 35 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_ARRAY_OR_NULL;
 36 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE;
 37 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_INSTANCE_OR_NULL;
 38 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY;
 39 import static org.graalvm.compiler.hotspot.HotSpotBackend.NEW_MULTI_ARRAY_OR_NULL;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_ARRAY_KLASS_LOCATION;
 41 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_INIT_STATE_LOCATION;
 42 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
 43 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.MARK_WORD_LOCATION;
 44 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.PROTOTYPE_MARK_WORD_LOCATION;
 45 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_END_LOCATION;
 46 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.TLAB_TOP_LOCATION;
 47 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.arrayKlassOffset;
 48 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.instanceKlassStateBeingInitialized;
 49 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.isInstanceKlassFullyInitialized;
 50 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeMask;
 51 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperHeaderSizeShift;
 52 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeMask;
 53 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.layoutHelperLog2ElementSizeShift;
 54 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.loadKlassFromObject;
 55 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.prototypeMarkWordOffset;
 56 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitState;
 57 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readInstanceKlassInitThread;
 58 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.readLayoutHelper;
 59 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.registerAsWord;
 60 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocations;
 61 import static org.graalvm.compiler.hotspot.replacements.HotspotSnippetsOptions.ProfileAllocationsContext;
 62 import static org.graalvm.compiler.nodes.PiArrayNode.piArrayCastToSnippetReplaceeStamp;
 63 import static org.graalvm.compiler.nodes.PiNode.piCastToSnippetReplaceeStamp;
 64 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.DEOPT_PROBABILITY;
 65 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.FAST_PATH_PROBABILITY;
 66 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.SLOW_PATH_PROBABILITY;
 67 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.VERY_FAST_PATH_PROBABILITY;
 68 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.probability;
 69 import static org.graalvm.compiler.replacements.ReplacementsUtil.runtimeAssert;
 70 import static org.graalvm.compiler.replacements.ReplacementsUtil.staticAssert;
 71 import static org.graalvm.compiler.replacements.SnippetTemplate.DEFAULT_REPLACER;
 72 import static org.graalvm.compiler.replacements.nodes.CStringConstant.cstring;
 73 
 74 import org.graalvm.compiler.api.replacements.Fold;
 75 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 76 import org.graalvm.compiler.api.replacements.Snippet;
 77 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
 78 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
 79 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 80 import org.graalvm.compiler.core.common.type.StampFactory;
 81 import org.graalvm.compiler.debug.DebugHandlersFactory;
 82 import org.graalvm.compiler.debug.GraalError;
 83 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 84 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 85 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 86 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
 87 import org.graalvm.compiler.hotspot.meta.HotSpotRegistersProvider;
 88 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;
 89 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyFixedNode;
 90 import org.graalvm.compiler.hotspot.nodes.aot.LoadConstantIndirectlyNode;
 91 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 92 import org.graalvm.compiler.hotspot.word.KlassPointer;
 93 import org.graalvm.compiler.nodes.ConstantNode;
 94 import org.graalvm.compiler.nodes.DeoptimizeNode;
 95 import org.graalvm.compiler.nodes.PiNode;
 96 import org.graalvm.compiler.nodes.SnippetAnchorNode;
 97 import org.graalvm.compiler.nodes.StructuredGraph;
 98 import org.graalvm.compiler.nodes.ValueNode;
 99 import org.graalvm.compiler.nodes.debug.DynamicCounterNode;
100 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
101 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
102 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
103 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
104 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
105 import org.graalvm.compiler.nodes.java.NewArrayNode;
106 import org.graalvm.compiler.nodes.java.NewInstanceNode;
107 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
108 import org.graalvm.compiler.nodes.spi.LoweringTool;
109 import org.graalvm.compiler.nodes.util.GraphUtil;
110 import org.graalvm.compiler.options.OptionValues;
111 import org.graalvm.compiler.replacements.AllocationSnippets;
112 import org.graalvm.compiler.replacements.SnippetCounter;
113 import org.graalvm.compiler.replacements.SnippetTemplate;
114 import org.graalvm.compiler.replacements.SnippetTemplate.AbstractTemplates;
115 import org.graalvm.compiler.replacements.SnippetTemplate.Arguments;
116 import org.graalvm.compiler.replacements.SnippetTemplate.SnippetInfo;
117 import org.graalvm.compiler.word.Word;
118 import jdk.internal.vm.compiler.word.UnsignedWord;
119 import jdk.internal.vm.compiler.word.WordFactory;
120 
121 import jdk.vm.ci.code.CodeUtil;
122 import jdk.vm.ci.code.Register;
123 import jdk.vm.ci.code.TargetDescription;
124 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
125 import jdk.vm.ci.meta.JavaKind;
126 import jdk.vm.ci.meta.MetaAccessProvider;
127 import jdk.vm.ci.meta.ResolvedJavaType;
128 
129 public class HotSpotAllocationSnippets extends AllocationSnippets {
130     /** New dynamic array stub that throws an {@link OutOfMemoryError} on allocation failure. */
131     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE = new ForeignCallDescriptor(&quot;dynamic_new_instance&quot;, Object.class, Class.class);
132     /** New dynamic array stub that returns null on allocation failure. */
133     public static final ForeignCallDescriptor DYNAMIC_NEW_INSTANCE_OR_NULL = new ForeignCallDescriptor(&quot;dynamic_new_instance_or_null&quot;, Object.class, Class.class);
134 
135     private final GraalHotSpotVMConfig config;
136     private final Register threadRegister;
137 
138     public HotSpotAllocationSnippets(GraalHotSpotVMConfig config, HotSpotRegistersProvider registers) {
139         this.config = config;
140         this.threadRegister = registers.getThreadRegister();
141     }
142 
143     @Snippet
144     protected Object allocateInstance(KlassPointer hub,
145                     Word prototypeMarkWord,
146                     @ConstantParameter long size,
147                     @ConstantParameter boolean fillContents,
148                     @ConstantParameter boolean emitMemoryBarrier,
149                     @ConstantParameter AllocationProfilingData profilingData) {
150         Object result = allocateInstanceImpl(hub.asWord(), prototypeMarkWord, WordFactory.unsigned(size), fillContents, emitMemoryBarrier, true, profilingData);
151         return piCastToSnippetReplaceeStamp(result);
152     }
153 
154     @Snippet
155     public Object allocateArray(KlassPointer hub,
156                     Word prototypeMarkWord,
157                     int length,
158                     @ConstantParameter int headerSize,
159                     @ConstantParameter int log2ElementSize,
160                     @ConstantParameter boolean fillContents,
161                     @ConstantParameter boolean emitMemoryBarrier,
162                     @ConstantParameter boolean maybeUnroll,
163                     @ConstantParameter boolean supportsBulkZeroing,
164                     @ConstantParameter AllocationProfilingData profilingData) {
165         Object result = allocateArrayImpl(hub.asWord(), prototypeMarkWord, length, headerSize, log2ElementSize, fillContents, headerSize, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing,
166                         profilingData);
167         return piArrayCastToSnippetReplaceeStamp(result, length);
168     }
169 
170     @Snippet
171     protected Object allocateInstancePIC(KlassPointer hub,
172                     Word prototypeMarkWord,
173                     @ConstantParameter long size,
174                     @ConstantParameter boolean fillContents,
175                     @ConstantParameter boolean emitMemoryBarrier,
176                     @ConstantParameter AllocationProfilingData profilingData) {
177         // Klass must be initialized by the time the first instance is allocated, therefore we can
178         // just load it from the corresponding cell and avoid the resolution check. We have to use a
179         // fixed load though, to prevent it from floating above the initialization.
180         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
181         Object result = allocateInstanceImpl(picHub.asWord(), prototypeMarkWord, WordFactory.unsigned(size), fillContents, emitMemoryBarrier, true, profilingData);
182         return piCastToSnippetReplaceeStamp(result);
183     }
184 
185     @Snippet
186     public Object allocateInstanceDynamic(Class&lt;?&gt; type,
187                     Class&lt;?&gt; classClass,
188                     @ConstantParameter boolean fillContents,
189                     @ConstantParameter boolean emitMemoryBarrier,
190                     @ConstantParameter AllocationProfilingData profilingData) {
191         if (probability(DEOPT_PROBABILITY, type == null)) {
192             DeoptimizeNode.deopt(None, RuntimeConstraint);
193         }
194         Class&lt;?&gt; nonNullType = PiNode.piCastNonNullClass(type, SnippetAnchorNode.anchor());
195 
196         if (probability(DEOPT_PROBABILITY, DynamicNewInstanceNode.throwsInstantiationException(type, classClass))) {
197             DeoptimizeNode.deopt(None, RuntimeConstraint);
198         }
199 
200         KlassPointer hub = ClassGetHubNode.readClass(nonNullType);
201         if (probability(FAST_PATH_PROBABILITY, !hub.isNull())) {
202             KlassPointer nonNullHub = ClassGetHubNode.piCastNonNull(hub, SnippetAnchorNode.anchor());
203 
204             if (probability(VERY_FAST_PATH_PROBABILITY, isInstanceKlassFullyInitialized(nonNullHub))) {
205                 int layoutHelper = readLayoutHelper(nonNullHub);
206                 /*
207                  * src/share/vm/oops/klass.hpp: For instances, layout helper is a positive number,
208                  * the instance size. This size is already passed through align_object_size and
209                  * scaled to bytes. The low order bit is set if instances of this class cannot be
210                  * allocated using the fastpath.
211                  */
212                 if (probability(FAST_PATH_PROBABILITY, (layoutHelper &amp; 1) == 0)) {
213                     Word prototypeMarkWord = nonNullHub.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
214                     /*
215                      * FIXME(je,ds): we should actually pass typeContext instead of &quot;&quot; but late
216                      * binding of parameters is not yet supported by the GraphBuilderPlugin system.
217                      */
218                     UnsignedWord size = WordFactory.unsigned(layoutHelper);
219                     return allocateInstanceImpl(nonNullHub.asWord(), prototypeMarkWord, size, fillContents, emitMemoryBarrier, false, profilingData);
220                 }
221             } else {
222                 DeoptimizeNode.deopt(None, RuntimeConstraint);
223             }
224         }
225         return PiNode.piCastToSnippetReplaceeStamp(dynamicNewInstanceStub(type));
226     }
227 
228     @Snippet
229     public Object allocatePrimitiveArrayPIC(KlassPointer hub,
230                     Word prototypeMarkWord,
231                     int length,
232                     @ConstantParameter int headerSize,
233                     @ConstantParameter int log2ElementSize,
234                     @ConstantParameter boolean fillContents,
235                     @ConstantParameter boolean emitMemoryBarrier,
236                     @ConstantParameter boolean maybeUnroll,
237                     @ConstantParameter boolean supportsBulkZeroing,
238                     @ConstantParameter AllocationProfilingData profilingData) {
239         // Primitive array types are eagerly pre-resolved. We can use a floating load.
240         KlassPointer picHub = LoadConstantIndirectlyNode.loadKlass(hub);
241         return allocateArrayImpl(picHub.asWord(), prototypeMarkWord, length, headerSize, log2ElementSize, fillContents, headerSize, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing, profilingData);
242     }
243 
244     @Snippet
245     public Object allocateArrayPIC(KlassPointer hub,
246                     Word prototypeMarkWord,
247                     int length,
248                     @ConstantParameter int headerSize,
249                     @ConstantParameter int log2ElementSize,
250                     @ConstantParameter boolean fillContents,
251                     @ConstantParameter boolean emitMemoryBarrier,
252                     @ConstantParameter boolean maybeUnroll,
253                     @ConstantParameter boolean supportsBulkZeroing,
254                     @ConstantParameter AllocationProfilingData profilingData) {
255         // Array type would be resolved by dominating resolution.
256         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
257         return allocateArrayImpl(picHub.asWord(), prototypeMarkWord, length, headerSize, log2ElementSize, fillContents, headerSize, emitMemoryBarrier, maybeUnroll, supportsBulkZeroing, profilingData);
258     }
259 
260     @Snippet
261     public Object allocateArrayDynamic(Class&lt;?&gt; elementType,
262                     Word prototypeMarkWord,
263                     Class&lt;?&gt; voidClass,
264                     int length,
265                     @ConstantParameter boolean fillContents,
266                     @ConstantParameter boolean emitMemoryBarrier,
267                     @ConstantParameter JavaKind knownElementKind,
268                     @ConstantParameter int knownLayoutHelper,
269                     @ConstantParameter boolean supportsBulkZeroing,
270                     @ConstantParameter AllocationProfilingData profilingData) {
271         /*
272          * We only need the dynamic check for void when we have no static information from
273          * knownElementKind.
274          */
275         staticAssert(knownElementKind != JavaKind.Void, &quot;unsupported knownElementKind&quot;);
276         if (knownElementKind == JavaKind.Illegal &amp;&amp; probability(SLOW_PATH_PROBABILITY, elementType == null || DynamicNewArrayNode.throwsIllegalArgumentException(elementType, voidClass))) {
277             DeoptimizeNode.deopt(None, RuntimeConstraint);
278         }
279 
280         KlassPointer klass = loadKlassFromObject(elementType, arrayKlassOffset(INJECTED_VMCONFIG), CLASS_ARRAY_KLASS_LOCATION);
281         if (probability(DEOPT_PROBABILITY, klass.isNull())) {
282             DeoptimizeNode.deopt(None, RuntimeConstraint);
283         }
284         KlassPointer nonNullKlass = ClassGetHubNode.piCastNonNull(klass, SnippetAnchorNode.anchor());
285 
286         if (probability(DEOPT_PROBABILITY, length &lt; 0)) {
287             DeoptimizeNode.deopt(None, RuntimeConstraint);
288         }
289         int layoutHelper;
290         if (knownElementKind == JavaKind.Illegal) {
291             layoutHelper = readLayoutHelper(nonNullKlass);
292         } else {
293             runtimeAssert(knownLayoutHelper == readLayoutHelper(nonNullKlass), &quot;layout mismatch&quot;);
294             layoutHelper = knownLayoutHelper;
295         }
296         //@formatter:off
297         // from src/share/vm/oops/klass.hpp:
298         //
299         // For arrays, layout helper is a negative number, containing four
300         // distinct bytes, as follows:
301         //    MSB:[tag, hsz, ebt, log2(esz)]:LSB
302         // where:
303         //    tag is 0x80 if the elements are oops, 0xC0 if non-oops
304         //    hsz is array header size in bytes (i.e., offset of first element)
305         //    ebt is the BasicType of the elements
306         //    esz is the element size in bytes
307         //@formatter:on
308 
309         int headerSize = (layoutHelper &gt;&gt; layoutHelperHeaderSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperHeaderSizeMask(INJECTED_VMCONFIG);
310         int log2ElementSize = (layoutHelper &gt;&gt; layoutHelperLog2ElementSizeShift(INJECTED_VMCONFIG)) &amp; layoutHelperLog2ElementSizeMask(INJECTED_VMCONFIG);
311 
312         Object result = allocateArrayImpl(nonNullKlass.asWord(), prototypeMarkWord, length, headerSize, log2ElementSize, fillContents, headerSize, emitMemoryBarrier, false, supportsBulkZeroing,
313                         profilingData);
314         return piArrayCastToSnippetReplaceeStamp(result, length);
315     }
316 
317     @Snippet
318     protected Object newmultiarray(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
319         return newMultiArrayImpl(hub.asWord(), rank, dimensions);
320     }
321 
322     @Snippet
323     private Object newmultiarrayPIC(KlassPointer hub, @ConstantParameter int rank, @VarargsParameter int[] dimensions) {
324         // Array type would be resolved by dominating resolution.
325         KlassPointer picHub = LoadConstantIndirectlyFixedNode.loadKlass(hub);
326         return newMultiArrayImpl(picHub.asWord(), rank, dimensions);
327     }
328 
329     @Snippet
330     private void verifyHeap() {
331         Word tlabInfo = getTLABInfo();
332         Word topValue = readTlabTop(tlabInfo);
333         if (!topValue.equal(WordFactory.zero())) {
334             Word topValueContents = topValue.readWord(0, MARK_WORD_LOCATION);
335             if (topValueContents.equal(WordFactory.zero())) {
336                 AssertionSnippets.vmMessageC(AssertionSnippets.ASSERTION_VM_MESSAGE_C, true, cstring(&quot;overzeroing of TLAB detected&quot;), 0L, 0L, 0L);
337             }
338         }
339     }
340 
341     @Snippet
342     private void threadBeingInitializedCheck(KlassPointer klass) {
343         int state = readInstanceKlassInitState(klass);
344         if (state != instanceKlassStateBeingInitialized(INJECTED_VMCONFIG)) {
345             // The klass is no longer being initialized so force recompilation
346             DeoptimizeNode.deopt(InvalidateRecompile, RuntimeConstraint);
347         } else if (getThread() != readInstanceKlassInitThread(klass)) {
348             // The klass is being initialized but this isn&#39;t the initializing thread so
349             // so deopt and allow execution to resume in the interpreter where it should block.
350             DeoptimizeNode.deopt(None, RuntimeConstraint);
351         }
352     }
353 
354     @Override
355     protected final int getPrefetchStyle() {
356         return HotSpotReplacementsUtil.allocatePrefetchStyle(INJECTED_VMCONFIG);
357     }
358 
359     @Override
360     protected final int getPrefetchLines(boolean isArray) {
361         if (isArray) {
362             return HotSpotReplacementsUtil.allocatePrefetchLines(INJECTED_VMCONFIG);
363         } else {
364             return HotSpotReplacementsUtil.allocateInstancePrefetchLines(INJECTED_VMCONFIG);
365         }
366     }
367 
368     @Override
369     protected final int getPrefetchStepSize() {
370         return HotSpotReplacementsUtil.allocatePrefetchStepSize(INJECTED_VMCONFIG);
371     }
372 
373     @Override
374     protected final int getPrefetchDistance() {
375         return HotSpotReplacementsUtil.allocatePrefetchDistance(INJECTED_VMCONFIG);
376     }
377 
378     @Override
379     protected final Object callNewInstanceStub(Word hub) {
380         KlassPointer klassPtr = KlassPointer.fromWord(hub);
381         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
382             return nonNullOrDeopt(newInstanceOrNull(NEW_INSTANCE_OR_NULL, klassPtr));
383         } else {
384             return newInstance(NEW_INSTANCE, klassPtr);
385         }
386     }
387 
388     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
389     private static native Object newInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
390 
391     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
392     private static native Object newInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub);
393 
394     /**
395      * When allocating on the slow path, determines whether to use a version of the runtime call
396      * that returns {@code null} on a failed allocation instead of raising an OutOfMemoryError.
397      */
398     @Fold
399     static boolean useNullAllocationStubs(@InjectedParameter GraalHotSpotVMConfig config) {
400         return config.areNullAllocationStubsAvailable();
401     }
402 
403     @Override
404     protected final Object callNewArrayStub(Word hub, int length) {
405         KlassPointer klassPtr = KlassPointer.fromWord(hub);
406         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
407             return nonNullOrDeopt(newArrayOrNull(NEW_ARRAY_OR_NULL, klassPtr, length));
408         } else {
409             return newArray(NEW_ARRAY, klassPtr, length);
410         }
411     }
412 
413     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
414     private static native Object newArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
415 
416     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
417     private static native Object newArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int length);
418 
419     /**
420      * Deoptimizes if {@code obj == null} otherwise returns {@code obj}.
421      */
422     private static Object nonNullOrDeopt(Object obj) {
423         if (BranchProbabilityNode.probability(BranchProbabilityNode.DEOPT_PROBABILITY, obj == null)) {
424             DeoptimizeNode.deopt(None, RuntimeConstraint);
425         }
426         return obj;
427     }
428 
429     public static Object dynamicNewInstanceStub(Class&lt;?&gt; elementType) {
430         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
431             return nonNullOrDeopt(dynamicNewInstanceOrNull(DYNAMIC_NEW_INSTANCE_OR_NULL, elementType));
432         } else {
433             return dynamicNewInstance(DYNAMIC_NEW_INSTANCE, elementType);
434         }
435     }
436 
437     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
438     public static native Object dynamicNewInstance(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
439 
440     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
441     public static native Object dynamicNewInstanceOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, Class&lt;?&gt; elementType);
442 
443     @Override
444     protected final Object callNewMultiArrayStub(Word hub, int rank, Word dims) {
445         KlassPointer klassPointer = KlassPointer.fromWord(hub);
446         if (useNullAllocationStubs(INJECTED_VMCONFIG)) {
447             return nonNullOrDeopt(newMultiArrayOrNull(NEW_MULTI_ARRAY_OR_NULL, klassPointer, rank, dims));
448         } else {
449             return newMultiArray(NEW_MULTI_ARRAY, klassPointer, rank, dims);
450         }
451     }
452 
453     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = true)
454     private static native Object newMultiArray(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
455 
456     @NodeIntrinsic(value = ForeignCallNode.class, injectedStampIsNonNull = false)
457     private static native Object newMultiArrayOrNull(@ConstantNodeParameter ForeignCallDescriptor descriptor, KlassPointer hub, int rank, Word dims);
458 
459     @Fold
460     static int getMinimalBulkZeroingSize(@InjectedParameter OptionValues optionValues) {
461         return MinimalBulkZeroingSize.getValue(optionValues);
462     }
463 
464     @Override
465     protected final int getMinimalBulkZeroingSize() {
466         return getMinimalBulkZeroingSize(INJECTED_OPTIONVALUES);
467     }
468 
469     @Override
470     protected final void initializeObjectHeader(Word memory, Word hub, Word prototypeMarkWord, boolean isArray) {
471         KlassPointer klassPtr = KlassPointer.fromWord(hub);
472         Word markWord = prototypeMarkWord;
473         if (!isArray &amp;&amp; HotSpotReplacementsUtil.useBiasedLocking(INJECTED_VMCONFIG)) {
474             markWord = klassPtr.readWord(prototypeMarkWordOffset(INJECTED_VMCONFIG), PROTOTYPE_MARK_WORD_LOCATION);
475         }
476 
477         HotSpotReplacementsUtil.initializeObjectHeader(memory, markWord, klassPtr);
478     }
479 
480     @Override
481     protected final int instanceHeaderSize() {
482         return HotSpotReplacementsUtil.instanceHeaderSize(INJECTED_VMCONFIG);
483     }
484 
485     @Override
486     protected final int arrayLengthOffset() {
487         return HotSpotReplacementsUtil.arrayLengthOffset(INJECTED_VMCONFIG);
488     }
489 
490     @Override
491     protected final int objectAlignment() {
492         return HotSpotReplacementsUtil.objectAlignment(INJECTED_VMCONFIG);
493     }
494 
495     @Override
496     protected final boolean useTLAB() {
497         return HotSpotReplacementsUtil.useTLAB(INJECTED_VMCONFIG);
498     }
499 
500     @Override
501     protected final boolean shouldAllocateInTLAB(UnsignedWord allocationSize, boolean isArray) {
502         if (HotSpotReplacementsUtil.useG1GC(INJECTED_VMCONFIG)) {
503             // The TLAB is sized in a way that humongous objects are never allocated in the TLAB.
504             // So, whatever fits into the TLAB can be allocated there.
505             return true;
506         } else {
507             return !isArray || allocationSize.belowThan(16 * 1024 * 1024);
508         }
509     }
510 
511     @Override
512     protected final Word getTLABInfo() {
513         return getThread();
514     }
515 
516     private Word getThread() {
517         return registerAsWord(threadRegister);
518     }
519 
520     @Override
521     protected final Word readTlabEnd(Word thread) {
522         return HotSpotReplacementsUtil.readTlabEnd(thread);
523     }
524 
525     @Override
526     protected final Word readTlabTop(Word thread) {
527         return HotSpotReplacementsUtil.readTlabTop(thread);
528     }
529 
530     @Override
531     protected final void writeTlabTop(Word thread, Word newTop) {
532         HotSpotReplacementsUtil.writeTlabTop(thread, newTop);
533     }
534 
535     @Override
536     protected final Object verifyOop(Object obj) {
537         return HotSpotReplacementsUtil.verifyOop(obj);
538     }
539 
540     @Override
541     protected final void profileAllocation(AllocationProfilingData profilingData, UnsignedWord size) {
542         if (doProfile(INJECTED_OPTIONVALUES)) {
543             String name = createName(INJECTED_OPTIONVALUES, profilingData);
544 
545             boolean context = withContext(INJECTED_OPTIONVALUES);
546             DynamicCounterNode.counter(&quot;number of bytes allocated&quot;, name, size.rawValue(), context);
547             DynamicCounterNode.counter(&quot;number of allocations&quot;, name, 1, context);
548         }
549     }
550 
551     @Fold
552     static boolean doProfile(@Fold.InjectedParameter OptionValues options) {
553         return ProfileAllocations.getValue(options);
554     }
555 
556     enum ProfileContext {
557         AllocatingMethod,
558         InstanceOrArray,
559         AllocatedType,
560         AllocatedTypesInMethod,
561         Total
562     }
563 
564     @Fold
565     static String createName(@Fold.InjectedParameter OptionValues options, AllocationProfilingData profilingData) {
566         HotSpotAllocationProfilingData hotspotAllocationProfilingData = (HotSpotAllocationProfilingData) profilingData;
567         switch (ProfileAllocationsContext.getValue(options)) {
568             case AllocatingMethod:
569                 return &quot;&quot;;
570             case InstanceOrArray:
571                 return hotspotAllocationProfilingData.path;
572             case AllocatedType:
573             case AllocatedTypesInMethod:
574                 return hotspotAllocationProfilingData.typeContext;
575             case Total:
576                 return &quot;bytes&quot;;
577             default:
578                 throw GraalError.shouldNotReachHere();
579         }
580     }
581 
582     @Fold
583     static boolean withContext(@Fold.InjectedParameter OptionValues options) {
584         ProfileContext context = ProfileAllocationsContext.getValue(options);
585         return context == ProfileContext.AllocatingMethod || context == ProfileContext.AllocatedTypesInMethod;
586     }
587 
588     static HotSpotResolvedObjectType lookupArrayClass(MetaAccessProvider metaAccessProvider, JavaKind kind) {
589         return (HotSpotResolvedObjectType) metaAccessProvider.lookupJavaType(kind == JavaKind.Object ? Object.class : kind.toJavaClass()).getArrayClass();
590     }
591 
592     public static class Templates extends AbstractTemplates {
593         private final GraalHotSpotVMConfig config;
594         private final AllocationSnippetCounters snippetCounters;
595         private HotSpotAllocationProfilingData profilingData;
596 
597         private final SnippetInfo allocateInstance;
598         private final SnippetInfo allocateInstancePIC;
599         private final SnippetInfo allocateArray;
600         private final SnippetInfo allocateArrayPIC;
601         private final SnippetInfo allocatePrimitiveArrayPIC;
602         private final SnippetInfo allocateArrayDynamic;
603         private final SnippetInfo allocateInstanceDynamic;
604         private final SnippetInfo newmultiarray;
605         private final SnippetInfo newmultiarrayPIC;
606         private final SnippetInfo verifyHeap;
607         private final SnippetInfo threadBeingInitializedCheck;
608 
609         public Templates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory groupFactory, HotSpotProviders providers, TargetDescription target,
610                         GraalHotSpotVMConfig config) {
611             super(options, factories, providers, providers.getSnippetReflection(), target);
612             this.config = config;
613             snippetCounters = new AllocationSnippetCounters(groupFactory);
614 
615             HotSpotAllocationSnippets receiver = new HotSpotAllocationSnippets(config, providers.getRegisters());
616 
617             allocateInstance = snippet(HotSpotAllocationSnippets.class, &quot;allocateInstance&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION,
618                             PROTOTYPE_MARK_WORD_LOCATION);
619             allocateArray = snippet(HotSpotAllocationSnippets.class, &quot;allocateArray&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
620             allocateInstancePIC = snippet(HotSpotAllocationSnippets.class, &quot;allocateInstancePIC&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION,
621                             PROTOTYPE_MARK_WORD_LOCATION);
622             allocateArrayPIC = snippet(HotSpotAllocationSnippets.class, &quot;allocateArrayPIC&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
623             allocatePrimitiveArrayPIC = snippet(HotSpotAllocationSnippets.class, &quot;allocatePrimitiveArrayPIC&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
624                             TLAB_END_LOCATION);
625             allocateArrayDynamic = snippet(HotSpotAllocationSnippets.class, &quot;allocateArrayDynamic&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
626                             TLAB_END_LOCATION);
627             allocateInstanceDynamic = snippet(HotSpotAllocationSnippets.class, &quot;allocateInstanceDynamic&quot;, null, receiver, MARK_WORD_LOCATION, HUB_WRITE_LOCATION, TLAB_TOP_LOCATION,
628                             TLAB_END_LOCATION, PROTOTYPE_MARK_WORD_LOCATION, CLASS_INIT_STATE_LOCATION);
629             newmultiarray = snippet(HotSpotAllocationSnippets.class, &quot;newmultiarray&quot;, null, receiver, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
630             newmultiarrayPIC = snippet(HotSpotAllocationSnippets.class, &quot;newmultiarrayPIC&quot;, null, receiver, TLAB_TOP_LOCATION, TLAB_END_LOCATION);
631             verifyHeap = snippet(HotSpotAllocationSnippets.class, &quot;verifyHeap&quot;, null, receiver);
632             threadBeingInitializedCheck = snippet(HotSpotAllocationSnippets.class, &quot;threadBeingInitializedCheck&quot;, null, receiver);
633         }
634 
635         private AllocationProfilingData getProfilingData(OptionValues localOptions, String path, ResolvedJavaType type) {
636             if (ProfileAllocations.getValue(localOptions)) {
637                 // Create one object per snippet instantiation - this kills the snippet caching as
638                 // we need to add the object as a constant to the snippet.
639                 String typeContext = type == null ? null : type.toJavaName(false);
640                 return new HotSpotAllocationProfilingData(snippetCounters, path, typeContext);
641             } else if (profilingData == null) {
642                 profilingData = new HotSpotAllocationProfilingData(snippetCounters, null, null);
643             }
644 
645             return profilingData;
646         }
647 
648         /**
649          * Lowers a {@link NewInstanceNode}.
650          */
651         public void lower(NewInstanceNode node, LoweringTool tool) {
652             StructuredGraph graph = node.graph();
653             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) node.instanceClass();
654             assert !type.isArray();
655             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
656             long size = instanceSize(type);
657 
658             OptionValues localOptions = graph.getOptions();
659             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? allocateInstancePIC : allocateInstance;
660             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
661             args.add(&quot;hub&quot;, hub);
662             args.add(&quot;prototypeMarkWord&quot;, type.prototypeMarkWord());
663             args.addConst(&quot;size&quot;, size);
664             args.addConst(&quot;fillContents&quot;, node.fillContents());
665             args.addConst(&quot;emitMemoryBarrier&quot;, node.emitMemoryBarrier());
666             args.addConst(&quot;profilingData&quot;, getProfilingData(localOptions, &quot;instance&quot;, type));
667 
668             SnippetTemplate template = template(node, args);
669             graph.getDebug().log(&quot;Lowering allocateInstance in %s: node=%s, template=%s, arguments=%s&quot;, graph, node, template, args);
670             template.instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
671         }
672 
673         /**
674          * Lowers a {@link NewArrayNode}.
675          */
676         public void lower(NewArrayNode node, LoweringTool tool) {
677             StructuredGraph graph = node.graph();
678             ResolvedJavaType elementType = node.elementType();
679             HotSpotResolvedObjectType arrayType = (HotSpotResolvedObjectType) elementType.getArrayClass();
680             JavaKind elementKind = elementType.getJavaKind();
681             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), arrayType.klass(), providers.getMetaAccess(), graph);
682             final int headerSize = tool.getMetaAccess().getArrayBaseOffset(elementKind);
683             int log2ElementSize = CodeUtil.log2(tool.getMetaAccess().getArrayIndexScale(elementKind));
684 
685             OptionValues localOptions = graph.getOptions();
686             SnippetInfo snippet;
687             if (GeneratePIC.getValue(localOptions)) {
688                 if (elementType.isPrimitive()) {
689                     snippet = allocatePrimitiveArrayPIC;
690                 } else {
691                     snippet = allocateArrayPIC;
692                 }
693             } else {
694                 snippet = allocateArray;
695             }
696 
697             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
698             args.add(&quot;hub&quot;, hub);
699             assert arrayType.prototypeMarkWord() == lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord() : &quot;all array types are assumed to have the same prototypeMarkWord&quot;;
700             args.add(&quot;prototypeMarkWord&quot;, arrayType.prototypeMarkWord());
701             ValueNode length = node.length();
702             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
703             args.addConst(&quot;headerSize&quot;, headerSize);
704             args.addConst(&quot;log2ElementSize&quot;, log2ElementSize);
705             args.addConst(&quot;fillContents&quot;, node.fillContents());
706             args.addConst(&quot;emitMemoryBarrier&quot;, node.emitMemoryBarrier());
707             args.addConst(&quot;maybeUnroll&quot;, length.isConstant());
708             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());
709             args.addConst(&quot;profilingData&quot;, getProfilingData(localOptions, &quot;array&quot;, arrayType));
710 
711             SnippetTemplate template = template(node, args);
712             graph.getDebug().log(&quot;Lowering allocateArray in %s: node=%s, template=%s, arguments=%s&quot;, graph, node, template, args);
713             template.instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
714         }
715 
716         public void lower(NewMultiArrayNode node, LoweringTool tool) {
717             StructuredGraph graph = node.graph();
718             OptionValues localOptions = graph.getOptions();
719             int rank = node.dimensionCount();
720             ValueNode[] dims = new ValueNode[rank];
721             for (int i = 0; i &lt; node.dimensionCount(); i++) {
722                 dims[i] = node.dimension(i);
723             }
724             HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) node.type();
725             ConstantNode hub = ConstantNode.forConstant(KlassPointerStamp.klassNonNull(), type.klass(), providers.getMetaAccess(), graph);
726 
727             SnippetInfo snippet = GeneratePIC.getValue(localOptions) ? newmultiarrayPIC : newmultiarray;
728             Arguments args = new Arguments(snippet, graph.getGuardsStage(), tool.getLoweringStage());
729             args.add(&quot;hub&quot;, hub);
730             args.addConst(&quot;rank&quot;, rank);
731             args.addVarargs(&quot;dimensions&quot;, int.class, StampFactory.forKind(JavaKind.Int), dims);
732 
733             template(node, args).instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
734         }
735 
736         public void lower(DynamicNewInstanceNode node, LoweringTool tool) {
737             OptionValues localOptions = node.graph().getOptions();
738             ValueNode classClass = node.getClassClass();
739             assert classClass != null;
740 
741             Arguments args = new Arguments(allocateInstanceDynamic, node.graph().getGuardsStage(), tool.getLoweringStage());
742             args.add(&quot;type&quot;, node.getInstanceType());
743             args.add(&quot;classClass&quot;, classClass);
744             args.addConst(&quot;fillContents&quot;, node.fillContents());
745             args.addConst(&quot;emitMemoryBarrier&quot;, node.emitMemoryBarrier());
746             args.addConst(&quot;profilingData&quot;, getProfilingData(localOptions, &quot;&quot;, null));
747 
748             template(node, args).instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
749         }
750 
751         public void lower(DynamicNewArrayNode node, LoweringTool tool) {
752             StructuredGraph graph = node.graph();
753             OptionValues localOptions = graph.getOptions();
754             ValueNode length = node.length();
755             ValueNode voidClass = node.getVoidClass();
756             assert voidClass != null;
757 
758             Arguments args = new Arguments(allocateArrayDynamic, graph.getGuardsStage(), tool.getLoweringStage());
759             args.add(&quot;elementType&quot;, node.getElementType());
760             args.add(&quot;prototypeMarkWord&quot;, lookupArrayClass(tool, JavaKind.Object).prototypeMarkWord());
761             args.add(&quot;voidClass&quot;, voidClass);
762             args.add(&quot;length&quot;, length.isAlive() ? length : graph.addOrUniqueWithInputs(length));
763             args.addConst(&quot;fillContents&quot;, node.fillContents());
764             args.addConst(&quot;emitMemoryBarrier&quot;, node.emitMemoryBarrier());
765             /*
766              * We use Kind.Illegal as a marker value instead of null because constant snippet
767              * parameters cannot be null.
768              */
769             args.addConst(&quot;knownElementKind&quot;, node.getKnownElementKind() == null ? JavaKind.Illegal : node.getKnownElementKind());
770             if (node.getKnownElementKind() != null) {
771                 args.addConst(&quot;knownLayoutHelper&quot;, lookupArrayClass(tool, node.getKnownElementKind()).layoutHelper());
772             } else {
773                 args.addConst(&quot;knownLayoutHelper&quot;, 0);
774             }
775             args.addConst(&quot;supportsBulkZeroing&quot;, tool.getLowerer().supportsBulkZeroing());
776             args.addConst(&quot;profilingData&quot;, getProfilingData(localOptions, &quot;dynamic type&quot;, null));
777 
778             template(node, args).instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
779         }
780 
781         public void lower(VerifyHeapNode node, LoweringTool tool) {
782             if (config.cAssertions) {
783                 Arguments args = new Arguments(verifyHeap, node.graph().getGuardsStage(), tool.getLoweringStage());
784 
785                 template(node, args).instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
786             } else {
787                 GraphUtil.removeFixedWithUnusedInputs(node);
788             }
789         }
790 
791         public void lower(KlassBeingInitializedCheckNode node, LoweringTool tool) {
792             Arguments args = new Arguments(threadBeingInitializedCheck, node.graph().getGuardsStage(), tool.getLoweringStage());
793             args.add(&quot;klass&quot;, node.getKlass());
794 
795             template(node, args).instantiate(providers.getMetaAccess(), node, DEFAULT_REPLACER, args);
796         }
797 
798         private static HotSpotResolvedObjectType lookupArrayClass(LoweringTool tool, JavaKind kind) {
799             return HotSpotAllocationSnippets.lookupArrayClass(tool.getMetaAccess(), kind);
800         }
801 
802         private static long instanceSize(HotSpotResolvedObjectType type) {
803             long size = type.instanceSize();
804             assert size &gt;= 0;
805             return size;
806         }
807     }
808 
809     private static class HotSpotAllocationProfilingData extends AllocationProfilingData {
810         String path;
811         String typeContext;
812 
813         HotSpotAllocationProfilingData(AllocationSnippetCounters snippetCounters, String path, String typeContext) {
814             super(snippetCounters);
815             this.path = path;
816             this.typeContext = typeContext;
817         }
818     }
819 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64AddressLoweringByUse.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2017, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 
 27 package org.graalvm.compiler.core.aarch64;
 28 
<a name="2" id="anc2"></a><span class="line-modified"> 29 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;</span>
 30 import org.graalvm.compiler.core.common.LIRKind;
 31 import org.graalvm.compiler.core.common.NumUtil;
 32 import org.graalvm.compiler.core.common.type.Stamp;
 33 import org.graalvm.compiler.nodes.ValueNode;
 34 import org.graalvm.compiler.nodes.calc.AddNode;
<a name="3" id="anc3"></a><span class="line-added"> 35 import org.graalvm.compiler.nodes.calc.LeftShiftNode;</span>
<span class="line-added"> 36 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;</span>
 37 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 38 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 39 import org.graalvm.compiler.phases.common.AddressLoweringByUsePhase;
 40 
 41 import jdk.vm.ci.aarch64.AArch64Kind;
 42 import jdk.vm.ci.meta.JavaConstant;
 43 
 44 public class AArch64AddressLoweringByUse extends AddressLoweringByUsePhase.AddressLoweringByUse {
 45     private AArch64LIRKindTool kindtool;
<a name="4" id="anc4"></a><span class="line-added"> 46     private boolean supportsDerivedReference;</span>
 47 
 48     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool) {
<a name="5" id="anc5"></a><span class="line-added"> 49         this(kindtool, true);</span>
<span class="line-added"> 50     }</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52     public AArch64AddressLoweringByUse(AArch64LIRKindTool kindtool, boolean supportsDerivedReference) {</span>
 53         this.kindtool = kindtool;
<a name="6" id="anc6"></a><span class="line-added"> 54         this.supportsDerivedReference = supportsDerivedReference;</span>
 55     }
 56 
 57     @Override
 58     public AddressNode lower(ValueNode use, Stamp stamp, AddressNode address) {
 59         if (address instanceof OffsetAddressNode) {
 60             OffsetAddressNode offsetAddress = (OffsetAddressNode) address;
 61             return doLower(stamp, offsetAddress.getBase(), offsetAddress.getOffset());
 62         } else {
 63             // must be an already transformed AArch64AddressNode
 64             return address;
 65         }
 66     }
 67 
 68     @Override
 69     public AddressNode lower(AddressNode address) {
 70         return lower(null, null, address);
 71     }
 72 
 73     private AddressNode doLower(Stamp stamp, ValueNode base, ValueNode index) {
 74         AArch64AddressNode ret = new AArch64AddressNode(base, index);
 75         AArch64Kind aarch64Kind = (stamp == null ? null : getAArch64Kind(stamp));
 76 
 77         // improve the address as much as possible
 78         boolean changed;
 79         do {
 80             changed = improve(aarch64Kind, ret);
 81         } while (changed);
 82 
 83         // avoid duplicates
 84         return base.graph().unique(ret);
 85     }
 86 
<a name="7" id="anc7"></a><span class="line-modified"> 87     private boolean improve(AArch64Kind kind, AArch64AddressNode ret) {</span>
<span class="line-modified"> 88         AddressingMode mode = ret.getAddressingMode();</span>
 89         // if we have already set a displacement or set to base only mode then we are done
 90         if (isDisplacementMode(mode) || isBaseOnlyMode(mode)) {
 91             return false;
 92         }
 93         ValueNode base = ret.getBase();
 94         ValueNode index = ret.getIndex();
 95 
 96         // avoid a constant or null base if possible
 97         if (base == null) {
 98             ret.setBase(index);
 99             ret.setIndex(base);
100             return true;
101         }
102         // make sure any integral JavaConstant
103         // is the index rather than the base
104         // strictly we don&#39;t need the conditions on index
105         // as we ought not to see two JavaConstant values
106         if (base.isJavaConstant() &amp;&amp; base.asJavaConstant().getJavaKind().isNumericInteger() &amp;&amp;
107                         index != null &amp;&amp; !index.isJavaConstant()) {
108             ret.setBase(index);
109             ret.setIndex(base);
110             return true;
111         }
112 
113         // if the base is an add then move it up
114         if (index == null &amp;&amp; base instanceof AddNode) {
115             AddNode add = (AddNode) base;
116             ret.setBase(add.getX());
117             ret.setIndex(add.getY());
118             return true;
119         }
120 
121         // we can try to fold a JavaConstant index into a displacement
122         if (index != null &amp;&amp; index.isJavaConstant()) {
123             JavaConstant javaConstant = index.asJavaConstant();
124             if (javaConstant.getJavaKind().isNumericInteger()) {
125                 long disp = javaConstant.asLong();
126                 mode = immediateMode(kind, disp);
127                 if (isDisplacementMode(mode)) {
128                     index = null;
129                     // we can fold this in as a displacement
130                     // but first see if we can pull up any additional
131                     // constants added into the base
132                     boolean tryNextBase = (base instanceof AddNode);
133                     while (tryNextBase) {
134                         AddNode add = (AddNode) base;
135                         tryNextBase = false;
136                         ValueNode child = add.getX();
137                         if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
138                             long newDisp = disp + child.asJavaConstant().asLong();
<a name="8" id="anc8"></a><span class="line-modified">139                             AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">140                             if (newMode != AddressingMode.REGISTER_OFFSET) {</span>
141                                 disp = newDisp;
142                                 mode = newMode;
143                                 base = add.getY();
144                                 ret.setBase(base);
145                                 tryNextBase = (base instanceof AddNode);
146                             }
147                         } else {
148                             child = add.getY();
149                             if (child.isJavaConstant() &amp;&amp; child.asJavaConstant().getJavaKind().isNumericInteger()) {
150                                 long newDisp = disp + child.asJavaConstant().asLong();
<a name="9" id="anc9"></a><span class="line-modified">151                                 AddressingMode newMode = immediateMode(kind, newDisp);</span>
<span class="line-modified">152                                 if (newMode != AddressingMode.REGISTER_OFFSET) {</span>
153                                     disp = newDisp;
154                                     mode = newMode;
155                                     base = add.getX();
156                                     ret.setBase(base);
157                                     tryNextBase = (base instanceof AddNode);
158                                 }
159                             }
160                         }
161                     }
162                     if (disp != 0) {
163                         // ok now set the displacement in place of an index
164                         ret.setIndex(null);
165                         int scaleFactor = computeScaleFactor(kind, mode);
166                         ret.setDisplacement(disp, scaleFactor, mode);
167                     } else {
168                         // reset to base register only
169                         ret.setIndex(null);
<a name="10" id="anc10"></a><span class="line-modified">170                         ret.setDisplacement(0, 1, AddressingMode.BASE_REGISTER_ONLY);</span>
171                     }
172                     return true;
173                 }
174             }
175         }
<a name="11" id="anc11"></a><span class="line-added">176 </span>
<span class="line-added">177         // We try to convert (OffsetAddress base (Add (LeftShift (Ext i) k) #imm))</span>
<span class="line-added">178         // to (AArch64AddressNode (AArch64PointerAdd (base (LeftShift (Ext i) k)) #imm)</span>
<span class="line-added">179         if (supportsDerivedReference &amp;&amp; index != null &amp;&amp; index instanceof AddNode &amp;&amp; index.getStackKind().isNumericInteger()) {</span>
<span class="line-added">180             ValueNode x = ((AddNode) index).getX();</span>
<span class="line-added">181             ValueNode y = ((AddNode) index).getY();</span>
<span class="line-added">182             ValueNode objHeadOffset = null;</span>
<span class="line-added">183             ValueNode scaledIndex = null;</span>
<span class="line-added">184             if (x.isConstant()) {</span>
<span class="line-added">185                 objHeadOffset = x;</span>
<span class="line-added">186                 scaledIndex = y;</span>
<span class="line-added">187             } else if (y.isConstant()) {</span>
<span class="line-added">188                 objHeadOffset = y;</span>
<span class="line-added">189                 scaledIndex = x;</span>
<span class="line-added">190             }</span>
<span class="line-added">191 </span>
<span class="line-added">192             if (scaledIndex == null || objHeadOffset == null) {</span>
<span class="line-added">193                 return false;</span>
<span class="line-added">194             }</span>
<span class="line-added">195 </span>
<span class="line-added">196             ZeroExtendNode wordIndex = null;</span>
<span class="line-added">197             if (scaledIndex instanceof LeftShiftNode) {</span>
<span class="line-added">198                 ValueNode var = ((LeftShiftNode) scaledIndex).getX();</span>
<span class="line-added">199                 ValueNode amount = ((LeftShiftNode) scaledIndex).getY();</span>
<span class="line-added">200                 if (amount.isConstant() &amp;&amp; var instanceof ZeroExtendNode) {</span>
<span class="line-added">201                     int s = amount.asJavaConstant().asInt();</span>
<span class="line-added">202                     if (s &gt;= 0 &amp;&amp; s &lt;= 4) {</span>
<span class="line-added">203                         wordIndex = (ZeroExtendNode) var;</span>
<span class="line-added">204                     }</span>
<span class="line-added">205                 }</span>
<span class="line-added">206             } else if (scaledIndex instanceof ZeroExtendNode) {</span>
<span class="line-added">207                 wordIndex = (ZeroExtendNode) scaledIndex;</span>
<span class="line-added">208             }</span>
<span class="line-added">209 </span>
<span class="line-added">210             if (wordIndex != null) {</span>
<span class="line-added">211                 AArch64PointerAddNode addP = base.graph().unique(new AArch64PointerAddNode(base, scaledIndex));</span>
<span class="line-added">212                 ret.setBase(addP);</span>
<span class="line-added">213                 ret.setIndex(objHeadOffset);</span>
<span class="line-added">214                 return true;</span>
<span class="line-added">215             }</span>
<span class="line-added">216         }</span>
<span class="line-added">217 </span>
218         // nope cannot improve this any more
219         return false;
220     }
221 
222     private AArch64Kind getAArch64Kind(Stamp stamp) {
223         LIRKind lirKind = stamp.getLIRKind(kindtool);
224         if (!lirKind.isValue()) {
225             if (!lirKind.isReference(0) || lirKind.getReferenceCount() != 1) {
226                 return null;
227             }
228         }
229 
230         return (AArch64Kind) lirKind.getPlatformKind();
231     }
232 
<a name="12" id="anc12"></a><span class="line-modified">233     private static AddressingMode immediateMode(AArch64Kind kind, long value) {</span>
234         if (kind != null) {
235             int size = kind.getSizeInBytes();
236             // this next test should never really fail
237             if ((value &amp; (size - 1)) == 0) {
238                 long encodedValue = value / size;
239                 // assert value % size == 0
240                 // we can try for a 12 bit scaled offset
241                 if (NumUtil.isUnsignedNbit(12, encodedValue)) {
<a name="13" id="anc13"></a><span class="line-modified">242                     return AddressingMode.IMMEDIATE_SCALED;</span>
243                 }
244             }
245         }
246 
247         // we can try for a 9 bit unscaled offset
248         if (NumUtil.isSignedNbit(9, value)) {
<a name="14" id="anc14"></a><span class="line-modified">249             return AddressingMode.IMMEDIATE_UNSCALED;</span>
250         }
251 
252         // nope this index needs to be passed via offset register
<a name="15" id="anc15"></a><span class="line-modified">253         return AddressingMode.REGISTER_OFFSET;</span>
254     }
255 
<a name="16" id="anc16"></a><span class="line-modified">256     private static int computeScaleFactor(AArch64Kind kind, AddressingMode mode) {</span>
<span class="line-modified">257         if (mode == AddressingMode.IMMEDIATE_SCALED) {</span>
258             return kind.getSizeInBytes();
259         }
260         return 1;
261     }
262 
<a name="17" id="anc17"></a><span class="line-modified">263     boolean isBaseOnlyMode(AddressingMode addressingMode) {</span>
<span class="line-modified">264         return addressingMode == AddressingMode.BASE_REGISTER_ONLY;</span>
265     }
266 
<a name="18" id="anc18"></a><span class="line-modified">267     private static boolean isDisplacementMode(AddressingMode addressingMode) {</span>
268         switch (addressingMode) {
269             case IMMEDIATE_POST_INDEXED:
270             case IMMEDIATE_PRE_INDEXED:
271             case IMMEDIATE_SCALED:
272             case IMMEDIATE_UNSCALED:
273                 return true;
274         }
275         return false;
276     }
277 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
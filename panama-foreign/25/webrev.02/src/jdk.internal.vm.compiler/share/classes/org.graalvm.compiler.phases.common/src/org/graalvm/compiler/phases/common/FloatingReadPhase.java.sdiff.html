<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AddressLoweringByUsePhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InsertGuardFencesPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 47 import org.graalvm.compiler.nodes.LoopBeginNode;
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;
 51 import org.graalvm.compiler.nodes.ProxyNode;
 52 import org.graalvm.compiler.nodes.ReturnNode;
 53 import org.graalvm.compiler.nodes.StartNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNodeUtil;
 56 import org.graalvm.compiler.nodes.calc.FloatingNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 59 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 60 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 62 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 63 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 64 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 65 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;</span>
 66 import org.graalvm.compiler.nodes.memory.MemoryMap;
 67 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 68 import org.graalvm.compiler.nodes.memory.MemoryNode;
 69 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;

 70 import org.graalvm.compiler.nodes.memory.ReadNode;

 71 import org.graalvm.compiler.nodes.util.GraphUtil;
 72 import org.graalvm.compiler.phases.Phase;
 73 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 74 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 75 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.LoopInfo;
 76 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 77 import jdk.internal.vm.compiler.word.LocationIdentity;
 78 
 79 public class FloatingReadPhase extends Phase {
 80 
 81     private boolean createFloatingReads;
 82     private boolean createMemoryMapNodes;
 83 
 84     public static class MemoryMapImpl implements MemoryMap {
 85 
 86         private final EconomicMap&lt;LocationIdentity, MemoryNode&gt; lastMemorySnapshot;
 87 
 88         public MemoryMapImpl(MemoryMapImpl memoryMap) {
 89             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT, memoryMap.lastMemorySnapshot);
 90         }
</pre>
<hr />
<pre>
124     }
125 
126     public FloatingReadPhase() {
127         this(true, false);
128     }
129 
130     /**
131      * @param createFloatingReads specifies whether {@link FloatableAccessNode}s like
132      *            {@link ReadNode} should be converted into floating nodes (e.g.,
133      *            {@link FloatingReadNode}s) where possible
134      * @param createMemoryMapNodes a {@link MemoryMapNode} will be created for each return if this
135      *            is true
136      */
137     public FloatingReadPhase(boolean createFloatingReads, boolean createMemoryMapNodes) {
138         this.createFloatingReads = createFloatingReads;
139         this.createMemoryMapNodes = createMemoryMapNodes;
140     }
141 
142     @Override
143     public float codeSizeIncrease() {
<span class="line-modified">144         return 1.25f;</span>
145     }
146 
147     /**
148      * Removes nodes from a given set that (transitively) have a usage outside the set.
149      */
150     private static EconomicSet&lt;Node&gt; removeExternallyUsedNodes(EconomicSet&lt;Node&gt; set) {
151         boolean change;
152         do {
153             change = false;
154             for (Iterator&lt;Node&gt; iter = set.iterator(); iter.hasNext();) {
155                 Node node = iter.next();
156                 for (Node usage : node.usages()) {
157                     if (!set.contains(usage)) {
158                         change = true;
159                         iter.remove();
160                         break;
161                     }
162                 }
163             }
164         } while (change);
165         return set;
166     }
167 
168     protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
<span class="line-modified">169         if (node instanceof MemoryCheckpoint.Single) {</span>
<span class="line-modified">170             processIdentity(currentState, ((MemoryCheckpoint.Single) node).getKilledLocationIdentity());</span>
<span class="line-modified">171         } else if (node instanceof MemoryCheckpoint.Multi) {</span>
<span class="line-modified">172             for (LocationIdentity identity : ((MemoryCheckpoint.Multi) node).getKilledLocationIdentities()) {</span>
173                 processIdentity(currentState, identity);
174             }
175         }
176     }
177 
178     private static void processIdentity(EconomicSet&lt;LocationIdentity&gt; currentState, LocationIdentity identity) {
179         if (identity.isMutable()) {
180             currentState.add(identity);
181         }
182     }
183 
184     protected void processBlock(Block b, EconomicSet&lt;LocationIdentity&gt; currentState) {
185         for (FixedNode n : b.getNodes()) {
186             processNode(n, currentState);
187         }
188     }
189 
190     private EconomicSet&lt;LocationIdentity&gt; processLoop(HIRLoop loop, EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops) {
191         LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();
192         EconomicSet&lt;LocationIdentity&gt; result = modifiedInLoops.get(loopBegin);
</pre>
<hr />
<pre>
264                     } else if (merged == null) {
265                         merged = last;
266                     } else {
267                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
268                         for (int j = 0; j &lt; mergedStatesCount; j++) {
269                             phi.addInput(ValueNodeUtil.asNode(merged));
270                         }
271                         phi.addInput(ValueNodeUtil.asNode(last));
272                         merged = phi;
273                         isPhi = true;
274                     }
275                 }
276                 mergedStatesCount++;
277             }
278             newState.getMap().put(key, merged);
279         }
280         return newState;
281 
282     }
283 




284     private static boolean checkNoImmutableLocations(EconomicSet&lt;LocationIdentity&gt; keys) {
285         keys.forEach(t -&gt; {
286             assert t.isMutable();
287         });
288         return true;
289     }
290 
291     public static class FloatingReadClosure extends NodeIteratorClosure&lt;MemoryMapImpl&gt; {
292 
293         private final EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops;
294         private boolean createFloatingReads;
295         private boolean createMemoryMapNodes;
296 
297         public FloatingReadClosure(EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops, boolean createFloatingReads, boolean createMemoryMapNodes) {
298             this.modifiedInLoops = modifiedInLoops;
299             this.createFloatingReads = createFloatingReads;
300             this.createMemoryMapNodes = createMemoryMapNodes;
301         }
302 
303         @Override
</pre>
<hr />
<pre>
307                 final LoopExitNode loopExitNode = (LoopExitNode) node;
308                 final EconomicSet&lt;LocationIdentity&gt; modifiedInLoop = modifiedInLoops.get(loopExitNode.loopBegin());
309                 final boolean anyModified = modifiedInLoop.contains(LocationIdentity.any());
310                 state.getMap().replaceAll((locationIdentity, memoryNode) -&gt; (anyModified || modifiedInLoop.contains(locationIdentity))
311                                 ? ProxyNode.forMemory(memoryNode, loopExitNode, locationIdentity)
312                                 : memoryNode);
313             }
314 
315             if (node instanceof MemoryAnchorNode) {
316                 processAnchor((MemoryAnchorNode) node, state);
317                 return state;
318             }
319 
320             if (node instanceof MemoryAccess) {
321                 processAccess((MemoryAccess) node, state);
322             }
323 
324             if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
325                 processFloatable((FloatableAccessNode) node, state);
326             }
<span class="line-modified">327             if (node instanceof MemoryCheckpoint.Single) {</span>
<span class="line-modified">328                 processCheckpoint((MemoryCheckpoint.Single) node, state);</span>
<span class="line-modified">329             } else if (node instanceof MemoryCheckpoint.Multi) {</span>
<span class="line-modified">330                 processCheckpoint((MemoryCheckpoint.Multi) node, state);</span>
331             }
<span class="line-modified">332             assert MemoryCheckpoint.TypeAssertion.correctType(node) : node;</span>
333 
334             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
335                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));
336             }
337             return state;
338         }
339 
340         /**
341          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
342          * real last access location.
343          */
344         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
345             for (Node node : anchor.usages().snapshot()) {
346                 if (node instanceof MemoryAccess) {
347                     MemoryAccess access = (MemoryAccess) node;
348                     if (access.getLastLocationAccess() == anchor) {
349                         MemoryNode lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());
350                         assert lastLocationAccess != null;
351                         access.setLastLocationAccess(lastLocationAccess);
352                     }
353                 }
354             }
355 
356             if (anchor.hasNoUsages()) {
357                 anchor.graph().removeFixed(anchor);
358             }
359         }
360 
361         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
362             LocationIdentity locationIdentity = access.getLocationIdentity();
363             if (!locationIdentity.equals(LocationIdentity.any())) {
364                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
365                 access.setLastLocationAccess(lastLocationAccess);
366             }
367         }
368 
<span class="line-modified">369         private static void processCheckpoint(MemoryCheckpoint.Single checkpoint, MemoryMapImpl state) {</span>
370             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);
371         }
372 
<span class="line-modified">373         private static void processCheckpoint(MemoryCheckpoint.Multi checkpoint, MemoryMapImpl state) {</span>
374             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {
375                 processIdentity(identity, checkpoint, state);
376             }
377         }
378 
<span class="line-modified">379         private static void processIdentity(LocationIdentity identity, MemoryCheckpoint checkpoint, MemoryMapImpl state) {</span>
380             if (identity.isAny()) {
381                 state.getMap().clear();
382             }
383             if (identity.isMutable()) {
384                 state.getMap().put(identity, checkpoint);
385             }
386         }
387 
388         @SuppressWarnings(&quot;try&quot;)
389         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
390             StructuredGraph graph = accessNode.graph();
391             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
392             if (accessNode.canFloat()) {
393                 assert accessNode.getNullCheck() == false;
394                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
395                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
396                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();
397                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;
398                     graph.replaceFixedWithFloating(accessNode, floatingNode);
399                 }
400             }
401         }
402 
403         @Override
404         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
405             return mergeMemoryMaps(merge, states);
406         }
407 
408         @Override
409         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
410             MemoryMapImpl result = new MemoryMapImpl(oldState);
411             if (node.predecessor() instanceof InvokeWithExceptionNode) {
412                 /*
413                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
414                  * Since it is both the invoke and a control flow split, the scheduler cannot
415                  * schedule anything immediately after the invoke. It can only schedule in the
416                  * normal or exceptional successor - and we have to tell the scheduler here which
417                  * side it needs to choose by putting in the location identity on both successors.
418                  */
419                 InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">420                 result.getMap().put(invoke.getKilledLocationIdentity(), (MemoryCheckpoint) node);</span>
421             }
422             return result;
423         }
424 
425         @Override
426         protected EconomicMap&lt;LoopExitNode, MemoryMapImpl&gt; processLoop(LoopBeginNode loop, MemoryMapImpl initialState) {
427             EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
428             EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
429             if (modifiedLocations.contains(LocationIdentity.any())) {
430                 // create phis for all locations if ANY is modified in the loop
431                 modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
432                 modifiedLocations.addAll(initialState.getMap().getKeys());
433             }
434 
435             for (LocationIdentity location : modifiedLocations) {
436                 createMemoryPhi(loop, initialState, phis, location);
437             }
438             initialState.getMap().putAll(phis);
439 
440             LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 45 import org.graalvm.compiler.nodes.FixedNode;
 46 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 47 import org.graalvm.compiler.nodes.LoopBeginNode;
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;
 51 import org.graalvm.compiler.nodes.ProxyNode;
 52 import org.graalvm.compiler.nodes.ReturnNode;
 53 import org.graalvm.compiler.nodes.StartNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNodeUtil;
 56 import org.graalvm.compiler.nodes.calc.FloatingNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 59 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 60 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 62 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 63 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 64 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 65 import org.graalvm.compiler.nodes.memory.MemoryKill;</span>
 66 import org.graalvm.compiler.nodes.memory.MemoryMap;
 67 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 68 import org.graalvm.compiler.nodes.memory.MemoryNode;
 69 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
<span class="line-added"> 70 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;</span>
 71 import org.graalvm.compiler.nodes.memory.ReadNode;
<span class="line-added"> 72 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;</span>
 73 import org.graalvm.compiler.nodes.util.GraphUtil;
 74 import org.graalvm.compiler.phases.Phase;
 75 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 76 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 77 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.LoopInfo;
 78 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 79 import jdk.internal.vm.compiler.word.LocationIdentity;
 80 
 81 public class FloatingReadPhase extends Phase {
 82 
 83     private boolean createFloatingReads;
 84     private boolean createMemoryMapNodes;
 85 
 86     public static class MemoryMapImpl implements MemoryMap {
 87 
 88         private final EconomicMap&lt;LocationIdentity, MemoryNode&gt; lastMemorySnapshot;
 89 
 90         public MemoryMapImpl(MemoryMapImpl memoryMap) {
 91             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT, memoryMap.lastMemorySnapshot);
 92         }
</pre>
<hr />
<pre>
126     }
127 
128     public FloatingReadPhase() {
129         this(true, false);
130     }
131 
132     /**
133      * @param createFloatingReads specifies whether {@link FloatableAccessNode}s like
134      *            {@link ReadNode} should be converted into floating nodes (e.g.,
135      *            {@link FloatingReadNode}s) where possible
136      * @param createMemoryMapNodes a {@link MemoryMapNode} will be created for each return if this
137      *            is true
138      */
139     public FloatingReadPhase(boolean createFloatingReads, boolean createMemoryMapNodes) {
140         this.createFloatingReads = createFloatingReads;
141         this.createMemoryMapNodes = createMemoryMapNodes;
142     }
143 
144     @Override
145     public float codeSizeIncrease() {
<span class="line-modified">146         return 1.50f;</span>
147     }
148 
149     /**
150      * Removes nodes from a given set that (transitively) have a usage outside the set.
151      */
152     private static EconomicSet&lt;Node&gt; removeExternallyUsedNodes(EconomicSet&lt;Node&gt; set) {
153         boolean change;
154         do {
155             change = false;
156             for (Iterator&lt;Node&gt; iter = set.iterator(); iter.hasNext();) {
157                 Node node = iter.next();
158                 for (Node usage : node.usages()) {
159                     if (!set.contains(usage)) {
160                         change = true;
161                         iter.remove();
162                         break;
163                     }
164                 }
165             }
166         } while (change);
167         return set;
168     }
169 
170     protected void processNode(FixedNode node, EconomicSet&lt;LocationIdentity&gt; currentState) {
<span class="line-modified">171         if (node instanceof SingleMemoryKill) {</span>
<span class="line-modified">172             processIdentity(currentState, ((SingleMemoryKill) node).getKilledLocationIdentity());</span>
<span class="line-modified">173         } else if (node instanceof MultiMemoryKill) {</span>
<span class="line-modified">174             for (LocationIdentity identity : ((MultiMemoryKill) node).getKilledLocationIdentities()) {</span>
175                 processIdentity(currentState, identity);
176             }
177         }
178     }
179 
180     private static void processIdentity(EconomicSet&lt;LocationIdentity&gt; currentState, LocationIdentity identity) {
181         if (identity.isMutable()) {
182             currentState.add(identity);
183         }
184     }
185 
186     protected void processBlock(Block b, EconomicSet&lt;LocationIdentity&gt; currentState) {
187         for (FixedNode n : b.getNodes()) {
188             processNode(n, currentState);
189         }
190     }
191 
192     private EconomicSet&lt;LocationIdentity&gt; processLoop(HIRLoop loop, EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops) {
193         LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();
194         EconomicSet&lt;LocationIdentity&gt; result = modifiedInLoops.get(loopBegin);
</pre>
<hr />
<pre>
266                     } else if (merged == null) {
267                         merged = last;
268                     } else {
269                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
270                         for (int j = 0; j &lt; mergedStatesCount; j++) {
271                             phi.addInput(ValueNodeUtil.asNode(merged));
272                         }
273                         phi.addInput(ValueNodeUtil.asNode(last));
274                         merged = phi;
275                         isPhi = true;
276                     }
277                 }
278                 mergedStatesCount++;
279             }
280             newState.getMap().put(key, merged);
281         }
282         return newState;
283 
284     }
285 
<span class="line-added">286     public static boolean nodeOfMemoryType(Node node) {</span>
<span class="line-added">287         return !(node instanceof MemoryKill) || (node instanceof SingleMemoryKill ^ node instanceof MultiMemoryKill);</span>
<span class="line-added">288     }</span>
<span class="line-added">289 </span>
290     private static boolean checkNoImmutableLocations(EconomicSet&lt;LocationIdentity&gt; keys) {
291         keys.forEach(t -&gt; {
292             assert t.isMutable();
293         });
294         return true;
295     }
296 
297     public static class FloatingReadClosure extends NodeIteratorClosure&lt;MemoryMapImpl&gt; {
298 
299         private final EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops;
300         private boolean createFloatingReads;
301         private boolean createMemoryMapNodes;
302 
303         public FloatingReadClosure(EconomicMap&lt;LoopBeginNode, EconomicSet&lt;LocationIdentity&gt;&gt; modifiedInLoops, boolean createFloatingReads, boolean createMemoryMapNodes) {
304             this.modifiedInLoops = modifiedInLoops;
305             this.createFloatingReads = createFloatingReads;
306             this.createMemoryMapNodes = createMemoryMapNodes;
307         }
308 
309         @Override
</pre>
<hr />
<pre>
313                 final LoopExitNode loopExitNode = (LoopExitNode) node;
314                 final EconomicSet&lt;LocationIdentity&gt; modifiedInLoop = modifiedInLoops.get(loopExitNode.loopBegin());
315                 final boolean anyModified = modifiedInLoop.contains(LocationIdentity.any());
316                 state.getMap().replaceAll((locationIdentity, memoryNode) -&gt; (anyModified || modifiedInLoop.contains(locationIdentity))
317                                 ? ProxyNode.forMemory(memoryNode, loopExitNode, locationIdentity)
318                                 : memoryNode);
319             }
320 
321             if (node instanceof MemoryAnchorNode) {
322                 processAnchor((MemoryAnchorNode) node, state);
323                 return state;
324             }
325 
326             if (node instanceof MemoryAccess) {
327                 processAccess((MemoryAccess) node, state);
328             }
329 
330             if (createFloatingReads &amp;&amp; node instanceof FloatableAccessNode) {
331                 processFloatable((FloatableAccessNode) node, state);
332             }
<span class="line-modified">333             if (node instanceof SingleMemoryKill) {</span>
<span class="line-modified">334                 processCheckpoint((SingleMemoryKill) node, state);</span>
<span class="line-modified">335             } else if (node instanceof MultiMemoryKill) {</span>
<span class="line-modified">336                 processCheckpoint((MultiMemoryKill) node, state);</span>
337             }
<span class="line-modified">338             assert nodeOfMemoryType(node) : node;</span>
339 
340             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
341                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));
342             }
343             return state;
344         }
345 
346         /**
347          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
348          * real last access location.
349          */
350         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
351             for (Node node : anchor.usages().snapshot()) {
352                 if (node instanceof MemoryAccess) {
353                     MemoryAccess access = (MemoryAccess) node;
354                     if (access.getLastLocationAccess() == anchor) {
355                         MemoryNode lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());
356                         assert lastLocationAccess != null;
357                         access.setLastLocationAccess(lastLocationAccess);
358                     }
359                 }
360             }
361 
362             if (anchor.hasNoUsages()) {
363                 anchor.graph().removeFixed(anchor);
364             }
365         }
366 
367         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
368             LocationIdentity locationIdentity = access.getLocationIdentity();
369             if (!locationIdentity.equals(LocationIdentity.any())) {
370                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
371                 access.setLastLocationAccess(lastLocationAccess);
372             }
373         }
374 
<span class="line-modified">375         private static void processCheckpoint(SingleMemoryKill checkpoint, MemoryMapImpl state) {</span>
376             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);
377         }
378 
<span class="line-modified">379         private static void processCheckpoint(MultiMemoryKill checkpoint, MemoryMapImpl state) {</span>
380             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {
381                 processIdentity(identity, checkpoint, state);
382             }
383         }
384 
<span class="line-modified">385         private static void processIdentity(LocationIdentity identity, MemoryKill checkpoint, MemoryMapImpl state) {</span>
386             if (identity.isAny()) {
387                 state.getMap().clear();
388             }
389             if (identity.isMutable()) {
390                 state.getMap().put(identity, checkpoint);
391             }
392         }
393 
394         @SuppressWarnings(&quot;try&quot;)
395         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
396             StructuredGraph graph = accessNode.graph();
397             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
398             if (accessNode.canFloat()) {
399                 assert accessNode.getNullCheck() == false;
400                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);
401                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
402                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();
403                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;
404                     graph.replaceFixedWithFloating(accessNode, floatingNode);
405                 }
406             }
407         }
408 
409         @Override
410         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
411             return mergeMemoryMaps(merge, states);
412         }
413 
414         @Override
415         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
416             MemoryMapImpl result = new MemoryMapImpl(oldState);
417             if (node.predecessor() instanceof InvokeWithExceptionNode) {
418                 /*
419                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
420                  * Since it is both the invoke and a control flow split, the scheduler cannot
421                  * schedule anything immediately after the invoke. It can only schedule in the
422                  * normal or exceptional successor - and we have to tell the scheduler here which
423                  * side it needs to choose by putting in the location identity on both successors.
424                  */
425                 InvokeWithExceptionNode invoke = (InvokeWithExceptionNode) node.predecessor();
<span class="line-modified">426                 result.getMap().put(invoke.getKilledLocationIdentity(), (MemoryKill) node);</span>
427             }
428             return result;
429         }
430 
431         @Override
432         protected EconomicMap&lt;LoopExitNode, MemoryMapImpl&gt; processLoop(LoopBeginNode loop, MemoryMapImpl initialState) {
433             EconomicSet&lt;LocationIdentity&gt; modifiedLocations = modifiedInLoops.get(loop);
434             EconomicMap&lt;LocationIdentity, MemoryPhiNode&gt; phis = EconomicMap.create(Equivalence.DEFAULT);
435             if (modifiedLocations.contains(LocationIdentity.any())) {
436                 // create phis for all locations if ANY is modified in the loop
437                 modifiedLocations = EconomicSet.create(Equivalence.DEFAULT, modifiedLocations);
438                 modifiedLocations.addAll(initialState.getMap().getKeys());
439             }
440 
441             for (LocationIdentity location : modifiedLocations) {
442                 createMemoryPhi(loop, initialState, phis, location);
443             }
444             initialState.getMap().putAll(phis);
445 
446             LoopInfo&lt;MemoryMapImpl&gt; loopInfo = ReentrantNodeIterator.processLoop(this, loop, initialState);
</pre>
</td>
</tr>
</table>
<center><a href="AddressLoweringByUsePhase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="InsertGuardFencesPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
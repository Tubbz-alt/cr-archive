diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -66,10 +66,11 @@
 import org.graalvm.compiler.nodes.VirtualState;
 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
 import org.graalvm.compiler.nodes.cfg.Block;
 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 import org.graalvm.compiler.nodes.spi.NodeWithState;
+import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;
 import org.graalvm.compiler.nodes.spi.Virtualizable;
 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
@@ -163,12 +164,12 @@
      * with generics.
      */
     public static final class Final extends PartialEscapeClosure<PartialEscapeBlockState.Final> {
 
         public Final(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
-                        LoweringProvider loweringProvider) {
-            super(schedule, metaAccess, constantReflection, constantFieldProvider, loweringProvider);
+                        LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {
+            super(schedule, metaAccess, constantReflection, constantFieldProvider, loweringProvider, platformConfigurationProvider);
         }
 
         @Override
         protected PartialEscapeBlockState.Final getInitialState() {
             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
@@ -179,19 +180,20 @@
             return new PartialEscapeBlockState.Final(oldState);
         }
     }
 
     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
-        this(schedule, metaAccess, constantReflection, constantFieldProvider, null);
+        this(schedule, metaAccess, constantReflection, constantFieldProvider, null, null);
     }
 
     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
-                    LoweringProvider loweringProvider) {
+                    LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {
         super(schedule, schedule.getCFG());
         StructuredGraph graph = schedule.getCFG().graph;
         this.hasVirtualInputs = graph.createNodeBitMap();
-        this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, this, graph.getAssumptions(), graph.getOptions(), debug, loweringProvider);
+        this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, platformConfigurationProvider, this, graph.getAssumptions(), graph.getOptions(), debug,
+                        loweringProvider);
     }
 
     /**
      * @return true if the node was deleted, false otherwise
      */
@@ -843,10 +845,12 @@
          * object states are compatible, then this method will create PhiNodes for the object's
          * entries where needed. If they are incompatible, then all incoming virtual objects will be
          * materialized, and a PhiNode for the materialized values will be created. Object states
          * can be incompatible if they contain {@code long} or {@code double} values occupying two
          * {@code int} slots in such a way that that their values cannot be merged using PhiNodes.
+         * The states may also be incompatible if they contain escaped large writes to byte arrays
+         * in such a way that they cannot be merged using PhiNodes.
          *
          * @param states the predecessor block states of the merge
          * @return true if materialization happened during the merge, false otherwise
          */
         private boolean mergeObjectStates(int resultObject, int[] sourceObjects, PartialEscapeBlockState<?>[] states) {
@@ -857,10 +861,15 @@
             VirtualObjectNode virtual = virtualObjects.get(resultObject);
             int entryCount = virtual.entryCount();
 
             // determine all entries that have a two-slot value
             JavaKind[] twoSlotKinds = null;
+
+            // Determine all entries that span multiple slots.
+            int[] virtualByteCount = null;
+            JavaKind[] virtualKinds = null;
+
             outer: for (int i = 0; i < states.length; i++) {
                 ObjectState objectState = states[i].getObjectState(getObject.applyAsInt(i));
                 ValueNode[] entries = objectState.getEntries();
                 int valueIndex = 0;
                 ensureVirtual &= objectState.getEnsureVirtualized();
@@ -876,10 +885,66 @@
                             break outer;
                         }
                         twoSlotKinds[valueIndex] = otherKind;
                         // skip the next entry
                         valueIndex++;
+                    } else if (virtual.isVirtualByteArray()) {
+                        int bytecount = tool.getVirtualByteCount(entries, valueIndex);
+                        // @formatter:off
+                        /*
+                         * Having a bytecount of 1 here can mean two things:
+                         * - This was a regular byte array access
+                         * - This is an uninitialized value (ie: default)
+                         *
+                         * In the first case, we want to be able to merge regular accesses without
+                         * issues. But in the second case, if one of the branch has escaped a write
+                         * (while other branches did not touch the array), we want to be able to
+                         * propagate the escape to the merge.
+                         *
+                         * However, the semantics of virtual object creation in PEA puts a default
+                         * (0) byte value on all entries. As such, the merging is done in two steps:
+                         * - For each virtual entry, know if there is an escaped write in one of the
+                         * branch, and store its byte count, unless it is 1.
+                         * - Now that we know the byte count, we can escape multiple writes for the
+                         * default values from branches that did nothing on the entry in question to
+                         * a default write of a bigger kind.
+                         *
+                         * for example, consider:
+                         *
+                         * b = new byte[8];
+                         * if (...) {b[0] <- 1L}
+                         * else     {}
+                         *
+                         * for escape analysis purposes, it can be seen as:
+                         *
+                         * b = new byte[8];
+                         * if (...) {b[0] <- 1L}
+                         * else     {b[0] <- 0L}
+                         */
+                        // @formatter:on
+                        if (bytecount > 1) {
+                            if (virtualByteCount == null) {
+                                virtualByteCount = new int[entryCount];
+                            }
+                            if (virtualKinds == null) {
+                                virtualKinds = new JavaKind[entryCount];
+                            }
+                            if (virtualByteCount[valueIndex] != 0 && virtualByteCount[valueIndex] != bytecount) {
+                                compatible = false;
+                                break outer;
+                            }
+                            // Disallow merging ints with floats. Allows merging shorts with chars
+                            // (working with stack kinds).
+                            if (virtualKinds[valueIndex] != null && virtualKinds[valueIndex] != otherKind) {
+                                compatible = false;
+                                break outer;
+                            }
+                            virtualByteCount[valueIndex] = bytecount;
+                            virtualKinds[valueIndex] = otherKind;
+                            // skip illegals.
+                            valueIndex = valueIndex + bytecount - 1;
+                        }
                     } else {
                         assert entryKind.getStackKind() == otherKind.getStackKind() || (entryKind == JavaKind.Int && otherKind == JavaKind.Illegal) ||
                                         entryKind.getBitCount() >= otherKind.getBitCount() : entryKind + " vs " + otherKind;
                     }
                     valueIndex++;
@@ -899,20 +964,45 @@
                                 ValueNode nextValue = objectState.getEntry(valueIndex + 1);
                                 if (value.isConstant() && value.asConstant().equals(JavaConstant.INT_0) && nextValue.isConstant() && nextValue.asConstant().equals(JavaConstant.INT_0)) {
                                     // rewrite to a zero constant of the larger kind
                                     debug.log("Rewriting entry %s to constant of larger size", valueIndex);
                                     states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(twoSlotKinds[valueIndex], graph()));
-                                    states[i].setEntry(object, valueIndex + 1, ConstantNode.forConstant(JavaConstant.forIllegal(), tool.getMetaAccess(), graph()));
+                                    states[i].setEntry(object, valueIndex + 1, tool.getIllegalConstant());
                                 } else {
                                     compatible = false;
                                     break outer;
                                 }
                             }
                         }
                     }
                 }
             }
+            if (compatible && virtualByteCount != null) {
+                assert twoSlotKinds == null;
+                outer: //
+                for (int valueIndex = 0; valueIndex < entryCount; valueIndex++) {
+                    if (virtualByteCount[valueIndex] != 0) {
+                        int byteCount = virtualByteCount[valueIndex];
+                        for (int i = 0; i < states.length; i++) {
+                            int object = getObject.applyAsInt(i);
+                            ObjectState objectState = states[i].getObjectState(object);
+                            if (tool.isEntryDefaults(objectState, byteCount, valueIndex)) {
+                                // Interpret uninitialized as a corresponding large access.
+                                states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(virtualKinds[valueIndex]));
+                                for (int illegalIndex = valueIndex + 1; illegalIndex < valueIndex + byteCount; illegalIndex++) {
+                                    states[i].setEntry(object, illegalIndex, tool.getIllegalConstant());
+                                }
+                            } else {
+                                if (tool.getVirtualByteCount(objectState.getEntries(), valueIndex) != byteCount) {
+                                    compatible = false;
+                                    break outer;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
 
             if (compatible) {
                 // virtual objects are compatible: create phis for all entries that need them
                 ValueNode[] values = states[0].getObjectState(getObject.applyAsInt(0)).getEntries().clone();
                 PhiNode[] phis = getValuePhis(virtual, virtual.entryCount());
@@ -931,11 +1021,11 @@
                     }
                     if (twoSlotKinds != null && twoSlotKinds[valueIndex] != null) {
                         // skip an entry after a long/double value that occupies two int slots
                         valueIndex++;
                         phis[valueIndex] = null;
-                        values[valueIndex] = ConstantNode.forConstant(JavaConstant.forIllegal(), tool.getMetaAccess(), graph());
+                        values[valueIndex] = tool.getIllegalConstant();
                     }
                     valueIndex++;
                 }
 
                 boolean materialized = false;

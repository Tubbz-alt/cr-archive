<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.virtual.phases.ea;
  26 
  27 import java.util.ArrayList;
  28 import java.util.BitSet;
  29 import java.util.Iterator;
  30 import java.util.List;
  31 import java.util.function.IntUnaryOperator;
  32 
  33 import jdk.internal.vm.compiler.collections.EconomicMap;
  34 import jdk.internal.vm.compiler.collections.EconomicSet;
  35 import jdk.internal.vm.compiler.collections.Equivalence;
  36 import org.graalvm.compiler.core.common.GraalOptions;
  37 import org.graalvm.compiler.core.common.cfg.Loop;
  38 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
  39 import org.graalvm.compiler.core.common.type.Stamp;
  40 import org.graalvm.compiler.core.common.type.StampFactory;
  41 import org.graalvm.compiler.debug.CounterKey;
  42 import org.graalvm.compiler.debug.DebugContext;
  43 import org.graalvm.compiler.graph.Node;
  44 import org.graalvm.compiler.graph.NodeBitMap;
  45 import org.graalvm.compiler.graph.Position;
  46 import org.graalvm.compiler.graph.spi.Canonicalizable;
  47 import org.graalvm.compiler.nodes.AbstractEndNode;
  48 import org.graalvm.compiler.nodes.CallTargetNode;
  49 import org.graalvm.compiler.nodes.ConstantNode;
  50 import org.graalvm.compiler.nodes.ControlSinkNode;
  51 import org.graalvm.compiler.nodes.FixedNode;
  52 import org.graalvm.compiler.nodes.FixedWithNextNode;
  53 import org.graalvm.compiler.nodes.FrameState;
  54 import org.graalvm.compiler.nodes.Invoke;
  55 import org.graalvm.compiler.nodes.LoopBeginNode;
  56 import org.graalvm.compiler.nodes.LoopExitNode;
  57 import org.graalvm.compiler.nodes.NodeView;
  58 import org.graalvm.compiler.nodes.PhiNode;
  59 import org.graalvm.compiler.nodes.ProxyNode;
  60 import org.graalvm.compiler.nodes.StructuredGraph;
  61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  62 import org.graalvm.compiler.nodes.UnwindNode;
  63 import org.graalvm.compiler.nodes.ValueNode;
  64 import org.graalvm.compiler.nodes.ValuePhiNode;
  65 import org.graalvm.compiler.nodes.ValueProxyNode;
  66 import org.graalvm.compiler.nodes.VirtualState;
  67 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
  68 import org.graalvm.compiler.nodes.cfg.Block;
  69 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  70 import org.graalvm.compiler.nodes.spi.NodeWithState;
  71 import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;
  72 import org.graalvm.compiler.nodes.spi.Virtualizable;
  73 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  74 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  75 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  76 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  77 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  78 
  79 import jdk.vm.ci.meta.ConstantReflectionProvider;
  80 import jdk.vm.ci.meta.JavaConstant;
  81 import jdk.vm.ci.meta.JavaKind;
  82 import jdk.vm.ci.meta.MetaAccessProvider;
  83 
  84 public abstract class PartialEscapeClosure&lt;BlockT extends PartialEscapeBlockState&lt;BlockT&gt;&gt; extends EffectsClosure&lt;BlockT&gt; {
  85 
  86     public static final CounterKey COUNTER_MATERIALIZATIONS = DebugContext.counter(&quot;Materializations&quot;);
  87     public static final CounterKey COUNTER_MATERIALIZATIONS_PHI = DebugContext.counter(&quot;MaterializationsPhi&quot;);
  88     public static final CounterKey COUNTER_MATERIALIZATIONS_MERGE = DebugContext.counter(&quot;MaterializationsMerge&quot;);
  89     public static final CounterKey COUNTER_MATERIALIZATIONS_UNHANDLED = DebugContext.counter(&quot;MaterializationsUnhandled&quot;);
  90     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_REITERATION = DebugContext.counter(&quot;MaterializationsLoopReiteration&quot;);
  91     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_END = DebugContext.counter(&quot;MaterializationsLoopEnd&quot;);
  92     public static final CounterKey COUNTER_ALLOCATION_REMOVED = DebugContext.counter(&quot;AllocationsRemoved&quot;);
  93     public static final CounterKey COUNTER_MEMORYCHECKPOINT = DebugContext.counter(&quot;MemoryCheckpoint&quot;);
  94 
  95     /**
  96      * Nodes with inputs that were modified during analysis are marked in this bitset - this way
  97      * nodes that are not influenced at all by analysis can be rejected quickly.
  98      */
  99     private final NodeBitMap hasVirtualInputs;
 100 
 101     /**
 102      * This is handed out to implementers of {@link Virtualizable}.
 103      */
 104     protected final VirtualizerToolImpl tool;
 105 
 106     /**
 107      * The indexes into this array correspond to {@link VirtualObjectNode#getObjectId()}.
 108      */
 109     public final ArrayList&lt;VirtualObjectNode&gt; virtualObjects = new ArrayList&lt;&gt;();
 110 
 111     @Override
 112     public boolean needsApplyEffects() {
 113         if (hasChanged()) {
 114             return true;
 115         }
 116         /*
 117          * If there is a mismatch between the number of materializations and the number of
 118          * virtualizations, we need to apply effects, even if there were no other significant
 119          * changes to the graph. This applies to each block, since moving from one block to the
 120          * other can also be important (if the probabilities of the block differ).
 121          */
 122         for (Block block : cfg.getBlocks()) {
 123             GraphEffectList effects = blockEffects.get(block);
 124             if (effects != null) {
 125                 if (effects.getVirtualizationDelta() != 0) {
 126                     return true;
 127                 }
 128             }
 129         }
 130         return false;
 131     }
 132 
 133     private final class CollectVirtualObjectsClosure extends NodeClosure&lt;ValueNode&gt; {
 134         private final EconomicSet&lt;VirtualObjectNode&gt; virtual;
 135         private final GraphEffectList effects;
 136         private final BlockT state;
 137 
 138         private CollectVirtualObjectsClosure(EconomicSet&lt;VirtualObjectNode&gt; virtual, GraphEffectList effects, BlockT state) {
 139             this.virtual = virtual;
 140             this.effects = effects;
 141             this.state = state;
 142         }
 143 
 144         @Override
 145         public void apply(Node usage, ValueNode value) {
 146             if (value instanceof VirtualObjectNode) {
 147                 VirtualObjectNode object = (VirtualObjectNode) value;
 148                 if (object.getObjectId() != -1 &amp;&amp; state.getObjectStateOptional(object) != null) {
 149                     virtual.add(object);
 150                 }
 151             } else {
 152                 ValueNode alias = getAlias(value);
 153                 if (alias instanceof VirtualObjectNode) {
 154                     VirtualObjectNode object = (VirtualObjectNode) alias;
 155                     virtual.add(object);
 156                     effects.replaceFirstInput(usage, value, object);
 157                 }
 158             }
 159         }
 160     }
 161 
 162     /**
 163      * Final subclass of PartialEscapeClosure, for performance and to make everything behave nicely
 164      * with generics.
 165      */
 166     public static final class Final extends PartialEscapeClosure&lt;PartialEscapeBlockState.Final&gt; {
 167 
 168         public Final(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
 169                         LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {
 170             super(schedule, metaAccess, constantReflection, constantFieldProvider, loweringProvider, platformConfigurationProvider);
 171         }
 172 
 173         @Override
 174         protected PartialEscapeBlockState.Final getInitialState() {
 175             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
 176         }
 177 
 178         @Override
 179         protected PartialEscapeBlockState.Final cloneState(PartialEscapeBlockState.Final oldState) {
 180             return new PartialEscapeBlockState.Final(oldState);
 181         }
 182     }
 183 
 184     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
 185         this(schedule, metaAccess, constantReflection, constantFieldProvider, null, null);
 186     }
 187 
 188     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
 189                     LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {
 190         super(schedule, schedule.getCFG());
 191         StructuredGraph graph = schedule.getCFG().graph;
 192         this.hasVirtualInputs = graph.createNodeBitMap();
 193         this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, platformConfigurationProvider, this, graph.getAssumptions(), graph.getOptions(), debug,
 194                         loweringProvider);
 195     }
 196 
 197     /**
 198      * @return true if the node was deleted, false otherwise
 199      */
 200     @Override
 201     protected boolean processNode(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 202         /*
 203          * These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
 204          * and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
 205          * scheduled, but can safely be ignored.
 206          */
 207         if (node instanceof CallTargetNode || node instanceof FrameState || node instanceof ConstantNode) {
 208             return false;
 209         } else if (node instanceof Invoke) {
 210             processNodeInternal(((Invoke) node).callTarget(), state, effects, lastFixedNode);
 211         }
 212         return processNodeInternal(node, state, effects, lastFixedNode);
 213     }
 214 
 215     private boolean processNodeInternal(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 216         FixedNode nextFixedNode = lastFixedNode == null ? null : lastFixedNode.next();
 217         VirtualUtil.trace(node.getOptions(), debug, &quot;%s&quot;, node);
 218 
 219         if (requiresProcessing(node)) {
 220             if (processVirtualizable((ValueNode) node, nextFixedNode, state, effects) == false) {
 221                 return false;
 222             }
 223             if (tool.isDeleted()) {
 224                 VirtualUtil.trace(node.getOptions(), debug, &quot;deleted virtualizable allocation %s&quot;, node);
 225                 return true;
 226             }
 227         }
 228         if (hasVirtualInputs.isMarked(node) &amp;&amp; node instanceof ValueNode) {
 229             if (node instanceof Virtualizable) {
 230                 if (processVirtualizable((ValueNode) node, nextFixedNode, state, effects) == false) {
 231                     return false;
 232                 }
 233                 if (tool.isDeleted()) {
 234                     VirtualUtil.trace(node.getOptions(), debug, &quot;deleted virtualizable node %s&quot;, node);
 235                     return true;
 236                 }
 237             }
 238             processNodeInputs((ValueNode) node, nextFixedNode, state, effects);
 239         }
 240 
 241         if (hasScalarReplacedInputs(node) &amp;&amp; node instanceof ValueNode) {
 242             if (processNodeWithScalarReplacedInputs((ValueNode) node, nextFixedNode, state, effects)) {
 243                 return true;
 244             }
 245         }
 246         return false;
 247     }
 248 
 249     protected boolean requiresProcessing(Node node) {
 250         return node instanceof VirtualizableAllocation;
 251     }
 252 
 253     private boolean processVirtualizable(ValueNode node, FixedNode insertBefore, BlockT state, GraphEffectList effects) {
 254         tool.reset(state, node, insertBefore, effects);
 255         return virtualize(node, tool);
 256     }
 257 
 258     protected boolean virtualize(ValueNode node, VirtualizerTool vt) {
 259         ((Virtualizable) node).virtualize(vt);
 260         return true; // request further processing
 261     }
 262 
 263     /**
 264      * This tries to canonicalize the node based on improved (replaced) inputs.
 265      */
 266     @SuppressWarnings(&quot;unchecked&quot;)
 267     private boolean processNodeWithScalarReplacedInputs(ValueNode node, FixedNode insertBefore, BlockT state, GraphEffectList effects) {
 268         ValueNode canonicalizedValue = node;
 269         if (node instanceof Canonicalizable.Unary&lt;?&gt;) {
 270             Canonicalizable.Unary&lt;ValueNode&gt; canonicalizable = (Canonicalizable.Unary&lt;ValueNode&gt;) node;
 271             ObjectState valueObj = getObjectState(state, canonicalizable.getValue());
 272             ValueNode valueAlias = valueObj != null ? valueObj.getMaterializedValue() : getScalarAlias(canonicalizable.getValue());
 273             if (valueAlias != canonicalizable.getValue()) {
 274                 canonicalizedValue = (ValueNode) canonicalizable.canonical(tool, valueAlias);
 275             }
 276         } else if (node instanceof Canonicalizable.Binary&lt;?&gt;) {
 277             Canonicalizable.Binary&lt;ValueNode&gt; canonicalizable = (Canonicalizable.Binary&lt;ValueNode&gt;) node;
 278             ObjectState xObj = getObjectState(state, canonicalizable.getX());
 279             ValueNode xAlias = xObj != null ? xObj.getMaterializedValue() : getScalarAlias(canonicalizable.getX());
 280             ObjectState yObj = getObjectState(state, canonicalizable.getY());
 281             ValueNode yAlias = yObj != null ? yObj.getMaterializedValue() : getScalarAlias(canonicalizable.getY());
 282             if (xAlias != canonicalizable.getX() || yAlias != canonicalizable.getY()) {
 283                 canonicalizedValue = (ValueNode) canonicalizable.canonical(tool, xAlias, yAlias);
 284             }
 285         } else {
 286             return false;
 287         }
 288         if (canonicalizedValue != node &amp;&amp; canonicalizedValue != null) {
 289             if (canonicalizedValue.isAlive()) {
 290                 ValueNode alias = getAliasAndResolve(state, canonicalizedValue);
 291                 if (alias instanceof VirtualObjectNode) {
 292                     addVirtualAlias((VirtualObjectNode) alias, node);
 293                     effects.deleteNode(node);
 294                 } else {
 295                     effects.replaceAtUsages(node, alias, insertBefore);
 296                     addScalarAlias(node, alias);
 297                 }
 298             } else {
 299                 if (!prepareCanonicalNode(canonicalizedValue, state, effects)) {
 300                     VirtualUtil.trace(node.getOptions(), debug, &quot;replacement via canonicalization too complex: %s -&gt; %s&quot;, node, canonicalizedValue);
 301                     return false;
 302                 }
 303                 if (canonicalizedValue instanceof ControlSinkNode) {
 304                     effects.replaceWithSink((FixedWithNextNode) node, (ControlSinkNode) canonicalizedValue);
 305                     state.markAsDead();
 306                 } else {
 307                     effects.replaceAtUsages(node, canonicalizedValue, insertBefore);
 308                     addScalarAlias(node, canonicalizedValue);
 309                 }
 310             }
 311             VirtualUtil.trace(node.getOptions(), debug, &quot;replaced via canonicalization: %s -&gt; %s&quot;, node, canonicalizedValue);
 312             return true;
 313         }
 314         return false;
 315     }
 316 
 317     /**
 318      * Nodes created during canonicalizations need to be scanned for values that were replaced.
 319      */
 320     private boolean prepareCanonicalNode(ValueNode node, BlockT state, GraphEffectList effects) {
 321         assert !node.isAlive();
 322         for (Position pos : node.inputPositions()) {
 323             Node input = pos.get(node);
 324             if (input instanceof ValueNode) {
 325                 if (input.isAlive()) {
 326                     if (!(input instanceof VirtualObjectNode)) {
 327                         ObjectState obj = getObjectState(state, (ValueNode) input);
 328                         if (obj != null) {
 329                             if (obj.isVirtual()) {
 330                                 return false;
 331                             } else {
 332                                 pos.initialize(node, obj.getMaterializedValue());
 333                             }
 334                         } else {
 335                             pos.initialize(node, getScalarAlias((ValueNode) input));
 336                         }
 337                     }
 338                 } else {
 339                     if (!prepareCanonicalNode((ValueNode) input, state, effects)) {
 340                         return false;
 341                     }
 342                 }
 343             }
 344         }
 345         return true;
 346     }
 347 
 348     /**
 349      * This replaces all inputs that point to virtual or materialized values with the actual value,
 350      * materializing if necessary. Also takes care of frame states, adding the necessary
 351      * {@link VirtualObjectState}.
 352      */
 353     private void processNodeInputs(ValueNode node, FixedNode insertBefore, BlockT state, GraphEffectList effects) {
 354         VirtualUtil.trace(node.getOptions(), debug, &quot;processing nodewithstate: %s&quot;, node);
 355         for (Node input : node.inputs()) {
 356             if (input instanceof ValueNode) {
 357                 ValueNode alias = getAlias((ValueNode) input);
 358                 if (alias instanceof VirtualObjectNode) {
 359                     int id = ((VirtualObjectNode) alias).getObjectId();
 360                     ensureMaterialized(state, id, insertBefore, effects, COUNTER_MATERIALIZATIONS_UNHANDLED);
 361                     effects.replaceFirstInput(node, input, state.getObjectState(id).getMaterializedValue());
 362                     VirtualUtil.trace(node.getOptions(), debug, &quot;replacing input %s at %s&quot;, input, node);
 363                 }
 364             }
 365         }
 366         if (node instanceof NodeWithState) {
 367             processNodeWithState((NodeWithState) node, state, effects);
 368         }
 369     }
 370 
 371     private void processNodeWithState(NodeWithState nodeWithState, BlockT state, GraphEffectList effects) {
 372         for (FrameState fs : nodeWithState.states()) {
 373             FrameState frameState = getUniqueFramestate(nodeWithState, fs);
 374             EconomicSet&lt;VirtualObjectNode&gt; virtual = EconomicSet.create(Equivalence.IDENTITY_WITH_SYSTEM_HASHCODE);
 375             frameState.applyToNonVirtual(new CollectVirtualObjectsClosure(virtual, effects, state));
 376             collectLockedVirtualObjects(state, virtual);
 377             collectReferencedVirtualObjects(state, virtual);
 378             addVirtualMappings(frameState, virtual, state, effects);
 379         }
 380     }
 381 
 382     private static FrameState getUniqueFramestate(NodeWithState nodeWithState, FrameState frameState) {
 383         if (frameState.hasMoreThanOneUsage()) {
 384             // Can happen for example from inlined snippets with multiple state split nodes.
 385             FrameState copy = (FrameState) frameState.copyWithInputs();
 386             nodeWithState.asNode().replaceFirstInput(frameState, copy);
 387             return copy;
 388         }
 389         return frameState;
 390     }
 391 
 392     private void addVirtualMappings(FrameState frameState, EconomicSet&lt;VirtualObjectNode&gt; virtual, BlockT state, GraphEffectList effects) {
 393         for (VirtualObjectNode obj : virtual) {
 394             effects.addVirtualMapping(frameState, state.getObjectState(obj).createEscapeObjectState(debug, obj));
 395         }
 396     }
 397 
 398     private void collectReferencedVirtualObjects(BlockT state, EconomicSet&lt;VirtualObjectNode&gt; virtual) {
 399         Iterator&lt;VirtualObjectNode&gt; iterator = virtual.iterator();
 400         while (iterator.hasNext()) {
 401             VirtualObjectNode object = iterator.next();
 402             int id = object.getObjectId();
 403             if (id != -1) {
 404                 ObjectState objState = state.getObjectStateOptional(id);
 405                 if (objState != null &amp;&amp; objState.isVirtual()) {
 406                     for (ValueNode entry : objState.getEntries()) {
 407                         if (entry instanceof VirtualObjectNode) {
 408                             VirtualObjectNode entryVirtual = (VirtualObjectNode) entry;
 409                             if (!virtual.contains(entryVirtual)) {
 410                                 virtual.add(entryVirtual);
 411                             }
 412                         }
 413                     }
 414                 }
 415             }
 416         }
 417     }
 418 
 419     private void collectLockedVirtualObjects(BlockT state, EconomicSet&lt;VirtualObjectNode&gt; virtual) {
 420         for (int i = 0; i &lt; state.getStateCount(); i++) {
 421             ObjectState objState = state.getObjectStateOptional(i);
 422             if (objState != null &amp;&amp; objState.isVirtual() &amp;&amp; objState.hasLocks()) {
 423                 virtual.add(virtualObjects.get(i));
 424             }
 425         }
 426     }
 427 
 428     /**
 429      * @return true if materialization happened, false if not.
 430      */
 431     protected boolean ensureMaterialized(PartialEscapeBlockState&lt;?&gt; state, int object, FixedNode materializeBefore, GraphEffectList effects, CounterKey counter) {
 432         if (state.getObjectState(object).isVirtual()) {
 433             counter.increment(debug);
 434             VirtualObjectNode virtual = virtualObjects.get(object);
 435             state.materializeBefore(materializeBefore, virtual, effects);
 436             assert !updateStatesForMaterialized(state, virtual, state.getObjectState(object).getMaterializedValue()) : &quot;method must already have been called before&quot;;
 437             return true;
 438         } else {
 439             return false;
 440         }
 441     }
 442 
 443     public static boolean updateStatesForMaterialized(PartialEscapeBlockState&lt;?&gt; state, VirtualObjectNode virtual, ValueNode materializedValue) {
 444         // update all existing states with the newly materialized object
 445         boolean change = false;
 446         for (int i = 0; i &lt; state.getStateCount(); i++) {
 447             ObjectState objState = state.getObjectStateOptional(i);
 448             if (objState != null &amp;&amp; objState.isVirtual()) {
 449                 ValueNode[] entries = objState.getEntries();
 450                 for (int i2 = 0; i2 &lt; entries.length; i2++) {
 451                     if (entries[i2] == virtual) {
 452                         state.setEntry(i, i2, materializedValue);
 453                         change = true;
 454                     }
 455                 }
 456             }
 457         }
 458         return change;
 459     }
 460 
 461     @Override
 462     protected BlockT stripKilledLoopLocations(Loop&lt;Block&gt; loop, BlockT originalInitialState) {
 463         BlockT initialState = super.stripKilledLoopLocations(loop, originalInitialState);
 464         if (loop.getDepth() &gt; GraalOptions.EscapeAnalysisLoopCutoff.getValue(cfg.graph.getOptions())) {
 465             /*
 466              * After we&#39;ve reached the maximum loop nesting, we&#39;ll simply materialize everything we
 467              * can to make sure that the loops only need to be iterated one time. Care is taken here
 468              * to not materialize virtual objects that have the &quot;ensureVirtualized&quot; flag set.
 469              */
 470             LoopBeginNode loopBegin = (LoopBeginNode) loop.getHeader().getBeginNode();
 471             AbstractEndNode end = loopBegin.forwardEnd();
 472             Block loopPredecessor = loop.getHeader().getFirstPredecessor();
 473             assert loopPredecessor.getEndNode() == end;
 474             int length = initialState.getStateCount();
 475 
 476             boolean change;
 477             BitSet ensureVirtualized = new BitSet(length);
 478             for (int i = 0; i &lt; length; i++) {
 479                 ObjectState state = initialState.getObjectStateOptional(i);
 480                 if (state != null &amp;&amp; state.isVirtual() &amp;&amp; state.getEnsureVirtualized()) {
 481                     ensureVirtualized.set(i);
 482                 }
 483             }
 484             do {
 485                 // propagate &quot;ensureVirtualized&quot; flag
 486                 change = false;
 487                 for (int i = 0; i &lt; length; i++) {
 488                     if (!ensureVirtualized.get(i)) {
 489                         ObjectState state = initialState.getObjectStateOptional(i);
 490                         if (state != null &amp;&amp; state.isVirtual()) {
 491                             for (ValueNode entry : state.getEntries()) {
 492                                 if (entry instanceof VirtualObjectNode) {
 493                                     if (ensureVirtualized.get(((VirtualObjectNode) entry).getObjectId())) {
 494                                         change = true;
 495                                         ensureVirtualized.set(i);
 496                                         break;
 497                                     }
 498                                 }
 499                             }
 500                         }
 501                     }
 502                 }
 503             } while (change);
 504 
 505             for (int i = 0; i &lt; length; i++) {
 506                 ObjectState state = initialState.getObjectStateOptional(i);
 507                 if (state != null &amp;&amp; state.isVirtual() &amp;&amp; !ensureVirtualized.get(i)) {
 508                     initialState.materializeBefore(end, virtualObjects.get(i), blockEffects.get(loopPredecessor));
 509                 }
 510             }
 511         }
 512         return initialState;
 513     }
 514 
 515     @Override
 516     protected void processInitialLoopState(Loop&lt;Block&gt; loop, BlockT initialState) {
 517         for (PhiNode phi : ((LoopBeginNode) loop.getHeader().getBeginNode()).phis()) {
 518             if (phi.valueAt(0) != null) {
 519                 ValueNode alias = getAliasAndResolve(initialState, phi.valueAt(0));
 520                 if (alias instanceof VirtualObjectNode) {
 521                     VirtualObjectNode virtual = (VirtualObjectNode) alias;
 522                     addVirtualAlias(virtual, phi);
 523                 } else {
 524                     aliases.set(phi, null);
 525                 }
 526             }
 527         }
 528     }
 529 
 530     @Override
 531     protected void processLoopExit(LoopExitNode exitNode, BlockT initialState, BlockT exitState, GraphEffectList effects) {
 532         if (exitNode.graph().hasValueProxies()) {
 533             EconomicMap&lt;Integer, ProxyNode&gt; proxies = EconomicMap.create(Equivalence.DEFAULT);
 534             for (ProxyNode proxy : exitNode.proxies()) {
 535                 ValueNode alias = getAlias(proxy.value());
 536                 if (alias instanceof VirtualObjectNode) {
 537                     VirtualObjectNode virtual = (VirtualObjectNode) alias;
 538                     proxies.put(virtual.getObjectId(), proxy);
 539                 }
 540             }
 541             for (int i = 0; i &lt; exitState.getStateCount(); i++) {
 542                 ObjectState exitObjState = exitState.getObjectStateOptional(i);
 543                 if (exitObjState != null) {
 544                     ObjectState initialObjState = initialState.getObjectStateOptional(i);
 545 
 546                     if (exitObjState.isVirtual()) {
 547                         processVirtualAtLoopExit(exitNode, effects, i, exitObjState, initialObjState, exitState);
 548                     } else {
 549                         processMaterializedAtLoopExit(exitNode, effects, proxies, i, exitObjState, initialObjState, exitState);
 550                     }
 551                 }
 552             }
 553         }
 554     }
 555 
 556     private static void processMaterializedAtLoopExit(LoopExitNode exitNode, GraphEffectList effects, EconomicMap&lt;Integer, ProxyNode&gt; proxies, int object, ObjectState exitObjState,
 557                     ObjectState initialObjState, PartialEscapeBlockState&lt;?&gt; exitState) {
 558         if (initialObjState == null || initialObjState.isVirtual()) {
 559             ProxyNode proxy = proxies.get(object);
 560             if (proxy == null) {
 561                 proxy = new ValueProxyNode(exitObjState.getMaterializedValue(), exitNode);
 562                 effects.addFloatingNode(proxy, &quot;proxy&quot;);
 563             } else {
 564                 effects.replaceFirstInput(proxy, proxy.value(), exitObjState.getMaterializedValue());
 565                 // nothing to do - will be handled in processNode
 566             }
 567             exitState.updateMaterializedValue(object, proxy);
 568         } else {
 569             if (initialObjState.getMaterializedValue() != exitObjState.getMaterializedValue()) {
 570                 exitNode.getDebug().log(&quot;materialized value changes within loop: %s vs. %s at %s&quot;, initialObjState.getMaterializedValue(), exitObjState.getMaterializedValue(), exitNode);
 571             }
 572         }
 573     }
 574 
 575     private static void processVirtualAtLoopExit(LoopExitNode exitNode, GraphEffectList effects, int object, ObjectState exitObjState, ObjectState initialObjState,
 576                     PartialEscapeBlockState&lt;?&gt; exitState) {
 577         for (int i = 0; i &lt; exitObjState.getEntries().length; i++) {
 578             ValueNode value = exitState.getObjectState(object).getEntry(i);
 579             if (!(value instanceof VirtualObjectNode || value.isConstant())) {
 580                 if (exitNode.loopBegin().isPhiAtMerge(value) || initialObjState == null || !initialObjState.isVirtual() || initialObjState.getEntry(i) != value) {
 581                     ProxyNode proxy = new ValueProxyNode(value, exitNode);
 582                     exitState.setEntry(object, i, proxy);
 583                     effects.addFloatingNode(proxy, &quot;virtualProxy&quot;);
 584                 }
 585             }
 586         }
 587     }
 588 
 589     @Override
 590     protected MergeProcessor createMergeProcessor(Block merge) {
 591         return new MergeProcessor(merge);
 592     }
 593 
 594     protected class MergeProcessor extends EffectsClosure&lt;BlockT&gt;.MergeProcessor {
 595 
 596         private EconomicMap&lt;Object, ValuePhiNode&gt; materializedPhis;
 597         private EconomicMap&lt;ValueNode, ValuePhiNode[]&gt; valuePhis;
 598         private EconomicMap&lt;ValuePhiNode, VirtualObjectNode&gt; valueObjectVirtuals;
 599         private final boolean needsCaching;
 600 
 601         public MergeProcessor(Block mergeBlock) {
 602             super(mergeBlock);
 603             // merge will only be called multiple times for loop headers
 604             needsCaching = mergeBlock.isLoopHeader();
 605         }
 606 
 607         protected &lt;T&gt; PhiNode getPhi(T virtual, Stamp stamp) {
 608             if (needsCaching) {
 609                 return getPhiCached(virtual, stamp);
 610             } else {
 611                 return createValuePhi(stamp);
 612             }
 613         }
 614 
 615         private &lt;T&gt; PhiNode getPhiCached(T virtual, Stamp stamp) {
 616             if (materializedPhis == null) {
 617                 materializedPhis = EconomicMap.create(Equivalence.DEFAULT);
 618             }
 619             ValuePhiNode result = materializedPhis.get(virtual);
 620             if (result == null) {
 621                 result = createValuePhi(stamp);
 622                 materializedPhis.put(virtual, result);
 623             }
 624             return result;
 625         }
 626 
 627         private PhiNode[] getValuePhis(ValueNode key, int entryCount) {
 628             if (needsCaching) {
 629                 return getValuePhisCached(key, entryCount);
 630             } else {
 631                 return new ValuePhiNode[entryCount];
 632             }
 633         }
 634 
 635         private PhiNode[] getValuePhisCached(ValueNode key, int entryCount) {
 636             if (valuePhis == null) {
 637                 valuePhis = EconomicMap.create(Equivalence.IDENTITY_WITH_SYSTEM_HASHCODE);
 638             }
 639             ValuePhiNode[] result = valuePhis.get(key);
 640             if (result == null) {
 641                 result = new ValuePhiNode[entryCount];
 642                 valuePhis.put(key, result);
 643             }
 644             assert result.length == entryCount;
 645             return result;
 646         }
 647 
 648         private VirtualObjectNode getValueObjectVirtual(ValuePhiNode phi, VirtualObjectNode virtual) {
 649             if (needsCaching) {
 650                 return getValueObjectVirtualCached(phi, virtual);
 651             } else {
 652                 VirtualObjectNode duplicate = virtual.duplicate();
 653                 duplicate.setNodeSourcePosition(virtual.getNodeSourcePosition());
 654                 return duplicate;
 655             }
 656         }
 657 
 658         private VirtualObjectNode getValueObjectVirtualCached(ValuePhiNode phi, VirtualObjectNode virtual) {
 659             if (valueObjectVirtuals == null) {
 660                 valueObjectVirtuals = EconomicMap.create(Equivalence.IDENTITY);
 661             }
 662             VirtualObjectNode result = valueObjectVirtuals.get(phi);
 663             if (result == null) {
 664                 result = virtual.duplicate();
 665                 result.setNodeSourcePosition(virtual.getNodeSourcePosition());
 666                 valueObjectVirtuals.put(phi, result);
 667             }
 668             return result;
 669         }
 670 
 671         /**
 672          * Merge all predecessor block states into one block state. This is an iterative process,
 673          * because merging states can lead to materializations which make previous parts of the
 674          * merging operation invalid. The merging process is executed until a stable state has been
 675          * reached. This method needs to be careful to place the effects of the merging operation
 676          * into the correct blocks.
 677          *
 678          * @param statesList the predecessor block states of the merge
 679          */
 680         @Override
 681         protected void merge(List&lt;BlockT&gt; statesList) {
 682 
 683             PartialEscapeBlockState&lt;?&gt;[] states = new PartialEscapeBlockState&lt;?&gt;[statesList.size()];
 684             for (int i = 0; i &lt; statesList.size(); i++) {
 685                 states[i] = statesList.get(i);
 686             }
 687 
 688             // calculate the set of virtual objects that exist in all predecessors
 689             int[] virtualObjTemp = intersectVirtualObjects(states);
 690 
 691             boolean forceMaterialization = false;
 692             ValueNode forcedMaterializationValue = null;
 693             FrameState frameState = merge.stateAfter();
 694             if (frameState != null &amp;&amp; frameState.isExceptionHandlingBCI()) {
 695                 // We can not go below merges with an exception handling bci
 696                 // it could create allocations whose slow-path has an invalid framestate
 697                 forceMaterialization = true;
 698                 // check if we can reduce the scope of forced materialization to one phi node
 699                 if (frameState.stackSize() == 1 &amp;&amp; merge.next() instanceof UnwindNode) {
 700                     assert frameState.outerFrameState() == null;
 701                     UnwindNode unwind = (UnwindNode) merge.next();
 702                     if (unwind.exception() == frameState.stackAt(0)) {
 703                         boolean nullLocals = true;
 704                         for (int i = 0; i &lt; frameState.localsSize(); i++) {
 705                             if (frameState.localAt(i) != null) {
 706                                 nullLocals = false;
 707                                 break;
 708                             }
 709                         }
 710                         if (nullLocals) {
 711                             // We found that the merge is directly followed by an unwind
 712                             // the Framestate only has the thrown value on the stack and no locals
 713                             forcedMaterializationValue = unwind.exception();
 714                         }
 715                     }
 716                 }
 717             }
 718 
 719             boolean materialized;
 720             do {
 721                 materialized = false;
 722 
 723                 if (!forceMaterialization &amp;&amp; PartialEscapeBlockState.identicalObjectStates(states)) {
 724                     newState.adoptAddObjectStates(states[0]);
 725                 } else {
 726 
 727                     for (int object : virtualObjTemp) {
 728                         if (!forceMaterialization &amp;&amp; PartialEscapeBlockState.identicalObjectStates(states, object)) {
 729                             newState.addObject(object, states[0].getObjectState(object).share());
 730                             continue;
 731                         }
 732 
 733                         // determine if all inputs are virtual or the same materialized value
 734                         int virtualCount = 0;
 735                         ObjectState startObj = states[0].getObjectState(object);
 736                         boolean locksMatch = true;
 737                         boolean ensureVirtual = true;
 738                         ValueNode uniqueMaterializedValue = startObj.isVirtual() ? null : startObj.getMaterializedValue();
 739                         for (int i = 0; i &lt; states.length; i++) {
 740                             ObjectState obj = states[i].getObjectState(object);
 741                             ensureVirtual &amp;= obj.getEnsureVirtualized();
 742                             if (forceMaterialization) {
 743                                 if (forcedMaterializationValue == null) {
 744                                     uniqueMaterializedValue = null;
 745                                     continue;
 746                                 } else {
 747                                     ValueNode value = forcedMaterializationValue;
 748                                     if (merge.isPhiAtMerge(value)) {
 749                                         value = ((ValuePhiNode) value).valueAt(i);
 750                                     }
 751                                     ValueNode alias = getAlias(value);
 752                                     if (alias instanceof VirtualObjectNode &amp;&amp; ((VirtualObjectNode) alias).getObjectId() == object) {
 753                                         uniqueMaterializedValue = null;
 754                                         continue;
 755                                     }
 756                                 }
 757                             }
 758                             if (obj.isVirtual()) {
 759                                 virtualCount++;
 760                                 uniqueMaterializedValue = null;
 761                                 locksMatch &amp;= obj.locksEqual(startObj);
 762                             } else if (obj.getMaterializedValue() != uniqueMaterializedValue) {
 763                                 uniqueMaterializedValue = null;
 764                             }
 765                         }
 766 
 767                         if (virtualCount == states.length &amp;&amp; locksMatch) {
 768                             materialized |= mergeObjectStates(object, null, states);
 769                         } else {
 770                             if (uniqueMaterializedValue != null) {
 771                                 newState.addObject(object, new ObjectState(uniqueMaterializedValue, null, ensureVirtual));
 772                             } else {
 773                                 PhiNode materializedValuePhi = getPhi(object, StampFactory.forKind(JavaKind.Object));
 774                                 mergeEffects.addFloatingNode(materializedValuePhi, &quot;materializedPhi&quot;);
 775                                 for (int i = 0; i &lt; states.length; i++) {
 776                                     ObjectState obj = states[i].getObjectState(object);
 777                                     if (obj.isVirtual()) {
 778                                         Block predecessor = getPredecessor(i);
 779                                         if (!ensureVirtual &amp;&amp; obj.isVirtual()) {
 780                                             // we can materialize if not all inputs are
 781                                             // &quot;ensureVirtualized&quot;
 782                                             obj.setEnsureVirtualized(false);
 783                                         }
 784                                         materialized |= ensureMaterialized(states[i], object, predecessor.getEndNode(), blockEffects.get(predecessor), COUNTER_MATERIALIZATIONS_MERGE);
 785                                         obj = states[i].getObjectState(object);
 786                                     }
 787                                     setPhiInput(materializedValuePhi, i, obj.getMaterializedValue());
 788                                 }
 789                                 newState.addObject(object, new ObjectState(materializedValuePhi, null, false));
 790                             }
 791                         }
 792                     }
 793                 }
 794 
 795                 for (PhiNode phi : getPhis()) {
 796                     aliases.set(phi, null);
 797                     if (hasVirtualInputs.isMarked(phi) &amp;&amp; phi instanceof ValuePhiNode) {
 798                         materialized |= processPhi((ValuePhiNode) phi, states);
 799                     }
 800                 }
 801                 if (materialized) {
 802                     newState.resetObjectStates(virtualObjects.size());
 803                     mergeEffects.clear();
 804                     afterMergeEffects.clear();
 805                 }
 806             } while (materialized);
 807         }
 808 
 809         private int[] intersectVirtualObjects(PartialEscapeBlockState&lt;?&gt;[] states) {
 810             int length = states[0].getStateCount();
 811             for (int i = 1; i &lt; states.length; i++) {
 812                 length = Math.min(length, states[i].getStateCount());
 813             }
 814 
 815             int count = 0;
 816             for (int objectIndex = 0; objectIndex &lt; length; objectIndex++) {
 817                 if (intersectObjectState(states, objectIndex)) {
 818                     count++;
 819                 }
 820             }
 821 
 822             int index = 0;
 823             int[] resultInts = new int[count];
 824             for (int objectIndex = 0; objectIndex &lt; length; objectIndex++) {
 825                 if (intersectObjectState(states, objectIndex)) {
 826                     resultInts[index++] = objectIndex;
 827                 }
 828             }
 829             assert index == count;
 830             return resultInts;
 831         }
 832 
 833         private boolean intersectObjectState(PartialEscapeBlockState&lt;?&gt;[] states, int objectIndex) {
 834             for (int i = 0; i &lt; states.length; i++) {
 835                 PartialEscapeBlockState&lt;?&gt; state = states[i];
 836                 if (state.getObjectStateOptional(objectIndex) == null) {
 837                     return false;
 838                 }
 839             }
 840             return true;
 841         }
 842 
 843         /**
 844          * Try to merge multiple virtual object states into a single object state. If the incoming
 845          * object states are compatible, then this method will create PhiNodes for the object&#39;s
 846          * entries where needed. If they are incompatible, then all incoming virtual objects will be
 847          * materialized, and a PhiNode for the materialized values will be created. Object states
 848          * can be incompatible if they contain {@code long} or {@code double} values occupying two
 849          * {@code int} slots in such a way that that their values cannot be merged using PhiNodes.
 850          * The states may also be incompatible if they contain escaped large writes to byte arrays
 851          * in such a way that they cannot be merged using PhiNodes.
 852          *
 853          * @param states the predecessor block states of the merge
 854          * @return true if materialization happened during the merge, false otherwise
 855          */
 856         private boolean mergeObjectStates(int resultObject, int[] sourceObjects, PartialEscapeBlockState&lt;?&gt;[] states) {
 857             boolean compatible = true;
 858             boolean ensureVirtual = true;
 859             IntUnaryOperator getObject = index -&gt; sourceObjects == null ? resultObject : sourceObjects[index];
 860 
 861             VirtualObjectNode virtual = virtualObjects.get(resultObject);
 862             int entryCount = virtual.entryCount();
 863 
 864             // determine all entries that have a two-slot value
 865             JavaKind[] twoSlotKinds = null;
 866 
 867             // Determine all entries that span multiple slots.
 868             int[] virtualByteCount = null;
 869             JavaKind[] virtualKinds = null;
 870 
 871             outer: for (int i = 0; i &lt; states.length; i++) {
 872                 ObjectState objectState = states[i].getObjectState(getObject.applyAsInt(i));
 873                 ValueNode[] entries = objectState.getEntries();
 874                 int valueIndex = 0;
 875                 ensureVirtual &amp;= objectState.getEnsureVirtualized();
 876                 while (valueIndex &lt; entryCount) {
 877                     JavaKind otherKind = entries[valueIndex].getStackKind();
 878                     JavaKind entryKind = virtual.entryKind(valueIndex);
 879                     if (entryKind == JavaKind.Int &amp;&amp; otherKind.needsTwoSlots()) {
 880                         if (twoSlotKinds == null) {
 881                             twoSlotKinds = new JavaKind[entryCount];
 882                         }
 883                         if (twoSlotKinds[valueIndex] != null &amp;&amp; twoSlotKinds[valueIndex] != otherKind) {
 884                             compatible = false;
 885                             break outer;
 886                         }
 887                         twoSlotKinds[valueIndex] = otherKind;
 888                         // skip the next entry
 889                         valueIndex++;
 890                     } else if (virtual.isVirtualByteArray()) {
 891                         int bytecount = tool.getVirtualByteCount(entries, valueIndex);
 892                         // @formatter:off
 893                         /*
 894                          * Having a bytecount of 1 here can mean two things:
 895                          * - This was a regular byte array access
 896                          * - This is an uninitialized value (ie: default)
 897                          *
 898                          * In the first case, we want to be able to merge regular accesses without
 899                          * issues. But in the second case, if one of the branch has escaped a write
 900                          * (while other branches did not touch the array), we want to be able to
 901                          * propagate the escape to the merge.
 902                          *
 903                          * However, the semantics of virtual object creation in PEA puts a default
 904                          * (0) byte value on all entries. As such, the merging is done in two steps:
 905                          * - For each virtual entry, know if there is an escaped write in one of the
 906                          * branch, and store its byte count, unless it is 1.
 907                          * - Now that we know the byte count, we can escape multiple writes for the
 908                          * default values from branches that did nothing on the entry in question to
 909                          * a default write of a bigger kind.
 910                          *
 911                          * for example, consider:
 912                          *
 913                          * b = new byte[8];
 914                          * if (...) {b[0] &lt;- 1L}
 915                          * else     {}
 916                          *
 917                          * for escape analysis purposes, it can be seen as:
 918                          *
 919                          * b = new byte[8];
 920                          * if (...) {b[0] &lt;- 1L}
 921                          * else     {b[0] &lt;- 0L}
 922                          */
 923                         // @formatter:on
 924                         if (bytecount &gt; 1) {
 925                             if (virtualByteCount == null) {
 926                                 virtualByteCount = new int[entryCount];
 927                             }
 928                             if (virtualKinds == null) {
 929                                 virtualKinds = new JavaKind[entryCount];
 930                             }
 931                             if (virtualByteCount[valueIndex] != 0 &amp;&amp; virtualByteCount[valueIndex] != bytecount) {
 932                                 compatible = false;
 933                                 break outer;
 934                             }
 935                             // Disallow merging ints with floats. Allows merging shorts with chars
 936                             // (working with stack kinds).
 937                             if (virtualKinds[valueIndex] != null &amp;&amp; virtualKinds[valueIndex] != otherKind) {
 938                                 compatible = false;
 939                                 break outer;
 940                             }
 941                             virtualByteCount[valueIndex] = bytecount;
 942                             virtualKinds[valueIndex] = otherKind;
 943                             // skip illegals.
 944                             valueIndex = valueIndex + bytecount - 1;
 945                         }
 946                     } else {
 947                         assert entryKind.getStackKind() == otherKind.getStackKind() || (entryKind == JavaKind.Int &amp;&amp; otherKind == JavaKind.Illegal) ||
 948                                         entryKind.getBitCount() &gt;= otherKind.getBitCount() : entryKind + &quot; vs &quot; + otherKind;
 949                     }
 950                     valueIndex++;
 951                 }
 952             }
 953             if (compatible &amp;&amp; twoSlotKinds != null) {
 954                 // if there are two-slot values then make sure the incoming states can be merged
 955                 outer: for (int valueIndex = 0; valueIndex &lt; entryCount; valueIndex++) {
 956                     if (twoSlotKinds[valueIndex] != null) {
 957                         assert valueIndex &lt; virtual.entryCount() - 1 &amp;&amp; virtual.entryKind(valueIndex) == JavaKind.Int &amp;&amp; virtual.entryKind(valueIndex + 1) == JavaKind.Int;
 958                         for (int i = 0; i &lt; states.length; i++) {
 959                             int object = getObject.applyAsInt(i);
 960                             ObjectState objectState = states[i].getObjectState(object);
 961                             ValueNode value = objectState.getEntry(valueIndex);
 962                             JavaKind valueKind = value.getStackKind();
 963                             if (valueKind != twoSlotKinds[valueIndex]) {
 964                                 ValueNode nextValue = objectState.getEntry(valueIndex + 1);
 965                                 if (value.isConstant() &amp;&amp; value.asConstant().equals(JavaConstant.INT_0) &amp;&amp; nextValue.isConstant() &amp;&amp; nextValue.asConstant().equals(JavaConstant.INT_0)) {
 966                                     // rewrite to a zero constant of the larger kind
 967                                     debug.log(&quot;Rewriting entry %s to constant of larger size&quot;, valueIndex);
 968                                     states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(twoSlotKinds[valueIndex], graph()));
 969                                     states[i].setEntry(object, valueIndex + 1, tool.getIllegalConstant());
 970                                 } else {
 971                                     compatible = false;
 972                                     break outer;
 973                                 }
 974                             }
 975                         }
 976                     }
 977                 }
 978             }
 979             if (compatible &amp;&amp; virtualByteCount != null) {
 980                 assert twoSlotKinds == null;
 981                 outer: //
 982                 for (int valueIndex = 0; valueIndex &lt; entryCount; valueIndex++) {
 983                     if (virtualByteCount[valueIndex] != 0) {
 984                         int byteCount = virtualByteCount[valueIndex];
 985                         for (int i = 0; i &lt; states.length; i++) {
 986                             int object = getObject.applyAsInt(i);
 987                             ObjectState objectState = states[i].getObjectState(object);
 988                             if (tool.isEntryDefaults(objectState, byteCount, valueIndex)) {
 989                                 // Interpret uninitialized as a corresponding large access.
 990                                 states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(virtualKinds[valueIndex]));
 991                                 for (int illegalIndex = valueIndex + 1; illegalIndex &lt; valueIndex + byteCount; illegalIndex++) {
 992                                     states[i].setEntry(object, illegalIndex, tool.getIllegalConstant());
 993                                 }
 994                             } else {
 995                                 if (tool.getVirtualByteCount(objectState.getEntries(), valueIndex) != byteCount) {
 996                                     compatible = false;
 997                                     break outer;
 998                                 }
 999                             }
1000                         }
1001                     }
1002                 }
1003             }
1004 
1005             if (compatible) {
1006                 // virtual objects are compatible: create phis for all entries that need them
1007                 ValueNode[] values = states[0].getObjectState(getObject.applyAsInt(0)).getEntries().clone();
1008                 PhiNode[] phis = getValuePhis(virtual, virtual.entryCount());
1009                 int valueIndex = 0;
1010                 while (valueIndex &lt; values.length) {
1011                     for (int i = 1; i &lt; states.length; i++) {
1012                         if (phis[valueIndex] == null) {
1013                             ValueNode field = states[i].getObjectState(getObject.applyAsInt(i)).getEntry(valueIndex);
1014                             if (values[valueIndex] != field) {
1015                                 phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
1016                             }
1017                         }
1018                     }
1019                     if (phis[valueIndex] != null &amp;&amp; !phis[valueIndex].stamp(NodeView.DEFAULT).isCompatible(values[valueIndex].stamp(NodeView.DEFAULT))) {
1020                         phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
1021                     }
1022                     if (twoSlotKinds != null &amp;&amp; twoSlotKinds[valueIndex] != null) {
1023                         // skip an entry after a long/double value that occupies two int slots
1024                         valueIndex++;
1025                         phis[valueIndex] = null;
1026                         values[valueIndex] = tool.getIllegalConstant();
1027                     }
1028                     valueIndex++;
1029                 }
1030 
1031                 boolean materialized = false;
1032                 for (int i = 0; i &lt; values.length; i++) {
1033                     PhiNode phi = phis[i];
1034                     if (phi != null) {
1035                         mergeEffects.addFloatingNode(phi, &quot;virtualMergePhi&quot;);
1036                         if (virtual.entryKind(i) == JavaKind.Object) {
1037                             materialized |= mergeObjectEntry(getObject, states, phi, i);
1038                         } else {
1039                             for (int i2 = 0; i2 &lt; states.length; i2++) {
1040                                 ObjectState state = states[i2].getObjectState(getObject.applyAsInt(i2));
1041                                 if (!state.isVirtual()) {
1042                                     break;
1043                                 }
1044                                 setPhiInput(phi, i2, state.getEntry(i));
1045                             }
1046                         }
1047                         values[i] = phi;
1048                     }
1049                 }
1050                 newState.addObject(resultObject, new ObjectState(values, states[0].getObjectState(getObject.applyAsInt(0)).getLocks(), ensureVirtual));
1051                 return materialized;
1052             } else {
1053                 // not compatible: materialize in all predecessors
1054                 PhiNode materializedValuePhi = getPhi(resultObject, StampFactory.forKind(JavaKind.Object));
1055                 for (int i = 0; i &lt; states.length; i++) {
1056                     Block predecessor = getPredecessor(i);
1057                     if (!ensureVirtual &amp;&amp; states[i].getObjectState(getObject.applyAsInt(i)).isVirtual()) {
1058                         // we can materialize if not all inputs are &quot;ensureVirtualized&quot;
1059                         states[i].getObjectState(getObject.applyAsInt(i)).setEnsureVirtualized(false);
1060                     }
1061                     ensureMaterialized(states[i], getObject.applyAsInt(i), predecessor.getEndNode(), blockEffects.get(predecessor), COUNTER_MATERIALIZATIONS_MERGE);
1062                     setPhiInput(materializedValuePhi, i, states[i].getObjectState(getObject.applyAsInt(i)).getMaterializedValue());
1063                 }
1064                 newState.addObject(resultObject, new ObjectState(materializedValuePhi, null, ensureVirtual));
1065                 return true;
1066             }
1067         }
1068 
1069         /**
1070          * Fill the inputs of the PhiNode corresponding to one {@link JavaKind#Object} entry in the
1071          * virtual object.
1072          *
1073          * @return true if materialization happened during the merge, false otherwise
1074          */
1075         private boolean mergeObjectEntry(IntUnaryOperator objectIdFunc, PartialEscapeBlockState&lt;?&gt;[] states, PhiNode phi, int entryIndex) {
1076             boolean materialized = false;
1077             for (int i = 0; i &lt; states.length; i++) {
1078                 int object = objectIdFunc.applyAsInt(i);
1079                 ObjectState objectState = states[i].getObjectState(object);
1080                 if (!objectState.isVirtual()) {
1081                     break;
1082                 }
1083                 ValueNode entry = objectState.getEntry(entryIndex);
1084                 if (entry instanceof VirtualObjectNode) {
1085                     VirtualObjectNode entryVirtual = (VirtualObjectNode) entry;
1086                     Block predecessor = getPredecessor(i);
1087                     materialized |= ensureMaterialized(states[i], entryVirtual.getObjectId(), predecessor.getEndNode(), blockEffects.get(predecessor), COUNTER_MATERIALIZATIONS_MERGE);
1088                     objectState = states[i].getObjectState(object);
1089                     if (objectState.isVirtual()) {
1090                         states[i].setEntry(object, entryIndex, entry = states[i].getObjectState(entryVirtual.getObjectId()).getMaterializedValue());
1091                     }
1092                 }
1093                 setPhiInput(phi, i, entry);
1094             }
1095             return materialized;
1096         }
1097 
1098         /**
1099          * Examine a PhiNode and try to replace it with merging of virtual objects if all its inputs
1100          * refer to virtual object states. In order for the merging to happen, all incoming object
1101          * states need to be compatible and without object identity (meaning that their object
1102          * identity if not used later on).
1103          *
1104          * @param phi the PhiNode that should be processed
1105          * @param states the predecessor block states of the merge
1106          * @return true if materialization happened during the merge, false otherwise
1107          */
1108         private boolean processPhi(ValuePhiNode phi, PartialEscapeBlockState&lt;?&gt;[] states) {
1109 
1110             // determine how many inputs are virtual and if they&#39;re all the same virtual object
1111             int virtualInputs = 0;
1112             boolean uniqueVirtualObject = true;
1113             boolean ensureVirtual = true;
1114             VirtualObjectNode[] virtualObjs = new VirtualObjectNode[states.length];
1115             for (int i = 0; i &lt; states.length; i++) {
1116                 ValueNode alias = getAlias(getPhiValueAt(phi, i));
1117                 if (alias instanceof VirtualObjectNode) {
1118                     VirtualObjectNode virtual = (VirtualObjectNode) alias;
1119                     virtualObjs[i] = virtual;
1120                     ObjectState objectState = states[i].getObjectStateOptional(virtual);
1121                     if (objectState == null) {
1122                         assert getPhiValueAt(phi, i) instanceof PhiNode : &quot;this should only happen for phi nodes&quot;;
1123                         return false;
1124                     }
1125                     if (objectState.isVirtual()) {
1126                         if (virtualObjs[0] != alias) {
1127                             uniqueVirtualObject = false;
1128                         }
1129                         ensureVirtual &amp;= objectState.getEnsureVirtualized();
1130                         virtualInputs++;
1131                     }
1132                 }
1133             }
1134             if (virtualInputs == states.length) {
1135                 if (uniqueVirtualObject) {
1136                     // all inputs refer to the same object: just make the phi node an alias
1137                     addVirtualAlias(virtualObjs[0], phi);
1138                     mergeEffects.deleteNode(phi);
1139                     return false;
1140                 } else {
1141                     // all inputs are virtual: check if they&#39;re compatible and without identity
1142                     boolean compatible = true;
1143                     VirtualObjectNode firstVirtual = virtualObjs[0];
1144                     for (int i = 0; i &lt; states.length; i++) {
1145                         VirtualObjectNode virtual = virtualObjs[i];
1146 
1147                         if (!firstVirtual.type().equals(virtual.type()) || firstVirtual.entryCount() != virtual.entryCount()) {
1148                             compatible = false;
1149                             break;
1150                         }
1151                         if (!states[0].getObjectState(firstVirtual).locksEqual(states[i].getObjectState(virtual))) {
1152                             compatible = false;
1153                             break;
1154                         }
1155                     }
1156                     if (compatible) {
1157                         for (int i = 0; i &lt; states.length; i++) {
1158                             VirtualObjectNode virtual = virtualObjs[i];
1159                             /*
1160                              * check whether we trivially see that this is the only reference to
1161                              * this allocation
1162                              */
1163                             if (virtual.hasIdentity() &amp;&amp; !isSingleUsageAllocation(getPhiValueAt(phi, i), virtualObjs, states[i])) {
1164                                 compatible = false;
1165                                 break;
1166                             }
1167                         }
1168                     }
1169                     if (compatible) {
1170                         VirtualObjectNode virtual = getValueObjectVirtual(phi, virtualObjs[0]);
1171                         mergeEffects.addFloatingNode(virtual, &quot;valueObjectNode&quot;);
1172                         mergeEffects.deleteNode(phi);
1173                         if (virtual.getObjectId() == -1) {
1174                             int id = virtualObjects.size();
1175                             virtualObjects.add(virtual);
1176                             virtual.setObjectId(id);
1177                         }
1178 
1179                         int[] virtualObjectIds = new int[states.length];
1180                         for (int i = 0; i &lt; states.length; i++) {
1181                             virtualObjectIds[i] = virtualObjs[i].getObjectId();
1182                         }
1183                         boolean materialized = mergeObjectStates(virtual.getObjectId(), virtualObjectIds, states);
1184                         addVirtualAlias(virtual, virtual);
1185                         addVirtualAlias(virtual, phi);
1186                         return materialized;
1187                     }
1188                 }
1189             }
1190 
1191             // otherwise: materialize all phi inputs
1192             boolean materialized = false;
1193             if (virtualInputs &gt; 0) {
1194                 for (int i = 0; i &lt; states.length; i++) {
1195                     VirtualObjectNode virtual = virtualObjs[i];
1196                     if (virtual != null) {
1197                         Block predecessor = getPredecessor(i);
1198                         if (!ensureVirtual &amp;&amp; states[i].getObjectState(virtual).isVirtual()) {
1199                             // we can materialize if not all inputs are &quot;ensureVirtualized&quot;
1200                             states[i].getObjectState(virtual).setEnsureVirtualized(false);
1201                         }
1202                         materialized |= ensureMaterialized(states[i], virtual.getObjectId(), predecessor.getEndNode(), blockEffects.get(predecessor), COUNTER_MATERIALIZATIONS_PHI);
1203                     }
1204                 }
1205             }
1206             for (int i = 0; i &lt; states.length; i++) {
1207                 VirtualObjectNode virtual = virtualObjs[i];
1208                 if (virtual != null) {
1209                     setPhiInput(phi, i, getAliasAndResolve(states[i], virtual));
1210                 }
1211             }
1212             return materialized;
1213         }
1214 
1215         private boolean isSingleUsageAllocation(ValueNode value, VirtualObjectNode[] virtualObjs, PartialEscapeBlockState&lt;?&gt; state) {
1216             /*
1217              * If the phi input is an allocation, we know that it is a &quot;fresh&quot; value, i.e., that
1218              * this is a value that will only appear through this source, and cannot appear anywhere
1219              * else. If the phi is also the only usage of this input, we know that no other place
1220              * can check object identity against it, so it is safe to lose the object identity here.
1221              */
1222             if (!(value instanceof AllocatedObjectNode &amp;&amp; value.hasExactlyOneUsage())) {
1223                 return false;
1224             }
1225 
1226             /*
1227              * Check that the state only references the one virtual object from the Phi.
1228              */
1229             VirtualObjectNode singleVirtual = null;
1230             for (int v = 0; v &lt; virtualObjs.length; v++) {
1231                 if (state.contains(virtualObjs[v])) {
1232                     if (singleVirtual == null) {
1233                         singleVirtual = virtualObjs[v];
1234                     } else if (singleVirtual != virtualObjs[v]) {
1235                         /*
1236                          * More than one virtual object is visible in the object state.
1237                          */
1238                         return false;
1239                     }
1240                 }
1241             }
1242             return true;
1243         }
1244     }
1245 
1246     public ObjectState getObjectState(PartialEscapeBlockState&lt;?&gt; state, ValueNode value) {
1247         if (value == null) {
1248             return null;
1249         }
1250         if (value.isAlive() &amp;&amp; !aliases.isNew(value)) {
1251             ValueNode object = aliases.get(value);
1252             return object instanceof VirtualObjectNode ? state.getObjectStateOptional((VirtualObjectNode) object) : null;
1253         } else {
1254             if (value instanceof VirtualObjectNode) {
1255                 return state.getObjectStateOptional((VirtualObjectNode) value);
1256             }
1257             return null;
1258         }
1259     }
1260 
1261     public ValueNode getAlias(ValueNode value) {
1262         if (value != null &amp;&amp; !(value instanceof VirtualObjectNode)) {
1263             if (value.isAlive() &amp;&amp; !aliases.isNew(value)) {
1264                 ValueNode result = aliases.get(value);
1265                 if (result != null) {
1266                     return result;
1267                 }
1268             }
1269         }
1270         return value;
1271     }
1272 
1273     public ValueNode getAliasAndResolve(PartialEscapeBlockState&lt;?&gt; state, ValueNode value) {
1274         ValueNode result = getAlias(value);
1275         if (result instanceof VirtualObjectNode) {
1276             int id = ((VirtualObjectNode) result).getObjectId();
1277             if (id != -1 &amp;&amp; !state.getObjectState(id).isVirtual()) {
1278                 result = state.getObjectState(id).getMaterializedValue();
1279             }
1280         }
1281         return result;
1282     }
1283 
1284     void addVirtualAlias(VirtualObjectNode virtual, ValueNode node) {
1285         if (node.isAlive()) {
1286             aliases.set(node, virtual);
1287             for (Node usage : node.usages()) {
1288                 markVirtualUsages(usage);
1289             }
1290         }
1291     }
1292 
1293     private void markVirtualUsages(Node node) {
1294         if (!hasVirtualInputs.isNew(node) &amp;&amp; !hasVirtualInputs.isMarked(node)) {
1295             hasVirtualInputs.mark(node);
1296             if (node instanceof VirtualState) {
1297                 for (Node usage : node.usages()) {
1298                     markVirtualUsages(usage);
1299                 }
1300             }
1301         }
1302     }
1303 }
    </pre>
  </body>
</html>
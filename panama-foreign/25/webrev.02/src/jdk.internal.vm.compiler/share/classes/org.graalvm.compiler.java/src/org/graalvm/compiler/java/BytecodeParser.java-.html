<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.java/src/org/graalvm/compiler/java/BytecodeParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.java;
  26 
  27 import static java.lang.String.format;
  28 import static java.lang.reflect.Modifier.STATIC;
  29 import static java.lang.reflect.Modifier.SYNCHRONIZED;
  30 import static jdk.vm.ci.code.BytecodeFrame.UNKNOWN_BCI;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateRecompile;
  32 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  33 import static jdk.vm.ci.meta.DeoptimizationAction.None;
  34 import static jdk.vm.ci.meta.DeoptimizationReason.ClassCastException;
  35 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  36 import static jdk.vm.ci.meta.DeoptimizationReason.RuntimeConstraint;
  37 import static jdk.vm.ci.meta.DeoptimizationReason.UnreachedCode;
  38 import static jdk.vm.ci.meta.DeoptimizationReason.Unresolved;
  39 import static jdk.vm.ci.runtime.JVMCICompiler.INVOCATION_ENTRY_BCI;
  40 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  41 import static org.graalvm.compiler.bytecode.Bytecodes.AALOAD;
  42 import static org.graalvm.compiler.bytecode.Bytecodes.AASTORE;
  43 import static org.graalvm.compiler.bytecode.Bytecodes.ACONST_NULL;
  44 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD;
  45 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_0;
  46 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_1;
  47 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_2;
  48 import static org.graalvm.compiler.bytecode.Bytecodes.ALOAD_3;
  49 import static org.graalvm.compiler.bytecode.Bytecodes.ANEWARRAY;
  50 import static org.graalvm.compiler.bytecode.Bytecodes.ARETURN;
  51 import static org.graalvm.compiler.bytecode.Bytecodes.ARRAYLENGTH;
  52 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE;
  53 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_0;
  54 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_1;
  55 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_2;
  56 import static org.graalvm.compiler.bytecode.Bytecodes.ASTORE_3;
  57 import static org.graalvm.compiler.bytecode.Bytecodes.ATHROW;
  58 import static org.graalvm.compiler.bytecode.Bytecodes.BALOAD;
  59 import static org.graalvm.compiler.bytecode.Bytecodes.BASTORE;
  60 import static org.graalvm.compiler.bytecode.Bytecodes.BIPUSH;
  61 import static org.graalvm.compiler.bytecode.Bytecodes.BREAKPOINT;
  62 import static org.graalvm.compiler.bytecode.Bytecodes.CALOAD;
  63 import static org.graalvm.compiler.bytecode.Bytecodes.CASTORE;
  64 import static org.graalvm.compiler.bytecode.Bytecodes.CHECKCAST;
  65 import static org.graalvm.compiler.bytecode.Bytecodes.D2F;
  66 import static org.graalvm.compiler.bytecode.Bytecodes.D2I;
  67 import static org.graalvm.compiler.bytecode.Bytecodes.D2L;
  68 import static org.graalvm.compiler.bytecode.Bytecodes.DADD;
  69 import static org.graalvm.compiler.bytecode.Bytecodes.DALOAD;
  70 import static org.graalvm.compiler.bytecode.Bytecodes.DASTORE;
  71 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPG;
  72 import static org.graalvm.compiler.bytecode.Bytecodes.DCMPL;
  73 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_0;
  74 import static org.graalvm.compiler.bytecode.Bytecodes.DCONST_1;
  75 import static org.graalvm.compiler.bytecode.Bytecodes.DDIV;
  76 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD;
  77 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_0;
  78 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_1;
  79 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_2;
  80 import static org.graalvm.compiler.bytecode.Bytecodes.DLOAD_3;
  81 import static org.graalvm.compiler.bytecode.Bytecodes.DMUL;
  82 import static org.graalvm.compiler.bytecode.Bytecodes.DNEG;
  83 import static org.graalvm.compiler.bytecode.Bytecodes.DREM;
  84 import static org.graalvm.compiler.bytecode.Bytecodes.DRETURN;
  85 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE;
  86 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_0;
  87 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_1;
  88 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_2;
  89 import static org.graalvm.compiler.bytecode.Bytecodes.DSTORE_3;
  90 import static org.graalvm.compiler.bytecode.Bytecodes.DSUB;
  91 import static org.graalvm.compiler.bytecode.Bytecodes.DUP;
  92 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2;
  93 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X1;
  94 import static org.graalvm.compiler.bytecode.Bytecodes.DUP2_X2;
  95 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X1;
  96 import static org.graalvm.compiler.bytecode.Bytecodes.DUP_X2;
  97 import static org.graalvm.compiler.bytecode.Bytecodes.F2D;
  98 import static org.graalvm.compiler.bytecode.Bytecodes.F2I;
  99 import static org.graalvm.compiler.bytecode.Bytecodes.F2L;
 100 import static org.graalvm.compiler.bytecode.Bytecodes.FADD;
 101 import static org.graalvm.compiler.bytecode.Bytecodes.FALOAD;
 102 import static org.graalvm.compiler.bytecode.Bytecodes.FASTORE;
 103 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPG;
 104 import static org.graalvm.compiler.bytecode.Bytecodes.FCMPL;
 105 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_0;
 106 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_1;
 107 import static org.graalvm.compiler.bytecode.Bytecodes.FCONST_2;
 108 import static org.graalvm.compiler.bytecode.Bytecodes.FDIV;
 109 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD;
 110 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_0;
 111 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_1;
 112 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_2;
 113 import static org.graalvm.compiler.bytecode.Bytecodes.FLOAD_3;
 114 import static org.graalvm.compiler.bytecode.Bytecodes.FMUL;
 115 import static org.graalvm.compiler.bytecode.Bytecodes.FNEG;
 116 import static org.graalvm.compiler.bytecode.Bytecodes.FREM;
 117 import static org.graalvm.compiler.bytecode.Bytecodes.FRETURN;
 118 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE;
 119 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_0;
 120 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_1;
 121 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_2;
 122 import static org.graalvm.compiler.bytecode.Bytecodes.FSTORE_3;
 123 import static org.graalvm.compiler.bytecode.Bytecodes.FSUB;
 124 import static org.graalvm.compiler.bytecode.Bytecodes.GETFIELD;
 125 import static org.graalvm.compiler.bytecode.Bytecodes.GETSTATIC;
 126 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO;
 127 import static org.graalvm.compiler.bytecode.Bytecodes.GOTO_W;
 128 import static org.graalvm.compiler.bytecode.Bytecodes.I2B;
 129 import static org.graalvm.compiler.bytecode.Bytecodes.I2C;
 130 import static org.graalvm.compiler.bytecode.Bytecodes.I2D;
 131 import static org.graalvm.compiler.bytecode.Bytecodes.I2F;
 132 import static org.graalvm.compiler.bytecode.Bytecodes.I2L;
 133 import static org.graalvm.compiler.bytecode.Bytecodes.I2S;
 134 import static org.graalvm.compiler.bytecode.Bytecodes.IADD;
 135 import static org.graalvm.compiler.bytecode.Bytecodes.IALOAD;
 136 import static org.graalvm.compiler.bytecode.Bytecodes.IAND;
 137 import static org.graalvm.compiler.bytecode.Bytecodes.IASTORE;
 138 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_0;
 139 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_1;
 140 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_2;
 141 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_3;
 142 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_4;
 143 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_5;
 144 import static org.graalvm.compiler.bytecode.Bytecodes.ICONST_M1;
 145 import static org.graalvm.compiler.bytecode.Bytecodes.IDIV;
 146 import static org.graalvm.compiler.bytecode.Bytecodes.IFEQ;
 147 import static org.graalvm.compiler.bytecode.Bytecodes.IFGE;
 148 import static org.graalvm.compiler.bytecode.Bytecodes.IFGT;
 149 import static org.graalvm.compiler.bytecode.Bytecodes.IFLE;
 150 import static org.graalvm.compiler.bytecode.Bytecodes.IFLT;
 151 import static org.graalvm.compiler.bytecode.Bytecodes.IFNE;
 152 import static org.graalvm.compiler.bytecode.Bytecodes.IFNONNULL;
 153 import static org.graalvm.compiler.bytecode.Bytecodes.IFNULL;
 154 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPEQ;
 155 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ACMPNE;
 156 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPEQ;
 157 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGE;
 158 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPGT;
 159 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLE;
 160 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPLT;
 161 import static org.graalvm.compiler.bytecode.Bytecodes.IF_ICMPNE;
 162 import static org.graalvm.compiler.bytecode.Bytecodes.IINC;
 163 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD;
 164 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_0;
 165 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_1;
 166 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_2;
 167 import static org.graalvm.compiler.bytecode.Bytecodes.ILOAD_3;
 168 import static org.graalvm.compiler.bytecode.Bytecodes.IMUL;
 169 import static org.graalvm.compiler.bytecode.Bytecodes.INEG;
 170 import static org.graalvm.compiler.bytecode.Bytecodes.INSTANCEOF;
 171 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEDYNAMIC;
 172 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEINTERFACE;
 173 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESPECIAL;
 174 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKESTATIC;
 175 import static org.graalvm.compiler.bytecode.Bytecodes.INVOKEVIRTUAL;
 176 import static org.graalvm.compiler.bytecode.Bytecodes.IOR;
 177 import static org.graalvm.compiler.bytecode.Bytecodes.IREM;
 178 import static org.graalvm.compiler.bytecode.Bytecodes.IRETURN;
 179 import static org.graalvm.compiler.bytecode.Bytecodes.ISHL;
 180 import static org.graalvm.compiler.bytecode.Bytecodes.ISHR;
 181 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE;
 182 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_0;
 183 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_1;
 184 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_2;
 185 import static org.graalvm.compiler.bytecode.Bytecodes.ISTORE_3;
 186 import static org.graalvm.compiler.bytecode.Bytecodes.ISUB;
 187 import static org.graalvm.compiler.bytecode.Bytecodes.IUSHR;
 188 import static org.graalvm.compiler.bytecode.Bytecodes.IXOR;
 189 import static org.graalvm.compiler.bytecode.Bytecodes.JSR;
 190 import static org.graalvm.compiler.bytecode.Bytecodes.JSR_W;
 191 import static org.graalvm.compiler.bytecode.Bytecodes.L2D;
 192 import static org.graalvm.compiler.bytecode.Bytecodes.L2F;
 193 import static org.graalvm.compiler.bytecode.Bytecodes.L2I;
 194 import static org.graalvm.compiler.bytecode.Bytecodes.LADD;
 195 import static org.graalvm.compiler.bytecode.Bytecodes.LALOAD;
 196 import static org.graalvm.compiler.bytecode.Bytecodes.LAND;
 197 import static org.graalvm.compiler.bytecode.Bytecodes.LASTORE;
 198 import static org.graalvm.compiler.bytecode.Bytecodes.LCMP;
 199 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_0;
 200 import static org.graalvm.compiler.bytecode.Bytecodes.LCONST_1;
 201 import static org.graalvm.compiler.bytecode.Bytecodes.LDC;
 202 import static org.graalvm.compiler.bytecode.Bytecodes.LDC2_W;
 203 import static org.graalvm.compiler.bytecode.Bytecodes.LDC_W;
 204 import static org.graalvm.compiler.bytecode.Bytecodes.LDIV;
 205 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD;
 206 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_0;
 207 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_1;
 208 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_2;
 209 import static org.graalvm.compiler.bytecode.Bytecodes.LLOAD_3;
 210 import static org.graalvm.compiler.bytecode.Bytecodes.LMUL;
 211 import static org.graalvm.compiler.bytecode.Bytecodes.LNEG;
 212 import static org.graalvm.compiler.bytecode.Bytecodes.LOOKUPSWITCH;
 213 import static org.graalvm.compiler.bytecode.Bytecodes.LOR;
 214 import static org.graalvm.compiler.bytecode.Bytecodes.LREM;
 215 import static org.graalvm.compiler.bytecode.Bytecodes.LRETURN;
 216 import static org.graalvm.compiler.bytecode.Bytecodes.LSHL;
 217 import static org.graalvm.compiler.bytecode.Bytecodes.LSHR;
 218 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE;
 219 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_0;
 220 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_1;
 221 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_2;
 222 import static org.graalvm.compiler.bytecode.Bytecodes.LSTORE_3;
 223 import static org.graalvm.compiler.bytecode.Bytecodes.LSUB;
 224 import static org.graalvm.compiler.bytecode.Bytecodes.LUSHR;
 225 import static org.graalvm.compiler.bytecode.Bytecodes.LXOR;
 226 import static org.graalvm.compiler.bytecode.Bytecodes.MONITORENTER;
 227 import static org.graalvm.compiler.bytecode.Bytecodes.MONITOREXIT;
 228 import static org.graalvm.compiler.bytecode.Bytecodes.MULTIANEWARRAY;
 229 import static org.graalvm.compiler.bytecode.Bytecodes.NEW;
 230 import static org.graalvm.compiler.bytecode.Bytecodes.NEWARRAY;
 231 import static org.graalvm.compiler.bytecode.Bytecodes.NOP;
 232 import static org.graalvm.compiler.bytecode.Bytecodes.POP;
 233 import static org.graalvm.compiler.bytecode.Bytecodes.POP2;
 234 import static org.graalvm.compiler.bytecode.Bytecodes.PUTFIELD;
 235 import static org.graalvm.compiler.bytecode.Bytecodes.PUTSTATIC;
 236 import static org.graalvm.compiler.bytecode.Bytecodes.RET;
 237 import static org.graalvm.compiler.bytecode.Bytecodes.RETURN;
 238 import static org.graalvm.compiler.bytecode.Bytecodes.SALOAD;
 239 import static org.graalvm.compiler.bytecode.Bytecodes.SASTORE;
 240 import static org.graalvm.compiler.bytecode.Bytecodes.SIPUSH;
 241 import static org.graalvm.compiler.bytecode.Bytecodes.SWAP;
 242 import static org.graalvm.compiler.bytecode.Bytecodes.TABLESWITCH;
 243 import static org.graalvm.compiler.bytecode.Bytecodes.nameOf;
 244 import static org.graalvm.compiler.core.common.GraalOptions.DeoptALot;
 245 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 246 import static org.graalvm.compiler.core.common.GraalOptions.HotSpotPrintInlining;
 247 import static org.graalvm.compiler.core.common.GraalOptions.PrintProfilingInformation;
 248 import static org.graalvm.compiler.core.common.GraalOptions.StressExplicitExceptionCode;
 249 import static org.graalvm.compiler.core.common.GraalOptions.StressInvokeWithExceptionNode;
 250 import static org.graalvm.compiler.core.common.type.StampFactory.objectNonNull;
 251 import static org.graalvm.compiler.debug.GraalError.guarantee;
 252 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
 253 import static org.graalvm.compiler.java.BytecodeParserOptions.InlinePartialIntrinsicExitDuringParsing;
 254 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceBytecodeParserLevel;
 255 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceInlineDuringParsing;
 256 import static org.graalvm.compiler.java.BytecodeParserOptions.TraceParserPlugins;
 257 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_FAST_PATH_PROBABILITY;
 258 import static org.graalvm.compiler.nodes.extended.BranchProbabilityNode.LUDICROUSLY_SLOW_PATH_PROBABILITY;
 259 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_DURING_PARSING;
 260 import static org.graalvm.compiler.nodes.type.StampTool.isPointerNonNull;
 261 
 262 import java.util.ArrayList;
 263 import java.util.Collections;
 264 import java.util.Comparator;
 265 import java.util.Formatter;
 266 import java.util.List;
 267 import java.util.function.Supplier;
 268 
 269 import jdk.internal.vm.compiler.collections.EconomicMap;
 270 import jdk.internal.vm.compiler.collections.Equivalence;
 271 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
 272 import org.graalvm.compiler.api.replacements.Fold;
 273 import org.graalvm.compiler.api.replacements.MethodSubstitution;
 274 import org.graalvm.compiler.api.replacements.Snippet;
 275 import org.graalvm.compiler.bytecode.Bytecode;
 276 import org.graalvm.compiler.bytecode.BytecodeDisassembler;
 277 import org.graalvm.compiler.bytecode.BytecodeLookupSwitch;
 278 import org.graalvm.compiler.bytecode.BytecodeProvider;
 279 import org.graalvm.compiler.bytecode.BytecodeStream;
 280 import org.graalvm.compiler.bytecode.BytecodeSwitch;
 281 import org.graalvm.compiler.bytecode.BytecodeTableSwitch;
 282 import org.graalvm.compiler.bytecode.Bytecodes;
 283 import org.graalvm.compiler.bytecode.Bytes;
 284 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
 285 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecodeProvider;
 286 import org.graalvm.compiler.core.common.GraalOptions;
 287 import org.graalvm.compiler.core.common.PermanentBailoutException;
 288 import org.graalvm.compiler.core.common.RetryableBailoutException;
 289 import org.graalvm.compiler.core.common.calc.CanonicalCondition;
 290 import org.graalvm.compiler.core.common.calc.Condition;
 291 import org.graalvm.compiler.core.common.calc.Condition.CanonicalizedCondition;
 292 import org.graalvm.compiler.core.common.calc.FloatConvert;
 293 import org.graalvm.compiler.core.common.spi.ConstantFieldProvider;
 294 import org.graalvm.compiler.core.common.type.IntegerStamp;
 295 import org.graalvm.compiler.core.common.type.ObjectStamp;
 296 import org.graalvm.compiler.core.common.type.Stamp;
 297 import org.graalvm.compiler.core.common.type.StampFactory;
 298 import org.graalvm.compiler.core.common.type.StampPair;
 299 import org.graalvm.compiler.core.common.type.TypeReference;
 300 import org.graalvm.compiler.core.common.util.Util;
 301 import org.graalvm.compiler.debug.Assertions;
 302 import org.graalvm.compiler.debug.CounterKey;
 303 import org.graalvm.compiler.debug.DebugCloseable;
 304 import org.graalvm.compiler.debug.DebugContext;
 305 import org.graalvm.compiler.debug.DebugOptions;
 306 import org.graalvm.compiler.debug.GraalError;
 307 import org.graalvm.compiler.debug.Indent;
 308 import org.graalvm.compiler.debug.MethodFilter;
 309 import org.graalvm.compiler.debug.TTY;
 310 import org.graalvm.compiler.graph.Graph.Mark;
 311 import org.graalvm.compiler.graph.Node;
 312 import org.graalvm.compiler.graph.NodeSourcePosition;
 313 import org.graalvm.compiler.graph.iterators.NodeIterable;
 314 import org.graalvm.compiler.java.BciBlockMapping.BciBlock;
 315 import org.graalvm.compiler.java.BciBlockMapping.ExceptionDispatchBlock;
 316 import org.graalvm.compiler.nodes.AbstractBeginNode;
 317 import org.graalvm.compiler.nodes.AbstractMergeNode;
 318 import org.graalvm.compiler.nodes.BeginNode;
 319 import org.graalvm.compiler.nodes.BeginStateSplitNode;
 320 import org.graalvm.compiler.nodes.CallTargetNode;
 321 import org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;
 322 import org.graalvm.compiler.nodes.ConstantNode;
 323 import org.graalvm.compiler.nodes.ControlSplitNode;
 324 import org.graalvm.compiler.nodes.DeoptimizeNode;
 325 import org.graalvm.compiler.nodes.EndNode;
 326 import org.graalvm.compiler.nodes.EntryMarkerNode;
 327 import org.graalvm.compiler.nodes.EntryProxyNode;
 328 import org.graalvm.compiler.nodes.FieldLocationIdentity;
 329 import org.graalvm.compiler.nodes.FixedGuardNode;
 330 import org.graalvm.compiler.nodes.FixedNode;
 331 import org.graalvm.compiler.nodes.FixedWithNextNode;
 332 import org.graalvm.compiler.nodes.FrameState;
 333 import org.graalvm.compiler.nodes.FullInfopointNode;
 334 import org.graalvm.compiler.nodes.IfNode;
 335 import org.graalvm.compiler.nodes.InliningLog;
 336 import org.graalvm.compiler.nodes.Invoke;
 337 import org.graalvm.compiler.nodes.InvokeNode;
 338 import org.graalvm.compiler.nodes.InvokeWithExceptionNode;
 339 import org.graalvm.compiler.nodes.KillingBeginNode;
 340 import org.graalvm.compiler.nodes.LogicConstantNode;
 341 import org.graalvm.compiler.nodes.LogicNegationNode;
 342 import org.graalvm.compiler.nodes.LogicNode;
 343 import org.graalvm.compiler.nodes.LoopBeginNode;
 344 import org.graalvm.compiler.nodes.LoopEndNode;
 345 import org.graalvm.compiler.nodes.LoopExitNode;
 346 import org.graalvm.compiler.nodes.MergeNode;
 347 import org.graalvm.compiler.nodes.NodeView;
 348 import org.graalvm.compiler.nodes.ParameterNode;
 349 import org.graalvm.compiler.nodes.PiNode;
 350 import org.graalvm.compiler.nodes.ReturnNode;
 351 import org.graalvm.compiler.nodes.StartNode;
 352 import org.graalvm.compiler.nodes.StateSplit;
 353 import org.graalvm.compiler.nodes.StructuredGraph;
 354 import org.graalvm.compiler.nodes.UnwindNode;
 355 import org.graalvm.compiler.nodes.ValueNode;
 356 import org.graalvm.compiler.nodes.ValuePhiNode;
 357 import org.graalvm.compiler.nodes.calc.AddNode;
 358 import org.graalvm.compiler.nodes.calc.AndNode;
 359 import org.graalvm.compiler.nodes.calc.CompareNode;
 360 import org.graalvm.compiler.nodes.calc.ConditionalNode;
 361 import org.graalvm.compiler.nodes.calc.FloatConvertNode;
 362 import org.graalvm.compiler.nodes.calc.FloatDivNode;
 363 import org.graalvm.compiler.nodes.calc.FloatNormalizeCompareNode;
 364 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
 365 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
 366 import org.graalvm.compiler.nodes.calc.IntegerLessThanNode;
 367 import org.graalvm.compiler.nodes.calc.IntegerNormalizeCompareNode;
 368 import org.graalvm.compiler.nodes.calc.IsNullNode;
 369 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 370 import org.graalvm.compiler.nodes.calc.MulNode;
 371 import org.graalvm.compiler.nodes.calc.NarrowNode;
 372 import org.graalvm.compiler.nodes.calc.NegateNode;
 373 import org.graalvm.compiler.nodes.calc.ObjectEqualsNode;
 374 import org.graalvm.compiler.nodes.calc.OrNode;
 375 import org.graalvm.compiler.nodes.calc.RemNode;
 376 import org.graalvm.compiler.nodes.calc.RightShiftNode;
 377 import org.graalvm.compiler.nodes.calc.SignExtendNode;
 378 import org.graalvm.compiler.nodes.calc.SignedDivNode;
 379 import org.graalvm.compiler.nodes.calc.SignedRemNode;
 380 import org.graalvm.compiler.nodes.calc.SubNode;
 381 import org.graalvm.compiler.nodes.calc.UnsignedRightShiftNode;
 382 import org.graalvm.compiler.nodes.calc.XorNode;
 383 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
 384 import org.graalvm.compiler.nodes.extended.AnchoringNode;
 385 import org.graalvm.compiler.nodes.extended.BranchProbabilityNode;
 386 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
 387 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
 388 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 389 import org.graalvm.compiler.nodes.extended.GuardingNode;
 390 import org.graalvm.compiler.nodes.extended.IntegerSwitchNode;
 391 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 392 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 393 import org.graalvm.compiler.nodes.extended.MembarNode;
 394 import org.graalvm.compiler.nodes.extended.StateSplitProxyNode;
 395 import org.graalvm.compiler.nodes.graphbuilderconf.ClassInitializationPlugin;
 396 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
 397 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.BytecodeExceptionMode;
 398 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 399 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
 400 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo;
 401 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 402 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 403 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.InvocationPluginReceiver;
 404 import org.graalvm.compiler.nodes.graphbuilderconf.InvokeDynamicPlugin;
 405 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
 406 import org.graalvm.compiler.nodes.graphbuilderconf.ProfilingPlugin;
 407 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 408 import org.graalvm.compiler.nodes.java.ExceptionObjectNode;
 409 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 410 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 411 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 412 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 413 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 414 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 415 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 416 import org.graalvm.compiler.nodes.java.MonitorExitNode;
 417 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 418 import org.graalvm.compiler.nodes.java.NewArrayNode;
 419 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 420 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
 421 import org.graalvm.compiler.nodes.java.RegisterFinalizerNode;
 422 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 423 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 424 import org.graalvm.compiler.nodes.spi.CoreProviders;
 425 import org.graalvm.compiler.nodes.spi.Replacements;
 426 import org.graalvm.compiler.nodes.spi.StampProvider;
 427 import org.graalvm.compiler.nodes.type.StampTool;
 428 import org.graalvm.compiler.nodes.util.GraphUtil;
 429 import org.graalvm.compiler.options.OptionValues;
 430 import org.graalvm.compiler.phases.OptimisticOptimizations;
 431 import org.graalvm.compiler.phases.util.ValueMergeUtil;
 432 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 433 import jdk.internal.vm.compiler.word.LocationIdentity;
 434 
 435 import jdk.vm.ci.code.BailoutException;
 436 import jdk.vm.ci.code.BytecodeFrame;
 437 import jdk.vm.ci.code.CodeUtil;
 438 import jdk.vm.ci.code.site.InfopointReason;
 439 import jdk.vm.ci.meta.Constant;
 440 import jdk.vm.ci.meta.ConstantPool;
 441 import jdk.vm.ci.meta.ConstantReflectionProvider;
 442 import jdk.vm.ci.meta.DeoptimizationAction;
 443 import jdk.vm.ci.meta.DeoptimizationReason;
 444 import jdk.vm.ci.meta.JavaConstant;
 445 import jdk.vm.ci.meta.JavaField;
 446 import jdk.vm.ci.meta.JavaKind;
 447 import jdk.vm.ci.meta.JavaMethod;
 448 import jdk.vm.ci.meta.JavaType;
 449 import jdk.vm.ci.meta.JavaTypeProfile;
 450 import jdk.vm.ci.meta.LineNumberTable;
 451 import jdk.vm.ci.meta.MetaAccessProvider;
 452 import jdk.vm.ci.meta.ProfilingInfo;
 453 import jdk.vm.ci.meta.RawConstant;
 454 import jdk.vm.ci.meta.ResolvedJavaField;
 455 import jdk.vm.ci.meta.ResolvedJavaMethod;
 456 import jdk.vm.ci.meta.ResolvedJavaType;
 457 import jdk.vm.ci.meta.Signature;
 458 import jdk.vm.ci.meta.TriState;
 459 
 460 /**
 461  * The {@code GraphBuilder} class parses the bytecode of a method and builds the IR graph.
 462  */
 463 public class BytecodeParser implements GraphBuilderContext {
 464 
 465     /**
 466      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 467      * to trace the bytecode instructions as they are parsed.
 468      */
 469     public static final int TRACELEVEL_INSTRUCTIONS = 1;
 470 
 471     /**
 472      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 473      * to emit the frame state for each traced bytecode instruction.
 474      */
 475     public static final int TRACELEVEL_STATE = 2;
 476 
 477     /**
 478      * The minimum value to which {@link BytecodeParserOptions#TraceBytecodeParserLevel} must be set
 479      * to emit the block map for each traced method.
 480      */
 481     public static final int TRACELEVEL_BLOCKMAP = 3;
 482 
 483     /**
 484      * Meters the number of actual bytecodes parsed.
 485      */
 486     public static final CounterKey BytecodesParsed = DebugContext.counter(&quot;BytecodesParsed&quot;);
 487 
 488     protected static final CounterKey EXPLICIT_EXCEPTIONS = DebugContext.counter(&quot;ExplicitExceptions&quot;);
 489 
 490     /**
 491      * A scoped object for tasks to be performed after inlining during parsing such as processing
 492      * {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frames states.
 493      */
 494     static class InliningScope implements AutoCloseable {
 495         final ResolvedJavaMethod callee;
 496         FrameState stateBefore;
 497         final Mark mark;
 498         final BytecodeParser parser;
 499         List&lt;ReturnToCallerData&gt; returnDataList;
 500 
 501         /**
 502          * Creates a scope for root parsing an intrinsic.
 503          *
 504          * @param parser the parsing context of the intrinsic
 505          */
 506         InliningScope(BytecodeParser parser) {
 507             this.parser = parser;
 508             assert parser.parent == null;
 509             assert parser.bci() == 0;
 510             mark = null;
 511             callee = null;
 512         }
 513 
 514         /**
 515          * Creates a scope for graph builder inlining.
 516          *
 517          * @param parser the parsing context of the (non-intrinsic) method calling the intrinsic
 518          * @param args the arguments to the call
 519          */
 520         InliningScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {
 521             this.callee = callee;
 522             assert !parser.parsingIntrinsic();
 523             this.parser = parser;
 524             mark = parser.getGraph().getMark();
 525             JavaKind[] argSlotKinds = callee.getSignature().toParameterKinds(!callee.isStatic());
 526             stateBefore = parser.frameState.create(parser.bci(), parser.getNonIntrinsicAncestor(), false, argSlotKinds, args);
 527         }
 528 
 529         @Override
 530         public void close() {
 531             processPlaceholderFrameStates(false);
 532         }
 533 
 534         /**
 535          * Fixes up the {@linkplain BytecodeFrame#isPlaceholderBci(int) placeholder} frame states
 536          * added to the graph while parsing/inlining the intrinsic for which this object exists.
 537          */
 538         protected void processPlaceholderFrameStates(boolean isCompilationRoot) {
 539             StructuredGraph graph = parser.getGraph();
 540             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;Before processPlaceholderFrameStates in %s&quot;, parser.method);
 541             for (Node node : graph.getNewNodes(mark)) {
 542                 if (node instanceof FrameState) {
 543                     FrameState frameState = (FrameState) node;
 544                     if (BytecodeFrame.isPlaceholderBci(frameState.bci)) {
 545                         if (frameState.bci == BytecodeFrame.AFTER_BCI) {
 546                             if (parser.getInvokeReturnType() == null) {
 547                                 // A frame state in a root compiled intrinsic.
 548                                 assert isCompilationRoot;
 549                                 FrameState newFrameState = graph.add(new FrameState(BytecodeFrame.INVALID_FRAMESTATE_BCI));
 550                                 frameState.replaceAndDelete(newFrameState);
 551                             } else {
 552                                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 553                                 FrameStateBuilder frameStateBuilder = parser.frameState;
 554                                 assert !frameState.rethrowException();
 555                                 if (frameState.stackSize() != 0) {
 556                                     ValueNode returnVal = frameState.stackAt(0);
 557                                     if (!ReturnToCallerData.containsReturnValue(returnDataList, returnVal)) {
 558                                         throw new GraalError(&quot;AFTER_BCI frame state within a sub-parse has a non-return value on the stack: %s&quot;, returnVal);
 559                                     }
 560 
 561                                     // Swap the top-of-stack value with the return value
 562                                     ValueNode tos = frameStateBuilder.pop(returnKind);
 563                                     assert tos.getStackKind() == returnVal.getStackKind();
 564                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), parser.getNonIntrinsicAncestor(), false, new JavaKind[]{returnKind},
 565                                                     new ValueNode[]{returnVal});
 566                                     frameState.replaceAndDelete(newFrameState);
 567                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 568                                     frameStateBuilder.push(returnKind, tos);
 569                                 } else if (returnKind != JavaKind.Void) {
 570                                     handleReturnMismatch(graph, frameState);
 571                                 } else {
 572                                     // An intrinsic for a void method.
 573                                     FrameState newFrameState = frameStateBuilder.create(parser.stream.nextBCI(), null);
 574                                     newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 575                                     frameState.replaceAndDelete(newFrameState);
 576                                 }
 577                             }
 578                         } else if (frameState.bci == BytecodeFrame.BEFORE_BCI) {
 579                             if (stateBefore == null) {
 580                                 stateBefore = graph.start().stateAfter();
 581                             }
 582                             if (stateBefore != frameState) {
 583                                 frameState.replaceAndDelete(stateBefore);
 584                             }
 585                         } else if (frameState.bci == BytecodeFrame.AFTER_EXCEPTION_BCI || (frameState.bci == BytecodeFrame.UNWIND_BCI &amp;&amp; !callee.isSynchronized())) {
 586                             // This is a frame state for the entry point to an exception
 587                             // dispatcher in an intrinsic. For example, the invoke denoting
 588                             // a partial intrinsic exit will have an edge to such a
 589                             // dispatcher if the profile for the original invoke being
 590                             // intrinsified indicates an exception was seen. As per JVM
 591                             // bytecode semantics, the interpreter expects a single
 592                             // value on the stack on entry to an exception handler,
 593                             // namely the exception object.
 594                             assert frameState.rethrowException();
 595                             ValueNode exceptionValue = frameState.stackAt(0);
 596                             FrameStateBuilder dispatchState = parser.frameState.copy();
 597                             dispatchState.clearStack();
 598                             dispatchState.push(JavaKind.Object, exceptionValue);
 599                             dispatchState.setRethrowException(true);
 600                             for (Node usage : frameState.usages()) {
 601                                 FrameState newFrameState = dispatchState.create(parser.bci(), (StateSplit) usage);
 602                                 frameState.replaceAndDelete(newFrameState);
 603                                 newFrameState.setNodeSourcePosition(frameState.getNodeSourcePosition());
 604                             }
 605                         } else if (frameState.bci == BytecodeFrame.UNWIND_BCI) {
 606                             if (graph.getGuardsStage().allowsFloatingGuards()) {
 607                                 throw GraalError.shouldNotReachHere(&quot;Cannot handle this UNWIND_BCI&quot;);
 608                             }
 609                             // hope that by construction, there are no fixed guard after this unwind
 610                             // and before an other state split
 611                         } else {
 612                             assert frameState.bci == BytecodeFrame.INVALID_FRAMESTATE_BCI : frameState.bci;
 613                         }
 614                     }
 615                 }
 616             }
 617             graph.getDebug().dump(DebugContext.DETAILED_LEVEL, graph, &quot;After processPlaceholderFrameStates in %s&quot;, parser.method);
 618         }
 619 
 620         @SuppressWarnings(&quot;unused&quot;)
 621         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {
 622             throw GraalError.shouldNotReachHere(&quot;Unexpected return kind mismatch in &quot; + parser.method + &quot; at FS &quot; + fs);
 623         }
 624     }
 625 
 626     static class IntrinsicScope extends InliningScope {
 627         ArrayList&lt;StateSplit&gt; invalidStateUsers;
 628 
 629         IntrinsicScope(BytecodeParser parser) {
 630             super(parser);
 631         }
 632 
 633         IntrinsicScope(BytecodeParser parser, ResolvedJavaMethod callee, ValueNode[] args) {
 634             super(parser, callee, args);
 635         }
 636 
 637         @SuppressWarnings(&quot;unlikely-arg-type&quot;)
 638         @Override
 639         public void close() {
 640             IntrinsicContext intrinsic = parser.intrinsicContext;
 641             boolean isRootCompilation;
 642             if (intrinsic != null) {
 643                 if (intrinsic.isPostParseInlined()) {
 644                     return;
 645                 }
 646                 isRootCompilation = intrinsic.isCompilationRoot();
 647             } else {
 648                 isRootCompilation = false;
 649             }
 650             processPlaceholderFrameStates(isRootCompilation);
 651             if (invalidStateUsers != null) {
 652                 JavaKind returnKind = parser.getInvokeReturnType().getJavaKind();
 653                 ValueNode returnValue = parser.frameState.pop(returnKind);
 654                 if (invalidStateUsers.size() == 1 &amp;&amp; invalidStateUsers.get(0) == parser.lastInstr) {
 655                     updateSplitFrameState(invalidStateUsers.get(0), returnKind, returnValue);
 656                 } else if (parser.lastInstr instanceof MergeNode) {
 657                     ValuePhiNode returnValues = null;
 658                     MergeNode merge = (MergeNode) parser.lastInstr;
 659 
 660                     if (returnValue instanceof ValuePhiNode &amp;&amp; ((ValuePhiNode) returnValue).merge() == parser.lastInstr) {
 661                         returnValues = (ValuePhiNode) returnValue;
 662                     }
 663                     if (invalidStateUsers.remove(merge)) {
 664                         updateSplitFrameState(merge, returnKind, returnValue);
 665                     }
 666                     for (EndNode pred : merge.cfgPredecessors()) {
 667                         Node lastPred = pred.predecessor();
 668                         if (invalidStateUsers.remove(lastPred)) {
 669                             ValueNode predReturnValue = returnValue;
 670                             if (returnValues != null) {
 671                                 int index = merge.phiPredecessorIndex(pred);
 672                                 predReturnValue = ((ValuePhiNode) returnValue).valueAt(index);
 673                             }
 674                             updateSplitFrameState((StateSplit) lastPred, returnKind, predReturnValue);
 675                         }
 676                     }
 677                     if (invalidStateUsers.size() != 0) {
 678                         throw new GraalError(&quot;unexpected StateSplit above merge %s&quot;, invalidStateUsers);
 679                     }
 680                 } else {
 681                     throw new GraalError(&quot;unexpected node between return StateSplit and last instruction %s&quot;, parser.lastInstr);
 682                 }
 683                 // Restore the original return value
 684                 parser.frameState.push(returnKind, returnValue);
 685             }
 686             boolean inlinedIntrinsic = parser.getInvokeReturnType() != null;
 687             if (inlinedIntrinsic) {
 688                 for (Node n : parser.graph.getNewNodes(mark)) {
 689                     if (n instanceof FrameState) {
 690                         GraalError.guarantee(((FrameState) n).bci != BytecodeFrame.INVALID_FRAMESTATE_BCI,
 691                                         &quot;Inlined call to intrinsic (callee %s) produced invalid framestate %s. &quot; +
 692                                                         &quot;Such framestates must never be used as deoptimizing targets, thus they cannot be part of a high-tier graph, &quot; +
 693                                                         &quot;and must only be used after framestate assignment. A common error is invalid usage of foreign call nodes in method &quot; +
 694                                                         &quot;substitutions, which can be avoided by ensuring such calls are either replaced with nodes that are snippet &quot; +
 695                                                         &quot;lowered after framestate assignment (see FastNotifyNode.java for example) or by ensuring all foreign use the state after of the &quot; +
 696                                                         &quot;original call instruction.&quot;,
 697                                         callee, n);
 698                     }
 699                 }
 700             } else {
 701 
 702                 /*
 703                  * Special case root compiled method substitutions
 704                  *
 705                  * Root compiled intrinsics with self recursive calls (partial intrinsic exit) must
 706                  * never produce more than one state except the start framestate since we do not
 707                  * compile calls to the original method (or inline them) but deopt
 708                  *
 709                  * See ByteCodeParser::inline and search for compilationRoot
 710                  */
 711                 assert intrinsic == null || intrinsic.isIntrinsicEncoding() || verifyIntrinsicRootCompileEffects();
 712             }
 713         }
 714 
 715         private boolean verifyIntrinsicRootCompileEffects() {
 716             int invalidBCIsInRootCompiledIntrinsic = 0;
 717             for (Node n : parser.graph.getNewNodes(mark)) {
 718                 if (n instanceof FrameState) {
 719                     if (((FrameState) n).bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 720                         invalidBCIsInRootCompiledIntrinsic++;
 721                     }
 722                 }
 723             }
 724             if (invalidBCIsInRootCompiledIntrinsic &gt; 1) {
 725                 int invalidBCIsToFind = invalidBCIsInRootCompiledIntrinsic;
 726                 List&lt;ReturnNode&gt; returns = parser.getGraph().getNodes(ReturnNode.TYPE).snapshot();
 727                 if (returns.size() &gt; 1) {
 728                     outer: for (ReturnNode ret : returns) {
 729                         for (FixedNode f : GraphUtil.predecessorIterable(ret)) {
 730                             if (f instanceof StateSplit) {
 731                                 StateSplit split = (StateSplit) f;
 732                                 if (split.hasSideEffect()) {
 733                                     assert ((StateSplit) f).stateAfter() != null;
 734                                     if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 735                                         invalidBCIsToFind--;
 736                                         continue outer;
 737                                     }
 738                                 }
 739                             }
 740                         }
 741                     }
 742                     GraalError.guarantee(invalidBCIsToFind == 0, &quot;Root compiled intrinsic with invalid states has more than one return. &quot; +
 743                                     &quot;This is allowed, however one path down a sink has more than one state, this is prohibited. &quot; +
 744                                     &quot;Intrinsic %s&quot;, parser.method);
 745                     return true;
 746                 }
 747                 ReturnNode ret = returns.get(0);
 748                 MergeNode merge = null;
 749                 int mergeCount = parser.graph.getNodes(MergeNode.TYPE).count();
 750                 if (mergeCount != 1) {
 751                     throw new GraalError(&quot;Root compiled intrinsic with invalid states %s:Must have exactly one merge node. %d found&quot;, parser.method, mergeCount);
 752                 }
 753                 if (ret.predecessor() instanceof MergeNode) {
 754                     merge = (MergeNode) ret.predecessor();
 755                 }
 756                 if (merge == null) {
 757                     throw new GraalError(&quot;Root compiled intrinsic with invalid state: Unexpected node between return and merge.&quot;);
 758                 }
 759                 //@formatter:off
 760                 GraalError.guarantee(invalidBCIsInRootCompiledIntrinsic &lt;= merge.phiPredecessorCount() + 1 /* merge itself */,
 761                                 &quot;Root compiled intrinsic with invalid states %s must at maximum produce (0,1 or if the last instruction is a merge |merge.predCount|&quot; +
 762                                                 &quot; invalid BCI state, however %d where found.&quot;,
 763                                 parser.method, invalidBCIsInRootCompiledIntrinsic);
 764                 //@formatter:on
 765                 if (merge.stateAfter() != null &amp;&amp; merge.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 766                     invalidBCIsToFind--;
 767                 }
 768                 for (EndNode pred : merge.cfgPredecessors()) {
 769                     Node lastPred = pred.predecessor();
 770                     for (FixedNode f : GraphUtil.predecessorIterable((FixedNode) lastPred)) {
 771                         if (f instanceof StateSplit) {
 772                             StateSplit split = (StateSplit) f;
 773                             if (split.hasSideEffect()) {
 774                                 assert ((StateSplit) f).stateAfter() != null;
 775                                 if (split.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
 776                                     invalidBCIsToFind--;
 777                                 }
 778                             }
 779                         }
 780                     }
 781                 }
 782                 if (invalidBCIsToFind != 0) {
 783                     throw new GraalError(
 784                                     &quot;Invalid BCI state missmatch: This root compiled method substitution %s &quot; +
 785                                                     &quot;uses invalid side-effecting nodes resulting in invalid deoptimization information. &quot; +
 786                                                     &quot;Method substitutions must never have more than one state (the after state) for deoptimization.&quot; +
 787                                                     &quot; Multiple states are only allowed if they are dominated by a control-flow split, there is only&quot; +
 788                                                     &quot; a single effect per branch and a post dominating merge with the same invalid_bci state &quot; +
 789                                                     &quot;(that must only be different in its return value).&quot;,
 790                                     parser.method);
 791                 }
 792             }
 793             return true;
 794         }
 795 
 796         private void updateSplitFrameState(StateSplit split, JavaKind returnKind, ValueNode returnValue) {
 797             parser.frameState.push(returnKind, returnValue);
 798             FrameState oldState = split.stateAfter();
 799             split.setStateAfter(parser.createFrameState(parser.stream.nextBCI(), split));
 800             parser.frameState.pop(returnKind);
 801             if (oldState.hasNoUsages()) {
 802                 oldState.safeDelete();
 803             }
 804         }
 805 
 806         @Override
 807         protected void handleReturnMismatch(StructuredGraph g, FrameState fs) {
 808             if (invalidStateUsers == null) {
 809                 invalidStateUsers = new ArrayList&lt;&gt;();
 810             }
 811             for (Node use : fs.usages()) {
 812                 if (!(use instanceof StateSplit)) {
 813                     throw new GraalError(&quot;Expected StateSplit for return mismatch&quot;);
 814                 }
 815                 invalidStateUsers.add((StateSplit) use);
 816             }
 817         }
 818     }
 819 
 820     private static class Target {
 821         final FixedNode entry;
 822         final FixedNode originalEntry;
 823         final FrameStateBuilder state;
 824 
 825         Target(FixedNode entry, FrameStateBuilder state) {
 826             this.entry = entry;
 827             this.state = state;
 828             this.originalEntry = null;
 829         }
 830 
 831         Target(FixedNode entry, FrameStateBuilder state, FixedNode originalEntry) {
 832             this.entry = entry;
 833             this.state = state;
 834             this.originalEntry = originalEntry;
 835         }
 836     }
 837 
 838     @SuppressWarnings(&quot;serial&quot;)
 839     public static class BytecodeParserError extends GraalError {
 840 
 841         public BytecodeParserError(Throwable cause) {
 842             super(cause);
 843         }
 844 
 845         public BytecodeParserError(String msg, Object... args) {
 846             super(msg, args);
 847         }
 848     }
 849 
 850     protected static class ReturnToCallerData {
 851         protected final ValueNode returnValue;
 852         protected final FixedWithNextNode beforeReturnNode;
 853 
 854         protected ReturnToCallerData(ValueNode returnValue, FixedWithNextNode beforeReturnNode) {
 855             this.returnValue = returnValue;
 856             this.beforeReturnNode = beforeReturnNode;
 857         }
 858 
 859         static boolean containsReturnValue(List&lt;ReturnToCallerData&gt; list, ValueNode value) {
 860             for (ReturnToCallerData e : list) {
 861                 if (e.returnValue == value) {
 862                     return true;
 863                 }
 864             }
 865             return false;
 866         }
 867     }
 868 
 869     private final GraphBuilderPhase.Instance graphBuilderInstance;
 870     protected final StructuredGraph graph;
 871     protected final OptionValues options;
 872     protected final DebugContext debug;
 873 
 874     private BciBlockMapping blockMap;
 875     private LocalLiveness liveness;
 876     protected final int entryBCI;
 877     private final BytecodeParser parent;
 878 
 879     private LineNumberTable lnt;
 880     private int previousLineNumber;
 881     private int currentLineNumber;
 882 
 883     private ValueNode methodSynchronizedObject;
 884 
 885     private List&lt;ReturnToCallerData&gt; returnDataList;
 886     private ValueNode unwindValue;
 887     private FixedWithNextNode beforeUnwindNode;
 888 
 889     protected FixedWithNextNode lastInstr;                 // the last instruction added
 890     private boolean controlFlowSplit;
 891     private final InvocationPluginReceiver invocationPluginReceiver = new InvocationPluginReceiver(this);
 892 
 893     private FixedWithNextNode[] firstInstructionArray;
 894     private FrameStateBuilder[] entryStateArray;
 895 
 896     private boolean finalBarrierRequired;
 897     private ValueNode originalReceiver;
 898     private final boolean eagerInitializing;
 899     private final boolean uninitializedIsError;
 900     private final int traceLevel;
 901 
 902     protected BytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method,
 903                     int entryBCI, IntrinsicContext intrinsicContext) {
 904         this.bytecodeProvider = intrinsicContext == null ? new ResolvedJavaMethodBytecodeProvider() : intrinsicContext.getBytecodeProvider();
 905         this.code = bytecodeProvider.getBytecode(method);
 906         this.method = code.getMethod();
 907         this.graphBuilderInstance = graphBuilderInstance;
 908         this.graph = graph;
 909         this.options = graph.getOptions();
 910         this.debug = graph.getDebug();
 911         this.graphBuilderConfig = graphBuilderInstance.graphBuilderConfig;
 912         this.optimisticOpts = graphBuilderInstance.optimisticOpts;
 913         this.providers = graphBuilderInstance.providers;
 914         this.stream = new BytecodeStream(code.getCode());
 915         this.profilingInfo = graph.useProfilingInfo() ? code.getProfilingInfo() : null;
 916         this.constantPool = code.getConstantPool();
 917         this.intrinsicContext = intrinsicContext;
 918         this.entryBCI = entryBCI;
 919         this.parent = parent;
 920 
 921         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
 922         if (classInitializationPlugin != null &amp;&amp; graphBuilderConfig.eagerResolving() &amp;&amp; classInitializationPlugin.supportsLazyInitialization(constantPool)) {
 923             eagerInitializing = false;
 924             uninitializedIsError = false;
 925         } else {
 926             eagerInitializing = graphBuilderConfig.eagerResolving();
 927             uninitializedIsError = graphBuilderConfig.unresolvedIsError();
 928         }
 929 
 930         assert code.getCode() != null : &quot;method must contain bytecodes: &quot; + method;
 931 
 932         if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
 933             lnt = code.getLineNumberTable();
 934             previousLineNumber = -1;
 935         }
 936 
 937         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || graph.trackNodeSourcePosition();
 938         if (graphBuilderConfig.trackNodeSourcePosition() || (parent != null &amp;&amp; parent.graph.trackNodeSourcePosition())) {
 939             graph.setTrackNodeSourcePosition();
 940         }
 941 
 942         int level = TraceBytecodeParserLevel.getValue(options);
 943         this.traceLevel = level != 0 ? refineTraceLevel(level) : 0;
 944     }
 945 
 946     private int refineTraceLevel(int level) {
 947         ResolvedJavaMethod tmethod = graph.method();
 948         if (tmethod == null) {
 949             tmethod = method;
 950         }
 951         String filterValue = DebugOptions.MethodFilter.getValue(options);
 952         if (filterValue != null) {
 953             MethodFilter[] filters = MethodFilter.parse(filterValue);
 954             if (!MethodFilter.matches(filters, tmethod)) {
 955                 return 0;
 956             }
 957         }
 958         return level;
 959     }
 960 
 961     protected GraphBuilderPhase.Instance getGraphBuilderInstance() {
 962         return graphBuilderInstance;
 963     }
 964 
 965     public ValueNode getUnwindValue() {
 966         return unwindValue;
 967     }
 968 
 969     public FixedWithNextNode getBeforeUnwindNode() {
 970         return this.beforeUnwindNode;
 971     }
 972 
 973     @SuppressWarnings(&quot;try&quot;)
 974     protected void buildRootMethod() {
 975         FrameStateBuilder startFrameState = new FrameStateBuilder(this, code, graph, graphBuilderConfig.retainLocalVariables());
 976         startFrameState.initializeForMethodStart(graph.getAssumptions(), graphBuilderConfig.eagerResolving() || intrinsicContext != null, graphBuilderConfig.getPlugins());
 977 
 978         try (IntrinsicScope s = intrinsicContext != null ? new IntrinsicScope(this) : null) {
 979             build(graph.start(), startFrameState);
 980         }
 981 
 982         cleanupFinalGraph();
 983         ComputeLoopFrequenciesClosure.compute(graph);
 984     }
 985 
 986     @SuppressWarnings(&quot;try&quot;)
 987     protected void build(FixedWithNextNode startInstruction, FrameStateBuilder startFrameState) {
 988         if (PrintProfilingInformation.getValue(options) &amp;&amp; profilingInfo != null) {
 989             TTY.println(&quot;Profiling info for &quot; + method.format(&quot;%H.%n(%p)&quot;));
 990             TTY.println(Util.indent(profilingInfo.toString(method, CodeUtil.NEW_LINE), &quot;  &quot;));
 991         }
 992 
 993         try (Indent indent = debug.logAndIndent(&quot;build graph for %s&quot;, method)) {
 994             if (bytecodeProvider.shouldRecordMethodDependencies()) {
 995                 assert getParent() != null || method.equals(graph.method());
 996                 // Record method dependency in the graph
 997                 graph.recordMethod(method);
 998             }
 999 
1000             // compute the block map, setup exception handlers and get the entrypoint(s)
1001             BciBlockMapping newMapping = BciBlockMapping.create(stream, code, options, graph.getDebug());
1002             this.blockMap = newMapping;
1003             this.firstInstructionArray = new FixedWithNextNode[blockMap.getBlockCount()];
1004             this.entryStateArray = new FrameStateBuilder[blockMap.getBlockCount()];
1005             if (!method.isStatic()) {
1006                 originalReceiver = startFrameState.loadLocal(0, JavaKind.Object);
1007             }
1008 
1009             /*
1010              * Configure the assertion checking behavior of the FrameStateBuilder. This needs to be
1011              * done only when assertions are enabled, so it is wrapped in an assertion itself.
1012              */
1013             assert computeKindVerification(startFrameState);
1014 
1015             try (DebugContext.Scope s = debug.scope(&quot;LivenessAnalysis&quot;)) {
1016                 int maxLocals = method.getMaxLocals();
1017                 liveness = LocalLiveness.compute(debug, stream, blockMap.getBlocks(), maxLocals, blockMap.getLoopCount());
1018             } catch (Throwable e) {
1019                 throw debug.handle(e);
1020             }
1021 
1022             lastInstr = startInstruction;
1023             this.setCurrentFrameState(startFrameState);
1024             stream.setBCI(0);
1025 
1026             BciBlock startBlock = blockMap.getStartBlock();
1027             if (this.parent == null) {
1028                 StartNode startNode = graph.start();
1029                 if (method.isSynchronized()) {
1030                     assert !parsingIntrinsic();
1031                     startNode.setStateAfter(createFrameState(BytecodeFrame.BEFORE_BCI, startNode));
1032                 } else {
1033                     if (!parsingIntrinsic()) {
1034                         if (graph.method() != null &amp;&amp; graph.method().isJavaLangObjectInit()) {
1035                             /*
1036                              * Don&#39;t clear the receiver when Object.&lt;init&gt; is the compilation root.
1037                              * The receiver is needed as input to RegisterFinalizerNode.
1038                              */
1039                         } else {
1040                             frameState.clearNonLiveLocals(startBlock, liveness, true);
1041                         }
1042                         assert bci() == 0;
1043                         startNode.setStateAfter(createFrameState(bci(), startNode));
1044                     } else {
1045                         if (startNode.stateAfter() == null) {
1046                             FrameState stateAfterStart = createStateAfterStartOfReplacementGraph();
1047                             startNode.setStateAfter(stateAfterStart);
1048                         }
1049                     }
1050                 }
1051             }
1052 
1053             try (DebugCloseable context = openNodeContext()) {
1054                 if (method.isSynchronized()) {
1055                     finishPrepare(lastInstr, BytecodeFrame.BEFORE_BCI, frameState);
1056 
1057                     // add a monitor enter to the start block
1058                     methodSynchronizedObject = synchronizedObject(frameState, method);
1059                     frameState.clearNonLiveLocals(startBlock, liveness, true);
1060                     assert bci() == 0;
1061                     genMonitorEnter(methodSynchronizedObject, bci());
1062                 }
1063 
1064                 ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1065                 if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1066                     FrameState stateBefore = createCurrentFrameState();
1067                     profilingPlugin.profileInvoke(this, method, stateBefore);
1068                 }
1069 
1070                 finishPrepare(lastInstr, 0, frameState);
1071 
1072                 genInfoPointNode(InfopointReason.METHOD_START, null);
1073             }
1074 
1075             currentBlock = blockMap.getStartBlock();
1076             setEntryState(startBlock, frameState);
1077             if (startBlock.isLoopHeader()) {
1078                 appendGoto(startBlock);
1079             } else {
1080                 setFirstInstruction(startBlock, lastInstr);
1081             }
1082 
1083             BciBlock[] blocks = blockMap.getBlocks();
1084             for (BciBlock block : blocks) {
1085                 processBlock(block);
1086             }
1087         }
1088     }
1089 
1090     private boolean computeKindVerification(FrameStateBuilder startFrameState) {
1091         if (blockMap.hasJsrBytecodes) {
1092             /*
1093              * The JSR return address is an int value, but stored using the astore bytecode. Instead
1094              * of weakening the kind assertion checking for all methods, we disable it completely
1095              * for methods that contain a JSR bytecode.
1096              */
1097             startFrameState.disableKindVerification();
1098         }
1099 
1100         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
1101             if (plugin.canChangeStackKind(this)) {
1102                 /*
1103                  * We have a plugin that can change the kind of values, so no kind assertion
1104                  * checking is possible.
1105                  */
1106                 startFrameState.disableKindVerification();
1107             }
1108         }
1109         return true;
1110     }
1111 
1112     /**
1113      * Hook for subclasses to modify synthetic code (start nodes and unwind nodes).
1114      *
1115      * @param instruction the current last instruction
1116      * @param bci the current bci
1117      * @param state The current frame state.
1118      */
1119     protected void finishPrepare(FixedWithNextNode instruction, int bci, FrameStateBuilder state) {
1120     }
1121 
1122     protected void cleanupFinalGraph() {
1123         GraphUtil.normalizeLoops(graph);
1124 
1125         // Remove dead parameters.
1126         for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {
1127             if (param.hasNoUsages()) {
1128                 assert param.inputs().isEmpty();
1129                 param.safeDelete();
1130             }
1131         }
1132 
1133         // Remove redundant begin nodes.
1134         for (BeginNode beginNode : graph.getNodes(BeginNode.TYPE)) {
1135             Node predecessor = beginNode.predecessor();
1136             if (predecessor instanceof ControlSplitNode) {
1137                 // The begin node is necessary.
1138             } else if (!beginNode.hasUsages()) {
1139                 GraphUtil.unlinkFixedNode(beginNode);
1140                 beginNode.safeDelete();
1141             }
1142         }
1143         if (graph.isOSR() &amp;&amp; getParent() == null &amp;&amp; graph.getNodes().filter(EntryMarkerNode.class).isEmpty()) {
1144             // This should generally be a transient condition because of inconsistent profile
1145             // information.
1146             throw new RetryableBailoutException(&quot;OSR entry point wasn&#39;t parsed&quot;);
1147         }
1148     }
1149 
1150     /**
1151      * Creates the frame state after the start node of a graph for an {@link IntrinsicContext
1152      * intrinsic} that is the parse root (either for root compiling or for post-parse inlining).
1153      */
1154     private FrameState createStateAfterStartOfReplacementGraph() {
1155         assert parent == null;
1156         assert frameState.getMethod().equals(intrinsicContext.getIntrinsicMethod());
1157         assert bci() == 0;
1158         assert frameState.stackSize() == 0;
1159         FrameState stateAfterStart;
1160         if (intrinsicContext.isPostParseInlined()) {
1161             stateAfterStart = graph.add(new FrameState(BytecodeFrame.BEFORE_BCI));
1162         } else {
1163             ResolvedJavaMethod original = intrinsicContext.getOriginalMethod();
1164             ValueNode[] locals;
1165             if (original.getMaxLocals() == frameState.localsSize() || original.isNative()) {
1166                 locals = new ValueNode[original.getMaxLocals()];
1167                 for (int i = 0; i &lt; locals.length; i++) {
1168                     ValueNode node = frameState.locals[i];
1169                     if (node == FrameState.TWO_SLOT_MARKER) {
1170                         node = null;
1171                     }
1172                     locals[i] = node;
1173                 }
1174             } else {
1175                 locals = new ValueNode[original.getMaxLocals()];
1176                 int parameterCount = original.getSignature().getParameterCount(!original.isStatic());
1177                 for (int i = 0; i &lt; parameterCount; i++) {
1178                     ValueNode param = frameState.locals[i];
1179                     if (param == FrameState.TWO_SLOT_MARKER) {
1180                         param = null;
1181                     }
1182                     locals[i] = param;
1183                     assert param == null || param instanceof ParameterNode || param.isConstant();
1184                 }
1185             }
1186             ValueNode[] stack = {};
1187             int stackSize = 0;
1188             ValueNode[] locks = {};
1189             List&lt;MonitorIdNode&gt; monitorIds = Collections.emptyList();
1190             stateAfterStart = graph.add(new FrameState(null, new ResolvedJavaMethodBytecode(original), 0, locals, stack, stackSize, locks, monitorIds, false, false));
1191         }
1192         return stateAfterStart;
1193     }
1194 
1195     /**
1196      * @param type the unresolved type of the constant
1197      */
1198     protected void handleUnresolvedLoadConstant(JavaType type) {
1199         assert !graphBuilderConfig.unresolvedIsError();
1200         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1201         /*
1202          * Track source position for deopt nodes even if
1203          * GraphBuilderConfiguration.trackNodeSourcePosition is not set.
1204          */
1205         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1206     }
1207 
1208     /**
1209      * @param type the unresolved type of the type check
1210      * @param object the object value whose type is being checked against {@code type}
1211      */
1212     protected void handleUnresolvedCheckCast(JavaType type, ValueNode object) {
1213         assert !graphBuilderConfig.unresolvedIsError();
1214         append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(object)), Unresolved, InvalidateRecompile));
1215         frameState.push(JavaKind.Object, appendConstant(JavaConstant.NULL_POINTER));
1216     }
1217 
1218     /**
1219      * @param type the unresolved type of the type check
1220      * @param object the object value whose type is being checked against {@code type}
1221      */
1222     protected void handleUnresolvedInstanceOf(JavaType type, ValueNode object) {
1223         assert !graphBuilderConfig.unresolvedIsError();
1224         AbstractBeginNode successor = graph.add(new BeginNode());
1225         DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1226         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1227         append(new IfNode(graph.addOrUniqueWithInputs(IsNullNode.create(object)), successor, deopt, 1));
1228         lastInstr = successor;
1229         frameState.push(JavaKind.Int, appendConstant(JavaConstant.INT_0));
1230     }
1231 
1232     /**
1233      * @param type the type being instantiated
1234      */
1235     protected void handleUnresolvedNewInstance(JavaType type) {
1236         assert !graphBuilderConfig.unresolvedIsError();
1237         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1238         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1239     }
1240 
1241     /**
1242      * @param type the type being instantiated
1243      */
1244     protected void handleIllegalNewInstance(JavaType type) {
1245         assert !graphBuilderConfig.unresolvedIsError();
1246         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1247         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1248     }
1249 
1250     /**
1251      * @param type the type of the array being instantiated
1252      * @param length the length of the array
1253      */
1254     protected void handleUnresolvedNewObjectArray(JavaType type, ValueNode length) {
1255         assert !graphBuilderConfig.unresolvedIsError();
1256         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1257         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1258     }
1259 
1260     /**
1261      * @param type the type being instantiated
1262      * @param dims the dimensions for the multi-array
1263      */
1264     protected void handleUnresolvedNewMultiArray(JavaType type, ValueNode[] dims) {
1265         assert !graphBuilderConfig.unresolvedIsError();
1266         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1267         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1268     }
1269 
1270     /**
1271      * @param field the unresolved field
1272      * @param receiver the object containing the field or {@code null} if {@code field} is static
1273      */
1274     protected void handleUnresolvedLoadField(JavaField field, ValueNode receiver) {
1275         assert !graphBuilderConfig.unresolvedIsError();
1276         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1277         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1278     }
1279 
1280     /**
1281      * @param field the unresolved field
1282      * @param value the value being stored to the field
1283      * @param receiver the object containing the field or {@code null} if {@code field} is static
1284      */
1285     protected void handleUnresolvedStoreField(JavaField field, ValueNode value, ValueNode receiver) {
1286         assert !graphBuilderConfig.unresolvedIsError();
1287         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1288         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1289     }
1290 
1291     /**
1292      * @param type
1293      */
1294     protected void handleUnresolvedExceptionType(JavaType type) {
1295         assert !graphBuilderConfig.unresolvedIsError();
1296         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1297         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1298     }
1299 
1300     /**
1301      * @param javaMethod
1302      * @param invokeKind
1303      */
1304     protected void handleUnresolvedInvoke(JavaMethod javaMethod, InvokeKind invokeKind) {
1305         assert !graphBuilderConfig.unresolvedIsError();
1306         DeoptimizeNode deopt = append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1307         deopt.updateNodeSourcePosition(() -&gt; createBytecodePosition());
1308     }
1309 
1310     /**
1311      * @return the entry point to exception dispatch
1312      */
1313     private AbstractBeginNode handleException(ValueNode exceptionObject, int bci, boolean deoptimizeOnly) {
1314         FixedWithNextNode currentLastInstr = lastInstr;
1315         assert bci == BytecodeFrame.BEFORE_BCI || bci == bci() : &quot;invalid bci&quot;;
1316         debug.log(&quot;Creating exception dispatch edges at %d, exception object=%s, exception seen=%s&quot;, bci, exceptionObject, (profilingInfo == null ? &quot;&quot; : profilingInfo.getExceptionSeen(bci)));
1317 
1318         FrameStateBuilder dispatchState = frameState.copy();
1319         dispatchState.clearStack();
1320 
1321         AbstractBeginNode dispatchBegin;
1322         if (exceptionObject == null) {
1323             ExceptionObjectNode newExceptionObject = graph.add(new ExceptionObjectNode(getMetaAccess()));
1324             dispatchState.push(JavaKind.Object, newExceptionObject);
1325             dispatchState.setRethrowException(true);
1326             newExceptionObject.setStateAfter(dispatchState.create(bci, newExceptionObject));
1327             dispatchBegin = newExceptionObject;
1328         } else {
1329             dispatchBegin = graph.add(new BeginNode());
1330             dispatchState.push(JavaKind.Object, exceptionObject);
1331             dispatchState.setRethrowException(true);
1332         }
1333         this.controlFlowSplit = true;
1334         FixedWithNextNode afterExceptionLoaded = finishInstruction(dispatchBegin, dispatchState);
1335 
1336         if (deoptimizeOnly) {
1337             DeoptimizeNode deoptimizeNode = graph.add(new DeoptimizeNode(DeoptimizationAction.None, DeoptimizationReason.TransferToInterpreter));
1338             afterExceptionLoaded.setNext(BeginNode.begin(deoptimizeNode));
1339         } else {
1340             createHandleExceptionTarget(afterExceptionLoaded, bci, dispatchState);
1341         }
1342         assert currentLastInstr == lastInstr;
1343         return dispatchBegin;
1344     }
1345 
1346     protected void createHandleExceptionTarget(FixedWithNextNode afterExceptionLoaded, int bci, FrameStateBuilder dispatchState) {
1347         FixedWithNextNode afterInstrumentation = afterExceptionLoaded;
1348         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
1349             afterInstrumentation = plugin.instrumentExceptionDispatch(graph, afterInstrumentation, () -&gt; dispatchState.create(bci, getNonIntrinsicAncestor(), false, null, null));
1350             assert afterInstrumentation.next() == null : &quot;exception dispatch instrumentation will be linked to dispatch block&quot;;
1351         }
1352 
1353         BciBlock dispatchBlock = currentBlock.exceptionDispatchBlock();
1354         /*
1355          * The exception dispatch block is always for the last bytecode of a block, so if we are not
1356          * at the endBci yet, there is no exception handler for this bci and we can unwind
1357          * immediately.
1358          */
1359         if (bci != currentBlock.endBci || dispatchBlock == null) {
1360             dispatchBlock = blockMap.getUnwindBlock();
1361         }
1362 
1363         FixedNode target = createTarget(dispatchBlock, dispatchState);
1364         afterInstrumentation.setNext(target);
1365     }
1366 
1367     protected ValueNode genLoadIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, JavaKind kind) {
1368         return LoadIndexedNode.create(graph.getAssumptions(), array, index, boundsCheck, kind, getMetaAccess(), getConstantReflection());
1369     }
1370 
1371     protected void genStoreIndexed(ValueNode array, ValueNode index, GuardingNode boundsCheck, GuardingNode storeCheck, JavaKind kind, ValueNode value) {
1372         add(new StoreIndexedNode(array, index, boundsCheck, storeCheck, kind, value));
1373     }
1374 
1375     protected ValueNode genIntegerAdd(ValueNode x, ValueNode y) {
1376         return AddNode.create(x, y, NodeView.DEFAULT);
1377     }
1378 
1379     protected ValueNode genIntegerSub(ValueNode x, ValueNode y) {
1380         return SubNode.create(x, y, NodeView.DEFAULT);
1381     }
1382 
1383     protected ValueNode genIntegerMul(ValueNode x, ValueNode y) {
1384         return MulNode.create(x, y, NodeView.DEFAULT);
1385     }
1386 
1387     protected ValueNode genFloatAdd(ValueNode x, ValueNode y) {
1388         return AddNode.create(x, y, NodeView.DEFAULT);
1389     }
1390 
1391     protected ValueNode genFloatSub(ValueNode x, ValueNode y) {
1392         return SubNode.create(x, y, NodeView.DEFAULT);
1393     }
1394 
1395     protected ValueNode genFloatMul(ValueNode x, ValueNode y) {
1396         return MulNode.create(x, y, NodeView.DEFAULT);
1397     }
1398 
1399     protected ValueNode genFloatDiv(ValueNode x, ValueNode y) {
1400         return FloatDivNode.create(x, y, NodeView.DEFAULT);
1401     }
1402 
1403     protected ValueNode genFloatRem(ValueNode x, ValueNode y) {
1404         return RemNode.create(x, y, NodeView.DEFAULT);
1405     }
1406 
1407     protected ValueNode genIntegerDiv(ValueNode x, ValueNode y, GuardingNode zeroCheck) {
1408         return SignedDivNode.create(x, y, zeroCheck, NodeView.DEFAULT);
1409     }
1410 
1411     protected ValueNode genIntegerRem(ValueNode x, ValueNode y, GuardingNode zeroCheck) {
1412         return SignedRemNode.create(x, y, zeroCheck, NodeView.DEFAULT);
1413     }
1414 
1415     protected ValueNode genNegateOp(ValueNode x) {
1416         return NegateNode.create(x, NodeView.DEFAULT);
1417     }
1418 
1419     protected ValueNode genLeftShift(ValueNode x, ValueNode y) {
1420         return LeftShiftNode.create(x, y, NodeView.DEFAULT);
1421     }
1422 
1423     protected ValueNode genRightShift(ValueNode x, ValueNode y) {
1424         return RightShiftNode.create(x, y, NodeView.DEFAULT);
1425     }
1426 
1427     protected ValueNode genUnsignedRightShift(ValueNode x, ValueNode y) {
1428         return UnsignedRightShiftNode.create(x, y, NodeView.DEFAULT);
1429     }
1430 
1431     protected ValueNode genAnd(ValueNode x, ValueNode y) {
1432         return AndNode.create(x, y, NodeView.DEFAULT);
1433     }
1434 
1435     protected ValueNode genOr(ValueNode x, ValueNode y) {
1436         return OrNode.create(x, y, NodeView.DEFAULT);
1437     }
1438 
1439     protected ValueNode genXor(ValueNode x, ValueNode y) {
1440         return XorNode.create(x, y, NodeView.DEFAULT);
1441     }
1442 
1443     protected ValueNode genNormalizeCompare(ValueNode x, ValueNode y, boolean isUnorderedLess) {
1444         return FloatNormalizeCompareNode.create(x, y, isUnorderedLess, JavaKind.Int, getConstantReflection());
1445     }
1446 
1447     protected ValueNode genIntegerNormalizeCompare(ValueNode x, ValueNode y) {
1448         return IntegerNormalizeCompareNode.create(x, y, false, JavaKind.Int, getConstantReflection());
1449     }
1450 
1451     protected ValueNode genFloatConvert(FloatConvert op, ValueNode input) {
1452         return FloatConvertNode.create(op, input, NodeView.DEFAULT);
1453     }
1454 
1455     protected ValueNode genNarrow(ValueNode input, int bitCount) {
1456         return NarrowNode.create(input, bitCount, NodeView.DEFAULT);
1457     }
1458 
1459     protected ValueNode genSignExtend(ValueNode input, int bitCount) {
1460         return SignExtendNode.create(input, bitCount, NodeView.DEFAULT);
1461     }
1462 
1463     protected ValueNode genZeroExtend(ValueNode input, int bitCount) {
1464         return ZeroExtendNode.create(input, bitCount, NodeView.DEFAULT);
1465     }
1466 
1467     protected void genGoto() {
1468         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
1469         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
1470             FrameState stateBefore = createCurrentFrameState();
1471             int targetBci = currentBlock.getSuccessor(0).startBci;
1472             profilingPlugin.profileGoto(this, method, bci(), targetBci, stateBefore);
1473         }
1474         appendGoto(currentBlock.getSuccessor(0));
1475         assert currentBlock.numNormalSuccessors() == 1;
1476     }
1477 
1478     protected LogicNode genObjectEquals(ValueNode x, ValueNode y) {
1479         return ObjectEqualsNode.create(getConstantReflection(), getMetaAccess(), options, x, y, NodeView.DEFAULT);
1480     }
1481 
1482     protected LogicNode genIntegerEquals(ValueNode x, ValueNode y) {
1483         return IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);
1484     }
1485 
1486     protected LogicNode genIntegerLessThan(ValueNode x, ValueNode y) {
1487         return IntegerLessThanNode.create(getConstantReflection(), getMetaAccess(), options, null, x, y, NodeView.DEFAULT);
1488     }
1489 
1490     protected ValueNode genUnique(ValueNode x) {
1491         return graph.addOrUniqueWithInputs(x);
1492     }
1493 
1494     protected LogicNode genUnique(LogicNode x) {
1495         return graph.addOrUniqueWithInputs(x);
1496     }
1497 
1498     protected ValueNode genIfNode(LogicNode condition, FixedNode trueSuccessor, FixedNode falseSuccessor, double d) {
1499         return new IfNode(condition, trueSuccessor, falseSuccessor, d);
1500     }
1501 
1502     protected void genThrow() {
1503         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
1504 
1505         ValueNode exception = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
1506         if (!StampTool.isPointerNonNull(exception.stamp(NodeView.DEFAULT))) {
1507             FixedGuardNode nullCheck = append(new FixedGuardNode(graph.addOrUniqueWithInputs(IsNullNode.create(exception)), NullCheckException, InvalidateReprofile, true));
1508             exception = graph.maybeAddOrUnique(PiNode.create(exception, exception.stamp(NodeView.DEFAULT).join(objectNonNull()), nullCheck));
1509         }
1510         lastInstr.setNext(handleException(exception, bci(), false));
1511     }
1512 
1513     protected LogicNode createInstanceOf(TypeReference type, ValueNode object) {
1514         return InstanceOfNode.create(type, object);
1515     }
1516 
1517     protected AnchoringNode createAnchor(JavaTypeProfile profile) {
1518         if (profile == null || profile.getNotRecordedProbability() &gt; 0.0) {
1519             return null;
1520         } else {
1521             return BeginNode.prevBegin(lastInstr);
1522         }
1523     }
1524 
1525     protected LogicNode createInstanceOf(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1526         return InstanceOfNode.create(type, object, profile, createAnchor(profile));
1527     }
1528 
1529     protected LogicNode createInstanceOfAllowNull(TypeReference type, ValueNode object, JavaTypeProfile profile) {
1530         return InstanceOfNode.createAllowNull(type, object, profile, createAnchor(profile));
1531     }
1532 
1533     protected ValueNode genConditional(ValueNode x) {
1534         return ConditionalNode.create((LogicNode) x, NodeView.DEFAULT);
1535     }
1536 
1537     protected NewInstanceNode createNewInstance(ResolvedJavaType type, boolean fillContents) {
1538         return new NewInstanceNode(type, fillContents);
1539     }
1540 
1541     protected NewArrayNode createNewArray(ResolvedJavaType elementType, ValueNode length, boolean fillContents) {
1542         return new NewArrayNode(elementType, length, fillContents);
1543     }
1544 
1545     protected NewMultiArrayNode createNewMultiArray(ResolvedJavaType type, ValueNode[] dimensions) {
1546         return new NewMultiArrayNode(type, dimensions);
1547     }
1548 
1549     protected ValueNode genLoadField(ValueNode receiver, ResolvedJavaField field) {
1550         StampPair stamp = graphBuilderConfig.getPlugins().getOverridingStamp(this, field.getType(), false);
1551         if (stamp == null) {
1552             return LoadFieldNode.create(getConstantFieldProvider(), getConstantReflection(), getMetaAccess(), getOptions(),
1553                             getAssumptions(), receiver, field, false, false);
1554         } else {
1555             return LoadFieldNode.createOverrideStamp(getConstantFieldProvider(), getConstantReflection(), getMetaAccess(), getOptions(),
1556                             stamp, receiver, field, false, false);
1557         }
1558     }
1559 
1560     protected StateSplitProxyNode genVolatileFieldReadProxy(ValueNode fieldRead) {
1561         return new StateSplitProxyNode(fieldRead);
1562     }
1563 
1564     protected ValueNode maybeEmitExplicitNullCheck(ValueNode receiver) {
1565         if (StampTool.isPointerNonNull(receiver.stamp(NodeView.DEFAULT)) || !needsExplicitNullCheckException(receiver)) {
1566             return receiver;
1567         }
1568         LogicNode condition = genUnique(IsNullNode.create(receiver));
1569         AbstractBeginNode passingSuccessor = emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.NULL_POINTER);
1570         return genUnique(PiNode.create(receiver, objectNonNull(), passingSuccessor));
1571     }
1572 
1573     protected GuardingNode maybeEmitExplicitBoundsCheck(ValueNode receiver, ValueNode index) {
1574         if (!needsExplicitBoundsCheckException(receiver, index)) {
1575             return null;
1576         }
1577         ValueNode length = append(genArrayLength(receiver));
1578         LogicNode condition = genUnique(IntegerBelowNode.create(getConstantReflection(), getMetaAccess(), options, null, index, length, NodeView.DEFAULT));
1579         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.OUT_OF_BOUNDS, index, length);
1580     }
1581 
1582     protected GuardingNode maybeEmitExplicitStoreCheck(ValueNode array, JavaKind elementKind, ValueNode value) {
1583         if (elementKind != JavaKind.Object || StampTool.isPointerAlwaysNull(value) || !needsExplicitStoreCheckException(array, value)) {
1584             return null;
1585         }
1586         ValueNode arrayClass = genUnique(LoadHubNode.create(array, getStampProvider(), getMetaAccess(), getConstantReflection()));
1587         ValueNode componentHub = append(LoadArrayComponentHubNode.create(arrayClass, getStampProvider(), getMetaAccess(), getConstantReflection()));
1588         LogicNode condition = genUnique(InstanceOfDynamicNode.create(graph.getAssumptions(), getConstantReflection(), componentHub, value, true));
1589         return emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.ARRAY_STORE, value);
1590     }
1591 
1592     protected GuardingNode maybeEmitExplicitDivisionByZeroCheck(ValueNode y) {
1593         if (!((IntegerStamp) y.stamp(NodeView.DEFAULT)).contains(0) || !needsExplicitDivisionByZeroException(y)) {
1594             return null;
1595         }
1596         ConstantNode zero = ConstantNode.defaultForKind(y.getStackKind(), graph);
1597         LogicNode condition = genUnique(IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, y, zero, NodeView.DEFAULT));
1598         return emitBytecodeExceptionCheck(condition, false, BytecodeExceptionKind.DIVISION_BY_ZERO);
1599     }
1600 
1601     private AbstractBeginNode emitBytecodeExceptionCheck(LogicNode condition, boolean passingOnTrue, BytecodeExceptionKind exceptionKind, ValueNode... arguments) {
1602         if (passingOnTrue ? condition.isTautology() : condition.isContradiction()) {
1603             return null;
1604         }
1605 
1606         BytecodeExceptionNode exception = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind, arguments));
1607         AbstractBeginNode passingSuccessor = graph.add(new BeginNode());
1608 
1609         FixedNode trueSuccessor = passingOnTrue ? passingSuccessor : exception;
1610         FixedNode falseSuccessor = passingOnTrue ? exception : passingSuccessor;
1611         append(new IfNode(condition, trueSuccessor, falseSuccessor, passingOnTrue ? LUDICROUSLY_FAST_PATH_PROBABILITY : LUDICROUSLY_SLOW_PATH_PROBABILITY));
1612         lastInstr = passingSuccessor;
1613 
1614         exception.setStateAfter(createBytecodeExceptionFrameState(bci(), exception));
1615         exception.setNext(handleException(exception, bci(), false));
1616         EXPLICIT_EXCEPTIONS.increment(debug);
1617 
1618         return passingSuccessor;
1619     }
1620 
1621     protected ValueNode genArrayLength(ValueNode x) {
1622         return ArrayLengthNode.create(x, getConstantReflection());
1623     }
1624 
1625     protected void genStoreField(ValueNode receiver, ResolvedJavaField field, ValueNode value) {
1626         StoreFieldNode storeFieldNode = new StoreFieldNode(receiver, field, maskSubWordValue(value, field.getJavaKind()));
1627         append(storeFieldNode);
1628         storeFieldNode.setStateAfter(this.createFrameState(stream.nextBCI(), storeFieldNode));
1629     }
1630 
1631     /**
1632      * Ensure that concrete classes are at least linked before generating an invoke. Interfaces may
1633      * never be linked so simply return true for them.
1634      *
1635      * @param target
1636      * @return true if the declared holder is an interface or is linked
1637      */
1638     private static boolean callTargetIsResolved(JavaMethod target) {
1639         if (target instanceof ResolvedJavaMethod) {
1640             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1641             ResolvedJavaType resolvedType = resolvedTarget.getDeclaringClass();
1642             return resolvedType.isInterface() || resolvedType.isLinked();
1643         }
1644         return false;
1645     }
1646 
1647     /**
1648      * Check if a type is resolved. Can be overwritten by sub-classes to implement different type
1649      * resolution rules.
1650      */
1651     protected boolean typeIsResolved(JavaType type) {
1652         return type instanceof ResolvedJavaType;
1653     }
1654 
1655     protected void genInvokeStatic(int cpi, int opcode) {
1656         JavaMethod target = lookupMethod(cpi, opcode);
1657         assert !uninitializedIsError ||
1658                         (target instanceof ResolvedJavaMethod &amp;&amp; ((ResolvedJavaMethod) target).getDeclaringClass().isInitialized()) : target;
1659         genInvokeStatic(target);
1660     }
1661 
1662     void genInvokeStatic(JavaMethod target) {
1663         if (callTargetIsResolved(target)) {
1664             ResolvedJavaMethod resolvedTarget = (ResolvedJavaMethod) target;
1665             ResolvedJavaType holder = resolvedTarget.getDeclaringClass();
1666             maybeEagerlyInitialize(holder);
1667             ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
1668             if (!holder.isInitialized() &amp;&amp; classInitializationPlugin == null) {
1669                 handleUnresolvedInvoke(target, InvokeKind.Static);
1670                 return;
1671             }
1672 
1673             ValueNode[] classInit = {null};
1674             if (classInitializationPlugin != null) {
1675                 classInitializationPlugin.apply(this, resolvedTarget.getDeclaringClass(), this::createCurrentFrameState, classInit);
1676             }
1677 
1678             ValueNode[] args = frameState.popArguments(resolvedTarget.getSignature().getParameterCount(false));
1679             Invoke invoke = appendInvoke(InvokeKind.Static, resolvedTarget, args);
1680             if (invoke != null &amp;&amp; classInit[0] != null) {
1681                 invoke.setClassInit(classInit[0]);
1682             }
1683         } else {
1684             handleUnresolvedInvoke(target, InvokeKind.Static);
1685         }
1686     }
1687 
1688     /**
1689      * Creates a frame state for the current parse position.
1690      */
1691     private FrameState createCurrentFrameState() {
1692         return frameState.create(bci(), getNonIntrinsicAncestor(), false, null, null);
1693     }
1694 
1695     protected void genInvokeInterface(int cpi, int opcode) {
1696         JavaMethod target = lookupMethod(cpi, opcode);
1697         genInvokeInterface(target);
1698     }
1699 
1700     protected void genInvokeInterface(JavaMethod target) {
1701         if (callTargetIsResolved(target)) {
1702             ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(true));
1703             appendInvoke(InvokeKind.Interface, (ResolvedJavaMethod) target, args);
1704         } else {
1705             handleUnresolvedInvoke(target, InvokeKind.Interface);
1706         }
1707     }
1708 
1709     protected void genInvokeDynamic(int cpi, int opcode) {
1710         JavaMethod target = lookupMethod(cpi, opcode);
1711         genInvokeDynamic(target);
1712     }
1713 
1714     void genInvokeDynamic(JavaMethod target) {
1715         if (!(target instanceof ResolvedJavaMethod) || !genDynamicInvokeHelper((ResolvedJavaMethod) target, stream.readCPI4(), INVOKEDYNAMIC)) {
1716             handleUnresolvedInvoke(target, InvokeKind.Static);
1717         }
1718     }
1719 
1720     protected void genInvokeVirtual(int cpi, int opcode) {
1721         JavaMethod target = lookupMethod(cpi, opcode);
1722         if (callTargetIsResolved(target)) {
1723             genInvokeVirtual((ResolvedJavaMethod) target);
1724         } else {
1725             handleUnresolvedInvoke(target, InvokeKind.Virtual);
1726         }
1727     }
1728 
1729     protected void genInvokeVirtual(ResolvedJavaMethod resolvedTarget) {
1730         int cpi = stream.readCPI();
1731 
1732         /*
1733          * Special handling for runtimes that rewrite an invocation of MethodHandle.invoke(...) or
1734          * MethodHandle.invokeExact(...) to a static adapter. HotSpot does this - see
1735          * https://wiki.openjdk.java.net/display/HotSpot/Method+handles+and+invokedynamic
1736          */
1737 
1738         if (genDynamicInvokeHelper(resolvedTarget, cpi, INVOKEVIRTUAL)) {
1739             return;
1740         }
1741 
1742         ValueNode[] args = frameState.popArguments(resolvedTarget.getSignature().getParameterCount(true));
1743         appendInvoke(InvokeKind.Virtual, resolvedTarget, args);
1744     }
1745 
1746     private boolean genDynamicInvokeHelper(ResolvedJavaMethod target, int cpi, int opcode) {
1747         assert opcode == INVOKEDYNAMIC || opcode == INVOKEVIRTUAL;
1748 
1749         InvokeDynamicPlugin invokeDynamicPlugin = graphBuilderConfig.getPlugins().getInvokeDynamicPlugin();
1750 
1751         if (opcode == INVOKEVIRTUAL &amp;&amp; invokeDynamicPlugin != null &amp;&amp; !invokeDynamicPlugin.isResolvedDynamicInvoke(this, cpi, opcode)) {
1752             // regular invokevirtual, let caller handle it
1753             return false;
1754         }
1755 
1756         if (GeneratePIC.getValue(options) &amp;&amp; (invokeDynamicPlugin == null || !invokeDynamicPlugin.supportsDynamicInvoke(this, cpi, opcode))) {
1757             // bail out if static compiler and no dynamic type support
1758             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1759             return true;
1760         }
1761 
1762         JavaConstant appendix = constantPool.lookupAppendix(cpi, opcode);
1763         ValueNode appendixNode = null;
1764 
1765         if (appendix != null) {
1766             if (invokeDynamicPlugin != null) {
1767                 invokeDynamicPlugin.recordDynamicMethod(this, cpi, opcode, target);
1768 
1769                 // Will perform runtime type checks and static initialization
1770                 FrameState stateBefore = createCurrentFrameState();
1771                 appendixNode = invokeDynamicPlugin.genAppendixNode(this, cpi, opcode, appendix, stateBefore);
1772             } else {
1773                 appendixNode = ConstantNode.forConstant(appendix, getMetaAccess(), graph);
1774             }
1775 
1776             frameState.push(JavaKind.Object, appendixNode);
1777 
1778         } else if (GeneratePIC.getValue(options)) {
1779             // Need to emit runtime guard and perform static initialization.
1780             // Not implemented yet.
1781             append(new DeoptimizeNode(InvalidateRecompile, Unresolved));
1782             return true;
1783         }
1784 
1785         boolean hasReceiver = (opcode == INVOKEDYNAMIC) ? false : !target.isStatic();
1786         ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(hasReceiver));
1787         if (hasReceiver) {
1788             appendInvoke(InvokeKind.Virtual, target, args);
1789         } else {
1790             appendInvoke(InvokeKind.Static, target, args);
1791         }
1792 
1793         return true;
1794     }
1795 
1796     protected void genInvokeSpecial(int cpi, int opcode) {
1797         JavaMethod target = lookupMethod(cpi, opcode);
1798         genInvokeSpecial(target);
1799     }
1800 
1801     void genInvokeSpecial(JavaMethod target) {
1802         if (callTargetIsResolved(target)) {
1803             assert target != null;
1804             assert target.getSignature() != null;
1805             ValueNode[] args = frameState.popArguments(target.getSignature().getParameterCount(true));
1806             appendInvoke(InvokeKind.Special, (ResolvedJavaMethod) target, args);
1807         } else {
1808             handleUnresolvedInvoke(target, InvokeKind.Special);
1809         }
1810     }
1811 
1812     static class CurrentInvoke {
1813         final ValueNode[] args;
1814         final InvokeKind kind;
1815         final JavaType returnType;
1816 
1817         CurrentInvoke(ValueNode[] args, InvokeKind kind, JavaType returnType) {
1818             this.args = args;
1819             this.kind = kind;
1820             this.returnType = returnType;
1821         }
1822     }
1823 
1824     private CurrentInvoke currentInvoke;
1825     protected FrameStateBuilder frameState;
1826     protected BciBlock currentBlock;
1827     protected final BytecodeStream stream;
1828     protected final GraphBuilderConfiguration graphBuilderConfig;
1829     protected final ResolvedJavaMethod method;
1830     protected final Bytecode code;
1831     protected final BytecodeProvider bytecodeProvider;
1832     protected final ProfilingInfo profilingInfo;
1833     protected final OptimisticOptimizations optimisticOpts;
1834     protected final ConstantPool constantPool;
1835     protected final CoreProviders providers;
1836     protected final IntrinsicContext intrinsicContext;
1837 
1838     @Override
1839     public InvokeKind getInvokeKind() {
1840         return currentInvoke == null ? null : currentInvoke.kind;
1841     }
1842 
1843     @Override
1844     public JavaType getInvokeReturnType() {
1845         return currentInvoke == null ? null : currentInvoke.returnType;
1846     }
1847 
1848     private boolean forceInliningEverything;
1849 
1850     @Override
1851     public Invoke handleReplacedInvoke(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, boolean inlineEverything) {
1852         boolean previous = forceInliningEverything;
1853         forceInliningEverything = previous || inlineEverything;
1854         try {
1855             return appendInvoke(invokeKind, targetMethod, args);
1856         } finally {
1857             forceInliningEverything = previous;
1858         }
1859     }
1860 
1861     @Override
1862     public void handleReplacedInvoke(CallTargetNode callTarget, JavaKind resultType) {
1863         BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1864         ExceptionEdgeAction exceptionEdgeAction = intrinsicCallSiteParser == null ? getActionForInvokeExceptionEdge(null) : intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null);
1865         createNonInlinedInvoke(exceptionEdgeAction, bci(), callTarget, resultType);
1866     }
1867 
1868     protected Invoke appendInvoke(InvokeKind initialInvokeKind, ResolvedJavaMethod initialTargetMethod, ValueNode[] args) {
1869         ResolvedJavaMethod targetMethod = initialTargetMethod;
1870         InvokeKind invokeKind = initialInvokeKind;
1871         if (initialInvokeKind.isIndirect()) {
1872             ResolvedJavaType contextType = this.frameState.getMethod().getDeclaringClass();
1873             ResolvedJavaMethod specialCallTarget = MethodCallTargetNode.findSpecialCallTarget(initialInvokeKind, args[0], initialTargetMethod, contextType);
1874             if (specialCallTarget != null) {
1875                 invokeKind = InvokeKind.Special;
1876                 targetMethod = specialCallTarget;
1877             }
1878         }
1879 
1880         JavaKind resultType = targetMethod.getSignature().getReturnKind();
1881         if (!parsingIntrinsic() &amp;&amp; DeoptALot.getValue(options)) {
1882             append(new DeoptimizeNode(DeoptimizationAction.None, RuntimeConstraint));
1883             frameState.pushReturn(resultType, ConstantNode.defaultForKind(resultType, graph));
1884             return null;
1885         }
1886 
1887         JavaType returnType = maybeEagerlyResolve(targetMethod.getSignature().getReturnType(method.getDeclaringClass()), targetMethod.getDeclaringClass());
1888         if (invokeKind.hasReceiver()) {
1889             args[0] = maybeEmitExplicitNullCheck(args[0]);
1890         }
1891 
1892         if (initialInvokeKind == InvokeKind.Special &amp;&amp; !targetMethod.isConstructor()) {
1893             emitCheckForInvokeSuperSpecial(args);
1894         } else if (initialInvokeKind == InvokeKind.Interface &amp;&amp; targetMethod.isPrivate()) {
1895             emitCheckForDeclaringClassChange(targetMethod.getDeclaringClass(), args);
1896         }
1897 
1898         InlineInfo inlineInfo = null;
1899         try {
1900             currentInvoke = new CurrentInvoke(args, invokeKind, returnType);
1901             if (tryNodePluginForInvocation(args, targetMethod)) {
1902                 if (TraceParserPlugins.getValue(options)) {
1903                     traceWithContext(&quot;used node plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1904                 }
1905                 return null;
1906             }
1907 
1908             if (invokeKind.hasReceiver() &amp;&amp; args[0].isNullConstant()) {
1909                 append(new DeoptimizeNode(InvalidateRecompile, NullCheckException));
1910                 return null;
1911             }
1912 
1913             if (!invokeKind.isIndirect()) {
1914                 if (tryInvocationPlugin(invokeKind, args, targetMethod, resultType)) {
1915                     if (TraceParserPlugins.getValue(options)) {
1916                         traceWithContext(&quot;used invocation plugin for %s&quot;, targetMethod.format(&quot;%h.%n(%p)&quot;));
1917                     }
1918                     return null;
1919                 }
1920             }
1921             if (invokeKind.isDirect()) {
1922                 inlineInfo = tryInline(args, targetMethod);
1923                 if (inlineInfo == SUCCESSFULLY_INLINED) {
1924                     return null;
1925                 }
1926             }
1927         } finally {
1928             currentInvoke = null;
1929         }
1930         int invokeBci = bci();
1931         JavaTypeProfile profile = getProfileForInvoke(invokeKind);
1932         ExceptionEdgeAction edgeAction = getActionForInvokeExceptionEdge(inlineInfo);
1933         boolean partialIntrinsicExit = false;
1934         if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1935             partialIntrinsicExit = true;
1936             ResolvedJavaMethod originalMethod = intrinsicContext.getOriginalMethod();
1937             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
1938             if (intrinsicCallSiteParser != null) {
1939                 // When exiting a partial intrinsic, the invoke to the original
1940                 // must use the same context as the call to the intrinsic.
1941                 invokeBci = intrinsicCallSiteParser.bci();
1942                 profile = intrinsicCallSiteParser.getProfileForInvoke(invokeKind);
1943                 edgeAction = intrinsicCallSiteParser.getActionForInvokeExceptionEdge(inlineInfo);
1944             } else {
1945                 // We are parsing the intrinsic for the root compilation or for inlining,
1946                 // This call is a partial intrinsic exit, and we do not have profile information
1947                 // for this callsite. We also have to assume that the call needs an exception
1948                 // edge. Finally, we know that this intrinsic is parsed for late inlining,
1949                 // so the bci must be set to unknown, so that the inliner patches it later.
1950                 assert intrinsicContext.isPostParseInlined();
1951                 invokeBci = UNKNOWN_BCI;
1952                 profile = null;
1953                 edgeAction = graph.method().getAnnotation(Snippet.class) == null ? ExceptionEdgeAction.INCLUDE_AND_HANDLE : ExceptionEdgeAction.OMIT;
1954             }
1955 
1956             if (originalMethod.isStatic()) {
1957                 invokeKind = InvokeKind.Static;
1958             } else {
1959                 // The original call to the intrinsic must have been devirtualized
1960                 // otherwise we wouldn&#39;t be here.
1961                 invokeKind = InvokeKind.Special;
1962             }
1963             Signature sig = originalMethod.getSignature();
1964             returnType = sig.getReturnType(method.getDeclaringClass());
1965             resultType = sig.getReturnKind();
1966             assert intrinsicContext.allowPartialIntrinsicArgumentMismatch() || checkPartialIntrinsicExit(intrinsicCallSiteParser == null ? null : intrinsicCallSiteParser.currentInvoke.args, args);
1967             targetMethod = originalMethod;
1968         }
1969         Invoke invoke = createNonInlinedInvoke(edgeAction, invokeBci, args, targetMethod, invokeKind, resultType, returnType, profile);
1970         graph.getInliningLog().addDecision(invoke, false, &quot;GraphBuilderPhase&quot;, null, null, &quot;bytecode parser did not replace invoke&quot;);
1971         if (partialIntrinsicExit) {
1972             // This invoke must never be later inlined as it might select the intrinsic graph.
1973             // Until there is a mechanism to guarantee that any late inlining will not select
1974             // the intrinsic graph, prevent this invoke from being inlined.
1975             invoke.setUseForInlining(false);
1976         }
1977         return invoke;
1978     }
1979 
1980     /**
1981      * Checks that the class of the receiver of an {@link Bytecodes#INVOKEINTERFACE} invocation of a
1982      * private method is assignable to the interface that declared the method. If not, then
1983      * deoptimize so that the interpreter can throw an {@link IllegalAccessError}.
1984      *
1985      * This is a check not performed by the verifier and so must be performed at runtime.
1986      *
1987      * @param declaringClass interface declaring the callee
1988      * @param args arguments to an {@link Bytecodes#INVOKEINTERFACE} call to a private method
1989      *            declared in a interface
1990      */
1991     private void emitCheckForDeclaringClassChange(ResolvedJavaType declaringClass, ValueNode[] args) {
1992         ValueNode receiver = args[0];
1993         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), declaringClass);
1994         LogicNode condition = genUnique(createInstanceOf(checkedType, receiver, null));
1995         FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, ClassCastException, None, false));
1996         args[0] = append(PiNode.create(receiver, StampFactory.object(checkedType, true), fixedGuard));
1997     }
1998 
1999     /**
2000      * Checks that the class of the receiver of an {@link Bytecodes#INVOKESPECIAL} in a method
2001      * declared in an interface (i.e., a default method) is assignable to the interface. If not,
2002      * then deoptimize so that the interpreter can throw an {@link IllegalAccessError}.
2003      *
2004      * This is a check not performed by the verifier and so must be performed at runtime.
2005      *
2006      * @param args arguments to an {@link Bytecodes#INVOKESPECIAL} implementing a direct call to a
2007      *            method in a super class
2008      */
2009     protected void emitCheckForInvokeSuperSpecial(ValueNode[] args) {
2010         ResolvedJavaType callingClass = method.getDeclaringClass();
2011         if (callingClass.getHostClass() != null) {
2012             callingClass = callingClass.getHostClass();
2013         }
2014         if (callingClass.isInterface()) {
2015             ValueNode receiver = args[0];
2016             TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), callingClass);
2017             LogicNode condition = genUnique(createInstanceOf(checkedType, receiver, null));
2018             FixedGuardNode fixedGuard = append(new FixedGuardNode(condition, ClassCastException, None, false));
2019             args[0] = append(PiNode.create(receiver, StampFactory.object(checkedType, true), fixedGuard));
2020         }
2021     }
2022 
2023     protected JavaTypeProfile getProfileForInvoke(InvokeKind invokeKind) {
2024         if (invokeKind.isIndirect() &amp;&amp; profilingInfo != null &amp;&amp; this.optimisticOpts.useTypeCheckHints(getOptions())) {
2025             return profilingInfo.getTypeProfile(bci());
2026         }
2027         return null;
2028     }
2029 
2030     /**
2031      * A partial intrinsic exits by (effectively) calling the intrinsified method. This call must
2032      * use exactly the arguments to the call being intrinsified.
2033      *
2034      * @param originalArgs arguments of original call to intrinsified method
2035      * @param recursiveArgs arguments of recursive call to intrinsified method
2036      */
2037     private static boolean checkPartialIntrinsicExit(ValueNode[] originalArgs, ValueNode[] recursiveArgs) {
2038         if (originalArgs != null) {
2039             for (int i = 0; i &lt; originalArgs.length; i++) {
2040                 ValueNode arg = GraphUtil.unproxify(recursiveArgs[i]);
2041                 ValueNode icArg = GraphUtil.unproxify(originalArgs[i]);
2042                 assert arg == icArg : String.format(&quot;argument %d of call denoting partial intrinsic exit should be %s, not %s&quot;, i, icArg, arg);
2043             }
2044         } else {
2045             for (int i = 0; i &lt; recursiveArgs.length; i++) {
2046                 ValueNode arg = GraphUtil.unproxify(recursiveArgs[i]);
2047                 assert arg instanceof ParameterNode &amp;&amp; ((ParameterNode) arg).index() == i : String.format(&quot;argument %d of call denoting partial intrinsic exit should be a %s with index %d, not %s&quot;,
2048                                 i, ParameterNode.class.getSimpleName(), i, arg);
2049             }
2050         }
2051         return true;
2052     }
2053 
2054     protected Invoke createNonInlinedInvoke(ExceptionEdgeAction exceptionEdge, int invokeBci, ValueNode[] invokeArgs, ResolvedJavaMethod targetMethod,
2055                     InvokeKind invokeKind, JavaKind resultType, JavaType returnType, JavaTypeProfile profile) {
2056 
2057         StampPair returnStamp = graphBuilderConfig.getPlugins().getOverridingStamp(this, returnType, false);
2058         if (returnStamp == null) {
2059             returnStamp = StampFactory.forDeclaredType(graph.getAssumptions(), returnType, false);
2060         }
2061 
2062         MethodCallTargetNode callTarget = graph.add(createMethodCallTarget(invokeKind, targetMethod, invokeArgs, returnStamp, profile));
2063         Invoke invoke = createNonInlinedInvoke(exceptionEdge, invokeBci, callTarget, resultType);
2064 
2065         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2066             plugin.notifyNotInlined(this, targetMethod, invoke);
2067         }
2068 
2069         return invoke;
2070     }
2071 
2072     protected Invoke createNonInlinedInvoke(ExceptionEdgeAction exceptionEdge, int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2073         if (exceptionEdge == ExceptionEdgeAction.OMIT) {
2074             return createInvoke(invokeBci, callTarget, resultType);
2075         } else {
2076             Invoke invoke = createInvokeWithException(invokeBci, callTarget, resultType, exceptionEdge);
2077             AbstractBeginNode beginNode = graph.add(KillingBeginNode.create(LocationIdentity.any()));
2078             invoke.setNext(beginNode);
2079             lastInstr = beginNode;
2080             return invoke;
2081         }
2082     }
2083 
2084     /**
2085      * Describes what should be done with the exception edge of an invocation. The edge can be
2086      * omitted or included. An included edge can handle the exception or transfer execution to the
2087      * interpreter for handling (deoptimize).
2088      */
2089     protected enum ExceptionEdgeAction {
2090         OMIT,
2091         INCLUDE_AND_HANDLE,
2092         INCLUDE_AND_DEOPTIMIZE
2093     }
2094 
2095     protected ExceptionEdgeAction getActionForInvokeExceptionEdge(InlineInfo lastInlineInfo) {
2096         if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION) {
2097             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2098         } else if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_NO_EXCEPTION) {
2099             return ExceptionEdgeAction.OMIT;
2100         } else if (lastInlineInfo == InlineInfo.DO_NOT_INLINE_DEOPTIMIZE_ON_EXCEPTION) {
2101             return ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE;
2102         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.CheckAll) {
2103             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2104         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.ExplicitOnly) {
2105             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2106         } else if (graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.OmitAll) {
2107             return ExceptionEdgeAction.OMIT;
2108         } else {
2109             assert graphBuilderConfig.getBytecodeExceptionMode() == BytecodeExceptionMode.Profile;
2110             // be conservative if information was not recorded (could result in endless
2111             // recompiles otherwise)
2112             if (!StressInvokeWithExceptionNode.getValue(options)) {
2113                 if (optimisticOpts.useExceptionProbability(getOptions())) {
2114                     if (profilingInfo != null) {
2115                         TriState exceptionSeen = profilingInfo.getExceptionSeen(bci());
2116                         if (exceptionSeen == TriState.FALSE) {
2117                             return ExceptionEdgeAction.OMIT;
2118                         }
2119                     }
2120                 }
2121             }
2122             return ExceptionEdgeAction.INCLUDE_AND_HANDLE;
2123         }
2124     }
2125 
2126     /**
2127      * Contains all the assertion checking logic around the application of an
2128      * {@link InvocationPlugin}. This class is only loaded when assertions are enabled.
2129      */
2130     class InvocationPluginAssertions {
2131         final InvocationPlugin plugin;
2132         final ValueNode[] args;
2133         final ResolvedJavaMethod targetMethod;
2134         final JavaKind resultType;
2135         final int beforeStackSize;
2136         final boolean needsNullCheck;
2137         final int nodeCount;
2138         final Mark mark;
2139 
2140         InvocationPluginAssertions(InvocationPlugin plugin, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
2141             guarantee(Assertions.assertionsEnabled(), &quot;%s should only be loaded and instantiated if assertions are enabled&quot;, getClass().getSimpleName());
2142             this.plugin = plugin;
2143             this.targetMethod = targetMethod;
2144             this.args = args;
2145             this.resultType = resultType;
2146             this.beforeStackSize = frameState.stackSize();
2147             this.needsNullCheck = !targetMethod.isStatic() &amp;&amp; args[0].getStackKind() == JavaKind.Object &amp;&amp; !StampTool.isPointerNonNull(args[0].stamp(NodeView.DEFAULT));
2148             this.nodeCount = graph.getNodeCount();
2149             this.mark = graph.getMark();
2150         }
2151 
2152         String error(String format, Object... a) {
2153             return String.format(format, a) + String.format(&quot;%n\tplugin at %s&quot;, plugin.getApplySourceLocation(getMetaAccess()));
2154         }
2155 
2156         boolean check(boolean pluginResult) {
2157             if (pluginResult) {
2158                 /*
2159                  * If lastInstr is null, even if this method has a non-void return type, the method
2160                  * doesn&#39;t return a value, it probably throws an exception.
2161                  */
2162                 int expectedStackSize = beforeStackSize + resultType.getSlotCount();
2163                 assert lastInstr == null || expectedStackSize == frameState.stackSize() : error(&quot;plugin manipulated the stack incorrectly: expected=%d, actual=%d&quot;, expectedStackSize,
2164                                 frameState.stackSize());
2165 
2166                 NodeIterable&lt;Node&gt; newNodes = graph.getNewNodes(mark);
2167                 assert !needsNullCheck || isPointerNonNull(args[0].stamp(NodeView.DEFAULT)) : error(&quot;plugin needs to null check the receiver of %s: receiver=%s&quot;, targetMethod.format(&quot;%H.%n(%p)&quot;),
2168                                 args[0]);
2169                 for (Node n : newNodes) {
2170                     if (n instanceof StateSplit) {
2171                         StateSplit stateSplit = (StateSplit) n;
2172                         assert stateSplit.stateAfter() != null || !stateSplit.hasSideEffect() : error(&quot;%s node added by plugin for %s need to have a non-null frame state: %s&quot;,
2173                                         StateSplit.class.getSimpleName(), targetMethod.format(&quot;%H.%n(%p)&quot;), stateSplit);
2174                     }
2175                 }
2176                 try {
2177                     graphBuilderConfig.getPlugins().getInvocationPlugins().checkNewNodes(BytecodeParser.this, plugin, newNodes);
2178                 } catch (Throwable t) {
2179                     throw new AssertionError(error(&quot;Error in plugin&quot;), t);
2180                 }
2181             } else {
2182                 assert nodeCount == graph.getNodeCount() : error(&quot;plugin that returns false must not create new nodes&quot;);
2183                 assert beforeStackSize == frameState.stackSize() : error(&quot;plugin that returns false must not modify the stack&quot;);
2184             }
2185             return true;
2186         }
2187     }
2188 
2189     @SuppressWarnings(&quot;try&quot;)
2190     protected boolean tryInvocationPlugin(InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
2191         InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
2192         if (plugin != null) {
2193 
2194             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
2195                 // Self recursive intrinsic means the original method should be called.
2196                 return false;
2197             }
2198 
2199             InvocationPluginReceiver pluginReceiver = invocationPluginReceiver.init(targetMethod, args);
2200             assert invokeKind.isDirect() : &quot;Cannot apply invocation plugin on an indirect call site.&quot;;
2201 
2202             InvocationPluginAssertions assertions = Assertions.assertionsEnabled() ? new InvocationPluginAssertions(plugin, args, targetMethod, resultType) : null;
2203             try (DebugCloseable context = openNodeContext(targetMethod)) {
2204                 if (plugin.execute(this, targetMethod, pluginReceiver, args)) {
2205                     assert assertions.check(true);
2206                     return !plugin.isDecorator();
2207                 } else {
2208                     assert assertions.check(false);
2209                 }
2210             }
2211         }
2212         return false;
2213     }
2214 
2215     private boolean tryNodePluginForInvocation(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2216         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
2217             if (plugin.handleInvoke(this, targetMethod, args)) {
2218                 return true;
2219             }
2220         }
2221         return false;
2222     }
2223 
2224     private static final InlineInfo SUCCESSFULLY_INLINED = InlineInfo.createStandardInlineInfo(null);
2225 
2226     /**
2227      * Try to inline a method. If the method was inlined, returns {@link #SUCCESSFULLY_INLINED}.
2228      * Otherwise, it returns the {@link InlineInfo} that lead to the decision to not inline it, or
2229      * {@code null} if there is no {@link InlineInfo} for this method.
2230      */
2231     private InlineInfo tryInline(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2232         boolean canBeInlined = forceInliningEverything || parsingIntrinsic() || targetMethod.canBeInlined();
2233         if (!canBeInlined) {
2234             return null;
2235         }
2236 
2237         if (forceInliningEverything) {
2238             if (inline(targetMethod, targetMethod, null, args)) {
2239                 return SUCCESSFULLY_INLINED;
2240             } else {
2241                 return null;
2242             }
2243         }
2244 
2245         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2246             InlineInfo inlineInfo = plugin.shouldInlineInvoke(this, targetMethod, args);
2247             if (inlineInfo != null) {
2248                 if (inlineInfo.allowsInlining()) {
2249                     if (inline(targetMethod, inlineInfo.getMethodToInline(), inlineInfo.getIntrinsicBytecodeProvider(), args)) {
2250                         return SUCCESSFULLY_INLINED;
2251                     }
2252                     inlineInfo = null;
2253                 }
2254                 /* Do not inline, and do not ask the remaining plugins. */
2255                 return inlineInfo;
2256             }
2257         }
2258 
2259         // There was no inline plugin with a definite answer to whether or not
2260         // to inline. If we&#39;re parsing an intrinsic, then we need to enforce the
2261         // invariant here that methods are always force inlined in intrinsics/snippets.
2262         if (parsingIntrinsic()) {
2263             if (inline(targetMethod, targetMethod, this.bytecodeProvider, args)) {
2264                 return SUCCESSFULLY_INLINED;
2265             }
2266         }
2267         return null;
2268     }
2269 
2270     private static final int ACCESSOR_BYTECODE_LENGTH = 5;
2271 
2272     /**
2273      * Tries to inline {@code targetMethod} if it is an instance field accessor. This avoids the
2274      * overhead of creating and using a nested {@link BytecodeParser} object.
2275      */
2276     @SuppressWarnings(&quot;try&quot;)
2277     private boolean tryFastInlineAccessor(ValueNode[] args, ResolvedJavaMethod targetMethod) {
2278         byte[] bytecode = targetMethod.getCode();
2279         if (bytecode != null &amp;&amp; bytecode.length == ACCESSOR_BYTECODE_LENGTH &amp;&amp;
2280                         Bytes.beU1(bytecode, 0) == ALOAD_0 &amp;&amp;
2281                         Bytes.beU1(bytecode, 1) == GETFIELD) {
2282             int b4 = Bytes.beU1(bytecode, 4);
2283             if (b4 &gt;= IRETURN &amp;&amp; b4 &lt;= ARETURN) {
2284                 int cpi = Bytes.beU2(bytecode, 2);
2285                 JavaField field = targetMethod.getConstantPool().lookupField(cpi, targetMethod, GETFIELD);
2286                 if (field instanceof ResolvedJavaField) {
2287                     ValueNode receiver = invocationPluginReceiver.init(targetMethod, args).get();
2288                     ResolvedJavaField resolvedField = (ResolvedJavaField) field;
2289                     try (DebugCloseable context = openNodeContext(targetMethod, 1)) {
2290                         genGetField(resolvedField, receiver);
2291                         notifyBeforeInline(targetMethod);
2292                         printInlining(targetMethod, targetMethod, true, &quot;inline accessor method (bytecode parsing)&quot;);
2293                         notifyAfterInline(targetMethod);
2294                     }
2295                     return true;
2296                 }
2297             }
2298         }
2299         return false;
2300     }
2301 
2302     /**
2303      * Inline a method substitution graph. This is necessary for libgraal as substitutions only
2304      * exist as encoded graphs and can&#39;t be parsed directly into the caller.
2305      */
2306     @Override
2307     @SuppressWarnings(&quot;try&quot;)
2308     public boolean intrinsify(ResolvedJavaMethod targetMethod, StructuredGraph substituteGraph, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2309         if (receiver != null) {
2310             receiver.get();
2311         }
2312 
2313         InvokeWithExceptionNode withException = null;
2314         FixedWithNextNode replacee = lastInstr;
2315         try (DebugContext.Scope a = debug.scope(&quot;instantiate&quot;, substituteGraph)) {
2316             // Inline the snippet nodes, replacing parameters with the given args in the process
2317             StartNode entryPointNode = substituteGraph.start();
2318             FixedNode firstCFGNode = entryPointNode.next();
2319             StructuredGraph replaceeGraph = replacee.graph();
2320             Mark mark = replaceeGraph.getMark();
2321             try (InliningScope inlineScope = new IntrinsicScope(this, targetMethod, args)) {
2322 
2323                 EconomicMap&lt;Node, Node&gt; replacementsMap = EconomicMap.create(Equivalence.IDENTITY);
2324                 for (ParameterNode param : substituteGraph.getNodes().filter(ParameterNode.class)) {
2325                     replacementsMap.put(param, args[param.index()]);
2326                 }
2327                 replacementsMap.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
2328 
2329                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;Before inlining method substitution %s&quot;, substituteGraph.method());
2330                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineMethodSubstitution(replaceeGraph, substituteGraph, replacementsMap);
2331 
2332                 FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
2333                 replacee.setNext(firstCFGNodeDuplicate);
2334                 debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining method substitution %s&quot;, substituteGraph.method());
2335 
2336                 // Handle partial intrinsic exits
2337                 for (Node node : graph.getNewNodes(mark)) {
2338                     if (node instanceof Invoke) {
2339                         Invoke invoke = (Invoke) node;
2340                         if (invoke.bci() == BytecodeFrame.UNKNOWN_BCI) {
2341                             invoke.replaceBci(bci());
2342                         }
2343                         if (node instanceof InvokeWithExceptionNode) {
2344                             // The graphs for MethodSubsitutions are produced assuming that
2345                             // exceptions
2346                             // must be dispatched. If the calling context doesn&#39;t want exception
2347                             // then
2348                             // convert back into a normal InvokeNode.
2349                             assert withException == null : &quot;only one invoke expected&quot;;
2350                             withException = (InvokeWithExceptionNode) node;
2351                             BytecodeParser intrinsicCallSiteParser = getNonIntrinsicAncestor();
2352                             if (intrinsicCallSiteParser != null &amp;&amp; intrinsicCallSiteParser.getActionForInvokeExceptionEdge(null) == ExceptionEdgeAction.OMIT) {
2353                                 InvokeNode newInvoke = graph.add(new InvokeNode(withException));
2354                                 newInvoke.setStateDuring(withException.stateDuring());
2355                                 newInvoke.setStateAfter(withException.stateAfter());
2356                                 withException.killExceptionEdge();
2357                                 AbstractBeginNode next = withException.killKillingBegin();
2358                                 FixedWithNextNode pred = (FixedWithNextNode) withException.predecessor();
2359                                 pred.setNext(newInvoke);
2360                                 withException.setNext(null);
2361                                 newInvoke.setNext(next);
2362                                 withException.replaceAndDelete(newInvoke);
2363                             } else {
2364                                 // Disconnnect exception edge
2365                                 withException.killExceptionEdge();
2366                             }
2367                         }
2368                     } else if (node instanceof ForeignCallNode) {
2369                         ForeignCallNode call = (ForeignCallNode) node;
2370                         if (call.getBci() == BytecodeFrame.UNKNOWN_BCI) {
2371                             call.setBci(bci());
2372                             if (call.stateAfter() != null &amp;&amp; call.stateAfter().bci == BytecodeFrame.INVALID_FRAMESTATE_BCI) {
2373                                 call.setStateAfter(inlineScope.stateBefore);
2374                             }
2375                         }
2376                     }
2377                 }
2378 
2379                 ArrayList&lt;ReturnToCallerData&gt; calleeReturnDataList = new ArrayList&lt;&gt;();
2380                 for (ReturnNode n : substituteGraph.getNodes().filter(ReturnNode.class)) {
2381                     ReturnNode returnNode = (ReturnNode) duplicates.get(n);
2382                     FixedWithNextNode predecessor = (FixedWithNextNode) returnNode.predecessor();
2383                     calleeReturnDataList.add(new ReturnToCallerData(returnNode.result(), predecessor));
2384                     predecessor.setNext(null);
2385                     returnNode.safeDelete();
2386                 }
2387 
2388                 // Merge multiple returns
2389                 processCalleeReturn(targetMethod, inlineScope, calleeReturnDataList);
2390 
2391                 // Exiting this scope causes processing of the placeholder frame states.
2392             }
2393 
2394             if (withException != null &amp;&amp; withException.isAlive()) {
2395                 // Connect exception edge into main graph
2396                 AbstractBeginNode exceptionEdge = handleException(null, bci(), false);
2397                 withException.setExceptionEdge(exceptionEdge);
2398             }
2399 
2400             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
2401             return true;
2402         } catch (Throwable t) {
2403             throw debug.handle(t);
2404         }
2405     }
2406 
2407     private static UnmodifiableEconomicMap&lt;Node, Node&gt; inlineMethodSubstitution(StructuredGraph replaceeGraph, StructuredGraph snippet,
2408                     EconomicMap&lt;Node, Node&gt; replacementsMap) {
2409         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {
2410             InliningLog log = replaceeGraph.getInliningLog();
2411             if (oldNode == null) {
2412                 log.trackNewCallsite(newNode);
2413             }
2414         })) {
2415             StartNode entryPointNode = snippet.start();
2416             ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());
2417             for (Node node : snippet.getNodes()) {
2418                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {
2419                     nodes.add(node);
2420                 }
2421             }
2422             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacementsMap);
2423             if (scope != null) {
2424                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());
2425             }
2426             return duplicates;
2427         }
2428     }
2429 
2430     @Override
2431     public boolean intrinsify(BytecodeProvider intrinsicBytecodeProvider, ResolvedJavaMethod targetMethod, ResolvedJavaMethod substitute, InvocationPlugin.Receiver receiver, ValueNode[] args) {
2432         if (receiver != null) {
2433             receiver.get();
2434         }
2435         boolean res = inline(targetMethod, substitute, intrinsicBytecodeProvider, args);
2436         assert res : &quot;failed to inline &quot; + substitute;
2437         return res;
2438     }
2439 
2440     private boolean inline(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, BytecodeProvider intrinsicBytecodeProvider, ValueNode[] args) {
2441         try (InliningLog.RootScope scope = graph.getInliningLog().openRootScope(targetMethod, bci())) {
2442             IntrinsicContext intrinsic = this.intrinsicContext;
2443 
2444             if (intrinsic == null &amp;&amp; !graphBuilderConfig.insertFullInfopoints() &amp;&amp;
2445                             targetMethod.equals(inlinedMethod) &amp;&amp;
2446                             (targetMethod.getModifiers() &amp; (STATIC | SYNCHRONIZED)) == 0 &amp;&amp;
2447                             tryFastInlineAccessor(args, targetMethod)) {
2448                 return true;
2449             }
2450 
2451             if (intrinsic != null &amp;&amp; intrinsic.isCallToOriginal(targetMethod)) {
2452                 if (intrinsic.isCompilationRoot()) {
2453                     // A root compiled intrinsic needs to deoptimize
2454                     // if the slow path is taken. During frame state
2455                     // assignment, the deopt node will get its stateBefore
2456                     // from the start node of the intrinsic
2457                     append(new DeoptimizeNode(InvalidateRecompile, RuntimeConstraint));
2458                     printInlining(targetMethod, inlinedMethod, true, &quot;compilation root (bytecode parsing)&quot;);
2459                     if (scope != null) {
2460                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;compilation root&quot;);
2461                     }
2462                     return true;
2463                 } else {
2464                     if (intrinsic.getOriginalMethod().isNative()) {
2465                         printInlining(targetMethod, inlinedMethod, false, &quot;native method (bytecode parsing)&quot;);
2466                         if (scope != null) {
2467                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;native method&quot;);
2468                         }
2469                         return false;
2470                     }
2471                     if (canInlinePartialIntrinsicExit()) {
2472                         // Otherwise inline the original method. Any frame state created
2473                         // during the inlining will exclude frame(s) in the
2474                         // intrinsic method (see FrameStateBuilder.create(int bci)).
2475                         notifyBeforeInline(inlinedMethod);
2476                         printInlining(targetMethod, inlinedMethod, true, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2477                         if (scope != null) {
2478                             graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2479                         }
2480                         parseAndInlineCallee(intrinsic.getOriginalMethod(), args, null);
2481                         notifyAfterInline(inlinedMethod);
2482                         return true;
2483                     } else {
2484                         printInlining(targetMethod, inlinedMethod, false, &quot;partial intrinsic exit (bytecode parsing)&quot;);
2485                         if (scope != null) {
2486                             graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;partial intrinsic exit&quot;);
2487                         }
2488                         return false;
2489                     }
2490                 }
2491             } else {
2492                 boolean isIntrinsic = intrinsicBytecodeProvider != null;
2493                 if (intrinsic == null &amp;&amp; isIntrinsic) {
2494                     assert !inlinedMethod.equals(targetMethod);
2495                     intrinsic = new IntrinsicContext(targetMethod, inlinedMethod, intrinsicBytecodeProvider, INLINE_DURING_PARSING);
2496                 }
2497                 if (inlinedMethod.hasBytecodes()) {
2498                     notifyBeforeInline(inlinedMethod);
2499                     printInlining(targetMethod, inlinedMethod, true, &quot;inline method (bytecode parsing)&quot;);
2500                     if (scope != null) {
2501                         graph.getInliningLog().addDecision(scope.getInvoke(), true, &quot;GraphBuilderPhase&quot;, null, null, &quot;inline method&quot;);
2502                     }
2503                     parseAndInlineCallee(inlinedMethod, args, intrinsic);
2504                     notifyAfterInline(inlinedMethod);
2505                 } else {
2506                     printInlining(targetMethod, inlinedMethod, false, &quot;no bytecodes (abstract or native) (bytecode parsing)&quot;);
2507                     if (scope != null) {
2508                         graph.getInliningLog().addDecision(scope.getInvoke(), false, &quot;GraphBuilderPhase&quot;, null, null, &quot;no bytecodes (abstract or native)&quot;);
2509                     }
2510                     return false;
2511                 }
2512             }
2513             return true;
2514         }
2515     }
2516 
2517     protected void notifyBeforeInline(ResolvedJavaMethod inlinedMethod) {
2518         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2519             plugin.notifyBeforeInline(inlinedMethod);
2520         }
2521     }
2522 
2523     protected void notifyAfterInline(ResolvedJavaMethod inlinedMethod) {
2524         for (InlineInvokePlugin plugin : graphBuilderConfig.getPlugins().getInlineInvokePlugins()) {
2525             plugin.notifyAfterInline(inlinedMethod);
2526         }
2527     }
2528 
2529     /**
2530      * Determines if a partial intrinsic exit (i.e., a call to the original method within an
2531      * intrinsic) can be inlined.
2532      */
2533     protected boolean canInlinePartialIntrinsicExit() {
2534         return InlinePartialIntrinsicExitDuringParsing.getValue(options) &amp;&amp; !IS_BUILDING_NATIVE_IMAGE &amp;&amp; method.getAnnotation(Snippet.class) == null;
2535     }
2536 
2537     private void printInlining(ResolvedJavaMethod targetMethod, ResolvedJavaMethod inlinedMethod, boolean success, String msg) {
2538         if (success) {
2539             if (TraceInlineDuringParsing.getValue(options) || TraceParserPlugins.getValue(options)) {
2540                 if (targetMethod.equals(inlinedMethod)) {
2541                     traceWithContext(&quot;inlining call to %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;));
2542                 } else {
2543                     traceWithContext(&quot;inlining call to %s as intrinsic for %s&quot;, inlinedMethod.format(&quot;%h.%n(%p)&quot;), targetMethod.format(&quot;%h.%n(%p)&quot;));
2544                 }
2545             }
2546         }
2547         if (HotSpotPrintInlining.getValue(options)) {
2548             if (targetMethod.equals(inlinedMethod)) {
2549                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s&quot;, msg);
2550             } else {
2551                 Util.printInlining(inlinedMethod, bci(), getDepth(), success, &quot;%s intrinsic for %s&quot;, msg, targetMethod.format(&quot;%h.%n(%p)&quot;));
2552             }
2553         }
2554     }
2555 
2556     /**
2557      * Prints a line to {@link TTY} with a prefix indicating the current parse context. The prefix
2558      * is of the form:
2559      *
2560      * &lt;pre&gt;
2561      * {SPACE * n} {name of method being parsed} &quot;(&quot; {file name} &quot;:&quot; {line number} &quot;)&quot;
2562      * &lt;/pre&gt;
2563      *
2564      * where {@code n} is the current inlining depth.
2565      *
2566      * @param format a format string
2567      * @param args arguments to the format string
2568      */
2569 
2570     protected void traceWithContext(String format, Object... args) {
2571         StackTraceElement where = code.asStackTraceElement(bci());
2572         String s = format(&quot;%s%s (%s:%d) %s&quot;, nSpaces(getDepth()), method.isConstructor() ? method.format(&quot;%h.%n&quot;) : method.getName(), where.getFileName(), where.getLineNumber(),
2573                         format(format, args));
2574         TTY.println(s);
2575     }
2576 
2577     protected RuntimeException throwParserError(Throwable e) {
2578         if (e instanceof BytecodeParserError) {
2579             throw (BytecodeParserError) e;
2580         }
2581         BytecodeParser bp = this;
2582         BytecodeParserError res = new BytecodeParserError(e);
2583         while (bp != null) {
2584             res.addContext(&quot;parsing &quot; + bp.code.asStackTraceElement(bp.bci()));
2585             bp = bp.parent;
2586         }
2587         throw res;
2588     }
2589 
2590     protected void parseAndInlineCallee(ResolvedJavaMethod targetMethod, ValueNode[] args, IntrinsicContext calleeIntrinsicContext) {
2591         FixedWithNextNode calleeBeforeUnwindNode = null;
2592         ValueNode calleeUnwindValue = null;
2593 
2594         try (InliningScope s = parsingIntrinsic() ? null
2595                         : (calleeIntrinsicContext != null ? new IntrinsicScope(this, targetMethod, args)
2596                                         : new InliningScope(this, targetMethod, args))) {
2597             BytecodeParser parser = graphBuilderInstance.createBytecodeParser(graph, this, targetMethod, INVOCATION_ENTRY_BCI, calleeIntrinsicContext);
2598             boolean targetIsSubstitution = targetMethod.isAnnotationPresent(MethodSubstitution.class);
2599             FrameStateBuilder startFrameState = new FrameStateBuilder(parser, parser.code, graph, graphBuilderConfig.retainLocalVariables() &amp;&amp; !targetIsSubstitution);
2600             if (!targetMethod.isStatic()) {
2601                 args[0] = nullCheckedValue(args[0]);
2602             }
2603             startFrameState.initializeFromArgumentsArray(args);
2604             parser.build(this.lastInstr, startFrameState);
2605 
2606             List&lt;ReturnToCallerData&gt; calleeReturnDataList = parser.returnDataList;
2607 
2608             /*
2609              * Propagate any side effects into the caller when parsing intrinsics.
2610              */
2611             if (parser.frameState.isAfterSideEffect() &amp;&amp; parsingIntrinsic()) {
2612                 for (StateSplit sideEffect : parser.frameState.sideEffects()) {
2613                     frameState.addSideEffect(sideEffect);
2614                 }
2615             }
2616 
2617             processCalleeReturn(targetMethod, s, calleeReturnDataList);
2618 
2619             calleeBeforeUnwindNode = parser.getBeforeUnwindNode();
2620             if (calleeBeforeUnwindNode != null) {
2621                 calleeUnwindValue = parser.getUnwindValue();
2622                 assert calleeUnwindValue != null;
2623             }
2624         }
2625 
2626         /*
2627          * Method handleException will call createTarget, which wires this exception edge to the
2628          * corresponding exception dispatch block in the caller. In the case where it wires to the
2629          * caller&#39;s unwind block, any FrameState created meanwhile, e.g., FrameState for
2630          * LoopExitNode, would be instantiated with AFTER_EXCEPTION_BCI. Such frame states should
2631          * not be fixed by IntrinsicScope.close, as they denote the states of the caller. Thus, the
2632          * following code should be placed outside the IntrinsicScope, so that correctly created
2633          * FrameStates are not replaced.
2634          */
2635         if (calleeBeforeUnwindNode != null) {
2636             calleeBeforeUnwindNode.setNext(handleException(calleeUnwindValue, bci(), false));
2637         }
2638     }
2639 
2640     private ValueNode processCalleeReturn(ResolvedJavaMethod targetMethod, InliningScope inliningScope, List&lt;ReturnToCallerData&gt; calleeReturnDataList) {
2641         if (calleeReturnDataList == null) {
2642             /* Callee does not return. */
2643             lastInstr = null;
2644         } else {
2645             ValueNode calleeReturnValue;
2646             MergeNode returnMergeNode = null;
2647             if (inliningScope != null) {
2648                 inliningScope.returnDataList = calleeReturnDataList;
2649             }
2650             if (calleeReturnDataList.size() == 1) {
2651                 /* Callee has a single return, we can continue parsing at that point. */
2652                 ReturnToCallerData singleReturnData = calleeReturnDataList.get(0);
2653                 lastInstr = singleReturnData.beforeReturnNode;
2654                 calleeReturnValue = singleReturnData.returnValue;
2655             } else {
2656                 assert calleeReturnDataList.size() &gt; 1;
2657                 /* Callee has multiple returns, we need to insert a control flow merge. */
2658                 returnMergeNode = graph.add(new MergeNode());
2659                 calleeReturnValue = ValueMergeUtil.mergeValueProducers(returnMergeNode, calleeReturnDataList, returnData -&gt; returnData.beforeReturnNode, returnData -&gt; returnData.returnValue);
2660             }
2661 
2662             if (calleeReturnValue != null) {
2663                 frameState.push(targetMethod.getSignature().getReturnKind().getStackKind(), calleeReturnValue);
2664             }
2665             if (returnMergeNode != null) {
2666                 returnMergeNode.setStateAfter(createFrameState(stream.nextBCI(), returnMergeNode));
2667                 lastInstr = finishInstruction(returnMergeNode, frameState);
2668             }
2669             return calleeReturnValue;
2670         }
2671         return null;
2672     }
2673 
2674     public MethodCallTargetNode createMethodCallTarget(InvokeKind invokeKind, ResolvedJavaMethod targetMethod, ValueNode[] args, StampPair returnStamp, JavaTypeProfile profile) {
2675         return new MethodCallTargetNode(invokeKind, targetMethod, args, returnStamp, profile);
2676     }
2677 
2678     protected InvokeNode createInvoke(int invokeBci, CallTargetNode callTarget, JavaKind resultType) {
2679         InvokeNode invoke = append(new InvokeNode(callTarget, invokeBci));
2680         frameState.pushReturn(resultType, invoke);
2681         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2682         return invoke;
2683     }
2684 
2685     protected InvokeWithExceptionNode createInvokeWithException(int invokeBci, CallTargetNode callTarget, JavaKind resultType, ExceptionEdgeAction exceptionEdgeAction) {
2686         if (currentBlock != null &amp;&amp; stream.nextBCI() &gt; currentBlock.endBci) {
2687             /*
2688              * Clear non-live locals early so that the exception handler entry gets the cleared
2689              * state.
2690              */
2691             frameState.clearNonLiveLocals(currentBlock, liveness, false);
2692         }
2693 
2694         AbstractBeginNode exceptionEdge = handleException(null, bci(), exceptionEdgeAction == ExceptionEdgeAction.INCLUDE_AND_DEOPTIMIZE);
2695         InvokeWithExceptionNode invoke = append(new InvokeWithExceptionNode(callTarget, exceptionEdge, invokeBci));
2696         frameState.pushReturn(resultType, invoke);
2697         invoke.setStateAfter(createFrameState(stream.nextBCI(), invoke));
2698         return invoke;
2699     }
2700 
2701     protected void genReturn(ValueNode returnVal, JavaKind returnKind) {
2702         if (parsingIntrinsic() &amp;&amp; returnVal != null) {
2703 
2704             if (returnVal instanceof StateSplit) {
2705                 StateSplit stateSplit = (StateSplit) returnVal;
2706                 FrameState stateAfter = stateSplit.stateAfter();
2707                 if (stateSplit.hasSideEffect()) {
2708                     assert stateSplit != null;
2709                     if (stateAfter.bci == BytecodeFrame.AFTER_BCI) {
2710                         assert stateAfter.hasExactlyOneUsage();
2711                         assert stateAfter.usages().first() == stateSplit;
2712                         FrameState state;
2713                         if (returnVal.getStackKind() == JavaKind.Illegal) {
2714                             // This should only occur when Fold and NodeIntrinsic plugins are
2715                             // deferred. Their return value might not be a Java type and in that
2716                             // case this can&#39;t be the final AFTER_BCI so just create a FrameState
2717                             // without a return value on the top of stack.
2718                             assert stateSplit instanceof Invoke;
2719                             ResolvedJavaMethod targetMethod = ((Invoke) stateSplit).getTargetMethod();
2720                             assert targetMethod != null &amp;&amp; (targetMethod.getAnnotation(Fold.class) != null || targetMethod.getAnnotation(Node.NodeIntrinsic.class) != null);
2721                             state = new FrameState(BytecodeFrame.AFTER_BCI);
2722                         } else {
2723                             state = new FrameState(BytecodeFrame.AFTER_BCI, returnVal);
2724                         }
2725                         stateAfter.replaceAtUsages(graph.add(state));
2726                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
2727                     } else {
2728                         /*
2729                          * This must be the return value from within a partial intrinsification.
2730                          */
2731                         assert !BytecodeFrame.isPlaceholderBci(stateAfter.bci) || intrinsicContext.isDeferredInvoke(stateSplit);
2732                     }
2733                 } else {
2734                     assert stateAfter == null;
2735                 }
2736             }
2737         }
2738 
2739         ValueNode realReturnVal = processReturnValue(returnVal, returnKind);
2740 
2741         frameState.setRethrowException(false);
2742         frameState.clearStack();
2743         beforeReturn(realReturnVal, returnKind);
2744         if (parent == null) {
2745             append(new ReturnNode(realReturnVal));
2746         } else {
2747             if (returnDataList == null) {
2748                 returnDataList = new ArrayList&lt;&gt;();
2749             }
2750             returnDataList.add(new ReturnToCallerData(realReturnVal, lastInstr));
2751             lastInstr = null;
2752         }
2753     }
2754 
2755     private ValueNode processReturnValue(ValueNode value, JavaKind kind) {
2756         JavaKind returnKind = method.getSignature().getReturnKind();
2757         if (kind != returnKind) {
2758             // sub-word integer
2759             assert returnKind.isNumericInteger() &amp;&amp; returnKind.getStackKind() == JavaKind.Int;
2760             IntegerStamp stamp = (IntegerStamp) value.stamp(NodeView.DEFAULT);
2761 
2762             // the bytecode verifier doesn&#39;t check that the value is in the correct range
2763             if (stamp.lowerBound() &lt; returnKind.getMinValue() || returnKind.getMaxValue() &lt; stamp.upperBound()) {
2764                 return maskSubWordValue(value, returnKind);
2765             }
2766         }
2767 
2768         return value;
2769     }
2770 
2771     private void beforeReturn(ValueNode x, JavaKind kind) {
2772         if (graph.method() != null &amp;&amp; graph.method().isJavaLangObjectInit()) {
2773             /*
2774              * Get the receiver from the initial state since bytecode rewriting could do arbitrary
2775              * things to the state of the locals.
2776              */
2777             ValueNode receiver = graph.start().stateAfter().localAt(0);
2778             assert receiver != null &amp;&amp; receiver.getStackKind() == JavaKind.Object;
2779             if (RegisterFinalizerNode.mayHaveFinalizer(receiver, graph.getAssumptions())) {
2780                 append(new RegisterFinalizerNode(receiver));
2781             }
2782         }
2783         genInfoPointNode(InfopointReason.METHOD_END, x);
2784         if (finalBarrierRequired) {
2785             assert originalReceiver != null;
2786             /*
2787              * When compiling an OSR with a final field store, don&#39;t bother tracking the original
2788              * receiver since the receiver cannot be EA&#39;ed.
2789              */
2790             append(new FinalFieldBarrierNode(entryBCI == INVOCATION_ENTRY_BCI ? originalReceiver : null));
2791         }
2792         synchronizedEpilogue(BytecodeFrame.AFTER_BCI, x, kind);
2793         if (method.isSynchronized()) {
2794             finishPrepare(lastInstr, BytecodeFrame.AFTER_BCI, frameState);
2795         }
2796     }
2797 
2798     protected MonitorEnterNode createMonitorEnterNode(ValueNode x, MonitorIdNode monitorId) {
2799         return new MonitorEnterNode(x, monitorId);
2800     }
2801 
2802     protected void genMonitorEnter(ValueNode x, int bci) {
2803         MonitorIdNode monitorId = graph.add(new MonitorIdNode(frameState.lockDepth(true)));
2804         MonitorEnterNode monitorEnter = append(createMonitorEnterNode(x, monitorId));
2805         frameState.pushLock(x, monitorId);
2806         monitorEnter.setStateAfter(createFrameState(bci, monitorEnter));
2807     }
2808 
2809     protected void genMonitorExit(ValueNode x, ValueNode escapedValue, int bci) {
2810         if (frameState.lockDepth(false) == 0) {
2811             throw bailout(&quot;unbalanced monitors: too many exits&quot;);
2812         }
2813         MonitorIdNode monitorId = frameState.peekMonitorId();
2814         ValueNode lockedObject = frameState.popLock();
2815         ValueNode originalLockedObject = GraphUtil.originalValue(lockedObject, false);
2816         ValueNode originalX = GraphUtil.originalValue(x, false);
2817         if (originalLockedObject != originalX) {
2818             throw bailout(String.format(&quot;unbalanced monitors: mismatch at monitorexit, %s != %s&quot;, originalLockedObject, originalX));
2819         }
2820         MonitorExitNode monitorExit = append(new MonitorExitNode(lockedObject, monitorId, escapedValue));
2821         monitorExit.setStateAfter(createFrameState(bci, monitorExit));
2822     }
2823 
2824     protected void genJsr(int dest) {
2825         BciBlock successor = currentBlock.getJsrSuccessor();
2826         assert successor.startBci == dest : successor.startBci + &quot; != &quot; + dest + &quot; @&quot; + bci();
2827         JsrScope scope = currentBlock.getJsrScope();
2828         int nextBci = getStream().nextBCI();
2829         if (!successor.getJsrScope().pop().equals(scope)) {
2830             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2831         }
2832         if (successor.getJsrScope().nextReturnAddress() != nextBci) {
2833             throw new JsrNotSupportedBailout(&quot;unstructured control flow (internal limitation)&quot;);
2834         }
2835         ConstantNode nextBciNode = getJsrConstant(nextBci);
2836         frameState.push(JavaKind.Object, nextBciNode);
2837         appendGoto(successor);
2838     }
2839 
2840     protected void genRet(int localIndex) {
2841         BciBlock successor = currentBlock.getRetSuccessor();
2842         ValueNode local = frameState.loadLocal(localIndex, JavaKind.Object);
2843         JsrScope scope = currentBlock.getJsrScope();
2844         int retAddress = scope.nextReturnAddress();
2845         ConstantNode returnBciNode = getJsrConstant(retAddress);
2846         LogicNode guard = IntegerEqualsNode.create(getConstantReflection(), getMetaAccess(), options, null, local, returnBciNode, NodeView.DEFAULT);
2847         if (!guard.isTautology()) {
2848             throw new JsrNotSupportedBailout(&quot;cannot statically decide jsr return address &quot; + local);
2849         }
2850         if (!successor.getJsrScope().equals(scope.pop())) {
2851             throw new JsrNotSupportedBailout(&quot;unstructured control flow (ret leaves more than one scope)&quot;);
2852         }
2853         appendGoto(successor);
2854     }
2855 
2856     private ConstantNode getJsrConstant(long bci) {
2857         JavaConstant nextBciConstant = new RawConstant(bci);
2858         Stamp nextBciStamp = StampFactory.forConstant(nextBciConstant);
2859         ConstantNode nextBciNode = new ConstantNode(nextBciConstant, nextBciStamp);
2860         return graph.unique(nextBciNode);
2861     }
2862 
2863     protected void genIntegerSwitch(ValueNode value, ArrayList&lt;BciBlock&gt; actualSuccessors, int[] keys, double[] keyProbabilities, int[] keySuccessors) {
2864         if (value.isConstant()) {
2865             JavaConstant constant = (JavaConstant) value.asConstant();
2866             int constantValue = constant.asInt();
2867             for (int i = 0; i &lt; keys.length; ++i) {
2868                 if (keys[i] == constantValue) {
2869                     appendGoto(actualSuccessors.get(keySuccessors[i]));
2870                     return;
2871                 }
2872             }
2873             appendGoto(actualSuccessors.get(keySuccessors[keys.length]));
2874         } else {
2875             this.controlFlowSplit = true;
2876             double[] successorProbabilities = successorProbabilites(actualSuccessors.size(), keySuccessors, keyProbabilities);
2877             IntegerSwitchNode switchNode = append(new IntegerSwitchNode(value, actualSuccessors.size(), keys, keyProbabilities, keySuccessors));
2878             for (int i = 0; i &lt; actualSuccessors.size(); i++) {
2879                 switchNode.setBlockSuccessor(i, createBlockTarget(successorProbabilities[i], actualSuccessors.get(i), frameState));
2880             }
2881         }
2882     }
2883 
2884     /**
2885      * Helper function that sums up the probabilities of all keys that lead to a specific successor.
2886      *
2887      * @return an array of size successorCount with the accumulated probability for each successor.
2888      */
2889     private static double[] successorProbabilites(int successorCount, int[] keySuccessors, double[] keyProbabilities) {
2890         double[] probability = new double[successorCount];
2891         for (int i = 0; i &lt; keySuccessors.length; i++) {
2892             probability[keySuccessors[i]] += keyProbabilities[i];
2893         }
2894         return probability;
2895     }
2896 
2897     protected ConstantNode appendConstant(JavaConstant constant) {
2898         assert constant != null;
2899         return ConstantNode.forConstant(constant, getMetaAccess(), graph);
2900     }
2901 
2902     @Override
2903     public &lt;T extends ValueNode&gt; T append(T v) {
2904         assert !graph.trackNodeSourcePosition() || graph.currentNodeSourcePosition() != null || currentBlock == blockMap.getUnwindBlock() || currentBlock instanceof ExceptionDispatchBlock;
2905         if (v.graph() != null) {
2906             return v;
2907         }
2908         T added = graph.addOrUniqueWithInputs(v);
2909         if (added == v) {
2910             updateLastInstruction(v);
2911         }
2912         return added;
2913     }
2914 
2915     private &lt;T extends ValueNode&gt; void updateLastInstruction(T v) {
2916         if (v instanceof FixedNode) {
2917             FixedNode fixedNode = (FixedNode) v;
2918             if (lastInstr != null) {
2919                 lastInstr.setNext(fixedNode);
2920             }
2921             if (fixedNode instanceof FixedWithNextNode) {
2922                 FixedWithNextNode fixedWithNextNode = (FixedWithNextNode) fixedNode;
2923                 assert fixedWithNextNode.next() == null : &quot;cannot append instruction to instruction which isn&#39;t end&quot;;
2924                 lastInstr = fixedWithNextNode;
2925             } else {
2926                 lastInstr = null;
2927             }
2928         }
2929     }
2930 
2931     private Target checkLoopExit(Target target, BciBlock targetBlock) {
2932         if (currentBlock != null) {
2933             long exits = currentBlock.loops &amp; ~targetBlock.loops;
2934             if (exits != 0) {
2935                 LoopExitNode firstLoopExit = null;
2936                 LoopExitNode lastLoopExit = null;
2937 
2938                 int pos = 0;
2939                 ArrayList&lt;BciBlock&gt; exitLoops = new ArrayList&lt;&gt;(Long.bitCount(exits));
2940                 do {
2941                     long lMask = 1L &lt;&lt; pos;
2942                     if ((exits &amp; lMask) != 0) {
2943                         exitLoops.add(blockMap.getLoopHeader(pos));
2944                         exits &amp;= ~lMask;
2945                     }
2946                     pos++;
2947                 } while (exits != 0);
2948 
2949                 Collections.sort(exitLoops, new Comparator&lt;BciBlock&gt;() {
2950 
2951                     @Override
2952                     public int compare(BciBlock o1, BciBlock o2) {
2953                         return Long.bitCount(o2.loops) - Long.bitCount(o1.loops);
2954                     }
2955                 });
2956 
2957                 int bci = targetBlock.startBci;
2958                 if (targetBlock instanceof ExceptionDispatchBlock) {
2959                     bci = ((ExceptionDispatchBlock) targetBlock).deoptBci;
2960                 }
2961                 FrameStateBuilder newState = target.state.copy();
2962                 for (BciBlock loop : exitLoops) {
2963                     LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(loop);
2964                     LoopExitNode loopExit = graph.add(new LoopExitNode(loopBegin));
2965                     if (lastLoopExit != null) {
2966                         lastLoopExit.setNext(loopExit);
2967                     }
2968                     if (firstLoopExit == null) {
2969                         firstLoopExit = loopExit;
2970                     }
2971                     lastLoopExit = loopExit;
2972                     debug.log(&quot;Target %s Exits %s, scanning framestates...&quot;, targetBlock, loop);
2973                     newState.clearNonLiveLocals(targetBlock, liveness, true);
2974                     newState.insertLoopProxies(loopExit, getEntryState(loop));
2975                     loopExit.setStateAfter(newState.create(bci, loopExit));
2976                 }
2977 
2978                 // Fortify: Suppress Null Dereference false positive
2979                 assert lastLoopExit != null;
2980 
2981                 if (target.originalEntry == null) {
2982                     lastLoopExit.setNext(target.entry);
2983                     return new Target(firstLoopExit, newState, target.entry);
2984                 } else {
2985                     target.originalEntry.replaceAtPredecessor(firstLoopExit);
2986                     lastLoopExit.setNext(target.originalEntry);
2987                     return new Target(target.entry, newState, target.originalEntry);
2988                 }
2989             }
2990         }
2991         return target;
2992     }
2993 
2994     private Target checkUnwind(FixedNode target, BciBlock targetBlock, FrameStateBuilder state) {
2995         if (targetBlock != blockMap.getUnwindBlock()) {
2996             return new Target(target, state);
2997         }
2998         FrameStateBuilder newState = state;
2999         newState = newState.copy();
3000         newState.setRethrowException(false);
3001         if (!method.isSynchronized()) {
3002             return new Target(target, newState);
3003         }
3004         FixedWithNextNode originalLast = lastInstr;
3005         FrameStateBuilder originalState = frameState;
3006         BeginNode holder = new BeginNode();
3007         lastInstr = graph.add(holder);
3008         frameState = newState;
3009         assert frameState.stackSize() == 1;
3010         ValueNode exception = frameState.peekObject();
3011         synchronizedEpilogue(BytecodeFrame.AFTER_EXCEPTION_BCI, exception, JavaKind.Void);
3012         lastInstr.setNext(target);
3013 
3014         lastInstr = originalLast;
3015         frameState = originalState;
3016 
3017         FixedNode result = holder.next();
3018         holder.setNext(null);
3019         holder.safeDelete();
3020         return new Target(result, newState, target);
3021     }
3022 
3023     private FrameStateBuilder getEntryState(BciBlock block) {
3024         return entryStateArray[block.id];
3025     }
3026 
3027     private void setEntryState(BciBlock block, FrameStateBuilder entryState) {
3028         this.entryStateArray[block.id] = entryState;
3029     }
3030 
3031     private void setFirstInstruction(BciBlock block, FixedWithNextNode firstInstruction) {
3032         this.firstInstructionArray[block.id] = firstInstruction;
3033     }
3034 
3035     private FixedWithNextNode getFirstInstruction(BciBlock block) {
3036         return firstInstructionArray[block.id];
3037     }
3038 
3039     private FixedNode createTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3040         assert probability &gt;= 0 &amp;&amp; probability &lt;= 1.01 : probability;
3041         if (isNeverExecutedCode(probability)) {
3042             return graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3043         } else {
3044             assert block != null;
3045             return createTarget(block, stateAfter);
3046         }
3047     }
3048 
3049     private FixedNode createTarget(BciBlock block, FrameStateBuilder state) {
3050         return createTarget(block, state, false, false);
3051     }
3052 
3053     @SuppressWarnings(&quot;try&quot;)
3054     private FixedNode createTarget(BciBlock block, FrameStateBuilder state, boolean canReuseInstruction, boolean canReuseState) {
3055         assert block != null &amp;&amp; state != null;
3056         assert !block.isExceptionEntry() || state.stackSize() == 1;
3057 
3058         try (DebugCloseable context = openNodeContext(state, block.startBci)) {
3059             if (getFirstInstruction(block) == null) {
3060                 /*
3061                  * This is the first time we see this block as a branch target. Create and return a
3062                  * placeholder that later can be replaced with a MergeNode when we see this block
3063                  * again.
3064                  */
3065                 if (canReuseInstruction &amp;&amp; (block.getPredecessorCount() == 1 || !controlFlowSplit) &amp;&amp; !block.isLoopHeader() &amp;&amp; (currentBlock.loops &amp; ~block.loops) == 0 &amp;&amp;
3066                                 currentBlock.getJsrScope() == block.getJsrScope()) {
3067                     /*
3068                      * If we know that no BeginNode is necessary, then we can avoid allocating and
3069                      * later removing that node. This is strictly a performance optimization:
3070                      * unnecessary BeginNode are allowed and will be removed later on. We need to be
3071                      * careful though because the predecessor information is not always enough: when
3072                      * the loop level changes, we always need a BeginNode. Also, JSR scope changes
3073                      * required a BeginNode because the predecessors coming from RET bytecodes are
3074                      * not reflected in the predecessor count.
3075                      */
3076                     setFirstInstruction(block, lastInstr);
3077                     lastInstr = null;
3078                 } else {
3079                     setFirstInstruction(block, graph.add(new BeginNode()));
3080                 }
3081                 Target target = checkUnwind(getFirstInstruction(block), block, state);
3082                 target = checkLoopExit(target, block);
3083                 FixedNode result = target.entry;
3084                 FrameStateBuilder currentEntryState = target.state == state ? (canReuseState ? state : state.copy()) : target.state;
3085                 setEntryState(block, currentEntryState);
3086                 currentEntryState.clearNonLiveLocals(block, liveness, true);
3087 
3088                 debug.log(&quot;createTarget %s: first visit, result: %s&quot;, block, result);
3089                 return result;
3090             }
3091 
3092             if (getFirstInstruction(block) instanceof LoopBeginNode) {
3093                 assert (block.isLoopHeader() &amp;&amp; currentBlock.getId() &gt;= block.getId()) : &quot;must be backward branch&quot;;
3094                 /*
3095                  * Backward loop edge. We need to create a special LoopEndNode and merge with the
3096                  * loop begin node created before.
3097                  */
3098                 LoopBeginNode loopBegin = (LoopBeginNode) getFirstInstruction(block);
3099                 LoopEndNode loopEnd = graph.add(new LoopEndNode(loopBegin));
3100                 Target target = checkLoopExit(new Target(loopEnd, state), block);
3101                 FixedNode result = target.entry;
3102                 getEntryState(block).merge(loopBegin, target.state);
3103 
3104                 debug.log(&quot;createTarget %s: merging backward branch to loop header %s, result: %s&quot;, block, loopBegin, result);
3105                 return result;
3106             }
3107             assert currentBlock == null || currentBlock.getId() &lt; block.getId() : &quot;must not be backward branch&quot;;
3108             assert getFirstInstruction(block).next() == null : &quot;bytecodes already parsed for block&quot;;
3109 
3110             if (getFirstInstruction(block) instanceof AbstractBeginNode &amp;&amp; !(getFirstInstruction(block) instanceof AbstractMergeNode)) {
3111                 /*
3112                  * This is the second time we see this block. Create the actual MergeNode and the
3113                  * End Node for the already existing edge.
3114                  */
3115                 AbstractBeginNode beginNode = (AbstractBeginNode) getFirstInstruction(block);
3116 
3117                 // The EndNode for the already existing edge.
3118                 EndNode end = graph.add(new EndNode());
3119                 // The MergeNode that replaces the placeholder.
3120                 AbstractMergeNode mergeNode = graph.add(new MergeNode());
3121                 FixedNode next = beginNode.next();
3122 
3123                 if (beginNode.predecessor() instanceof ControlSplitNode) {
3124                     beginNode.setNext(end);
3125                 } else {
3126                     beginNode.replaceAtPredecessor(end);
3127                     beginNode.safeDelete();
3128                 }
3129 
3130                 mergeNode.addForwardEnd(end);
3131                 mergeNode.setNext(next);
3132 
3133                 setFirstInstruction(block, mergeNode);
3134             }
3135 
3136             AbstractMergeNode mergeNode = (AbstractMergeNode) getFirstInstruction(block);
3137 
3138             // The EndNode for the newly merged edge.
3139             EndNode newEnd = graph.add(new EndNode());
3140             Target target = checkLoopExit(checkUnwind(newEnd, block, state), block);
3141             FixedNode result = target.entry;
3142             getEntryState(block).merge(mergeNode, target.state);
3143             mergeNode.addForwardEnd(newEnd);
3144 
3145             debug.log(&quot;createTarget %s: merging state, result: %s&quot;, block, result);
3146             return result;
3147         }
3148     }
3149 
3150     /**
3151      * Returns a block begin node with the specified state. If the specified probability is 0, the
3152      * block deoptimizes immediately.
3153      */
3154     private AbstractBeginNode createBlockTarget(double probability, BciBlock block, FrameStateBuilder stateAfter) {
3155         FixedNode target = createTarget(probability, block, stateAfter);
3156         AbstractBeginNode begin = BeginNode.begin(target);
3157 
3158         assert !(target instanceof DeoptimizeNode &amp;&amp; begin instanceof BeginStateSplitNode &amp;&amp;
3159                         ((BeginStateSplitNode) begin).stateAfter() != null) : &quot;We are not allowed to set the stateAfter of the begin node,&quot; +
3160                                         &quot; because we have to deoptimize to a bci _before_ the actual if, so that the interpreter can update the profiling information.&quot;;
3161         return begin;
3162     }
3163 
3164     private ValueNode synchronizedObject(FrameStateBuilder state, ResolvedJavaMethod target) {
3165         if (target.isStatic()) {
3166             return appendConstant(getConstantReflection().asJavaClass(target.getDeclaringClass()));
3167         } else {
3168             return state.loadLocal(0, JavaKind.Object);
3169         }
3170     }
3171 
3172     @SuppressWarnings(&quot;try&quot;)
3173     protected void processBlock(BciBlock block) {
3174         // Ignore blocks that have no predecessors by the time their bytecodes are parsed
3175         FixedWithNextNode firstInstruction = getFirstInstruction(block);
3176         if (firstInstruction == null) {
3177             debug.log(&quot;Ignoring block %s&quot;, block);
3178             return;
3179         }
3180         try (Indent indent = debug.logAndIndent(&quot;Parsing block %s  firstInstruction: %s  loopHeader: %b&quot;, block, firstInstruction, block.isLoopHeader())) {
3181 
3182             lastInstr = firstInstruction;
3183             frameState = getEntryState(block);
3184             setCurrentFrameState(frameState);
3185             currentBlock = block;
3186 
3187             if (block != blockMap.getUnwindBlock() &amp;&amp; !(block instanceof ExceptionDispatchBlock)) {
3188                 frameState.setRethrowException(false);
3189             }
3190 
3191             if (firstInstruction instanceof AbstractMergeNode) {
3192                 setMergeStateAfter(block, firstInstruction);
3193             }
3194 
3195             if (block == blockMap.getUnwindBlock()) {
3196                 handleUnwindBlock((ExceptionDispatchBlock) block);
3197             } else if (block instanceof ExceptionDispatchBlock) {
3198                 createExceptionDispatch((ExceptionDispatchBlock) block);
3199             } else {
3200                 iterateBytecodesForBlock(block);
3201             }
3202         }
3203     }
3204 
3205     private void handleUnwindBlock(ExceptionDispatchBlock block) {
3206         if (frameState.lockDepth(false) != 0) {
3207             throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3208         }
3209         assert !frameState.rethrowException();
3210         finishPrepare(lastInstr, block.deoptBci, frameState);
3211         if (parent == null) {
3212             createUnwind();
3213         } else {
3214             this.unwindValue = frameState.pop(JavaKind.Object);
3215             this.beforeUnwindNode = this.lastInstr;
3216         }
3217     }
3218 
3219     private void setMergeStateAfter(BciBlock block, FixedWithNextNode firstInstruction) {
3220         AbstractMergeNode abstractMergeNode = (AbstractMergeNode) firstInstruction;
3221         if (abstractMergeNode.stateAfter() == null) {
3222             int bci = block.startBci;
3223             if (block instanceof ExceptionDispatchBlock) {
3224                 bci = ((ExceptionDispatchBlock) block).deoptBci;
3225             }
3226             abstractMergeNode.setStateAfter(createFrameState(bci, abstractMergeNode));
3227         }
3228     }
3229 
3230     @SuppressWarnings(&quot;try&quot;)
3231     private void createUnwind() {
3232         assert frameState.stackSize() == 1 : frameState;
3233         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.UNWIND_BCI)) {
3234             ValueNode exception = frameState.pop(JavaKind.Object);
3235             append(new UnwindNode(exception));
3236         }
3237     }
3238 
3239     @SuppressWarnings(&quot;try&quot;)
3240     private void synchronizedEpilogue(int bci, ValueNode currentReturnValue, JavaKind currentReturnValueKind) {
3241         try (DebugCloseable context = openNodeContext(frameState, bci)) {
3242             if (method.isSynchronized()) {
3243                 if (currentReturnValueKind != JavaKind.Void) {
3244                     // we are making a state that should look like the state after the return:
3245                     // push the return value on the stack
3246                     frameState.push(currentReturnValueKind, currentReturnValue);
3247                 }
3248                 genMonitorExit(methodSynchronizedObject, currentReturnValue, bci);
3249                 assert !frameState.rethrowException();
3250             }
3251             if (frameState.lockDepth(false) != 0) {
3252                 throw bailout(&quot;unbalanced monitors: too few exits exiting frame&quot;);
3253             }
3254         }
3255     }
3256 
3257     @SuppressWarnings(&quot;try&quot;)
3258     private void createExceptionDispatch(ExceptionDispatchBlock block) {
3259         try (DebugCloseable context = openNodeContext(frameState, BytecodeFrame.AFTER_EXCEPTION_BCI)) {
3260             lastInstr = finishInstruction(lastInstr, frameState);
3261 
3262             assert frameState.stackSize() == 1 : frameState;
3263             if (block.handler.isCatchAll()) {
3264                 assert block.getSuccessorCount() == 1;
3265                 appendGoto(block.getSuccessor(0));
3266                 return;
3267             }
3268 
3269             JavaType catchType = block.handler.getCatchType();
3270             if (graphBuilderConfig.eagerResolving()) {
3271                 catchType = lookupType(block.handler.catchTypeCPI(), INSTANCEOF);
3272             }
3273             if (typeIsResolved(catchType)) {
3274                 TypeReference checkedCatchType = TypeReference.createTrusted(graph.getAssumptions(), (ResolvedJavaType) catchType);
3275 
3276                 if (graphBuilderConfig.getSkippedExceptionTypes() != null) {
3277                     for (ResolvedJavaType skippedType : graphBuilderConfig.getSkippedExceptionTypes()) {
3278                         if (skippedType.isAssignableFrom(checkedCatchType.getType())) {
3279                             BciBlock nextBlock = block.getSuccessorCount() == 1 ? blockMap.getUnwindBlock() : block.getSuccessor(1);
3280                             ValueNode exception = frameState.stack[0];
3281                             FixedNode trueSuccessor = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3282                             FixedNode nextDispatch = createTarget(nextBlock, frameState);
3283                             append(new IfNode(graph.addOrUniqueWithInputs(createInstanceOf(checkedCatchType, exception)), trueSuccessor, nextDispatch, 0));
3284                             return;
3285                         }
3286                     }
3287                 }
3288 
3289                 BciBlock nextBlock = block.getSuccessorCount() == 1 ? blockMap.getUnwindBlock() : block.getSuccessor(1);
3290                 ValueNode exception = frameState.stack[0];
3291                 /*
3292                  * Anchor for the piNode, which must be before any LoopExit inserted by
3293                  * createTarget.
3294                  */
3295                 BeginNode piNodeAnchor = graph.add(new BeginNode());
3296                 ObjectStamp checkedStamp = StampFactory.objectNonNull(checkedCatchType);
3297                 PiNode piNode = graph.addWithoutUnique(new PiNode(exception, checkedStamp));
3298                 frameState.pop(JavaKind.Object);
3299                 frameState.push(JavaKind.Object, piNode);
3300                 FixedNode catchSuccessor = createTarget(block.getSuccessor(0), frameState);
3301                 frameState.pop(JavaKind.Object);
3302                 frameState.push(JavaKind.Object, exception);
3303                 FixedNode nextDispatch = createTarget(nextBlock, frameState);
3304                 piNodeAnchor.setNext(catchSuccessor);
3305                 IfNode ifNode = append(new IfNode(graph.unique(createInstanceOf(checkedCatchType, exception)), piNodeAnchor, nextDispatch, 0.5));
3306                 assert ifNode.trueSuccessor() == piNodeAnchor;
3307                 piNode.setGuard(ifNode.trueSuccessor());
3308             } else {
3309                 handleUnresolvedExceptionType(catchType);
3310             }
3311         }
3312     }
3313 
3314     private void appendGoto(BciBlock successor) {
3315         FixedNode targetInstr = createTarget(successor, frameState, true, true);
3316         if (lastInstr != null &amp;&amp; lastInstr != targetInstr) {
3317             lastInstr.setNext(targetInstr);
3318         }
3319     }
3320 
3321     @SuppressWarnings(&quot;try&quot;)
3322     protected void iterateBytecodesForBlock(BciBlock block) {
3323         if (block.isLoopHeader()) {
3324             // Create the loop header block, which later will merge the backward branches of
3325             // the loop.
3326             controlFlowSplit = true;
3327             LoopBeginNode loopBegin = appendLoopBegin(this.lastInstr, block.startBci);
3328             lastInstr = loopBegin;
3329 
3330             // Create phi functions for all local variables and operand stack slots.
3331             frameState.insertLoopPhis(liveness, block.loopId, loopBegin, forceLoopPhis() || this.graphBuilderConfig.replaceLocalsWithConstants(), stampFromValueForForcedPhis());
3332             loopBegin.setStateAfter(createFrameState(block.startBci, loopBegin));
3333 
3334             /*
3335              * We have seen all forward branches. All subsequent backward branches will merge to the
3336              * loop header. This ensures that the loop header has exactly one non-loop predecessor.
3337              */
3338             setFirstInstruction(block, loopBegin);
3339             /*
3340              * We need to preserve the frame state builder of the loop header so that we can merge
3341              * values for phi functions, so make a copy of it.
3342              */
3343             setEntryState(block, frameState.copy());
3344 
3345             debug.log(&quot;  created loop header %s&quot;, loopBegin);
3346         } else if (lastInstr instanceof MergeNode) {
3347             /*
3348              * All inputs of non-loop phi nodes are known by now. We can infer the stamp for the
3349              * phi, so that parsing continues with more precise type information.
3350              */
3351             frameState.inferPhiStamps((AbstractMergeNode) lastInstr);
3352         }
3353         assert lastInstr.next() == null : &quot;instructions already appended at block &quot; + block;
3354         debug.log(&quot;  frameState: %s&quot;, frameState);
3355 
3356         lastInstr = finishInstruction(lastInstr, frameState);
3357 
3358         int endBCI = stream.endBCI();
3359 
3360         stream.setBCI(block.startBci);
3361         int bci = block.startBci;
3362         BytecodesParsed.add(debug, block.endBci - bci);
3363 
3364         /* Reset line number for new block */
3365         if (graphBuilderConfig.insertFullInfopoints()) {
3366             previousLineNumber = -1;
3367         }
3368 
3369         while (bci &lt; endBCI) {
3370             try (DebugCloseable context = openNodeContext()) {
3371                 if (graphBuilderConfig.insertFullInfopoints() &amp;&amp; !parsingIntrinsic()) {
3372                     currentLineNumber = lnt != null ? lnt.getLineNumber(bci) : -1;
3373                     if (currentLineNumber != previousLineNumber) {
3374                         genInfoPointNode(InfopointReason.BYTECODE_POSITION, null);
3375                         previousLineNumber = currentLineNumber;
3376                     }
3377                 }
3378 
3379                 // read the opcode
3380                 int opcode = stream.currentBC();
3381                 if (traceLevel != 0) {
3382                     traceInstruction(bci, opcode, bci == block.startBci);
3383                 }
3384                 if (parent == null &amp;&amp; bci == entryBCI) {
3385                     if (block.getJsrScope() != JsrScope.EMPTY_SCOPE) {
3386                         throw new JsrNotSupportedBailout(&quot;OSR into a JSR scope is not supported&quot;);
3387                     }
3388                     EntryMarkerNode x = append(new EntryMarkerNode());
3389                     frameState.insertProxies(value -&gt; graph.unique(new EntryProxyNode(value, x)));
3390                     x.setStateAfter(createFrameState(bci, x));
3391                 }
3392 
3393                 processBytecode(bci, opcode);
3394             } catch (BailoutException e) {
3395                 // Don&#39;t wrap bailouts as parser errors
3396                 throw e;
3397             } catch (Throwable e) {
3398                 throw throwParserError(e);
3399             }
3400 
3401             if (lastInstr == null || lastInstr.next() != null) {
3402                 break;
3403             }
3404 
3405             stream.next();
3406             bci = stream.currentBCI();
3407 
3408             assert block == currentBlock;
3409             assert checkLastInstruction();
3410             lastInstr = finishInstruction(lastInstr, frameState);
3411             if (bci &lt; endBCI) {
3412                 if (bci &gt; block.endBci) {
3413                     assert !block.getSuccessor(0).isExceptionEntry();
3414                     assert block.numNormalSuccessors() == 1;
3415                     // we fell through to the next block, add a goto and break
3416                     appendGoto(block.getSuccessor(0));
3417                     break;
3418                 }
3419             }
3420         }
3421     }
3422 
3423     private DebugCloseable openNodeContext(FrameStateBuilder state, int startBci) {
3424         if (graph.trackNodeSourcePosition()) {
3425             return graph.withNodeSourcePosition(state.createBytecodePosition(startBci));
3426         }
3427         return null;
3428     }
3429 
3430     private DebugCloseable openNodeContext(ResolvedJavaMethod targetMethod) {
3431         return openNodeContext(targetMethod, -1);
3432     }
3433 
3434     private DebugCloseable openNodeContext(ResolvedJavaMethod targetMethod, int bci) {
3435         if (graph.trackNodeSourcePosition()) {
3436             return graph.withNodeSourcePosition(new NodeSourcePosition(createBytecodePosition(), targetMethod, bci));
3437         }
3438         return null;
3439     }
3440 
3441     private DebugCloseable openNodeContext() {
3442         return openNodeContext(frameState, bci());
3443     }
3444 
3445     /* Also a hook for subclasses. */
3446     protected boolean forceLoopPhis() {
3447         return graph.isOSR();
3448     }
3449 
3450     /* Hook for subclasses. */
3451     protected boolean stampFromValueForForcedPhis() {
3452         return false;
3453     }
3454 
3455     protected boolean checkLastInstruction() {
3456         if (lastInstr instanceof BeginNode) {
3457             // ignore
3458         } else if (lastInstr instanceof StateSplit) {
3459             StateSplit stateSplit = (StateSplit) lastInstr;
3460             if (stateSplit.hasSideEffect()) {
3461                 assert stateSplit.stateAfter() != null : &quot;side effect &quot; + lastInstr + &quot; requires a non-null stateAfter&quot;;
3462             }
3463         }
3464         return true;
3465     }
3466 
3467     /* Also a hook for subclasses. */
3468     protected boolean disableLoopSafepoint() {
3469         return parsingIntrinsic();
3470     }
3471 
3472     @SuppressWarnings(&quot;try&quot;)
3473     private LoopBeginNode appendLoopBegin(FixedWithNextNode fixedWithNext, int startBci) {
3474         try (DebugCloseable context = openNodeContext(frameState, startBci)) {
3475             EndNode preLoopEnd = graph.add(new EndNode());
3476             LoopBeginNode loopBegin = graph.add(new LoopBeginNode());
3477             if (disableLoopSafepoint()) {
3478                 loopBegin.disableSafepoint();
3479             }
3480             fixedWithNext.setNext(preLoopEnd);
3481             // Add the single non-loop predecessor of the loop header.
3482             loopBegin.addForwardEnd(preLoopEnd);
3483             return loopBegin;
3484         }
3485     }
3486 
3487     /**
3488      * Hook for subclasses to modify the last instruction or add other instructions.
3489      *
3490      * @param instr The last instruction (= fixed node) which was added.
3491      * @param state The current frame state.
3492      * @return Returns the (new) last instruction.
3493      */
3494     protected FixedWithNextNode finishInstruction(FixedWithNextNode instr, FrameStateBuilder state) {
3495         return instr;
3496     }
3497 
3498     private void genInfoPointNode(InfopointReason reason, ValueNode escapedReturnValue) {
3499         if (!parsingIntrinsic() &amp;&amp; graphBuilderConfig.insertFullInfopoints()) {
3500             append(new FullInfopointNode(reason, createFrameState(bci(), null), escapedReturnValue));
3501         }
3502     }
3503 
3504     protected void genIf(ValueNode x, Condition cond, ValueNode y) {
3505         assert x.getStackKind() == y.getStackKind();
3506         assert currentBlock.getSuccessorCount() == 2;
3507         BciBlock trueBlock = currentBlock.getSuccessor(0);
3508         BciBlock falseBlock = currentBlock.getSuccessor(1);
3509 
3510         if (trueBlock == falseBlock) {
3511             // The target block is the same independent of the condition.
3512             appendGoto(trueBlock);
3513             return;
3514         }
3515 
3516         ValueNode a = x;
3517         ValueNode b = y;
3518         BciBlock trueSuccessor = trueBlock;
3519         BciBlock falseSuccessor = falseBlock;
3520 
3521         CanonicalizedCondition canonicalizedCondition = cond.canonicalize();
3522 
3523         // Check whether the condition needs to mirror the operands.
3524         if (canonicalizedCondition.mustMirror()) {
3525             a = y;
3526             b = x;
3527         }
3528         if (canonicalizedCondition.mustNegate()) {
3529             trueSuccessor = falseBlock;
3530             falseSuccessor = trueBlock;
3531         }
3532 
3533         // Create the logic node for the condition.
3534         LogicNode condition = createLogicNode(canonicalizedCondition.getCanonicalCondition(), a, b);
3535 
3536         double probability = -1;
3537         if (condition instanceof IntegerEqualsNode) {
3538             probability = extractInjectedProbability((IntegerEqualsNode) condition);
3539             // the probability coming from here is about the actual condition
3540         }
3541 
3542         if (probability == -1) {
3543             probability = getProfileProbability(canonicalizedCondition.mustNegate());
3544         }
3545 
3546         genIf(condition, trueSuccessor, falseSuccessor, probability);
3547     }
3548 
3549     protected double getProfileProbability(boolean negate) {
3550         if (profilingInfo == null) {
3551             return 0.5;
3552         }
3553 
3554         assert assertAtIfBytecode();
3555         double probability = profilingInfo.getBranchTakenProbability(bci());
3556 
3557         if (probability &lt; 0) {
3558             assert probability == -1 : &quot;invalid probability&quot;;
3559             debug.log(&quot;missing probability in %s at bci %d&quot;, code, bci());
3560             return 0.5;
3561         }
3562 
3563         if (negate &amp;&amp; shouldComplementProbability()) {
3564             // the probability coming from profile is about the original condition
3565             probability = 1 - probability;
3566         }
3567         return clampProbability(probability);
3568     }
3569 
3570     private double extractInjectedProbability(IntegerEqualsNode condition) {
3571         // Propagate injected branch probability if any.
3572         IntegerEqualsNode equalsNode = condition;
3573         BranchProbabilityNode probabilityNode = null;
3574         ValueNode other = null;
3575         if (equalsNode.getX() instanceof BranchProbabilityNode) {
3576             probabilityNode = (BranchProbabilityNode) equalsNode.getX();
3577             other = equalsNode.getY();
3578         } else if (equalsNode.getY() instanceof BranchProbabilityNode) {
3579             probabilityNode = (BranchProbabilityNode) equalsNode.getY();
3580             other = equalsNode.getX();
3581         }
3582 
3583         if (probabilityNode != null &amp;&amp; probabilityNode.getProbability().isConstant() &amp;&amp; other != null &amp;&amp; other.isConstant()) {
3584             double probabilityValue = clampProbability(probabilityNode.getProbability().asJavaConstant().asDouble());
3585             return other.asJavaConstant().asInt() == 0 ? 1.0 - probabilityValue : probabilityValue;
3586         }
3587         return -1;
3588     }
3589 
3590     protected void genIf(LogicNode conditionInput, BciBlock trueBlockInput, BciBlock falseBlockInput, double probabilityInput) {
3591         BciBlock trueBlock = trueBlockInput;
3592         BciBlock falseBlock = falseBlockInput;
3593         LogicNode condition = conditionInput;
3594         double probability = probabilityInput;
3595         FrameState stateBefore = null;
3596         ProfilingPlugin profilingPlugin = this.graphBuilderConfig.getPlugins().getProfilingPlugin();
3597         if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3598             stateBefore = createCurrentFrameState();
3599         }
3600 
3601         // Remove a logic negation node.
3602         if (condition instanceof LogicNegationNode) {
3603             LogicNegationNode logicNegationNode = (LogicNegationNode) condition;
3604             BciBlock tmpBlock = trueBlock;
3605             trueBlock = falseBlock;
3606             falseBlock = tmpBlock;
3607             if (shouldComplementProbability()) {
3608                 // the probability coming from profile is about the original condition
3609                 probability = 1 - probability;
3610             }
3611             condition = logicNegationNode.getValue();
3612         }
3613 
3614         if (condition instanceof LogicConstantNode) {
3615             genConstantTargetIf(trueBlock, falseBlock, condition);
3616         } else {
3617             if (condition.graph() == null) {
3618                 condition = genUnique(condition);
3619             }
3620 
3621             BciBlock deoptBlock = null;
3622             BciBlock noDeoptBlock = null;
3623             if (isNeverExecutedCode(probability)) {
3624                 deoptBlock = trueBlock;
3625                 noDeoptBlock = falseBlock;
3626             } else if (isNeverExecutedCode(1 - probability)) {
3627                 deoptBlock = falseBlock;
3628                 noDeoptBlock = trueBlock;
3629             }
3630 
3631             if (deoptBlock != null) {
3632                 NodeSourcePosition currentPosition = graph.currentNodeSourcePosition();
3633                 NodeSourcePosition survivingSuccessorPosition = null;
3634                 if (graph.trackNodeSourcePosition()) {
3635                     survivingSuccessorPosition = new NodeSourcePosition(currentPosition.getCaller(), currentPosition.getMethod(), noDeoptBlock.startBci);
3636                 }
3637                 boolean negated = deoptBlock == trueBlock;
3638                 if (!isPotentialCountedLoopExit(condition, deoptBlock)) {
3639                     if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3640                         profilingPlugin.profileGoto(this, method, bci(), noDeoptBlock.startBci, stateBefore);
3641                     }
3642                     append(new FixedGuardNode(condition, UnreachedCode, InvalidateReprofile, negated, survivingSuccessorPosition));
3643                     appendGoto(noDeoptBlock);
3644                 } else {
3645                     this.controlFlowSplit = true;
3646                     FixedNode noDeoptSuccessor = createTarget(noDeoptBlock, frameState, false, true);
3647                     DeoptimizeNode deopt = graph.add(new DeoptimizeNode(InvalidateReprofile, UnreachedCode));
3648                     /*
3649                      * We do not want to `checkLoopExit` here: otherwise the deopt will go to the
3650                      * deoptBlock&#39;s BCI, skipping the branch in the interpreter, and the profile
3651                      * will never see that the branch is taken. This can lead to deopt loops or OSR
3652                      * failure.
3653                      */
3654                     double calculatedProbability = negated ? BranchProbabilityNode.DEOPT_PROBABILITY : 1.0 - BranchProbabilityNode.DEOPT_PROBABILITY;
3655                     FixedNode deoptSuccessor = BeginNode.begin(deopt);
3656                     ValueNode ifNode = genIfNode(condition, negated ? deoptSuccessor : noDeoptSuccessor, negated ? noDeoptSuccessor : deoptSuccessor, calculatedProbability);
3657                     postProcessIfNode(ifNode);
3658                     append(ifNode);
3659                 }
3660                 return;
3661             }
3662 
3663             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3664                 profilingPlugin.profileIf(this, method, bci(), condition, trueBlock.startBci, falseBlock.startBci, stateBefore);
3665             }
3666 
3667             int oldBci = stream.currentBCI();
3668             int trueBlockInt = checkPositiveIntConstantPushed(trueBlock);
3669             if (trueBlockInt != -1) {
3670                 int falseBlockInt = checkPositiveIntConstantPushed(falseBlock);
3671                 if (falseBlockInt != -1) {
3672                     if (tryGenConditionalForIf(trueBlock, falseBlock, condition, oldBci, trueBlockInt, falseBlockInt)) {
3673                         return;
3674                     }
3675                 }
3676             }
3677 
3678             this.controlFlowSplit = true;
3679             FixedNode falseSuccessor = createTarget(falseBlock, frameState, false, false);
3680             FixedNode trueSuccessor = createTarget(trueBlock, frameState, false, true);
3681 
3682             if (this.graphBuilderConfig.replaceLocalsWithConstants() &amp;&amp; condition instanceof CompareNode) {
3683                 CompareNode compareNode = (CompareNode) condition;
3684                 if (compareNode.condition() == CanonicalCondition.EQ) {
3685                     ValueNode constantNode = null;
3686                     ValueNode nonConstantNode = null;
3687                     if (compareNode.getX() instanceof ConstantNode) {
3688                         constantNode = compareNode.getX();
3689                         nonConstantNode = compareNode.getY();
3690                     } else if (compareNode.getY() instanceof ConstantNode) {
3691                         constantNode = compareNode.getY();
3692                         nonConstantNode = compareNode.getX();
3693                     }
3694 
3695                     if (constantNode != null &amp;&amp; nonConstantNode != null) {
3696                         this.getEntryState(trueBlock).replaceValue(nonConstantNode, constantNode);
3697                     }
3698                 }
3699             }
3700 
3701             ValueNode ifNode = genIfNode(condition, trueSuccessor, falseSuccessor, probability);
3702             postProcessIfNode(ifNode);
3703             append(ifNode);
3704         }
3705     }
3706 
3707     public boolean isPotentialCountedLoopExit(LogicNode condition, BciBlock target) {
3708         if (currentBlock != null) {
3709             long exits = currentBlock.loops &amp; ~target.loops;
3710             if (exits != 0) {
3711                 return condition instanceof CompareNode;
3712             }
3713         }
3714         return false;
3715     }
3716 
3717     /**
3718      * Hook for subclasses to decide whether the IfNode probability should be complemented during
3719      * conversion to Graal IR.
3720      */
3721     protected boolean shouldComplementProbability() {
3722         return true;
3723     }
3724 
3725     /**
3726      * Hook for subclasses to generate custom nodes before an IfNode.
3727      */
3728     @SuppressWarnings(&quot;unused&quot;)
3729     protected void postProcessIfNode(ValueNode node) {
3730     }
3731 
3732     private boolean tryGenConditionalForIf(BciBlock trueBlock, BciBlock falseBlock, LogicNode condition, int oldBci, int trueBlockInt, int falseBlockInt) {
3733         if (gotoOrFallThroughAfterConstant(trueBlock) &amp;&amp; gotoOrFallThroughAfterConstant(falseBlock) &amp;&amp; trueBlock.getSuccessor(0) == falseBlock.getSuccessor(0)) {
3734             genConditionalForIf(trueBlock, condition, oldBci, trueBlockInt, falseBlockInt, false);
3735             return true;
3736         } else if (this.parent != null &amp;&amp; returnAfterConstant(trueBlock) &amp;&amp; returnAfterConstant(falseBlock)) {
3737             genConditionalForIf(trueBlock, condition, oldBci, trueBlockInt, falseBlockInt, true);
3738             return true;
3739         }
3740         return false;
3741     }
3742 
3743     private void genConditionalForIf(BciBlock trueBlock, LogicNode condition, int oldBci, int trueBlockInt, int falseBlockInt, boolean genReturn) {
3744         ConstantNode trueValue = graph.unique(ConstantNode.forInt(trueBlockInt));
3745         ConstantNode falseValue = graph.unique(ConstantNode.forInt(falseBlockInt));
3746         ValueNode conditionalNode = ConditionalNode.create(condition, trueValue, falseValue, NodeView.DEFAULT);
3747         if (conditionalNode.graph() == null) {
3748             conditionalNode = graph.addOrUniqueWithInputs(conditionalNode);
3749         }
3750         if (genReturn) {
3751             JavaKind returnKind = method.getSignature().getReturnKind().getStackKind();
3752             this.genReturn(conditionalNode, returnKind);
3753         } else {
3754             frameState.push(JavaKind.Int, conditionalNode);
3755             appendGoto(trueBlock.getSuccessor(0));
3756             stream.setBCI(oldBci);
3757         }
3758     }
3759 
3760     private LogicNode createLogicNode(CanonicalCondition cond, ValueNode a, ValueNode b) {
3761         assert !a.getStackKind().isNumericFloat();
3762         switch (cond) {
3763             case EQ:
3764                 if (a.getStackKind() == JavaKind.Object) {
3765                     return genObjectEquals(a, b);
3766                 } else {
3767                     return genIntegerEquals(a, b);
3768                 }
3769             case LT:
3770                 assert a.getStackKind() != JavaKind.Object;
3771                 return genIntegerLessThan(a, b);
3772             default:
3773                 throw GraalError.shouldNotReachHere(&quot;Unexpected condition: &quot; + cond);
3774         }
3775     }
3776 
3777     private void genConstantTargetIf(BciBlock trueBlock, BciBlock falseBlock, LogicNode condition) {
3778         LogicConstantNode constantLogicNode = (LogicConstantNode) condition;
3779         boolean value = constantLogicNode.getValue();
3780         BciBlock nextBlock = falseBlock;
3781         if (value) {
3782             nextBlock = trueBlock;
3783         }
3784         int startBci = nextBlock.startBci;
3785         int targetAtStart = stream.readUByte(startBci);
3786         if (targetAtStart == Bytecodes.GOTO &amp;&amp; nextBlock.getPredecessorCount() == 1) {
3787             // This is an empty block. Skip it.
3788             BciBlock successorBlock = nextBlock.successors.get(0);
3789             ProfilingPlugin profilingPlugin = graphBuilderConfig.getPlugins().getProfilingPlugin();
3790             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3791                 FrameState stateBefore = createCurrentFrameState();
3792                 profilingPlugin.profileGoto(this, method, bci(), successorBlock.startBci, stateBefore);
3793             }
3794             appendGoto(successorBlock);
3795             assert nextBlock.numNormalSuccessors() == 1;
3796         } else {
3797             ProfilingPlugin profilingPlugin = graphBuilderConfig.getPlugins().getProfilingPlugin();
3798             if (profilingPlugin != null &amp;&amp; profilingPlugin.shouldProfile(this, method)) {
3799                 FrameState stateBefore = createCurrentFrameState();
3800                 profilingPlugin.profileGoto(this, method, bci(), nextBlock.startBci, stateBefore);
3801             }
3802             appendGoto(nextBlock);
3803         }
3804     }
3805 
3806     private int checkPositiveIntConstantPushed(BciBlock block) {
3807         stream.setBCI(block.startBci);
3808         int currentBC = stream.currentBC();
3809         if (currentBC &gt;= Bytecodes.ICONST_0 &amp;&amp; currentBC &lt;= Bytecodes.ICONST_5) {
3810             int constValue = currentBC - Bytecodes.ICONST_0;
3811             return constValue;
3812         }
3813         return -1;
3814     }
3815 
3816     private boolean gotoOrFallThroughAfterConstant(BciBlock block) {
3817         stream.setBCI(block.startBci);
3818         int currentBCI = stream.nextBCI();
3819         stream.setBCI(currentBCI);
3820         int currentBC = stream.currentBC();
3821         return stream.currentBCI() &gt; block.endBci || currentBC == Bytecodes.GOTO || currentBC == Bytecodes.GOTO_W;
3822     }
3823 
3824     private boolean returnAfterConstant(BciBlock block) {
3825         stream.setBCI(block.startBci);
3826         int currentBCI = stream.nextBCI();
3827         stream.setBCI(currentBCI);
3828         int currentBC = stream.currentBC();
3829         return currentBC == Bytecodes.IRETURN;
3830     }
3831 
3832     @Override
3833     public StampProvider getStampProvider() {
3834         return providers.getStampProvider();
3835     }
3836 
3837     @Override
3838     public MetaAccessProvider getMetaAccess() {
3839         return providers.getMetaAccess();
3840     }
3841 
3842     @Override
3843     public Replacements getReplacements() {
3844         return providers.getReplacements();
3845     }
3846 
3847     @Override
3848     public void push(JavaKind slotKind, ValueNode value) {
3849         assert value.isAlive();
3850         frameState.push(slotKind, value);
3851     }
3852 
3853     @Override
3854     public ValueNode pop(JavaKind slotKind) {
3855         return frameState.pop(slotKind);
3856     }
3857 
3858     @Override
3859     public ConstantReflectionProvider getConstantReflection() {
3860         return providers.getConstantReflection();
3861     }
3862 
3863     @Override
3864     public ConstantFieldProvider getConstantFieldProvider() {
3865         return providers.getConstantFieldProvider();
3866     }
3867 
3868     /**
3869      * Gets the graph being processed by this builder.
3870      */
3871     @Override
3872     public StructuredGraph getGraph() {
3873         return graph;
3874     }
3875 
3876     @Override
3877     public BytecodeParser getParent() {
3878         return parent;
3879     }
3880 
3881     @Override
3882     public IntrinsicContext getIntrinsic() {
3883         return intrinsicContext;
3884     }
3885 
3886     @Override
3887     public String toString() {
3888         Formatter fmt = new Formatter();
3889         BytecodeParser bp = this;
3890         String indent = &quot;&quot;;
3891         while (bp != null) {
3892             if (bp != this) {
3893                 fmt.format(&quot;%n%s&quot;, indent);
3894             }
3895             fmt.format(&quot;%s [bci: %d, intrinsic: %s]&quot;, bp.code.asStackTraceElement(bp.bci()), bp.bci(), bp.parsingIntrinsic());
3896             fmt.format(&quot;%n%s&quot;, new BytecodeDisassembler().disassemble(bp.code, bp.bci(), bp.bci() + 10));
3897             bp = bp.parent;
3898             indent += &quot; &quot;;
3899         }
3900         return fmt.toString();
3901     }
3902 
3903     @Override
3904     public BailoutException bailout(String string) {
3905         FrameState currentFrameState = createFrameState(bci(), null);
3906         StackTraceElement[] elements = GraphUtil.approxSourceStackTraceElement(currentFrameState);
3907         BailoutException bailout = new PermanentBailoutException(string);
3908         throw GraphUtil.createBailoutException(string, bailout, elements);
3909     }
3910 
3911     private FrameState createFrameState(int bci, StateSplit forStateSplit) {
3912         assert !(forStateSplit instanceof BytecodeExceptionNode);
3913         if (currentBlock != null &amp;&amp; bci &gt; currentBlock.endBci) {
3914             frameState.clearNonLiveLocals(currentBlock, liveness, false);
3915         }
3916         return frameState.create(bci, forStateSplit);
3917     }
3918 
3919     private FrameState createBytecodeExceptionFrameState(int bci, BytecodeExceptionNode bytecodeException) {
3920         FrameStateBuilder copy = frameState.copy();
3921         copy.clearStack();
3922         if (currentBlock != null) {
3923             copy.clearNonLiveLocals(currentBlock, liveness, false);
3924         }
3925         copy.setRethrowException(true);
3926         copy.push(JavaKind.Object, bytecodeException);
3927         return copy.create(bci, bytecodeException);
3928     }
3929 
3930     @Override
3931     public void setStateAfter(StateSplit sideEffect) {
3932         assert sideEffect.hasSideEffect() || sideEffect instanceof AbstractMergeNode;
3933         FrameState stateAfter = createFrameState(stream.nextBCI(), sideEffect);
3934         sideEffect.setStateAfter(stateAfter);
3935     }
3936 
3937     protected NodeSourcePosition createBytecodePosition() {
3938         NodeSourcePosition bytecodePosition = frameState.createBytecodePosition(bci());
3939         return bytecodePosition;
3940     }
3941 
3942     public void setCurrentFrameState(FrameStateBuilder frameState) {
3943         this.frameState = frameState;
3944     }
3945 
3946     protected final BytecodeStream getStream() {
3947         return stream;
3948     }
3949 
3950     @Override
3951     public int bci() {
3952         return stream.currentBCI();
3953     }
3954 
3955     public void loadLocal(int index, JavaKind kind) {
3956         ValueNode value = frameState.loadLocal(index, kind);
3957         frameState.push(kind, value);
3958     }
3959 
3960     @SuppressWarnings(&quot;try&quot;)
3961     public void loadLocalObject(int index) {
3962         ValueNode value = frameState.loadLocal(index, JavaKind.Object);
3963 
3964         int nextBCI = stream.nextBCI();
3965         int nextBC = stream.readUByte(nextBCI);
3966         if (nextBCI &lt;= currentBlock.endBci &amp;&amp; nextBC == Bytecodes.GETFIELD) {
3967             stream.next();
3968             try (DebugCloseable ignored = openNodeContext()) {
3969                 genGetField(stream.readCPI(), Bytecodes.GETFIELD, value);
3970             }
3971         } else {
3972             frameState.push(JavaKind.Object, value);
3973         }
3974     }
3975 
3976     public void storeLocal(JavaKind kind, int index) {
3977         ValueNode value = frameState.pop(kind);
3978         frameState.storeLocal(index, kind, value);
3979     }
3980 
3981     protected void genLoadConstant(int cpi, int opcode) {
3982         Object con = lookupConstant(cpi, opcode);
3983 
3984         if (con instanceof JavaType) {
3985             // this is a load of class constant which might be unresolved
3986             JavaType type = (JavaType) con;
3987             if (typeIsResolved(type)) {
3988                 frameState.push(JavaKind.Object, appendConstant(getConstantReflection().asJavaClass((ResolvedJavaType) type)));
3989             } else {
3990                 handleUnresolvedLoadConstant(type);
3991             }
3992         } else if (con instanceof JavaConstant) {
3993             JavaConstant constant = (JavaConstant) con;
3994             frameState.push(constant.getJavaKind(), appendConstant(constant));
3995         } else {
3996             throw new Error(&quot;lookupConstant returned an object of incorrect type&quot;);
3997         }
3998     }
3999 
4000     private JavaKind refineComponentType(ValueNode array, JavaKind kind) {
4001         if (kind == JavaKind.Byte) {
4002             JavaType type = array.stamp(NodeView.DEFAULT).javaType(getMetaAccess());
4003             if (type.isArray()) {
4004                 JavaType componentType = type.getComponentType();
4005                 if (componentType != null) {
4006                     JavaKind refinedKind = componentType.getJavaKind();
4007                     assert refinedKind == JavaKind.Byte || refinedKind == JavaKind.Boolean;
4008                     return refinedKind;
4009                 }
4010             }
4011         }
4012         return kind;
4013     }
4014 
4015     private void genLoadIndexed(JavaKind kind) {
4016         ValueNode index = frameState.pop(JavaKind.Int);
4017         ValueNode array = frameState.pop(JavaKind.Object);
4018 
4019         array = maybeEmitExplicitNullCheck(array);
4020         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
4021 
4022         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4023             if (plugin.handleLoadIndexed(this, array, index, boundsCheck, kind)) {
4024                 return;
4025             }
4026         }
4027 
4028         JavaKind actualKind = refineComponentType(array, kind);
4029         frameState.push(actualKind, append(genLoadIndexed(array, index, boundsCheck, actualKind)));
4030     }
4031 
4032     private void genStoreIndexed(JavaKind kind) {
4033         ValueNode value = frameState.pop(kind);
4034         ValueNode index = frameState.pop(JavaKind.Int);
4035         ValueNode array = frameState.pop(JavaKind.Object);
4036 
4037         array = maybeEmitExplicitNullCheck(array);
4038         GuardingNode boundsCheck = maybeEmitExplicitBoundsCheck(array, index);
4039         GuardingNode storeCheck = maybeEmitExplicitStoreCheck(array, kind, value);
4040 
4041         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4042             if (plugin.handleStoreIndexed(this, array, index, boundsCheck, storeCheck, kind, value)) {
4043                 return;
4044             }
4045         }
4046 
4047         JavaKind actualKind = refineComponentType(array, kind);
4048         genStoreIndexed(array, index, boundsCheck, storeCheck, actualKind, maskSubWordValue(value, actualKind));
4049     }
4050 
4051     private void genArithmeticOp(JavaKind kind, int opcode) {
4052         ValueNode y = frameState.pop(kind);
4053         ValueNode x = frameState.pop(kind);
4054         ValueNode v;
4055         switch (opcode) {
4056             case IADD:
4057             case LADD:
4058                 v = genIntegerAdd(x, y);
4059                 break;
4060             case FADD:
4061             case DADD:
4062                 v = genFloatAdd(x, y);
4063                 break;
4064             case ISUB:
4065             case LSUB:
4066                 v = genIntegerSub(x, y);
4067                 break;
4068             case FSUB:
4069             case DSUB:
4070                 v = genFloatSub(x, y);
4071                 break;
4072             case IMUL:
4073             case LMUL:
4074                 v = genIntegerMul(x, y);
4075                 break;
4076             case FMUL:
4077             case DMUL:
4078                 v = genFloatMul(x, y);
4079                 break;
4080             case FDIV:
4081             case DDIV:
4082                 v = genFloatDiv(x, y);
4083                 break;
4084             case FREM:
4085             case DREM:
4086                 v = genFloatRem(x, y);
4087                 break;
4088             default:
4089                 throw shouldNotReachHere();
4090         }
4091         frameState.push(kind, append(v));
4092     }
4093 
4094     private void genIntegerDivOp(JavaKind kind, int opcode) {
4095         ValueNode y = frameState.pop(kind);
4096         ValueNode x = frameState.pop(kind);
4097 
4098         GuardingNode zeroCheck = maybeEmitExplicitDivisionByZeroCheck(y);
4099 
4100         ValueNode v;
4101         switch (opcode) {
4102             case IDIV:
4103             case LDIV:
4104                 v = genIntegerDiv(x, y, zeroCheck);
4105                 break;
4106             case IREM:
4107             case LREM:
4108                 v = genIntegerRem(x, y, zeroCheck);
4109                 break;
4110             default:
4111                 throw shouldNotReachHere();
4112         }
4113         frameState.push(kind, append(v));
4114     }
4115 
4116     private void genNegateOp(JavaKind kind) {
4117         ValueNode x = frameState.pop(kind);
4118         frameState.push(kind, append(genNegateOp(x)));
4119     }
4120 
4121     private void genShiftOp(JavaKind kind, int opcode) {
4122         ValueNode s = frameState.pop(JavaKind.Int);
4123         ValueNode x = frameState.pop(kind);
4124         ValueNode v;
4125         switch (opcode) {
4126             case ISHL:
4127             case LSHL:
4128                 v = genLeftShift(x, s);
4129                 break;
4130             case ISHR:
4131             case LSHR:
4132                 v = genRightShift(x, s);
4133                 break;
4134             case IUSHR:
4135             case LUSHR:
4136                 v = genUnsignedRightShift(x, s);
4137                 break;
4138             default:
4139                 throw shouldNotReachHere();
4140         }
4141         frameState.push(kind, append(v));
4142     }
4143 
4144     private void genLogicOp(JavaKind kind, int opcode) {
4145         ValueNode y = frameState.pop(kind);
4146         ValueNode x = frameState.pop(kind);
4147         ValueNode v;
4148         switch (opcode) {
4149             case IAND:
4150             case LAND:
4151                 v = genAnd(x, y);
4152                 break;
4153             case IOR:
4154             case LOR:
4155                 v = genOr(x, y);
4156                 break;
4157             case IXOR:
4158             case LXOR:
4159                 v = genXor(x, y);
4160                 break;
4161             default:
4162                 throw shouldNotReachHere();
4163         }
4164         frameState.push(kind, append(v));
4165     }
4166 
4167     private void genFloatCompareOp(JavaKind kind, boolean isUnorderedLess) {
4168         ValueNode y = frameState.pop(kind);
4169         ValueNode x = frameState.pop(kind);
4170         frameState.push(JavaKind.Int, append(genNormalizeCompare(x, y, isUnorderedLess)));
4171     }
4172 
4173     private void genIntegerCompareOp(JavaKind kind) {
4174         ValueNode y = frameState.pop(kind);
4175         ValueNode x = frameState.pop(kind);
4176         frameState.push(JavaKind.Int, append(genIntegerNormalizeCompare(x, y)));
4177     }
4178 
4179     private void genFloatConvert(FloatConvert op, JavaKind from, JavaKind to) {
4180         ValueNode input = frameState.pop(from);
4181         frameState.push(to, append(genFloatConvert(op, input)));
4182     }
4183 
4184     private void genSignExtend(JavaKind from, JavaKind to) {
4185         ValueNode input = frameState.pop(from);
4186         if (from != from.getStackKind()) {
4187             input = append(genNarrow(input, from.getBitCount()));
4188         }
4189         frameState.push(to, append(genSignExtend(input, to.getBitCount())));
4190     }
4191 
4192     private void genZeroExtend(JavaKind from, JavaKind to) {
4193         ValueNode input = frameState.pop(from);
4194         if (from != from.getStackKind()) {
4195             input = append(genNarrow(input, from.getBitCount()));
4196         }
4197         frameState.push(to, append(genZeroExtend(input, to.getBitCount())));
4198     }
4199 
4200     private void genNarrow(JavaKind from, JavaKind to) {
4201         ValueNode input = frameState.pop(from);
4202         frameState.push(to, append(genNarrow(input, to.getBitCount())));
4203     }
4204 
4205     private void genIncrement() {
4206         int index = getStream().readLocalIndex();
4207         int delta = getStream().readIncrement();
4208         ValueNode x = frameState.loadLocal(index, JavaKind.Int);
4209         ValueNode y = appendConstant(JavaConstant.forInt(delta));
4210         frameState.storeLocal(index, JavaKind.Int, append(genIntegerAdd(x, y)));
4211     }
4212 
4213     private void genIfZero(Condition cond) {
4214         ValueNode y = appendConstant(JavaConstant.INT_0);
4215         ValueNode x = frameState.pop(JavaKind.Int);
4216         genIf(x, cond, y);
4217     }
4218 
4219     private void genIfNull(Condition cond) {
4220         ValueNode y = appendConstant(JavaConstant.NULL_POINTER);
4221         ValueNode x = frameState.pop(JavaKind.Object);
4222         genIf(x, cond, y);
4223     }
4224 
4225     private void genIfSame(JavaKind kind, Condition cond) {
4226         ValueNode y = frameState.pop(kind);
4227         ValueNode x = frameState.pop(kind);
4228         genIf(x, cond, y);
4229     }
4230 
4231     private static void initialize(ResolvedJavaType resolvedType) {
4232         /*
4233          * Since we&#39;re potentially triggering class initialization here, we need synchronization to
4234          * mitigate the potential for class initialization related deadlock being caused by the
4235          * compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4236          */
4237         synchronized (BytecodeParser.class) {
4238             resolvedType.initialize();
4239         }
4240     }
4241 
4242     protected JavaType lookupType(int cpi, int bytecode) {
4243         maybeEagerlyResolve(cpi, bytecode);
4244         JavaType result = constantPool.lookupType(cpi, bytecode);
4245         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaType;
4246         return result;
4247     }
4248 
4249     private String unresolvedMethodAssertionMessage(JavaMethod result) {
4250         String message = result.format(&quot;%H.%n(%P)%R&quot;);
4251         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
4252             JavaType declaringClass = result.getDeclaringClass();
4253             String className = declaringClass.getName();
4254             switch (className) {
4255                 case &quot;Ljava/nio/ByteBuffer;&quot;:
4256                 case &quot;Ljava/nio/ShortBuffer;&quot;:
4257                 case &quot;Ljava/nio/CharBuffer;&quot;:
4258                 case &quot;Ljava/nio/IntBuffer;&quot;:
4259                 case &quot;Ljava/nio/LongBuffer;&quot;:
4260                 case &quot;Ljava/nio/FloatBuffer;&quot;:
4261                 case &quot;Ljava/nio/DoubleBuffer;&quot;:
4262                 case &quot;Ljava/nio/MappedByteBuffer;&quot;: {
4263                     switch (result.getName()) {
4264                         case &quot;position&quot;:
4265                         case &quot;limit&quot;:
4266                         case &quot;mark&quot;:
4267                         case &quot;reset&quot;:
4268                         case &quot;clear&quot;:
4269                         case &quot;flip&quot;:
4270                         case &quot;rewind&quot;: {
4271                             String returnType = result.getSignature().getReturnType(null).toJavaName();
4272                             if (returnType.equals(declaringClass.toJavaName())) {
4273                                 message += String.format(&quot; [Probably cause: %s was compiled with javac from JDK 9+ using &quot; +
4274                                                 &quot;`-target 8` and `-source 8` options. See https://bugs.openjdk.java.net/browse/JDK-4774077 for details.]&quot;, method.getDeclaringClass().toClassName());
4275                             }
4276                         }
4277                     }
4278                     break;
4279                 }
4280             }
4281         }
4282         return message;
4283     }
4284 
4285     private JavaMethod lookupMethod(int cpi, int opcode) {
4286         maybeEagerlyResolve(cpi, opcode);
4287         JavaMethod result = lookupMethodInPool(cpi, opcode);
4288         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaMethod : unresolvedMethodAssertionMessage(result);
4289         return result;
4290     }
4291 
4292     protected JavaMethod lookupMethodInPool(int cpi, int opcode) {
4293         return constantPool.lookupMethod(cpi, opcode);
4294     }
4295 
4296     protected JavaField lookupField(int cpi, int opcode) {
4297         maybeEagerlyResolve(cpi, opcode);
4298         JavaField result = constantPool.lookupField(cpi, method, opcode);
4299         return lookupField(result);
4300     }
4301 
4302     protected JavaField lookupField(JavaField result) {
4303         assert !graphBuilderConfig.unresolvedIsError() || result instanceof ResolvedJavaField : &quot;Not resolved: &quot; + result;
4304         if (parsingIntrinsic() || eagerInitializing) {
4305             if (result instanceof ResolvedJavaField) {
4306                 ResolvedJavaType declaringClass = ((ResolvedJavaField) result).getDeclaringClass();
4307                 if (!declaringClass.isInitialized()) {
4308                     // Even with eager initialization, superinterfaces are not always initialized.
4309                     // See StaticInterfaceFieldTest
4310                     assert !eagerInitializing || declaringClass.isInterface() : &quot;Declaring class not initialized but not an interface? &quot; + declaringClass;
4311                     initialize(declaringClass);
4312                 }
4313             }
4314         }
4315         assert !uninitializedIsError || (result instanceof ResolvedJavaField &amp;&amp; ((ResolvedJavaField) result).getDeclaringClass().isInitialized()) : result;
4316         return result;
4317     }
4318 
4319     private Object lookupConstant(int cpi, int opcode) {
4320         maybeEagerlyResolve(cpi, opcode);
4321         Object result = constantPool.lookupConstant(cpi);
4322         assert !graphBuilderConfig.unresolvedIsError() || !(result instanceof JavaType) || (result instanceof ResolvedJavaType) : result;
4323         return result;
4324     }
4325 
4326     protected void maybeEagerlyResolve(int cpi, int bytecode) {
4327         if (intrinsicContext != null) {
4328             constantPool.loadReferencedType(cpi, bytecode);
4329         } else if (graphBuilderConfig.eagerResolving()) {
4330             /*
4331              * Since we&#39;re potentially triggering class initialization here, we need synchronization
4332              * to mitigate the potential for class initialization related deadlock being caused by
4333              * the compiler (e.g., https://github.com/graalvm/graal-core/pull/232/files#r90788550).
4334              */
4335             synchronized (BytecodeParser.class) {
4336                 ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4337                 if (classInitializationPlugin != null) {
4338                     classInitializationPlugin.loadReferencedType(this, constantPool, cpi, bytecode);
4339                 } else {
4340                     constantPool.loadReferencedType(cpi, bytecode);
4341                 }
4342             }
4343         }
4344     }
4345 
4346     protected JavaType maybeEagerlyResolve(JavaType type, ResolvedJavaType accessingClass) {
4347         if (graphBuilderConfig.eagerResolving() || parsingIntrinsic()) {
4348             return type.resolve(accessingClass);
4349         }
4350         return type;
4351     }
4352 
4353     protected void maybeEagerlyInitialize(ResolvedJavaType resolvedType) {
4354         if (!resolvedType.isInitialized() &amp;&amp; eagerInitializing) {
4355             initialize(resolvedType);
4356         }
4357     }
4358 
4359     private JavaTypeProfile getProfileForTypeCheck(TypeReference type) {
4360         if (parsingIntrinsic() || profilingInfo == null || !optimisticOpts.useTypeCheckHints(getOptions()) || type.isExact()) {
4361             return null;
4362         } else {
4363             return profilingInfo.getTypeProfile(bci());
4364         }
4365     }
4366 
4367     private void genCheckCast(int cpi) {
4368         JavaType type = lookupType(cpi, CHECKCAST);
4369         ValueNode object = frameState.pop(JavaKind.Object);
4370         genCheckCast(type, object);
4371     }
4372 
4373     protected void genCheckCast(JavaType type, ValueNode object) {
4374         if (typeIsResolved(type)) {
4375             genCheckCast((ResolvedJavaType) type, object);
4376         } else {
4377             handleUnresolvedCheckCast(type, object);
4378         }
4379     }
4380 
4381     protected void genCheckCast(ResolvedJavaType resolvedType, ValueNode objectIn) {
4382         ValueNode object = objectIn;
4383         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4384         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4385 
4386         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4387             if (plugin.handleCheckCast(this, object, checkedType.getType(), profile)) {
4388                 return;
4389             }
4390         }
4391 
4392         ValueNode castNode = null;
4393         if (profile != null) {
4394             if (profile.getNullSeen().isFalse()) {
4395                 object = nullCheckedValue(object);
4396                 ResolvedJavaType singleType = profile.asSingleType();
4397                 if (singleType != null &amp;&amp; checkedType.getType().isAssignableFrom(singleType)) {
4398                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4399                     if (typeCheck.isTautology()) {
4400                         castNode = object;
4401                     } else {
4402                         FixedGuardNode fixedGuard = append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile, false));
4403                         castNode = append(PiNode.create(object, StampFactory.objectNonNull(TypeReference.createExactTrusted(singleType)), fixedGuard));
4404                     }
4405                 }
4406             }
4407         }
4408 
4409         boolean nonNull = ((ObjectStamp) object.stamp(NodeView.DEFAULT)).nonNull();
4410         if (castNode == null) {
4411             LogicNode condition = genUnique(createInstanceOfAllowNull(checkedType, object, null));
4412             if (condition.isTautology()) {
4413                 castNode = object;
4414             } else {
4415                 GuardingNode guard;
4416                 if (needsExplicitClassCastException(object)) {
4417                     Constant hub = getConstantReflection().asObjectHub(resolvedType);
4418                     Stamp hubStamp = getStampProvider().createHubStamp(StampFactory.object(TypeReference.createExactTrusted(resolvedType)));
4419                     ConstantNode hubConstant = ConstantNode.forConstant(hubStamp, hub, getMetaAccess(), graph);
4420                     guard = emitBytecodeExceptionCheck(condition, true, BytecodeExceptionKind.CLASS_CAST, object, hubConstant);
4421                 } else {
4422                     guard = append(new FixedGuardNode(condition, DeoptimizationReason.ClassCastException, DeoptimizationAction.InvalidateReprofile, false));
4423                 }
4424                 castNode = append(PiNode.create(object, StampFactory.object(checkedType, nonNull), guard.asNode()));
4425             }
4426         }
4427         frameState.push(JavaKind.Object, castNode);
4428     }
4429 
4430     private void genInstanceOf(int cpi) {
4431         JavaType type = lookupType(cpi, INSTANCEOF);
4432         ValueNode object = frameState.pop(JavaKind.Object);
4433         genInstanceOf(type, object);
4434     }
4435 
4436     protected void genInstanceOf(JavaType type, ValueNode object) {
4437         if (typeIsResolved(type)) {
4438             genInstanceOf((ResolvedJavaType) type, object);
4439         } else {
4440             handleUnresolvedInstanceOf(type, object);
4441         }
4442     }
4443 
4444     @SuppressWarnings(&quot;try&quot;)
4445     protected void genInstanceOf(ResolvedJavaType resolvedType, ValueNode objectIn) {
4446         ValueNode object = objectIn;
4447         TypeReference checkedType = TypeReference.createTrusted(graph.getAssumptions(), resolvedType);
4448         JavaTypeProfile profile = getProfileForTypeCheck(checkedType);
4449 
4450         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4451             if (plugin.handleInstanceOf(this, object, checkedType.getType(), profile)) {
4452                 return;
4453             }
4454         }
4455 
4456         LogicNode instanceOfNode = null;
4457         if (profile != null) {
4458             if (profile.getNullSeen().isFalse()) {
4459                 object = nullCheckedValue(object);
4460                 ResolvedJavaType singleType = profile.asSingleType();
4461                 if (singleType != null) {
4462                     LogicNode typeCheck = append(createInstanceOf(TypeReference.createExactTrusted(singleType), object, profile));
4463                     if (!typeCheck.isTautology()) {
4464                         append(new FixedGuardNode(typeCheck, DeoptimizationReason.TypeCheckedInliningViolated, DeoptimizationAction.InvalidateReprofile));
4465                     }
4466                     instanceOfNode = LogicConstantNode.forBoolean(checkedType.getType().isAssignableFrom(singleType));
4467                 }
4468             }
4469         }
4470         if (instanceOfNode == null) {
4471             instanceOfNode = createInstanceOf(checkedType, object, null);
4472         }
4473         LogicNode logicNode = genUnique(instanceOfNode);
4474 
4475         int next = getStream().nextBCI();
4476         int value = getStream().readUByte(next);
4477         if (next &lt;= currentBlock.endBci &amp;&amp; (value == Bytecodes.IFEQ || value == Bytecodes.IFNE)) {
4478             getStream().next();
4479             try (DebugCloseable context = openNodeContext()) {
4480                 BciBlock firstSucc = currentBlock.getSuccessor(0);
4481                 BciBlock secondSucc = currentBlock.getSuccessor(1);
4482                 if (firstSucc != secondSucc) {
4483                     boolean negate = value != Bytecodes.IFNE;
4484                     if (negate) {
4485                         BciBlock tmp = firstSucc;
4486                         firstSucc = secondSucc;
4487                         secondSucc = tmp;
4488                     }
4489                     genIf(instanceOfNode, firstSucc, secondSucc, getProfileProbability(negate));
4490                 } else {
4491                     appendGoto(firstSucc);
4492                 }
4493             }
4494         } else {
4495             // Most frequent for value is IRETURN, followed by ISTORE.
4496             frameState.push(JavaKind.Int, append(genConditional(logicNode)));
4497         }
4498     }
4499 
4500     protected void genNewInstance(int cpi) {
4501         JavaType type = lookupType(cpi, NEW);
4502         genNewInstance(type);
4503     }
4504 
4505     protected void genNewInstance(JavaType type) {
4506         if (typeIsResolved(type)) {
4507             genNewInstance((ResolvedJavaType) type);
4508         } else {
4509             handleUnresolvedNewInstance(type);
4510         }
4511     }
4512 
4513     protected void genNewInstance(ResolvedJavaType resolvedType) {
4514         if (resolvedType.isAbstract() || resolvedType.isInterface()) {
4515             handleIllegalNewInstance(resolvedType);
4516             return;
4517         }
4518         maybeEagerlyInitialize(resolvedType);
4519 
4520         ClassInitializationPlugin classInitializationPlugin = graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4521         if (!resolvedType.isInitialized() &amp;&amp; classInitializationPlugin == null) {
4522             handleIllegalNewInstance(resolvedType);
4523             return;
4524         }
4525 
4526         for (ResolvedJavaType exceptionType : this.graphBuilderConfig.getSkippedExceptionTypes()) {
4527             if (exceptionType.isAssignableFrom(resolvedType)) {
4528                 append(new DeoptimizeNode(DeoptimizationAction.InvalidateRecompile, RuntimeConstraint));
4529                 return;
4530             }
4531         }
4532 
4533         if (classInitializationPlugin != null) {
4534             classInitializationPlugin.apply(this, resolvedType, this::createCurrentFrameState);
4535         }
4536 
4537         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4538             if (plugin.handleNewInstance(this, resolvedType)) {
4539                 return;
4540             }
4541         }
4542 
4543         frameState.push(JavaKind.Object, append(createNewInstance(resolvedType, true)));
4544     }
4545 
4546     /**
4547      * Gets the kind of array elements for the array type code that appears in a
4548      * {@link Bytecodes#NEWARRAY} bytecode.
4549      *
4550      * @param code the array type code
4551      * @return the kind from the array type code
4552      */
4553     private static Class&lt;?&gt; arrayTypeCodeToClass(int code) {
4554         switch (code) {
4555             case 4:
4556                 return boolean.class;
4557             case 5:
4558                 return char.class;
4559             case 6:
4560                 return float.class;
4561             case 7:
4562                 return double.class;
4563             case 8:
4564                 return byte.class;
4565             case 9:
4566                 return short.class;
4567             case 10:
4568                 return int.class;
4569             case 11:
4570                 return long.class;
4571             default:
4572                 throw new IllegalArgumentException(&quot;unknown array type code: &quot; + code);
4573         }
4574     }
4575 
4576     private void genNewPrimitiveArray(int typeCode) {
4577         ResolvedJavaType elementType = getMetaAccess().lookupJavaType(arrayTypeCodeToClass(typeCode));
4578         ValueNode length = frameState.pop(JavaKind.Int);
4579 
4580         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4581             if (plugin.handleNewArray(this, elementType, length)) {
4582                 return;
4583             }
4584         }
4585 
4586         frameState.push(JavaKind.Object, append(createNewArray(elementType, length, true)));
4587     }
4588 
4589     private void genNewObjectArray(int cpi) {
4590         JavaType type = lookupType(cpi, ANEWARRAY);
4591         genNewObjectArray(type);
4592     }
4593 
4594     private void genNewObjectArray(JavaType type) {
4595         if (typeIsResolved(type)) {
4596             genNewObjectArray((ResolvedJavaType) type);
4597         } else {
4598             ValueNode length = frameState.pop(JavaKind.Int);
4599             handleUnresolvedNewObjectArray(type, length);
4600         }
4601     }
4602 
4603     private void genNewObjectArray(ResolvedJavaType resolvedType) {
4604 
4605         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4606         if (classInitializationPlugin != null) {
4607             classInitializationPlugin.apply(this, resolvedType.getArrayClass(), this::createCurrentFrameState);
4608         }
4609 
4610         ValueNode length = frameState.pop(JavaKind.Int);
4611         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4612             if (plugin.handleNewArray(this, resolvedType, length)) {
4613                 return;
4614             }
4615         }
4616 
4617         frameState.push(JavaKind.Object, append(createNewArray(resolvedType, length, true)));
4618     }
4619 
4620     private void genNewMultiArray(int cpi) {
4621         JavaType type = lookupType(cpi, MULTIANEWARRAY);
4622         int rank = getStream().readUByte(bci() + 3);
4623         ValueNode[] dims = new ValueNode[rank];
4624         genNewMultiArray(type, rank, dims);
4625     }
4626 
4627     private void genNewMultiArray(JavaType type, int rank, ValueNode[] dims) {
4628         if (typeIsResolved(type)) {
4629             genNewMultiArray((ResolvedJavaType) type, rank, dims);
4630         } else {
4631             for (int i = rank - 1; i &gt;= 0; i--) {
4632                 dims[i] = frameState.pop(JavaKind.Int);
4633             }
4634             handleUnresolvedNewMultiArray(type, dims);
4635         }
4636     }
4637 
4638     private void genNewMultiArray(ResolvedJavaType resolvedType, int rank, ValueNode[] dims) {
4639 
4640         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4641         if (classInitializationPlugin != null) {
4642             classInitializationPlugin.apply(this, resolvedType, this::createCurrentFrameState);
4643         }
4644 
4645         for (int i = rank - 1; i &gt;= 0; i--) {
4646             dims[i] = frameState.pop(JavaKind.Int);
4647         }
4648 
4649         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4650             if (plugin.handleNewMultiArray(this, resolvedType, dims)) {
4651                 return;
4652             }
4653         }
4654 
4655         frameState.push(JavaKind.Object, append(createNewMultiArray(resolvedType, dims)));
4656     }
4657 
4658     protected void genGetField(int cpi, int opcode) {
4659         genGetField(cpi, opcode, frameState.pop(JavaKind.Object));
4660     }
4661 
4662     protected void genGetField(int cpi, int opcode, ValueNode receiverInput) {
4663         JavaField field = lookupField(cpi, opcode);
4664         genGetField(field, receiverInput);
4665     }
4666 
4667     private void genGetField(JavaField field, ValueNode receiverInput) {
4668         if (field instanceof ResolvedJavaField) {
4669             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4670             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4671             genGetField(resolvedField, receiver);
4672         } else {
4673             handleUnresolvedLoadField(field, receiverInput);
4674         }
4675     }
4676 
4677     private void genGetField(ResolvedJavaField resolvedField, ValueNode receiver) {
4678         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4679             graph.recordField(resolvedField);
4680         }
4681 
4682         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4683             if (plugin.handleLoadField(this, receiver, resolvedField)) {
4684                 return;
4685             }
4686         }
4687 
4688         ValueNode fieldRead = append(genLoadField(receiver, resolvedField));
4689 
4690         if (resolvedField.getDeclaringClass().getName().equals(&quot;Ljava/lang/ref/Reference;&quot;) &amp;&amp; resolvedField.getName().equals(&quot;referent&quot;)) {
4691             LocationIdentity referentIdentity = new FieldLocationIdentity(resolvedField);
4692             append(new MembarNode(0, referentIdentity));
4693         }
4694 
4695         JavaKind fieldKind = resolvedField.getJavaKind();
4696 
4697         pushLoadField(resolvedField, fieldRead, fieldKind);
4698     }
4699 
4700     /**
4701      * Returns true if an explicit null check should be emitted for the given object.
4702      *
4703      * @param object The object that is accessed.
4704      */
4705     protected boolean needsExplicitNullCheckException(ValueNode object) {
4706         return needsExplicitException();
4707     }
4708 
4709     /**
4710      * Returns true if an explicit null check should be emitted for the given object.
4711      *
4712      * @param array The array that is accessed.
4713      * @param index The array index that is accessed.
4714      */
4715     protected boolean needsExplicitBoundsCheckException(ValueNode array, ValueNode index) {
4716         return needsExplicitException();
4717     }
4718 
4719     /**
4720      * Returns true if an explicit check for a {@link ClassCastException} should be emitted for the
4721      * given object.
4722      *
4723      * @param object The object that is accessed.
4724      */
4725     protected boolean needsExplicitClassCastException(ValueNode object) {
4726         return needsExplicitException();
4727     }
4728 
4729     /**
4730      * Returns true if an explicit null check should be emitted for the given object.
4731      *
4732      * @param array The array that is accessed.
4733      * @param value The value that is stored into the array.
4734      */
4735     protected boolean needsExplicitStoreCheckException(ValueNode array, ValueNode value) {
4736         return needsExplicitException();
4737     }
4738 
4739     /**
4740      * Returns true if an explicit null check should be emitted for the given object.
4741      *
4742      * @param y The dividend.
4743      */
4744     protected boolean needsExplicitDivisionByZeroException(ValueNode y) {
4745         return needsExplicitException();
4746     }
4747 
4748     @Override
4749     public boolean needsExplicitException() {
4750         BytecodeExceptionMode exceptionMode = graphBuilderConfig.getBytecodeExceptionMode();
4751         if (exceptionMode == BytecodeExceptionMode.CheckAll || StressExplicitExceptionCode.getValue(options)) {
4752             return true;
4753         } else if (exceptionMode == BytecodeExceptionMode.Profile &amp;&amp; profilingInfo != null) {
4754             return profilingInfo.getExceptionSeen(bci()) == TriState.TRUE;
4755         }
4756         return false;
4757     }
4758 
4759     @Override
4760     public AbstractBeginNode genExplicitExceptionEdge(BytecodeExceptionKind exceptionKind) {
4761         BytecodeExceptionNode exceptionNode = graph.add(new BytecodeExceptionNode(getMetaAccess(), exceptionKind));
4762         exceptionNode.setStateAfter(createBytecodeExceptionFrameState(bci(), exceptionNode));
4763         AbstractBeginNode exceptionDispatch = handleException(exceptionNode, bci(), false);
4764         exceptionNode.setNext(exceptionDispatch);
4765         return BeginNode.begin(exceptionNode);
4766     }
4767 
4768     protected void genPutField(int cpi, int opcode) {
4769         JavaField field = lookupField(cpi, opcode);
4770         genPutField(field);
4771     }
4772 
4773     protected void genPutField(JavaField field) {
4774         genPutField(field, frameState.pop(field.getJavaKind()));
4775     }
4776 
4777     private void genPutField(JavaField field, ValueNode value) {
4778         ValueNode receiverInput = frameState.pop(JavaKind.Object);
4779 
4780         if (field instanceof ResolvedJavaField) {
4781             ValueNode receiver = maybeEmitExplicitNullCheck(receiverInput);
4782             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4783 
4784             if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4785                 graph.recordField(resolvedField);
4786             }
4787 
4788             for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4789                 if (plugin.handleStoreField(this, receiver, resolvedField, value)) {
4790                     return;
4791                 }
4792             }
4793 
4794             if (resolvedField.isFinal() &amp;&amp; method.isConstructor()) {
4795                 finalBarrierRequired = true;
4796             }
4797             genStoreField(receiver, resolvedField, value);
4798         } else {
4799             handleUnresolvedStoreField(field, value, receiverInput);
4800         }
4801     }
4802 
4803     protected void genGetStatic(int cpi, int opcode) {
4804         JavaField field = lookupField(cpi, opcode);
4805         genGetStatic(field);
4806     }
4807 
4808     private void genGetStatic(JavaField field) {
4809         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, null);
4810         if (resolvedField == null) {
4811             return;
4812         }
4813 
4814         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4815             graph.recordField(resolvedField);
4816         }
4817 
4818         /*
4819          * Javac does not allow use of &quot;$assertionsDisabled&quot; for a field name but Eclipse does, in
4820          * which case a suffix is added to the generated field.
4821          */
4822         if (resolvedField.isSynthetic() &amp;&amp; resolvedField.getName().startsWith(&quot;$assertionsDisabled&quot;)) {
4823             if (parsingIntrinsic()) {
4824                 throw new GraalError(&quot;Cannot use an assertion within the context of an intrinsic: &quot; + resolvedField);
4825             } else if (graphBuilderConfig.omitAssertions()) {
4826                 frameState.push(field.getJavaKind(), ConstantNode.forBoolean(true, graph));
4827                 return;
4828             }
4829         }
4830 
4831         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4832         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4833         if (classInitializationPlugin != null) {
4834             classInitializationPlugin.apply(this, holder, this::createCurrentFrameState);
4835         }
4836 
4837         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4838             if (plugin.handleLoadStaticField(this, resolvedField)) {
4839                 return;
4840             }
4841         }
4842 
4843         ValueNode fieldRead = append(genLoadField(null, resolvedField));
4844         JavaKind fieldKind = resolvedField.getJavaKind();
4845 
4846         pushLoadField(resolvedField, fieldRead, fieldKind);
4847     }
4848 
4849     /**
4850      * Pushes a loaded field onto the stack. If the loaded field is volatile, a
4851      * {@link StateSplitProxyNode} is appended so that deoptimization does not deoptimize to a point
4852      * before the field load.
4853      */
4854     private void pushLoadField(ResolvedJavaField resolvedField, ValueNode fieldRead, JavaKind fieldKind) {
4855         if (resolvedField.isVolatile() &amp;&amp; fieldRead instanceof LoadFieldNode) {
4856             StateSplitProxyNode readProxy = append(genVolatileFieldReadProxy(fieldRead));
4857             frameState.push(fieldKind, readProxy);
4858             readProxy.setStateAfter(frameState.create(stream.nextBCI(), readProxy));
4859         } else {
4860             frameState.push(fieldKind, fieldRead);
4861         }
4862     }
4863 
4864     private ResolvedJavaField resolveStaticFieldAccess(JavaField field, ValueNode value) {
4865         if (field instanceof ResolvedJavaField) {
4866             ResolvedJavaField resolvedField = (ResolvedJavaField) field;
4867             ResolvedJavaType resolvedType = resolvedField.getDeclaringClass();
4868             maybeEagerlyInitialize(resolvedType);
4869 
4870             if (resolvedType.isInitialized() || graphBuilderConfig.getPlugins().getClassInitializationPlugin() != null) {
4871                 return resolvedField;
4872             }
4873 
4874             /*
4875              * Static fields have initialization semantics but may be safely accessed under certain
4876              * conditions while the class is being initialized. Executing in the clinit or init of
4877              * subclasses (but not implementers) of the field holder are sure to be running in a
4878              * context where the access is safe.
4879              */
4880             if (!resolvedType.isInterface() &amp;&amp; resolvedType.isAssignableFrom(method.getDeclaringClass())) {
4881                 if (method.isClassInitializer() || method.isConstructor()) {
4882                     return resolvedField;
4883                 }
4884             }
4885         }
4886         if (value == null) {
4887             handleUnresolvedLoadField(field, null);
4888         } else {
4889             handleUnresolvedStoreField(field, value, null);
4890 
4891         }
4892         return null;
4893     }
4894 
4895     protected void genPutStatic(int cpi, int opcode) {
4896         JavaField field = lookupField(cpi, opcode);
4897         genPutStatic(field);
4898     }
4899 
4900     protected void genPutStatic(JavaField field) {
4901         int stackSizeBefore = frameState.stackSize();
4902         ValueNode value = frameState.pop(field.getJavaKind());
4903         ResolvedJavaField resolvedField = resolveStaticFieldAccess(field, value);
4904         if (resolvedField == null) {
4905             return;
4906         }
4907 
4908         if (!parsingIntrinsic() &amp;&amp; GeneratePIC.getValue(getOptions())) {
4909             graph.recordField(resolvedField);
4910         }
4911 
4912         ClassInitializationPlugin classInitializationPlugin = this.graphBuilderConfig.getPlugins().getClassInitializationPlugin();
4913         ResolvedJavaType holder = resolvedField.getDeclaringClass();
4914         if (classInitializationPlugin != null) {
4915             Supplier&lt;FrameState&gt; stateBefore = () -&gt; {
4916                 JavaKind[] pushedSlotKinds = {field.getJavaKind()};
4917                 ValueNode[] pushedValues = {value};
4918                 FrameState fs = frameState.create(bci(), getNonIntrinsicAncestor(), false, pushedSlotKinds, pushedValues);
4919                 assert stackSizeBefore == fs.stackSize();
4920                 return fs;
4921             };
4922             classInitializationPlugin.apply(this, holder, stateBefore);
4923         }
4924 
4925         for (NodePlugin plugin : graphBuilderConfig.getPlugins().getNodePlugins()) {
4926             if (plugin.handleStoreStaticField(this, resolvedField, value)) {
4927                 return;
4928             }
4929         }
4930 
4931         genStoreField(null, resolvedField, value);
4932     }
4933 
4934     private double[] switchProbability(int numberOfCases, int bci) {
4935         double[] prob = (profilingInfo == null ? null : profilingInfo.getSwitchProbabilities(bci));
4936         if (prob != null) {
4937             assert prob.length == numberOfCases;
4938         } else {
4939             debug.log(&quot;Missing probability (switch) in %s at bci %d&quot;, method, bci);
4940             prob = new double[numberOfCases];
4941             for (int i = 0; i &lt; numberOfCases; i++) {
4942                 prob[i] = 1.0d / numberOfCases;
4943             }
4944         }
4945         assert allPositive(prob);
4946         return prob;
4947     }
4948 
4949     private static boolean allPositive(double[] a) {
4950         for (double d : a) {
4951             if (d &lt; 0) {
4952                 return false;
4953             }
4954         }
4955         return true;
4956     }
4957 
4958     static class SuccessorInfo {
4959         final int blockIndex;
4960         int actualIndex;
4961 
4962         SuccessorInfo(int blockSuccessorIndex) {
4963             this.blockIndex = blockSuccessorIndex;
4964             actualIndex = -1;
4965         }
4966     }
4967 
4968     private static final int SWITCH_DEOPT_UNSEEN = -2;
4969     private static final int SWITCH_DEOPT_SEEN = -1;
4970 
4971     private void genSwitch(BytecodeSwitch bs) {
4972         int bci = bci();
4973         ValueNode value = frameState.pop(JavaKind.Int);
4974 
4975         int nofCases = bs.numberOfCases();
4976         int nofCasesPlusDefault = nofCases + 1;
4977         double[] keyProbabilities = switchProbability(nofCasesPlusDefault, bci);
4978 
4979         EconomicMap&lt;Integer, SuccessorInfo&gt; bciToBlockSuccessorIndex = EconomicMap.create(Equivalence.DEFAULT);
4980         for (int i = 0; i &lt; currentBlock.getSuccessorCount(); i++) {
4981             assert !bciToBlockSuccessorIndex.containsKey(currentBlock.getSuccessor(i).startBci);
4982             bciToBlockSuccessorIndex.put(currentBlock.getSuccessor(i).startBci, new SuccessorInfo(i));
4983         }
4984 
4985         ArrayList&lt;BciBlock&gt; actualSuccessors = new ArrayList&lt;&gt;();
4986         int[] keys = new int[nofCases];
4987         int[] keySuccessors = new int[nofCasesPlusDefault];
4988         int deoptSuccessorIndex = SWITCH_DEOPT_UNSEEN;
4989         int nextSuccessorIndex = 0;
4990         boolean constantValue = value.isConstant();
4991         for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
4992             if (i &lt; nofCases) {
4993                 keys[i] = bs.keyAt(i);
4994             }
4995             if (!constantValue &amp;&amp; isNeverExecutedCode(keyProbabilities[i])) {
4996                 deoptSuccessorIndex = SWITCH_DEOPT_SEEN;
4997                 keySuccessors[i] = SWITCH_DEOPT_SEEN;
4998             } else {
4999                 int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5000                 SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5001                 if (info.actualIndex &lt; 0) {
5002                     info.actualIndex = nextSuccessorIndex++;
5003                     actualSuccessors.add(currentBlock.getSuccessor(info.blockIndex));
5004                 }
5005                 keySuccessors[i] = info.actualIndex;
5006             }
5007         }
5008         /*
5009          * When the profile indicates a case is never taken, the above code will cause the case to
5010          * deopt should it be subsequently encountered. However, the case may share code with
5011          * another case that is taken according to the profile.
5012          *
5013          * For example:
5014          * // @formatter:off
5015          * switch (opcode) {
5016          *     case GOTO:
5017          *     case GOTO_W: {
5018          *         // emit goto code
5019          *         break;
5020          *     }
5021          * }
5022          * // @formatter:on
5023          *
5024          * The profile may indicate the GOTO_W case is never taken, and thus a deoptimization stub
5025          * will be emitted. There might be optimization opportunity if additional branching based
5026          * on opcode is within the case block. Specially, if there is only single case that
5027          * reaches a target, we have better chance cutting out unused branches. Otherwise,
5028          * it might be beneficial routing to the same code instead of deopting.
5029          *
5030          * The following code rewires deoptimization stub to existing resolved branch target if
5031          * the target is connected by more than 1 cases.
5032          *
5033          * If this operation rewires every deoptimization seen to an existing branch, care is
5034          * taken that we do not spawn a branch that will never be taken.
5035          */
5036         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {
5037             int[] connectedCases = new int[nextSuccessorIndex + 1];
5038             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
5039                 connectedCases[keySuccessors[i] + 1]++;
5040             }
5041 
5042             for (int i = 0; i &lt; nofCasesPlusDefault; i++) {
5043                 if (keySuccessors[i] == SWITCH_DEOPT_SEEN) {
5044                     int targetBci = i &lt; nofCases ? bs.targetAt(i) : bs.defaultTarget();
5045                     SuccessorInfo info = bciToBlockSuccessorIndex.get(targetBci);
5046                     int rewiredIndex = info.actualIndex;
5047                     if (rewiredIndex &gt;= 0 &amp;&amp; connectedCases[rewiredIndex + 1] &gt; 1) {
5048                         // Rewire
5049                         keySuccessors[i] = info.actualIndex;
5050                     } else {
5051                         if (deoptSuccessorIndex == SWITCH_DEOPT_SEEN) {
5052                             // Spawn deopt successor if needed.
5053                             deoptSuccessorIndex = nextSuccessorIndex++;
5054                             actualSuccessors.add(null);
5055                         }
5056                         keySuccessors[i] = deoptSuccessorIndex;
5057                     }
5058                 }
5059             }
5060         }
5061 
5062         genIntegerSwitch(value, actualSuccessors, keys, keyProbabilities, keySuccessors);
5063 
5064     }
5065 
5066     protected boolean isNeverExecutedCode(double probability) {
5067         return probability == 0 &amp;&amp; optimisticOpts.removeNeverExecutedCode(getOptions());
5068     }
5069 
5070     private double clampProbability(double probability) {
5071         if (!optimisticOpts.removeNeverExecutedCode(getOptions())) {
5072             if (probability == 0) {
5073                 return LUDICROUSLY_SLOW_PATH_PROBABILITY;
5074             } else if (probability == 1) {
5075                 return LUDICROUSLY_FAST_PATH_PROBABILITY;
5076             }
5077         }
5078         return probability;
5079     }
5080 
5081     private boolean assertAtIfBytecode() {
5082         int bytecode = stream.currentBC();
5083         switch (bytecode) {
5084             case IFEQ:
5085             case IFNE:
5086             case IFLT:
5087             case IFGE:
5088             case IFGT:
5089             case IFLE:
5090             case IF_ICMPEQ:
5091             case IF_ICMPNE:
5092             case IF_ICMPLT:
5093             case IF_ICMPGE:
5094             case IF_ICMPGT:
5095             case IF_ICMPLE:
5096             case IF_ACMPEQ:
5097             case IF_ACMPNE:
5098             case IFNULL:
5099             case IFNONNULL:
5100                 return true;
5101         }
5102         assert false : String.format(&quot;%x is not an if bytecode&quot;, bytecode);
5103         return true;
5104     }
5105 
5106     public final void processBytecode(int bci, int opcode) {
5107         int cpi;
5108 
5109         // @formatter:off
5110         // Checkstyle: stop
5111         switch (opcode) {
5112             case NOP            : /* nothing to do */ break;
5113             case ACONST_NULL    : frameState.push(JavaKind.Object, appendConstant(JavaConstant.NULL_POINTER)); break;
5114             case ICONST_M1      : // fall through
5115             case ICONST_0       : // fall through
5116             case ICONST_1       : // fall through
5117             case ICONST_2       : // fall through
5118             case ICONST_3       : // fall through
5119             case ICONST_4       : // fall through
5120             case ICONST_5       : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(opcode - ICONST_0))); break;
5121             case LCONST_0       : // fall through
5122             case LCONST_1       : frameState.push(JavaKind.Long, appendConstant(JavaConstant.forLong(opcode - LCONST_0))); break;
5123             case FCONST_0       : // fall through
5124             case FCONST_1       : // fall through
5125             case FCONST_2       : frameState.push(JavaKind.Float, appendConstant(JavaConstant.forFloat(opcode - FCONST_0))); break;
5126             case DCONST_0       : // fall through
5127             case DCONST_1       : frameState.push(JavaKind.Double, appendConstant(JavaConstant.forDouble(opcode - DCONST_0))); break;
5128             case BIPUSH         : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(stream.readByte()))); break;
5129             case SIPUSH         : frameState.push(JavaKind.Int, appendConstant(JavaConstant.forInt(stream.readShort()))); break;
5130             case LDC            : // fall through
5131             case LDC_W          : // fall through
5132             case LDC2_W         : genLoadConstant(stream.readCPI(), opcode); break;
5133             case ILOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Int); break;
5134             case LLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Long); break;
5135             case FLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Float); break;
5136             case DLOAD          : loadLocal(stream.readLocalIndex(), JavaKind.Double); break;
5137             case ALOAD          : loadLocalObject(stream.readLocalIndex()); break;
5138             case ILOAD_0        : // fall through
5139             case ILOAD_1        : // fall through
5140             case ILOAD_2        : // fall through
5141             case ILOAD_3        : loadLocal(opcode - ILOAD_0, JavaKind.Int); break;
5142             case LLOAD_0        : // fall through
5143             case LLOAD_1        : // fall through
5144             case LLOAD_2        : // fall through
5145             case LLOAD_3        : loadLocal(opcode - LLOAD_0, JavaKind.Long); break;
5146             case FLOAD_0        : // fall through
5147             case FLOAD_1        : // fall through
5148             case FLOAD_2        : // fall through
5149             case FLOAD_3        : loadLocal(opcode - FLOAD_0, JavaKind.Float); break;
5150             case DLOAD_0        : // fall through
5151             case DLOAD_1        : // fall through
5152             case DLOAD_2        : // fall through
5153             case DLOAD_3        : loadLocal(opcode - DLOAD_0, JavaKind.Double); break;
5154             case ALOAD_0        : // fall through
5155             case ALOAD_1        : // fall through
5156             case ALOAD_2        : // fall through
5157             case ALOAD_3        : loadLocalObject(opcode - ALOAD_0); break;
5158             case IALOAD         : genLoadIndexed(JavaKind.Int   ); break;
5159             case LALOAD         : genLoadIndexed(JavaKind.Long  ); break;
5160             case FALOAD         : genLoadIndexed(JavaKind.Float ); break;
5161             case DALOAD         : genLoadIndexed(JavaKind.Double); break;
5162             case AALOAD         : genLoadIndexed(JavaKind.Object); break;
5163             case BALOAD         : genLoadIndexed(JavaKind.Byte  ); break;
5164             case CALOAD         : genLoadIndexed(JavaKind.Char  ); break;
5165             case SALOAD         : genLoadIndexed(JavaKind.Short ); break;
5166             case ISTORE         : storeLocal(JavaKind.Int, stream.readLocalIndex()); break;
5167             case LSTORE         : storeLocal(JavaKind.Long, stream.readLocalIndex()); break;
5168             case FSTORE         : storeLocal(JavaKind.Float, stream.readLocalIndex()); break;
5169             case DSTORE         : storeLocal(JavaKind.Double, stream.readLocalIndex()); break;
5170             case ASTORE         : storeLocal(JavaKind.Object, stream.readLocalIndex()); break;
5171             case ISTORE_0       : // fall through
5172             case ISTORE_1       : // fall through
5173             case ISTORE_2       : // fall through
5174             case ISTORE_3       : storeLocal(JavaKind.Int, opcode - ISTORE_0); break;
5175             case LSTORE_0       : // fall through
5176             case LSTORE_1       : // fall through
5177             case LSTORE_2       : // fall through
5178             case LSTORE_3       : storeLocal(JavaKind.Long, opcode - LSTORE_0); break;
5179             case FSTORE_0       : // fall through
5180             case FSTORE_1       : // fall through
5181             case FSTORE_2       : // fall through
5182             case FSTORE_3       : storeLocal(JavaKind.Float, opcode - FSTORE_0); break;
5183             case DSTORE_0       : // fall through
5184             case DSTORE_1       : // fall through
5185             case DSTORE_2       : // fall through
5186             case DSTORE_3       : storeLocal(JavaKind.Double, opcode - DSTORE_0); break;
5187             case ASTORE_0       : // fall through
5188             case ASTORE_1       : // fall through
5189             case ASTORE_2       : // fall through
5190             case ASTORE_3       : storeLocal(JavaKind.Object, opcode - ASTORE_0); break;
5191             case IASTORE        : genStoreIndexed(JavaKind.Int   ); break;
5192             case LASTORE        : genStoreIndexed(JavaKind.Long  ); break;
5193             case FASTORE        : genStoreIndexed(JavaKind.Float ); break;
5194             case DASTORE        : genStoreIndexed(JavaKind.Double); break;
5195             case AASTORE        : genStoreIndexed(JavaKind.Object); break;
5196             case BASTORE        : genStoreIndexed(JavaKind.Byte  ); break;
5197             case CASTORE        : genStoreIndexed(JavaKind.Char  ); break;
5198             case SASTORE        : genStoreIndexed(JavaKind.Short ); break;
5199             case POP            : // fall through
5200             case POP2           : // fall through
5201             case DUP            : // fall through
5202             case DUP_X1         : // fall through
5203             case DUP_X2         : // fall through
5204             case DUP2           : // fall through
5205             case DUP2_X1        : // fall through
5206             case DUP2_X2        : // fall through
5207             case SWAP           : frameState.stackOp(opcode); break;
5208             case IADD           : // fall through
5209             case ISUB           : // fall through
5210             case IMUL           : genArithmeticOp(JavaKind.Int, opcode); break;
5211             case IDIV           : // fall through
5212             case IREM           : genIntegerDivOp(JavaKind.Int, opcode); break;
5213             case LADD           : // fall through
5214             case LSUB           : // fall through
5215             case LMUL           : genArithmeticOp(JavaKind.Long, opcode); break;
5216             case LDIV           : // fall through
5217             case LREM           : genIntegerDivOp(JavaKind.Long, opcode); break;
5218             case FADD           : // fall through
5219             case FSUB           : // fall through
5220             case FMUL           : // fall through
5221             case FDIV           : // fall through
5222             case FREM           : genArithmeticOp(JavaKind.Float, opcode); break;
5223             case DADD           : // fall through
5224             case DSUB           : // fall through
5225             case DMUL           : // fall through
5226             case DDIV           : // fall through
5227             case DREM           : genArithmeticOp(JavaKind.Double, opcode); break;
5228             case INEG           : genNegateOp(JavaKind.Int); break;
5229             case LNEG           : genNegateOp(JavaKind.Long); break;
5230             case FNEG           : genNegateOp(JavaKind.Float); break;
5231             case DNEG           : genNegateOp(JavaKind.Double); break;
5232             case ISHL           : // fall through
5233             case ISHR           : // fall through
5234             case IUSHR          : genShiftOp(JavaKind.Int, opcode); break;
5235             case IAND           : // fall through
5236             case IOR            : // fall through
5237             case IXOR           : genLogicOp(JavaKind.Int, opcode); break;
5238             case LSHL           : // fall through
5239             case LSHR           : // fall through
5240             case LUSHR          : genShiftOp(JavaKind.Long, opcode); break;
5241             case LAND           : // fall through
5242             case LOR            : // fall through
5243             case LXOR           : genLogicOp(JavaKind.Long, opcode); break;
5244             case IINC           : genIncrement(); break;
5245             case I2F            : genFloatConvert(FloatConvert.I2F, JavaKind.Int, JavaKind.Float); break;
5246             case I2D            : genFloatConvert(FloatConvert.I2D, JavaKind.Int, JavaKind.Double); break;
5247             case L2F            : genFloatConvert(FloatConvert.L2F, JavaKind.Long, JavaKind.Float); break;
5248             case L2D            : genFloatConvert(FloatConvert.L2D, JavaKind.Long, JavaKind.Double); break;
5249             case F2I            : genFloatConvert(FloatConvert.F2I, JavaKind.Float, JavaKind.Int); break;
5250             case F2L            : genFloatConvert(FloatConvert.F2L, JavaKind.Float, JavaKind.Long); break;
5251             case F2D            : genFloatConvert(FloatConvert.F2D, JavaKind.Float, JavaKind.Double); break;
5252             case D2I            : genFloatConvert(FloatConvert.D2I, JavaKind.Double, JavaKind.Int); break;
5253             case D2L            : genFloatConvert(FloatConvert.D2L, JavaKind.Double, JavaKind.Long); break;
5254             case D2F            : genFloatConvert(FloatConvert.D2F, JavaKind.Double, JavaKind.Float); break;
5255             case L2I            : genNarrow(JavaKind.Long, JavaKind.Int); break;
5256             case I2L            : genSignExtend(JavaKind.Int, JavaKind.Long); break;
5257             case I2B            : genSignExtend(JavaKind.Byte, JavaKind.Int); break;
5258             case I2S            : genSignExtend(JavaKind.Short, JavaKind.Int); break;
5259             case I2C            : genZeroExtend(JavaKind.Char, JavaKind.Int); break;
5260             case LCMP           : genIntegerCompareOp(JavaKind.Long); break;
5261             case FCMPL          : genFloatCompareOp(JavaKind.Float, true); break;
5262             case FCMPG          : genFloatCompareOp(JavaKind.Float, false); break;
5263             case DCMPL          : genFloatCompareOp(JavaKind.Double, true); break;
5264             case DCMPG          : genFloatCompareOp(JavaKind.Double, false); break;
5265             case IFEQ           : genIfZero(Condition.EQ); break;
5266             case IFNE           : genIfZero(Condition.NE); break;
5267             case IFLT           : genIfZero(Condition.LT); break;
5268             case IFGE           : genIfZero(Condition.GE); break;
5269             case IFGT           : genIfZero(Condition.GT); break;
5270             case IFLE           : genIfZero(Condition.LE); break;
5271             case IF_ICMPEQ      : genIfSame(JavaKind.Int, Condition.EQ); break;
5272             case IF_ICMPNE      : genIfSame(JavaKind.Int, Condition.NE); break;
5273             case IF_ICMPLT      : genIfSame(JavaKind.Int, Condition.LT); break;
5274             case IF_ICMPGE      : genIfSame(JavaKind.Int, Condition.GE); break;
5275             case IF_ICMPGT      : genIfSame(JavaKind.Int, Condition.GT); break;
5276             case IF_ICMPLE      : genIfSame(JavaKind.Int, Condition.LE); break;
5277             case IF_ACMPEQ      : genIfSame(JavaKind.Object, Condition.EQ); break;
5278             case IF_ACMPNE      : genIfSame(JavaKind.Object, Condition.NE); break;
5279             case GOTO           : genGoto(); break;
5280             case JSR            : genJsr(stream.readBranchDest()); break;
5281             case RET            : genRet(stream.readLocalIndex()); break;
5282             case TABLESWITCH    : genSwitch(new BytecodeTableSwitch(getStream(), bci())); break;
5283             case LOOKUPSWITCH   : genSwitch(new BytecodeLookupSwitch(getStream(), bci())); break;
5284             case IRETURN        : genReturn(frameState.pop(JavaKind.Int), JavaKind.Int); break;
5285             case LRETURN        : genReturn(frameState.pop(JavaKind.Long), JavaKind.Long); break;
5286             case FRETURN        : genReturn(frameState.pop(JavaKind.Float), JavaKind.Float); break;
5287             case DRETURN        : genReturn(frameState.pop(JavaKind.Double), JavaKind.Double); break;
5288             case ARETURN        : genReturn(frameState.pop(JavaKind.Object), JavaKind.Object); break;
5289             case RETURN         : genReturn(null, JavaKind.Void); break;
5290             case GETSTATIC      : cpi = stream.readCPI(); genGetStatic(cpi, opcode); break;
5291             case PUTSTATIC      : cpi = stream.readCPI(); genPutStatic(cpi, opcode); break;
5292             case GETFIELD       : cpi = stream.readCPI(); genGetField(cpi, opcode); break;
5293             case PUTFIELD       : cpi = stream.readCPI(); genPutField(cpi, opcode); break;
5294             case INVOKEVIRTUAL  : cpi = stream.readCPI(); genInvokeVirtual(cpi, opcode); break;
5295             case INVOKESPECIAL  : cpi = stream.readCPI(); genInvokeSpecial(cpi, opcode); break;
5296             case INVOKESTATIC   : cpi = stream.readCPI(); genInvokeStatic(cpi, opcode); break;
5297             case INVOKEINTERFACE: cpi = stream.readCPI(); genInvokeInterface(cpi, opcode); break;
5298             case INVOKEDYNAMIC  : cpi = stream.readCPI4(); genInvokeDynamic(cpi, opcode); break;
5299             case NEW            : genNewInstance(stream.readCPI()); break;
5300             case NEWARRAY       : genNewPrimitiveArray(stream.readLocalIndex()); break;
5301             case ANEWARRAY      : genNewObjectArray(stream.readCPI()); break;
5302             case ARRAYLENGTH    : genArrayLength(); break;
5303             case ATHROW         : genThrow(); break;
5304             case CHECKCAST      : genCheckCast(stream.readCPI()); break;
5305             case INSTANCEOF     : genInstanceOf(stream.readCPI()); break;
5306             case MONITORENTER   : genMonitorEnter(frameState.pop(JavaKind.Object), stream.nextBCI()); break;
5307             case MONITOREXIT    : genMonitorExit(frameState.pop(JavaKind.Object), null, stream.nextBCI()); break;
5308             case MULTIANEWARRAY : genNewMultiArray(stream.readCPI()); break;
5309             case IFNULL         : genIfNull(Condition.EQ); break;
5310             case IFNONNULL      : genIfNull(Condition.NE); break;
5311             case GOTO_W         : genGoto(); break;
5312             case JSR_W          : genJsr(stream.readBranchDest()); break;
5313             case BREAKPOINT     : throw new PermanentBailoutException(&quot;concurrent setting of breakpoint&quot;);
5314             default             : throw new PermanentBailoutException(&quot;Unsupported opcode %d (%s) [bci=%d]&quot;, opcode, nameOf(opcode), bci);
5315         }
5316         // @formatter:on
5317         // Checkstyle: resume
5318     }
5319 
5320     private void genArrayLength() {
5321         ValueNode array = maybeEmitExplicitNullCheck(frameState.pop(JavaKind.Object));
5322         frameState.push(JavaKind.Int, append(genArrayLength(array)));
5323     }
5324 
5325     @Override
5326     public ResolvedJavaMethod getMethod() {
5327         return method;
5328     }
5329 
5330     @Override
5331     public Bytecode getCode() {
5332         return code;
5333     }
5334 
5335     public FrameStateBuilder getFrameStateBuilder() {
5336         return frameState;
5337     }
5338 
5339     private boolean firstTraceEmitted;
5340 
5341     protected void traceInstruction(int bci, int opcode, boolean blockStart) {
5342         String indent = new String(new char[getDepth() * 2]).replace(&#39;\0&#39;, &#39; &#39;);
5343         StringBuilder sb = new StringBuilder(40);
5344         String nl = System.lineSeparator();
5345         if (!firstTraceEmitted) {
5346             sb.append(indent).append(method.format(&quot;Parsing %H.%n(%p)%r&quot;)).append(nl);
5347             if (traceLevel &gt;= TRACELEVEL_BLOCKMAP) {
5348                 sb.append(indent).append(&quot;Blocks:&quot;).append(nl);
5349                 String bm = blockMap.toString().replace(nl, nl + indent + &quot;  &quot;);
5350                 sb.append(indent).append(&quot;  &quot;).append(bm).append(nl);
5351             }
5352             firstTraceEmitted = true;
5353         }
5354         if (traceLevel &gt;= TRACELEVEL_STATE) {
5355             sb.append(indent).append(frameState).append(nl);
5356         }
5357         sb.append(indent);
5358         sb.append(blockStart ? &#39;+&#39; : &#39;|&#39;);
5359         if (bci &lt; 10) {
5360             sb.append(&quot;  &quot;);
5361         } else if (bci &lt; 100) {
5362             sb.append(&#39; &#39;);
5363         }
5364         sb.append(bci).append(&quot;: &quot;).append(Bytecodes.nameOf(opcode));
5365         for (int i = bci + 1; i &lt; stream.nextBCI(); ++i) {
5366             sb.append(&#39; &#39;).append(stream.readUByte(i));
5367         }
5368         if (!currentBlock.getJsrScope().isEmpty()) {
5369             sb.append(&#39; &#39;).append(currentBlock.getJsrScope());
5370         }
5371         TTY.println(&quot;%s&quot;, sb);
5372     }
5373 
5374     @Override
5375     public boolean parsingIntrinsic() {
5376         return intrinsicContext != null;
5377     }
5378 
5379     @Override
5380     public BytecodeParser getNonIntrinsicAncestor() {
5381         BytecodeParser ancestor = parent;
5382         while (ancestor != null &amp;&amp; ancestor.parsingIntrinsic()) {
5383             ancestor = ancestor.parent;
5384         }
5385         return ancestor;
5386     }
5387 
5388     static String nSpaces(int n) {
5389         return n == 0 ? &quot;&quot; : format(&quot;%&quot; + n + &quot;s&quot;, &quot;&quot;);
5390     }
5391 }
    </pre>
  </body>
</html>
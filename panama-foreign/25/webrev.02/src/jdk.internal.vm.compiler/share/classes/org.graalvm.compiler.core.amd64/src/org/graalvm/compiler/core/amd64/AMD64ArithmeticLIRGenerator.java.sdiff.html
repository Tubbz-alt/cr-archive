<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64AddressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64LIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 777     }
 778 
 779     private AllocatableValue emitConvertOp(LIRKind kind, AMD64MROp op, OperandSize size, Value input) {
 780         Variable result = getLIRGen().newVariable(kind);
 781         getLIRGen().append(new AMD64Unary.MROp(op, size, result, asAllocatable(input)));
 782         return result;
 783     }
 784 
 785     @Override
 786     public Value emitReinterpret(LIRKind to, Value inputVal) {
 787         ValueKind&lt;?&gt; from = inputVal.getValueKind();
 788         if (to.equals(from)) {
 789             return inputVal;
 790         }
 791 
 792         AllocatableValue input = asAllocatable(inputVal);
 793         /*
 794          * Conversions between integer to floating point types require moves between CPU and FPU
 795          * registers.
 796          */
<span class="line-modified"> 797         AMD64Kind fromKind = (AMD64Kind) from.getPlatformKind();</span>
<span class="line-modified"> 798         switch ((AMD64Kind) to.getPlatformKind()) {</span>

 799             case DWORD:
 800                 switch (fromKind) {
 801                     case SINGLE:
 802                         return emitConvertOp(to, AMD64MROp.MOVD, DWORD, input);
 803                 }
 804                 break;
 805             case QWORD:
 806                 switch (fromKind) {
 807                     case DOUBLE:
 808                         return emitConvertOp(to, AMD64MROp.MOVQ, QWORD, input);
 809                 }
 810                 break;
 811             case SINGLE:
 812                 switch (fromKind) {
 813                     case DWORD:
 814                         return emitConvertOp(to, AMD64RMOp.MOVD, DWORD, input);
 815                 }
 816                 break;
 817             case DOUBLE:
 818                 switch (fromKind) {
 819                     case QWORD:
 820                         return emitConvertOp(to, AMD64RMOp.MOVQ, QWORD, input);
 821                 }
 822                 break;
 823         }
<span class="line-modified"> 824         throw GraalError.shouldNotReachHere();</span>














 825     }
 826 
 827     @Override
 828     public Value emitFloatConvert(FloatConvert op, Value input) {
 829         switch (op) {
 830             case D2F:
 831                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSD2SS, SD, input);
 832             case D2I:
 833                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSD2SI, DWORD, input);
 834             case D2L:
 835                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSD2SI, QWORD, input);
 836             case F2D:
 837                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSS2SD, SS, input);
 838             case F2I:
 839                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSS2SI, DWORD, input);
 840             case F2L:
 841                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSS2SI, QWORD, input);
 842             case I2D:
 843                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, DWORD, input);
 844             case I2F:
</pre>
<hr />
<pre>
1246                 break;
1247             case DOUBLE:
1248                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSD, SD, address, value, state));
1249                 break;
1250             default:
1251                 throw GraalError.shouldNotReachHere();
1252         }
1253     }
1254 
1255     @Override
1256     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value input, LIRFrameState state) {
1257         AMD64AddressValue storeAddress = getAMD64LIRGen().asAddressValue(address);
1258         AMD64Kind kind = (AMD64Kind) lirKind.getPlatformKind();
1259         if (isConstantValue(input)) {
1260             emitStoreConst(kind, storeAddress, asConstantValue(input), state);
1261         } else {
1262             emitStore(kind, storeAddress, asAllocatable(input), state);
1263         }
1264     }
1265 
<span class="line-modified">1266     private boolean mustReplaceNullWithNullRegister(Constant nullConstant) {</span>
1267         /* Uncompressed null pointers only */
1268         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);
1269     }
1270 




1271     @Override
1272     public void emitCompareOp(AMD64Kind cmpKind, Variable left, Value right) {
1273         OperandSize size;
1274         switch (cmpKind) {
1275             case BYTE:
1276                 size = BYTE;
1277                 break;
1278             case WORD:
1279                 size = WORD;
1280                 break;
1281             case DWORD:
1282                 size = DWORD;
1283                 break;
1284             case QWORD:
1285                 size = QWORD;
1286                 break;
1287             case SINGLE:
1288                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PS, left, asAllocatable(right)));
1289                 return;
1290             case DOUBLE:
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
 777     }
 778 
 779     private AllocatableValue emitConvertOp(LIRKind kind, AMD64MROp op, OperandSize size, Value input) {
 780         Variable result = getLIRGen().newVariable(kind);
 781         getLIRGen().append(new AMD64Unary.MROp(op, size, result, asAllocatable(input)));
 782         return result;
 783     }
 784 
 785     @Override
 786     public Value emitReinterpret(LIRKind to, Value inputVal) {
 787         ValueKind&lt;?&gt; from = inputVal.getValueKind();
 788         if (to.equals(from)) {
 789             return inputVal;
 790         }
 791 
 792         AllocatableValue input = asAllocatable(inputVal);
 793         /*
 794          * Conversions between integer to floating point types require moves between CPU and FPU
 795          * registers.
 796          */
<span class="line-modified"> 797         AMD64Kind fromKind = scalarKind((AMD64Kind) from.getPlatformKind());</span>
<span class="line-modified"> 798         AMD64Kind toKind = scalarKind((AMD64Kind) to.getPlatformKind());</span>
<span class="line-added"> 799         switch (toKind) {</span>
 800             case DWORD:
 801                 switch (fromKind) {
 802                     case SINGLE:
 803                         return emitConvertOp(to, AMD64MROp.MOVD, DWORD, input);
 804                 }
 805                 break;
 806             case QWORD:
 807                 switch (fromKind) {
 808                     case DOUBLE:
 809                         return emitConvertOp(to, AMD64MROp.MOVQ, QWORD, input);
 810                 }
 811                 break;
 812             case SINGLE:
 813                 switch (fromKind) {
 814                     case DWORD:
 815                         return emitConvertOp(to, AMD64RMOp.MOVD, DWORD, input);
 816                 }
 817                 break;
 818             case DOUBLE:
 819                 switch (fromKind) {
 820                     case QWORD:
 821                         return emitConvertOp(to, AMD64RMOp.MOVQ, QWORD, input);
 822                 }
 823                 break;
 824         }
<span class="line-modified"> 825         throw GraalError.shouldNotReachHere(toKind + &quot; &quot; + fromKind);</span>
<span class="line-added"> 826     }</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828     private static AMD64Kind scalarKind(AMD64Kind kind) {</span>
<span class="line-added"> 829         AMD64Kind resultKind = kind;</span>
<span class="line-added"> 830         if (kind.isXMM() &amp;&amp; kind.getVectorLength() &gt; 1) {</span>
<span class="line-added"> 831             if (kind.getSizeInBytes() == AMD64Kind.SINGLE.getSizeInBytes()) {</span>
<span class="line-added"> 832                 resultKind = AMD64Kind.SINGLE;</span>
<span class="line-added"> 833             } else if (kind.getSizeInBytes() == AMD64Kind.DOUBLE.getSizeInBytes()) {</span>
<span class="line-added"> 834                 resultKind = AMD64Kind.DOUBLE;</span>
<span class="line-added"> 835             } else {</span>
<span class="line-added"> 836                 GraalError.shouldNotReachHere(&quot;no equal size scalar kind for &quot; + kind);</span>
<span class="line-added"> 837             }</span>
<span class="line-added"> 838         }</span>
<span class="line-added"> 839         return resultKind;</span>
 840     }
 841 
 842     @Override
 843     public Value emitFloatConvert(FloatConvert op, Value input) {
 844         switch (op) {
 845             case D2F:
 846                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSD2SS, SD, input);
 847             case D2I:
 848                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSD2SI, DWORD, input);
 849             case D2L:
 850                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSD2SI, QWORD, input);
 851             case F2D:
 852                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSS2SD, SS, input);
 853             case F2I:
 854                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSS2SI, DWORD, input);
 855             case F2L:
 856                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSS2SI, QWORD, input);
 857             case I2D:
 858                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, DWORD, input);
 859             case I2F:
</pre>
<hr />
<pre>
1261                 break;
1262             case DOUBLE:
1263                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSD, SD, address, value, state));
1264                 break;
1265             default:
1266                 throw GraalError.shouldNotReachHere();
1267         }
1268     }
1269 
1270     @Override
1271     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value input, LIRFrameState state) {
1272         AMD64AddressValue storeAddress = getAMD64LIRGen().asAddressValue(address);
1273         AMD64Kind kind = (AMD64Kind) lirKind.getPlatformKind();
1274         if (isConstantValue(input)) {
1275             emitStoreConst(kind, storeAddress, asConstantValue(input), state);
1276         } else {
1277             emitStore(kind, storeAddress, asAllocatable(input), state);
1278         }
1279     }
1280 
<span class="line-modified">1281     public boolean mustReplaceNullWithNullRegister(Constant nullConstant) {</span>
1282         /* Uncompressed null pointers only */
1283         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);
1284     }
1285 
<span class="line-added">1286     public AllocatableValue getNullRegisterValue() {</span>
<span class="line-added">1287         return nullRegisterValue;</span>
<span class="line-added">1288     }</span>
<span class="line-added">1289 </span>
1290     @Override
1291     public void emitCompareOp(AMD64Kind cmpKind, Variable left, Value right) {
1292         OperandSize size;
1293         switch (cmpKind) {
1294             case BYTE:
1295                 size = BYTE;
1296                 break;
1297             case WORD:
1298                 size = WORD;
1299                 break;
1300             case DWORD:
1301                 size = DWORD;
1302                 break;
1303             case QWORD:
1304                 size = QWORD;
1305                 break;
1306             case SINGLE:
1307                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PS, left, asAllocatable(right)));
1308                 return;
1309             case DOUBLE:
</pre>
</td>
</tr>
</table>
<center><a href="AMD64AddressNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64LIRGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
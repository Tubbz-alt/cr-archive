<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/GraalOptions.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.common;
 26 
 27 import org.graalvm.compiler.options.Option;
 28 import org.graalvm.compiler.options.OptionKey;
 29 import org.graalvm.compiler.options.OptionStability;
 30 import org.graalvm.compiler.options.OptionType;
 31 
 32 /**
 33  * This class encapsulates options that control the behavior of the GraalVM compiler.
 34  */
 35 // @formatter:off
 36 public final class GraalOptions {
 37 
 38     @Option(help = &quot;Use compiler intrinsifications.&quot;, type = OptionType.Debug)
 39     public static final OptionKey&lt;Boolean&gt; Intrinsify = new OptionKey&lt;&gt;(true);
 40 
 41     @Option(help = &quot;Inline calls with monomorphic type profile.&quot;, type = OptionType.Expert)
 42     public static final OptionKey&lt;Boolean&gt; InlineMonomorphicCalls = new OptionKey&lt;&gt;(true);
 43 
 44     @Option(help = &quot;Inline calls with polymorphic type profile.&quot;, type = OptionType.Expert)
 45     public static final OptionKey&lt;Boolean&gt; InlinePolymorphicCalls = new OptionKey&lt;&gt;(true);
 46 
 47     @Option(help = &quot;Inline calls with megamorphic type profile (i.e., not all types could be recorded).&quot;, type = OptionType.Expert)
 48     public static final OptionKey&lt;Boolean&gt; InlineMegamorphicCalls = new OptionKey&lt;&gt;(true);
 49 
 50     @Option(help = &quot;Maximum desired size of the compiler graph in nodes.&quot;, type = OptionType.User)
 51     public static final OptionKey&lt;Integer&gt; MaximumDesiredSize = new OptionKey&lt;&gt;(20000);
 52 
 53     @Option(help = &quot;Minimum probability for methods to be inlined for megamorphic type profiles.&quot;, type = OptionType.Expert)
 54     public static final OptionKey&lt;Double&gt; MegamorphicInliningMinMethodProbability = new OptionKey&lt;&gt;(0.33D);
 55 
 56     @Option(help = &quot;Maximum level of recursive inlining.&quot;, type = OptionType.Expert)
 57     public static final OptionKey&lt;Integer&gt; MaximumRecursiveInlining = new OptionKey&lt;&gt;(5);
 58 
 59     @Option(help = &quot;Graphs with less than this number of nodes are trivial and therefore always inlined.&quot;, type = OptionType.Expert)
 60     public static final OptionKey&lt;Integer&gt; TrivialInliningSize = new OptionKey&lt;&gt;(10);
 61 
 62     @Option(help = &quot;Inlining is explored up to this number of nodes in the graph for each call site.&quot;, type = OptionType.Expert)
 63     public static final OptionKey&lt;Integer&gt; MaximumInliningSize = new OptionKey&lt;&gt;(300);
 64 
 65     @Option(help = &quot;If the previous low-level graph size of the method exceeds the threshold, it is not inlined.&quot;, type = OptionType.Expert)
 66     public static final OptionKey&lt;Integer&gt; SmallCompiledLowLevelGraphSize = new OptionKey&lt;&gt;(330);
 67 
 68     @Option(help = &quot;&quot;, type = OptionType.Expert)
 69     public static final OptionKey&lt;Double&gt; LimitInlinedInvokes = new OptionKey&lt;&gt;(5.0);
 70 
 71     @Option(help = &quot;&quot;, type = OptionType.Expert)
 72     public static final OptionKey&lt;Boolean&gt; InlineEverything = new OptionKey&lt;&gt;(false);
 73 
 74     // escape analysis settings
 75     @Option(help = &quot;&quot;, type = OptionType.Debug)
 76     public static final OptionKey&lt;Boolean&gt; PartialEscapeAnalysis = new OptionKey&lt;&gt;(true);
 77 
 78     @Option(help = &quot;&quot;, type = OptionType.Debug)
 79     public static final OptionKey&lt;Integer&gt; EscapeAnalysisIterations = new OptionKey&lt;&gt;(2);
 80 
 81     @Option(help = &quot;&quot;, type = OptionType.Debug)
 82     public static final OptionKey&lt;Integer&gt; EscapeAnalysisLoopCutoff = new OptionKey&lt;&gt;(20);
 83 
 84     @Option(help = &quot;&quot;, type = OptionType.Debug)
 85     public static final OptionKey&lt;String&gt; EscapeAnalyzeOnly = new OptionKey&lt;&gt;(null);
 86 
 87     @Option(help = &quot;The maximum length of an array that will be escape analyzed.&quot;, type = OptionType.Expert)
 88     public static final OptionKey&lt;Integer&gt; MaximumEscapeAnalysisArrayLength = new OptionKey&lt;&gt;(128);
 89 
 90     @Option(help = &quot;&quot;, type = OptionType.Debug)
 91     public static final OptionKey&lt;Boolean&gt; PEAInliningHints = new OptionKey&lt;&gt;(false);
 92 
 93     @Option(help = &quot;&quot;, type = OptionType.Expert)
 94     public static final OptionKey&lt;Double&gt; TailDuplicationProbability = new OptionKey&lt;&gt;(0.5);
 95 
 96     @Option(help = &quot;&quot;, type = OptionType.Expert)
 97     public static final OptionKey&lt;Integer&gt; TailDuplicationTrivialSize = new OptionKey&lt;&gt;(1);
 98 
 99     @Option(help = &quot;&quot;, type = OptionType.Expert)
100     public static final OptionKey&lt;Integer&gt; DeoptsToDisableOptimisticOptimization = new OptionKey&lt;&gt;(40);
101 
102     @Option(help = &quot;&quot;, type = OptionType.Debug)
103     public static final OptionKey&lt;Boolean&gt; LoopPeeling = new OptionKey&lt;&gt;(true);
104 
105     @Option(help = &quot;&quot;, type = OptionType.Debug)
106     public static final OptionKey&lt;Boolean&gt; ReassociateInvariants = new OptionKey&lt;&gt;(true);
107 
108     @Option(help = &quot;&quot;, type = OptionType.Debug)
109     public static final OptionKey&lt;Boolean&gt; FullUnroll = new OptionKey&lt;&gt;(true);
110 
111     @Option(help = &quot;&quot;, type = OptionType.Debug)
112     public static final OptionKey&lt;Boolean&gt; LoopUnswitch = new OptionKey&lt;&gt;(true);
113 
114     @Option(help = &quot;&quot;, type = OptionType.Debug)
115     public static final OptionKey&lt;Boolean&gt; PartialUnroll = new OptionKey&lt;&gt;(true);
116 
117     @Option(help = &quot;&quot;, type = OptionType.Expert)
118     public static final OptionKey&lt;Float&gt; MinimumPeelFrequency = new OptionKey&lt;&gt;(0.35f);
119 
120     @Option(help = &quot;&quot;, type = OptionType.Expert)
121     public static final OptionKey&lt;Integer&gt; LoopMaxUnswitch = new OptionKey&lt;&gt;(3);
122 
123     @Option(help = &quot;&quot;, type = OptionType.Debug)
124     public static final OptionKey&lt;Boolean&gt; UseLoopLimitChecks = new OptionKey&lt;&gt;(true);
125 
126     // debugging settings
127     @Option(help = &quot;&quot;, type = OptionType.Debug)
128     public static final OptionKey&lt;Boolean&gt; ZapStackOnMethodEntry = new OptionKey&lt;&gt;(false);
129 
130     @Option(help = &quot;&quot;, type = OptionType.Debug)
131     public static final OptionKey&lt;Boolean&gt; DeoptALot = new OptionKey&lt;&gt;(false);
132 
133     @Option(help = &quot;Stress the code emitting explicit exception throwing code.&quot;, type = OptionType.Debug)
134     public static final OptionKey&lt;Boolean&gt; StressExplicitExceptionCode = new OptionKey&lt;&gt;(false);
135 
136     @Option(help = &quot;Stress the code emitting invokes with explicit exception edges.&quot;, type = OptionType.Debug)
137     public static final OptionKey&lt;Boolean&gt; StressInvokeWithExceptionNode = new OptionKey&lt;&gt;(false);
138 
139     @Option(help = &quot;Stress the code by emitting reads at earliest instead of latest point.&quot;, type = OptionType.Debug)
140     public static final OptionKey&lt;Boolean&gt; StressTestEarlyReads = new OptionKey&lt;&gt;(false);
141 
142     @Option(help = &quot;&quot;, type = OptionType.Debug)
143     public static final OptionKey&lt;Boolean&gt; VerifyPhases = new OptionKey&lt;&gt;(false);
144 
145     // Debug settings:
146     @Option(help = &quot;Start tracing compiled GC barriers after N garbage collections (disabled if N &lt;= 0).&quot;, type = OptionType.Debug)
147     public static final OptionKey&lt;Integer&gt; GCDebugStartCycle = new OptionKey&lt;&gt;(-1);
148 
149     @Option(help = &quot;Perform platform dependent validation of the Java heap at returns&quot;, type = OptionType.Debug)
150     public static final OptionKey&lt;Boolean&gt; VerifyHeapAtReturn = new OptionKey&lt;&gt;(false);
151 
152     // Other printing settings
153     @Option(help = &quot;Print profiling information when parsing a method&#39;s bytecode&quot;, type = OptionType.Debug)
154     public static final OptionKey&lt;Boolean&gt; PrintProfilingInformation = new OptionKey&lt;&gt;(false);
155 
156     @Option(help = &quot;&quot;, type = OptionType.Debug)
157     public static final OptionKey&lt;Boolean&gt; TraceEscapeAnalysis = new OptionKey&lt;&gt;(false);
158 
159     // HotSpot command line options
160     @Option(help = &quot;Print inlining optimizations&quot;, type = OptionType.Debug)
161     public static final OptionKey&lt;Boolean&gt; HotSpotPrintInlining = new OptionKey&lt;&gt;(false);
162 
163     // Register allocator debugging
164     @Option(help = &quot;Comma separated list of registers that register allocation is limited to.&quot;, type = OptionType.Debug)
165     public static final OptionKey&lt;String&gt; RegisterPressure = new OptionKey&lt;&gt;(null);
166 
167     @Option(help = &quot;&quot;, type = OptionType.Debug)
168     public static final OptionKey&lt;Boolean&gt; ConditionalElimination = new OptionKey&lt;&gt;(true);
169 
170     @Option(help = &quot;&quot;, type = OptionType.Debug)
171     public static final OptionKey&lt;Integer&gt; ConditionalEliminationMaxIterations = new OptionKey&lt;&gt;(4);
172 
173     @Option(help = &quot;&quot;, type = OptionType.Debug)
174     public static final OptionKey&lt;Boolean&gt; RawConditionalElimination = new OptionKey&lt;&gt;(true);
175 
176     @Option(help = &quot;&quot;, type = OptionType.Debug)
177     public static final OptionKey&lt;Boolean&gt; ReplaceInputsWithConstantsBasedOnStamps = new OptionKey&lt;&gt;(true);
178 
179     @Option(help = &quot;&quot;, type = OptionType.Debug)
180     public static final OptionKey&lt;Boolean&gt; RemoveNeverExecutedCode = new OptionKey&lt;&gt;(true);
181 
182     @Option(help = &quot;&quot;, type = OptionType.Debug)
183     public static final OptionKey&lt;Boolean&gt; UseExceptionProbability = new OptionKey&lt;&gt;(true);
184 
185     @Option(help = &quot;&quot;, type = OptionType.Debug)
186     public static final OptionKey&lt;Boolean&gt; OmitHotExceptionStacktrace = new OptionKey&lt;&gt;(false);
187 
188     @Option(help = &quot;&quot;, type = OptionType.Debug)
189     public static final OptionKey&lt;Boolean&gt; GenSafepoints = new OptionKey&lt;&gt;(true);
190 
191     @Option(help = &quot;&quot;, type = OptionType.Debug)
192     public static final OptionKey&lt;Boolean&gt; GenLoopSafepoints = new OptionKey&lt;&gt;(true);
193 
194     @Option(help = &quot;&quot;, type = OptionType.Debug)
195     public static final OptionKey&lt;Boolean&gt; UseTypeCheckHints = new OptionKey&lt;&gt;(true);
196 
197     @Option(help = &quot;&quot;, type = OptionType.Expert)
198     public static final OptionKey&lt;Boolean&gt; InlineVTableStubs = new OptionKey&lt;&gt;(true);
199 
200     @Option(help = &quot;&quot;, type = OptionType.Expert)
201     public static final OptionKey&lt;Boolean&gt; AlwaysInlineVTableStubs = new OptionKey&lt;&gt;(false);
202 
203     @Option(help = &quot;&quot;, type = OptionType.Debug)
204     public static final OptionKey&lt;Boolean&gt; CanOmitFrame = new OptionKey&lt;&gt;(true);
205 
206     // Ahead of time compilation
207     @Option(help = &quot;Try to avoid emitting code where patching is required&quot;, type = OptionType.Expert)
208     public static final OptionKey&lt;Boolean&gt; ImmutableCode = new OptionKey&lt;&gt;(false);
209 
210     @Option(help = &quot;Generate position independent code&quot;, type = OptionType.Expert)
211     public static final OptionKey&lt;Boolean&gt; GeneratePIC = new OptionKey&lt;&gt;(false);
212 
213     // Runtime settings
214     @Option(help = &quot;&quot;, type = OptionType.Expert)
215     public static final OptionKey&lt;Boolean&gt; SupportJsrBytecodes = new OptionKey&lt;&gt;(true);
216 
217     @Option(help = &quot;&quot;, type = OptionType.Expert)
218     public static final OptionKey&lt;Boolean&gt; OptAssumptions = new OptionKey&lt;&gt;(true);
219 
220     @Option(help = &quot;&quot;, type = OptionType.Debug)
221     public static final OptionKey&lt;Boolean&gt; OptConvertDeoptsToGuards = new OptionKey&lt;&gt;(true);
222 
223     @Option(help = &quot;&quot;, type = OptionType.Debug)
224     public static final OptionKey&lt;Boolean&gt; OptReadElimination = new OptionKey&lt;&gt;(true);
225 
226     @Option(help = &quot;&quot;, type = OptionType.Debug)
227     public static final OptionKey&lt;Integer&gt; ReadEliminationMaxLoopVisits = new OptionKey&lt;&gt;(5);
228 
229     @Option(help = &quot;&quot;, type = OptionType.Debug)
230     public static final OptionKey&lt;Boolean&gt; OptDeoptimizationGrouping = new OptionKey&lt;&gt;(true);
231 
232     @Option(help = &quot;&quot;, type = OptionType.Debug)
233     public static final OptionKey&lt;Boolean&gt; OptScheduleOutOfLoops = new OptionKey&lt;&gt;(true);
234 
235     @Option(help = &quot;&quot;, type = OptionType.Debug)
236     public static final OptionKey&lt;Boolean&gt; GuardPriorities = new OptionKey&lt;&gt;(true);
237 
238     @Option(help = &quot;&quot;, type = OptionType.Debug)
239     public static final OptionKey&lt;Boolean&gt; OptEliminateGuards = new OptionKey&lt;&gt;(true);
240 
241     @Option(help = &quot;&quot;, type = OptionType.Debug)
242     public static final OptionKey&lt;Boolean&gt; OptImplicitNullChecks = new OptionKey&lt;&gt;(true);
243 
244     @Option(help = &quot;&quot;, type = OptionType.Debug)
245     public static final OptionKey&lt;Boolean&gt; OptFloatingReads = new OptionKey&lt;&gt;(true);
246 
247     @Option(help = &quot;&quot;, type = OptionType.Debug)
248     public static final OptionKey&lt;Boolean&gt; OptEliminatePartiallyRedundantGuards = new OptionKey&lt;&gt;(true);
249 
250     @Option(help = &quot;&quot;, type = OptionType.Debug)
251     public static final OptionKey&lt;Boolean&gt; OptFilterProfiledTypes = new OptionKey&lt;&gt;(true);
252 
253     @Option(help = &quot;&quot;, type = OptionType.Debug)
254     public static final OptionKey&lt;Boolean&gt; OptDevirtualizeInvokesOptimistically = new OptionKey&lt;&gt;(true);
255 
256     @Option(help = &quot;Track the NodeSourcePosition.&quot;, type = OptionType.Debug)
257     public static final OptionKey&lt;Boolean&gt; TrackNodeSourcePosition = new OptionKey&lt;&gt;(false);
258 
259     @Option(help = &quot;Track source stack trace where a node was inserted into the graph.&quot;, type = OptionType.Debug)
260     public static final OptionKey&lt;Boolean&gt; TrackNodeInsertion = new OptionKey&lt;&gt;(false);
261 
262     @Option(help = &quot;Allow backend to match complex expressions.&quot;, type = OptionType.Debug)
263     public static final OptionKey&lt;Boolean&gt; MatchExpressions = new OptionKey&lt;&gt;(true);
264 
265     @Option(help = &quot;Enable counters for various paths in snippets.&quot;, type = OptionType.Debug)
266     public static final OptionKey&lt;Boolean&gt; SnippetCounters = new OptionKey&lt;&gt;(false);
267 
268     @Option(help = &quot;Eagerly construct extra snippet info.&quot;, type = OptionType.Debug)
269     public static final OptionKey&lt;Boolean&gt; EagerSnippets = new OptionKey&lt;&gt;(false);
270 
271     @Option(help = &quot;Use a cache for snippet graphs.&quot;, type = OptionType.Debug)
272     public static final OptionKey&lt;Boolean&gt; UseSnippetGraphCache = new OptionKey&lt;&gt;(true);
273 
274     @Option(help = &quot;file:doc-files/TraceInliningHelp.txt&quot;, type = OptionType.Debug, stability = OptionStability.STABLE)
275     public static final OptionKey&lt;Boolean&gt; TraceInlining = new OptionKey&lt;&gt;(false);
276 
277     @Option(help = &quot;Enable inlining decision tracing in stubs and snippets.&quot;, type = OptionType.Debug)
278     public static final OptionKey&lt;Boolean&gt; TraceInliningForStubsAndSnippets = new OptionKey&lt;&gt;(false);
279 
280     @Option(help = &quot;Use Graal-generated stubs for complicated LIR operations instead of embedding all the emitted code.&quot;, type = OptionType.Expert)
281     public static final OptionKey&lt;Boolean&gt; UseGraalStubs = new OptionKey&lt;&gt;(true);
282 
283     @Option(help = &quot;Encode and decode snippets and substitutions before parsing to test libgraal code path. This option is ignored in the context of libgraal.&quot;)
284     public static final OptionKey&lt;Boolean&gt; UseEncodedGraphs = new OptionKey&lt;&gt;(false);
285 
286     @Option(help = &quot;If applicable, use bulk zeroing instructions when the zeroing size in bytes exceeds this threshold.&quot;, type = OptionType.Expert)
287     public static final OptionKey&lt;Integer&gt; MinimalBulkZeroingSize = new OptionKey&lt;&gt;(2048);
288 
289     @Option(help = &quot;Alignment in bytes for loop header blocks.&quot;, type = OptionType.Expert)
290     public static final OptionKey&lt;Integer&gt; LoopHeaderAlignment = new OptionKey&lt;&gt;(16);
291 
292     @Option(help = &quot;Do not include membars for volatile accesses until the end of optimizations.&quot;, type = OptionType.Expert)
293     public static final OptionKey&lt;Boolean&gt; LateMembars = new OptionKey&lt;&gt;(true);
294 }
    </pre>
  </body>
</html>
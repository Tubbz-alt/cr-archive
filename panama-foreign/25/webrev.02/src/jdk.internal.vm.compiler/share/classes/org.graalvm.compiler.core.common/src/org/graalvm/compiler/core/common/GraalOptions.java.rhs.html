<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/GraalOptions.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.common;
 26 
 27 import org.graalvm.compiler.options.Option;
 28 import org.graalvm.compiler.options.OptionKey;
 29 import org.graalvm.compiler.options.OptionStability;
 30 import org.graalvm.compiler.options.OptionType;
 31 
 32 /**
 33  * This class encapsulates options that control the behavior of the GraalVM compiler.
 34  */
 35 // @formatter:off
 36 public final class GraalOptions {
 37 
 38     @Option(help = &quot;Use compiler intrinsifications.&quot;, type = OptionType.Debug)
 39     public static final OptionKey&lt;Boolean&gt; Intrinsify = new OptionKey&lt;&gt;(true);
 40 
 41     @Option(help = &quot;Inline calls with monomorphic type profile.&quot;, type = OptionType.Expert)
 42     public static final OptionKey&lt;Boolean&gt; InlineMonomorphicCalls = new OptionKey&lt;&gt;(true);
 43 
 44     @Option(help = &quot;Inline calls with polymorphic type profile.&quot;, type = OptionType.Expert)
 45     public static final OptionKey&lt;Boolean&gt; InlinePolymorphicCalls = new OptionKey&lt;&gt;(true);
 46 
 47     @Option(help = &quot;Inline calls with megamorphic type profile (i.e., not all types could be recorded).&quot;, type = OptionType.Expert)
 48     public static final OptionKey&lt;Boolean&gt; InlineMegamorphicCalls = new OptionKey&lt;&gt;(true);
 49 
 50     @Option(help = &quot;Maximum desired size of the compiler graph in nodes.&quot;, type = OptionType.User)
 51     public static final OptionKey&lt;Integer&gt; MaximumDesiredSize = new OptionKey&lt;&gt;(20000);
 52 
 53     @Option(help = &quot;Minimum probability for methods to be inlined for megamorphic type profiles.&quot;, type = OptionType.Expert)
 54     public static final OptionKey&lt;Double&gt; MegamorphicInliningMinMethodProbability = new OptionKey&lt;&gt;(0.33D);
 55 
 56     @Option(help = &quot;Maximum level of recursive inlining.&quot;, type = OptionType.Expert)
 57     public static final OptionKey&lt;Integer&gt; MaximumRecursiveInlining = new OptionKey&lt;&gt;(5);
 58 
 59     @Option(help = &quot;Graphs with less than this number of nodes are trivial and therefore always inlined.&quot;, type = OptionType.Expert)
 60     public static final OptionKey&lt;Integer&gt; TrivialInliningSize = new OptionKey&lt;&gt;(10);
 61 
 62     @Option(help = &quot;Inlining is explored up to this number of nodes in the graph for each call site.&quot;, type = OptionType.Expert)
 63     public static final OptionKey&lt;Integer&gt; MaximumInliningSize = new OptionKey&lt;&gt;(300);
 64 
 65     @Option(help = &quot;If the previous low-level graph size of the method exceeds the threshold, it is not inlined.&quot;, type = OptionType.Expert)
 66     public static final OptionKey&lt;Integer&gt; SmallCompiledLowLevelGraphSize = new OptionKey&lt;&gt;(330);
 67 
 68     @Option(help = &quot;&quot;, type = OptionType.Expert)
 69     public static final OptionKey&lt;Double&gt; LimitInlinedInvokes = new OptionKey&lt;&gt;(5.0);
 70 
 71     @Option(help = &quot;&quot;, type = OptionType.Expert)
 72     public static final OptionKey&lt;Boolean&gt; InlineEverything = new OptionKey&lt;&gt;(false);
 73 
 74     // escape analysis settings
 75     @Option(help = &quot;&quot;, type = OptionType.Debug)
 76     public static final OptionKey&lt;Boolean&gt; PartialEscapeAnalysis = new OptionKey&lt;&gt;(true);
 77 
 78     @Option(help = &quot;&quot;, type = OptionType.Debug)
 79     public static final OptionKey&lt;Integer&gt; EscapeAnalysisIterations = new OptionKey&lt;&gt;(2);
 80 
 81     @Option(help = &quot;&quot;, type = OptionType.Debug)
 82     public static final OptionKey&lt;Integer&gt; EscapeAnalysisLoopCutoff = new OptionKey&lt;&gt;(20);
 83 
 84     @Option(help = &quot;&quot;, type = OptionType.Debug)
 85     public static final OptionKey&lt;String&gt; EscapeAnalyzeOnly = new OptionKey&lt;&gt;(null);
 86 
 87     @Option(help = &quot;The maximum length of an array that will be escape analyzed.&quot;, type = OptionType.Expert)
 88     public static final OptionKey&lt;Integer&gt; MaximumEscapeAnalysisArrayLength = new OptionKey&lt;&gt;(128);
 89 
<a name="1" id="anc1"></a>








 90     @Option(help = &quot;&quot;, type = OptionType.Expert)
 91     public static final OptionKey&lt;Integer&gt; DeoptsToDisableOptimisticOptimization = new OptionKey&lt;&gt;(40);
 92 
 93     @Option(help = &quot;&quot;, type = OptionType.Debug)
 94     public static final OptionKey&lt;Boolean&gt; LoopPeeling = new OptionKey&lt;&gt;(true);
 95 
 96     @Option(help = &quot;&quot;, type = OptionType.Debug)
 97     public static final OptionKey&lt;Boolean&gt; ReassociateInvariants = new OptionKey&lt;&gt;(true);
 98 
 99     @Option(help = &quot;&quot;, type = OptionType.Debug)
100     public static final OptionKey&lt;Boolean&gt; FullUnroll = new OptionKey&lt;&gt;(true);
101 
102     @Option(help = &quot;&quot;, type = OptionType.Debug)
103     public static final OptionKey&lt;Boolean&gt; LoopUnswitch = new OptionKey&lt;&gt;(true);
104 
105     @Option(help = &quot;&quot;, type = OptionType.Debug)
106     public static final OptionKey&lt;Boolean&gt; PartialUnroll = new OptionKey&lt;&gt;(true);
107 
108     @Option(help = &quot;&quot;, type = OptionType.Expert)
109     public static final OptionKey&lt;Float&gt; MinimumPeelFrequency = new OptionKey&lt;&gt;(0.35f);
110 
111     @Option(help = &quot;&quot;, type = OptionType.Expert)
112     public static final OptionKey&lt;Integer&gt; LoopMaxUnswitch = new OptionKey&lt;&gt;(3);
113 
114     @Option(help = &quot;&quot;, type = OptionType.Debug)
115     public static final OptionKey&lt;Boolean&gt; UseLoopLimitChecks = new OptionKey&lt;&gt;(true);
116 
117     // debugging settings
118     @Option(help = &quot;&quot;, type = OptionType.Debug)
119     public static final OptionKey&lt;Boolean&gt; ZapStackOnMethodEntry = new OptionKey&lt;&gt;(false);
120 
121     @Option(help = &quot;&quot;, type = OptionType.Debug)
122     public static final OptionKey&lt;Boolean&gt; DeoptALot = new OptionKey&lt;&gt;(false);
123 
124     @Option(help = &quot;Stress the code emitting explicit exception throwing code.&quot;, type = OptionType.Debug)
125     public static final OptionKey&lt;Boolean&gt; StressExplicitExceptionCode = new OptionKey&lt;&gt;(false);
126 
127     @Option(help = &quot;Stress the code emitting invokes with explicit exception edges.&quot;, type = OptionType.Debug)
128     public static final OptionKey&lt;Boolean&gt; StressInvokeWithExceptionNode = new OptionKey&lt;&gt;(false);
129 
130     @Option(help = &quot;Stress the code by emitting reads at earliest instead of latest point.&quot;, type = OptionType.Debug)
131     public static final OptionKey&lt;Boolean&gt; StressTestEarlyReads = new OptionKey&lt;&gt;(false);
132 
133     @Option(help = &quot;&quot;, type = OptionType.Debug)
134     public static final OptionKey&lt;Boolean&gt; VerifyPhases = new OptionKey&lt;&gt;(false);
135 
136     // Debug settings:
137     @Option(help = &quot;Start tracing compiled GC barriers after N garbage collections (disabled if N &lt;= 0).&quot;, type = OptionType.Debug)
138     public static final OptionKey&lt;Integer&gt; GCDebugStartCycle = new OptionKey&lt;&gt;(-1);
139 
140     @Option(help = &quot;Perform platform dependent validation of the Java heap at returns&quot;, type = OptionType.Debug)
141     public static final OptionKey&lt;Boolean&gt; VerifyHeapAtReturn = new OptionKey&lt;&gt;(false);
142 
143     // Other printing settings
144     @Option(help = &quot;Print profiling information when parsing a method&#39;s bytecode&quot;, type = OptionType.Debug)
145     public static final OptionKey&lt;Boolean&gt; PrintProfilingInformation = new OptionKey&lt;&gt;(false);
146 
147     @Option(help = &quot;&quot;, type = OptionType.Debug)
148     public static final OptionKey&lt;Boolean&gt; TraceEscapeAnalysis = new OptionKey&lt;&gt;(false);
149 
150     // HotSpot command line options
151     @Option(help = &quot;Print inlining optimizations&quot;, type = OptionType.Debug)
152     public static final OptionKey&lt;Boolean&gt; HotSpotPrintInlining = new OptionKey&lt;&gt;(false);
153 
154     // Register allocator debugging
155     @Option(help = &quot;Comma separated list of registers that register allocation is limited to.&quot;, type = OptionType.Debug)
156     public static final OptionKey&lt;String&gt; RegisterPressure = new OptionKey&lt;&gt;(null);
157 
158     @Option(help = &quot;&quot;, type = OptionType.Debug)
159     public static final OptionKey&lt;Boolean&gt; ConditionalElimination = new OptionKey&lt;&gt;(true);
160 
161     @Option(help = &quot;&quot;, type = OptionType.Debug)
162     public static final OptionKey&lt;Integer&gt; ConditionalEliminationMaxIterations = new OptionKey&lt;&gt;(4);
163 
164     @Option(help = &quot;&quot;, type = OptionType.Debug)
165     public static final OptionKey&lt;Boolean&gt; RawConditionalElimination = new OptionKey&lt;&gt;(true);
166 
167     @Option(help = &quot;&quot;, type = OptionType.Debug)
168     public static final OptionKey&lt;Boolean&gt; ReplaceInputsWithConstantsBasedOnStamps = new OptionKey&lt;&gt;(true);
169 
170     @Option(help = &quot;&quot;, type = OptionType.Debug)
171     public static final OptionKey&lt;Boolean&gt; RemoveNeverExecutedCode = new OptionKey&lt;&gt;(true);
172 
173     @Option(help = &quot;&quot;, type = OptionType.Debug)
174     public static final OptionKey&lt;Boolean&gt; UseExceptionProbability = new OptionKey&lt;&gt;(true);
175 
176     @Option(help = &quot;&quot;, type = OptionType.Debug)
177     public static final OptionKey&lt;Boolean&gt; OmitHotExceptionStacktrace = new OptionKey&lt;&gt;(false);
178 
<a name="2" id="anc2"></a>


179     @Option(help = &quot;&quot;, type = OptionType.Debug)
180     public static final OptionKey&lt;Boolean&gt; GenLoopSafepoints = new OptionKey&lt;&gt;(true);
181 
182     @Option(help = &quot;&quot;, type = OptionType.Debug)
183     public static final OptionKey&lt;Boolean&gt; UseTypeCheckHints = new OptionKey&lt;&gt;(true);
184 
185     @Option(help = &quot;&quot;, type = OptionType.Expert)
186     public static final OptionKey&lt;Boolean&gt; InlineVTableStubs = new OptionKey&lt;&gt;(true);
187 
188     @Option(help = &quot;&quot;, type = OptionType.Expert)
189     public static final OptionKey&lt;Boolean&gt; AlwaysInlineVTableStubs = new OptionKey&lt;&gt;(false);
190 
191     @Option(help = &quot;&quot;, type = OptionType.Debug)
192     public static final OptionKey&lt;Boolean&gt; CanOmitFrame = new OptionKey&lt;&gt;(true);
193 
194     // Ahead of time compilation
195     @Option(help = &quot;Try to avoid emitting code where patching is required&quot;, type = OptionType.Expert)
196     public static final OptionKey&lt;Boolean&gt; ImmutableCode = new OptionKey&lt;&gt;(false);
197 
198     @Option(help = &quot;Generate position independent code&quot;, type = OptionType.Expert)
199     public static final OptionKey&lt;Boolean&gt; GeneratePIC = new OptionKey&lt;&gt;(false);
200 
201     // Runtime settings
202     @Option(help = &quot;&quot;, type = OptionType.Expert)
203     public static final OptionKey&lt;Boolean&gt; SupportJsrBytecodes = new OptionKey&lt;&gt;(true);
204 
205     @Option(help = &quot;&quot;, type = OptionType.Expert)
206     public static final OptionKey&lt;Boolean&gt; OptAssumptions = new OptionKey&lt;&gt;(true);
207 
208     @Option(help = &quot;&quot;, type = OptionType.Debug)
209     public static final OptionKey&lt;Boolean&gt; OptConvertDeoptsToGuards = new OptionKey&lt;&gt;(true);
210 
211     @Option(help = &quot;&quot;, type = OptionType.Debug)
212     public static final OptionKey&lt;Boolean&gt; OptReadElimination = new OptionKey&lt;&gt;(true);
213 
214     @Option(help = &quot;&quot;, type = OptionType.Debug)
215     public static final OptionKey&lt;Integer&gt; ReadEliminationMaxLoopVisits = new OptionKey&lt;&gt;(5);
216 
217     @Option(help = &quot;&quot;, type = OptionType.Debug)
218     public static final OptionKey&lt;Boolean&gt; OptDeoptimizationGrouping = new OptionKey&lt;&gt;(true);
219 
220     @Option(help = &quot;&quot;, type = OptionType.Debug)
221     public static final OptionKey&lt;Boolean&gt; OptScheduleOutOfLoops = new OptionKey&lt;&gt;(true);
222 
223     @Option(help = &quot;&quot;, type = OptionType.Debug)
224     public static final OptionKey&lt;Boolean&gt; GuardPriorities = new OptionKey&lt;&gt;(true);
225 
226     @Option(help = &quot;&quot;, type = OptionType.Debug)
227     public static final OptionKey&lt;Boolean&gt; OptEliminateGuards = new OptionKey&lt;&gt;(true);
228 
229     @Option(help = &quot;&quot;, type = OptionType.Debug)
230     public static final OptionKey&lt;Boolean&gt; OptImplicitNullChecks = new OptionKey&lt;&gt;(true);
231 
232     @Option(help = &quot;&quot;, type = OptionType.Debug)
233     public static final OptionKey&lt;Boolean&gt; OptFloatingReads = new OptionKey&lt;&gt;(true);
234 
<a name="3" id="anc3"></a>





235     @Option(help = &quot;&quot;, type = OptionType.Debug)
236     public static final OptionKey&lt;Boolean&gt; OptDevirtualizeInvokesOptimistically = new OptionKey&lt;&gt;(true);
237 
238     @Option(help = &quot;Track the NodeSourcePosition.&quot;, type = OptionType.Debug)
239     public static final OptionKey&lt;Boolean&gt; TrackNodeSourcePosition = new OptionKey&lt;&gt;(false);
240 
241     @Option(help = &quot;Track source stack trace where a node was inserted into the graph.&quot;, type = OptionType.Debug)
242     public static final OptionKey&lt;Boolean&gt; TrackNodeInsertion = new OptionKey&lt;&gt;(false);
243 
244     @Option(help = &quot;Allow backend to match complex expressions.&quot;, type = OptionType.Debug)
245     public static final OptionKey&lt;Boolean&gt; MatchExpressions = new OptionKey&lt;&gt;(true);
246 
247     @Option(help = &quot;Enable counters for various paths in snippets.&quot;, type = OptionType.Debug)
248     public static final OptionKey&lt;Boolean&gt; SnippetCounters = new OptionKey&lt;&gt;(false);
249 
250     @Option(help = &quot;Eagerly construct extra snippet info.&quot;, type = OptionType.Debug)
251     public static final OptionKey&lt;Boolean&gt; EagerSnippets = new OptionKey&lt;&gt;(false);
252 
253     @Option(help = &quot;Use a cache for snippet graphs.&quot;, type = OptionType.Debug)
254     public static final OptionKey&lt;Boolean&gt; UseSnippetGraphCache = new OptionKey&lt;&gt;(true);
255 
256     @Option(help = &quot;file:doc-files/TraceInliningHelp.txt&quot;, type = OptionType.Debug, stability = OptionStability.STABLE)
257     public static final OptionKey&lt;Boolean&gt; TraceInlining = new OptionKey&lt;&gt;(false);
258 
259     @Option(help = &quot;Enable inlining decision tracing in stubs and snippets.&quot;, type = OptionType.Debug)
260     public static final OptionKey&lt;Boolean&gt; TraceInliningForStubsAndSnippets = new OptionKey&lt;&gt;(false);
261 
262     @Option(help = &quot;Use Graal-generated stubs for complicated LIR operations instead of embedding all the emitted code.&quot;, type = OptionType.Expert)
263     public static final OptionKey&lt;Boolean&gt; UseGraalStubs = new OptionKey&lt;&gt;(true);
264 
265     @Option(help = &quot;Encode and decode snippets and substitutions before parsing to test libgraal code path. This option is ignored in the context of libgraal.&quot;)
266     public static final OptionKey&lt;Boolean&gt; UseEncodedGraphs = new OptionKey&lt;&gt;(false);
267 
268     @Option(help = &quot;If applicable, use bulk zeroing instructions when the zeroing size in bytes exceeds this threshold.&quot;, type = OptionType.Expert)
269     public static final OptionKey&lt;Integer&gt; MinimalBulkZeroingSize = new OptionKey&lt;&gt;(2048);
270 
271     @Option(help = &quot;Alignment in bytes for loop header blocks.&quot;, type = OptionType.Expert)
272     public static final OptionKey&lt;Integer&gt; LoopHeaderAlignment = new OptionKey&lt;&gt;(16);
273 
274     @Option(help = &quot;Do not include membars for volatile accesses until the end of optimizations.&quot;, type = OptionType.Expert)
275     public static final OptionKey&lt;Boolean&gt; LateMembars = new OptionKey&lt;&gt;(true);
276 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
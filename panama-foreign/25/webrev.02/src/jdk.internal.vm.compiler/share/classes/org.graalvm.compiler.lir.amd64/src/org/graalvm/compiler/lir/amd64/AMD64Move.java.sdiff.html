<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64MathTanOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringLatin1InflateOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64Move.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  27 import static java.lang.Double.doubleToRawLongBits;
  28 import static java.lang.Float.floatToRawIntBits;
  29 import static jdk.vm.ci.code.ValueUtil.asRegister;
  30 import static jdk.vm.ci.code.ValueUtil.isRegister;
  31 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
  32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag.Equal;
  33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag.NotEqual;
  34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  35 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;
  36 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;
  37 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
  38 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
  39 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  40 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  41 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;
  42 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  43 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  44 
  45 import org.graalvm.compiler.asm.Label;
  46 import org.graalvm.compiler.asm.amd64.AMD64Address;

  47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp;
  49 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
  50 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  51 import org.graalvm.compiler.core.common.CompressEncoding;
  52 import org.graalvm.compiler.core.common.LIRKind;
  53 import org.graalvm.compiler.core.common.NumUtil;
  54 import org.graalvm.compiler.core.common.spi.LIRKindTool;
  55 import org.graalvm.compiler.core.common.type.DataPointerConstant;
  56 import org.graalvm.compiler.debug.GraalError;
  57 import org.graalvm.compiler.lir.LIRFrameState;
  58 import org.graalvm.compiler.lir.LIRInstructionClass;
  59 import org.graalvm.compiler.lir.Opcode;
  60 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
  61 import org.graalvm.compiler.lir.StandardOp.NullCheck;
  62 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
  63 import org.graalvm.compiler.lir.VirtualStackSlot;
  64 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  65 import org.graalvm.compiler.options.OptionValues;
  66 
</pre>
<hr />
<pre>
 572         if (asRegister(input).equals(asRegister(result))) {
 573             return;
 574         }
 575         assert asRegister(result).getRegisterCategory().equals(asRegister(input).getRegisterCategory());
 576         switch (kind) {
 577             case BYTE:
 578             case WORD:
 579             case DWORD:
 580                 masm.movl(asRegister(result), asRegister(input));
 581                 break;
 582             case QWORD:
 583                 masm.movq(asRegister(result), asRegister(input));
 584                 break;
 585             case SINGLE:
 586                 masm.movflt(asRegister(result, AMD64Kind.SINGLE), asRegister(input, AMD64Kind.SINGLE));
 587                 break;
 588             case DOUBLE:
 589                 masm.movdbl(asRegister(result, AMD64Kind.DOUBLE), asRegister(input, AMD64Kind.DOUBLE));
 590                 break;
 591             default:
<span class="line-modified"> 592                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + kind);</span>
 593         }
 594     }
 595 
 596     public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input) {
 597         AMD64Address dest = (AMD64Address) crb.asAddress(result);
 598         switch (kind) {
 599             case BYTE:
 600                 masm.movb(dest, input);
 601                 break;
 602             case WORD:
 603                 masm.movw(dest, input);
 604                 break;
 605             case DWORD:
 606                 masm.movl(dest, input);
 607                 break;
 608             case QWORD:
 609                 masm.movq(dest, input);
 610                 break;
 611             case SINGLE:
 612                 masm.movflt(dest, input);
 613                 break;
 614             case DOUBLE:
 615                 masm.movsd(dest, input);
 616                 break;
 617             default:
<span class="line-modified"> 618                 throw GraalError.shouldNotReachHere();</span>
 619         }
 620     }
 621 
 622     public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input) {
 623         AMD64Address src = (AMD64Address) crb.asAddress(input);
 624         switch (kind) {
 625             case BYTE:
 626                 masm.movsbl(result, src);
 627                 break;
 628             case WORD:
 629                 masm.movswl(result, src);
 630                 break;
 631             case DWORD:
 632                 masm.movl(result, src);
 633                 break;
 634             case QWORD:
 635                 masm.movq(result, src);
 636                 break;
 637             case SINGLE:
 638                 masm.movflt(result, src);
 639                 break;
 640             case DOUBLE:
 641                 masm.movdbl(result, src);
 642                 break;
 643             default:
<span class="line-modified"> 644                 throw GraalError.shouldNotReachHere();</span>
 645         }
 646     }
 647 
 648     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {
 649         /*
 650          * Note: we use the kind of the input operand (and not the kind of the result operand)
 651          * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
 652          * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
 653          * operations are then performed on the pointer).
 654          */
 655         switch (input.getJavaKind().getStackKind()) {
 656             case Int:
 657                 // Do not optimize with an XOR as this instruction may be between
 658                 // a CMP and a Jcc in which case the XOR will modify the condition
 659                 // flags and interfere with the Jcc.
 660                 masm.movl(result, input.asInt());
 661 
 662                 break;
 663             case Long:
 664                 // Do not optimize with an XOR as this instruction may be between
</pre>
<hr />
<pre>
 794                 masm.movl(dest, (int) imm);
 795                 break;
 796             case QWORD:
 797             case DOUBLE:
 798                 masm.movlong(dest, imm);
 799                 break;
 800             default:
 801                 throw GraalError.shouldNotReachHere(&quot;Unknown result Kind: &quot; + result.getPlatformKind());
 802         }
 803     }
 804 
 805     public abstract static class PointerCompressionOp extends AMD64LIRInstruction {
 806         protected final LIRKindTool lirKindTool;
 807         protected final CompressEncoding encoding;
 808         protected final boolean nonNull;
 809 
 810         @Def({REG, HINT}) private AllocatableValue result;
 811         @Use({REG, CONST}) private Value input;
 812         @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;
 813 
<span class="line-modified"> 814         protected PointerCompressionOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,</span>
<span class="line-modified"> 815                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {</span>





 816 
 817             super(type);
 818             this.result = result;
 819             this.input = input;
 820             this.baseRegister = baseRegister;
 821             this.encoding = encoding;
 822             this.nonNull = nonNull;
 823             this.lirKindTool = lirKindTool;
 824         }
 825 
 826         public static boolean hasBase(OptionValues options, CompressEncoding encoding) {
 827             return GeneratePIC.getValue(options) || encoding.hasBase();
 828         }
 829 
 830         public final Value getInput() {
 831             return input;
 832         }
 833 
 834         public final AllocatableValue getResult() {
 835             return result;
 836         }
 837 
 838         protected final Register getResultRegister() {
 839             return asRegister(result);
 840         }
 841 
 842         protected final Register getBaseRegister(CompilationResultBuilder crb) {
 843             return hasBase(crb.getOptions(), encoding) ? asRegister(baseRegister) : Register.None;
 844         }
 845 
 846         protected final int getShift() {
 847             return encoding.getShift();
 848         }
 849 



 850         protected final void move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 851             AMD64Move.move((AMD64Kind) kind.getPlatformKind(), crb, masm, result, input);
 852         }































 853     }
 854 
 855     public static class CompressPointerOp extends PointerCompressionOp {
 856         public static final LIRInstructionClass&lt;CompressPointerOp&gt; TYPE = LIRInstructionClass.create(CompressPointerOp.class);
 857 
 858         public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 859             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);
 860         }
 861 
 862         private CompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,
 863                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 864 
 865             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);
 866         }
 867 
 868         @Override
 869         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 870             move(lirKindTool.getObjectKind(), crb, masm);
 871 
 872             final Register resReg = getResultRegister();
</pre>
<hr />
<pre>
 884                 masm.shrq(resReg, shift);
 885             }
 886         }
 887     }
 888 
 889     public static class UncompressPointerOp extends PointerCompressionOp {
 890         public static final LIRInstructionClass&lt;UncompressPointerOp&gt; TYPE = LIRInstructionClass.create(UncompressPointerOp.class);
 891 
 892         public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 893             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);
 894         }
 895 
 896         private UncompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,
 897                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 898             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);
 899         }
 900 
 901         @Override
 902         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 903             Register baseReg = getBaseRegister(crb);


 904             if (nonNull &amp;&amp; !baseReg.equals(Register.None) &amp;&amp; getInput() instanceof RegisterValue) {
 905                 Register inputReg = ((RegisterValue) getInput()).getRegister();
<span class="line-modified"> 906                 if (!inputReg.equals(getResultRegister())) {</span>
<span class="line-modified"> 907                     masm.leaq(getResultRegister(), new AMD64Address(baseReg, inputReg, AMD64Address.Scale.fromShift(getShift())));</span>
 908                     return;
 909                 }
 910             }
 911             move(lirKindTool.getNarrowOopKind(), crb, masm);
<span class="line-modified"> 912             emitUncompressCode(masm, getResultRegister(), getShift(), baseReg, nonNull);</span>
 913         }
 914 
 915         public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull) {
 916             if (nonNull) {
 917                 if (!baseReg.equals(Register.None)) {
<span class="line-modified"> 918                     if (shift != 0) {</span>
<span class="line-removed"> 919                         masm.leaq(resReg, new AMD64Address(baseReg, resReg, AMD64Address.Scale.fromShift(shift)));</span>
<span class="line-removed"> 920                     } else {</span>
<span class="line-removed"> 921                         masm.addq(resReg, baseReg);</span>
<span class="line-removed"> 922                     }</span>
 923                 } else if (shift != 0) {
 924                     masm.shlq(resReg, shift);
 925                 }
 926             } else {
 927                 if (shift != 0) {
 928                     masm.shlq(resReg, shift);
 929                 }
 930 
 931                 if (!baseReg.equals(Register.None)) {
 932                     if (shift == 0) {
 933                         // if encoding.shift != 0, the flags are already set by the shlq
 934                         masm.testq(resReg, resReg);
 935                     }
 936 
 937                     Label done = new Label();
 938                     masm.jccb(Equal, done);
 939                     masm.addq(resReg, baseReg);
 940                     masm.bind(done);
 941                 }
 942             }
</pre>
<hr />
<pre>
 957         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 958             Register nullRegister = crb.uncompressedNullRegister;
 959             if (!nullRegister.equals(Register.None)) {
 960                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
 961             }
 962         }
 963 
 964         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm);
 965     }
 966 
 967     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {
 968         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);
 969 
 970         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {
 971             super(TYPE, result, input);
 972         }
 973 
 974         @Override
 975         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
 976             if (inputRegister.equals(resultRegister)) {
<span class="line-removed"> 977                 masm.subq(inputRegister, nullRegister);</span>
 978                 Label done = new Label();
<span class="line-modified"> 979                 masm.jccb(Equal, done);</span>
 980                 masm.addq(inputRegister, nullRegister);
 981                 masm.bind(done);
 982             } else {
 983                 masm.subq(resultRegister, resultRegister);
 984                 masm.cmpq(inputRegister, nullRegister);
 985                 masm.cmovq(NotEqual, resultRegister, inputRegister);
 986             }
 987         }
 988     }
 989 
 990     public static class ConvertZeroToNullOp extends ZeroNullConversionOp {
 991         public static final LIRInstructionClass&lt;ConvertZeroToNullOp&gt; TYPE = LIRInstructionClass.create(ConvertZeroToNullOp.class);
 992 
 993         public ConvertZeroToNullOp(AllocatableValue result, AllocatableValue input) {
 994             super(TYPE, result, input);
 995         }
 996 
 997         @Override
 998         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
 999             if (!inputRegister.equals(resultRegister)) {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  27 import static java.lang.Double.doubleToRawLongBits;
  28 import static java.lang.Float.floatToRawIntBits;
  29 import static jdk.vm.ci.code.ValueUtil.asRegister;
  30 import static jdk.vm.ci.code.ValueUtil.isRegister;
  31 import static jdk.vm.ci.code.ValueUtil.isStackSlot;
  32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag.Equal;
  33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag.NotEqual;
  34 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  35 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;
  36 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.CONST;
  37 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;
  38 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.ILLEGAL;
  39 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;
  40 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;
  41 import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;
  42 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  43 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  44 
  45 import org.graalvm.compiler.asm.Label;
  46 import org.graalvm.compiler.asm.amd64.AMD64Address;
<span class="line-added">  47 import org.graalvm.compiler.asm.amd64.AMD64Address.Scale;</span>
  48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp;
  50 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
  51 import org.graalvm.compiler.asm.amd64.AMD64MacroAssembler;
  52 import org.graalvm.compiler.core.common.CompressEncoding;
  53 import org.graalvm.compiler.core.common.LIRKind;
  54 import org.graalvm.compiler.core.common.NumUtil;
  55 import org.graalvm.compiler.core.common.spi.LIRKindTool;
  56 import org.graalvm.compiler.core.common.type.DataPointerConstant;
  57 import org.graalvm.compiler.debug.GraalError;
  58 import org.graalvm.compiler.lir.LIRFrameState;
  59 import org.graalvm.compiler.lir.LIRInstructionClass;
  60 import org.graalvm.compiler.lir.Opcode;
  61 import org.graalvm.compiler.lir.StandardOp.LoadConstantOp;
  62 import org.graalvm.compiler.lir.StandardOp.NullCheck;
  63 import org.graalvm.compiler.lir.StandardOp.ValueMoveOp;
  64 import org.graalvm.compiler.lir.VirtualStackSlot;
  65 import org.graalvm.compiler.lir.asm.CompilationResultBuilder;
  66 import org.graalvm.compiler.options.OptionValues;
  67 
</pre>
<hr />
<pre>
 573         if (asRegister(input).equals(asRegister(result))) {
 574             return;
 575         }
 576         assert asRegister(result).getRegisterCategory().equals(asRegister(input).getRegisterCategory());
 577         switch (kind) {
 578             case BYTE:
 579             case WORD:
 580             case DWORD:
 581                 masm.movl(asRegister(result), asRegister(input));
 582                 break;
 583             case QWORD:
 584                 masm.movq(asRegister(result), asRegister(input));
 585                 break;
 586             case SINGLE:
 587                 masm.movflt(asRegister(result, AMD64Kind.SINGLE), asRegister(input, AMD64Kind.SINGLE));
 588                 break;
 589             case DOUBLE:
 590                 masm.movdbl(asRegister(result, AMD64Kind.DOUBLE), asRegister(input, AMD64Kind.DOUBLE));
 591                 break;
 592             default:
<span class="line-modified"> 593                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + kind + &quot; input=&quot; + input + &quot; result=&quot; + result);</span>
 594         }
 595     }
 596 
 597     public static void reg2stack(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, Register input) {
 598         AMD64Address dest = (AMD64Address) crb.asAddress(result);
 599         switch (kind) {
 600             case BYTE:
 601                 masm.movb(dest, input);
 602                 break;
 603             case WORD:
 604                 masm.movw(dest, input);
 605                 break;
 606             case DWORD:
 607                 masm.movl(dest, input);
 608                 break;
 609             case QWORD:
 610                 masm.movq(dest, input);
 611                 break;
 612             case SINGLE:
 613                 masm.movflt(dest, input);
 614                 break;
 615             case DOUBLE:
 616                 masm.movsd(dest, input);
 617                 break;
 618             default:
<span class="line-modified"> 619                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + kind + &quot; input=&quot; + input + &quot; result=&quot; + result);</span>
 620         }
 621     }
 622 
 623     public static void stack2reg(AMD64Kind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, Value input) {
 624         AMD64Address src = (AMD64Address) crb.asAddress(input);
 625         switch (kind) {
 626             case BYTE:
 627                 masm.movsbl(result, src);
 628                 break;
 629             case WORD:
 630                 masm.movswl(result, src);
 631                 break;
 632             case DWORD:
 633                 masm.movl(result, src);
 634                 break;
 635             case QWORD:
 636                 masm.movq(result, src);
 637                 break;
 638             case SINGLE:
 639                 masm.movflt(result, src);
 640                 break;
 641             case DOUBLE:
 642                 masm.movdbl(result, src);
 643                 break;
 644             default:
<span class="line-modified"> 645                 throw GraalError.shouldNotReachHere(&quot;kind=&quot; + kind + &quot; input=&quot; + input + &quot; result=&quot; + result);</span>
 646         }
 647     }
 648 
 649     public static void const2reg(CompilationResultBuilder crb, AMD64MacroAssembler masm, Register result, JavaConstant input, AMD64Kind moveKind) {
 650         /*
 651          * Note: we use the kind of the input operand (and not the kind of the result operand)
 652          * because they don&#39;t match in all cases. For example, an object constant can be loaded to a
 653          * long register when unsafe casts occurred (e.g., for a write barrier where arithmetic
 654          * operations are then performed on the pointer).
 655          */
 656         switch (input.getJavaKind().getStackKind()) {
 657             case Int:
 658                 // Do not optimize with an XOR as this instruction may be between
 659                 // a CMP and a Jcc in which case the XOR will modify the condition
 660                 // flags and interfere with the Jcc.
 661                 masm.movl(result, input.asInt());
 662 
 663                 break;
 664             case Long:
 665                 // Do not optimize with an XOR as this instruction may be between
</pre>
<hr />
<pre>
 795                 masm.movl(dest, (int) imm);
 796                 break;
 797             case QWORD:
 798             case DOUBLE:
 799                 masm.movlong(dest, imm);
 800                 break;
 801             default:
 802                 throw GraalError.shouldNotReachHere(&quot;Unknown result Kind: &quot; + result.getPlatformKind());
 803         }
 804     }
 805 
 806     public abstract static class PointerCompressionOp extends AMD64LIRInstruction {
 807         protected final LIRKindTool lirKindTool;
 808         protected final CompressEncoding encoding;
 809         protected final boolean nonNull;
 810 
 811         @Def({REG, HINT}) private AllocatableValue result;
 812         @Use({REG, CONST}) private Value input;
 813         @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;
 814 
<span class="line-modified"> 815         protected PointerCompressionOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type,</span>
<span class="line-modified"> 816                         AllocatableValue result,</span>
<span class="line-added"> 817                         Value input,</span>
<span class="line-added"> 818                         AllocatableValue baseRegister,</span>
<span class="line-added"> 819                         CompressEncoding encoding,</span>
<span class="line-added"> 820                         boolean nonNull,</span>
<span class="line-added"> 821                         LIRKindTool lirKindTool) {</span>
 822 
 823             super(type);
 824             this.result = result;
 825             this.input = input;
 826             this.baseRegister = baseRegister;
 827             this.encoding = encoding;
 828             this.nonNull = nonNull;
 829             this.lirKindTool = lirKindTool;
 830         }
 831 
 832         public static boolean hasBase(OptionValues options, CompressEncoding encoding) {
 833             return GeneratePIC.getValue(options) || encoding.hasBase();
 834         }
 835 
 836         public final Value getInput() {
 837             return input;
 838         }
 839 
 840         public final AllocatableValue getResult() {
 841             return result;
 842         }
 843 
 844         protected final Register getResultRegister() {
 845             return asRegister(result);
 846         }
 847 
 848         protected final Register getBaseRegister(CompilationResultBuilder crb) {
 849             return hasBase(crb.getOptions(), encoding) ? asRegister(baseRegister) : Register.None;
 850         }
 851 
 852         protected final int getShift() {
 853             return encoding.getShift();
 854         }
 855 
<span class="line-added"> 856         /**</span>
<span class="line-added"> 857          * Emits code to move {@linkplain #getInput input} to {@link #getResult result}.</span>
<span class="line-added"> 858          */</span>
 859         protected final void move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 860             AMD64Move.move((AMD64Kind) kind.getPlatformKind(), crb, masm, result, input);
 861         }
<span class="line-added"> 862 </span>
<span class="line-added"> 863         /**</span>
<span class="line-added"> 864          * Emits code to uncompress the compressed oop in {@code inputAndResultReg} by left shifting</span>
<span class="line-added"> 865          * it {@code shift} bits, adding it to {@code baseReg} and storing the result back in</span>
<span class="line-added"> 866          * {@code inputAndResultReg}.</span>
<span class="line-added"> 867          */</span>
<span class="line-added"> 868         public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register inputAndResultReg, Register baseReg, int shift, boolean preserveFlagsRegister) {</span>
<span class="line-added"> 869             emitUncompressWithBaseRegister(masm, inputAndResultReg, baseReg, inputAndResultReg, shift, preserveFlagsRegister);</span>
<span class="line-added"> 870         }</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872         /**</span>
<span class="line-added"> 873          * Emits code to uncompress the compressed oop in {@code inputReg} by left shifting it</span>
<span class="line-added"> 874          * {@code shift} bits, adding it to {@code baseReg} and storing the result in</span>
<span class="line-added"> 875          * {@code resultReg}.</span>
<span class="line-added"> 876          */</span>
<span class="line-added"> 877         public static void emitUncompressWithBaseRegister(AMD64MacroAssembler masm, Register resultReg, Register baseReg, Register inputReg, int shift, boolean preserveFlagsRegister) {</span>
<span class="line-added"> 878             assert !baseReg.equals(Register.None) || shift != 0 : &quot;compression not enabled&quot;;</span>
<span class="line-added"> 879             if (Scale.isScaleShiftSupported(shift)) {</span>
<span class="line-added"> 880                 AMD64Address.Scale scale = AMD64Address.Scale.fromShift(shift);</span>
<span class="line-added"> 881                 masm.leaq(resultReg, new AMD64Address(baseReg, inputReg, scale));</span>
<span class="line-added"> 882             } else {</span>
<span class="line-added"> 883                 if (preserveFlagsRegister) {</span>
<span class="line-added"> 884                     throw GraalError.shouldNotReachHere(&quot;No valid flag-effect-free instruction available to uncompress oop&quot;);</span>
<span class="line-added"> 885                 }</span>
<span class="line-added"> 886                 if (!resultReg.equals(inputReg)) {</span>
<span class="line-added"> 887                     masm.movq(resultReg, inputReg);</span>
<span class="line-added"> 888                 }</span>
<span class="line-added"> 889                 masm.shlq(resultReg, shift);</span>
<span class="line-added"> 890                 masm.addq(resultReg, baseReg);</span>
<span class="line-added"> 891             }</span>
<span class="line-added"> 892         }</span>
 893     }
 894 
 895     public static class CompressPointerOp extends PointerCompressionOp {
 896         public static final LIRInstructionClass&lt;CompressPointerOp&gt; TYPE = LIRInstructionClass.create(CompressPointerOp.class);
 897 
 898         public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 899             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);
 900         }
 901 
 902         private CompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,
 903                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 904 
 905             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);
 906         }
 907 
 908         @Override
 909         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 910             move(lirKindTool.getObjectKind(), crb, masm);
 911 
 912             final Register resReg = getResultRegister();
</pre>
<hr />
<pre>
 924                 masm.shrq(resReg, shift);
 925             }
 926         }
 927     }
 928 
 929     public static class UncompressPointerOp extends PointerCompressionOp {
 930         public static final LIRInstructionClass&lt;UncompressPointerOp&gt; TYPE = LIRInstructionClass.create(UncompressPointerOp.class);
 931 
 932         public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 933             this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);
 934         }
 935 
 936         private UncompressPointerOp(LIRInstructionClass&lt;? extends PointerCompressionOp&gt; type, AllocatableValue result, Value input,
 937                         AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {
 938             super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);
 939         }
 940 
 941         @Override
 942         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 943             Register baseReg = getBaseRegister(crb);
<span class="line-added"> 944             int shift = getShift();</span>
<span class="line-added"> 945             Register resReg = getResultRegister();</span>
 946             if (nonNull &amp;&amp; !baseReg.equals(Register.None) &amp;&amp; getInput() instanceof RegisterValue) {
 947                 Register inputReg = ((RegisterValue) getInput()).getRegister();
<span class="line-modified"> 948                 if (!inputReg.equals(resReg)) {</span>
<span class="line-modified"> 949                     emitUncompressWithBaseRegister(masm, resReg, baseReg, inputReg, shift, false);</span>
 950                     return;
 951                 }
 952             }
 953             move(lirKindTool.getNarrowOopKind(), crb, masm);
<span class="line-modified"> 954             emitUncompressCode(masm, resReg, shift, baseReg, nonNull);</span>
 955         }
 956 
 957         public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull) {
 958             if (nonNull) {
 959                 if (!baseReg.equals(Register.None)) {
<span class="line-modified"> 960                     emitUncompressWithBaseRegister(masm, resReg, baseReg, shift, false);</span>




 961                 } else if (shift != 0) {
 962                     masm.shlq(resReg, shift);
 963                 }
 964             } else {
 965                 if (shift != 0) {
 966                     masm.shlq(resReg, shift);
 967                 }
 968 
 969                 if (!baseReg.equals(Register.None)) {
 970                     if (shift == 0) {
 971                         // if encoding.shift != 0, the flags are already set by the shlq
 972                         masm.testq(resReg, resReg);
 973                     }
 974 
 975                     Label done = new Label();
 976                     masm.jccb(Equal, done);
 977                     masm.addq(resReg, baseReg);
 978                     masm.bind(done);
 979                 }
 980             }
</pre>
<hr />
<pre>
 995         public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {
 996             Register nullRegister = crb.uncompressedNullRegister;
 997             if (!nullRegister.equals(Register.None)) {
 998                 emitConversion(asRegister(result), asRegister(input), nullRegister, masm);
 999             }
1000         }
1001 
1002         protected abstract void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm);
1003     }
1004 
1005     public static class ConvertNullToZeroOp extends ZeroNullConversionOp {
1006         public static final LIRInstructionClass&lt;ConvertNullToZeroOp&gt; TYPE = LIRInstructionClass.create(ConvertNullToZeroOp.class);
1007 
1008         public ConvertNullToZeroOp(AllocatableValue result, AllocatableValue input) {
1009             super(TYPE, result, input);
1010         }
1011 
1012         @Override
1013         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
1014             if (inputRegister.equals(resultRegister)) {

1015                 Label done = new Label();
<span class="line-modified">1016                 masm.subqAndJcc(inputRegister, nullRegister, Equal, done, true);</span>
1017                 masm.addq(inputRegister, nullRegister);
1018                 masm.bind(done);
1019             } else {
1020                 masm.subq(resultRegister, resultRegister);
1021                 masm.cmpq(inputRegister, nullRegister);
1022                 masm.cmovq(NotEqual, resultRegister, inputRegister);
1023             }
1024         }
1025     }
1026 
1027     public static class ConvertZeroToNullOp extends ZeroNullConversionOp {
1028         public static final LIRInstructionClass&lt;ConvertZeroToNullOp&gt; TYPE = LIRInstructionClass.create(ConvertZeroToNullOp.class);
1029 
1030         public ConvertZeroToNullOp(AllocatableValue result, AllocatableValue input) {
1031             super(TYPE, result, input);
1032         }
1033 
1034         @Override
1035         protected final void emitConversion(Register resultRegister, Register inputRegister, Register nullRegister, AMD64MacroAssembler masm) {
1036             if (!inputRegister.equals(resultRegister)) {
</pre>
</td>
</tr>
</table>
<center><a href="AMD64MathTanOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64StringLatin1InflateOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
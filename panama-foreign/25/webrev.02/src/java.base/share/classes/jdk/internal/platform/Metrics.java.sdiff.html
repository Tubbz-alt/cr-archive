<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/platform/Metrics.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../sun/launcher/LauncherHelper.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/platform/Metrics.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39  *&lt;li&gt; All processes, including the current process running together
 40  *    isolated from other non-isolated processes.
 41  *
 42  *&lt;li&gt; All processes running on a host when that there is no isolation
 43  *     in effect.
 44  *&lt;/ol&gt;
 45  *
 46  * @author bobv
 47  * @since 11
 48  */
 49 
 50 public interface Metrics {
 51 
 52     /**
 53      * Returns an instance of the Metrics class.
 54      *
 55      * @return Metrics object or null if not supported on this platform.
 56      */
 57     public static Metrics systemMetrics() {
 58         try {
<span class="line-modified"> 59             // We currently only support cgroupv1</span>
<span class="line-removed"> 60             Class&lt;?&gt; c = Class.forName(&quot;jdk.internal.platform.cgroupv1.Metrics&quot;);</span>
<span class="line-removed"> 61             @SuppressWarnings(&quot;unchecked&quot;)</span>
 62             Method m = c.getMethod(&quot;getInstance&quot;);
 63             return (Metrics) m.invoke(null);
 64         } catch (ClassNotFoundException e) {
 65             return null;
 66         } catch (ReflectiveOperationException e) {
 67             throw new InternalError(e);
 68         }
 69     }
 70 
 71     /**
 72      * Returns the interface responsible for providing the
 73      * platform metrics.
 74      *
 75      * @implNote
 76      * Metrics are currently only supported Linux.
<span class="line-modified"> 77      * The provider for Linux is cgroupsv1.</span>
 78      *
 79      * @return The name of the provider.
 80      *
 81      */
 82     public String getProvider();
 83 
 84 
 85     /*****************************************************************
 86      * CPU Accounting Subsystem
 87      ****************************************************************/
 88 
 89     /**
 90      * Returns the aggregate time, in nanoseconds, consumed by all
 91      * tasks in the Isolation Group.
 92      *
<span class="line-modified"> 93      * @return Time in nanoseconds or 0L if metric is not available.</span>

 94      *
 95      */
 96     public long getCpuUsage();
 97 
 98     /**
 99      * Returns the aggregate time, in nanoseconds, consumed by all tasks in
100      * the Isolation Group, separated by CPU. If the current process
101      * is running within a container, the reported time will only be
102      * valid for processes running within the same container.  The values
103      * are returned in an array, one entry for each physical processor
104      * on the system.  Time values for processors unavailable to this
105      * Group are undefined.
106      *
107      * @return long array of time values.  The size of the array is equal
108      *         to the total number of physical processors in the system. If
<span class="line-modified">109      *         this metric is not available, a zero length array will be</span>
110      *         returned.
111      *
112      */
113     public long[] getPerCpuUsage();
114 
115     /**
116      * Returns the aggregate user time, in nanoseconds, consumed by all
117      * tasks in the Isolation Group.
118      *
<span class="line-modified">119      * @return User time in nanoseconds or 0L if metric is not available.</span>

120      *
121      */
122     public long getCpuUserUsage();
123 
124     /**
125      * Returns the aggregate system time, in nanoseconds, consumed by
126      * all tasks in the Isolation Group.
127      *
<span class="line-modified">128      * @return System time in nanoseconds or 0L if metric is not available.</span>

129      *
130      */
131     public long getCpuSystemUsage();
132 
133     /*****************************************************************
134      * CPU Scheduling Metrics
135      ****************************************************************/
136 
137     /**
138      * Returns the length of the scheduling period, in
139      * microseconds, for processes within the Isolation Group.
140      *
<span class="line-modified">141      * @return time in microseconds or 0L if metric is not available.</span>

142      *
143      */
144     public long getCpuPeriod();
145 
146     /**
147      * Returns the total available run-time allowed, in microseconds,
148      * during each scheduling period for all tasks in the Isolation
149      * Group.
150      *
<span class="line-modified">151      * @return time in microseconds or -1 if the quota is unlimited.</span>

152      *
153      */
154     public long getCpuQuota();
155 
156 
157     /**
158      * Returns the relative weighting of processes with the Isolation
159      * Group used for prioritizing the scheduling of processes across
160      * all Isolation Groups running on a host.
161      *
162      * @implNote
163      * Popular container orchestration systems have standardized shares
164      * to be multiples of 1024, where 1024 is interpreted as 1 CPU share
165      * of execution.  Users can distribute CPU resources to multiple
166      * Isolation Groups by specifying the CPU share weighting needed by
167      * each process.  To request 2 CPUS worth of execution time, CPU shares
168      * would be set to 2048.
169      *
<span class="line-modified">170      * @return shares value or -1 if no share set.</span>

171      *
172      */
173     public long getCpuShares();
174 
175     /**
176      * Returns the number of time-slice periods that have elapsed if
<span class="line-modified">177      * a CPU quota has been setup for the Isolation Group; otherwise</span>
<span class="line-removed">178      * returns 0.</span>
179      *
<span class="line-modified">180      * @return count of elapsed periods or 0 if the quota is unlimited.</span>

181      *
182      */
183     public long getCpuNumPeriods();
184 
185     /**
186      * Returns the number of time-slice periods that the group has
187      * been throttled or limited due to the group exceeding its quota
188      * if a CPU quota has been setup for the Isolation Group.
189      *
<span class="line-modified">190      * @return count of throttled periods or 0 if the quota is unlimited.</span>

191      *
192      */
193     public long getCpuNumThrottled();
194 
195     /**
196      * Returns the total time duration, in nanoseconds, that the
197      * group has been throttled or limited due to the group exceeding
198      * its quota if a CPU quota has been setup for the Isolation Group.
199      *
<span class="line-modified">200      * @return Throttled time in nanoseconds or 0 if the quota is unlimited.</span>

201      *
202      */
203     public long getCpuThrottledTime();
204 
205 
206     /**
207      * Returns the number of effective processors that this Isolation
208      * group has available to it.  This effective processor count is
209      * computed based on the number of dedicated CPUs, CPU shares and
210      * CPU quotas in effect for this isolation group.
211      *
212      * This method returns the same value as
213      * {@link java.lang.Runtime#availableProcessors()}.
214      *
215      * @return The number of effective CPUs.
216      *
217      */
218     public long getEffectiveCpuCount();
219 
220     /*****************************************************************
221      * CPU Sets
222      ****************************************************************/
223 
224     /**
225      * Returns the CPUS that are available for execution of processes
226      * in the current Isolation Group. The size of the array is equal
227      * to the total number of CPUs and the elements in the array are the
228      * physical CPU numbers that are available.  Some of the CPUs returned
229      * may be offline.  To get the current online CPUs, use
230      * {@link getEffectiveCpuSetCpus()}.
231      *
<span class="line-modified">232      * @return An array of available CPUs or a zero length array</span>
<span class="line-modified">233      *         if the metric is not available.</span>
234      *
235      */
236     public int[] getCpuSetCpus();
237 
238     /**
239      * Returns the CPUS that are available and online for execution of
240      * processes within the current Isolation Group. The size of the
241      * array is equal to the total number of CPUs and the elements in
242      * the array are the physical CPU numbers.
243      *
<span class="line-modified">244      * @return An array of available and online CPUs or a zero length</span>
<span class="line-modified">245      *         array if the metric is not available.</span>
246      *
247      */
248     public int[] getEffectiveCpuSetCpus();
249 
250     /**
251      * Returns the memory nodes that are available for use by processes
252      * in the current Isolation Group. The size of the array is equal
253      * to the total number of nodes and the elements in the array are the
254      * physical node numbers that are available.  Some of the nodes returned
255      * may be offline.  To get the current online memory nodes, use
256      * {@link getEffectiveCpuSetMems()}.
257      *
<span class="line-modified">258      * @return An array of available memory nodes or a zero length array</span>
<span class="line-modified">259      *         if the metric is not available.</span>
260      *
261      */
262     public int[] getCpuSetMems();
263 
264     /**
265      * Returns the memory nodes that are available and online for use by
266      * processes within the current Isolation Group. The size of the
267      * array is equal to the total number of nodes and the elements in
268      * the array are the physical node numbers.
269      *
<span class="line-modified">270      * @return An array of available and online nodes or a zero length</span>
<span class="line-modified">271      *         array if the metric is not available.</span>
272      *
273      */
274     public int[] getEffectiveCpuSetMems();
275 
<span class="line-removed">276     /**</span>
<span class="line-removed">277      * Returns the (attempts per second * 1000), if enabled, that the</span>
<span class="line-removed">278      * operating system tries to satisfy a memory request for any</span>
<span class="line-removed">279      * process in the current Isolation Group when no free memory is</span>
<span class="line-removed">280      * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to</span>
<span class="line-removed">281      * determine if this support is enabled.</span>
<span class="line-removed">282      *</span>
<span class="line-removed">283      * @return Memory pressure or 0 if not enabled or metric is not</span>
<span class="line-removed">284      *         available.</span>
<span class="line-removed">285      *</span>
<span class="line-removed">286      */</span>
<span class="line-removed">287     public double getCpuSetMemoryPressure();</span>
<span class="line-removed">288 </span>
<span class="line-removed">289     /**</span>
<span class="line-removed">290      * Returns the state of the memory pressure detection support.</span>
<span class="line-removed">291      *</span>
<span class="line-removed">292      * @return true if the support is available and enabled, otherwise false.</span>
<span class="line-removed">293      *</span>
<span class="line-removed">294      */</span>
<span class="line-removed">295     public boolean isCpuSetMemoryPressureEnabled();</span>
<span class="line-removed">296 </span>
297     /*****************************************************************
298      * Memory Subsystem
299      ****************************************************************/
300 
301     /**
302      * Returns the number of times that user memory requests in the
303      * Isolation Group have exceeded the memory limit.
304      *
<span class="line-modified">305      * @return The number of exceeded requests or 0 if none or metric</span>
<span class="line-modified">306      *         is not available.</span>

307      *
308      */
309     public long getMemoryFailCount();
310 
311     /**
312      * Returns the maximum amount of physical memory, in bytes, that
313      * can be allocated in the Isolation Group.
314      *
<span class="line-modified">315      * @return The maximum amount of memory in bytes or -1 if either</span>
<span class="line-modified">316      *         there is no limit set or this metric is not available.</span>
317      *
318      */
319     public long getMemoryLimit();
320 
<span class="line-removed">321     /**</span>
<span class="line-removed">322      * Returns the largest amount of physical memory, in bytes, that</span>
<span class="line-removed">323      * have been allocated in the Isolation Group.</span>
<span class="line-removed">324      *</span>
<span class="line-removed">325      * @return The largest amount of memory in bytes or 0 if this</span>
<span class="line-removed">326      *         metric is not available.</span>
<span class="line-removed">327      *</span>
<span class="line-removed">328      */</span>
<span class="line-removed">329     public long getMemoryMaxUsage();</span>
<span class="line-removed">330 </span>
331     /**
332      * Returns the amount of physical memory, in bytes, that is currently
333      * allocated in the current Isolation Group.
334      *
<span class="line-modified">335      * @return The amount of memory in bytes allocated or 0 if this</span>
<span class="line-modified">336      *         metric is not available.</span>

337      *
338      */
339     public long getMemoryUsage();
340 
<span class="line-removed">341     /**</span>
<span class="line-removed">342      * Returns the number of times that kernel memory requests in the</span>
<span class="line-removed">343      * Isolation Group have exceeded the kernel memory limit.</span>
<span class="line-removed">344      *</span>
<span class="line-removed">345      * @return The number of exceeded requests or 0 if none or metric</span>
<span class="line-removed">346      *         is not available.</span>
<span class="line-removed">347      *</span>
<span class="line-removed">348      */</span>
<span class="line-removed">349     public long getKernelMemoryFailCount();</span>
<span class="line-removed">350 </span>
<span class="line-removed">351     /**</span>
<span class="line-removed">352      * Returns the maximum amount of kernel physical memory, in bytes, that</span>
<span class="line-removed">353      * can be allocated in the Isolation Group.</span>
<span class="line-removed">354      *</span>
<span class="line-removed">355      * @return The maximum amount of memory in bytes or -1 if either</span>
<span class="line-removed">356      *         there is no limit set or this metric is not available.</span>
<span class="line-removed">357      *</span>
<span class="line-removed">358      */</span>
<span class="line-removed">359     public long getKernelMemoryLimit();</span>
<span class="line-removed">360 </span>
<span class="line-removed">361     /**</span>
<span class="line-removed">362      * Returns the largest amount of kernel physical memory, in bytes, that</span>
<span class="line-removed">363      * have been allocated in the Isolation Group.</span>
<span class="line-removed">364      *</span>
<span class="line-removed">365      * @return The largest amount of memory in bytes or 0 if this</span>
<span class="line-removed">366      *         metric is not available.</span>
<span class="line-removed">367      *</span>
<span class="line-removed">368      */</span>
<span class="line-removed">369     public long getKernelMemoryMaxUsage();</span>
<span class="line-removed">370 </span>
<span class="line-removed">371     /**</span>
<span class="line-removed">372      * Returns the amount of kernel physical memory, in bytes, that</span>
<span class="line-removed">373      * is currently allocated in the current Isolation Group.</span>
<span class="line-removed">374      *</span>
<span class="line-removed">375      * @return The amount of memory in bytes allocated or 0 if this</span>
<span class="line-removed">376      *         metric is not available.</span>
<span class="line-removed">377      *</span>
<span class="line-removed">378      */</span>
<span class="line-removed">379     public long getKernelMemoryUsage();</span>
<span class="line-removed">380 </span>
<span class="line-removed">381     /**</span>
<span class="line-removed">382      * Returns the number of times that networking memory requests in the</span>
<span class="line-removed">383      * Isolation Group have exceeded the kernel memory limit.</span>
<span class="line-removed">384      *</span>
<span class="line-removed">385      * @return The number of exceeded requests or 0 if none or metric</span>
<span class="line-removed">386      *         is not available.</span>
<span class="line-removed">387      *</span>
<span class="line-removed">388      */</span>
<span class="line-removed">389     public long getTcpMemoryFailCount();</span>
<span class="line-removed">390 </span>
<span class="line-removed">391     /**</span>
<span class="line-removed">392      * Returns the maximum amount of networking physical memory, in bytes,</span>
<span class="line-removed">393      * that can be allocated in the Isolation Group.</span>
<span class="line-removed">394      *</span>
<span class="line-removed">395      * @return The maximum amount of memory in bytes or -1 if either</span>
<span class="line-removed">396      *         there is no limit set or this metric is not available.</span>
<span class="line-removed">397      *</span>
<span class="line-removed">398      */</span>
<span class="line-removed">399     public long getTcpMemoryLimit();</span>
<span class="line-removed">400 </span>
<span class="line-removed">401     /**</span>
<span class="line-removed">402      * Returns the largest amount of networking physical memory, in bytes,</span>
<span class="line-removed">403      * that have been allocated in the Isolation Group.</span>
<span class="line-removed">404      *</span>
<span class="line-removed">405      * @return The largest amount of memory in bytes or 0 if this</span>
<span class="line-removed">406      *         metric is not available.</span>
<span class="line-removed">407      *</span>
<span class="line-removed">408      */</span>
<span class="line-removed">409     public long getTcpMemoryMaxUsage();</span>
<span class="line-removed">410 </span>
411     /**
412      * Returns the amount of networking physical memory, in bytes, that
413      * is currently allocated in the current Isolation Group.
414      *
<span class="line-modified">415      * @return The amount of memory in bytes allocated or 0 if this</span>
<span class="line-modified">416      *         metric is not available.</span>
417      *
418      */
419     public long getTcpMemoryUsage();
420 
<span class="line-removed">421     /**</span>
<span class="line-removed">422      * Returns the number of times that user memory requests in the</span>
<span class="line-removed">423      * Isolation Group have exceeded the memory + swap limit.</span>
<span class="line-removed">424      *</span>
<span class="line-removed">425      * @return The number of exceeded requests or 0 if none or metric</span>
<span class="line-removed">426      *         is not available.</span>
<span class="line-removed">427      *</span>
<span class="line-removed">428      */</span>
<span class="line-removed">429     public long getMemoryAndSwapFailCount();</span>
<span class="line-removed">430 </span>
431     /**
432      * Returns the maximum amount of physical memory and swap space,
433      * in bytes, that can be allocated in the Isolation Group.
434      *
<span class="line-modified">435      * @return The maximum amount of memory in bytes or -1 if either</span>
<span class="line-modified">436      *         there is no limit set or this metric is not available.</span>
437      *
438      */
439     public long getMemoryAndSwapLimit();
440 
<span class="line-removed">441     /**</span>
<span class="line-removed">442      * Returns the largest amount of physical memory and swap space,</span>
<span class="line-removed">443      * in bytes, that have been allocated in the Isolation Group.</span>
<span class="line-removed">444      *</span>
<span class="line-removed">445      * @return The largest amount of memory in bytes or 0 if this</span>
<span class="line-removed">446      *         metric is not available.</span>
<span class="line-removed">447      *</span>
<span class="line-removed">448      */</span>
<span class="line-removed">449     public long getMemoryAndSwapMaxUsage();</span>
<span class="line-removed">450 </span>
451     /**
452      * Returns the amount of physical memory and swap space, in bytes,
453      * that is currently allocated in the current Isolation Group.
454      *
<span class="line-modified">455      * @return The amount of memory in bytes allocated or 0 if this</span>
<span class="line-modified">456      *         metric is not available.</span>

457      *
458      */
459     public long getMemoryAndSwapUsage();
460 
<span class="line-removed">461     /**</span>
<span class="line-removed">462      * Returns the state of the Operating System Out of Memory termination</span>
<span class="line-removed">463      * policy.</span>
<span class="line-removed">464      *</span>
<span class="line-removed">465      * @return Returns true if operating system will terminate processes</span>
<span class="line-removed">466      *         in the Isolation Group that exceed the amount of available</span>
<span class="line-removed">467      *         memory, otherwise false.  Flase will be returned if this</span>
<span class="line-removed">468      *         capability is not available on the current operating system.</span>
<span class="line-removed">469      *</span>
<span class="line-removed">470      */</span>
<span class="line-removed">471     public boolean isMemoryOOMKillEnabled();</span>
<span class="line-removed">472 </span>
473     /**
474      * Returns the hint to the operating system that allows groups
475      * to specify the minimum amount of physical memory that they need to
476      * achieve reasonable performance in low memory systems.  This allows
477      * host systems to provide greater sharing of memory.
478      *
479      * @return The minimum amount of physical memory, in bytes, that the
480      *         operating system will try to maintain under low memory
<span class="line-modified">481      *         conditions.  If this metric is not available, 0 will be</span>
<span class="line-modified">482      *         returned.</span>
483      *
484      */
485     public long getMemorySoftLimit();
486 
487     /*****************************************************************
488      * BlKIO Subsystem
489      ****************************************************************/
490 
491     /**
492      * Returns the number of block I/O requests to the disk that have been
493      * issued by the Isolation Group.
494      *
<span class="line-modified">495      * @return The count of requests or 0 if this metric is not available.</span>

496      *
497      */
498     public long getBlkIOServiceCount();
499 
500     /**
501      * Returns the number of block I/O bytes that have been transferred
502      * to/from the disk by the Isolation Group.
503      *
<span class="line-modified">504      * @return The number of bytes transferred or 0 if this metric is not available.</span>

505      *
506      */
507     public long getBlkIOServiced();
508 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 39  *&lt;li&gt; All processes, including the current process running together
 40  *    isolated from other non-isolated processes.
 41  *
 42  *&lt;li&gt; All processes running on a host when that there is no isolation
 43  *     in effect.
 44  *&lt;/ol&gt;
 45  *
 46  * @author bobv
 47  * @since 11
 48  */
 49 
 50 public interface Metrics {
 51 
 52     /**
 53      * Returns an instance of the Metrics class.
 54      *
 55      * @return Metrics object or null if not supported on this platform.
 56      */
 57     public static Metrics systemMetrics() {
 58         try {
<span class="line-modified"> 59             Class&lt;?&gt; c = Class.forName(&quot;jdk.internal.platform.CgroupMetrics&quot;);</span>


 60             Method m = c.getMethod(&quot;getInstance&quot;);
 61             return (Metrics) m.invoke(null);
 62         } catch (ClassNotFoundException e) {
 63             return null;
 64         } catch (ReflectiveOperationException e) {
 65             throw new InternalError(e);
 66         }
 67     }
 68 
 69     /**
 70      * Returns the interface responsible for providing the
 71      * platform metrics.
 72      *
 73      * @implNote
 74      * Metrics are currently only supported Linux.
<span class="line-modified"> 75      * The provider for Linux is cgroups (version 1 or 2).</span>
 76      *
 77      * @return The name of the provider.
 78      *
 79      */
 80     public String getProvider();
 81 
 82 
 83     /*****************************************************************
 84      * CPU Accounting Subsystem
 85      ****************************************************************/
 86 
 87     /**
 88      * Returns the aggregate time, in nanoseconds, consumed by all
 89      * tasks in the Isolation Group.
 90      *
<span class="line-modified"> 91      * @return Time in nanoseconds, -1 if unknown or</span>
<span class="line-added"> 92      *         -2 if the metric is not supported.</span>
 93      *
 94      */
 95     public long getCpuUsage();
 96 
 97     /**
 98      * Returns the aggregate time, in nanoseconds, consumed by all tasks in
 99      * the Isolation Group, separated by CPU. If the current process
100      * is running within a container, the reported time will only be
101      * valid for processes running within the same container.  The values
102      * are returned in an array, one entry for each physical processor
103      * on the system.  Time values for processors unavailable to this
104      * Group are undefined.
105      *
106      * @return long array of time values.  The size of the array is equal
107      *         to the total number of physical processors in the system. If
<span class="line-modified">108      *         this metric is not supported or not available, null will be</span>
109      *         returned.
110      *
111      */
112     public long[] getPerCpuUsage();
113 
114     /**
115      * Returns the aggregate user time, in nanoseconds, consumed by all
116      * tasks in the Isolation Group.
117      *
<span class="line-modified">118      * @return User time in nanoseconds, -1 if the metric is not available or</span>
<span class="line-added">119      *         -2 if the metric is not supported.</span>
120      *
121      */
122     public long getCpuUserUsage();
123 
124     /**
125      * Returns the aggregate system time, in nanoseconds, consumed by
126      * all tasks in the Isolation Group.
127      *
<span class="line-modified">128      * @return System time in nanoseconds, -1 if the metric is not available or</span>
<span class="line-added">129      *         -2 if the metric is not supported.</span>
130      *
131      */
132     public long getCpuSystemUsage();
133 
134     /*****************************************************************
135      * CPU Scheduling Metrics
136      ****************************************************************/
137 
138     /**
139      * Returns the length of the scheduling period, in
140      * microseconds, for processes within the Isolation Group.
141      *
<span class="line-modified">142      * @return time in microseconds, -1 if the metric is not available or</span>
<span class="line-added">143      *         -2 if the metric is not supported.</span>
144      *
145      */
146     public long getCpuPeriod();
147 
148     /**
149      * Returns the total available run-time allowed, in microseconds,
150      * during each scheduling period for all tasks in the Isolation
151      * Group.
152      *
<span class="line-modified">153      * @return time in microseconds, -1 if the quota is unlimited or</span>
<span class="line-added">154      *         -2 if not supported.</span>
155      *
156      */
157     public long getCpuQuota();
158 
159 
160     /**
161      * Returns the relative weighting of processes with the Isolation
162      * Group used for prioritizing the scheduling of processes across
163      * all Isolation Groups running on a host.
164      *
165      * @implNote
166      * Popular container orchestration systems have standardized shares
167      * to be multiples of 1024, where 1024 is interpreted as 1 CPU share
168      * of execution.  Users can distribute CPU resources to multiple
169      * Isolation Groups by specifying the CPU share weighting needed by
170      * each process.  To request 2 CPUS worth of execution time, CPU shares
171      * would be set to 2048.
172      *
<span class="line-modified">173      * @return shares value, -1 if the metric is not available or</span>
<span class="line-added">174      *         -2 if cpu shares are not supported.</span>
175      *
176      */
177     public long getCpuShares();
178 
179     /**
180      * Returns the number of time-slice periods that have elapsed if
<span class="line-modified">181      * a CPU quota has been setup for the Isolation Group</span>

182      *
<span class="line-modified">183      * @return count of elapsed periods, -1 if the metric is not available</span>
<span class="line-added">184      *         or -2 if the metric is not supported.</span>
185      *
186      */
187     public long getCpuNumPeriods();
188 
189     /**
190      * Returns the number of time-slice periods that the group has
191      * been throttled or limited due to the group exceeding its quota
192      * if a CPU quota has been setup for the Isolation Group.
193      *
<span class="line-modified">194      * @return count of throttled periods, -1 if the metric is not available or</span>
<span class="line-added">195      *         -2 if it is not supported.</span>
196      *
197      */
198     public long getCpuNumThrottled();
199 
200     /**
201      * Returns the total time duration, in nanoseconds, that the
202      * group has been throttled or limited due to the group exceeding
203      * its quota if a CPU quota has been setup for the Isolation Group.
204      *
<span class="line-modified">205      * @return Throttled time in nanoseconds, -1 if the metric is not available</span>
<span class="line-added">206      *         or -2 if it is not supported.</span>
207      *
208      */
209     public long getCpuThrottledTime();
210 
211 
212     /**
213      * Returns the number of effective processors that this Isolation
214      * group has available to it.  This effective processor count is
215      * computed based on the number of dedicated CPUs, CPU shares and
216      * CPU quotas in effect for this isolation group.
217      *
218      * This method returns the same value as
219      * {@link java.lang.Runtime#availableProcessors()}.
220      *
221      * @return The number of effective CPUs.
222      *
223      */
224     public long getEffectiveCpuCount();
225 
226     /*****************************************************************
227      * CPU Sets
228      ****************************************************************/
229 
230     /**
231      * Returns the CPUS that are available for execution of processes
232      * in the current Isolation Group. The size of the array is equal
233      * to the total number of CPUs and the elements in the array are the
234      * physical CPU numbers that are available.  Some of the CPUs returned
235      * may be offline.  To get the current online CPUs, use
236      * {@link getEffectiveCpuSetCpus()}.
237      *
<span class="line-modified">238      * @return An array of available CPUs. Returns null if the metric is not</span>
<span class="line-modified">239      *         available or the metric is not supported.</span>
240      *
241      */
242     public int[] getCpuSetCpus();
243 
244     /**
245      * Returns the CPUS that are available and online for execution of
246      * processes within the current Isolation Group. The size of the
247      * array is equal to the total number of CPUs and the elements in
248      * the array are the physical CPU numbers.
249      *
<span class="line-modified">250      * @return An array of available and online CPUs. Returns null</span>
<span class="line-modified">251      *         if the metric is not available or the metric is not supported.</span>
252      *
253      */
254     public int[] getEffectiveCpuSetCpus();
255 
256     /**
257      * Returns the memory nodes that are available for use by processes
258      * in the current Isolation Group. The size of the array is equal
259      * to the total number of nodes and the elements in the array are the
260      * physical node numbers that are available.  Some of the nodes returned
261      * may be offline.  To get the current online memory nodes, use
262      * {@link getEffectiveCpuSetMems()}.
263      *
<span class="line-modified">264      * @return An array of available memory nodes or null</span>
<span class="line-modified">265      *         if the metric is not available or is not supported.</span>
266      *
267      */
268     public int[] getCpuSetMems();
269 
270     /**
271      * Returns the memory nodes that are available and online for use by
272      * processes within the current Isolation Group. The size of the
273      * array is equal to the total number of nodes and the elements in
274      * the array are the physical node numbers.
275      *
<span class="line-modified">276      * @return An array of available and online nodes or null</span>
<span class="line-modified">277      *         if the metric is not available or is not supported.</span>
278      *
279      */
280     public int[] getEffectiveCpuSetMems();
281 





















282     /*****************************************************************
283      * Memory Subsystem
284      ****************************************************************/
285 
286     /**
287      * Returns the number of times that user memory requests in the
288      * Isolation Group have exceeded the memory limit.
289      *
<span class="line-modified">290      * @return The number of exceeded requests or -1 if the metric</span>
<span class="line-modified">291      *         is not available. Returns -2 if the metric is not</span>
<span class="line-added">292      *         supported.</span>
293      *
294      */
295     public long getMemoryFailCount();
296 
297     /**
298      * Returns the maximum amount of physical memory, in bytes, that
299      * can be allocated in the Isolation Group.
300      *
<span class="line-modified">301      * @return The maximum amount of memory in bytes or -1 if</span>
<span class="line-modified">302      *         there is no limit or -2 if this metric is not supported.</span>
303      *
304      */
305     public long getMemoryLimit();
306 










307     /**
308      * Returns the amount of physical memory, in bytes, that is currently
309      * allocated in the current Isolation Group.
310      *
<span class="line-modified">311      * @return The amount of memory in bytes allocated or -1 if</span>
<span class="line-modified">312      *         the metric is not available or -2 if the metric is not</span>
<span class="line-added">313      *         supported.</span>
314      *
315      */
316     public long getMemoryUsage();
317 






































































318     /**
319      * Returns the amount of networking physical memory, in bytes, that
320      * is currently allocated in the current Isolation Group.
321      *
<span class="line-modified">322      * @return The amount of memory in bytes allocated or -1 if the metric</span>
<span class="line-modified">323      *         is not available. Returns -2 if this metric is not supported.</span>
324      *
325      */
326     public long getTcpMemoryUsage();
327 










328     /**
329      * Returns the maximum amount of physical memory and swap space,
330      * in bytes, that can be allocated in the Isolation Group.
331      *
<span class="line-modified">332      * @return The maximum amount of memory in bytes or -1 if</span>
<span class="line-modified">333      *         there is no limit set or -2 if this metric is not supported.</span>
334      *
335      */
336     public long getMemoryAndSwapLimit();
337 










338     /**
339      * Returns the amount of physical memory and swap space, in bytes,
340      * that is currently allocated in the current Isolation Group.
341      *
<span class="line-modified">342      * @return The amount of memory in bytes allocated or -1 if</span>
<span class="line-modified">343      *         the metric is not available. Returns -2 if this metric is not</span>
<span class="line-added">344      *         supported.</span>
345      *
346      */
347     public long getMemoryAndSwapUsage();
348 












349     /**
350      * Returns the hint to the operating system that allows groups
351      * to specify the minimum amount of physical memory that they need to
352      * achieve reasonable performance in low memory systems.  This allows
353      * host systems to provide greater sharing of memory.
354      *
355      * @return The minimum amount of physical memory, in bytes, that the
356      *         operating system will try to maintain under low memory
<span class="line-modified">357      *         conditions.  If this metric is not available, -1 will be</span>
<span class="line-modified">358      *         returned. Returns -2 if the metric is not supported.</span>
359      *
360      */
361     public long getMemorySoftLimit();
362 
363     /*****************************************************************
364      * BlKIO Subsystem
365      ****************************************************************/
366 
367     /**
368      * Returns the number of block I/O requests to the disk that have been
369      * issued by the Isolation Group.
370      *
<span class="line-modified">371      * @return The count of requests or -1 if the metric is not available.</span>
<span class="line-added">372      *         Returns -2 if this metric is not supported.</span>
373      *
374      */
375     public long getBlkIOServiceCount();
376 
377     /**
378      * Returns the number of block I/O bytes that have been transferred
379      * to/from the disk by the Isolation Group.
380      *
<span class="line-modified">381      * @return The number of bytes transferred or -1 if the metric is not</span>
<span class="line-added">382      *         available. Returns -2 if this metric is not supported.</span>
383      *
384      */
385     public long getBlkIOServiced();
386 }
</pre>
</td>
</tr>
</table>
<center><a href="../misc/Unsafe.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../sun/launcher/LauncherHelper.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
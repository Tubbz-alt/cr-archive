<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os/linux/os_linux.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/x86_64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/dtrace/jhelper.d.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os/linux/os_linux.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;

  77 #include &quot;utilities/vmError.hpp&quot;
  78 
  79 // put OS-includes here
  80 # include &lt;sys/types.h&gt;
  81 # include &lt;sys/mman.h&gt;
  82 # include &lt;sys/stat.h&gt;
  83 # include &lt;sys/select.h&gt;
  84 # include &lt;pthread.h&gt;
  85 # include &lt;signal.h&gt;
  86 # include &lt;endian.h&gt;
  87 # include &lt;errno.h&gt;
  88 # include &lt;dlfcn.h&gt;
  89 # include &lt;stdio.h&gt;
  90 # include &lt;unistd.h&gt;
  91 # include &lt;sys/resource.h&gt;
  92 # include &lt;pthread.h&gt;
  93 # include &lt;sys/stat.h&gt;
  94 # include &lt;sys/time.h&gt;
  95 # include &lt;sys/times.h&gt;
  96 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
5109   // Java can be invoked as
5110   // 1. Without numactl and heap will be allocated/configured on all nodes as
5111   //    per the system policy.
5112   // 2. With numactl --interleave:
5113   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5114   //      API for membind case bitmask is reset.
5115   //      Interleave is only hint and Kernel can fallback to other nodes if
5116   //      no memory is available on the target nodes.
5117   // 3. With numactl --membind:
5118   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5119   //      interleave case returns bitmask of all nodes.
5120   // numa_all_nodes_ptr holds bitmask of all nodes.
5121   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5122   // bitmask when externally configured to run on all or fewer nodes.
5123 
5124   if (!Linux::libnuma_init()) {
5125     UseNUMA = false;
5126   } else {
5127     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5128       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5129       // is bound explicitly to a single node using membind, disable NUMA.</span>
<span class="line-modified">5130       UseNUMA = false;</span>

5131     } else {
5132 
5133       LogTarget(Info,os) log;
5134       LogStream ls(log);
5135 
5136       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5137 
5138       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5139       const char* numa_mode = &quot;membind&quot;;
5140 
5141       if (Linux::is_running_in_interleave_mode()) {
5142         bmp = Linux::_numa_interleave_bitmask;
5143         numa_mode = &quot;interleave&quot;;
5144       }
5145 
5146       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5147                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5148 
5149       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5150         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5151           ls.print(&quot; %d&quot;, node);
5152         }
5153       }
5154     }
5155   }
5156 
5157   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5158     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5159     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5160     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5161     // and disable adaptive resizing.
5162     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5163       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5164               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5165       UseAdaptiveSizePolicy = false;
5166       UseAdaptiveNUMAChunkSizing = false;
5167     }
5168   }
<span class="line-removed">5169 </span>
<span class="line-removed">5170   if (!UseNUMA &amp;&amp; ForceNUMA) {</span>
<span class="line-removed">5171     UseNUMA = true;</span>
<span class="line-removed">5172   }</span>
5173 }
5174 
5175 // this is called _after_ the global arguments have been parsed
5176 jint os::init_2(void) {
5177 
5178   // This could be set after os::Posix::init() but all platforms
5179   // have to set it the same so we have to mirror Solaris.
5180   DEBUG_ONLY(os::set_mutex_init_done();)
5181 
5182   os::Posix::init_2();
5183 
5184   Linux::fast_thread_clock_init();
5185 
5186   // initialize suspend/resume support - must do this before signal_sets_init()
5187   if (SR_initialize() != 0) {
5188     perror(&quot;SR_initialize failed&quot;);
5189     return JNI_ERR;
5190   }
5191 
5192   Linux::signal_sets_init();
</pre>
</td>
<td>
<hr />
<pre>
  57 #include &quot;runtime/perfMemory.hpp&quot;
  58 #include &quot;runtime/sharedRuntime.hpp&quot;
  59 #include &quot;runtime/statSampler.hpp&quot;
  60 #include &quot;runtime/stubRoutines.hpp&quot;
  61 #include &quot;runtime/thread.inline.hpp&quot;
  62 #include &quot;runtime/threadCritical.hpp&quot;
  63 #include &quot;runtime/threadSMR.hpp&quot;
  64 #include &quot;runtime/timer.hpp&quot;
  65 #include &quot;runtime/vm_version.hpp&quot;
  66 #include &quot;semaphore_posix.hpp&quot;
  67 #include &quot;services/attachListener.hpp&quot;
  68 #include &quot;services/memTracker.hpp&quot;
  69 #include &quot;services/runtimeService.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/decoder.hpp&quot;
  72 #include &quot;utilities/defaultStream.hpp&quot;
  73 #include &quot;utilities/events.hpp&quot;
  74 #include &quot;utilities/elfFile.hpp&quot;
  75 #include &quot;utilities/growableArray.hpp&quot;
  76 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  77 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  78 #include &quot;utilities/vmError.hpp&quot;
  79 
  80 // put OS-includes here
  81 # include &lt;sys/types.h&gt;
  82 # include &lt;sys/mman.h&gt;
  83 # include &lt;sys/stat.h&gt;
  84 # include &lt;sys/select.h&gt;
  85 # include &lt;pthread.h&gt;
  86 # include &lt;signal.h&gt;
  87 # include &lt;endian.h&gt;
  88 # include &lt;errno.h&gt;
  89 # include &lt;dlfcn.h&gt;
  90 # include &lt;stdio.h&gt;
  91 # include &lt;unistd.h&gt;
  92 # include &lt;sys/resource.h&gt;
  93 # include &lt;pthread.h&gt;
  94 # include &lt;sys/stat.h&gt;
  95 # include &lt;sys/time.h&gt;
  96 # include &lt;sys/times.h&gt;
  97 # include &lt;sys/utsname.h&gt;
</pre>
<hr />
<pre>
5110   // Java can be invoked as
5111   // 1. Without numactl and heap will be allocated/configured on all nodes as
5112   //    per the system policy.
5113   // 2. With numactl --interleave:
5114   //      Use numa_get_interleave_mask(v2) API to get nodes bitmask. The same
5115   //      API for membind case bitmask is reset.
5116   //      Interleave is only hint and Kernel can fallback to other nodes if
5117   //      no memory is available on the target nodes.
5118   // 3. With numactl --membind:
5119   //      Use numa_get_membind(v2) API to get nodes bitmask. The same API for
5120   //      interleave case returns bitmask of all nodes.
5121   // numa_all_nodes_ptr holds bitmask of all nodes.
5122   // numa_get_interleave_mask(v2) and numa_get_membind(v2) APIs returns correct
5123   // bitmask when externally configured to run on all or fewer nodes.
5124 
5125   if (!Linux::libnuma_init()) {
5126     UseNUMA = false;
5127   } else {
5128     if ((Linux::numa_max_node() &lt; 1) || Linux::is_bound_to_single_node()) {
5129       // If there&#39;s only one node (they start from 0) or if the process
<span class="line-modified">5130       // is bound explicitly to a single node using membind, disable NUMA unless</span>
<span class="line-modified">5131       // user explicilty forces NUMA optimizations on single-node/UMA systems</span>
<span class="line-added">5132       UseNUMA = ForceNUMA;</span>
5133     } else {
5134 
5135       LogTarget(Info,os) log;
5136       LogStream ls(log);
5137 
5138       Linux::set_configured_numa_policy(Linux::identify_numa_policy());
5139 
5140       struct bitmask* bmp = Linux::_numa_membind_bitmask;
5141       const char* numa_mode = &quot;membind&quot;;
5142 
5143       if (Linux::is_running_in_interleave_mode()) {
5144         bmp = Linux::_numa_interleave_bitmask;
5145         numa_mode = &quot;interleave&quot;;
5146       }
5147 
5148       ls.print(&quot;UseNUMA is enabled and invoked in &#39;%s&#39; mode.&quot;
5149                &quot; Heap will be configured using NUMA memory nodes:&quot;, numa_mode);
5150 
5151       for (int node = 0; node &lt;= Linux::numa_max_node(); node++) {
5152         if (Linux::_numa_bitmask_isbitset(bmp, node)) {
5153           ls.print(&quot; %d&quot;, node);
5154         }
5155       }
5156     }
5157   }
5158 
5159   if (UseParallelGC &amp;&amp; UseNUMA &amp;&amp; UseLargePages &amp;&amp; !can_commit_large_page_memory()) {
5160     // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there&#39;s no way
5161     // we can make the adaptive lgrp chunk resizing work. If the user specified both
5162     // UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn
5163     // and disable adaptive resizing.
5164     if (UseAdaptiveSizePolicy || UseAdaptiveNUMAChunkSizing) {
5165       warning(&quot;UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, &quot;
5166               &quot;disabling adaptive resizing (-XX:-UseAdaptiveSizePolicy -XX:-UseAdaptiveNUMAChunkSizing)&quot;);
5167       UseAdaptiveSizePolicy = false;
5168       UseAdaptiveNUMAChunkSizing = false;
5169     }
5170   }




5171 }
5172 
5173 // this is called _after_ the global arguments have been parsed
5174 jint os::init_2(void) {
5175 
5176   // This could be set after os::Posix::init() but all platforms
5177   // have to set it the same so we have to mirror Solaris.
5178   DEBUG_ONLY(os::set_mutex_init_done();)
5179 
5180   os::Posix::init_2();
5181 
5182   Linux::fast_thread_clock_init();
5183 
5184   // initialize suspend/resume support - must do this before signal_sets_init()
5185   if (SR_initialize() != 0) {
5186     perror(&quot;SR_initialize failed&quot;);
5187     return JNI_ERR;
5188   }
5189 
5190   Linux::signal_sets_init();
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/x86_64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../solaris/dtrace/jhelper.d.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
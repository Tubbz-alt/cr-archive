<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/vtableStubs.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="codeHeapState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/g1BiasedArray.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/vtableStubs.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/vtableStubs.hpp&quot;
 27 #include &quot;compiler/compileBroker.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/klassVtable.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/forte.hpp&quot;
 36 #include &quot;prims/jvmtiExport.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/sharedRuntime.hpp&quot;
 40 #include &quot;utilities/align.hpp&quot;

 41 #ifdef COMPILER2
 42 #include &quot;opto/matcher.hpp&quot;
 43 #endif
 44 
 45 // -----------------------------------------------------------------------------------------
 46 // Implementation of VtableStub
 47 
 48 address VtableStub::_chunk             = NULL;
 49 address VtableStub::_chunk_end         = NULL;
 50 VMReg   VtableStub::_receiver_location = VMRegImpl::Bad();
 51 
 52 
 53 void* VtableStub::operator new(size_t size, int code_size) throw() {
 54   assert_lock_strong(VtableStubs_lock);
 55   assert(size == sizeof(VtableStub), &quot;mismatched size&quot;);
 56   // compute real VtableStub size (rounded to nearest word)
 57   const int real_size = align_up(code_size + (int)sizeof(VtableStub), wordSize);
 58   // malloc them in chunks to minimize header overhead
 59   const int chunk_factor = 32;
 60   if (_chunk == NULL || _chunk + real_size &gt; _chunk_end) {
</pre>
<hr />
<pre>
111   //               vtable  itable
112   // aarch64:         460     324
113   // arm:               ?       ?
114   // ppc (linux, BE): 404     288
115   // ppc (linux, LE): 356     276
116   // ppc (AIX):       416     296
117   // s390x:           408     256
118   // Solaris-sparc:   792     348
119   // x86 (Linux):     670     309
120   // x86 (MacOS):     682     321
121   static const int first_vtableStub_size = 1024;
122   static const int first_itableStub_size =  512;
123 #endif
124 
125 
126 void VtableStubs::initialize() {
127   VtableStub::_receiver_location = SharedRuntime::name_for_receiver();
128   {
129     MutexLocker ml(VtableStubs_lock, Mutex::_no_safepoint_check_flag);
130     assert(_number_of_vtable_stubs == 0, &quot;potential performance bug: VtableStubs initialized more than once&quot;);
<span class="line-modified">131     assert(is_power_of_2(N), &quot;N must be a power of 2&quot;);</span>
132     for (int i = 0; i &lt; N; i++) {
133       _table[i] = NULL;
134     }
135   }
136 }
137 
138 
139 int VtableStubs::code_size_limit(bool is_vtable_stub) {
140   if (is_vtable_stub) {
141     return _vtab_stub_size &gt; 0 ? _vtab_stub_size : first_vtableStub_size;
142   } else { // itable stub
143     return _itab_stub_size &gt; 0 ? _itab_stub_size : first_itableStub_size;
144   }
145 }   // code_size_limit
146 
147 
148 void VtableStubs::check_and_set_size_limit(bool is_vtable_stub,
149                                            int  code_size,
150                                            int  padding) {
151   const char* name = is_vtable_stub ? &quot;vtable&quot; : &quot;itable&quot;;
</pre>
</td>
<td>
<hr />
<pre>
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;code/vtableStubs.hpp&quot;
 27 #include &quot;compiler/compileBroker.hpp&quot;
 28 #include &quot;compiler/disassembler.hpp&quot;
 29 #include &quot;logging/log.hpp&quot;
 30 #include &quot;memory/allocation.inline.hpp&quot;
 31 #include &quot;memory/resourceArea.hpp&quot;
 32 #include &quot;oops/instanceKlass.hpp&quot;
 33 #include &quot;oops/klassVtable.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;prims/forte.hpp&quot;
 36 #include &quot;prims/jvmtiExport.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/mutexLocker.hpp&quot;
 39 #include &quot;runtime/sharedRuntime.hpp&quot;
 40 #include &quot;utilities/align.hpp&quot;
<span class="line-added"> 41 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
 42 #ifdef COMPILER2
 43 #include &quot;opto/matcher.hpp&quot;
 44 #endif
 45 
 46 // -----------------------------------------------------------------------------------------
 47 // Implementation of VtableStub
 48 
 49 address VtableStub::_chunk             = NULL;
 50 address VtableStub::_chunk_end         = NULL;
 51 VMReg   VtableStub::_receiver_location = VMRegImpl::Bad();
 52 
 53 
 54 void* VtableStub::operator new(size_t size, int code_size) throw() {
 55   assert_lock_strong(VtableStubs_lock);
 56   assert(size == sizeof(VtableStub), &quot;mismatched size&quot;);
 57   // compute real VtableStub size (rounded to nearest word)
 58   const int real_size = align_up(code_size + (int)sizeof(VtableStub), wordSize);
 59   // malloc them in chunks to minimize header overhead
 60   const int chunk_factor = 32;
 61   if (_chunk == NULL || _chunk + real_size &gt; _chunk_end) {
</pre>
<hr />
<pre>
112   //               vtable  itable
113   // aarch64:         460     324
114   // arm:               ?       ?
115   // ppc (linux, BE): 404     288
116   // ppc (linux, LE): 356     276
117   // ppc (AIX):       416     296
118   // s390x:           408     256
119   // Solaris-sparc:   792     348
120   // x86 (Linux):     670     309
121   // x86 (MacOS):     682     321
122   static const int first_vtableStub_size = 1024;
123   static const int first_itableStub_size =  512;
124 #endif
125 
126 
127 void VtableStubs::initialize() {
128   VtableStub::_receiver_location = SharedRuntime::name_for_receiver();
129   {
130     MutexLocker ml(VtableStubs_lock, Mutex::_no_safepoint_check_flag);
131     assert(_number_of_vtable_stubs == 0, &quot;potential performance bug: VtableStubs initialized more than once&quot;);
<span class="line-modified">132     assert(is_power_of_2(int(N)), &quot;N must be a power of 2&quot;);</span>
133     for (int i = 0; i &lt; N; i++) {
134       _table[i] = NULL;
135     }
136   }
137 }
138 
139 
140 int VtableStubs::code_size_limit(bool is_vtable_stub) {
141   if (is_vtable_stub) {
142     return _vtab_stub_size &gt; 0 ? _vtab_stub_size : first_vtableStub_size;
143   } else { // itable stub
144     return _itab_stub_size &gt; 0 ? _itab_stub_size : first_itableStub_size;
145   }
146 }   // code_size_limit
147 
148 
149 void VtableStubs::check_and_set_size_limit(bool is_vtable_stub,
150                                            int  code_size,
151                                            int  padding) {
152   const char* name = is_vtable_stub ? &quot;vtable&quot; : &quot;itable&quot;;
</pre>
</td>
</tr>
</table>
<center><a href="codeHeapState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/g1/g1BiasedArray.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
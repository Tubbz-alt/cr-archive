<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/asm/codeBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/codeBuffer.hpp&quot;
  27 #include &quot;code/oopRecorder.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;oops/methodData.hpp&quot;
  30 #include &quot;oops/oop.inline.hpp&quot;
  31 #include &quot;runtime/icache.hpp&quot;
  32 #include &quot;runtime/safepointVerifiers.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 #include &quot;utilities/copy.hpp&quot;
<a name="1" id="anc1"></a>
  35 #include &quot;utilities/xmlstream.hpp&quot;
  36 
  37 // The structure of a CodeSection:
  38 //
  39 //    _start -&gt;           +----------------+
  40 //                        | machine code...|
  41 //    _end -&gt;             |----------------|
  42 //                        |                |
  43 //                        |    (empty)     |
  44 //                        |                |
  45 //                        |                |
  46 //                        +----------------+
  47 //    _limit -&gt;           |                |
  48 //
  49 //    _locs_start -&gt;      +----------------+
  50 //                        |reloc records...|
  51 //                        |----------------|
  52 //    _locs_end -&gt;        |                |
  53 //                        |                |
  54 //                        |    (empty)     |
  55 //                        |                |
  56 //                        |                |
  57 //                        +----------------+
  58 //    _locs_limit -&gt;      |                |
  59 // The _end (resp. _limit) pointer refers to the first
  60 // unused (resp. unallocated) byte.
  61 
  62 // The structure of the CodeBuffer while code is being accumulated:
  63 //
  64 //    _total_start -&gt;    \
  65 //    _insts._start -&gt;              +----------------+
  66 //                                  |                |
  67 //                                  |     Code       |
  68 //                                  |                |
  69 //    _stubs._start -&gt;              |----------------|
  70 //                                  |                |
  71 //                                  |    Stubs       | (also handlers for deopt/exception)
  72 //                                  |                |
  73 //    _consts._start -&gt;             |----------------|
  74 //                                  |                |
  75 //                                  |   Constants    |
  76 //                                  |                |
  77 //                                  +----------------+
  78 //    + _total_size -&gt;              |                |
  79 //
  80 // When the code and relocations are copied to the code cache,
  81 // the empty parts of each section are removed, and everything
  82 // is copied into contiguous locations.
  83 
  84 typedef CodeBuffer::csize_t csize_t;  // file-local definition
  85 
  86 // External buffer, in a predefined CodeBlob.
  87 // Important: The code_start must be taken exactly, and not realigned.
  88 CodeBuffer::CodeBuffer(CodeBlob* blob) {
  89   // Provide code buffer with meaningful name
  90   initialize_misc(blob-&gt;name());
  91   initialize(blob-&gt;content_begin(), blob-&gt;content_size());
  92   verify_section_allocation();
  93 }
  94 
  95 void CodeBuffer::initialize(csize_t code_size, csize_t locs_size) {
  96   // Compute maximal alignment.
  97   int align = _insts.alignment();
  98   // Always allow for empty slop around each section.
  99   int slop = (int) CodeSection::end_slop();
 100 
 101   assert(blob() == NULL, &quot;only once&quot;);
 102   set_blob(BufferBlob::create(_name, code_size + (align+slop) * (SECT_LIMIT+1)));
 103   if (blob() == NULL) {
 104     // The assembler constructor will throw a fatal on an empty CodeBuffer.
 105     return;  // caller must test this
 106   }
 107 
 108   // Set up various pointers into the blob.
 109   initialize(_total_start, _total_size);
 110 
 111   assert((uintptr_t)insts_begin() % CodeEntryAlignment == 0, &quot;instruction start not code entry aligned&quot;);
 112 
 113   pd_initialize();
 114 
 115   if (locs_size != 0) {
 116     _insts.initialize_locs(locs_size / sizeof(relocInfo));
 117   }
 118 
 119   verify_section_allocation();
 120 }
 121 
 122 
 123 CodeBuffer::~CodeBuffer() {
 124   verify_section_allocation();
 125 
 126   // If we allocate our code buffer from the CodeCache
 127   // via a BufferBlob, and it&#39;s not permanent, then
 128   // free the BufferBlob.
 129   // The rest of the memory will be freed when the ResourceObj
 130   // is released.
 131   for (CodeBuffer* cb = this; cb != NULL; cb = cb-&gt;before_expand()) {
 132     // Previous incarnations of this buffer are held live, so that internal
 133     // addresses constructed before expansions will not be confused.
 134     cb-&gt;free_blob();
 135   }
 136 
 137   // free any overflow storage
 138   delete _overflow_arena;
 139 
 140   // Claim is that stack allocation ensures resources are cleaned up.
 141   // This is resource clean up, let&#39;s hope that all were properly copied out.
 142   free_strings();
 143 
 144 #ifdef ASSERT
 145   // Save allocation type to execute assert in ~ResourceObj()
 146   // which is called after this destructor.
 147   assert(_default_oop_recorder.allocated_on_stack(), &quot;should be embedded object&quot;);
 148   ResourceObj::allocation_type at = _default_oop_recorder.get_allocation_type();
 149   Copy::fill_to_bytes(this, sizeof(*this), badResourceValue);
 150   ResourceObj::set_allocation_type((address)(&amp;_default_oop_recorder), at);
 151 #endif
 152 }
 153 
 154 void CodeBuffer::initialize_oop_recorder(OopRecorder* r) {
 155   assert(_oop_recorder == &amp;_default_oop_recorder &amp;&amp; _default_oop_recorder.is_unused(), &quot;do this once&quot;);
 156   DEBUG_ONLY(_default_oop_recorder.freeze());  // force unused OR to be frozen
 157   _oop_recorder = r;
 158 }
 159 
 160 void CodeBuffer::initialize_section_size(CodeSection* cs, csize_t size) {
 161   assert(cs != &amp;_insts, &quot;insts is the memory provider, not the consumer&quot;);
 162   csize_t slop = CodeSection::end_slop();  // margin between sections
 163   int align = cs-&gt;alignment();
 164   assert(is_power_of_2(align), &quot;sanity&quot;);
 165   address start  = _insts._start;
 166   address limit  = _insts._limit;
 167   address middle = limit - size;
 168   middle -= (intptr_t)middle &amp; (align-1);  // align the division point downward
 169   guarantee(middle - slop &gt; start, &quot;need enough space to divide up&quot;);
 170   _insts._limit = middle - slop;  // subtract desired space, plus slop
 171   cs-&gt;initialize(middle, limit - middle);
 172   assert(cs-&gt;start() == middle, &quot;sanity&quot;);
 173   assert(cs-&gt;limit() == limit,  &quot;sanity&quot;);
 174   // give it some relocations to start with, if the main section has them
 175   if (_insts.has_locs())  cs-&gt;initialize_locs(1);
 176 }
 177 
 178 void CodeBuffer::freeze_section(CodeSection* cs) {
 179   CodeSection* next_cs = (cs == consts())? NULL: code_section(cs-&gt;index()+1);
 180   csize_t frozen_size = cs-&gt;size();
 181   if (next_cs != NULL) {
 182     frozen_size = next_cs-&gt;align_at_start(frozen_size);
 183   }
 184   address old_limit = cs-&gt;limit();
 185   address new_limit = cs-&gt;start() + frozen_size;
 186   relocInfo* old_locs_limit = cs-&gt;locs_limit();
 187   relocInfo* new_locs_limit = cs-&gt;locs_end();
 188   // Patch the limits.
 189   cs-&gt;_limit = new_limit;
 190   cs-&gt;_locs_limit = new_locs_limit;
 191   cs-&gt;_frozen = true;
 192   if (next_cs != NULL &amp;&amp; !next_cs-&gt;is_allocated() &amp;&amp; !next_cs-&gt;is_frozen()) {
 193     // Give remaining buffer space to the following section.
 194     next_cs-&gt;initialize(new_limit, old_limit - new_limit);
 195     next_cs-&gt;initialize_shared_locs(new_locs_limit,
 196                                     old_locs_limit - new_locs_limit);
 197   }
 198 }
 199 
 200 void CodeBuffer::set_blob(BufferBlob* blob) {
 201   _blob = blob;
 202   if (blob != NULL) {
 203     address start = blob-&gt;content_begin();
 204     address end   = blob-&gt;content_end();
 205     // Round up the starting address.
 206     int align = _insts.alignment();
 207     start += (-(intptr_t)start) &amp; (align-1);
 208     _total_start = start;
 209     _total_size  = end - start;
 210   } else {
 211 #ifdef ASSERT
 212     // Clean out dangling pointers.
 213     _total_start    = badAddress;
 214     _consts._start  = _consts._end  = badAddress;
 215     _insts._start   = _insts._end   = badAddress;
 216     _stubs._start   = _stubs._end   = badAddress;
 217 #endif //ASSERT
 218   }
 219 }
 220 
 221 void CodeBuffer::free_blob() {
 222   if (_blob != NULL) {
 223     BufferBlob::free(_blob);
 224     set_blob(NULL);
 225   }
 226 }
 227 
 228 const char* CodeBuffer::code_section_name(int n) {
 229 #ifdef PRODUCT
 230   return NULL;
 231 #else //PRODUCT
 232   switch (n) {
 233   case SECT_CONSTS:            return &quot;consts&quot;;
 234   case SECT_INSTS:             return &quot;insts&quot;;
 235   case SECT_STUBS:             return &quot;stubs&quot;;
 236   default:                     return NULL;
 237   }
 238 #endif //PRODUCT
 239 }
 240 
 241 int CodeBuffer::section_index_of(address addr) const {
 242   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 243     const CodeSection* cs = code_section(n);
 244     if (cs-&gt;allocates(addr))  return n;
 245   }
 246   return SECT_NONE;
 247 }
 248 
 249 int CodeBuffer::locator(address addr) const {
 250   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 251     const CodeSection* cs = code_section(n);
 252     if (cs-&gt;allocates(addr)) {
 253       return locator(addr - cs-&gt;start(), n);
 254     }
 255   }
 256   return -1;
 257 }
 258 
 259 address CodeBuffer::locator_address(int locator) const {
 260   if (locator &lt; 0)  return NULL;
 261   address start = code_section(locator_sect(locator))-&gt;start();
 262   return start + locator_pos(locator);
 263 }
 264 
 265 bool CodeBuffer::is_backward_branch(Label&amp; L) {
 266   return L.is_bound() &amp;&amp; insts_end() &lt;= locator_address(L.loc());
 267 }
 268 
 269 address CodeBuffer::decode_begin() {
 270   address begin = _insts.start();
 271   if (_decode_begin != NULL &amp;&amp; _decode_begin &gt; begin)
 272     begin = _decode_begin;
 273   return begin;
 274 }
 275 
 276 
 277 GrowableArray&lt;int&gt;* CodeBuffer::create_patch_overflow() {
 278   if (_overflow_arena == NULL) {
 279     _overflow_arena = new (mtCode) Arena(mtCode);
 280   }
 281   return new (_overflow_arena) GrowableArray&lt;int&gt;(_overflow_arena, 8, 0, 0);
 282 }
 283 
 284 
 285 // Helper function for managing labels and their target addresses.
 286 // Returns a sensible address, and if it is not the label&#39;s final
 287 // address, notes the dependency (at &#39;branch_pc&#39;) on the label.
 288 address CodeSection::target(Label&amp; L, address branch_pc) {
 289   if (L.is_bound()) {
 290     int loc = L.loc();
 291     if (index() == CodeBuffer::locator_sect(loc)) {
 292       return start() + CodeBuffer::locator_pos(loc);
 293     } else {
 294       return outer()-&gt;locator_address(loc);
 295     }
 296   } else {
 297     assert(allocates2(branch_pc), &quot;sanity&quot;);
 298     address base = start();
 299     int patch_loc = CodeBuffer::locator(branch_pc - base, index());
 300     L.add_patch_at(outer(), patch_loc);
 301 
 302     // Need to return a pc, doesn&#39;t matter what it is since it will be
 303     // replaced during resolution later.
 304     // Don&#39;t return NULL or badAddress, since branches shouldn&#39;t overflow.
 305     // Don&#39;t return base either because that could overflow displacements
 306     // for shorter branches.  It will get checked when bound.
 307     return branch_pc;
 308   }
 309 }
 310 
 311 void CodeSection::relocate(address at, relocInfo::relocType rtype, int format, jint method_index) {
 312   RelocationHolder rh;
 313   switch (rtype) {
 314     case relocInfo::none: return;
 315     case relocInfo::opt_virtual_call_type: {
 316       rh = opt_virtual_call_Relocation::spec(method_index);
 317       break;
 318     }
 319     case relocInfo::static_call_type: {
 320       rh = static_call_Relocation::spec(method_index);
 321       break;
 322     }
 323     case relocInfo::virtual_call_type: {
 324       assert(method_index == 0, &quot;resolved method overriding is not supported&quot;);
 325       rh = Relocation::spec_simple(rtype);
 326       break;
 327     }
 328     default: {
 329       rh = Relocation::spec_simple(rtype);
 330       break;
 331     }
 332   }
 333   relocate(at, rh, format);
 334 }
 335 
 336 void CodeSection::relocate(address at, RelocationHolder const&amp; spec, int format) {
 337   // Do not relocate in scratch buffers.
 338   if (scratch_emit()) { return; }
 339   Relocation* reloc = spec.reloc();
 340   relocInfo::relocType rtype = (relocInfo::relocType) reloc-&gt;type();
 341   if (rtype == relocInfo::none)  return;
 342 
 343   // The assertion below has been adjusted, to also work for
 344   // relocation for fixup.  Sometimes we want to put relocation
 345   // information for the next instruction, since it will be patched
 346   // with a call.
 347   assert(start() &lt;= at &amp;&amp; at &lt;= end()+1,
 348          &quot;cannot relocate data outside code boundaries&quot;);
 349 
 350   if (!has_locs()) {
 351     // no space for relocation information provided =&gt; code cannot be
 352     // relocated.  Make sure that relocate is only called with rtypes
 353     // that can be ignored for this kind of code.
 354     assert(rtype == relocInfo::none              ||
 355            rtype == relocInfo::runtime_call_type ||
 356            rtype == relocInfo::internal_word_type||
 357            rtype == relocInfo::section_word_type ||
 358            rtype == relocInfo::external_word_type,
 359            &quot;code needs relocation information&quot;);
 360     // leave behind an indication that we attempted a relocation
 361     DEBUG_ONLY(_locs_start = _locs_limit = (relocInfo*)badAddress);
 362     return;
 363   }
 364 
 365   // Advance the point, noting the offset we&#39;ll have to record.
 366   csize_t offset = at - locs_point();
 367   set_locs_point(at);
 368 
 369   // Test for a couple of overflow conditions; maybe expand the buffer.
 370   relocInfo* end = locs_end();
 371   relocInfo* req = end + relocInfo::length_limit;
 372   // Check for (potential) overflow
 373   if (req &gt;= locs_limit() || offset &gt;= relocInfo::offset_limit()) {
 374     req += (uint)offset / (uint)relocInfo::offset_limit();
 375     if (req &gt;= locs_limit()) {
 376       // Allocate or reallocate.
 377       expand_locs(locs_count() + (req - end));
 378       // reload pointer
 379       end = locs_end();
 380     }
 381   }
 382 
 383   // If the offset is giant, emit filler relocs, of type &#39;none&#39;, but
 384   // each carrying the largest possible offset, to advance the locs_point.
 385   while (offset &gt;= relocInfo::offset_limit()) {
 386     assert(end &lt; locs_limit(), &quot;adjust previous paragraph of code&quot;);
 387     *end++ = filler_relocInfo();
 388     offset -= filler_relocInfo().addr_offset();
 389   }
 390 
 391   // If it&#39;s a simple reloc with no data, we&#39;ll just write (rtype | offset).
 392   (*end) = relocInfo(rtype, offset, format);
 393 
 394   // If it has data, insert the prefix, as (data_prefix_tag | data1), data2.
 395   end-&gt;initialize(this, reloc);
 396 }
 397 
 398 void CodeSection::initialize_locs(int locs_capacity) {
 399   assert(_locs_start == NULL, &quot;only one locs init step, please&quot;);
 400   // Apply a priori lower limits to relocation size:
 401   csize_t min_locs = MAX2(size() / 16, (csize_t)4);
 402   if (locs_capacity &lt; min_locs)  locs_capacity = min_locs;
 403   relocInfo* locs_start = NEW_RESOURCE_ARRAY(relocInfo, locs_capacity);
 404   _locs_start    = locs_start;
 405   _locs_end      = locs_start;
 406   _locs_limit    = locs_start + locs_capacity;
 407   _locs_own      = true;
 408 }
 409 
 410 void CodeSection::initialize_shared_locs(relocInfo* buf, int length) {
 411   assert(_locs_start == NULL, &quot;do this before locs are allocated&quot;);
 412   // Internal invariant:  locs buf must be fully aligned.
 413   // See copy_relocations_to() below.
 414   while ((uintptr_t)buf % HeapWordSize != 0 &amp;&amp; length &gt; 0) {
 415     ++buf; --length;
 416   }
 417   if (length &gt; 0) {
 418     _locs_start = buf;
 419     _locs_end   = buf;
 420     _locs_limit = buf + length;
 421     _locs_own   = false;
 422   }
 423 }
 424 
 425 void CodeSection::initialize_locs_from(const CodeSection* source_cs) {
 426   int lcount = source_cs-&gt;locs_count();
 427   if (lcount != 0) {
 428     initialize_shared_locs(source_cs-&gt;locs_start(), lcount);
 429     _locs_end = _locs_limit = _locs_start + lcount;
 430     assert(is_allocated(), &quot;must have copied code already&quot;);
 431     set_locs_point(start() + source_cs-&gt;locs_point_off());
 432   }
 433   assert(this-&gt;locs_count() == source_cs-&gt;locs_count(), &quot;sanity&quot;);
 434 }
 435 
 436 void CodeSection::expand_locs(int new_capacity) {
 437   if (_locs_start == NULL) {
 438     initialize_locs(new_capacity);
 439     return;
 440   } else {
 441     int old_count    = locs_count();
 442     int old_capacity = locs_capacity();
 443     if (new_capacity &lt; old_capacity * 2)
 444       new_capacity = old_capacity * 2;
 445     relocInfo* locs_start;
 446     if (_locs_own) {
 447       locs_start = REALLOC_RESOURCE_ARRAY(relocInfo, _locs_start, old_capacity, new_capacity);
 448     } else {
 449       locs_start = NEW_RESOURCE_ARRAY(relocInfo, new_capacity);
 450       Copy::conjoint_jbytes(_locs_start, locs_start, old_capacity * sizeof(relocInfo));
 451       _locs_own = true;
 452     }
 453     _locs_start    = locs_start;
 454     _locs_end      = locs_start + old_count;
 455     _locs_limit    = locs_start + new_capacity;
 456   }
 457 }
 458 
 459 
 460 /// Support for emitting the code to its final location.
 461 /// The pattern is the same for all functions.
 462 /// We iterate over all the sections, padding each to alignment.
 463 
 464 csize_t CodeBuffer::total_content_size() const {
 465   csize_t size_so_far = 0;
 466   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 467     const CodeSection* cs = code_section(n);
 468     if (cs-&gt;is_empty())  continue;  // skip trivial section
 469     size_so_far = cs-&gt;align_at_start(size_so_far);
 470     size_so_far += cs-&gt;size();
 471   }
 472   return size_so_far;
 473 }
 474 
 475 void CodeBuffer::compute_final_layout(CodeBuffer* dest) const {
 476   address buf = dest-&gt;_total_start;
 477   csize_t buf_offset = 0;
 478   assert(dest-&gt;_total_size &gt;= total_content_size(), &quot;must be big enough&quot;);
 479 
 480   {
 481     // not sure why this is here, but why not...
 482     int alignSize = MAX2((intx) sizeof(jdouble), CodeEntryAlignment);
 483     assert( (dest-&gt;_total_start - _insts.start()) % alignSize == 0, &quot;copy must preserve alignment&quot;);
 484   }
 485 
 486   const CodeSection* prev_cs      = NULL;
 487   CodeSection*       prev_dest_cs = NULL;
 488 
 489   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 490     // figure compact layout of each section
 491     const CodeSection* cs = code_section(n);
 492     csize_t csize = cs-&gt;size();
 493 
 494     CodeSection* dest_cs = dest-&gt;code_section(n);
 495     if (!cs-&gt;is_empty()) {
 496       // Compute initial padding; assign it to the previous non-empty guy.
 497       // Cf. figure_expanded_capacities.
 498       csize_t padding = cs-&gt;align_at_start(buf_offset) - buf_offset;
 499       if (prev_dest_cs != NULL) {
 500         if (padding != 0) {
 501           buf_offset += padding;
 502           prev_dest_cs-&gt;_limit += padding;
 503         }
 504       } else {
 505         guarantee(padding == 0, &quot;In first iteration no padding should be needed.&quot;);
 506       }
 507       #ifdef ASSERT
 508       if (prev_cs != NULL &amp;&amp; prev_cs-&gt;is_frozen() &amp;&amp; n &lt; (SECT_LIMIT - 1)) {
 509         // Make sure the ends still match up.
 510         // This is important because a branch in a frozen section
 511         // might target code in a following section, via a Label,
 512         // and without a relocation record.  See Label::patch_instructions.
 513         address dest_start = buf+buf_offset;
 514         csize_t start2start = cs-&gt;start() - prev_cs-&gt;start();
 515         csize_t dest_start2start = dest_start - prev_dest_cs-&gt;start();
 516         assert(start2start == dest_start2start, &quot;cannot stretch frozen sect&quot;);
 517       }
 518       #endif //ASSERT
 519       prev_dest_cs = dest_cs;
 520       prev_cs      = cs;
 521     }
 522 
 523     debug_only(dest_cs-&gt;_start = NULL);  // defeat double-initialization assert
 524     dest_cs-&gt;initialize(buf+buf_offset, csize);
 525     dest_cs-&gt;set_end(buf+buf_offset+csize);
 526     assert(dest_cs-&gt;is_allocated(), &quot;must always be allocated&quot;);
 527     assert(cs-&gt;is_empty() == dest_cs-&gt;is_empty(), &quot;sanity&quot;);
 528 
 529     buf_offset += csize;
 530   }
 531 
 532   // Done calculating sections; did it come out to the right end?
 533   assert(buf_offset == total_content_size(), &quot;sanity&quot;);
 534   dest-&gt;verify_section_allocation();
 535 }
 536 
 537 // Append an oop reference that keeps the class alive.
 538 static void append_oop_references(GrowableArray&lt;oop&gt;* oops, Klass* k) {
 539   oop cl = k-&gt;klass_holder();
 540   if (cl != NULL &amp;&amp; !oops-&gt;contains(cl)) {
 541     oops-&gt;append(cl);
 542   }
 543 }
 544 
 545 void CodeBuffer::finalize_oop_references(const methodHandle&amp; mh) {
 546   NoSafepointVerifier nsv;
 547 
 548   GrowableArray&lt;oop&gt; oops;
 549 
 550   // Make sure that immediate metadata records something in the OopRecorder
 551   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 552     // pull code out of each section
 553     CodeSection* cs = code_section(n);
 554     if (cs-&gt;is_empty())  continue;  // skip trivial section
 555     RelocIterator iter(cs);
 556     while (iter.next()) {
 557       if (iter.type() == relocInfo::metadata_type) {
 558         metadata_Relocation* md = iter.metadata_reloc();
 559         if (md-&gt;metadata_is_immediate()) {
 560           Metadata* m = md-&gt;metadata_value();
 561           if (oop_recorder()-&gt;is_real(m)) {
 562             if (m-&gt;is_methodData()) {
 563               m = ((MethodData*)m)-&gt;method();
 564             }
 565             if (m-&gt;is_method()) {
 566               m = ((Method*)m)-&gt;method_holder();
 567             }
 568             if (m-&gt;is_klass()) {
 569               append_oop_references(&amp;oops, (Klass*)m);
 570             } else {
 571               // XXX This will currently occur for MDO which don&#39;t
 572               // have a backpointer.  This has to be fixed later.
 573               m-&gt;print();
 574               ShouldNotReachHere();
 575             }
 576           }
 577         }
 578       }
 579     }
 580   }
 581 
 582   if (!oop_recorder()-&gt;is_unused()) {
 583     for (int i = 0; i &lt; oop_recorder()-&gt;metadata_count(); i++) {
 584       Metadata* m = oop_recorder()-&gt;metadata_at(i);
 585       if (oop_recorder()-&gt;is_real(m)) {
 586         if (m-&gt;is_methodData()) {
 587           m = ((MethodData*)m)-&gt;method();
 588         }
 589         if (m-&gt;is_method()) {
 590           m = ((Method*)m)-&gt;method_holder();
 591         }
 592         if (m-&gt;is_klass()) {
 593           append_oop_references(&amp;oops, (Klass*)m);
 594         } else {
 595           m-&gt;print();
 596           ShouldNotReachHere();
 597         }
 598       }
 599     }
 600 
 601   }
 602 
 603   // Add the class loader of Method* for the nmethod itself
 604   append_oop_references(&amp;oops, mh-&gt;method_holder());
 605 
 606   // Add any oops that we&#39;ve found
 607   Thread* thread = Thread::current();
 608   for (int i = 0; i &lt; oops.length(); i++) {
 609     oop_recorder()-&gt;find_index((jobject)thread-&gt;handle_area()-&gt;allocate_handle(oops.at(i)));
 610   }
 611 }
 612 
 613 
 614 
 615 csize_t CodeBuffer::total_offset_of(const CodeSection* cs) const {
 616   csize_t size_so_far = 0;
 617   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 618     const CodeSection* cur_cs = code_section(n);
 619     if (!cur_cs-&gt;is_empty()) {
 620       size_so_far = cur_cs-&gt;align_at_start(size_so_far);
 621     }
 622     if (cur_cs-&gt;index() == cs-&gt;index()) {
 623       return size_so_far;
 624     }
 625     size_so_far += cur_cs-&gt;size();
 626   }
 627   ShouldNotReachHere();
 628   return -1;
 629 }
 630 
 631 csize_t CodeBuffer::total_relocation_size() const {
 632   csize_t total = copy_relocations_to(NULL);  // dry run only
 633   return (csize_t) align_up(total, HeapWordSize);
 634 }
 635 
 636 csize_t CodeBuffer::copy_relocations_to(address buf, csize_t buf_limit, bool only_inst) const {
 637   csize_t buf_offset = 0;
 638   csize_t code_end_so_far = 0;
 639   csize_t code_point_so_far = 0;
 640 
 641   assert((uintptr_t)buf % HeapWordSize == 0, &quot;buf must be fully aligned&quot;);
 642   assert(buf_limit % HeapWordSize == 0, &quot;buf must be evenly sized&quot;);
 643 
 644   for (int n = (int) SECT_FIRST; n &lt; (int)SECT_LIMIT; n++) {
 645     if (only_inst &amp;&amp; (n != (int)SECT_INSTS)) {
 646       // Need only relocation info for code.
 647       continue;
 648     }
 649     // pull relocs out of each section
 650     const CodeSection* cs = code_section(n);
 651     assert(!(cs-&gt;is_empty() &amp;&amp; cs-&gt;locs_count() &gt; 0), &quot;sanity&quot;);
 652     if (cs-&gt;is_empty())  continue;  // skip trivial section
 653     relocInfo* lstart = cs-&gt;locs_start();
 654     relocInfo* lend   = cs-&gt;locs_end();
 655     csize_t    lsize  = (csize_t)( (address)lend - (address)lstart );
 656     csize_t    csize  = cs-&gt;size();
 657     code_end_so_far = cs-&gt;align_at_start(code_end_so_far);
 658 
 659     if (lsize &gt; 0) {
 660       // Figure out how to advance the combined relocation point
 661       // first to the beginning of this section.
 662       // We&#39;ll insert one or more filler relocs to span that gap.
 663       // (Don&#39;t bother to improve this by editing the first reloc&#39;s offset.)
 664       csize_t new_code_point = code_end_so_far;
 665       for (csize_t jump;
 666            code_point_so_far &lt; new_code_point;
 667            code_point_so_far += jump) {
 668         jump = new_code_point - code_point_so_far;
 669         relocInfo filler = filler_relocInfo();
 670         if (jump &gt;= filler.addr_offset()) {
 671           jump = filler.addr_offset();
 672         } else {  // else shrink the filler to fit
 673           filler = relocInfo(relocInfo::none, jump);
 674         }
 675         if (buf != NULL) {
 676           assert(buf_offset + (csize_t)sizeof(filler) &lt;= buf_limit, &quot;filler in bounds&quot;);
 677           *(relocInfo*)(buf+buf_offset) = filler;
 678         }
 679         buf_offset += sizeof(filler);
 680       }
 681 
 682       // Update code point and end to skip past this section:
 683       csize_t last_code_point = code_end_so_far + cs-&gt;locs_point_off();
 684       assert(code_point_so_far &lt;= last_code_point, &quot;sanity&quot;);
 685       code_point_so_far = last_code_point; // advance past this guy&#39;s relocs
 686     }
 687     code_end_so_far += csize;  // advance past this guy&#39;s instructions too
 688 
 689     // Done with filler; emit the real relocations:
 690     if (buf != NULL &amp;&amp; lsize != 0) {
 691       assert(buf_offset + lsize &lt;= buf_limit, &quot;target in bounds&quot;);
 692       assert((uintptr_t)lstart % HeapWordSize == 0, &quot;sane start&quot;);
 693       if (buf_offset % HeapWordSize == 0) {
 694         // Use wordwise copies if possible:
 695         Copy::disjoint_words((HeapWord*)lstart,
 696                              (HeapWord*)(buf+buf_offset),
 697                              (lsize + HeapWordSize-1) / HeapWordSize);
 698       } else {
 699         Copy::conjoint_jbytes(lstart, buf+buf_offset, lsize);
 700       }
 701     }
 702     buf_offset += lsize;
 703   }
 704 
 705   // Align end of relocation info in target.
 706   while (buf_offset % HeapWordSize != 0) {
 707     if (buf != NULL) {
 708       relocInfo padding = relocInfo(relocInfo::none, 0);
 709       assert(buf_offset + (csize_t)sizeof(padding) &lt;= buf_limit, &quot;padding in bounds&quot;);
 710       *(relocInfo*)(buf+buf_offset) = padding;
 711     }
 712     buf_offset += sizeof(relocInfo);
 713   }
 714 
 715   assert(only_inst || code_end_so_far == total_content_size(), &quot;sanity&quot;);
 716 
 717   return buf_offset;
 718 }
 719 
 720 csize_t CodeBuffer::copy_relocations_to(CodeBlob* dest) const {
 721   address buf = NULL;
 722   csize_t buf_offset = 0;
 723   csize_t buf_limit = 0;
 724 
 725   if (dest != NULL) {
 726     buf = (address)dest-&gt;relocation_begin();
 727     buf_limit = (address)dest-&gt;relocation_end() - buf;
 728   }
 729   // if dest == NULL, this is just the sizing pass
 730   //
 731   buf_offset = copy_relocations_to(buf, buf_limit, false);
 732 
 733   return buf_offset;
 734 }
 735 
 736 void CodeBuffer::copy_code_to(CodeBlob* dest_blob) {
 737 #ifndef PRODUCT
 738   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 739     tty-&gt;print(&quot;done with CodeBuffer:&quot;);
 740     ((CodeBuffer*)this)-&gt;print();
 741   }
 742 #endif //PRODUCT
 743 
 744   CodeBuffer dest(dest_blob);
 745   assert(dest_blob-&gt;content_size() &gt;= total_content_size(), &quot;good sizing&quot;);
 746   this-&gt;compute_final_layout(&amp;dest);
 747 
 748   // Set beginning of constant table before relocating.
 749   dest_blob-&gt;set_ctable_begin(dest.consts()-&gt;start());
 750 
 751   relocate_code_to(&amp;dest);
 752 
 753   // transfer strings and comments from buffer to blob
 754   dest_blob-&gt;set_strings(_code_strings);
 755 
 756   // Done moving code bytes; were they the right size?
 757   assert((int)align_up(dest.total_content_size(), oopSize) == dest_blob-&gt;content_size(), &quot;sanity&quot;);
 758 
 759   // Flush generated code
 760   ICache::invalidate_range(dest_blob-&gt;code_begin(), dest_blob-&gt;code_size());
 761 }
 762 
 763 // Move all my code into another code buffer.  Consult applicable
 764 // relocs to repair embedded addresses.  The layout in the destination
 765 // CodeBuffer is different to the source CodeBuffer: the destination
 766 // CodeBuffer gets the final layout (consts, insts, stubs in order of
 767 // ascending address).
 768 void CodeBuffer::relocate_code_to(CodeBuffer* dest) const {
 769   address dest_end = dest-&gt;_total_start + dest-&gt;_total_size;
 770   address dest_filled = NULL;
 771   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 772     // pull code out of each section
 773     const CodeSection* cs = code_section(n);
 774     if (cs-&gt;is_empty())  continue;  // skip trivial section
 775     CodeSection* dest_cs = dest-&gt;code_section(n);
 776     assert(cs-&gt;size() == dest_cs-&gt;size(), &quot;sanity&quot;);
 777     csize_t usize = dest_cs-&gt;size();
 778     csize_t wsize = align_up(usize, HeapWordSize);
 779     assert(dest_cs-&gt;start() + wsize &lt;= dest_end, &quot;no overflow&quot;);
 780     // Copy the code as aligned machine words.
 781     // This may also include an uninitialized partial word at the end.
 782     Copy::disjoint_words((HeapWord*)cs-&gt;start(),
 783                          (HeapWord*)dest_cs-&gt;start(),
 784                          wsize / HeapWordSize);
 785 
 786     if (dest-&gt;blob() == NULL) {
 787       // Destination is a final resting place, not just another buffer.
 788       // Normalize uninitialized bytes in the final padding.
 789       Copy::fill_to_bytes(dest_cs-&gt;end(), dest_cs-&gt;remaining(),
 790                           Assembler::code_fill_byte());
 791     }
 792     // Keep track of the highest filled address
 793     dest_filled = MAX2(dest_filled, dest_cs-&gt;end() + dest_cs-&gt;remaining());
 794 
 795     assert(cs-&gt;locs_start() != (relocInfo*)badAddress,
 796            &quot;this section carries no reloc storage, but reloc was attempted&quot;);
 797 
 798     // Make the new code copy use the old copy&#39;s relocations:
 799     dest_cs-&gt;initialize_locs_from(cs);
 800   }
 801 
 802   // Do relocation after all sections are copied.
 803   // This is necessary if the code uses constants in stubs, which are
 804   // relocated when the corresponding instruction in the code (e.g., a
 805   // call) is relocated. Stubs are placed behind the main code
 806   // section, so that section has to be copied before relocating.
 807   for (int n = (int) SECT_FIRST; n &lt; (int)SECT_LIMIT; n++) {
 808     // pull code out of each section
 809     const CodeSection* cs = code_section(n);
 810     if (cs-&gt;is_empty()) continue;  // skip trivial section
 811     CodeSection* dest_cs = dest-&gt;code_section(n);
 812     { // Repair the pc relative information in the code after the move
 813       RelocIterator iter(dest_cs);
 814       while (iter.next()) {
 815         iter.reloc()-&gt;fix_relocation_after_move(this, dest);
 816       }
 817     }
 818   }
 819 
 820   if (dest-&gt;blob() == NULL &amp;&amp; dest_filled != NULL) {
 821     // Destination is a final resting place, not just another buffer.
 822     // Normalize uninitialized bytes in the final padding.
 823     Copy::fill_to_bytes(dest_filled, dest_end - dest_filled,
 824                         Assembler::code_fill_byte());
 825 
 826   }
 827 }
 828 
 829 csize_t CodeBuffer::figure_expanded_capacities(CodeSection* which_cs,
 830                                                csize_t amount,
 831                                                csize_t* new_capacity) {
 832   csize_t new_total_cap = 0;
 833 
 834   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 835     const CodeSection* sect = code_section(n);
 836 
 837     if (!sect-&gt;is_empty()) {
 838       // Compute initial padding; assign it to the previous section,
 839       // even if it&#39;s empty (e.g. consts section can be empty).
 840       // Cf. compute_final_layout
 841       csize_t padding = sect-&gt;align_at_start(new_total_cap) - new_total_cap;
 842       if (padding != 0) {
 843         new_total_cap += padding;
 844         assert(n - 1 &gt;= SECT_FIRST, &quot;sanity&quot;);
 845         new_capacity[n - 1] += padding;
 846       }
 847     }
 848 
 849     csize_t exp = sect-&gt;size();  // 100% increase
 850     if ((uint)exp &lt; 4*K)  exp = 4*K;       // minimum initial increase
 851     if (sect == which_cs) {
 852       if (exp &lt; amount)  exp = amount;
 853       if (StressCodeBuffers)  exp = amount;  // expand only slightly
 854     } else if (n == SECT_INSTS) {
 855       // scale down inst increases to a more modest 25%
 856       exp = 4*K + ((exp - 4*K) &gt;&gt; 2);
 857       if (StressCodeBuffers)  exp = amount / 2;  // expand only slightly
 858     } else if (sect-&gt;is_empty()) {
 859       // do not grow an empty secondary section
 860       exp = 0;
 861     }
 862     // Allow for inter-section slop:
 863     exp += CodeSection::end_slop();
 864     csize_t new_cap = sect-&gt;size() + exp;
 865     if (new_cap &lt; sect-&gt;capacity()) {
 866       // No need to expand after all.
 867       new_cap = sect-&gt;capacity();
 868     }
 869     new_capacity[n] = new_cap;
 870     new_total_cap += new_cap;
 871   }
 872 
 873   return new_total_cap;
 874 }
 875 
 876 void CodeBuffer::expand(CodeSection* which_cs, csize_t amount) {
 877 #ifndef PRODUCT
 878   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 879     tty-&gt;print(&quot;expanding CodeBuffer:&quot;);
 880     this-&gt;print();
 881   }
 882 
 883   if (StressCodeBuffers &amp;&amp; blob() != NULL) {
 884     static int expand_count = 0;
 885     if (expand_count &gt;= 0)  expand_count += 1;
 886     if (expand_count &gt; 100 &amp;&amp; is_power_of_2(expand_count)) {
 887       tty-&gt;print_cr(&quot;StressCodeBuffers: have expanded %d times&quot;, expand_count);
 888       // simulate an occasional allocation failure:
 889       free_blob();
 890     }
 891   }
 892 #endif //PRODUCT
 893 
 894   // Resizing must be allowed
 895   {
 896     if (blob() == NULL)  return;  // caller must check for blob == NULL
 897     for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 898       guarantee(!code_section(n)-&gt;is_frozen(), &quot;resizing not allowed when frozen&quot;);
 899     }
 900   }
 901 
 902   // Figure new capacity for each section.
 903   csize_t new_capacity[SECT_LIMIT];
 904   memset(new_capacity, 0, sizeof(csize_t) * SECT_LIMIT);
 905   csize_t new_total_cap
 906     = figure_expanded_capacities(which_cs, amount, new_capacity);
 907 
 908   // Create a new (temporary) code buffer to hold all the new data
 909   CodeBuffer cb(name(), new_total_cap, 0);
 910   if (cb.blob() == NULL) {
 911     // Failed to allocate in code cache.
 912     free_blob();
 913     return;
 914   }
 915 
 916   // Create an old code buffer to remember which addresses used to go where.
 917   // This will be useful when we do final assembly into the code cache,
 918   // because we will need to know how to warp any internal address that
 919   // has been created at any time in this CodeBuffer&#39;s past.
 920   CodeBuffer* bxp = new CodeBuffer(_total_start, _total_size);
 921   bxp-&gt;take_over_code_from(this);  // remember the old undersized blob
 922   DEBUG_ONLY(this-&gt;_blob = NULL);  // silence a later assert
 923   bxp-&gt;_before_expand = this-&gt;_before_expand;
 924   this-&gt;_before_expand = bxp;
 925 
 926   // Give each section its required (expanded) capacity.
 927   for (int n = (int)SECT_LIMIT-1; n &gt;= SECT_FIRST; n--) {
 928     CodeSection* cb_sect   = cb.code_section(n);
 929     CodeSection* this_sect = code_section(n);
 930     if (new_capacity[n] == 0)  continue;  // already nulled out
 931     if (n != SECT_INSTS) {
 932       cb.initialize_section_size(cb_sect, new_capacity[n]);
 933     }
 934     assert(cb_sect-&gt;capacity() &gt;= new_capacity[n], &quot;big enough&quot;);
 935     address cb_start = cb_sect-&gt;start();
 936     cb_sect-&gt;set_end(cb_start + this_sect-&gt;size());
 937     if (this_sect-&gt;mark() == NULL) {
 938       cb_sect-&gt;clear_mark();
 939     } else {
 940       cb_sect-&gt;set_mark(cb_start + this_sect-&gt;mark_off());
 941     }
 942   }
 943 
 944   // Needs to be initialized when calling fix_relocation_after_move.
 945   cb.blob()-&gt;set_ctable_begin(cb.consts()-&gt;start());
 946 
 947   // Move all the code and relocations to the new blob:
 948   relocate_code_to(&amp;cb);
 949 
 950   // Copy the temporary code buffer into the current code buffer.
 951   // Basically, do {*this = cb}, except for some control information.
 952   this-&gt;take_over_code_from(&amp;cb);
 953   cb.set_blob(NULL);
 954 
 955   // Zap the old code buffer contents, to avoid mistakenly using them.
 956   debug_only(Copy::fill_to_bytes(bxp-&gt;_total_start, bxp-&gt;_total_size,
 957                                  badCodeHeapFreeVal));
 958 
 959   _decode_begin = NULL;  // sanity
 960 
 961   // Make certain that the new sections are all snugly inside the new blob.
 962   verify_section_allocation();
 963 
 964 #ifndef PRODUCT
 965   if (PrintNMethods &amp;&amp; (WizardMode || Verbose)) {
 966     tty-&gt;print(&quot;expanded CodeBuffer:&quot;);
 967     this-&gt;print();
 968   }
 969 #endif //PRODUCT
 970 }
 971 
 972 void CodeBuffer::take_over_code_from(CodeBuffer* cb) {
 973   // Must already have disposed of the old blob somehow.
 974   assert(blob() == NULL, &quot;must be empty&quot;);
 975   // Take the new blob away from cb.
 976   set_blob(cb-&gt;blob());
 977   // Take over all the section pointers.
 978   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
 979     CodeSection* cb_sect   = cb-&gt;code_section(n);
 980     CodeSection* this_sect = code_section(n);
 981     this_sect-&gt;take_over_code_from(cb_sect);
 982   }
 983   _overflow_arena = cb-&gt;_overflow_arena;
 984   // Make sure the old cb won&#39;t try to use it or free it.
 985   DEBUG_ONLY(cb-&gt;_blob = (BufferBlob*)badAddress);
 986 }
 987 
 988 void CodeBuffer::verify_section_allocation() {
 989   address tstart = _total_start;
 990   if (tstart == badAddress)  return;  // smashed by set_blob(NULL)
 991   address tend   = tstart + _total_size;
 992   if (_blob != NULL) {
 993 
 994     guarantee(tstart &gt;= _blob-&gt;content_begin(), &quot;sanity&quot;);
 995     guarantee(tend   &lt;= _blob-&gt;content_end(),   &quot;sanity&quot;);
 996   }
 997   // Verify disjointness.
 998   for (int n = (int) SECT_FIRST; n &lt; (int) SECT_LIMIT; n++) {
 999     CodeSection* sect = code_section(n);
1000     if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
1001     guarantee((intptr_t)sect-&gt;start() % sect-&gt;alignment() == 0
1002            || sect-&gt;is_empty() || _blob == NULL,
1003            &quot;start is aligned&quot;);
1004     for (int m = (int) SECT_FIRST; m &lt; (int) SECT_LIMIT; m++) {
1005       CodeSection* other = code_section(m);
1006       if (!other-&gt;is_allocated() || other == sect)  continue;
1007       guarantee(!other-&gt;contains(sect-&gt;start()    ), &quot;sanity&quot;);
1008       // limit is an exclusive address and can be the start of another
1009       // section.
1010       guarantee(!other-&gt;contains(sect-&gt;limit() - 1), &quot;sanity&quot;);
1011     }
1012     guarantee(sect-&gt;end() &lt;= tend, &quot;sanity&quot;);
1013     guarantee(sect-&gt;end() &lt;= sect-&gt;limit(), &quot;sanity&quot;);
1014   }
1015 }
1016 
1017 void CodeBuffer::log_section_sizes(const char* name) {
1018   if (xtty != NULL) {
1019     ttyLocker ttyl;
1020     // log info about buffer usage
1021     xtty-&gt;print_cr(&quot;&lt;blob name=&#39;%s&#39; size=&#39;%d&#39;&gt;&quot;, name, _total_size);
1022     for (int n = (int) CodeBuffer::SECT_FIRST; n &lt; (int) CodeBuffer::SECT_LIMIT; n++) {
1023       CodeSection* sect = code_section(n);
1024       if (!sect-&gt;is_allocated() || sect-&gt;is_empty())  continue;
1025       xtty-&gt;print_cr(&quot;&lt;sect index=&#39;%d&#39; size=&#39;&quot; SIZE_FORMAT &quot;&#39; free=&#39;&quot; SIZE_FORMAT &quot;&#39;/&gt;&quot;,
1026                      n, sect-&gt;limit() - sect-&gt;start(), sect-&gt;limit() - sect-&gt;end());
1027     }
1028     xtty-&gt;print_cr(&quot;&lt;/blob&gt;&quot;);
1029   }
1030 }
1031 
1032 #ifndef PRODUCT
1033 
1034 void CodeSection::decode() {
1035   Disassembler::decode(start(), end());
1036 }
1037 
1038 void CodeBuffer::block_comment(intptr_t offset, const char * comment) {
1039   if (_collect_comments) {
1040     _code_strings.add_comment(offset, comment);
1041   }
1042 }
1043 
1044 const char* CodeBuffer::code_string(const char* str) {
1045   return _code_strings.add_string(str);
1046 }
1047 
1048 class CodeString: public CHeapObj&lt;mtCode&gt; {
1049  private:
1050   friend class CodeStrings;
1051   const char * _string;
1052   CodeString*  _next;
1053   CodeString*  _prev;
1054   intptr_t     _offset;
1055 
1056   ~CodeString() {
1057     assert(_next == NULL &amp;&amp; _prev == NULL, &quot;wrong interface for freeing list&quot;);
1058     os::free((void*)_string);
1059   }
1060 
1061   bool is_comment() const { return _offset &gt;= 0; }
1062 
1063  public:
1064   CodeString(const char * string, intptr_t offset = -1)
1065     : _next(NULL), _prev(NULL), _offset(offset) {
1066     _string = os::strdup(string, mtCode);
1067   }
1068 
1069   const char * string() const { return _string; }
1070   intptr_t     offset() const { assert(_offset &gt;= 0, &quot;offset for non comment?&quot;); return _offset;  }
1071   CodeString* next()    const { return _next; }
1072 
1073   void set_next(CodeString* next) {
1074     _next = next;
1075     if (next != NULL) {
1076       next-&gt;_prev = this;
1077     }
1078   }
1079 
1080   CodeString* first_comment() {
1081     if (is_comment()) {
1082       return this;
1083     } else {
1084       return next_comment();
1085     }
1086   }
1087   CodeString* next_comment() const {
1088     CodeString* s = _next;
1089     while (s != NULL &amp;&amp; !s-&gt;is_comment()) {
1090       s = s-&gt;_next;
1091     }
1092     return s;
1093   }
1094 };
1095 
1096 CodeString* CodeStrings::find(intptr_t offset) const {
1097   CodeString* a = _strings-&gt;first_comment();
1098   while (a != NULL &amp;&amp; a-&gt;offset() != offset) {
1099     a = a-&gt;next_comment();
1100   }
1101   return a;
1102 }
1103 
1104 // Convenience for add_comment.
1105 CodeString* CodeStrings::find_last(intptr_t offset) const {
1106   CodeString* a = _strings_last;
1107   while (a != NULL &amp;&amp; !(a-&gt;is_comment() &amp;&amp; a-&gt;offset() == offset)) {
1108     a = a-&gt;_prev;
1109   }
1110   return a;
1111 }
1112 
1113 void CodeStrings::add_comment(intptr_t offset, const char * comment) {
1114   check_valid();
1115   CodeString* c      = new CodeString(comment, offset);
1116   CodeString* inspos = (_strings == NULL) ? NULL : find_last(offset);
1117 
1118   if (inspos) {
1119     // insert after already existing comments with same offset
1120     c-&gt;set_next(inspos-&gt;next());
1121     inspos-&gt;set_next(c);
1122   } else {
1123     // no comments with such offset, yet. Insert before anything else.
1124     c-&gt;set_next(_strings);
1125     _strings = c;
1126   }
1127   if (c-&gt;next() == NULL) {
1128     _strings_last = c;
1129   }
1130 }
1131 
1132 void CodeStrings::assign(CodeStrings&amp; other) {
1133   other.check_valid();
1134   assert(is_null(), &quot;Cannot assign onto non-empty CodeStrings&quot;);
1135   _strings = other._strings;
1136   _strings_last = other._strings_last;
1137 #ifdef ASSERT
1138   _defunct = false;
1139 #endif
1140   other.set_null_and_invalidate();
1141 }
1142 
1143 // Deep copy of CodeStrings for consistent memory management.
1144 // Only used for actual disassembly so this is cheaper than reference counting
1145 // for the &quot;normal&quot; fastdebug case.
1146 void CodeStrings::copy(CodeStrings&amp; other) {
1147   other.check_valid();
1148   check_valid();
1149   assert(is_null(), &quot;Cannot copy onto non-empty CodeStrings&quot;);
1150   CodeString* n = other._strings;
1151   CodeString** ps = &amp;_strings;
1152   CodeString* prev = NULL;
1153   while (n != NULL) {
1154     *ps = new CodeString(n-&gt;string(),n-&gt;offset());
1155     (*ps)-&gt;_prev = prev;
1156     prev = *ps;
1157     ps = &amp;((*ps)-&gt;_next);
1158     n = n-&gt;next();
1159   }
1160 }
1161 
1162 const char* CodeStrings::_prefix = &quot; ;; &quot;;  // default: can be changed via set_prefix
1163 
1164 // Check if any block comments are pending for the given offset.
1165 bool CodeStrings::has_block_comment(intptr_t offset) const {
1166   if (_strings == NULL) return false;
1167   CodeString* c = find(offset);
1168   return c != NULL;
1169 }
1170 
1171 void CodeStrings::print_block_comment(outputStream* stream, intptr_t offset) const {
1172   check_valid();
1173   if (_strings != NULL) {
1174     CodeString* c = find(offset);
1175     while (c &amp;&amp; c-&gt;offset() == offset) {
1176       stream-&gt;bol();
1177       stream-&gt;print(&quot;%s&quot;, _prefix);
1178       // Don&#39;t interpret as format strings since it could contain %
1179       stream-&gt;print_raw(c-&gt;string());
1180       stream-&gt;bol(); // advance to next line only if string didn&#39;t contain a cr() at the end.
1181       c = c-&gt;next_comment();
1182     }
1183   }
1184 }
1185 
1186 // Also sets isNull()
1187 void CodeStrings::free() {
1188   CodeString* n = _strings;
1189   while (n) {
1190     // unlink the node from the list saving a pointer to the next
1191     CodeString* p = n-&gt;next();
1192     n-&gt;set_next(NULL);
1193     if (p != NULL) {
1194       assert(p-&gt;_prev == n, &quot;missing prev link&quot;);
1195       p-&gt;_prev = NULL;
1196     }
1197     delete n;
1198     n = p;
1199   }
1200   set_null_and_invalidate();
1201 }
1202 
1203 const char* CodeStrings::add_string(const char * string) {
1204   check_valid();
1205   CodeString* s = new CodeString(string);
1206   s-&gt;set_next(_strings);
1207   if (_strings == NULL) {
1208     _strings_last = s;
1209   }
1210   _strings = s;
1211   assert(s-&gt;string() != NULL, &quot;should have a string&quot;);
1212   return s-&gt;string();
1213 }
1214 
1215 void CodeBuffer::decode() {
1216   ttyLocker ttyl;
1217   Disassembler::decode(decode_begin(), insts_end(), tty);
1218   _decode_begin = insts_end();
1219 }
1220 
1221 void CodeSection::print(const char* name) {
1222   csize_t locs_size = locs_end() - locs_start();
1223   tty-&gt;print_cr(&quot; %7s.code = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d)%s&quot;,
1224                 name, p2i(start()), p2i(end()), p2i(limit()), size(), capacity(),
1225                 is_frozen()? &quot; [frozen]&quot;: &quot;&quot;);
1226   tty-&gt;print_cr(&quot; %7s.locs = &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; : &quot; PTR_FORMAT &quot; (%d of %d) point=%d&quot;,
1227                 name, p2i(locs_start()), p2i(locs_end()), p2i(locs_limit()), locs_size, locs_capacity(), locs_point_off());
1228   if (PrintRelocations) {
1229     RelocIterator iter(this);
1230     iter.print();
1231   }
1232 }
1233 
1234 void CodeBuffer::print() {
1235   if (this == NULL) {
1236     tty-&gt;print_cr(&quot;NULL CodeBuffer pointer&quot;);
1237     return;
1238   }
1239 
1240   tty-&gt;print_cr(&quot;CodeBuffer:&quot;);
1241   for (int n = 0; n &lt; (int)SECT_LIMIT; n++) {
1242     // print each section
1243     CodeSection* cs = code_section(n);
1244     cs-&gt;print(code_section_name(n));
1245   }
1246 }
1247 
1248 // Directly disassemble code buffer.
1249 void CodeBuffer::decode(address start, address end) {
1250   ttyLocker ttyl;
1251   Disassembler::decode(this, start, end, tty);
1252 }
1253 
1254 #endif // PRODUCT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
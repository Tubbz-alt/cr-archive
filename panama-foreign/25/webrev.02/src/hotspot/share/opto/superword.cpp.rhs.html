<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  42 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  43 
  44 //
  45 //                  S U P E R W O R D   T R A N S F O R M
  46 //=============================================================================
  47 
  48 //------------------------------SuperWord---------------------------
  49 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  50   _phase(phase),
  51   _arena(phase-&gt;C-&gt;comp_arena()),
  52   _igvn(phase-&gt;_igvn),
  53   _packset(arena(), 8,  0, NULL),         // packs for the current block
  54   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  55   _block(arena(), 8,  0, NULL),           // nodes in current block
  56   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  57   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  58   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  59   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  60   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  61   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  62   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  63   _align_to_ref(NULL),                    // memory reference to align vectors to
  64   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  65   _dg(_arena),                            // dependence graph
  66   _visited(arena()),                      // visited node set
  67   _post_visited(arena()),                 // post visited node set
  68   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  69   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  70   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  71   _lpt(NULL),                             // loop tree node
  72   _lp(NULL),                              // LoopNode
  73   _bb(NULL),                              // basic block
  74   _iv(NULL),                              // induction var
  75   _race_possible(false),                  // cases where SDMU is true
  76   _early_return(true),                    // analysis evaluations routine
  77   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  78   _do_reserve_copy(DoReserveCopyInSuperWord),
  79   _num_work_vecs(0),                      // amount of vector work we have
  80   _num_reductions(0),                     // amount of reduction work we have
  81   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  82   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  83   _ii_order(arena(), 8, 0, 0)
  84 {
  85 #ifndef PRODUCT
  86   _vector_loop_debug = 0;
  87   if (_phase-&gt;C-&gt;method() != NULL) {
  88     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  89   }
  90 
  91 #endif
  92 }
  93 
  94 //------------------------------transform_loop---------------------------
  95 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  96   assert(UseSuperWord, &quot;should be&quot;);
  97   // Do vectors exist on this architecture?
  98   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  99 
 100   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 101   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 102 
 103   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 104 
 105   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 106   if (post_loop_allowed) {
 107     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 108     Node *limit = cl-&gt;limit();
 109     if (limit-&gt;is_Con()) return; // non constant limits only
 110     // Now check the limit for expressions we do not handle
 111     if (limit-&gt;is_Add()) {
 112       Node *in2 = limit-&gt;in(2);
 113       if (in2-&gt;is_Con()) {
 114         int val = in2-&gt;get_int();
 115         // should not try to program these cases
 116         if (val &lt; 0) return;
 117       }
 118     }
 119   }
 120 
 121   // skip any loop that has not been assigned max unroll by analysis
 122   if (do_optimization) {
 123     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 124   }
 125 
 126   // Check for no control flow in body (other than exit)
 127   Node *cl_exit = cl-&gt;loopexit();
 128   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 129     #ifndef PRODUCT
 130       if (TraceSuperWord) {
 131         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 132         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 133         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 134         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 135         lpt-&gt;dump_head();
 136       }
 137     #endif
 138     return;
 139   }
 140 
 141   // Make sure the are no extra control users of the loop backedge
 142   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 143     return;
 144   }
 145 
 146   // Skip any loops already optimized by slp
 147   if (cl-&gt;is_vectorized_loop()) return;
 148 
 149   if (cl-&gt;is_unroll_only()) return;
 150 
 151   if (cl-&gt;is_main_loop()) {
 152     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 153     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 154     if (pre_end == NULL) return;
 155     Node *pre_opaq1 = pre_end-&gt;limit();
 156     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 157   }
 158 
 159   init(); // initialize data structures
 160 
 161   set_lpt(lpt);
 162   set_lp(cl);
 163 
 164   // For now, define one block which is the entire loop body
 165   set_bb(cl);
 166 
 167   if (do_optimization) {
 168     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 169     SLP_extract();
 170     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 171       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 172         IdealLoopTree *lpt_next = lpt-&gt;_next;
 173         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 174         _phase-&gt;has_range_checks(lpt_next);
 175         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 176           if (!cl_next-&gt;is_vectorized_loop()) {
 177             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 178             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 179           }
 180         }
 181       }
 182     }
 183   }
 184 }
 185 
 186 //------------------------------early unrolling analysis------------------------------
 187 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 188   bool is_slp = true;
 189   ResourceMark rm;
 190   size_t ignored_size = lpt()-&gt;_body.size();
 191   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 192   Node_Stack nstack((int)ignored_size);
 193   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 194   Node *cl_exit = cl-&gt;loopexit_or_null();
 195   int rpo_idx = _post_block.length();
 196 
 197   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 198 
 199   // First clear the entries
 200   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 201     ignored_loop_nodes[i] = -1;
 202   }
 203 
 204   int max_vector = Matcher::max_vector_size(T_BYTE);
 205   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 206 
 207   // Process the loop, some/all of the stack entries will not be in order, ergo
 208   // need to preprocess the ignored initial state before we process the loop
 209   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 210     Node* n = lpt()-&gt;_body.at(i);
 211     if (n == cl-&gt;incr() ||
 212       n-&gt;is_reduction() ||
 213       n-&gt;is_AddP() ||
 214       n-&gt;is_Cmp() ||
 215       n-&gt;is_IfTrue() ||
 216       n-&gt;is_CountedLoop() ||
 217       (n == cl_exit)) {
 218       ignored_loop_nodes[i] = n-&gt;_idx;
 219       continue;
 220     }
 221 
 222     if (n-&gt;is_If()) {
 223       IfNode *iff = n-&gt;as_If();
 224       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 225         if (lpt()-&gt;is_loop_exit(iff)) {
 226           ignored_loop_nodes[i] = n-&gt;_idx;
 227           continue;
 228         }
 229       }
 230     }
 231 
 232     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 233       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 234       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 235         if (!n_tail-&gt;is_Mem()) {
 236           is_slp = false;
 237           break;
 238         }
 239       }
 240     }
 241 
 242     // This must happen after check of phi/if
 243     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 244       ignored_loop_nodes[i] = n-&gt;_idx;
 245       continue;
 246     }
 247 
 248     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 249       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 250       is_slp = false;
 251       break;
 252     }
 253 
 254     // Ignore nodes with non-primitive type.
 255     BasicType bt;
 256     if (n-&gt;is_Mem()) {
 257       bt = n-&gt;as_Mem()-&gt;memory_type();
 258     } else {
 259       bt = n-&gt;bottom_type()-&gt;basic_type();
 260     }
 261     if (is_java_primitive(bt) == false) {
 262       ignored_loop_nodes[i] = n-&gt;_idx;
 263       continue;
 264     }
 265 
 266     if (n-&gt;is_Mem()) {
 267       MemNode* current = n-&gt;as_Mem();
 268       Node* adr = n-&gt;in(MemNode::Address);
 269       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 270 
 271       // save a queue of post process nodes
 272       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 273         // Process the memory expression
 274         int stack_idx = 0;
 275         bool have_side_effects = true;
 276         if (adr-&gt;is_AddP() == false) {
 277           nstack.push(adr, stack_idx++);
 278         } else {
 279           // Mark the components of the memory operation in nstack
 280           SWPointer p1(current, this, &amp;nstack, true);
 281           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 282         }
 283 
 284         // Process the pointer stack
 285         while (have_side_effects) {
 286           Node* pointer_node = nstack.node();
 287           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 288             Node* cur_node = lpt()-&gt;_body.at(j);
 289             if (cur_node == pointer_node) {
 290               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 291               break;
 292             }
 293           }
 294           nstack.pop();
 295           have_side_effects = nstack.is_nonempty();
 296         }
 297       }
 298     }
 299   }
 300 
 301   if (is_slp) {
 302     // Now we try to find the maximum supported consistent vector which the machine
 303     // description can use
 304     bool small_basic_type = false;
 305     bool flag_small_bt = false;
 306     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 307       if (ignored_loop_nodes[i] != -1) continue;
 308 
 309       BasicType bt;
 310       Node* n = lpt()-&gt;_body.at(i);
 311       if (n-&gt;is_Mem()) {
 312         bt = n-&gt;as_Mem()-&gt;memory_type();
 313       } else {
 314         bt = n-&gt;bottom_type()-&gt;basic_type();
 315       }
 316 
 317       if (post_loop_allowed) {
 318         if (!small_basic_type) {
 319           switch (bt) {
 320           case T_CHAR:
 321           case T_BYTE:
 322           case T_SHORT:
 323             small_basic_type = true;
 324             break;
 325 
 326           case T_LONG:
 327             // TODO: Remove when support completed for mask context with LONG.
 328             //       Support needs to be augmented for logical qword operations, currently we map to dword
 329             //       buckets for vectors on logicals as these were legacy.
 330             small_basic_type = true;
 331             break;
 332 
 333           default:
 334             break;
 335           }
 336         }
 337       }
 338 
 339       if (is_java_primitive(bt) == false) continue;
 340 
 341          int cur_max_vector = Matcher::max_vector_size(bt);
 342 
 343       // If a max vector exists which is not larger than _local_loop_unroll_factor
 344       // stop looking, we already have the max vector to map to.
 345       if (cur_max_vector &lt; local_loop_unroll_factor) {
 346         is_slp = false;
 347         if (TraceSuperWordLoopUnrollAnalysis) {
 348           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 349         }
 350         break;
 351       }
 352 
 353       // Map the maximal common vector
 354       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 355         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 356           max_vector = cur_max_vector;
 357         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 358           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 359           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 360           // We check for possibility of narrowing by looking through chain operations using subword types.
 361           if (is_subword_type(bt)) {
 362             uint start, end;
 363             VectorNode::vector_operands(n, &amp;start, &amp;end);
 364 
 365             for (uint j = start; j &lt; end; j++) {
 366               Node* in = n-&gt;in(j);
 367               // Don&#39;t propagate through a memory
 368               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 369                 bool same_type = true;
 370                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 371                   Node *use = in-&gt;fast_out(k);
 372                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 373                     same_type = false;
 374                     break;
 375                   }
 376                 }
 377                 if (same_type) {
 378                   max_vector = cur_max_vector;
 379                   flag_small_bt = true;
 380                   cl-&gt;mark_subword_loop();
 381                 }
 382               }
 383             }
 384           }
 385         }
 386         // We only process post loops on predicated targets where we want to
 387         // mask map the loop to a single iteration
 388         if (post_loop_allowed) {
 389           _post_block.at_put_grow(rpo_idx++, n);
 390         }
 391       }
 392     }
 393     if (is_slp) {
 394       local_loop_unroll_factor = max_vector;
 395       cl-&gt;mark_passed_slp();
 396     }
 397     cl-&gt;mark_was_slp();
 398     if (cl-&gt;is_main_loop()) {
 399       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 400     } else if (post_loop_allowed) {
 401       if (!small_basic_type) {
 402         // avoid replication context for small basic types in programmable masked loops
 403         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 404       }
 405     }
 406   }
 407 }
 408 
 409 //------------------------------SLP_extract---------------------------
 410 // Extract the superword level parallelism
 411 //
 412 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 413 //    this list from first to last, all definitions are visited before their uses.
 414 //
 415 // 2) A point-to-point dependence graph is constructed between memory references.
 416 //    This simplies the upcoming &quot;independence&quot; checker.
 417 //
 418 // 3) The maximum depth in the node graph from the beginning of the block
 419 //    to each node is computed.  This is used to prune the graph search
 420 //    in the independence checker.
 421 //
 422 // 4) For integer types, the necessary bit width is propagated backwards
 423 //    from stores to allow packed operations on byte, char, and short
 424 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 425 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 426 //
 427 // 5) One of the memory references is picked to be an aligned vector reference.
 428 //    The pre-loop trip count is adjusted to align this reference in the
 429 //    unrolled body.
 430 //
 431 // 6) The initial set of pack pairs is seeded with memory references.
 432 //
 433 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 434 //
 435 // 8) The pairs are combined into vector sized packs.
 436 //
 437 // 9) Reorder the memory slices to co-locate members of the memory packs.
 438 //
 439 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 440 //    inserting scalar promotion, vector creation from multiple scalars, and
 441 //    extraction of scalar values from vectors.
 442 //
 443 void SuperWord::SLP_extract() {
 444 
 445 #ifndef PRODUCT
 446   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 447     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 448     tty-&gt;print(&quot;input loop\n&quot;);
 449     _lpt-&gt;dump_head();
 450     _lpt-&gt;dump();
 451     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 452       _lpt-&gt;_body.at(i)-&gt;dump();
 453     }
 454   }
 455 #endif
 456   // Ready the block
 457   if (!construct_bb()) {
 458     return; // Exit if no interesting nodes or complex graph.
 459   }
 460 
 461   // build    _dg, _disjoint_ptrs
 462   dependence_graph();
 463 
 464   // compute function depth(Node*)
 465   compute_max_depth();
 466 
 467   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 468   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 469   if (cl-&gt;is_main_loop()) {
 470     if (_do_vector_loop) {
 471       if (mark_generations() != -1) {
 472         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 473 
 474         if (!construct_bb()) {
 475           return; // Exit if no interesting nodes or complex graph.
 476         }
 477         dependence_graph();
 478         compute_max_depth();
 479       }
 480 
 481 #ifndef PRODUCT
 482       if (TraceSuperWord) {
 483         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 484         _lpt-&gt;dump_head();
 485         for (int j = 0; j &lt; _block.length(); j++) {
 486           Node* n = _block.at(j);
 487           int d = depth(n);
 488           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 489           tty-&gt;print(&quot;%d :&quot;, d);
 490           n-&gt;dump();
 491         }
 492       }
 493 #endif
 494     }
 495 
 496     compute_vector_element_type();
 497 
 498     // Attempt vectorization
 499 
 500     find_adjacent_refs();
 501 
 502     extend_packlist();
 503 
 504     if (_do_vector_loop) {
 505       if (_packset.length() == 0) {
 506         if (TraceSuperWord) {
 507           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 508         }
 509         pack_parallel();
 510       }
 511     }
 512 
 513     combine_packs();
 514 
 515     construct_my_pack_map();
 516     if (UseVectorCmov) {
 517       merge_packs_to_cmovd();
 518     }
 519 
 520     filter_packs();
 521 
 522     schedule();
 523   } else if (post_loop_allowed) {
 524     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 525     if (saved_mapped_unroll_factor) {
 526       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 527 
 528       // now reset the slp_unroll_factor so that we can check the analysis mapped
 529       // what the vector loop was mapped to
 530       cl-&gt;set_slp_max_unroll(0);
 531 
 532       // do the analysis on the post loop
 533       unrolling_analysis(vector_mapped_unroll_factor);
 534 
 535       // if our analyzed loop is a canonical fit, start processing it
 536       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 537         // now add the vector nodes to packsets
 538         for (int i = 0; i &lt; _post_block.length(); i++) {
 539           Node* n = _post_block.at(i);
 540           Node_List* singleton = new Node_List();
 541           singleton-&gt;push(n);
 542           _packset.append(singleton);
 543           set_my_pack(n, singleton);
 544         }
 545 
 546         // map base types for vector usage
 547         compute_vector_element_type();
 548       } else {
 549         return;
 550       }
 551     } else {
 552       // for some reason we could not map the slp analysis state of the vectorized loop
 553       return;
 554     }
 555   }
 556 
 557   output();
 558 }
 559 
 560 //------------------------------find_adjacent_refs---------------------------
 561 // Find the adjacent memory references and create pack pairs for them.
 562 // This is the initial set of packs that will then be extended by
 563 // following use-&gt;def and def-&gt;use links.  The align positions are
 564 // assigned relative to the reference &quot;align_to_ref&quot;
 565 void SuperWord::find_adjacent_refs() {
 566   // Get list of memory operations
 567   Node_List memops;
 568   for (int i = 0; i &lt; _block.length(); i++) {
 569     Node* n = _block.at(i);
 570     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 571         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 572       int align = memory_alignment(n-&gt;as_Mem(), 0);
 573       if (align != bottom_align) {
 574         memops.push(n);
 575       }
 576     }
 577   }
 578 
 579   Node_List align_to_refs;
 580   int max_idx;
 581   int best_iv_adjustment = 0;
 582   MemNode* best_align_to_mem_ref = NULL;
 583 
 584   while (memops.size() != 0) {
 585     // Find a memory reference to align to.
 586     MemNode* mem_ref = find_align_to_ref(memops, max_idx);
 587     if (mem_ref == NULL) break;
 588     align_to_refs.push(mem_ref);
 589     int iv_adjustment = get_iv_adjustment(mem_ref);
 590 
 591     if (best_align_to_mem_ref == NULL) {
 592       // Set memory reference which is the best from all memory operations
 593       // to be used for alignment. The pre-loop trip count is modified to align
 594       // this reference to a vector-aligned address.
 595       best_align_to_mem_ref = mem_ref;
 596       best_iv_adjustment = iv_adjustment;
 597       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 598     }
 599 
 600     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 601     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 602     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 603       MemNode* s = memops.at(i)-&gt;as_Mem();
 604       if (isomorphic(s, mem_ref) &amp;&amp;
 605            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 606         SWPointer p2(s, this, NULL, false);
 607         if (p2.comparable(align_to_ref_p)) {
 608           int align = memory_alignment(s, iv_adjustment);
 609           set_alignment(s, align);
 610         }
 611       }
 612     }
 613 
 614     // Create initial pack pairs of memory operations for which
 615     // alignment is set and vectors will be aligned.
 616     bool create_pack = true;
 617     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 618       if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 619         int vw = vector_width(mem_ref);
 620         int vw_best = vector_width(best_align_to_mem_ref);
 621         if (vw &gt; vw_best) {
 622           // Do not vectorize a memory access with more elements per vector
 623           // if unaligned memory access is not allowed because number of
 624           // iterations in pre-loop will be not enough to align it.
 625           create_pack = false;
 626         } else {
 627           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 628           if (align_to_ref_p.invar() != p2.invar()) {
 629             // Do not vectorize memory accesses with different invariants
 630             // if unaligned memory accesses are not allowed.
 631             create_pack = false;
 632           }
 633         }
 634       }
 635     } else {
 636       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 637         // Can&#39;t allow vectorization of unaligned memory accesses with the
 638         // same type since it could be overlapped accesses to the same array.
 639         create_pack = false;
 640       } else {
 641         // Allow independent (different type) unaligned memory operations
 642         // if HW supports them.
 643         if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 644           create_pack = false;
 645         } else {
 646           // Check if packs of the same memory type but
 647           // with a different alignment were created before.
 648           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 649             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 650             if (mr == mem_ref) {
 651               // Skip when we are looking at same memory operation.
 652               continue;
 653             }
 654             if (same_velt_type(mr, mem_ref) &amp;&amp;
 655                 memory_alignment(mr, iv_adjustment) != 0)
 656               create_pack = false;
 657           }
 658         }
 659       }
 660     }
 661     if (create_pack) {
 662       for (uint i = 0; i &lt; memops.size(); i++) {
 663         Node* s1 = memops.at(i);
 664         int align = alignment(s1);
 665         if (align == top_align) continue;
 666         for (uint j = 0; j &lt; memops.size(); j++) {
 667           Node* s2 = memops.at(j);
 668           if (alignment(s2) == top_align) continue;
 669           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 670             if (stmts_can_pack(s1, s2, align)) {
 671               Node_List* pair = new Node_List();
 672               pair-&gt;push(s1);
 673               pair-&gt;push(s2);
 674               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 675                 _packset.append(pair);
 676               }
 677             }
 678           }
 679         }
 680       }
 681     } else { // Don&#39;t create unaligned pack
 682       // First, remove remaining memory ops of the same type from the list.
 683       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 684         MemNode* s = memops.at(i)-&gt;as_Mem();
 685         if (same_velt_type(s, mem_ref)) {
 686           memops.remove(i);
 687         }
 688       }
 689 
 690       // Second, remove already constructed packs of the same type.
 691       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 692         Node_List* p = _packset.at(i);
 693         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 694         if (same_velt_type(s, mem_ref)) {
 695           remove_pack_at(i);
 696         }
 697       }
 698 
 699       // If needed find the best memory reference for loop alignment again.
 700       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 701         // Put memory ops from remaining packs back on memops list for
 702         // the best alignment search.
 703         uint orig_msize = memops.size();
 704         for (int i = 0; i &lt; _packset.length(); i++) {
 705           Node_List* p = _packset.at(i);
 706           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 707           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 708           memops.push(s);
 709         }
 710         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 711         if (best_align_to_mem_ref == NULL) {
 712           if (TraceSuperWord) {
 713             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 714           }
 715           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in
 716           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,
 717           // smallest data size and smallest iv offset from memory ops from remaining packs.
 718           if (_packset.length() &gt; 0) {
 719             if (orig_msize == 0) {
 720               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 721             } else {
 722               for (uint i = 0; i &lt; orig_msize; i++) {
 723                 memops.remove(0);
 724               }
 725               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 726               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);
 727               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 728             }
 729             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);
 730           }
 731           break;
 732         }
 733         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 734         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 735         // Restore list.
 736         while (memops.size() &gt; orig_msize)
 737           (void)memops.pop();
 738       }
 739     } // unaligned memory accesses
 740 
 741     // Remove used mem nodes.
 742     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 743       MemNode* m = memops.at(i)-&gt;as_Mem();
 744       if (alignment(m) != top_align) {
 745         memops.remove(i);
 746       }
 747     }
 748 
 749   } // while (memops.size() != 0
 750   set_align_to_ref(best_align_to_mem_ref);
 751 
 752   if (TraceSuperWord) {
 753     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 754     print_packset();
 755   }
 756 }
 757 
 758 #ifndef PRODUCT
 759 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 760   if (is_trace_adjacent()) {
 761     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 762        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 763        best_align_to_mem_ref-&gt;dump();
 764   }
 765 }
 766 #endif
 767 
 768 //------------------------------find_align_to_ref---------------------------
 769 // Find a memory reference to align the loop induction variable to.
 770 // Looks first at stores then at loads, looking for a memory reference
 771 // with the largest number of references similar to it.
 772 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 773   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 774 
 775   // Count number of comparable memory ops
 776   for (uint i = 0; i &lt; memops.size(); i++) {
 777     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 778     SWPointer p1(s1, this, NULL, false);
 779     // Discard if pre loop can&#39;t align this reference
 780     if (!ref_is_alignable(p1)) {
 781       *cmp_ct.adr_at(i) = 0;
 782       continue;
 783     }
 784     for (uint j = i+1; j &lt; memops.size(); j++) {
 785       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 786       if (isomorphic(s1, s2)) {
 787         SWPointer p2(s2, this, NULL, false);
 788         if (p1.comparable(p2)) {
 789           (*cmp_ct.adr_at(i))++;
 790           (*cmp_ct.adr_at(j))++;
 791         }
 792       }
 793     }
 794   }
 795 
 796   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 797   // biggest vector size, smallest data size and smallest iv offset.
 798   int max_ct        = 0;
 799   int max_vw        = 0;
 800   int max_idx       = -1;
 801   int min_size      = max_jint;
 802   int min_iv_offset = max_jint;
 803   for (uint j = 0; j &lt; memops.size(); j++) {
 804     MemNode* s = memops.at(j)-&gt;as_Mem();
 805     if (s-&gt;is_Store()) {
 806       int vw = vector_width_in_bytes(s);
 807       assert(vw &gt; 1, &quot;sanity&quot;);
 808       SWPointer p(s, this, NULL, false);
 809       if ( cmp_ct.at(j) &gt;  max_ct ||
 810           (cmp_ct.at(j) == max_ct &amp;&amp;
 811             ( vw &gt;  max_vw ||
 812              (vw == max_vw &amp;&amp;
 813               ( data_size(s) &lt;  min_size ||
 814                (data_size(s) == min_size &amp;&amp;
 815                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 816         max_ct = cmp_ct.at(j);
 817         max_vw = vw;
 818         max_idx = j;
 819         min_size = data_size(s);
 820         min_iv_offset = p.offset_in_bytes();
 821       }
 822     }
 823   }
 824   // If no stores, look at loads
 825   if (max_ct == 0) {
 826     for (uint j = 0; j &lt; memops.size(); j++) {
 827       MemNode* s = memops.at(j)-&gt;as_Mem();
 828       if (s-&gt;is_Load()) {
 829         int vw = vector_width_in_bytes(s);
 830         assert(vw &gt; 1, &quot;sanity&quot;);
 831         SWPointer p(s, this, NULL, false);
 832         if ( cmp_ct.at(j) &gt;  max_ct ||
 833             (cmp_ct.at(j) == max_ct &amp;&amp;
 834               ( vw &gt;  max_vw ||
 835                (vw == max_vw &amp;&amp;
 836                 ( data_size(s) &lt;  min_size ||
 837                  (data_size(s) == min_size &amp;&amp;
 838                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 839           max_ct = cmp_ct.at(j);
 840           max_vw = vw;
 841           max_idx = j;
 842           min_size = data_size(s);
 843           min_iv_offset = p.offset_in_bytes();
 844         }
 845       }
 846     }
 847   }
 848 
 849 #ifdef ASSERT
 850   if (TraceSuperWord &amp;&amp; Verbose) {
 851     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 852     for (uint i = 0; i &lt; memops.size(); i++) {
 853       MemNode* s = memops.at(i)-&gt;as_Mem();
 854       s-&gt;dump();
 855     }
 856   }
 857 #endif
 858 
 859   idx = max_idx;
 860   if (max_ct &gt; 0) {
 861 #ifdef ASSERT
 862     if (TraceSuperWord) {
 863       tty-&gt;print(&quot;\nVector align to node: &quot;);
 864       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 865     }
 866 #endif
 867     return memops.at(max_idx)-&gt;as_Mem();
 868   }
 869   return NULL;
 870 }
 871 
 872 //------------------span_works_for_memory_size-----------------------------
 873 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 874   bool span_matches_memory = false;
 875   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 876     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 877     // There is a mismatch on span size compared to memory.
 878     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 879       Node* use = mem-&gt;fast_out(j);
 880       if (!VectorNode::is_type_transition_to_int(use)) {
 881         return false;
 882       }
 883     }
 884     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 885     return true;
 886   }
 887   else {
 888     span_matches_memory = ABS(span) == mem_size;
 889   }
 890   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 891 }
 892 
 893 //------------------------------ref_is_alignable---------------------------
 894 // Can the preloop align the reference to position zero in the vector?
 895 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 896   if (!p.has_iv()) {
 897     return true;   // no induction variable
 898   }
 899   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 900   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 901   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 902   int preloop_stride = pre_end-&gt;stride_con();
 903 
 904   int span = preloop_stride * p.scale_in_bytes();
 905   int mem_size = p.memory_size();
 906   int offset   = p.offset_in_bytes();
 907   // Stride one accesses are alignable if offset is aligned to memory operation size.
 908   // Offset can be unaligned when UseUnalignedAccesses is used.
 909   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 910     return true;
 911   }
 912   // If the initial offset from start of the object is computable,
 913   // check if the pre-loop can align the final offset accordingly.
 914   //
 915   // In other words: Can we find an i such that the offset
 916   // after i pre-loop iterations is aligned to vw?
 917   //   (init_offset + pre_loop) % vw == 0              (1)
 918   // where
 919   //   pre_loop = i * span
 920   // is the number of bytes added to the offset by i pre-loop iterations.
 921   //
 922   // For this to hold we need pre_loop to increase init_offset by
 923   //   pre_loop = vw - (init_offset % vw)
 924   //
 925   // This is only possible if pre_loop is divisible by span because each
 926   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 927   //   (vw - (init_offset % vw)) % span == 0
 928   //
 929   int vw = vector_width_in_bytes(p.mem());
 930   assert(vw &gt; 1, &quot;sanity&quot;);
 931   Node* init_nd = pre_end-&gt;init_trip();
 932   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 933     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 934     int init_offset = init * p.scale_in_bytes() + offset;
 935     if (init_offset &lt; 0) { // negative offset from object start?
 936       return false;        // may happen in dead loop
 937     }
 938     if (vw % span == 0) {
 939       // If vm is a multiple of span, we use formula (1).
 940       if (span &gt; 0) {
 941         return (vw - (init_offset % vw)) % span == 0;
 942       } else {
 943         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 944         return (init_offset % vw) % -span == 0;
 945       }
 946     } else if (span % vw == 0) {
 947       // If span is a multiple of vw, we can simplify formula (1) to:
 948       //   (init_offset + i * span) % vw == 0
 949       //     =&gt;
 950       //   (init_offset % vw) + ((i * span) % vw) == 0
 951       //     =&gt;
 952       //   init_offset % vw == 0
 953       //
 954       // Because we add a multiple of vw to the initial offset, the final
 955       // offset is a multiple of vw if and only if init_offset is a multiple.
 956       //
 957       return (init_offset % vw) == 0;
 958     }
 959   }
 960   return false;
 961 }
 962 //---------------------------get_vw_bytes_special------------------------
 963 int SuperWord::get_vw_bytes_special(MemNode* s) {
 964   // Get the vector width in bytes.
 965   int vw = vector_width_in_bytes(s);
 966 
 967   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 968   BasicType btype = velt_basic_type(s);
 969   if (type2aelembytes(btype) == 2) {
 970     bool should_combine_adjacent = true;
 971     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 972       Node* user = s-&gt;fast_out(i);
 973       if (!VectorNode::is_muladds2i(user)) {
 974         should_combine_adjacent = false;
 975       }
 976     }
 977     if (should_combine_adjacent) {
 978       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 979     }
 980   }
 981 
 982   return vw;
 983 }
 984 
 985 //---------------------------get_iv_adjustment---------------------------
 986 // Calculate loop&#39;s iv adjustment for this memory ops.
 987 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 988   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 989   int offset = align_to_ref_p.offset_in_bytes();
 990   int scale  = align_to_ref_p.scale_in_bytes();
 991   int elt_size = align_to_ref_p.memory_size();
 992   int vw       = get_vw_bytes_special(mem_ref);
 993   assert(vw &gt; 1, &quot;sanity&quot;);
 994   int iv_adjustment;
 995   if (scale != 0) {
 996     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 997     // At least one iteration is executed in pre-loop by default. As result
 998     // several iterations are needed to align memory operations in main-loop even
 999     // if offset is 0.
1000     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
1001     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),
1002            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1003     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1004   } else {
1005     // This memory op is not dependent on iv (scale == 0)
1006     iv_adjustment = 0;
1007   }
1008 
1009 #ifndef PRODUCT
1010   if (TraceSuperWord) {
1011     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1012       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1013     mem_ref-&gt;dump();
1014   }
1015 #endif
1016   return iv_adjustment;
1017 }
1018 
1019 //---------------------------dependence_graph---------------------------
1020 // Construct dependency graph.
1021 // Add dependence edges to load/store nodes for memory dependence
1022 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1023 void SuperWord::dependence_graph() {
1024   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1025   // First, assign a dependence node to each memory node
1026   for (int i = 0; i &lt; _block.length(); i++ ) {
1027     Node *n = _block.at(i);
1028     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1029       _dg.make_node(n);
1030     }
1031   }
1032 
1033   // For each memory slice, create the dependences
1034   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1035     Node* n      = _mem_slice_head.at(i);
1036     Node* n_tail = _mem_slice_tail.at(i);
1037 
1038     // Get slice in predecessor order (last is first)
1039     if (cl-&gt;is_main_loop()) {
1040       mem_slice_preds(n_tail, n, _nlist);
1041     }
1042 
1043 #ifndef PRODUCT
1044     if(TraceSuperWord &amp;&amp; Verbose) {
1045       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1046       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1047         _nlist.at(j)-&gt;dump();
1048       }
1049     }
1050 #endif
1051     // Make the slice dependent on the root
1052     DepMem* slice = _dg.dep(n);
1053     _dg.make_edge(_dg.root(), slice);
1054 
1055     // Create a sink for the slice
1056     DepMem* slice_sink = _dg.make_node(NULL);
1057     _dg.make_edge(slice_sink, _dg.tail());
1058 
1059     // Now visit each pair of memory ops, creating the edges
1060     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1061       Node* s1 = _nlist.at(j);
1062 
1063       // If no dependency yet, use slice
1064       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1065         _dg.make_edge(slice, s1);
1066       }
1067       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1068       bool sink_dependent = true;
1069       for (int k = j - 1; k &gt;= 0; k--) {
1070         Node* s2 = _nlist.at(k);
1071         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1072           continue;
1073         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1074 
1075         int cmp = p1.cmp(p2);
1076         if (SuperWordRTDepCheck &amp;&amp;
1077             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1078           // Create a runtime check to disambiguate
1079           OrderedPair pp(p1.base(), p2.base());
1080           _disjoint_ptrs.append_if_missing(pp);
1081         } else if (!SWPointer::not_equal(cmp)) {
1082           // Possibly same address
1083           _dg.make_edge(s1, s2);
1084           sink_dependent = false;
1085         }
1086       }
1087       if (sink_dependent) {
1088         _dg.make_edge(s1, slice_sink);
1089       }
1090     }
1091 
1092     if (TraceSuperWord) {
1093       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1094       for (int q = 0; q &lt; _nlist.length(); q++) {
1095         _dg.print(_nlist.at(q));
1096       }
1097       tty-&gt;cr();
1098     }
1099 
1100     _nlist.clear();
1101   }
1102 
1103   if (TraceSuperWord) {
1104     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1105     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1106       _disjoint_ptrs.at(r).print();
1107       tty-&gt;cr();
1108     }
1109     tty-&gt;cr();
1110   }
1111 
1112 }
1113 
1114 //---------------------------mem_slice_preds---------------------------
1115 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1116 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1117   assert(preds.length() == 0, &quot;start empty&quot;);
1118   Node* n = start;
1119   Node* prev = NULL;
1120   while (true) {
1121     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1122     assert(in_bb(n), &quot;must be in block&quot;);
1123     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1124       Node* out = n-&gt;fast_out(i);
1125       if (out-&gt;is_Load()) {
1126         if (in_bb(out)) {
1127           preds.push(out);
1128           if (TraceSuperWord &amp;&amp; Verbose) {
1129             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1130           }
1131         }
1132       } else {
1133         // FIXME
1134         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1135           // Either unrolling is causing a memory edge not to disappear,
1136           // or need to run igvn.optimize() again before SLP
1137         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1138           // Ditto.  Not sure what else to check further.
1139         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1140           // StoreCM has an input edge used as a precedence edge.
1141           // Maybe an issue when oop stores are vectorized.
1142         } else {
1143           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1144         }
1145       }//else
1146     }//for
1147     if (n == stop) break;
1148     preds.push(n);
1149     if (TraceSuperWord &amp;&amp; Verbose) {
1150       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1151     }
1152     prev = n;
1153     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1154     n = n-&gt;in(MemNode::Memory);
1155   }
1156 }
1157 
1158 //------------------------------stmts_can_pack---------------------------
1159 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1160 // s1 aligned at &quot;align&quot;
1161 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1162 
1163   // Do not use superword for non-primitives
1164   BasicType bt1 = velt_basic_type(s1);
1165   BasicType bt2 = velt_basic_type(s2);
1166   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1167     return false;
1168   if (Matcher::max_vector_size(bt1) &lt; 2) {
1169     return false; // No vectors for this type
1170   }
1171 
1172   if (isomorphic(s1, s2)) {
1173     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1174       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1175         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1176           int s1_align = alignment(s1);
1177           int s2_align = alignment(s2);
1178           if (s1_align == top_align || s1_align == align) {
1179             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1180               return true;
1181             }
1182           }
1183         }
1184       }
1185     }
1186   }
1187   return false;
1188 }
1189 
1190 //------------------------------exists_at---------------------------
1191 // Does s exist in a pack at position pos?
1192 bool SuperWord::exists_at(Node* s, uint pos) {
1193   for (int i = 0; i &lt; _packset.length(); i++) {
1194     Node_List* p = _packset.at(i);
1195     if (p-&gt;at(pos) == s) {
1196       return true;
1197     }
1198   }
1199   return false;
1200 }
1201 
1202 //------------------------------are_adjacent_refs---------------------------
1203 // Is s1 immediately before s2 in memory?
1204 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1205   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1206   if (!in_bb(s1)    || !in_bb(s2))    return false;
1207 
1208   // Do not use superword for non-primitives
1209   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1210       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1211     return false;
1212   }
1213 
1214   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1215   // only pack memops that are in the same alias set until that&#39;s fixed.
1216   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1217       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1218     return false;
1219   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1220   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1221   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1222   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1223   return diff == data_size(s1);
1224 }
1225 
1226 //------------------------------isomorphic---------------------------
1227 // Are s1 and s2 similar?
1228 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1229   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1230   if (s1-&gt;req() != s2-&gt;req()) return false;
1231   if (!same_velt_type(s1, s2)) return false;
1232   Node* s1_ctrl = s1-&gt;in(0);
1233   Node* s2_ctrl = s2-&gt;in(0);
1234   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1235   if (s1_ctrl == s2_ctrl) {
1236     return true;
1237   } else {
1238     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1239     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1240     // If the control nodes are not invariant for the loop, fail isomorphism test.
1241     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1242       return false;
1243     }
1244     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1245       if (s1_ctrl-&gt;is_Proj()) {
1246         s1_ctrl = s1_ctrl-&gt;in(0);
1247         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1248       }
1249       if (s2_ctrl-&gt;is_Proj()) {
1250         s2_ctrl = s2_ctrl-&gt;in(0);
1251         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1252       }
1253       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1254         return false;
1255       }
1256     }
1257     // Control nodes are invariant. However, we have no way of checking whether they resolve
1258     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1259     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1260     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1261     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1262       Node* t1 = s1-&gt;fast_out(i);
1263       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1264         Node* t2 = s2-&gt;fast_out(j);
1265         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1266           return true;
1267         }
1268       }
1269     }
1270   }
1271   return false;
1272 }
1273 
1274 //------------------------------independent---------------------------
1275 // Is there no data path from s1 to s2 or s2 to s1?
1276 bool SuperWord::independent(Node* s1, Node* s2) {
1277   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1278   int d1 = depth(s1);
1279   int d2 = depth(s2);
1280   if (d1 == d2) return s1 != s2;
1281   Node* deep    = d1 &gt; d2 ? s1 : s2;
1282   Node* shallow = d1 &gt; d2 ? s2 : s1;
1283 
1284   visited_clear();
1285 
1286   return independent_path(shallow, deep);
1287 }
1288 
1289 //--------------------------have_similar_inputs-----------------------
1290 // For a node pair (s1, s2) which is isomorphic and independent,
1291 // do s1 and s2 have similar input edges?
1292 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1293   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1294   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1295   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1296     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1297       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1298     }
1299   }
1300   return true;
1301 }
1302 
1303 //------------------------------reduction---------------------------
1304 // Is there a data path between s1 and s2 and the nodes reductions?
1305 bool SuperWord::reduction(Node* s1, Node* s2) {
1306   bool retValue = false;
1307   int d1 = depth(s1);
1308   int d2 = depth(s2);
1309   if (d1 + 1 == d2) {
1310     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1311       // This is an ordered set, so s1 should define s2
1312       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1313         Node* t1 = s1-&gt;fast_out(i);
1314         if (t1 == s2) {
1315           // both nodes are reductions and connected
1316           retValue = true;
1317         }
1318       }
1319     }
1320   }
1321 
1322   return retValue;
1323 }
1324 
1325 //------------------------------independent_path------------------------------
1326 // Helper for independent
1327 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1328   if (dp &gt;= 1000) return false; // stop deep recursion
1329   visited_set(deep);
1330   int shal_depth = depth(shallow);
1331   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1332   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1333     Node* pred = preds.current();
1334     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1335       if (shallow == pred) {
1336         return false;
1337       }
1338       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1339         return false;
1340       }
1341     }
1342   }
1343   return true;
1344 }
1345 
1346 //------------------------------set_alignment---------------------------
1347 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1348   set_alignment(s1, align);
1349   if (align == top_align || align == bottom_align) {
1350     set_alignment(s2, align);
1351   } else {
1352     set_alignment(s2, align + data_size(s1));
1353   }
1354 }
1355 
1356 //------------------------------data_size---------------------------
1357 int SuperWord::data_size(Node* s) {
1358   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1359   if (UseVectorCmov) {
1360     use = _cmovev_kit.is_Bool_candidate(s);
1361     if (use != NULL) {
1362       return data_size(use);
1363     }
1364     use = _cmovev_kit.is_CmpD_candidate(s);
1365     if (use != NULL) {
1366       return data_size(use);
1367     }
1368   }
1369 
1370   int bsize = type2aelembytes(velt_basic_type(s));
1371   assert(bsize != 0, &quot;valid size&quot;);
1372   return bsize;
1373 }
1374 
1375 //------------------------------extend_packlist---------------------------
1376 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1377 void SuperWord::extend_packlist() {
1378   bool changed;
1379   do {
1380     packset_sort(_packset.length());
1381     changed = false;
1382     for (int i = 0; i &lt; _packset.length(); i++) {
1383       Node_List* p = _packset.at(i);
1384       changed |= follow_use_defs(p);
1385       changed |= follow_def_uses(p);
1386     }
1387   } while (changed);
1388 
1389   if (_race_possible) {
1390     for (int i = 0; i &lt; _packset.length(); i++) {
1391       Node_List* p = _packset.at(i);
1392       order_def_uses(p);
1393     }
1394   }
1395 
1396   if (TraceSuperWord) {
1397     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1398     print_packset();
1399   }
1400 }
1401 
1402 //------------------------------follow_use_defs---------------------------
1403 // Extend the packset by visiting operand definitions of nodes in pack p
1404 bool SuperWord::follow_use_defs(Node_List* p) {
1405   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1406   Node* s1 = p-&gt;at(0);
1407   Node* s2 = p-&gt;at(1);
1408   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1409   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1410 
1411   if (s1-&gt;is_Load()) return false;
1412 
1413   int align = alignment(s1);
1414   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1415   bool changed = false;
1416   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1417   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1418   for (int j = start; j &lt; end; j++) {
1419     Node* t1 = s1-&gt;in(j);
1420     Node* t2 = s2-&gt;in(j);
1421     if (!in_bb(t1) || !in_bb(t2))
1422       continue;
1423     if (stmts_can_pack(t1, t2, align)) {
1424       if (est_savings(t1, t2) &gt;= 0) {
1425         Node_List* pair = new Node_List();
1426         pair-&gt;push(t1);
1427         pair-&gt;push(t2);
1428         _packset.append(pair);
1429         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1430         set_alignment(t1, t2, align);
1431         changed = true;
1432       }
1433     }
1434   }
1435   return changed;
1436 }
1437 
1438 //------------------------------follow_def_uses---------------------------
1439 // Extend the packset by visiting uses of nodes in pack p
1440 bool SuperWord::follow_def_uses(Node_List* p) {
1441   bool changed = false;
1442   Node* s1 = p-&gt;at(0);
1443   Node* s2 = p-&gt;at(1);
1444   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1445   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1446   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1447 
1448   if (s1-&gt;is_Store()) return false;
1449 
1450   int align = alignment(s1);
1451   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1452   int savings = -1;
1453   int num_s1_uses = 0;
1454   Node* u1 = NULL;
1455   Node* u2 = NULL;
1456   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1457     Node* t1 = s1-&gt;fast_out(i);
1458     num_s1_uses++;
1459     if (!in_bb(t1)) continue;
1460     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1461       Node* t2 = s2-&gt;fast_out(j);
1462       if (!in_bb(t2)) continue;
1463       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1464       if (!opnd_positions_match(s1, t1, s2, t2))
1465         continue;
1466       if (stmts_can_pack(t1, t2, align)) {
1467         int my_savings = est_savings(t1, t2);
1468         if (my_savings &gt; savings) {
1469           savings = my_savings;
1470           u1 = t1;
1471           u2 = t2;
1472         }
1473       }
1474     }
1475   }
1476   if (num_s1_uses &gt; 1) {
1477     _race_possible = true;
1478   }
1479   if (savings &gt;= 0) {
1480     Node_List* pair = new Node_List();
1481     pair-&gt;push(u1);
1482     pair-&gt;push(u2);
1483     _packset.append(pair);
1484     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1485     set_alignment(u1, u2, align);
1486     changed = true;
1487   }
1488   return changed;
1489 }
1490 
1491 //------------------------------order_def_uses---------------------------
1492 // For extended packsets, ordinally arrange uses packset by major component
1493 void SuperWord::order_def_uses(Node_List* p) {
1494   Node* s1 = p-&gt;at(0);
1495 
1496   if (s1-&gt;is_Store()) return;
1497 
1498   // reductions are always managed beforehand
1499   if (s1-&gt;is_reduction()) return;
1500 
1501   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1502     Node* t1 = s1-&gt;fast_out(i);
1503 
1504     // Only allow operand swap on commuting operations
1505     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1506       break;
1507     }
1508 
1509     // Now find t1&#39;s packset
1510     Node_List* p2 = NULL;
1511     for (int j = 0; j &lt; _packset.length(); j++) {
1512       p2 = _packset.at(j);
1513       Node* first = p2-&gt;at(0);
1514       if (t1 == first) {
1515         break;
1516       }
1517       p2 = NULL;
1518     }
1519     // Arrange all sub components by the major component
1520     if (p2 != NULL) {
1521       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1522         Node* d1 = p-&gt;at(j);
1523         Node* u1 = p2-&gt;at(j);
1524         opnd_positions_match(s1, t1, d1, u1);
1525       }
1526     }
1527   }
1528 }
1529 
1530 //---------------------------opnd_positions_match-------------------------
1531 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1532 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1533   // check reductions to see if they are marshalled to represent the reduction
1534   // operator in a specified opnd
1535   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1536     // ensure reductions have phis and reduction definitions feeding the 1st operand
1537     Node* first = u1-&gt;in(2);
1538     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1539       u1-&gt;swap_edges(1, 2);
1540     }
1541     // ensure reductions have phis and reduction definitions feeding the 1st operand
1542     first = u2-&gt;in(2);
1543     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1544       u2-&gt;swap_edges(1, 2);
1545     }
1546     return true;
1547   }
1548 
1549   uint ct = u1-&gt;req();
1550   if (ct != u2-&gt;req()) return false;
1551   uint i1 = 0;
1552   uint i2 = 0;
1553   do {
1554     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1555     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1556     if (i1 != i2) {
1557       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1558         // Further analysis relies on operands position matching.
1559         u2-&gt;swap_edges(i1, i2);
1560       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1561         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1562           u2-&gt;swap_edges(1, 2);
1563           u2-&gt;swap_edges(3, 4);
1564         }
1565         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1566           u2-&gt;swap_edges(2, 3);
1567           u2-&gt;swap_edges(1, 4);
1568         }
1569         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1570       } else {
1571         return false;
1572       }
1573     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1574       u2-&gt;swap_edges(1, 3);
1575       u2-&gt;swap_edges(2, 4);
1576       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1577     }
1578   } while (i1 &lt; ct);
1579   return true;
1580 }
1581 
1582 //------------------------------est_savings---------------------------
1583 // Estimate the savings from executing s1 and s2 as a pack
1584 int SuperWord::est_savings(Node* s1, Node* s2) {
1585   int save_in = 2 - 1; // 2 operations per instruction in packed form
1586 
1587   // inputs
1588   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1589     Node* x1 = s1-&gt;in(i);
1590     Node* x2 = s2-&gt;in(i);
1591     if (x1 != x2) {
1592       if (are_adjacent_refs(x1, x2)) {
1593         save_in += adjacent_profit(x1, x2);
1594       } else if (!in_packset(x1, x2)) {
1595         save_in -= pack_cost(2);
1596       } else {
1597         save_in += unpack_cost(2);
1598       }
1599     }
1600   }
1601 
1602   // uses of result
1603   uint ct = 0;
1604   int save_use = 0;
1605   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1606     Node* s1_use = s1-&gt;fast_out(i);
1607     for (int j = 0; j &lt; _packset.length(); j++) {
1608       Node_List* p = _packset.at(j);
1609       if (p-&gt;at(0) == s1_use) {
1610         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1611           Node* s2_use = s2-&gt;fast_out(k);
1612           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1613             ct++;
1614             if (are_adjacent_refs(s1_use, s2_use)) {
1615               save_use += adjacent_profit(s1_use, s2_use);
1616             }
1617           }
1618         }
1619       }
1620     }
1621   }
1622 
1623   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1624   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1625 
1626   return MAX2(save_in, save_use);
1627 }
1628 
1629 //------------------------------costs---------------------------
1630 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1631 int SuperWord::pack_cost(int ct)   { return ct; }
1632 int SuperWord::unpack_cost(int ct) { return ct; }
1633 
1634 //------------------------------combine_packs---------------------------
1635 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1636 void SuperWord::combine_packs() {
1637   bool changed = true;
1638   // Combine packs regardless max vector size.
1639   while (changed) {
1640     changed = false;
1641     for (int i = 0; i &lt; _packset.length(); i++) {
1642       Node_List* p1 = _packset.at(i);
1643       if (p1 == NULL) continue;
1644       // Because of sorting we can start at i + 1
1645       for (int j = i + 1; j &lt; _packset.length(); j++) {
1646         Node_List* p2 = _packset.at(j);
1647         if (p2 == NULL) continue;
1648         if (i == j) continue;
1649         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1650           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1651             p1-&gt;push(p2-&gt;at(k));
1652           }
1653           _packset.at_put(j, NULL);
1654           changed = true;
1655         }
1656       }
1657     }
1658   }
1659 
1660   // Split packs which have size greater then max vector size.
1661   for (int i = 0; i &lt; _packset.length(); i++) {
1662     Node_List* p1 = _packset.at(i);
1663     if (p1 != NULL) {
1664       BasicType bt = velt_basic_type(p1-&gt;at(0));
1665       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1666       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1667       uint psize = p1-&gt;size();
1668       if (!is_power_of_2(psize)) {
1669         // Skip pack which can&#39;t be vector.
1670         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1671         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1672         _packset.at_put(i, NULL);
1673         continue;
1674       }
1675       if (psize &gt; max_vlen) {
1676         Node_List* pack = new Node_List();
1677         for (uint j = 0; j &lt; psize; j++) {
1678           pack-&gt;push(p1-&gt;at(j));
1679           if (pack-&gt;size() &gt;= max_vlen) {
1680             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1681             _packset.append(pack);
1682             pack = new Node_List();
1683           }
1684         }
1685         _packset.at_put(i, NULL);
1686       }
1687     }
1688   }
1689 
1690   // Compress list.
1691   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1692     Node_List* p1 = _packset.at(i);
1693     if (p1 == NULL) {
1694       _packset.remove_at(i);
1695     }
1696   }
1697 
1698   if (TraceSuperWord) {
1699     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1700     print_packset();
1701   }
1702 }
1703 
1704 //-----------------------------construct_my_pack_map--------------------------
1705 // Construct the map from nodes to packs.  Only valid after the
1706 // point where a node is only in one pack (after combine_packs).
1707 void SuperWord::construct_my_pack_map() {
1708   Node_List* rslt = NULL;
1709   for (int i = 0; i &lt; _packset.length(); i++) {
1710     Node_List* p = _packset.at(i);
1711     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1712       Node* s = p-&gt;at(j);
1713       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1714       set_my_pack(s, p);
1715     }
1716   }
1717 }
1718 
1719 //------------------------------filter_packs---------------------------
1720 // Remove packs that are not implemented or not profitable.
1721 void SuperWord::filter_packs() {
1722   // Remove packs that are not implemented
1723   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1724     Node_List* pk = _packset.at(i);
1725     bool impl = implemented(pk);
1726     if (!impl) {
1727 #ifndef PRODUCT
1728       if (TraceSuperWord &amp;&amp; Verbose) {
1729         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1730         pk-&gt;at(0)-&gt;dump();
1731       }
1732 #endif
1733       remove_pack_at(i);
1734     }
1735     Node *n = pk-&gt;at(0);
1736     if (n-&gt;is_reduction()) {
1737       _num_reductions++;
1738     } else {
1739       _num_work_vecs++;
1740     }
1741   }
1742 
1743   // Remove packs that are not profitable
1744   bool changed;
1745   do {
1746     changed = false;
1747     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1748       Node_List* pk = _packset.at(i);
1749       bool prof = profitable(pk);
1750       if (!prof) {
1751 #ifndef PRODUCT
1752         if (TraceSuperWord &amp;&amp; Verbose) {
1753           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1754           pk-&gt;at(0)-&gt;dump();
1755         }
1756 #endif
1757         remove_pack_at(i);
1758         changed = true;
1759       }
1760     }
1761   } while (changed);
1762 
1763 #ifndef PRODUCT
1764   if (TraceSuperWord) {
1765     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1766     print_packset();
1767     tty-&gt;cr();
1768   }
1769 #endif
1770 }
1771 
1772 //------------------------------merge_packs_to_cmovd---------------------------
1773 // Merge CMoveD into new vector-nodes
1774 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1775 //
1776 //                   SubD             ConD
1777 //                  /  |               /
1778 //                 /   |           /   /
1779 //                /    |       /      /
1780 //               /     |   /         /
1781 //              /      /            /
1782 //             /    /  |           /
1783 //            v /      |          /
1784 //         CmpD        |         /
1785 //          |          |        /
1786 //          v          |       /
1787 //         Bool        |      /
1788 //           \         |     /
1789 //             \       |    /
1790 //               \     |   /
1791 //                 \   |  /
1792 //                   \ v /
1793 //                   CMoveD
1794 //
1795 
1796 void SuperWord::merge_packs_to_cmovd() {
1797   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1798     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1799   }
1800   #ifndef PRODUCT
1801     if (TraceSuperWord) {
1802       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1803       print_packset();
1804       tty-&gt;cr();
1805     }
1806   #endif
1807 }
1808 
1809 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1810   Node* use = NULL;
1811   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1812     return NULL;
1813   }
1814   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1815     use = def-&gt;fast_out(j);
1816     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1817       return NULL;
1818     }
1819   }
1820   return use;
1821 }
1822 
1823 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1824   Node* use = NULL;
1825   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1826     return NULL;
1827   }
1828   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1829     use = def-&gt;fast_out(j);
1830     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1831       return NULL;
1832     }
1833   }
1834   return use;
1835 }
1836 
1837 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1838   Node *cmovd = cmovd_pk-&gt;at(0);
1839   if (!cmovd-&gt;is_CMove()) {
1840     return NULL;
1841   }
1842   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1843     return NULL;
1844   }
1845   if (pack(cmovd) != NULL) { // already in the cmov pack
1846     return NULL;
1847   }
1848   if (cmovd-&gt;in(0) != NULL) {
1849     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1850     return NULL;
1851   }
1852 
1853   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1854   if (!bol-&gt;is_Bool()
1855       || bol-&gt;outcnt() != 1
1856       || !_sw-&gt;same_generation(bol, cmovd)
1857       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1858       || _sw-&gt;my_pack(bol) == NULL) {
1859       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1860       return NULL;
1861   }
1862   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1863   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1864     return NULL;
1865   }
1866 
1867   Node* cmpd = bol-&gt;in(1);
1868   if (!cmpd-&gt;is_Cmp()
1869       || cmpd-&gt;outcnt() != 1
1870       || !_sw-&gt;same_generation(cmpd, cmovd)
1871       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1872       || _sw-&gt;my_pack(cmpd) == NULL) {
1873       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1874       return NULL;
1875   }
1876   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1877   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1878     return NULL;
1879   }
1880 
1881   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1882     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1883     return NULL;
1884   }
1885 
1886   Node_List* new_cmpd_pk = new Node_List();
1887   uint sz = cmovd_pk-&gt;size() - 1;
1888   for (uint i = 0; i &lt;= sz; ++i) {
1889     Node* cmov = cmovd_pk-&gt;at(i);
1890     Node* bol  = bool_pk-&gt;at(i);
1891     Node* cmp  = cmpd_pk-&gt;at(i);
1892 
1893     new_cmpd_pk-&gt;insert(i, cmov);
1894 
1895     map(cmov, new_cmpd_pk);
1896     map(bol, new_cmpd_pk);
1897     map(cmp, new_cmpd_pk);
1898 
1899     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1900   }
1901   _sw-&gt;_packset.remove(cmovd_pk);
1902   _sw-&gt;_packset.remove(bool_pk);
1903   _sw-&gt;_packset.remove(cmpd_pk);
1904   _sw-&gt;_packset.append(new_cmpd_pk);
1905   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1906   return new_cmpd_pk;
1907 }
1908 
1909 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1910   Node* cmpd0 = cmpd_pk-&gt;at(0);
1911   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1912   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1913   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1914   Node* in1 = cmpd0-&gt;in(1);
1915   Node* in2 = cmpd0-&gt;in(2);
1916   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1917   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1918 
1919   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1920      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1921     return false;
1922   }
1923 
1924   // test if &quot;all&quot; in1 are in the same pack or the same node
1925   if (in1_pk == NULL) {
1926     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1927       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1928         return false;
1929       }
1930     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1931   }
1932   // test if &quot;all&quot; in2 are in the same pack or the same node
1933   if (in2_pk == NULL) {
1934     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1935       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1936         return false;
1937       }
1938     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1939   }
1940   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1941   int cmovd_ind1, cmovd_ind2;
1942   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1943    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1944       cmovd_ind1 = CMoveNode::IfFalse;
1945       cmovd_ind2 = CMoveNode::IfTrue;
1946   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1947           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1948       cmovd_ind2 = CMoveNode::IfFalse;
1949       cmovd_ind1 = CMoveNode::IfTrue;
1950   }
1951   else {
1952     return false;
1953   }
1954 
1955   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1956     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1957         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1958         return false;
1959     }//if
1960   }
1961   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1962   return true;
1963 }
1964 
1965 //------------------------------implemented---------------------------
1966 // Can code be generated for pack p?
1967 bool SuperWord::implemented(Node_List* p) {
1968   bool retValue = false;
1969   Node* p0 = p-&gt;at(0);
1970   if (p0 != NULL) {
1971     int opc = p0-&gt;Opcode();
1972     uint size = p-&gt;size();
1973     if (p0-&gt;is_reduction()) {
1974       const Type *arith_type = p0-&gt;bottom_type();
1975       // Length 2 reductions of INT/LONG do not offer performance benefits
1976       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1977         retValue = false;
1978       } else {
1979         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1980       }
1981     } else {
1982       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1983     }
1984     if (!retValue) {
1985       if (is_cmov_pack(p)) {
1986         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1987         return true;
1988       }
1989     }
1990   }
1991   return retValue;
1992 }
1993 
1994 bool SuperWord::is_cmov_pack(Node_List* p) {
1995   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1996 }
1997 //------------------------------same_inputs--------------------------
1998 // For pack p, are all idx operands the same?
1999 bool SuperWord::same_inputs(Node_List* p, int idx) {
2000   Node* p0 = p-&gt;at(0);
2001   uint vlen = p-&gt;size();
2002   Node* p0_def = p0-&gt;in(idx);
2003   for (uint i = 1; i &lt; vlen; i++) {
2004     Node* pi = p-&gt;at(i);
2005     Node* pi_def = pi-&gt;in(idx);
2006     if (p0_def != pi_def) {
2007       return false;
2008     }
2009   }
2010   return true;
2011 }
2012 
2013 //------------------------------profitable---------------------------
2014 // For pack p, are all operands and all uses (with in the block) vector?
2015 bool SuperWord::profitable(Node_List* p) {
2016   Node* p0 = p-&gt;at(0);
2017   uint start, end;
2018   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2019 
2020   // Return false if some inputs are not vectors or vectors with different
2021   // size or alignment.
2022   // Also, for now, return false if not scalar promotion case when inputs are
2023   // the same. Later, implement PackNode and allow differing, non-vector inputs
2024   // (maybe just the ones from outside the block.)
2025   for (uint i = start; i &lt; end; i++) {
2026     if (!is_vector_use(p0, i)) {
2027       return false;
2028     }
2029   }
2030   // Check if reductions are connected
2031   if (p0-&gt;is_reduction()) {
2032     Node* second_in = p0-&gt;in(2);
2033     Node_List* second_pk = my_pack(second_in);
2034     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2035       // Remove reduction flag if no parent pack or if not enough work
2036       // to cover reduction expansion overhead
2037       p0-&gt;remove_flag(Node::Flag_is_reduction);
2038       return false;
2039     } else if (second_pk-&gt;size() != p-&gt;size()) {
2040       return false;
2041     }
2042   }
2043   if (VectorNode::is_shift(p0)) {
2044     // For now, return false if shift count is vector or not scalar promotion
2045     // case (different shift counts) because it is not supported yet.
2046     Node* cnt = p0-&gt;in(2);
2047     Node_List* cnt_pk = my_pack(cnt);
2048     if (cnt_pk != NULL)
2049       return false;
2050     if (!same_inputs(p, 2))
2051       return false;
2052   }
2053   if (!p0-&gt;is_Store()) {
2054     // For now, return false if not all uses are vector.
2055     // Later, implement ExtractNode and allow non-vector uses (maybe
2056     // just the ones outside the block.)
2057     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2058       Node* def = p-&gt;at(i);
2059       if (is_cmov_pack_internal_node(p, def)) {
2060         continue;
2061       }
2062       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2063         Node* use = def-&gt;fast_out(j);
2064         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2065           Node* n = use-&gt;in(k);
2066           if (def == n) {
2067             // Reductions should only have a Phi use at the loop head or a non-phi use
2068             // outside of the loop if it is the last element of the pack (e.g. SafePoint).
2069             if (def-&gt;is_reduction() &amp;&amp;
2070                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
2071                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {
2072               continue;
2073             }
2074             if (!is_vector_use(use, k)) {
2075               return false;
2076             }
2077           }
2078         }
2079       }
2080     }
2081   }
2082   return true;
2083 }
2084 
2085 //------------------------------schedule---------------------------
2086 // Adjust the memory graph for the packed operations
2087 void SuperWord::schedule() {
2088 
2089   // Co-locate in the memory graph the members of each memory pack
2090   for (int i = 0; i &lt; _packset.length(); i++) {
2091     co_locate_pack(_packset.at(i));
2092   }
2093 }
2094 
2095 //-------------------------------remove_and_insert-------------------
2096 // Remove &quot;current&quot; from its current position in the memory graph and insert
2097 // it after the appropriate insertion point (lip or uip).
2098 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2099                                   Node *uip, Unique_Node_List &amp;sched_before) {
2100   Node* my_mem = current-&gt;in(MemNode::Memory);
2101   bool sched_up = sched_before.member(current);
2102 
2103   // remove current_store from its current position in the memmory graph
2104   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2105     Node* use = current-&gt;out(i);
2106     if (use-&gt;is_Mem()) {
2107       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2108       if (use == prev) { // connect prev to my_mem
2109           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2110           --i; //deleted this edge; rescan position
2111       } else if (sched_before.member(use)) {
2112         if (!sched_up) { // Will be moved together with current
2113           _igvn.replace_input_of(use, MemNode::Memory, uip);
2114           --i; //deleted this edge; rescan position
2115         }
2116       } else {
2117         if (sched_up) { // Will be moved together with current
2118           _igvn.replace_input_of(use, MemNode::Memory, lip);
2119           --i; //deleted this edge; rescan position
2120         }
2121       }
2122     }
2123   }
2124 
2125   Node *insert_pt =  sched_up ?  uip : lip;
2126 
2127   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2128   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2129     Node* use = insert_pt-&gt;out(i);
2130     if (use-&gt;is_Mem()) {
2131       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2132       _igvn.replace_input_of(use, MemNode::Memory, current);
2133       --i; //deleted this edge; rescan position
2134     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2135       uint pos; //lip (lower insert point) must be the last one in the memory slice
2136       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2137         if (use-&gt;in(pos) == insert_pt) break;
2138       }
2139       _igvn.replace_input_of(use, pos, current);
2140       --i;
2141     }
2142   }
2143 
2144   //connect current to insert_pt
2145   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2146 }
2147 
2148 //------------------------------co_locate_pack----------------------------------
2149 // To schedule a store pack, we need to move any sandwiched memory ops either before
2150 // or after the pack, based upon dependence information:
2151 // (1) If any store in the pack depends on the sandwiched memory op, the
2152 //     sandwiched memory op must be scheduled BEFORE the pack;
2153 // (2) If a sandwiched memory op depends on any store in the pack, the
2154 //     sandwiched memory op must be scheduled AFTER the pack;
2155 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2156 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2157 //     scheduled before the pack, memB must also be scheduled before the pack;
2158 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2159 //     schedule this store AFTER the pack
2160 // (5) We know there is no dependence cycle, so there in no other case;
2161 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2162 //
2163 // To schedule a load pack, we use the memory state of either the first or the last load in
2164 // the pack, based on the dependence constraint.
2165 void SuperWord::co_locate_pack(Node_List* pk) {
2166   if (pk-&gt;at(0)-&gt;is_Store()) {
2167     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2168     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2169     Unique_Node_List schedule_before_pack;
2170     Unique_Node_List memops;
2171 
2172     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2173     MemNode* previous  = last;
2174     while (true) {
2175       assert(in_bb(current), &quot;stay in block&quot;);
2176       memops.push(previous);
2177       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2178         Node* use = current-&gt;out(i);
2179         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2180           memops.push(use);
2181       }
2182       if (current == first) break;
2183       previous = current;
2184       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2185     }
2186 
2187     // determine which memory operations should be scheduled before the pack
2188     for (uint i = 1; i &lt; memops.size(); i++) {
2189       Node *s1 = memops.at(i);
2190       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2191         for (uint j = 0; j&lt; i; j++) {
2192           Node *s2 = memops.at(j);
2193           if (!independent(s1, s2)) {
2194             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2195               schedule_before_pack.push(s1); // s1 must be scheduled before
2196               Node_List* mem_pk = my_pack(s1);
2197               if (mem_pk != NULL) {
2198                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2199                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2200                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2201                     schedule_before_pack.push(s);
2202                 }
2203               }
2204               break;
2205             }
2206           }
2207         }
2208       }
2209     }
2210 
2211     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2212     // Following code moves loads connected to upper_insert_pt below aliased stores.
2213     // Collect such loads here and reconnect them back to upper_insert_pt later.
2214     memops.clear();
2215     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2216       Node* use = upper_insert_pt-&gt;out(i);
2217       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2218         memops.push(use);
2219       }
2220     }
2221 
2222     MemNode* lower_insert_pt = last;
2223     previous                 = last; //previous store in pk
2224     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2225 
2226     // start scheduling from &quot;last&quot; to &quot;first&quot;
2227     while (true) {
2228       assert(in_bb(current), &quot;stay in block&quot;);
2229       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2230       Node* my_mem = current-&gt;in(MemNode::Memory);
2231 
2232       if (in_pack(current, pk)) {
2233         // Forward users of my memory state (except &quot;previous) to my input memory state
2234         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2235           Node* use = current-&gt;out(i);
2236           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2237             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2238             if (schedule_before_pack.member(use)) {
2239               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2240             } else {
2241               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2242             }
2243             --i; // deleted this edge; rescan position
2244           }
2245         }
2246         previous = current;
2247       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2248         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2249       }
2250 
2251       if (current == first) break;
2252       current = my_mem-&gt;as_Mem();
2253     } // end while
2254 
2255     // Reconnect loads back to upper_insert_pt.
2256     for (uint i = 0; i &lt; memops.size(); i++) {
2257       Node *ld = memops.at(i);
2258       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2259         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2260       }
2261     }
2262   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
2263     // all loads in the pack should have the same memory state. By default,
2264     // we use the memory state of the last load. However, if any load could
2265     // not be moved down due to the dependence constraint, we use the memory
2266     // state of the first load.
2267     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2268     Node* first_mem = last_mem;
2269     // Walk the memory graph from the current first load until the
2270     // start of the loop and check if nodes on the way are memory
2271     // edges of loads in the pack. The last one we encounter is the
2272     // first load.
2273     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {
2274      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);
2275      for (uint i = 1; i &lt; pk-&gt;size(); i++) {
2276         Node* ld = pk-&gt;at(i);
2277         if (ld-&gt;in(MemNode::Memory) == current) {
2278           first_mem = current;
2279           break;
2280         }
2281       }
2282     }
2283     // Find the last load by going over the pack again and walking
2284     // the memory graph from the loads of the pack to the memory of
2285     // the first load. If we encounter the memory of the current last
2286     // load, then we started from further down in the memory graph and
2287     // the load we started from is the last load. Check for dependence
2288     // constraints in that loop as well.
2289     bool schedule_last = true;
2290     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2291       Node* ld = pk-&gt;at(i);
2292       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {
2293         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2294         if (current-&gt;in(MemNode::Memory) == last_mem) {
2295           last_mem = ld-&gt;in(MemNode::Memory);
2296         }
2297         if (!independent(current, ld)) {
2298           schedule_last = false; // a later store depends on this load
2299         }
2300       }
2301     }
2302 
2303     Node* mem_input = schedule_last ? last_mem : first_mem;
2304     _igvn.hash_delete(mem_input);
2305     // Give each load the same memory state
2306     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2307       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2308       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2309     }
2310   }
2311 }
2312 
2313 #ifndef PRODUCT
2314 void SuperWord::print_loop(bool whole) {
2315   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2316   Node_List rpo_list;
2317   VectorSet visited(_arena);
2318   visited.set(lpt()-&gt;_head-&gt;_idx);
2319   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2320   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2321   if(whole) {
2322     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2323     _phase-&gt;dump();
2324     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2325   }
2326 }
2327 #endif
2328 
2329 //------------------------------output---------------------------
2330 // Convert packs into vector node operations
2331 void SuperWord::output() {
2332   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2333   Compile* C = _phase-&gt;C;
2334   if (_packset.length() == 0) {
2335     if (cl-&gt;is_main_loop()) {
2336       // Instigate more unrolling for optimization when vectorization fails.
2337       C-&gt;set_major_progress();
2338       cl-&gt;set_notpassed_slp();
2339       cl-&gt;mark_do_unroll_only();
2340     }
2341     return;
2342   }
2343 
2344 #ifndef PRODUCT
2345   if (TraceLoopOpts) {
2346     tty-&gt;print(&quot;SuperWord::output    &quot;);
2347     lpt()-&gt;dump_head();
2348   }
2349 #endif
2350 
2351   if (cl-&gt;is_main_loop()) {
2352     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2353     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2354 
2355     align_initial_loop_index(align_to_ref());
2356 
2357     // Insert extract (unpack) operations for scalar uses
2358     for (int i = 0; i &lt; _packset.length(); i++) {
2359       insert_extracts(_packset.at(i));
2360     }
2361   }
2362 
2363   uint max_vlen_in_bytes = 0;
2364   uint max_vlen = 0;
2365   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2366 
2367   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2368 
2369   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2370 
2371   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2372 
2373   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2374     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2375     return;
2376   }
2377 
2378   for (int i = 0; i &lt; _block.length(); i++) {
2379     Node* n = _block.at(i);
2380     Node_List* p = my_pack(n);
2381     if (p &amp;&amp; n == executed_last(p)) {
2382       uint vlen = p-&gt;size();
2383       uint vlen_in_bytes = 0;
2384       Node* vn = NULL;
2385       Node* low_adr = p-&gt;at(0);
2386       Node* first   = executed_first(p);
2387       if (can_process_post_loop) {
2388         // override vlen with the main loops vector length
2389         vlen = cl-&gt;slp_max_unroll();
2390       }
2391       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2392       int   opc = n-&gt;Opcode();
2393       if (n-&gt;is_Load()) {
2394         Node* ctl = n-&gt;in(MemNode::Control);
2395         Node* mem = first-&gt;in(MemNode::Memory);
2396         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2397         // Identify the memory dependency for the new loadVector node by
2398         // walking up through memory chain.
2399         // This is done to give flexibility to the new loadVector node so that
2400         // it can move above independent storeVector nodes.
2401         while (mem-&gt;is_StoreVector()) {
2402           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2403           int cmp = p1.cmp(p2);
2404           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2405             mem = mem-&gt;in(MemNode::Memory);
2406           } else {
2407             break; // dependent memory
2408           }
2409         }
2410         Node* adr = low_adr-&gt;in(MemNode::Address);
2411         const TypePtr* atyp = n-&gt;adr_type();
2412         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2413         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2414       } else if (n-&gt;is_Store()) {
2415         // Promote value to be stored to vector
2416         Node* val = vector_opd(p, MemNode::ValueIn);
2417         if (val == NULL) {
2418           if (do_reserve_copy()) {
2419             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2420             return; //and reverse to backup IG
2421           }
2422           ShouldNotReachHere();
2423         }
2424 
2425         Node* ctl = n-&gt;in(MemNode::Control);
2426         Node* mem = first-&gt;in(MemNode::Memory);
2427         Node* adr = low_adr-&gt;in(MemNode::Address);
2428         const TypePtr* atyp = n-&gt;adr_type();
2429         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2430         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
2431       } else if (VectorNode::is_roundopD(n)) {
2432         Node* in1 = vector_opd(p, 1);
2433         Node* in2 = low_adr-&gt;in(2);
2434         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);
2435         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2436         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2437       } else if (VectorNode::is_muladds2i(n)) {
2438         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2439         Node* in1 = vector_opd(p, 1);
2440         Node* in2 = vector_opd(p, 2);
2441         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2442         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2443       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2444         // Promote operands to vector
2445         Node* in1 = NULL;
2446         bool node_isa_reduction = n-&gt;is_reduction();
2447         if (node_isa_reduction) {
2448           // the input to the first reduction operation is retained
2449           in1 = low_adr-&gt;in(1);
2450         } else {
2451           in1 = vector_opd(p, 1);
2452           if (in1 == NULL) {
2453             if (do_reserve_copy()) {
2454               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2455               return; //and reverse to backup IG
2456             }
2457             ShouldNotReachHere();
2458           }
2459         }
2460         Node* in2 = vector_opd(p, 2);
2461         if (in2 == NULL) {
2462           if (do_reserve_copy()) {
2463             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2464             return; //and reverse to backup IG
2465           }
2466           ShouldNotReachHere();
2467         }
2468         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2469           // Move invariant vector input into second position to avoid register spilling.
2470           Node* tmp = in1;
2471           in1 = in2;
2472           in2 = tmp;
2473         }
2474         if (node_isa_reduction) {
2475           const Type *arith_type = n-&gt;bottom_type();
2476           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2477           if (in2-&gt;is_Load()) {
2478             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2479           } else {
2480             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2481           }
2482         } else {
2483           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2484           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2485         }
2486       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2487                  opc == Op_AbsF || opc == Op_AbsD ||
2488                  opc == Op_AbsI || opc == Op_AbsL ||
2489                  opc == Op_NegF || opc == Op_NegD ||
2490                  opc == Op_PopCountI) {
2491         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2492         Node* in = vector_opd(p, 1);
2493         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2494         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2495       } else if (is_cmov_pack(p)) {
2496         if (can_process_post_loop) {
2497           // do not refactor of flow in post loop context
2498           return;
2499         }
2500         if (!n-&gt;is_CMove()) {
2501           continue;
2502         }
2503         // place here CMoveVDNode
2504         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2505         Node* bol = n-&gt;in(CMoveNode::Condition);
2506         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2507           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2508           bol = bol-&gt;in(1); //may be ExtractNode
2509         }
2510 
2511         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2512         if (!bol-&gt;is_Bool()) {
2513           if (do_reserve_copy()) {
2514             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2515             return; //and reverse to backup IG
2516           }
2517           ShouldNotReachHere();
2518         }
2519 
2520         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2521         Node* in_cc  = _igvn.intcon(cond);
2522         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2523         Node* cc = bol-&gt;clone();
2524         cc-&gt;set_req(1, in_cc);
2525         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2526 
2527         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2528         if (src1 == NULL) {
2529           if (do_reserve_copy()) {
2530             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2531             return; //and reverse to backup IG
2532           }
2533           ShouldNotReachHere();
2534         }
2535         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2536         if (src2 == NULL) {
2537           if (do_reserve_copy()) {
2538             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2539             return; //and reverse to backup IG
2540           }
2541           ShouldNotReachHere();
2542         }
2543         BasicType bt = velt_basic_type(n);
2544         const TypeVect* vt = TypeVect::make(bt, vlen);
2545         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2546         if (bt == T_FLOAT) {
2547           vn = new CMoveVFNode(cc, src1, src2, vt);
2548         } else {
2549           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2550           vn = new CMoveVDNode(cc, src1, src2, vt);
2551         }
2552         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2553       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2554         // Promote operands to vector
2555         Node* in1 = vector_opd(p, 1);
2556         Node* in2 = vector_opd(p, 2);
2557         Node* in3 = vector_opd(p, 3);
2558         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2559         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2560       } else {
2561         if (do_reserve_copy()) {
2562           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2563           return; //and reverse to backup IG
2564         }
2565         ShouldNotReachHere();
2566       }
2567 
2568       assert(vn != NULL, &quot;sanity&quot;);
2569       if (vn == NULL) {
2570         if (do_reserve_copy()){
2571           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2572           return; //and reverse to backup IG
2573         }
2574         ShouldNotReachHere();
2575       }
2576 
2577       _block.at_put(i, vn);
2578       _igvn.register_new_node_with_optimizer(vn);
2579       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2580       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2581         Node* pm = p-&gt;at(j);
2582         _igvn.replace_node(pm, vn);
2583       }
2584       _igvn._worklist.push(vn);
2585 
2586       if (can_process_post_loop) {
2587         // first check if the vector size if the maximum vector which we can use on the machine,
2588         // other vector size have reduced values for predicated data mapping.
2589         if (vlen_in_bytes != (uint)MaxVectorSize) {
2590           return;
2591         }
2592       }
2593 
2594       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2595         max_vlen = vlen;
2596         max_vlen_in_bytes = vlen_in_bytes;
2597       }
2598 #ifdef ASSERT
2599       if (TraceNewVectors) {
2600         tty-&gt;print(&quot;new Vector node: &quot;);
2601         vn-&gt;dump();
2602       }
2603 #endif
2604     }
2605   }//for (int i = 0; i &lt; _block.length(); i++)
2606 
2607   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2608     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2609   }
2610   if (max_vlen_in_bytes &gt; 0) {
2611     cl-&gt;mark_loop_vectorized();
2612   }
2613 
2614   if (SuperWordLoopUnrollAnalysis) {
2615     if (cl-&gt;has_passed_slp()) {
2616       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2617       if (slp_max_unroll_factor == max_vlen) {
2618         if (TraceSuperWordLoopUnrollAnalysis) {
2619           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2620         }
2621 
2622         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2623         cl-&gt;set_notpassed_slp();
2624         if (cl-&gt;is_main_loop()) {
2625           // if vector resources are limited, do not allow additional unrolling, also
2626           // do not unroll more on pure vector loops which were not reduced so that we can
2627           // program the post loop to single iteration execution.
2628           if (FLOATPRESSURE &gt; 8) {
2629             C-&gt;set_major_progress();
2630             cl-&gt;mark_do_unroll_only();
2631           }
2632         }
2633 
2634         if (do_reserve_copy()) {
2635           if (can_process_post_loop) {
2636             // Now create the difference of trip and limit and use it as our mask index.
2637             // Note: We limited the unroll of the vectorized loop so that
2638             //       only vlen-1 size iterations can remain to be mask programmed.
2639             Node *incr = cl-&gt;incr();
2640             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2641             _igvn.register_new_node_with_optimizer(index);
2642             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2643             _igvn.register_new_node_with_optimizer(mask);
2644             // make this a single iteration loop
2645             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2646             _igvn.register_new_node_with_optimizer(new_incr);
2647             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2648             _igvn.replace_node(incr, new_incr);
2649             cl-&gt;mark_is_multiversioned();
2650             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2651           }
2652         }
2653       }
2654     }
2655   }
2656 
2657   if (do_reserve_copy()) {
2658     make_reversable.use_new();
2659   }
2660   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2661   return;
2662 }
2663 
2664 //------------------------------vector_opd---------------------------
2665 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2666 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2667   Node* p0 = p-&gt;at(0);
2668   uint vlen = p-&gt;size();
2669   Node* opd = p0-&gt;in(opd_idx);
2670   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2671 
2672   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2673     // override vlen with the main loops vector length
2674     vlen = cl-&gt;slp_max_unroll();
2675   }
2676 
2677   if (same_inputs(p, opd_idx)) {
2678     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2679       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2680       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2681         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2682         return NULL;
2683       }
2684       return opd; // input is matching vector
2685     }
2686     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2687       Compile* C = _phase-&gt;C;
2688       Node* cnt = opd;
2689       // Vector instructions do not mask shift count, do it here.
2690       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2691       const TypeInt* t = opd-&gt;find_int_type();
2692       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2693         juint shift = t-&gt;get_con();
2694         if (shift &gt; mask) { // Unsigned cmp
2695           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2696         }
2697       } else {
2698         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2699           cnt = ConNode::make(TypeInt::make(mask));
2700           _igvn.register_new_node_with_optimizer(cnt);
2701           cnt = new AndINode(opd, cnt);
2702           _igvn.register_new_node_with_optimizer(cnt);
2703           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2704         }
2705         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2706         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2707           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2708           return NULL;
2709         }
2710       }
2711       // Move shift count into vector register.
2712       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));
2713       _igvn.register_new_node_with_optimizer(cnt);
2714       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2715       return cnt;
2716     }
2717     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2718     if (opd-&gt;is_StoreVector()) {
2719       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2720       return NULL;
2721     }
2722     // Convert scalar input to vector with the same number of elements as
2723     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2724     // vector should match p0&#39;s size regardless operand&#39;s size.
2725     const Type* p0_t = velt_type(p0);
2726     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2727 
2728     _igvn.register_new_node_with_optimizer(vn);
2729     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2730 #ifdef ASSERT
2731     if (TraceNewVectors) {
2732       tty-&gt;print(&quot;new Vector node: &quot;);
2733       vn-&gt;dump();
2734     }
2735 #endif
2736     return vn;
2737   }
2738 
2739   // Insert pack operation
2740   BasicType bt = velt_basic_type(p0);
2741   PackNode* pk = PackNode::make(opd, vlen, bt);
2742   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2743 
2744   for (uint i = 1; i &lt; vlen; i++) {
2745     Node* pi = p-&gt;at(i);
2746     Node* in = pi-&gt;in(opd_idx);
2747     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2748     if (my_pack(in) != NULL) {
2749       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2750       return NULL;
2751     }
2752     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2753     pk-&gt;add_opd(in);
2754     if (VectorNode::is_muladds2i(pi)) {
2755       Node* in2 = pi-&gt;in(opd_idx + 2);
2756       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2757       if (my_pack(in2) != NULL) {
2758         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2759           return NULL;
2760       }
2761       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2762       pk-&gt;add_opd(in2);
2763     }
2764   }
2765   _igvn.register_new_node_with_optimizer(pk);
2766   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2767 #ifdef ASSERT
2768   if (TraceNewVectors) {
2769     tty-&gt;print(&quot;new Vector node: &quot;);
2770     pk-&gt;dump();
2771   }
2772 #endif
2773   return pk;
2774 }
2775 
2776 //------------------------------insert_extracts---------------------------
2777 // If a use of pack p is not a vector use, then replace the
2778 // use with an extract operation.
2779 void SuperWord::insert_extracts(Node_List* p) {
2780   if (p-&gt;at(0)-&gt;is_Store()) return;
2781   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2782 
2783   // Inspect each use of each pack member.  For each use that is
2784   // not a vector use, replace the use with an extract operation.
2785 
2786   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2787     Node* def = p-&gt;at(i);
2788     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2789       Node* use = def-&gt;fast_out(j);
2790       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2791         Node* n = use-&gt;in(k);
2792         if (def == n) {
2793           Node_List* u_pk = my_pack(use);
2794           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2795               _n_idx_list.push(use, k);
2796           }
2797         }
2798       }
2799     }
2800   }
2801 
2802   while (_n_idx_list.is_nonempty()) {
2803     Node* use = _n_idx_list.node();
2804     int   idx = _n_idx_list.index();
2805     _n_idx_list.pop();
2806     Node* def = use-&gt;in(idx);
2807 
2808     if (def-&gt;is_reduction()) continue;
2809 
2810     // Insert extract operation
2811     _igvn.hash_delete(def);
2812     int def_pos = alignment(def) / data_size(def);
2813 
2814     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2815     _igvn.register_new_node_with_optimizer(ex);
2816     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2817     _igvn.replace_input_of(use, idx, ex);
2818     _igvn._worklist.push(def);
2819 
2820     bb_insert_after(ex, bb_idx(def));
2821     set_velt_type(ex, velt_type(def));
2822   }
2823 }
2824 
2825 //------------------------------is_vector_use---------------------------
2826 // Is use-&gt;in(u_idx) a vector use?
2827 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2828   Node_List* u_pk = my_pack(use);
2829   if (u_pk == NULL) return false;
2830   if (use-&gt;is_reduction()) return true;
2831   Node* def = use-&gt;in(u_idx);
2832   Node_List* d_pk = my_pack(def);
2833   if (d_pk == NULL) {
2834     // check for scalar promotion
2835     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2836     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2837       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2838     }
2839     return true;
2840   }
2841   if (VectorNode::is_muladds2i(use)) {
2842     // MulAddS2I takes shorts and produces ints - hence the special checks
2843     // on alignment and size.
2844     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2845       return false;
2846     }
2847     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2848       Node* ui = u_pk-&gt;at(i);
2849       Node* di = d_pk-&gt;at(i);
2850       if (alignment(ui) != alignment(di) * 2) {
2851         return false;
2852       }
2853     }
2854     return true;
2855   }
2856   if (u_pk-&gt;size() != d_pk-&gt;size())
2857     return false;
2858   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2859     Node* ui = u_pk-&gt;at(i);
2860     Node* di = d_pk-&gt;at(i);
2861     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2862       return false;
2863   }
2864   return true;
2865 }
2866 
2867 //------------------------------construct_bb---------------------------
2868 // Construct reverse postorder list of block members
2869 bool SuperWord::construct_bb() {
2870   Node* entry = bb();
2871 
2872   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2873   assert(_block.length() == 0,          &quot;block is empty&quot;);
2874   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2875   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2876   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2877 
2878   // Find non-control nodes with no inputs from within block,
2879   // create a temporary map from node _idx to bb_idx for use
2880   // by the visited and post_visited sets,
2881   // and count number of nodes in block.
2882   int bb_ct = 0;
2883   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2884     Node *n = lpt()-&gt;_body.at(i);
2885     set_bb_idx(n, i); // Create a temporary map
2886     if (in_bb(n)) {
2887       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2888           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2889         // Bailout if the loop has LoadStore, MergeMem or data Proj
2890         // nodes. Superword optimization does not work with them.
2891         return false;
2892       }
2893       bb_ct++;
2894       if (!n-&gt;is_CFG()) {
2895         bool found = false;
2896         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2897           Node* def = n-&gt;in(j);
2898           if (def &amp;&amp; in_bb(def)) {
2899             found = true;
2900             break;
2901           }
2902         }
2903         if (!found) {
2904           assert(n != entry, &quot;can&#39;t be entry&quot;);
2905           _data_entry.push(n);
2906         }
2907       }
2908     }
2909   }
2910 
2911   // Find memory slices (head and tail)
2912   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2913     Node *n = lp()-&gt;fast_out(i);
2914     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2915       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2916       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2917         if (!n_tail-&gt;is_Mem()) {
2918           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2919           return false; // Bailout
2920         }
2921         _mem_slice_head.push(n);
2922         _mem_slice_tail.push(n_tail);
2923       }
2924     }
2925   }
2926 
2927   // Create an RPO list of nodes in block
2928 
2929   visited_clear();
2930   post_visited_clear();
2931 
2932   // Push all non-control nodes with no inputs from within block, then control entry
2933   for (int j = 0; j &lt; _data_entry.length(); j++) {
2934     Node* n = _data_entry.at(j);
2935     visited_set(n);
2936     _stk.push(n);
2937   }
2938   visited_set(entry);
2939   _stk.push(entry);
2940 
2941   // Do a depth first walk over out edges
2942   int rpo_idx = bb_ct - 1;
2943   int size;
2944   int reduction_uses = 0;
2945   while ((size = _stk.length()) &gt; 0) {
2946     Node* n = _stk.top(); // Leave node on stack
2947     if (!visited_test_set(n)) {
2948       // forward arc in graph
2949     } else if (!post_visited_test(n)) {
2950       // cross or back arc
2951       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2952         Node *use = n-&gt;fast_out(i);
2953         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2954             // Don&#39;t go around backedge
2955             (!use-&gt;is_Phi() || n == entry)) {
2956           if (use-&gt;is_reduction()) {
2957             // First see if we can map the reduction on the given system we are on, then
2958             // make a data entry operation for each reduction we see.
2959             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2960             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2961               reduction_uses++;
2962             }
2963           }
2964           _stk.push(use);
2965         }
2966       }
2967       if (_stk.length() == size) {
2968         // There were no additional uses, post visit node now
2969         _stk.pop(); // Remove node from stack
2970         assert(rpo_idx &gt;= 0, &quot;&quot;);
2971         _block.at_put_grow(rpo_idx, n);
2972         rpo_idx--;
2973         post_visited_set(n);
2974         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
2975       }
2976     } else {
2977       _stk.pop(); // Remove post-visited node from stack
2978     }
2979   }//while
2980 
2981   int ii_current = -1;
2982   unsigned int load_idx = (unsigned int)-1;
2983   _ii_order.clear();
2984   // Create real map of block indices for nodes
2985   for (int j = 0; j &lt; _block.length(); j++) {
2986     Node* n = _block.at(j);
2987     set_bb_idx(n, j);
2988     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
2989       if (ii_current == -1) {
2990         ii_current = _clone_map.gen(n-&gt;_idx);
2991         _ii_order.push(ii_current);
2992         load_idx = _clone_map.idx(n-&gt;_idx);
2993       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
2994         ii_current = _clone_map.gen(n-&gt;_idx);
2995         _ii_order.push(ii_current);
2996       }
2997     }
2998   }//for
2999 
3000   // Ensure extra info is allocated.
3001   initialize_bb();
3002 
3003 #ifndef PRODUCT
3004   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
3005     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
3006     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
3007       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
3008     }
3009     tty-&gt;print_cr(&quot; &quot;);
3010   }
3011   if (TraceSuperWord) {
3012     print_bb();
3013     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3014     for (int m = 0; m &lt; _data_entry.length(); m++) {
3015       tty-&gt;print(&quot;%3d &quot;, m);
3016       _data_entry.at(m)-&gt;dump();
3017     }
3018     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3019     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
3020       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
3021       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
3022     }
3023   }
3024 #endif
3025   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
3026   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
3027 }
3028 
3029 //------------------------------initialize_bb---------------------------
3030 // Initialize per node info
3031 void SuperWord::initialize_bb() {
3032   Node* last = _block.at(_block.length() - 1);
3033   grow_node_info(bb_idx(last));
3034 }
3035 
3036 //------------------------------bb_insert_after---------------------------
3037 // Insert n into block after pos
3038 void SuperWord::bb_insert_after(Node* n, int pos) {
3039   int n_pos = pos + 1;
3040   // Make room
3041   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3042     _block.at_put_grow(i+1, _block.at(i));
3043   }
3044   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3045     _node_info.at_put_grow(j+1, _node_info.at(j));
3046   }
3047   // Set value
3048   _block.at_put_grow(n_pos, n);
3049   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3050   // Adjust map from node-&gt;_idx to _block index
3051   for (int i = n_pos; i &lt; _block.length(); i++) {
3052     set_bb_idx(_block.at(i), i);
3053   }
3054 }
3055 
3056 //------------------------------compute_max_depth---------------------------
3057 // Compute max depth for expressions from beginning of block
3058 // Use to prune search paths during test for independence.
3059 void SuperWord::compute_max_depth() {
3060   int ct = 0;
3061   bool again;
3062   do {
3063     again = false;
3064     for (int i = 0; i &lt; _block.length(); i++) {
3065       Node* n = _block.at(i);
3066       if (!n-&gt;is_Phi()) {
3067         int d_orig = depth(n);
3068         int d_in   = 0;
3069         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3070           Node* pred = preds.current();
3071           if (in_bb(pred)) {
3072             d_in = MAX2(d_in, depth(pred));
3073           }
3074         }
3075         if (d_in + 1 != d_orig) {
3076           set_depth(n, d_in + 1);
3077           again = true;
3078         }
3079       }
3080     }
3081     ct++;
3082   } while (again);
3083 
3084   if (TraceSuperWord &amp;&amp; Verbose) {
3085     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3086   }
3087 }
3088 
3089 //-------------------------compute_vector_element_type-----------------------
3090 // Compute necessary vector element type for expressions
3091 // This propagates backwards a narrower integer type when the
3092 // upper bits of the value are not needed.
3093 // Example:  char a,b,c;  a = b + c;
3094 // Normally the type of the add is integer, but for packed character
3095 // operations the type of the add needs to be char.
3096 void SuperWord::compute_vector_element_type() {
3097   if (TraceSuperWord &amp;&amp; Verbose) {
3098     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3099   }
3100 
3101   // Initial type
3102   for (int i = 0; i &lt; _block.length(); i++) {
3103     Node* n = _block.at(i);
3104     set_velt_type(n, container_type(n));
3105   }
3106 
3107   // Propagate integer narrowed type backwards through operations
3108   // that don&#39;t depend on higher order bits
3109   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3110     Node* n = _block.at(i);
3111     // Only integer types need be examined
3112     const Type* vtn = velt_type(n);
3113     if (vtn-&gt;basic_type() == T_INT) {
3114       uint start, end;
3115       VectorNode::vector_operands(n, &amp;start, &amp;end);
3116 
3117       for (uint j = start; j &lt; end; j++) {
3118         Node* in  = n-&gt;in(j);
3119         // Don&#39;t propagate through a memory
3120         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3121             data_size(n) &lt; data_size(in)) {
3122           bool same_type = true;
3123           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3124             Node *use = in-&gt;fast_out(k);
3125             if (!in_bb(use) || !same_velt_type(use, n)) {
3126               same_type = false;
3127               break;
3128             }
3129           }
3130           if (same_type) {
3131             // For right shifts of small integer types (bool, byte, char, short)
3132             // we need precise information about sign-ness. Only Load nodes have
3133             // this information because Store nodes are the same for signed and
3134             // unsigned values. And any arithmetic operation after a load may
3135             // expand a value to signed Int so such right shifts can&#39;t be used
3136             // because vector elements do not have upper bits of Int.
3137             const Type* vt = vtn;
3138             if (VectorNode::is_shift(in)) {
3139               Node* load = in-&gt;in(1);
3140               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3141                 vt = velt_type(load);
3142               } else if (in-&gt;Opcode() != Op_LShiftI) {
3143                 // Widen type to Int to avoid creation of right shift vector
3144                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3145                 // Note, left shifts work regardless type.
3146                 vt = TypeInt::INT;
3147               }
3148             }
3149             set_velt_type(in, vt);
3150           }
3151         }
3152       }
3153     }
3154   }
3155 #ifndef PRODUCT
3156   if (TraceSuperWord &amp;&amp; Verbose) {
3157     for (int i = 0; i &lt; _block.length(); i++) {
3158       Node* n = _block.at(i);
3159       velt_type(n)-&gt;dump();
3160       tty-&gt;print(&quot;\t&quot;);
3161       n-&gt;dump();
3162     }
3163   }
3164 #endif
3165 }
3166 
3167 //------------------------------memory_alignment---------------------------
3168 // Alignment within a vector memory reference
3169 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3170   #ifndef PRODUCT
3171     if(TraceSuperWord &amp;&amp; Verbose) {
3172       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3173     }
3174   #endif
3175   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3176   SWPointer p(s, this, NULL, false);
3177   if (!p.valid()) {
3178     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3179     return bottom_align;
3180   }
3181   int vw = get_vw_bytes_special(s);
3182   if (vw &lt; 2) {
3183     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3184     return bottom_align; // No vectors for this type
3185   }
3186   int offset  = p.offset_in_bytes();
3187   offset     += iv_adjust*p.memory_size();
3188   int off_rem = offset % vw;
3189   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3190   if (TraceSuperWord &amp;&amp; Verbose) {
3191     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3192   }
3193   return off_mod;
3194 }
3195 
3196 //---------------------------container_type---------------------------
3197 // Smallest type containing range of values
3198 const Type* SuperWord::container_type(Node* n) {
3199   if (n-&gt;is_Mem()) {
3200     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3201     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3202       // Use T_SHORT type instead of T_CHAR for stored values because any
3203       // preceding arithmetic operation extends values to signed Int.
3204       bt = T_SHORT;
3205     }
3206     if (n-&gt;Opcode() == Op_LoadUB) {
3207       // Adjust type for unsigned byte loads, it is important for right shifts.
3208       // T_BOOLEAN is used because there is no basic type representing type
3209       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3210       // size (one byte) and sign is important.
3211       bt = T_BOOLEAN;
3212     }
3213     return Type::get_const_basic_type(bt);
3214   }
3215   const Type* t = _igvn.type(n);
3216   if (t-&gt;basic_type() == T_INT) {
3217     // A narrow type of arithmetic operations will be determined by
3218     // propagating the type of memory operations.
3219     return TypeInt::INT;
3220   }
3221   return t;
3222 }
3223 
3224 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3225   const Type* vt1 = velt_type(n1);
3226   const Type* vt2 = velt_type(n2);
3227   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3228     // Compare vectors element sizes for integer types.
3229     return data_size(n1) == data_size(n2);
3230   }
3231   return vt1 == vt2;
3232 }
3233 
3234 //------------------------------in_packset---------------------------
3235 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3236 bool SuperWord::in_packset(Node* s1, Node* s2) {
3237   for (int i = 0; i &lt; _packset.length(); i++) {
3238     Node_List* p = _packset.at(i);
3239     assert(p-&gt;size() == 2, &quot;must be&quot;);
3240     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3241       return true;
3242     }
3243   }
3244   return false;
3245 }
3246 
3247 //------------------------------in_pack---------------------------
3248 // Is s in pack p?
3249 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3250   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3251     if (p-&gt;at(i) == s) {
3252       return p;
3253     }
3254   }
3255   return NULL;
3256 }
3257 
3258 //------------------------------remove_pack_at---------------------------
3259 // Remove the pack at position pos in the packset
3260 void SuperWord::remove_pack_at(int pos) {
3261   Node_List* p = _packset.at(pos);
3262   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3263     Node* s = p-&gt;at(i);
3264     set_my_pack(s, NULL);
3265   }
3266   _packset.remove_at(pos);
3267 }
3268 
3269 void SuperWord::packset_sort(int n) {
3270   // simple bubble sort so that we capitalize with O(n) when its already sorted
3271   while (n != 0) {
3272     bool swapped = false;
3273     for (int i = 1; i &lt; n; i++) {
3274       Node_List* q_low = _packset.at(i-1);
3275       Node_List* q_i = _packset.at(i);
3276 
3277       // only swap when we find something to swap
3278       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3279         Node_List* t = q_i;
3280         *(_packset.adr_at(i)) = q_low;
3281         *(_packset.adr_at(i-1)) = q_i;
3282         swapped = true;
3283       }
3284     }
3285     if (swapped == false) break;
3286     n--;
3287   }
3288 }
3289 
3290 //------------------------------executed_first---------------------------
3291 // Return the node executed first in pack p.  Uses the RPO block list
3292 // to determine order.
3293 Node* SuperWord::executed_first(Node_List* p) {
3294   Node* n = p-&gt;at(0);
3295   int n_rpo = bb_idx(n);
3296   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3297     Node* s = p-&gt;at(i);
3298     int s_rpo = bb_idx(s);
3299     if (s_rpo &lt; n_rpo) {
3300       n = s;
3301       n_rpo = s_rpo;
3302     }
3303   }
3304   return n;
3305 }
3306 
3307 //------------------------------executed_last---------------------------
3308 // Return the node executed last in pack p.
3309 Node* SuperWord::executed_last(Node_List* p) {
3310   Node* n = p-&gt;at(0);
3311   int n_rpo = bb_idx(n);
3312   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3313     Node* s = p-&gt;at(i);
3314     int s_rpo = bb_idx(s);
3315     if (s_rpo &gt; n_rpo) {
3316       n = s;
3317       n_rpo = s_rpo;
3318     }
3319   }
3320   return n;
3321 }
3322 
3323 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3324   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3325   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3326     Node* n = p-&gt;at(i);
3327     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3328     if (!n-&gt;depends_only_on_test()) {
3329       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;
3330           dep != LoadNode::Pinned) {
3331         // Upgrade to unknown control...
3332         dep = LoadNode::UnknownControl;
3333       } else {
3334         // Otherwise, we must pin it.
3335         dep = LoadNode::Pinned;
3336       }
3337     }
3338   }
3339   return dep;
3340 }
3341 
3342 
3343 //----------------------------align_initial_loop_index---------------------------
3344 // Adjust pre-loop limit so that in main loop, a load/store reference
3345 // to align_to_ref will be a position zero in the vector.
3346 //   (iv + k) mod vector_align == 0
3347 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3348   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3349   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3350   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3351   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3352   Node *pre_opaq1 = pre_end-&gt;limit();
3353   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3354   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3355   Node *lim0 = pre_opaq-&gt;in(1);
3356 
3357   // Where we put new limit calculations
3358   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3359 
3360   // Ensure the original loop limit is available from the
3361   // pre-loop Opaque1 node.
3362   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3363   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3364 
3365   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3366   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3367 
3368   // Given:
3369   //     lim0 == original pre loop limit
3370   //     V == v_align (power of 2)
3371   //     invar == extra invariant piece of the address expression
3372   //     e == offset [ +/- invar ]
3373   //
3374   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3375   //     (a - b) % k == 0   =&gt;  a % k == b % k
3376   // and:
3377   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3378   //
3379   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3380   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3381   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3382   //     (2) (e + lim) % V == 0
3383   //   are true.
3384   //
3385   //   Substituting (1) into (2),
3386   //     (e + lim0 + N) % V == 0
3387   //   solve for N:
3388   //     N = (V - (e + lim0)) % V
3389   //   substitute back into (1), so that new limit
3390   //     lim = lim0 + (V - (e + lim0)) % V
3391   //
3392   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3393   //   Constraints:
3394   //     lim = lim0 + N
3395   //     (e - lim) % V == 0
3396   //   Solving for lim:
3397   //     (e - lim0 - N) % V == 0
3398   //     N = (e - lim0) % V
3399   //     lim = lim0 + (e - lim0) % V
3400   //
3401   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3402   //   Constraints:
3403   //     lim = lim0 - N
3404   //     (e + lim) % V == 0
3405   //   Solving for lim:
3406   //     (e + lim0 - N) % V == 0
3407   //     N = (e + lim0) % V
3408   //     lim = lim0 - (e + lim0) % V
3409   //
3410   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3411   //   Constraints:
3412   //     lim = lim0 - N
3413   //     (e - lim) % V == 0
3414   //   Solving for lim:
3415   //     (e - lim0 + N) % V == 0
3416   //     N = (V - (e - lim0)) % V
3417   //     lim = lim0 - (V - (e - lim0)) % V
3418 
3419   int vw = vector_width_in_bytes(align_to_ref);
3420   int stride   = iv_stride();
3421   int scale    = align_to_ref_p.scale_in_bytes();
3422   int elt_size = align_to_ref_p.memory_size();
3423   int v_align  = vw / elt_size;
3424   assert(v_align &gt; 1, &quot;sanity&quot;);
3425   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3426   Node *offsn  = _igvn.intcon(offset);
3427 
3428   Node *e = offsn;
3429   if (align_to_ref_p.invar() != NULL) {
3430     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3431     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3432     Node* invar = align_to_ref_p.invar();
3433     if (_igvn.type(invar)-&gt;isa_long()) {
3434       // Computations are done % (vector width/element size) so it&#39;s
3435       // safe to simply convert invar to an int and loose the upper 32
3436       // bit half.
3437       invar = new ConvL2INode(invar);
3438       _igvn.register_new_node_with_optimizer(invar);
3439     }
3440     Node* aref = new URShiftINode(invar, log2_elt);
3441     _igvn.register_new_node_with_optimizer(aref);
3442     _phase-&gt;set_ctrl(aref, pre_ctrl);
3443     if (align_to_ref_p.negate_invar()) {
3444       e = new SubINode(e, aref);
3445     } else {
3446       e = new AddINode(e, aref);
3447     }
3448     _igvn.register_new_node_with_optimizer(e);
3449     _phase-&gt;set_ctrl(e, pre_ctrl);
3450   }
3451   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3452     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3453     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3454     _igvn.register_new_node_with_optimizer(xbase);
3455 #ifdef _LP64
3456     xbase  = new ConvL2INode(xbase);
3457     _igvn.register_new_node_with_optimizer(xbase);
3458 #endif
3459     Node* mask = _igvn.intcon(vw-1);
3460     Node* masked_xbase  = new AndINode(xbase, mask);
3461     _igvn.register_new_node_with_optimizer(masked_xbase);
3462     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3463     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3464     _igvn.register_new_node_with_optimizer(bref);
3465     _phase-&gt;set_ctrl(bref, pre_ctrl);
3466     e = new AddINode(e, bref);
3467     _igvn.register_new_node_with_optimizer(e);
3468     _phase-&gt;set_ctrl(e, pre_ctrl);
3469   }
3470 
3471   // compute e +/- lim0
3472   if (scale &lt; 0) {
3473     e = new SubINode(e, lim0);
3474   } else {
3475     e = new AddINode(e, lim0);
3476   }
3477   _igvn.register_new_node_with_optimizer(e);
3478   _phase-&gt;set_ctrl(e, pre_ctrl);
3479 
3480   if (stride * scale &gt; 0) {
3481     // compute V - (e +/- lim0)
3482     Node* va  = _igvn.intcon(v_align);
3483     e = new SubINode(va, e);
3484     _igvn.register_new_node_with_optimizer(e);
3485     _phase-&gt;set_ctrl(e, pre_ctrl);
3486   }
3487   // compute N = (exp) % V
3488   Node* va_msk = _igvn.intcon(v_align - 1);
3489   Node* N = new AndINode(e, va_msk);
3490   _igvn.register_new_node_with_optimizer(N);
3491   _phase-&gt;set_ctrl(N, pre_ctrl);
3492 
3493   //   substitute back into (1), so that new limit
3494   //     lim = lim0 + N
3495   Node* lim;
3496   if (stride &lt; 0) {
3497     lim = new SubINode(lim0, N);
3498   } else {
3499     lim = new AddINode(lim0, N);
3500   }
3501   _igvn.register_new_node_with_optimizer(lim);
3502   _phase-&gt;set_ctrl(lim, pre_ctrl);
3503   Node* constrained =
3504     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3505                  : (Node*) new MaxINode(lim, orig_limit);
3506   _igvn.register_new_node_with_optimizer(constrained);
3507   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3508   _igvn.replace_input_of(pre_opaq, 1, constrained);
3509 }
3510 
3511 //----------------------------get_pre_loop_end---------------------------
3512 // Find pre loop end from main loop.  Returns null if none.
3513 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3514   // The loop cannot be optimized if the graph shape at
3515   // the loop entry is inappropriate.
3516   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3517     return NULL;
3518   }
3519 
3520   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3521   if (!p_f-&gt;is_IfFalse()) return NULL;
3522   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3523   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3524   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3525   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3526   return pre_end;
3527 }
3528 
3529 //------------------------------init---------------------------
3530 void SuperWord::init() {
3531   _dg.init();
3532   _packset.clear();
3533   _disjoint_ptrs.clear();
3534   _block.clear();
3535   _post_block.clear();
3536   _data_entry.clear();
3537   _mem_slice_head.clear();
3538   _mem_slice_tail.clear();
3539   _iteration_first.clear();
3540   _iteration_last.clear();
3541   _node_info.clear();
3542   _align_to_ref = NULL;
3543   _lpt = NULL;
3544   _lp = NULL;
3545   _bb = NULL;
3546   _iv = NULL;
3547   _race_possible = 0;
3548   _early_return = false;
3549   _num_work_vecs = 0;
3550   _num_reductions = 0;
3551 }
3552 
3553 //------------------------------restart---------------------------
3554 void SuperWord::restart() {
3555   _dg.init();
3556   _packset.clear();
3557   _disjoint_ptrs.clear();
3558   _block.clear();
3559   _post_block.clear();
3560   _data_entry.clear();
3561   _mem_slice_head.clear();
3562   _mem_slice_tail.clear();
3563   _node_info.clear();
3564 }
3565 
3566 //------------------------------print_packset---------------------------
3567 void SuperWord::print_packset() {
3568 #ifndef PRODUCT
3569   tty-&gt;print_cr(&quot;packset&quot;);
3570   for (int i = 0; i &lt; _packset.length(); i++) {
3571     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3572     Node_List* p = _packset.at(i);
3573     print_pack(p);
3574   }
3575 #endif
3576 }
3577 
3578 //------------------------------print_pack---------------------------
3579 void SuperWord::print_pack(Node_List* p) {
3580   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3581     print_stmt(p-&gt;at(i));
3582   }
3583 }
3584 
3585 //------------------------------print_bb---------------------------
3586 void SuperWord::print_bb() {
3587 #ifndef PRODUCT
3588   tty-&gt;print_cr(&quot;\nBlock&quot;);
3589   for (int i = 0; i &lt; _block.length(); i++) {
3590     Node* n = _block.at(i);
3591     tty-&gt;print(&quot;%d &quot;, i);
3592     if (n) {
3593       n-&gt;dump();
3594     }
3595   }
3596 #endif
3597 }
3598 
3599 //------------------------------print_stmt---------------------------
3600 void SuperWord::print_stmt(Node* s) {
3601 #ifndef PRODUCT
3602   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3603   s-&gt;dump();
3604 #endif
3605 }
3606 
3607 //------------------------------blank---------------------------
3608 char* SuperWord::blank(uint depth) {
3609   static char blanks[101];
3610   assert(depth &lt; 101, &quot;too deep&quot;);
3611   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3612   blanks[depth] = &#39;\0&#39;;
3613   return blanks;
3614 }
3615 
3616 
3617 //==============================SWPointer===========================
3618 #ifndef PRODUCT
3619 int SWPointer::Tracer::_depth = 0;
3620 #endif
3621 //----------------------------SWPointer------------------------
3622 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3623   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3624   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3625   _nstack(nstack), _analyze_only(analyze_only),
3626   _stack_idx(0)
3627 #ifndef PRODUCT
3628   , _tracer(slp)
3629 #endif
3630 {
3631   NOT_PRODUCT(_tracer.ctor_1(mem);)
3632 
3633   Node* adr = mem-&gt;in(MemNode::Address);
3634   if (!adr-&gt;is_AddP()) {
3635     assert(!valid(), &quot;too complex&quot;);
3636     return;
3637   }
3638   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3639   Node* base = adr-&gt;in(AddPNode::Base);
3640   // The base address should be loop invariant
3641   if (!invariant(base)) {
3642     assert(!valid(), &quot;base address is loop variant&quot;);
3643     return;
3644   }
3645   // unsafe references require misaligned vector access support
3646   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3647     assert(!valid(), &quot;unsafe access&quot;);
3648     return;
3649   }
3650 
3651   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3652   NOT_PRODUCT(_tracer.ctor_2(adr);)
3653 
3654   int i;
3655   for (i = 0; i &lt; 3; i++) {
3656     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3657 
3658     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3659       assert(!valid(), &quot;too complex&quot;);
3660       return;
3661     }
3662     adr = adr-&gt;in(AddPNode::Address);
3663     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3664 
3665     if (base == adr || !adr-&gt;is_AddP()) {
3666       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3667       break; // stop looking at addp&#39;s
3668     }
3669   }
3670   if (!invariant(adr)) {
3671     assert(!valid(), &quot;adr is loop variant&quot;);
3672     return;
3673   }
3674 
3675   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3676     assert(!valid(), &quot;adr and base differ&quot;);
3677     return;
3678   }
3679 
3680   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3681   NOT_PRODUCT(_tracer.ctor_6(mem);)
3682 
3683   _base = base;
3684   _adr  = adr;
3685   assert(valid(), &quot;Usable&quot;);
3686 }
3687 
3688 // Following is used to create a temporary object during
3689 // the pattern match of an address expression.
3690 SWPointer::SWPointer(SWPointer* p) :
3691   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3692   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3693   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3694   _stack_idx(p-&gt;_stack_idx)
3695   #ifndef PRODUCT
3696   , _tracer(p-&gt;_slp)
3697   #endif
3698 {}
3699 
3700 
3701 bool SWPointer::invariant(Node* n) {
3702   NOT_PRODUCT(Tracer::Depth dd;)
3703   Node *n_c = phase()-&gt;get_ctrl(n);
3704   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3705   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3706 }
3707 //------------------------scaled_iv_plus_offset--------------------
3708 // Match: k*iv + offset
3709 // where: k is a constant that maybe zero, and
3710 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3711 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3712   NOT_PRODUCT(Tracer::Depth ddd;)
3713   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3714 
3715   if (scaled_iv(n)) {
3716     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3717     return true;
3718   }
3719 
3720   if (offset_plus_k(n)) {
3721     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3722     return true;
3723   }
3724 
3725   int opc = n-&gt;Opcode();
3726   if (opc == Op_AddI) {
3727     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3728       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3729       return true;
3730     }
3731     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3732       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3733       return true;
3734     }
3735   } else if (opc == Op_SubI) {
3736     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3737       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3738       return true;
3739     }
3740     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3741       _scale *= -1;
3742       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3743       return true;
3744     }
3745   }
3746 
3747   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3748   return false;
3749 }
3750 
3751 //----------------------------scaled_iv------------------------
3752 // Match: k*iv where k is a constant that&#39;s not zero
3753 bool SWPointer::scaled_iv(Node* n) {
3754   NOT_PRODUCT(Tracer::Depth ddd;)
3755   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3756 
3757   if (_scale != 0) { // already found a scale
3758     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3759     return false;
3760   }
3761 
3762   if (n == iv()) {
3763     _scale = 1;
3764     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3765     return true;
3766   }
3767   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3768     _nstack-&gt;push(n, _stack_idx++);
3769   }
3770 
3771   int opc = n-&gt;Opcode();
3772   if (opc == Op_MulI) {
3773     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3774       _scale = n-&gt;in(2)-&gt;get_int();
3775       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3776       return true;
3777     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3778       _scale = n-&gt;in(1)-&gt;get_int();
3779       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3780       return true;
3781     }
3782   } else if (opc == Op_LShiftI) {
3783     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3784       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3785       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3786       return true;
3787     }
3788   } else if (opc == Op_ConvI2L) {
3789     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3790         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3791       // Skip range check dependent CastII nodes
3792       n = n-&gt;in(1);
3793     }
3794     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3795       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3796       return true;
3797     }
3798   } else if (opc == Op_LShiftL) {
3799     if (!has_iv() &amp;&amp; _invar == NULL) {
3800       // Need to preserve the current _offset value, so
3801       // create a temporary object for this expression subtree.
3802       // Hacky, so should re-engineer the address pattern match.
3803       NOT_PRODUCT(Tracer::Depth dddd;)
3804       SWPointer tmp(this);
3805       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3806 
3807       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3808         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3809           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3810           _scale   = tmp._scale  * mult;
3811           _offset += tmp._offset * mult;
3812           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3813           return true;
3814         }
3815       }
3816     }
3817   }
3818   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3819   return false;
3820 }
3821 
3822 //----------------------------offset_plus_k------------------------
3823 // Match: offset is (k [+/- invariant])
3824 // where k maybe zero and invariant is optional, but not both.
3825 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3826   NOT_PRODUCT(Tracer::Depth ddd;)
3827   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3828 
3829   int opc = n-&gt;Opcode();
3830   if (opc == Op_ConI) {
3831     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3832     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3833     return true;
3834   } else if (opc == Op_ConL) {
3835     // Okay if value fits into an int
3836     const TypeLong* t = n-&gt;find_long_type();
3837     if (t-&gt;higher_equal(TypeLong::INT)) {
3838       jlong loff = n-&gt;get_long();
3839       jint  off  = (jint)loff;
3840       _offset += negate ? -off : loff;
3841       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3842       return true;
3843     }
3844     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3845     return false;
3846   }
3847   if (_invar != NULL) { // already has an invariant
3848     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3849     return false;
3850   }
3851 
3852   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3853     _nstack-&gt;push(n, _stack_idx++);
3854   }
3855   if (opc == Op_AddI) {
3856     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3857       _negate_invar = negate;
3858       _invar = n-&gt;in(1);
3859       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3860       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3861       return true;
3862     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3863       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3864       _negate_invar = negate;
3865       _invar = n-&gt;in(2);
3866       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3867       return true;
3868     }
3869   }
3870   if (opc == Op_SubI) {
3871     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3872       _negate_invar = negate;
3873       _invar = n-&gt;in(1);
3874       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3875       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3876       return true;
3877     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3878       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3879       _negate_invar = !negate;
3880       _invar = n-&gt;in(2);
3881       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3882       return true;
3883     }
3884   }
3885   if (invariant(n)) {
3886     if (opc == Op_ConvI2L) {
3887       n = n-&gt;in(1);
3888       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3889           n-&gt;as_CastII()-&gt;has_range_check()) {
3890         // Skip range check dependent CastII nodes
3891         assert(invariant(n), &quot;sanity&quot;);
3892         n = n-&gt;in(1);
3893       }
3894     }
3895     _negate_invar = negate;
3896     _invar = n;
3897     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3898     return true;
3899   }
3900 
3901   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3902   return false;
3903 }
3904 
3905 //----------------------------print------------------------
3906 void SWPointer::print() {
3907 #ifndef PRODUCT
3908   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3909              _base != NULL ? _base-&gt;_idx : 0,
3910              _adr  != NULL ? _adr-&gt;_idx  : 0,
3911              _scale, _offset,
3912              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3913              _invar != NULL ? _invar-&gt;_idx : 0);
3914 #endif
3915 }
3916 
3917 //----------------------------tracing------------------------
3918 #ifndef PRODUCT
3919 void SWPointer::Tracer::print_depth() {
3920   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3921 }
3922 
3923 void SWPointer::Tracer::ctor_1 (Node* mem) {
3924   if(_slp-&gt;is_trace_alignment()) {
3925     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3926   }
3927 }
3928 
3929 void SWPointer::Tracer::ctor_2(Node* adr) {
3930   if(_slp-&gt;is_trace_alignment()) {
3931     //store_depth();
3932     inc_depth();
3933     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3934     inc_depth();
3935     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3936   }
3937 }
3938 
3939 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3940   if(_slp-&gt;is_trace_alignment()) {
3941     inc_depth();
3942     Node* offset = adr-&gt;in(AddPNode::Offset);
3943     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3944   }
3945 }
3946 
3947 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3948   if(_slp-&gt;is_trace_alignment()) {
3949     inc_depth();
3950     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3951   }
3952 }
3953 
3954 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3955   if(_slp-&gt;is_trace_alignment()) {
3956     inc_depth();
3957     if (base == adr) {
3958       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3959     } else if (!adr-&gt;is_AddP()) {
3960       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3961     }
3962   }
3963 }
3964 
3965 void SWPointer::Tracer::ctor_6(Node* mem) {
3966   if(_slp-&gt;is_trace_alignment()) {
3967     //restore_depth();
3968     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
3969   }
3970 }
3971 
3972 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
3973   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
3974     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
3975     int in_bb     =  _slp-&gt;in_bb(n);
3976     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
3977     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
3978     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
3979     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
3980   }
3981 }
3982 
3983 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
3984   if(_slp-&gt;is_trace_alignment()) {
3985     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
3986     n-&gt;dump();
3987   }
3988 }
3989 
3990 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
3991   if(_slp-&gt;is_trace_alignment()) {
3992     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3993   }
3994 }
3995 
3996 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
3997   if(_slp-&gt;is_trace_alignment()) {
3998     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3999   }
4000 }
4001 
4002 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
4003   if(_slp-&gt;is_trace_alignment()) {
4004     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4005     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4006     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4007   }
4008 }
4009 
4010 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
4011   if(_slp-&gt;is_trace_alignment()) {
4012     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4013     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4014     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4015   }
4016 }
4017 
4018 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
4019   if(_slp-&gt;is_trace_alignment()) {
4020     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4021     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4022     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4023   }
4024 }
4025 
4026 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
4027   if(_slp-&gt;is_trace_alignment()) {
4028     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4029     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4030     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4031   }
4032 }
4033 
4034 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
4035   if(_slp-&gt;is_trace_alignment()) {
4036     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
4037   }
4038 }
4039 
4040 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4041   if(_slp-&gt;is_trace_alignment()) {
4042     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4043   }
4044 }
4045 
4046 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4047   if(_slp-&gt;is_trace_alignment()) {
4048     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4049     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4050   }
4051 }
4052 
4053 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4054   if(_slp-&gt;is_trace_alignment()) {
4055     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4056   }
4057 }
4058 
4059 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4060   if(_slp-&gt;is_trace_alignment()) {
4061     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4062     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4063     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4064   }
4065 }
4066 
4067 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4068   if(_slp-&gt;is_trace_alignment()) {
4069     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4070     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4071     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4072   }
4073 }
4074 
4075 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4076   if(_slp-&gt;is_trace_alignment()) {
4077     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4078     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4079     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4080   }
4081 }
4082 
4083 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4084   if(_slp-&gt;is_trace_alignment()) {
4085     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4086     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4087     inc_depth(); inc_depth();
4088     print_depth(); n-&gt;in(1)-&gt;dump();
4089     dec_depth(); dec_depth();
4090   }
4091 }
4092 
4093 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4094   if(_slp-&gt;is_trace_alignment()) {
4095     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4096   }
4097 }
4098 
4099 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4100   if(_slp-&gt;is_trace_alignment()) {
4101     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4102     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4103     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4104     inc_depth(); inc_depth();
4105     print_depth(); n-&gt;in(1)-&gt;dump();
4106     print_depth(); n-&gt;in(2)-&gt;dump();
4107     dec_depth(); dec_depth();
4108   }
4109 }
4110 
4111 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4112   if(_slp-&gt;is_trace_alignment()) {
4113     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4114   }
4115 }
4116 
4117 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4118   if(_slp-&gt;is_trace_alignment()) {
4119     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4120   }
4121 }
4122 
4123 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4124   if(_slp-&gt;is_trace_alignment()) {
4125     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4126   }
4127 }
4128 
4129 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4130   if(_slp-&gt;is_trace_alignment()) {
4131     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4132   }
4133 }
4134 
4135 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4136   if(_slp-&gt;is_trace_alignment()) {
4137     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4138     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4139   }
4140 }
4141 
4142 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4143   if(_slp-&gt;is_trace_alignment()) {
4144     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4145     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4146   }
4147 }
4148 
4149 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4150   if(_slp-&gt;is_trace_alignment()) {
4151     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4152     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4153     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4154     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4155   }
4156 }
4157 
4158 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4159   if(_slp-&gt;is_trace_alignment()) {
4160     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4161     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4162     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4163     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4164   }
4165 }
4166 
4167 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4168   if(_slp-&gt;is_trace_alignment()) {
4169     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4170     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4171     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4172     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4173   }
4174 }
4175 
4176 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4177   if(_slp-&gt;is_trace_alignment()) {
4178     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4179     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4180     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4181   }
4182 }
4183 
4184 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4185   if(_slp-&gt;is_trace_alignment()) {
4186     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4187     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4188   }
4189 }
4190 
4191 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4192   if(_slp-&gt;is_trace_alignment()) {
4193     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4194   }
4195 }
4196 
4197 #endif
4198 // ========================= OrderedPair =====================
4199 
4200 const OrderedPair OrderedPair::initial;
4201 
4202 // ========================= SWNodeInfo =====================
4203 
4204 const SWNodeInfo SWNodeInfo::initial;
4205 
4206 
4207 // ============================ DepGraph ===========================
4208 
4209 //------------------------------make_node---------------------------
4210 // Make a new dependence graph node for an ideal node.
4211 DepMem* DepGraph::make_node(Node* node) {
4212   DepMem* m = new (_arena) DepMem(node);
4213   if (node != NULL) {
4214     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4215     _map.at_put_grow(node-&gt;_idx, m);
4216   }
4217   return m;
4218 }
4219 
4220 //------------------------------make_edge---------------------------
4221 // Make a new dependence graph edge from dpred -&gt; dsucc
4222 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4223   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4224   dpred-&gt;set_out_head(e);
4225   dsucc-&gt;set_in_head(e);
4226   return e;
4227 }
4228 
4229 // ========================== DepMem ========================
4230 
4231 //------------------------------in_cnt---------------------------
4232 int DepMem::in_cnt() {
4233   int ct = 0;
4234   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4235   return ct;
4236 }
4237 
4238 //------------------------------out_cnt---------------------------
4239 int DepMem::out_cnt() {
4240   int ct = 0;
4241   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4242   return ct;
4243 }
4244 
4245 //------------------------------print-----------------------------
4246 void DepMem::print() {
4247 #ifndef PRODUCT
4248   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4249   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4250     Node* pred = p-&gt;pred()-&gt;node();
4251     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4252   }
4253   tty-&gt;print(&quot;) [&quot;);
4254   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4255     Node* succ = s-&gt;succ()-&gt;node();
4256     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4257   }
4258   tty-&gt;print_cr(&quot; ]&quot;);
4259 #endif
4260 }
4261 
4262 // =========================== DepEdge =========================
4263 
4264 //------------------------------DepPreds---------------------------
4265 void DepEdge::print() {
4266 #ifndef PRODUCT
4267   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4268 #endif
4269 }
4270 
4271 // =========================== DepPreds =========================
4272 // Iterator over predecessor edges in the dependence graph.
4273 
4274 //------------------------------DepPreds---------------------------
4275 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4276   _n = n;
4277   _done = false;
4278   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4279     _next_idx = MemNode::Address;
4280     _end_idx  = n-&gt;req();
4281     _dep_next = dg.dep(_n)-&gt;in_head();
4282   } else if (_n-&gt;is_Mem()) {
4283     _next_idx = 0;
4284     _end_idx  = 0;
4285     _dep_next = dg.dep(_n)-&gt;in_head();
4286   } else {
4287     _next_idx = 1;
4288     _end_idx  = _n-&gt;req();
4289     _dep_next = NULL;
4290   }
4291   next();
4292 }
4293 
4294 //------------------------------next---------------------------
4295 void DepPreds::next() {
4296   if (_dep_next != NULL) {
4297     _current  = _dep_next-&gt;pred()-&gt;node();
4298     _dep_next = _dep_next-&gt;next_in();
4299   } else if (_next_idx &lt; _end_idx) {
4300     _current  = _n-&gt;in(_next_idx++);
4301   } else {
4302     _done = true;
4303   }
4304 }
4305 
4306 // =========================== DepSuccs =========================
4307 // Iterator over successor edges in the dependence graph.
4308 
4309 //------------------------------DepSuccs---------------------------
4310 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4311   _n = n;
4312   _done = false;
4313   if (_n-&gt;is_Load()) {
4314     _next_idx = 0;
4315     _end_idx  = _n-&gt;outcnt();
4316     _dep_next = dg.dep(_n)-&gt;out_head();
4317   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4318     _next_idx = 0;
4319     _end_idx  = 0;
4320     _dep_next = dg.dep(_n)-&gt;out_head();
4321   } else {
4322     _next_idx = 0;
4323     _end_idx  = _n-&gt;outcnt();
4324     _dep_next = NULL;
4325   }
4326   next();
4327 }
4328 
4329 //-------------------------------next---------------------------
4330 void DepSuccs::next() {
4331   if (_dep_next != NULL) {
4332     _current  = _dep_next-&gt;succ()-&gt;node();
4333     _dep_next = _dep_next-&gt;next_out();
4334   } else if (_next_idx &lt; _end_idx) {
4335     _current  = _n-&gt;raw_out(_next_idx++);
4336   } else {
4337     _done = true;
4338   }
4339 }
4340 
4341 //
4342 // --------------------------------- vectorization/simd -----------------------------------
4343 //
4344 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4345   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4346 }
4347 bool SuperWord::same_generation(Node* a, Node* b) const {
4348   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4349 }
4350 
4351 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4352   assert(in_bb(ld), &quot;must be in block&quot;);
4353   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4354 #ifndef PRODUCT
4355     if (_vector_loop_debug) {
4356       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4357         _clone_map.gen(ld-&gt;_idx));
4358     }
4359 #endif
4360     return NULL; //we think that any ld in the first gen being vectorizable
4361   }
4362 
4363   Node* mem = ld-&gt;in(MemNode::Memory);
4364   if (mem-&gt;outcnt() &lt;= 1) {
4365     // we don&#39;t want to remove the only edge from mem node to load
4366 #ifndef PRODUCT
4367     if (_vector_loop_debug) {
4368       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4369         mem-&gt;_idx, ld-&gt;_idx);
4370       ld-&gt;dump();
4371       mem-&gt;dump();
4372     }
4373 #endif
4374     return NULL;
4375   }
4376   if (!in_bb(mem) || same_generation(mem, ld)) {
4377 #ifndef PRODUCT
4378     if (_vector_loop_debug) {
4379       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4380         _clone_map.gen(mem-&gt;_idx));
4381     }
4382 #endif
4383     return NULL; // does not depend on loop volatile node or depends on the same generation
4384   }
4385 
4386   //otherwise first node should depend on mem-phi
4387   Node* first = first_node(ld);
4388   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4389   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4390   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4391 #ifndef PRODUCT
4392     if (_vector_loop_debug) {
4393       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4394       ld-&gt;dump();
4395       first-&gt;dump();
4396     }
4397 #endif
4398     return NULL;
4399   }
4400 
4401   Node* tail = 0;
4402   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4403     if (_mem_slice_head.at(m) == phi) {
4404       tail = _mem_slice_tail.at(m);
4405     }
4406   }
4407   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4408 #ifndef PRODUCT
4409     if (_vector_loop_debug) {
4410       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4411         ld-&gt;_idx, phi-&gt;_idx);
4412       ld-&gt;dump();
4413       phi-&gt;dump();
4414     }
4415 #endif
4416     return NULL;
4417   }
4418 
4419   // now all conditions are met
4420   return phi;
4421 }
4422 
4423 Node* SuperWord::first_node(Node* nd) {
4424   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4425     Node* nnn = _iteration_first.at(ii);
4426     if (same_origin_idx(nnn, nd)) {
4427 #ifndef PRODUCT
4428       if (_vector_loop_debug) {
4429         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4430           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4431       }
4432 #endif
4433       return nnn;
4434     }
4435   }
4436 
4437 #ifndef PRODUCT
4438   if (_vector_loop_debug) {
4439     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4440       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4441   }
4442 #endif
4443   return 0;
4444 }
4445 
4446 Node* SuperWord::last_node(Node* nd) {
4447   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4448     Node* nnn = _iteration_last.at(ii);
4449     if (same_origin_idx(nnn, nd)) {
4450 #ifndef PRODUCT
4451       if (_vector_loop_debug) {
4452         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4453           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4454       }
4455 #endif
4456       return nnn;
4457     }
4458   }
4459   return 0;
4460 }
4461 
4462 int SuperWord::mark_generations() {
4463   Node *ii_err = NULL, *tail_err = NULL;
4464   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4465     Node* phi  = _mem_slice_head.at(i);
4466     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4467 
4468     Node* tail = _mem_slice_tail.at(i);
4469     if (_ii_last == -1) {
4470       tail_err = tail;
4471       _ii_last = _clone_map.gen(tail-&gt;_idx);
4472     }
4473     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4474 #ifndef PRODUCT
4475       if (TraceSuperWord &amp;&amp; Verbose) {
4476         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4477         tail-&gt;dump();
4478         tail_err-&gt;dump();
4479       }
4480 #endif
4481       return -1;
4482     }
4483 
4484     // find first iteration in the loop
4485     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4486       Node* ii = phi-&gt;fast_out(i);
4487       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4488         if (_ii_first == -1) {
4489           ii_err = ii;
4490           _ii_first = _clone_map.gen(ii-&gt;_idx);
4491         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4492 #ifndef PRODUCT
4493           if (TraceSuperWord &amp;&amp; Verbose) {
4494             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4495             ii-&gt;dump();
4496             if (ii_err!= 0) {
4497               ii_err-&gt;dump();
4498             }
4499           }
4500 #endif
4501           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4502         }
4503       }
4504     }//for (DUIterator_Fast imax,
4505   }//for (int i...
4506 
4507   if (_ii_first == -1 || _ii_last == -1) {
4508     if (TraceSuperWord &amp;&amp; Verbose) {
4509       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4510     }
4511     return -1; // something vent wrong
4512   }
4513   // collect nodes in the first and last generations
4514   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4515   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4516   for (int j = 0; j &lt; _block.length(); j++) {
4517     Node* n = _block.at(j);
4518     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4519     if ((signed)gen == _ii_first) {
4520       _iteration_first.push(n);
4521     } else if ((signed)gen == _ii_last) {
4522       _iteration_last.push(n);
4523     }
4524   }
4525 
4526   // building order of iterations
4527   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4528     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4529     Node* nd = ii_err;
4530     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4531       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4532       bool found = false;
4533       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4534         Node* use = nd-&gt;fast_out(i);
4535         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4536           found = true;
4537           nd = use;
4538           break;
4539         }
4540       }//for
4541 
4542       if (found == false) {
4543         if (TraceSuperWord &amp;&amp; Verbose) {
4544           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4545         }
4546         _ii_order.clear();
4547         return -1;
4548       }
4549     } //while
4550     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4551   }
4552 
4553 #ifndef PRODUCT
4554   if (_vector_loop_debug) {
4555     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4556     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4557     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4558     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4559     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4560     tty-&gt;print_cr(&quot; &quot;);
4561 
4562     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4563     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4564       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4565     }
4566     tty-&gt;print_cr(&quot; &quot;);
4567   }
4568 #endif
4569 
4570   return _ii_first;
4571 }
4572 
4573 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4574   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4575   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4576   Node* gin1 = gold-&gt;in(1);
4577   Node* gin2 = gold-&gt;in(2);
4578   Node* fin1 = fix-&gt;in(1);
4579   Node* fin2 = fix-&gt;in(2);
4580   bool swapped = false;
4581 
4582   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4583     if (same_origin_idx(gin1, fin1) &amp;&amp;
4584         same_origin_idx(gin2, fin2)) {
4585       return true; // nothing to fix
4586     }
4587     if (same_origin_idx(gin1, fin2) &amp;&amp;
4588         same_origin_idx(gin2, fin1)) {
4589       fix-&gt;swap_edges(1, 2);
4590       swapped = true;
4591     }
4592   }
4593   // at least one input comes from outside of bb
4594   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4595     return true; // nothing to fix
4596   }
4597   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4598     fix-&gt;swap_edges(1, 2);
4599     swapped = true;
4600   }
4601 
4602   if (swapped) {
4603 #ifndef PRODUCT
4604     if (_vector_loop_debug) {
4605       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4606     }
4607 #endif
4608     return true;
4609   }
4610 
4611   if (TraceSuperWord &amp;&amp; Verbose) {
4612     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4613   }
4614 
4615   return false;
4616 }
4617 
4618 bool SuperWord::pack_parallel() {
4619 #ifndef PRODUCT
4620   if (_vector_loop_debug) {
4621     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4622   }
4623 #endif
4624 
4625   _packset.clear();
4626 
4627   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4628     Node* nd = _iteration_first.at(ii);
4629     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4630       Node_List* pk = new Node_List();
4631       pk-&gt;push(nd);
4632       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4633         for (int kk = 0; kk &lt; _block.length(); kk++) {
4634           Node* clone = _block.at(kk);
4635           if (same_origin_idx(clone, nd) &amp;&amp;
4636               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4637             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4638               fix_commutative_inputs(nd, clone);
4639             }
4640             pk-&gt;push(clone);
4641             if (pk-&gt;size() == 4) {
4642               _packset.append(pk);
4643 #ifndef PRODUCT
4644               if (_vector_loop_debug) {
4645                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4646                 pk-&gt;dump();
4647               }
4648 #endif
4649               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4650                 pk = new Node_List();
4651               }
4652             }
4653             break;
4654           }
4655         }
4656       }//for
4657     }//if
4658   }//for
4659 
4660 #ifndef PRODUCT
4661   if (_vector_loop_debug) {
4662     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4663   }
4664 #endif
4665 
4666   return true;
4667 }
4668 
4669 bool SuperWord::hoist_loads_in_graph() {
4670   GrowableArray&lt;Node*&gt; loads;
4671 
4672 #ifndef PRODUCT
4673   if (_vector_loop_debug) {
4674     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4675   }
4676 #endif
4677 
4678   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4679     Node* n = _mem_slice_head.at(i);
4680     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4681       if (TraceSuperWord &amp;&amp; Verbose) {
4682         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4683       }
4684       continue;
4685     }
4686 
4687 #ifndef PRODUCT
4688     if (_vector_loop_debug) {
4689       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4690     }
4691 #endif
4692 
4693     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4694       Node* ld = n-&gt;fast_out(i);
4695       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4696         for (int i = 0; i &lt; _block.length(); i++) {
4697           Node* ld2 = _block.at(i);
4698           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4699               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4700 #ifndef PRODUCT
4701             if (_vector_loop_debug) {
4702               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4703                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4704             }
4705 #endif
4706             // could not do on-the-fly, since iterator is immutable
4707             loads.push(ld2);
4708           }
4709         }// for
4710       }//if
4711     }//for (DUIterator_Fast imax,
4712   }//for (int i = 0; i
4713 
4714   for (int i = 0; i &lt; loads.length(); i++) {
4715     LoadNode* ld = loads.at(i)-&gt;as_Load();
4716     Node* phi = find_phi_for_mem_dep(ld);
4717     if (phi != NULL) {
4718 #ifndef PRODUCT
4719       if (_vector_loop_debug) {
4720         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4721           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4722       }
4723 #endif
4724       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4725     }
4726   }//for
4727 
4728   restart(); // invalidate all basic structures, since we rebuilt the graph
4729 
4730   if (TraceSuperWord &amp;&amp; Verbose) {
4731     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4732   }
4733 
4734   return true;
4735 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
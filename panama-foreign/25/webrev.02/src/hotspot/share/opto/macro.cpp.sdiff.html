<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;

  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/loopnode.hpp&quot;
  40 #include &quot;opto/macro.hpp&quot;
  41 #include &quot;opto/memnode.hpp&quot;
  42 #include &quot;opto/narrowptrnode.hpp&quot;
  43 #include &quot;opto/node.hpp&quot;
  44 #include &quot;opto/opaquenode.hpp&quot;
  45 #include &quot;opto/phaseX.hpp&quot;
  46 #include &quot;opto/rootnode.hpp&quot;
  47 #include &quot;opto/runtime.hpp&quot;
  48 #include &quot;opto/subnode.hpp&quot;

  49 #include &quot;opto/type.hpp&quot;
  50 #include &quot;runtime/sharedRuntime.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;

  52 #if INCLUDE_G1GC
  53 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  54 #endif // INCLUDE_G1GC
  55 #if INCLUDE_SHENANDOAHGC
  56 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  57 #endif
  58 
  59 
  60 //
  61 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  62 // Returns the number of replacements made.
  63 //
  64 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  65   int nreplacements = 0;
  66   uint req = use-&gt;req();
  67   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  68     Node *uin = use-&gt;in(j);
  69     if (uin == oldref) {
  70       if (j &lt; req)
  71         use-&gt;set_req(j, newref);
</pre>
<hr />
<pre>
2515   // No exceptions for unlocking
2516   // Capture slow path
2517   // disconnect fall-through projection from call and create a new one
2518   // hook up users of fall-through projection to region
2519   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2520   transform_later(slow_ctrl);
2521   _igvn.hash_delete(_fallthroughproj);
2522   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2523   region-&gt;init_req(1, slow_ctrl);
2524   // region inputs are now complete
2525   transform_later(region);
2526   _igvn.replace_node(_fallthroughproj, region);
2527 
2528   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2529   mem_phi-&gt;init_req(1, memproj );
2530   mem_phi-&gt;init_req(2, mem);
2531   transform_later(mem_phi);
2532   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2533 }
2534 





































2535 //---------------------------eliminate_macro_nodes----------------------
2536 // Eliminate scalar replaced allocations and associated locks.
2537 void PhaseMacroExpand::eliminate_macro_nodes() {
2538   if (C-&gt;macro_count() == 0)
2539     return;
2540 
2541   // First, attempt to eliminate locks
2542   int cnt = C-&gt;macro_count();
2543   for (int i=0; i &lt; cnt; i++) {
2544     Node *n = C-&gt;macro_node(i);
2545     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2546       // Before elimination mark all associated (same box and obj)
2547       // lock and unlock nodes.
2548       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2549     }
2550   }
2551   bool progress = true;
2552   while (progress) {
2553     progress = false;
2554     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
</pre>
<hr />
<pre>
2571       Node * n = C-&gt;macro_node(i-1);
2572       bool success = false;
2573       debug_only(int old_macro_count = C-&gt;macro_count(););
2574       switch (n-&gt;class_id()) {
2575       case Node::Class_Allocate:
2576       case Node::Class_AllocateArray:
2577         success = eliminate_allocate_node(n-&gt;as_Allocate());
2578         break;
2579       case Node::Class_CallStaticJava:
2580         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2581         break;
2582       case Node::Class_Lock:
2583       case Node::Class_Unlock:
2584         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2585         _has_locks = true;
2586         break;
2587       case Node::Class_ArrayCopy:
2588         break;
2589       case Node::Class_OuterStripMinedLoop:
2590         break;


2591       default:
2592         assert(n-&gt;Opcode() == Op_LoopLimit ||
2593                n-&gt;Opcode() == Op_Opaque1   ||
2594                n-&gt;Opcode() == Op_Opaque2   ||
2595                n-&gt;Opcode() == Op_Opaque3   ||
2596                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2597                &quot;unknown node type in macro list&quot;);
2598       }
2599       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2600       progress = progress || success;
2601     }
2602   }
2603 }
2604 
2605 //------------------------------expand_macro_nodes----------------------
2606 //  Returns true if a failure occurred.
2607 bool PhaseMacroExpand::expand_macro_nodes() {
2608   // Last attempt to eliminate macro nodes.
2609   eliminate_macro_nodes();
2610 
</pre>
<hr />
<pre>
2677     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2678     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2679       // node is unreachable, so don&#39;t try to expand it
2680       C-&gt;remove_macro_node(n);
2681       continue;
2682     }
2683     debug_only(int old_macro_count = C-&gt;macro_count(););
2684     switch (n-&gt;class_id()) {
2685     case Node::Class_Lock:
2686       expand_lock_node(n-&gt;as_Lock());
2687       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2688       break;
2689     case Node::Class_Unlock:
2690       expand_unlock_node(n-&gt;as_Unlock());
2691       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2692       break;
2693     case Node::Class_ArrayCopy:
2694       expand_arraycopy_node(n-&gt;as_ArrayCopy());
2695       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2696       break;




2697     }
2698     if (C-&gt;failing())  return true;
2699   }
2700 
2701   // All nodes except Allocate nodes are expanded now. There could be
2702   // new optimization opportunities (such as folding newly created
2703   // load from a just allocated object). Run IGVN.
2704   _igvn.set_delay_transform(false);
2705   _igvn.optimize();
2706   if (C-&gt;failing())  return true;
2707 
2708   _igvn.set_delay_transform(true);
2709 
2710   // expand &quot;macro&quot; nodes
2711   // nodes are removed from the macro list as they are processed
2712   while (C-&gt;macro_count() &gt; 0) {
2713     int macro_count = C-&gt;macro_count();
2714     Node * n = C-&gt;macro_node(macro_count-1);
2715     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2716     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;compiler/compileLog.hpp&quot;
  27 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/universe.hpp&quot;
  30 #include &quot;opto/addnode.hpp&quot;
  31 #include &quot;opto/arraycopynode.hpp&quot;
  32 #include &quot;opto/callnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/cfgnode.hpp&quot;
  35 #include &quot;opto/compile.hpp&quot;
  36 #include &quot;opto/convertnode.hpp&quot;
  37 #include &quot;opto/graphKit.hpp&quot;
<span class="line-added">  38 #include &quot;opto/intrinsicnode.hpp&quot;</span>
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/loopnode.hpp&quot;
  41 #include &quot;opto/macro.hpp&quot;
  42 #include &quot;opto/memnode.hpp&quot;
  43 #include &quot;opto/narrowptrnode.hpp&quot;
  44 #include &quot;opto/node.hpp&quot;
  45 #include &quot;opto/opaquenode.hpp&quot;
  46 #include &quot;opto/phaseX.hpp&quot;
  47 #include &quot;opto/rootnode.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
<span class="line-added">  50 #include &quot;opto/subtypenode.hpp&quot;</span>
  51 #include &quot;opto/type.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  54 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  55 #if INCLUDE_G1GC
  56 #include &quot;gc/g1/g1ThreadLocalData.hpp&quot;
  57 #endif // INCLUDE_G1GC
  58 #if INCLUDE_SHENANDOAHGC
  59 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
  60 #endif
  61 
  62 
  63 //
  64 // Replace any references to &quot;oldref&quot; in inputs to &quot;use&quot; with &quot;newref&quot;.
  65 // Returns the number of replacements made.
  66 //
  67 int PhaseMacroExpand::replace_input(Node *use, Node *oldref, Node *newref) {
  68   int nreplacements = 0;
  69   uint req = use-&gt;req();
  70   for (uint j = 0; j &lt; use-&gt;len(); j++) {
  71     Node *uin = use-&gt;in(j);
  72     if (uin == oldref) {
  73       if (j &lt; req)
  74         use-&gt;set_req(j, newref);
</pre>
<hr />
<pre>
2518   // No exceptions for unlocking
2519   // Capture slow path
2520   // disconnect fall-through projection from call and create a new one
2521   // hook up users of fall-through projection to region
2522   Node *slow_ctrl = _fallthroughproj-&gt;clone();
2523   transform_later(slow_ctrl);
2524   _igvn.hash_delete(_fallthroughproj);
2525   _fallthroughproj-&gt;disconnect_inputs(NULL, C);
2526   region-&gt;init_req(1, slow_ctrl);
2527   // region inputs are now complete
2528   transform_later(region);
2529   _igvn.replace_node(_fallthroughproj, region);
2530 
2531   Node *memproj = transform_later(new ProjNode(call, TypeFunc::Memory) );
2532   mem_phi-&gt;init_req(1, memproj );
2533   mem_phi-&gt;init_req(2, mem);
2534   transform_later(mem_phi);
2535   _igvn.replace_node(_memproj_fallthrough, mem_phi);
2536 }
2537 
<span class="line-added">2538 void PhaseMacroExpand::expand_subtypecheck_node(SubTypeCheckNode *check) {</span>
<span class="line-added">2539   assert(check-&gt;in(SubTypeCheckNode::Control) == NULL, &quot;should be pinned&quot;);</span>
<span class="line-added">2540   Node* bol = check-&gt;unique_out();</span>
<span class="line-added">2541   Node* obj_or_subklass = check-&gt;in(SubTypeCheckNode::ObjOrSubKlass);</span>
<span class="line-added">2542   Node* superklass = check-&gt;in(SubTypeCheckNode::SuperKlass);</span>
<span class="line-added">2543   assert(bol-&gt;is_Bool() &amp;&amp; bol-&gt;as_Bool()-&gt;_test._test == BoolTest::ne, &quot;unexpected bool node&quot;);</span>
<span class="line-added">2544 </span>
<span class="line-added">2545   for (DUIterator_Last imin, i = bol-&gt;last_outs(imin); i &gt;= imin; --i) {</span>
<span class="line-added">2546     Node* iff = bol-&gt;last_out(i);</span>
<span class="line-added">2547     assert(iff-&gt;is_If(), &quot;where&#39;s the if?&quot;);</span>
<span class="line-added">2548 </span>
<span class="line-added">2549     if (iff-&gt;in(0)-&gt;is_top()) {</span>
<span class="line-added">2550       _igvn.replace_input_of(iff, 1, C-&gt;top());</span>
<span class="line-added">2551       continue;</span>
<span class="line-added">2552     }</span>
<span class="line-added">2553 </span>
<span class="line-added">2554     Node* iftrue = iff-&gt;as_If()-&gt;proj_out(1);</span>
<span class="line-added">2555     Node* iffalse = iff-&gt;as_If()-&gt;proj_out(0);</span>
<span class="line-added">2556     Node* ctrl = iff-&gt;in(0);</span>
<span class="line-added">2557 </span>
<span class="line-added">2558     Node* subklass = NULL;</span>
<span class="line-added">2559     if (_igvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
<span class="line-added">2560       subklass = obj_or_subklass;</span>
<span class="line-added">2561     } else {</span>
<span class="line-added">2562       Node* k_adr = basic_plus_adr(obj_or_subklass, oopDesc::klass_offset_in_bytes());</span>
<span class="line-added">2563       subklass = _igvn.transform(LoadKlassNode::make(_igvn, NULL, C-&gt;immutable_memory(), k_adr, TypeInstPtr::KLASS));</span>
<span class="line-added">2564     }</span>
<span class="line-added">2565 </span>
<span class="line-added">2566     Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, NULL, _igvn);</span>
<span class="line-added">2567 </span>
<span class="line-added">2568     _igvn.replace_input_of(iff, 0, C-&gt;top());</span>
<span class="line-added">2569     _igvn.replace_node(iftrue, not_subtype_ctrl);</span>
<span class="line-added">2570     _igvn.replace_node(iffalse, ctrl);</span>
<span class="line-added">2571   }</span>
<span class="line-added">2572   _igvn.replace_node(check, C-&gt;top());</span>
<span class="line-added">2573 }</span>
<span class="line-added">2574 </span>
2575 //---------------------------eliminate_macro_nodes----------------------
2576 // Eliminate scalar replaced allocations and associated locks.
2577 void PhaseMacroExpand::eliminate_macro_nodes() {
2578   if (C-&gt;macro_count() == 0)
2579     return;
2580 
2581   // First, attempt to eliminate locks
2582   int cnt = C-&gt;macro_count();
2583   for (int i=0; i &lt; cnt; i++) {
2584     Node *n = C-&gt;macro_node(i);
2585     if (n-&gt;is_AbstractLock()) { // Lock and Unlock nodes
2586       // Before elimination mark all associated (same box and obj)
2587       // lock and unlock nodes.
2588       mark_eliminated_locking_nodes(n-&gt;as_AbstractLock());
2589     }
2590   }
2591   bool progress = true;
2592   while (progress) {
2593     progress = false;
2594     for (int i = C-&gt;macro_count(); i &gt; 0; i--) {
</pre>
<hr />
<pre>
2611       Node * n = C-&gt;macro_node(i-1);
2612       bool success = false;
2613       debug_only(int old_macro_count = C-&gt;macro_count(););
2614       switch (n-&gt;class_id()) {
2615       case Node::Class_Allocate:
2616       case Node::Class_AllocateArray:
2617         success = eliminate_allocate_node(n-&gt;as_Allocate());
2618         break;
2619       case Node::Class_CallStaticJava:
2620         success = eliminate_boxing_node(n-&gt;as_CallStaticJava());
2621         break;
2622       case Node::Class_Lock:
2623       case Node::Class_Unlock:
2624         assert(!n-&gt;as_AbstractLock()-&gt;is_eliminated(), &quot;sanity&quot;);
2625         _has_locks = true;
2626         break;
2627       case Node::Class_ArrayCopy:
2628         break;
2629       case Node::Class_OuterStripMinedLoop:
2630         break;
<span class="line-added">2631       case Node::Class_SubTypeCheck:</span>
<span class="line-added">2632         break;</span>
2633       default:
2634         assert(n-&gt;Opcode() == Op_LoopLimit ||
2635                n-&gt;Opcode() == Op_Opaque1   ||
2636                n-&gt;Opcode() == Op_Opaque2   ||
2637                n-&gt;Opcode() == Op_Opaque3   ||
2638                BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;is_gc_barrier_node(n),
2639                &quot;unknown node type in macro list&quot;);
2640       }
2641       assert(success == (C-&gt;macro_count() &lt; old_macro_count), &quot;elimination reduces macro count&quot;);
2642       progress = progress || success;
2643     }
2644   }
2645 }
2646 
2647 //------------------------------expand_macro_nodes----------------------
2648 //  Returns true if a failure occurred.
2649 bool PhaseMacroExpand::expand_macro_nodes() {
2650   // Last attempt to eliminate macro nodes.
2651   eliminate_macro_nodes();
2652 
</pre>
<hr />
<pre>
2719     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2720     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
2721       // node is unreachable, so don&#39;t try to expand it
2722       C-&gt;remove_macro_node(n);
2723       continue;
2724     }
2725     debug_only(int old_macro_count = C-&gt;macro_count(););
2726     switch (n-&gt;class_id()) {
2727     case Node::Class_Lock:
2728       expand_lock_node(n-&gt;as_Lock());
2729       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2730       break;
2731     case Node::Class_Unlock:
2732       expand_unlock_node(n-&gt;as_Unlock());
2733       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2734       break;
2735     case Node::Class_ArrayCopy:
2736       expand_arraycopy_node(n-&gt;as_ArrayCopy());
2737       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);
2738       break;
<span class="line-added">2739     case Node::Class_SubTypeCheck:</span>
<span class="line-added">2740       expand_subtypecheck_node(n-&gt;as_SubTypeCheck());</span>
<span class="line-added">2741       assert(C-&gt;macro_count() == (old_macro_count - 1), &quot;expansion must have deleted one node from macro list&quot;);</span>
<span class="line-added">2742       break;</span>
2743     }
2744     if (C-&gt;failing())  return true;
2745   }
2746 
2747   // All nodes except Allocate nodes are expanded now. There could be
2748   // new optimization opportunities (such as folding newly created
2749   // load from a just allocated object). Run IGVN.
2750   _igvn.set_delay_transform(false);
2751   _igvn.optimize();
2752   if (C-&gt;failing())  return true;
2753 
2754   _igvn.set_delay_transform(true);
2755 
2756   // expand &quot;macro&quot; nodes
2757   // nodes are removed from the macro list as they are processed
2758   while (C-&gt;macro_count() &gt; 0) {
2759     int macro_count = C-&gt;macro_count();
2760     Node * n = C-&gt;macro_node(macro_count-1);
2761     assert(n-&gt;is_macro(), &quot;only macro nodes expected here&quot;);
2762     if (_igvn.type(n) == Type::TOP || (n-&gt;in(0) != NULL &amp;&amp; n-&gt;in(0)-&gt;is_top())) {
</pre>
</td>
</tr>
</table>
<center><a href="loopopts.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macro.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
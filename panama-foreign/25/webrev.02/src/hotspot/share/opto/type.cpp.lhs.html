<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
<a name="1" id="anc1"></a>
  42 
  43 // Portions of code courtesy of Clifford Click
  44 
  45 // Optimization - Graph Style
  46 
  47 // Dictionary of types shared among compilations.
  48 Dict* Type::_shared_type_dict = NULL;
  49 
  50 // Array which maps compiler types to Basic Types
  51 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  52   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  53   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  54   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  55   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  56   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  57   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  58   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  59   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  60   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  61   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  62 
  63 #ifdef SPARC
  64   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  65   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
  66   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  67   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  68   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  69 #elif defined(PPC64)
  70   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  71   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  72   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  73   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  74   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  75 #elif defined(S390)
  76   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  77   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  78   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  79   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  80   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  81 #else // all other
  82   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  83   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  84   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  85   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  86   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  87 #endif
  88   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  89   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  90   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  91   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  92   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  93   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  94   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  95   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  96   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  97   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  98   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
  99   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 100   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 101   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 102   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 103   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 104   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 105   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 106 };
 107 
 108 // Map ideal registers (machine types) to ideal types
 109 const Type *Type::mreg2type[_last_machine_leaf];
 110 
 111 // Map basic types to canonical Type* pointers.
 112 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 113 
 114 // Map basic types to constant-zero Types.
 115 const Type* Type::            _zero_type[T_CONFLICT+1];
 116 
 117 // Map basic types to array-body alias types.
 118 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 119 
 120 //=============================================================================
 121 // Convenience common pre-built types.
 122 const Type *Type::ABIO;         // State-of-machine only
 123 const Type *Type::BOTTOM;       // All values
 124 const Type *Type::CONTROL;      // Control only
 125 const Type *Type::DOUBLE;       // All doubles
 126 const Type *Type::FLOAT;        // All floats
 127 const Type *Type::HALF;         // Placeholder half of doublewide type
 128 const Type *Type::MEMORY;       // Abstract store only
 129 const Type *Type::RETURN_ADDRESS;
 130 const Type *Type::TOP;          // No values in set
 131 
 132 //------------------------------get_const_type---------------------------
 133 const Type* Type::get_const_type(ciType* type) {
 134   if (type == NULL) {
 135     return NULL;
 136   } else if (type-&gt;is_primitive_type()) {
 137     return get_const_basic_type(type-&gt;basic_type());
 138   } else {
 139     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 140   }
 141 }
 142 
 143 //---------------------------array_element_basic_type---------------------------------
 144 // Mapping to the array element&#39;s basic type.
 145 BasicType Type::array_element_basic_type() const {
 146   BasicType bt = basic_type();
 147   if (bt == T_INT) {
 148     if (this == TypeInt::INT)   return T_INT;
 149     if (this == TypeInt::CHAR)  return T_CHAR;
 150     if (this == TypeInt::BYTE)  return T_BYTE;
 151     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 152     if (this == TypeInt::SHORT) return T_SHORT;
 153     return T_VOID;
 154   }
 155   return bt;
 156 }
 157 
 158 // For two instance arrays of same dimension, return the base element types.
 159 // Otherwise or if the arrays have different dimensions, return NULL.
 160 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 161                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 162 
 163   if (e1) *e1 = NULL;
 164   if (e2) *e2 = NULL;
 165   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 166   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 167 
 168   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 169     // Handle multidimensional arrays
 170     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 171     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 172     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 173       a1tap = a1tp-&gt;is_aryptr();
 174       a2tap = a2tp-&gt;is_aryptr();
 175       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 176       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 177     }
 178     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 179       if (e1) *e1 = a1tp-&gt;is_instptr();
 180       if (e2) *e2 = a2tp-&gt;is_instptr();
 181     }
 182   }
 183 }
 184 
 185 //---------------------------get_typeflow_type---------------------------------
 186 // Import a type produced by ciTypeFlow.
 187 const Type* Type::get_typeflow_type(ciType* type) {
 188   switch (type-&gt;basic_type()) {
 189 
 190   case ciTypeFlow::StateVector::T_BOTTOM:
 191     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 192     return Type::BOTTOM;
 193 
 194   case ciTypeFlow::StateVector::T_TOP:
 195     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 196     return Type::TOP;
 197 
 198   case ciTypeFlow::StateVector::T_NULL:
 199     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 200     return TypePtr::NULL_PTR;
 201 
 202   case ciTypeFlow::StateVector::T_LONG2:
 203     // The ciTypeFlow pass pushes a long, then the half.
 204     // We do the same.
 205     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 206     return TypeInt::TOP;
 207 
 208   case ciTypeFlow::StateVector::T_DOUBLE2:
 209     // The ciTypeFlow pass pushes double, then the half.
 210     // Our convention is the same.
 211     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 212     return Type::TOP;
 213 
 214   case T_ADDRESS:
 215     assert(type-&gt;is_return_address(), &quot;&quot;);
 216     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 217 
 218   default:
 219     // make sure we did not mix up the cases:
 220     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 221     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 222     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 223     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 224     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 225     assert(!type-&gt;is_return_address(), &quot;&quot;);
 226 
 227     return Type::get_const_type(type);
 228   }
 229 }
 230 
 231 
 232 //-----------------------make_from_constant------------------------------------
 233 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 234                                      int stable_dimension, bool is_narrow_oop,
 235                                      bool is_autobox_cache) {
 236   switch (constant.basic_type()) {
 237     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 238     case T_CHAR:     return TypeInt::make(constant.as_char());
 239     case T_BYTE:     return TypeInt::make(constant.as_byte());
 240     case T_SHORT:    return TypeInt::make(constant.as_short());
 241     case T_INT:      return TypeInt::make(constant.as_int());
 242     case T_LONG:     return TypeLong::make(constant.as_long());
 243     case T_FLOAT:    return TypeF::make(constant.as_float());
 244     case T_DOUBLE:   return TypeD::make(constant.as_double());
 245     case T_ARRAY:
 246     case T_OBJECT: {
 247         const Type* con_type = NULL;
 248         ciObject* oop_constant = constant.as_object();
 249         if (oop_constant-&gt;is_null_object()) {
 250           con_type = Type::get_zero_type(T_OBJECT);
 251         } else {
 252           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 253           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 254           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 255             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 256           }
 257           if (stable_dimension &gt; 0) {
 258             assert(FoldStableValues, &quot;sanity&quot;);
 259             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 260             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 261           }
 262         }
 263         if (is_narrow_oop) {
 264           con_type = con_type-&gt;make_narrowoop();
 265         }
 266         return con_type;
 267       }
 268     case T_ILLEGAL:
 269       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 270       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 271       return NULL;
 272     default:
 273       // Fall through to failure
 274       return NULL;
 275   }
 276 }
 277 
 278 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 279   BasicType conbt = con.basic_type();
 280   switch (conbt) {
 281     case T_BOOLEAN: conbt = T_BYTE;   break;
 282     case T_ARRAY:   conbt = T_OBJECT; break;
 283     default:                          break;
 284   }
 285   switch (loadbt) {
 286     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 287     case T_NARROWOOP: loadbt = T_OBJECT; break;
 288     case T_ARRAY:     loadbt = T_OBJECT; break;
 289     case T_ADDRESS:   loadbt = T_OBJECT; break;
 290     default:                             break;
 291   }
 292   if (conbt == loadbt) {
 293     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 294       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 295       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 296     } else {
 297       return con;
 298     }
 299   }
 300   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 301     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 302     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 303   }
 304   return ciConstant(); // T_ILLEGAL
 305 }
 306 
 307 // Try to constant-fold a stable array element.
 308 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 309                                                    BasicType loadbt, bool is_unsigned_load) {
 310   // Decode the results of GraphKit::array_element_address.
 311   ciConstant element_value = array-&gt;element_value_by_offset(off);
 312   if (element_value.basic_type() == T_ILLEGAL) {
 313     return NULL; // wrong offset
 314   }
 315   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 316 
 317   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 318          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 319 
 320   if (con.is_valid() &amp;&amp;          // not a mismatched access
 321       !con.is_null_or_zero()) {  // not a default value
 322     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 323     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 324   }
 325   return NULL;
 326 }
 327 
 328 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 329   ciField* field;
 330   ciType* type = holder-&gt;java_mirror_type();
 331   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 332     // Static field
 333     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 334   } else {
 335     // Instance field
 336     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 337   }
 338   if (field == NULL) {
 339     return NULL; // Wrong offset
 340   }
 341   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 342 }
 343 
 344 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 345                                            BasicType loadbt, bool is_unsigned_load) {
 346   if (!field-&gt;is_constant()) {
 347     return NULL; // Non-constant field
 348   }
 349   ciConstant field_value;
 350   if (field-&gt;is_static()) {
 351     // final static field
 352     field_value = field-&gt;constant_value();
 353   } else if (holder != NULL) {
 354     // final or stable non-static field
 355     // Treat final non-static fields of trusted classes (classes in
 356     // java.lang.invoke and sun.invoke packages and subpackages) as
 357     // compile time constants.
 358     field_value = field-&gt;constant_value_of(holder);
 359   }
 360   if (!field_value.is_valid()) {
 361     return NULL; // Not a constant
 362   }
 363 
 364   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 365 
 366   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 367          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 368 
 369   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 370   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 371   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 372 
 373   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 374                                             stable_dimension, is_narrow_oop,
 375                                             field-&gt;is_autobox_cache());
 376   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 377     ciCallSite* call_site = holder-&gt;as_call_site();
 378     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 379       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 380       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 381     }
 382   }
 383   return con_type;
 384 }
 385 
 386 //------------------------------make-------------------------------------------
 387 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 388 // and look for an existing copy in the type dictionary.
 389 const Type *Type::make( enum TYPES t ) {
 390   return (new Type(t))-&gt;hashcons();
 391 }
 392 
 393 //------------------------------cmp--------------------------------------------
 394 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 395   if( t1-&gt;_base != t2-&gt;_base )
 396     return 1;                   // Missed badly
 397   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 398   return !t1-&gt;eq(t2);           // Return ZERO if equal
 399 }
 400 
 401 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 402   if (!include_speculative) {
 403     return remove_speculative();
 404   }
 405   return this;
 406 }
 407 
 408 //------------------------------hash-------------------------------------------
 409 int Type::uhash( const Type *const t ) {
 410   return t-&gt;hash();
 411 }
 412 
 413 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 414 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 415 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 416 
 417 //--------------------------Initialize_shared----------------------------------
 418 void Type::Initialize_shared(Compile* current) {
 419   // This method does not need to be locked because the first system
 420   // compilations (stub compilations) occur serially.  If they are
 421   // changed to proceed in parallel, then this section will need
 422   // locking.
 423 
 424   Arena* save = current-&gt;type_arena();
 425   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 426 
 427   current-&gt;set_type_arena(shared_type_arena);
 428   _shared_type_dict =
 429     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 430                                   shared_type_arena, 128 );
 431   current-&gt;set_type_dict(_shared_type_dict);
 432 
 433   // Make shared pre-built types.
 434   CONTROL = make(Control);      // Control only
 435   TOP     = make(Top);          // No values in set
 436   MEMORY  = make(Memory);       // Abstract store only
 437   ABIO    = make(Abio);         // State-of-machine only
 438   RETURN_ADDRESS=make(Return_Address);
 439   FLOAT   = make(FloatBot);     // All floats
 440   DOUBLE  = make(DoubleBot);    // All doubles
 441   BOTTOM  = make(Bottom);       // Everything
 442   HALF    = make(Half);         // Placeholder half of doublewide type
 443 
 444   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 445   TypeF::ONE  = TypeF::make(1.0); // Float 1
 446   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 447   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 448 
 449   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 450   TypeD::ONE  = TypeD::make(1.0); // Double 1
 451   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 452   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 453 
 454   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 455   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 456   TypeInt::ONE     = TypeInt::make( 1);  //  1
 457   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 458   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 459   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 460   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 461   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 462   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 463   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 464   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 465   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 466   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 467   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 468   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 469   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 470   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 471   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 472   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 473   // CmpL is overloaded both as the bytecode computation returning
 474   // a trinary (-1,0,+1) integer result AND as an efficient long
 475   // compare returning optimizer ideal-type flags.
 476   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 477   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 478   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 479   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 480   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 481 
 482   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 483   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 484   TypeLong::ONE     = TypeLong::make( 1);        //  1
 485   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 486   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 487   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 488   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 489   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 490 
 491   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 492   fboth[0] = Type::CONTROL;
 493   fboth[1] = Type::CONTROL;
 494   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 495 
 496   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 497   ffalse[0] = Type::CONTROL;
 498   ffalse[1] = Type::TOP;
 499   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 500 
 501   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 502   fneither[0] = Type::TOP;
 503   fneither[1] = Type::TOP;
 504   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 505 
 506   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 507   ftrue[0] = Type::TOP;
 508   ftrue[1] = Type::CONTROL;
 509   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 510 
 511   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 512   floop[0] = Type::CONTROL;
 513   floop[1] = TypeInt::INT;
 514   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 515 
 516   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);
 517   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);
 518   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);
 519 
 520   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 521   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 522 
 523   const Type **fmembar = TypeTuple::fields(0);
 524   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 525 
 526   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 527   fsc[0] = TypeInt::CC;
 528   fsc[1] = Type::MEMORY;
 529   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 530 
 531   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 532   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 533   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 534   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 535                                            false, 0, oopDesc::mark_offset_in_bytes());
 536   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 537                                            false, 0, oopDesc::klass_offset_in_bytes());
 538   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);
 539 
 540   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);
 541 
 542   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 543   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 544 
 545   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 546 
 547   mreg2type[Op_Node] = Type::BOTTOM;
 548   mreg2type[Op_Set ] = 0;
 549   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 550   mreg2type[Op_RegI] = TypeInt::INT;
 551   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 552   mreg2type[Op_RegF] = Type::FLOAT;
 553   mreg2type[Op_RegD] = Type::DOUBLE;
 554   mreg2type[Op_RegL] = TypeLong::LONG;
 555   mreg2type[Op_RegFlags] = TypeInt::CC;
 556 
 557   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());
 558 
 559   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 560 
 561 #ifdef _LP64
 562   if (UseCompressedOops) {
 563     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 564     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 565   } else
 566 #endif
 567   {
 568     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 569     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 570   }
 571   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);
 572   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);
 573   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);
 574   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);
 575   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);
 576   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);
 577   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);
 578 
 579   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 580   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 581   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 582   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 583   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 584   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 585   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 586   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 587   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 588   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 589   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 590   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 591 
 592   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );
 593   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );
 594 
 595   const Type **fi2c = TypeTuple::fields(2);
 596   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 597   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 598   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 599 
 600   const Type **intpair = TypeTuple::fields(2);
 601   intpair[0] = TypeInt::INT;
 602   intpair[1] = TypeInt::INT;
 603   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 604 
 605   const Type **longpair = TypeTuple::fields(2);
 606   longpair[0] = TypeLong::LONG;
 607   longpair[1] = TypeLong::LONG;
 608   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 609 
 610   const Type **intccpair = TypeTuple::fields(2);
 611   intccpair[0] = TypeInt::INT;
 612   intccpair[1] = TypeInt::CC;
 613   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 614 
 615   const Type **longccpair = TypeTuple::fields(2);
 616   longccpair[0] = TypeLong::LONG;
 617   longccpair[1] = TypeInt::CC;
 618   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 619 
 620   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 621   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 622   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 623   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 624   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 625   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 626   _const_basic_type[T_INT]         = TypeInt::INT;
 627   _const_basic_type[T_LONG]        = TypeLong::LONG;
 628   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 629   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 630   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 631   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 632   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 633   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 634   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 635 
 636   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 637   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 638   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 639   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 640   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 641   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 642   _zero_type[T_INT]         = TypeInt::ZERO;
 643   _zero_type[T_LONG]        = TypeLong::ZERO;
 644   _zero_type[T_FLOAT]       = TypeF::ZERO;
 645   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 646   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 647   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 648   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 649   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 650 
 651   // get_zero_type() should not happen for T_CONFLICT
 652   _zero_type[T_CONFLICT]= NULL;
 653 
 654   // Vector predefined types, it needs initialized _const_basic_type[].
 655   if (Matcher::vector_size_supported(T_BYTE,4)) {
 656     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 657   }
 658   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 659     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 660   }
 661   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 662     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 663   }
 664   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 665     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 666   }
 667   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 668     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 669   }
 670   mreg2type[Op_VecS] = TypeVect::VECTS;
 671   mreg2type[Op_VecD] = TypeVect::VECTD;
 672   mreg2type[Op_VecX] = TypeVect::VECTX;
 673   mreg2type[Op_VecY] = TypeVect::VECTY;
 674   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 675 
 676   // Restore working type arena.
 677   current-&gt;set_type_arena(save);
 678   current-&gt;set_type_dict(NULL);
 679 }
 680 
 681 //------------------------------Initialize-------------------------------------
 682 void Type::Initialize(Compile* current) {
 683   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 684 
 685   if (_shared_type_dict == NULL) {
 686     Initialize_shared(current);
 687   }
 688 
 689   Arena* type_arena = current-&gt;type_arena();
 690 
 691   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 692   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 693   current-&gt;set_type_dict(tdic);
 694 
 695   // Transfer the shared types.
 696   DictI i(_shared_type_dict);
 697   for( ; i.test(); ++i ) {
 698     Type* t = (Type*)i._value;
 699     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 700   }
 701 }
 702 
 703 //------------------------------hashcons---------------------------------------
 704 // Do the hash-cons trick.  If the Type already exists in the type table,
 705 // delete the current Type and return the existing Type.  Otherwise stick the
 706 // current Type in the Type table.
 707 const Type *Type::hashcons(void) {
 708   debug_only(base());           // Check the assertion in Type::base().
 709   // Look up the Type in the Type dictionary
 710   Dict *tdic = type_dict();
 711   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 712   if( old ) {                   // Pre-existing Type?
 713     if( old != this )           // Yes, this guy is not the pre-existing?
 714       delete this;              // Yes, Nuke this guy
 715     assert( old-&gt;_dual, &quot;&quot; );
 716     return old;                 // Return pre-existing
 717   }
 718 
 719   // Every type has a dual (to make my lattice symmetric).
 720   // Since we just discovered a new Type, compute its dual right now.
 721   assert( !_dual, &quot;&quot; );         // No dual yet
 722   _dual = xdual();              // Compute the dual
 723   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 724     if (_dual != this) {
 725       delete _dual;
 726       _dual = this;
 727     }
 728     return this;
 729   }
 730   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 731   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 732   // New Type, insert into Type table
 733   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 734   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 735 #ifdef ASSERT
 736   Type *dual_dual = (Type*)_dual-&gt;xdual();
 737   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 738   delete dual_dual;
 739 #endif
 740   return this;                  // Return new Type
 741 }
 742 
 743 //------------------------------eq---------------------------------------------
 744 // Structural equality check for Type representations
 745 bool Type::eq( const Type * ) const {
 746   return true;                  // Nothing else can go wrong
 747 }
 748 
 749 //------------------------------hash-------------------------------------------
 750 // Type-specific hashing function.
 751 int Type::hash(void) const {
 752   return _base;
 753 }
 754 
 755 //------------------------------is_finite--------------------------------------
 756 // Has a finite value
 757 bool Type::is_finite() const {
 758   return false;
 759 }
 760 
 761 //------------------------------is_nan-----------------------------------------
 762 // Is not a number (NaN)
 763 bool Type::is_nan()    const {
 764   return false;
 765 }
 766 
 767 //----------------------interface_vs_oop---------------------------------------
 768 #ifdef ASSERT
 769 bool Type::interface_vs_oop_helper(const Type *t) const {
 770   bool result = false;
 771 
 772   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 773   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 774   if( this_ptr == NULL || t_ptr == NULL )
 775     return result;
 776 
 777   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 778   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 779   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 780     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 781     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 782     result = this_interface ^ t_interface;
 783   }
 784 
 785   return result;
 786 }
 787 
 788 bool Type::interface_vs_oop(const Type *t) const {
 789   if (interface_vs_oop_helper(t)) {
 790     return true;
 791   }
 792   // Now check the speculative parts as well
 793   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 794   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 795   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 796     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 797       return true;
 798     }
 799     return false;
 800   }
 801   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 802     return true;
 803   }
 804   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 805     return true;
 806   }
 807   return false;
 808 }
 809 
 810 #endif
 811 
 812 //------------------------------meet-------------------------------------------
 813 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is
 814 // commutative and the lattice is symmetric.
 815 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {
 816   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {
 817     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 818     return result-&gt;make_narrowoop();
 819   }
 820   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {
 821     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);
 822     return result-&gt;make_narrowklass();
 823   }
 824 
 825   const Type *this_t = maybe_remove_speculative(include_speculative);
 826   t = t-&gt;maybe_remove_speculative(include_speculative);
 827 
 828   const Type *mt = this_t-&gt;xmeet(t);
 829   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;
 830   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;
 831 #ifdef ASSERT
 832   assert(mt == t-&gt;xmeet(this_t), &quot;meet not commutative&quot;);
 833   const Type* dual_join = mt-&gt;_dual;
 834   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
 835   const Type *t2this = dual_join-&gt;xmeet(this_t-&gt;_dual);
 836 
 837   // Interface meet Oop is Not Symmetric:
 838   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 839   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 840 
 841   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this_t-&gt;_dual) ) {
 842     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 843     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
 844     tty-&gt;print(&quot;this=                   &quot;);         this_t-&gt;dump(); tty-&gt;cr();
 845     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 846 
 847     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 848     tty-&gt;print(&quot;this_dual=              &quot;);  this_t-&gt;_dual-&gt;dump(); tty-&gt;cr();
 849     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 850 
 851     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 852     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 853 
 854     fatal(&quot;meet not symmetric&quot; );
 855   }
 856 #endif
 857   return mt;
 858 }
 859 
 860 //------------------------------xmeet------------------------------------------
 861 // Compute the MEET of two types.  It returns a new Type object.
 862 const Type *Type::xmeet( const Type *t ) const {
 863   // Perform a fast test for common case; meeting the same types together.
 864   if( this == t ) return this;  // Meeting same type-rep?
 865 
 866   // Meeting TOP with anything?
 867   if( _base == Top ) return t;
 868 
 869   // Meeting BOTTOM with anything?
 870   if( _base == Bottom ) return BOTTOM;
 871 
 872   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 873   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 874   switch (t-&gt;base()) {  // Switch on original type
 875 
 876   // Cut in half the number of cases I must handle.  Only need cases for when
 877   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 878   case FloatCon:
 879   case DoubleCon:
 880   case Int:
 881   case Long:
 882     return t-&gt;xmeet(this);
 883 
 884   case OopPtr:
 885     return t-&gt;xmeet(this);
 886 
 887   case InstPtr:
 888     return t-&gt;xmeet(this);
 889 
 890   case MetadataPtr:
 891   case KlassPtr:
 892     return t-&gt;xmeet(this);
 893 
 894   case AryPtr:
 895     return t-&gt;xmeet(this);
 896 
 897   case NarrowOop:
 898     return t-&gt;xmeet(this);
 899 
 900   case NarrowKlass:
 901     return t-&gt;xmeet(this);
 902 
 903   case Bad:                     // Type check
 904   default:                      // Bogus type not in lattice
 905     typerr(t);
 906     return Type::BOTTOM;
 907 
 908   case Bottom:                  // Ye Olde Default
 909     return t;
 910 
 911   case FloatTop:
 912     if( _base == FloatTop ) return this;
 913   case FloatBot:                // Float
 914     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 915     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 916     typerr(t);
 917     return Type::BOTTOM;
 918 
 919   case DoubleTop:
 920     if( _base == DoubleTop ) return this;
 921   case DoubleBot:               // Double
 922     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 923     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 924     typerr(t);
 925     return Type::BOTTOM;
 926 
 927   // These next few cases must match exactly or it is a compile-time error.
 928   case Control:                 // Control of code
 929   case Abio:                    // State of world outside of program
 930   case Memory:
 931     if( _base == t-&gt;_base )  return this;
 932     typerr(t);
 933     return Type::BOTTOM;
 934 
 935   case Top:                     // Top of the lattice
 936     return this;
 937   }
 938 
 939   // The type is unchanged
 940   return this;
 941 }
 942 
 943 //-----------------------------filter------------------------------------------
 944 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
 945   const Type* ft = join_helper(kills, include_speculative);
 946   if (ft-&gt;empty())
 947     return Type::TOP;           // Canonical empty value
 948   return ft;
 949 }
 950 
 951 //------------------------------xdual------------------------------------------
 952 // Compute dual right now.
 953 const Type::TYPES Type::dual_type[Type::lastype] = {
 954   Bad,          // Bad
 955   Control,      // Control
 956   Bottom,       // Top
 957   Bad,          // Int - handled in v-call
 958   Bad,          // Long - handled in v-call
 959   Half,         // Half
 960   Bad,          // NarrowOop - handled in v-call
 961   Bad,          // NarrowKlass - handled in v-call
 962 
 963   Bad,          // Tuple - handled in v-call
 964   Bad,          // Array - handled in v-call
 965   Bad,          // VectorS - handled in v-call
 966   Bad,          // VectorD - handled in v-call
 967   Bad,          // VectorX - handled in v-call
 968   Bad,          // VectorY - handled in v-call
 969   Bad,          // VectorZ - handled in v-call
 970 
 971   Bad,          // AnyPtr - handled in v-call
 972   Bad,          // RawPtr - handled in v-call
 973   Bad,          // OopPtr - handled in v-call
 974   Bad,          // InstPtr - handled in v-call
 975   Bad,          // AryPtr - handled in v-call
 976 
 977   Bad,          //  MetadataPtr - handled in v-call
 978   Bad,          // KlassPtr - handled in v-call
 979 
 980   Bad,          // Function - handled in v-call
 981   Abio,         // Abio
 982   Return_Address,// Return_Address
 983   Memory,       // Memory
 984   FloatBot,     // FloatTop
 985   FloatCon,     // FloatCon
 986   FloatTop,     // FloatBot
 987   DoubleBot,    // DoubleTop
 988   DoubleCon,    // DoubleCon
 989   DoubleTop,    // DoubleBot
 990   Top           // Bottom
 991 };
 992 
 993 const Type *Type::xdual() const {
 994   // Note: the base() accessor asserts the sanity of _base.
 995   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
 996   return new Type(_type_info[_base].dual_type);
 997 }
 998 
 999 //------------------------------has_memory-------------------------------------
1000 bool Type::has_memory() const {
1001   Type::TYPES tx = base();
1002   if (tx == Memory) return true;
1003   if (tx == Tuple) {
1004     const TypeTuple *t = is_tuple();
1005     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1006       tx = t-&gt;field_at(i)-&gt;base();
1007       if (tx == Memory)  return true;
1008     }
1009   }
1010   return false;
1011 }
1012 
1013 #ifndef PRODUCT
1014 //------------------------------dump2------------------------------------------
1015 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1016   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1017 }
1018 
1019 //------------------------------dump-------------------------------------------
1020 void Type::dump_on(outputStream *st) const {
1021   ResourceMark rm;
1022   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1023   dump2(d,1, st);
1024   if (is_ptr_to_narrowoop()) {
1025     st-&gt;print(&quot; [narrow]&quot;);
1026   } else if (is_ptr_to_narrowklass()) {
1027     st-&gt;print(&quot; [narrowklass]&quot;);
1028   }
1029 }
1030 
1031 //-----------------------------------------------------------------------------
1032 const char* Type::str(const Type* t) {
1033   stringStream ss;
1034   t-&gt;dump_on(&amp;ss);
1035   return ss.as_string();
1036 }
1037 #endif
1038 
1039 //------------------------------singleton--------------------------------------
1040 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1041 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1042 bool Type::singleton(void) const {
1043   return _base == Top || _base == Half;
1044 }
1045 
1046 //------------------------------empty------------------------------------------
1047 // TRUE if Type is a type with no values, FALSE otherwise.
1048 bool Type::empty(void) const {
1049   switch (_base) {
1050   case DoubleTop:
1051   case FloatTop:
1052   case Top:
1053     return true;
1054 
1055   case Half:
1056   case Abio:
1057   case Return_Address:
1058   case Memory:
1059   case Bottom:
1060   case FloatBot:
1061   case DoubleBot:
1062     return false;  // never a singleton, therefore never empty
1063 
1064   default:
1065     ShouldNotReachHere();
1066     return false;
1067   }
1068 }
1069 
1070 //------------------------------dump_stats-------------------------------------
1071 // Dump collected statistics to stderr
1072 #ifndef PRODUCT
1073 void Type::dump_stats() {
1074   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1075 }
1076 #endif
1077 
1078 //------------------------------typerr-----------------------------------------
1079 void Type::typerr( const Type *t ) const {
1080 #ifndef PRODUCT
1081   tty-&gt;print(&quot;\nError mixing types: &quot;);
1082   dump();
1083   tty-&gt;print(&quot; and &quot;);
1084   t-&gt;dump();
1085   tty-&gt;print(&quot;\n&quot;);
1086 #endif
1087   ShouldNotReachHere();
1088 }
1089 
1090 
1091 //=============================================================================
1092 // Convenience common pre-built types.
1093 const TypeF *TypeF::ZERO;       // Floating point zero
1094 const TypeF *TypeF::ONE;        // Floating point one
1095 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1096 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1097 
1098 //------------------------------make-------------------------------------------
1099 // Create a float constant
1100 const TypeF *TypeF::make(float f) {
1101   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1102 }
1103 
1104 //------------------------------meet-------------------------------------------
1105 // Compute the MEET of two types.  It returns a new Type object.
1106 const Type *TypeF::xmeet( const Type *t ) const {
1107   // Perform a fast test for common case; meeting the same types together.
1108   if( this == t ) return this;  // Meeting same type-rep?
1109 
1110   // Current &quot;this-&gt;_base&quot; is FloatCon
1111   switch (t-&gt;base()) {          // Switch on original type
1112   case AnyPtr:                  // Mixing with oops happens when javac
1113   case RawPtr:                  // reuses local variables
1114   case OopPtr:
1115   case InstPtr:
1116   case AryPtr:
1117   case MetadataPtr:
1118   case KlassPtr:
1119   case NarrowOop:
1120   case NarrowKlass:
1121   case Int:
1122   case Long:
1123   case DoubleTop:
1124   case DoubleCon:
1125   case DoubleBot:
1126   case Bottom:                  // Ye Olde Default
1127     return Type::BOTTOM;
1128 
1129   case FloatBot:
1130     return t;
1131 
1132   default:                      // All else is a mistake
1133     typerr(t);
1134 
1135   case FloatCon:                // Float-constant vs Float-constant?
1136     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1137                                 // must compare bitwise as positive zero, negative zero and NaN have
1138                                 // all the same representation in C++
1139       return FLOAT;             // Return generic float
1140                                 // Equal constants
1141   case Top:
1142   case FloatTop:
1143     break;                      // Return the float constant
1144   }
1145   return this;                  // Return the float constant
1146 }
1147 
1148 //------------------------------xdual------------------------------------------
1149 // Dual: symmetric
1150 const Type *TypeF::xdual() const {
1151   return this;
1152 }
1153 
1154 //------------------------------eq---------------------------------------------
1155 // Structural equality check for Type representations
1156 bool TypeF::eq(const Type *t) const {
1157   // Bitwise comparison to distinguish between +/-0. These values must be treated
1158   // as different to be consistent with C1 and the interpreter.
1159   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1160 }
1161 
1162 //------------------------------hash-------------------------------------------
1163 // Type-specific hashing function.
1164 int TypeF::hash(void) const {
1165   return *(int*)(&amp;_f);
1166 }
1167 
1168 //------------------------------is_finite--------------------------------------
1169 // Has a finite value
1170 bool TypeF::is_finite() const {
1171   return g_isfinite(getf()) != 0;
1172 }
1173 
1174 //------------------------------is_nan-----------------------------------------
1175 // Is not a number (NaN)
1176 bool TypeF::is_nan()    const {
1177   return g_isnan(getf()) != 0;
1178 }
1179 
1180 //------------------------------dump2------------------------------------------
1181 // Dump float constant Type
1182 #ifndef PRODUCT
1183 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1184   Type::dump2(d,depth, st);
1185   st-&gt;print(&quot;%f&quot;, _f);
1186 }
1187 #endif
1188 
1189 //------------------------------singleton--------------------------------------
1190 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1191 // constants (Ldi nodes).  Singletons are integer, float or double constants
1192 // or a single symbol.
1193 bool TypeF::singleton(void) const {
1194   return true;                  // Always a singleton
1195 }
1196 
1197 bool TypeF::empty(void) const {
1198   return false;                 // always exactly a singleton
1199 }
1200 
1201 //=============================================================================
1202 // Convenience common pre-built types.
1203 const TypeD *TypeD::ZERO;       // Floating point zero
1204 const TypeD *TypeD::ONE;        // Floating point one
1205 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1206 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1207 
1208 //------------------------------make-------------------------------------------
1209 const TypeD *TypeD::make(double d) {
1210   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1211 }
1212 
1213 //------------------------------meet-------------------------------------------
1214 // Compute the MEET of two types.  It returns a new Type object.
1215 const Type *TypeD::xmeet( const Type *t ) const {
1216   // Perform a fast test for common case; meeting the same types together.
1217   if( this == t ) return this;  // Meeting same type-rep?
1218 
1219   // Current &quot;this-&gt;_base&quot; is DoubleCon
1220   switch (t-&gt;base()) {          // Switch on original type
1221   case AnyPtr:                  // Mixing with oops happens when javac
1222   case RawPtr:                  // reuses local variables
1223   case OopPtr:
1224   case InstPtr:
1225   case AryPtr:
1226   case MetadataPtr:
1227   case KlassPtr:
1228   case NarrowOop:
1229   case NarrowKlass:
1230   case Int:
1231   case Long:
1232   case FloatTop:
1233   case FloatCon:
1234   case FloatBot:
1235   case Bottom:                  // Ye Olde Default
1236     return Type::BOTTOM;
1237 
1238   case DoubleBot:
1239     return t;
1240 
1241   default:                      // All else is a mistake
1242     typerr(t);
1243 
1244   case DoubleCon:               // Double-constant vs Double-constant?
1245     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1246       return DOUBLE;            // Return generic double
1247   case Top:
1248   case DoubleTop:
1249     break;
1250   }
1251   return this;                  // Return the double constant
1252 }
1253 
1254 //------------------------------xdual------------------------------------------
1255 // Dual: symmetric
1256 const Type *TypeD::xdual() const {
1257   return this;
1258 }
1259 
1260 //------------------------------eq---------------------------------------------
1261 // Structural equality check for Type representations
1262 bool TypeD::eq(const Type *t) const {
1263   // Bitwise comparison to distinguish between +/-0. These values must be treated
1264   // as different to be consistent with C1 and the interpreter.
1265   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1266 }
1267 
1268 //------------------------------hash-------------------------------------------
1269 // Type-specific hashing function.
1270 int TypeD::hash(void) const {
1271   return *(int*)(&amp;_d);
1272 }
1273 
1274 //------------------------------is_finite--------------------------------------
1275 // Has a finite value
1276 bool TypeD::is_finite() const {
1277   return g_isfinite(getd()) != 0;
1278 }
1279 
1280 //------------------------------is_nan-----------------------------------------
1281 // Is not a number (NaN)
1282 bool TypeD::is_nan()    const {
1283   return g_isnan(getd()) != 0;
1284 }
1285 
1286 //------------------------------dump2------------------------------------------
1287 // Dump double constant Type
1288 #ifndef PRODUCT
1289 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1290   Type::dump2(d,depth,st);
1291   st-&gt;print(&quot;%f&quot;, _d);
1292 }
1293 #endif
1294 
1295 //------------------------------singleton--------------------------------------
1296 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1297 // constants (Ldi nodes).  Singletons are integer, float or double constants
1298 // or a single symbol.
1299 bool TypeD::singleton(void) const {
1300   return true;                  // Always a singleton
1301 }
1302 
1303 bool TypeD::empty(void) const {
1304   return false;                 // always exactly a singleton
1305 }
1306 
1307 //=============================================================================
1308 // Convience common pre-built types.
1309 const TypeInt *TypeInt::MINUS_1;// -1
1310 const TypeInt *TypeInt::ZERO;   // 0
1311 const TypeInt *TypeInt::ONE;    // 1
1312 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1313 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1314 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1315 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1316 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1317 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1318 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1319 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1320 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1321 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1322 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1323 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1324 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1325 const TypeInt *TypeInt::INT;    // 32-bit integers
1326 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1327 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1328 
1329 //------------------------------TypeInt----------------------------------------
1330 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1331 }
1332 
1333 //------------------------------make-------------------------------------------
1334 const TypeInt *TypeInt::make( jint lo ) {
1335   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1336 }
1337 
1338 static int normalize_int_widen( jint lo, jint hi, int w ) {
1339   // Certain normalizations keep us sane when comparing types.
1340   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1341   if (lo &lt;= hi) {
1342     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1343     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1344   } else {
1345     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1346     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1347   }
1348   return w;
1349 }
1350 
1351 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1352   w = normalize_int_widen(lo, hi, w);
1353   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1354 }
1355 
1356 //------------------------------meet-------------------------------------------
1357 // Compute the MEET of two types.  It returns a new Type representation object
1358 // with reference count equal to the number of Types pointing at it.
1359 // Caller should wrap a Types around it.
1360 const Type *TypeInt::xmeet( const Type *t ) const {
1361   // Perform a fast test for common case; meeting the same types together.
1362   if( this == t ) return this;  // Meeting same type?
1363 
1364   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1365   switch (t-&gt;base()) {          // Switch on original type
1366   case AnyPtr:                  // Mixing with oops happens when javac
1367   case RawPtr:                  // reuses local variables
1368   case OopPtr:
1369   case InstPtr:
1370   case AryPtr:
1371   case MetadataPtr:
1372   case KlassPtr:
1373   case NarrowOop:
1374   case NarrowKlass:
1375   case Long:
1376   case FloatTop:
1377   case FloatCon:
1378   case FloatBot:
1379   case DoubleTop:
1380   case DoubleCon:
1381   case DoubleBot:
1382   case Bottom:                  // Ye Olde Default
1383     return Type::BOTTOM;
1384   default:                      // All else is a mistake
1385     typerr(t);
1386   case Top:                     // No change
1387     return this;
1388   case Int:                     // Int vs Int?
1389     break;
1390   }
1391 
1392   // Expand covered set
1393   const TypeInt *r = t-&gt;is_int();
1394   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1395 }
1396 
1397 //------------------------------xdual------------------------------------------
1398 // Dual: reverse hi &amp; lo; flip widen
1399 const Type *TypeInt::xdual() const {
1400   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1401   return new TypeInt(_hi,_lo,w);
1402 }
1403 
1404 //------------------------------widen------------------------------------------
1405 // Only happens for optimistic top-down optimizations.
1406 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1407   // Coming from TOP or such; no widening
1408   if( old-&gt;base() != Int ) return this;
1409   const TypeInt *ot = old-&gt;is_int();
1410 
1411   // If new guy is equal to old guy, no widening
1412   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1413     return old;
1414 
1415   // If new guy contains old, then we widened
1416   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1417     // New contains old
1418     // If new guy is already wider than old, no widening
1419     if( _widen &gt; ot-&gt;_widen ) return this;
1420     // If old guy was a constant, do not bother
1421     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1422     // Now widen new guy.
1423     // Check for widening too far
1424     if (_widen == WidenMax) {
1425       int max = max_jint;
1426       int min = min_jint;
1427       if (limit-&gt;isa_int()) {
1428         max = limit-&gt;is_int()-&gt;_hi;
1429         min = limit-&gt;is_int()-&gt;_lo;
1430       }
1431       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1432         // If neither endpoint is extremal yet, push out the endpoint
1433         // which is closer to its respective limit.
1434         if (_lo &gt;= 0 ||                 // easy common case
1435             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1436           // Try to widen to an unsigned range type of 31 bits:
1437           return make(_lo, max, WidenMax);
1438         } else {
1439           return make(min, _hi, WidenMax);
1440         }
1441       }
1442       return TypeInt::INT;
1443     }
1444     // Returned widened new guy
1445     return make(_lo,_hi,_widen+1);
1446   }
1447 
1448   // If old guy contains new, then we probably widened too far &amp; dropped to
1449   // bottom.  Return the wider fellow.
1450   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1451     return old;
1452 
1453   //fatal(&quot;Integer value range is not subset&quot;);
1454   //return this;
1455   return TypeInt::INT;
1456 }
1457 
1458 //------------------------------narrow---------------------------------------
1459 // Only happens for pessimistic optimizations.
1460 const Type *TypeInt::narrow( const Type *old ) const {
1461   if (_lo &gt;= _hi)  return this;   // already narrow enough
1462   if (old == NULL)  return this;
1463   const TypeInt* ot = old-&gt;isa_int();
1464   if (ot == NULL)  return this;
1465   jint olo = ot-&gt;_lo;
1466   jint ohi = ot-&gt;_hi;
1467 
1468   // If new guy is equal to old guy, no narrowing
1469   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1470 
1471   // If old guy was maximum range, allow the narrowing
1472   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1473 
1474   if (_lo &lt; olo || _hi &gt; ohi)
1475     return this;                // doesn&#39;t narrow; pretty wierd
1476 
1477   // The new type narrows the old type, so look for a &quot;death march&quot;.
1478   // See comments on PhaseTransform::saturate.
1479   juint nrange = (juint)_hi - _lo;
1480   juint orange = (juint)ohi - olo;
1481   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1482     // Use the new type only if the range shrinks a lot.
1483     // We do not want the optimizer computing 2^31 point by point.
1484     return old;
1485   }
1486 
1487   return this;
1488 }
1489 
1490 //-----------------------------filter------------------------------------------
1491 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1492   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1493   if (ft == NULL || ft-&gt;empty())
1494     return Type::TOP;           // Canonical empty value
1495   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1496     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1497     // The widen bits must be allowed to run freely through the graph.
1498     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1499   }
1500   return ft;
1501 }
1502 
1503 //------------------------------eq---------------------------------------------
1504 // Structural equality check for Type representations
1505 bool TypeInt::eq( const Type *t ) const {
1506   const TypeInt *r = t-&gt;is_int(); // Handy access
1507   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1508 }
1509 
1510 //------------------------------hash-------------------------------------------
1511 // Type-specific hashing function.
1512 int TypeInt::hash(void) const {
1513   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1514 }
1515 
1516 //------------------------------is_finite--------------------------------------
1517 // Has a finite value
1518 bool TypeInt::is_finite() const {
1519   return true;
1520 }
1521 
1522 //------------------------------dump2------------------------------------------
1523 // Dump TypeInt
1524 #ifndef PRODUCT
1525 static const char* intname(char* buf, jint n) {
1526   if (n == min_jint)
1527     return &quot;min&quot;;
1528   else if (n &lt; min_jint + 10000)
1529     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1530   else if (n == max_jint)
1531     return &quot;max&quot;;
1532   else if (n &gt; max_jint - 10000)
1533     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1534   else
1535     sprintf(buf, INT32_FORMAT, n);
1536   return buf;
1537 }
1538 
1539 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1540   char buf[40], buf2[40];
1541   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1542     st-&gt;print(&quot;int&quot;);
1543   else if (is_con())
1544     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1545   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1546     st-&gt;print(&quot;bool&quot;);
1547   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1548     st-&gt;print(&quot;byte&quot;);
1549   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1550     st-&gt;print(&quot;char&quot;);
1551   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1552     st-&gt;print(&quot;short&quot;);
1553   else if (_hi == max_jint)
1554     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1555   else if (_lo == min_jint)
1556     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1557   else
1558     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1559 
1560   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1561     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1562 }
1563 #endif
1564 
1565 //------------------------------singleton--------------------------------------
1566 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1567 // constants.
1568 bool TypeInt::singleton(void) const {
1569   return _lo &gt;= _hi;
1570 }
1571 
1572 bool TypeInt::empty(void) const {
1573   return _lo &gt; _hi;
1574 }
1575 
1576 //=============================================================================
1577 // Convenience common pre-built types.
1578 const TypeLong *TypeLong::MINUS_1;// -1
1579 const TypeLong *TypeLong::ZERO; // 0
1580 const TypeLong *TypeLong::ONE;  // 1
1581 const TypeLong *TypeLong::POS;  // &gt;=0
1582 const TypeLong *TypeLong::LONG; // 64-bit integers
1583 const TypeLong *TypeLong::INT;  // 32-bit subrange
1584 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1585 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1586 
1587 //------------------------------TypeLong---------------------------------------
1588 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1589 }
1590 
1591 //------------------------------make-------------------------------------------
1592 const TypeLong *TypeLong::make( jlong lo ) {
1593   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1594 }
1595 
1596 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1597   // Certain normalizations keep us sane when comparing types.
1598   // The &#39;SMALLINT&#39; covers constants.
1599   if (lo &lt;= hi) {
1600     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1601     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1602   } else {
1603     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1604     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1605   }
1606   return w;
1607 }
1608 
1609 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1610   w = normalize_long_widen(lo, hi, w);
1611   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1612 }
1613 
1614 
1615 //------------------------------meet-------------------------------------------
1616 // Compute the MEET of two types.  It returns a new Type representation object
1617 // with reference count equal to the number of Types pointing at it.
1618 // Caller should wrap a Types around it.
1619 const Type *TypeLong::xmeet( const Type *t ) const {
1620   // Perform a fast test for common case; meeting the same types together.
1621   if( this == t ) return this;  // Meeting same type?
1622 
1623   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1624   switch (t-&gt;base()) {          // Switch on original type
1625   case AnyPtr:                  // Mixing with oops happens when javac
1626   case RawPtr:                  // reuses local variables
1627   case OopPtr:
1628   case InstPtr:
1629   case AryPtr:
1630   case MetadataPtr:
1631   case KlassPtr:
1632   case NarrowOop:
1633   case NarrowKlass:
1634   case Int:
1635   case FloatTop:
1636   case FloatCon:
1637   case FloatBot:
1638   case DoubleTop:
1639   case DoubleCon:
1640   case DoubleBot:
1641   case Bottom:                  // Ye Olde Default
1642     return Type::BOTTOM;
1643   default:                      // All else is a mistake
1644     typerr(t);
1645   case Top:                     // No change
1646     return this;
1647   case Long:                    // Long vs Long?
1648     break;
1649   }
1650 
1651   // Expand covered set
1652   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1653   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1654 }
1655 
1656 //------------------------------xdual------------------------------------------
1657 // Dual: reverse hi &amp; lo; flip widen
1658 const Type *TypeLong::xdual() const {
1659   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1660   return new TypeLong(_hi,_lo,w);
1661 }
1662 
1663 //------------------------------widen------------------------------------------
1664 // Only happens for optimistic top-down optimizations.
1665 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1666   // Coming from TOP or such; no widening
1667   if( old-&gt;base() != Long ) return this;
1668   const TypeLong *ot = old-&gt;is_long();
1669 
1670   // If new guy is equal to old guy, no widening
1671   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1672     return old;
1673 
1674   // If new guy contains old, then we widened
1675   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1676     // New contains old
1677     // If new guy is already wider than old, no widening
1678     if( _widen &gt; ot-&gt;_widen ) return this;
1679     // If old guy was a constant, do not bother
1680     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1681     // Now widen new guy.
1682     // Check for widening too far
1683     if (_widen == WidenMax) {
1684       jlong max = max_jlong;
1685       jlong min = min_jlong;
1686       if (limit-&gt;isa_long()) {
1687         max = limit-&gt;is_long()-&gt;_hi;
1688         min = limit-&gt;is_long()-&gt;_lo;
1689       }
1690       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1691         // If neither endpoint is extremal yet, push out the endpoint
1692         // which is closer to its respective limit.
1693         if (_lo &gt;= 0 ||                 // easy common case
1694             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1695           // Try to widen to an unsigned range type of 32/63 bits:
1696           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1697             return make(_lo, max_juint, WidenMax);
1698           else
1699             return make(_lo, max, WidenMax);
1700         } else {
1701           return make(min, _hi, WidenMax);
1702         }
1703       }
1704       return TypeLong::LONG;
1705     }
1706     // Returned widened new guy
1707     return make(_lo,_hi,_widen+1);
1708   }
1709 
1710   // If old guy contains new, then we probably widened too far &amp; dropped to
1711   // bottom.  Return the wider fellow.
1712   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1713     return old;
1714 
1715   //  fatal(&quot;Long value range is not subset&quot;);
1716   // return this;
1717   return TypeLong::LONG;
1718 }
1719 
1720 //------------------------------narrow----------------------------------------
1721 // Only happens for pessimistic optimizations.
1722 const Type *TypeLong::narrow( const Type *old ) const {
1723   if (_lo &gt;= _hi)  return this;   // already narrow enough
1724   if (old == NULL)  return this;
1725   const TypeLong* ot = old-&gt;isa_long();
1726   if (ot == NULL)  return this;
1727   jlong olo = ot-&gt;_lo;
1728   jlong ohi = ot-&gt;_hi;
1729 
1730   // If new guy is equal to old guy, no narrowing
1731   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1732 
1733   // If old guy was maximum range, allow the narrowing
1734   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1735 
1736   if (_lo &lt; olo || _hi &gt; ohi)
1737     return this;                // doesn&#39;t narrow; pretty wierd
1738 
1739   // The new type narrows the old type, so look for a &quot;death march&quot;.
1740   // See comments on PhaseTransform::saturate.
1741   julong nrange = _hi - _lo;
1742   julong orange = ohi - olo;
1743   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1744     // Use the new type only if the range shrinks a lot.
1745     // We do not want the optimizer computing 2^31 point by point.
1746     return old;
1747   }
1748 
1749   return this;
1750 }
1751 
1752 //-----------------------------filter------------------------------------------
1753 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1754   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1755   if (ft == NULL || ft-&gt;empty())
1756     return Type::TOP;           // Canonical empty value
1757   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1758     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1759     // The widen bits must be allowed to run freely through the graph.
1760     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1761   }
1762   return ft;
1763 }
1764 
1765 //------------------------------eq---------------------------------------------
1766 // Structural equality check for Type representations
1767 bool TypeLong::eq( const Type *t ) const {
1768   const TypeLong *r = t-&gt;is_long(); // Handy access
1769   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1770 }
1771 
1772 //------------------------------hash-------------------------------------------
1773 // Type-specific hashing function.
1774 int TypeLong::hash(void) const {
1775   return (int)(_lo+_hi+_widen+(int)Type::Long);
1776 }
1777 
1778 //------------------------------is_finite--------------------------------------
1779 // Has a finite value
1780 bool TypeLong::is_finite() const {
1781   return true;
1782 }
1783 
1784 //------------------------------dump2------------------------------------------
1785 // Dump TypeLong
1786 #ifndef PRODUCT
1787 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1788   if (n &gt; x) {
1789     if (n &gt;= x + 10000)  return NULL;
1790     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1791   } else if (n &lt; x) {
1792     if (n &lt;= x - 10000)  return NULL;
1793     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1794   } else {
1795     return xname;
1796   }
1797   return buf;
1798 }
1799 
1800 static const char* longname(char* buf, jlong n) {
1801   const char* str;
1802   if (n == min_jlong)
1803     return &quot;min&quot;;
1804   else if (n &lt; min_jlong + 10000)
1805     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1806   else if (n == max_jlong)
1807     return &quot;max&quot;;
1808   else if (n &gt; max_jlong - 10000)
1809     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1810   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1811     return str;
1812   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1813     return str;
1814   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1815     return str;
1816   else
1817     sprintf(buf, JLONG_FORMAT, n);
1818   return buf;
1819 }
1820 
1821 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1822   char buf[80], buf2[80];
1823   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1824     st-&gt;print(&quot;long&quot;);
1825   else if (is_con())
1826     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1827   else if (_hi == max_jlong)
1828     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1829   else if (_lo == min_jlong)
1830     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1831   else
1832     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1833 
1834   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1835     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1836 }
1837 #endif
1838 
1839 //------------------------------singleton--------------------------------------
1840 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1841 // constants
1842 bool TypeLong::singleton(void) const {
1843   return _lo &gt;= _hi;
1844 }
1845 
1846 bool TypeLong::empty(void) const {
1847   return _lo &gt; _hi;
1848 }
1849 
1850 //=============================================================================
1851 // Convenience common pre-built types.
1852 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1853 const TypeTuple *TypeTuple::IFFALSE;
1854 const TypeTuple *TypeTuple::IFTRUE;
1855 const TypeTuple *TypeTuple::IFNEITHER;
1856 const TypeTuple *TypeTuple::LOOPBODY;
1857 const TypeTuple *TypeTuple::MEMBAR;
1858 const TypeTuple *TypeTuple::STORECONDITIONAL;
1859 const TypeTuple *TypeTuple::START_I2C;
1860 const TypeTuple *TypeTuple::INT_PAIR;
1861 const TypeTuple *TypeTuple::LONG_PAIR;
1862 const TypeTuple *TypeTuple::INT_CC_PAIR;
1863 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1864 
1865 
1866 //------------------------------make-------------------------------------------
1867 // Make a TypeTuple from the range of a method signature
1868 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {
1869   ciType* return_type = sig-&gt;return_type();
1870   uint arg_cnt = return_type-&gt;size();
1871   const Type **field_array = fields(arg_cnt);
1872   switch (return_type-&gt;basic_type()) {
1873   case T_LONG:
1874     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1875     field_array[TypeFunc::Parms+1] = Type::HALF;
1876     break;
1877   case T_DOUBLE:
1878     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1879     field_array[TypeFunc::Parms+1] = Type::HALF;
1880     break;
1881   case T_OBJECT:
1882   case T_ARRAY:
1883   case T_BOOLEAN:
1884   case T_CHAR:
1885   case T_FLOAT:
1886   case T_BYTE:
1887   case T_SHORT:
1888   case T_INT:
1889     field_array[TypeFunc::Parms] = get_const_type(return_type);
1890     break;
1891   case T_VOID:
1892     break;
1893   default:
1894     ShouldNotReachHere();
1895   }
1896   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1897 }
1898 
1899 // Make a TypeTuple from the domain of a method signature
1900 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {
1901   uint arg_cnt = sig-&gt;size();
1902 
1903   uint pos = TypeFunc::Parms;
1904   const Type **field_array;
1905   if (recv != NULL) {
1906     arg_cnt++;
1907     field_array = fields(arg_cnt);
1908     // Use get_const_type here because it respects UseUniqueSubclasses:
1909     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
1910   } else {
1911     field_array = fields(arg_cnt);
1912   }
1913 
1914   int i = 0;
1915   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1916     ciType* type = sig-&gt;type_at(i);
1917 
1918     switch (type-&gt;basic_type()) {
1919     case T_LONG:
1920       field_array[pos++] = TypeLong::LONG;
1921       field_array[pos++] = Type::HALF;
1922       break;
1923     case T_DOUBLE:
1924       field_array[pos++] = Type::DOUBLE;
1925       field_array[pos++] = Type::HALF;
1926       break;
1927     case T_OBJECT:
1928     case T_ARRAY:
1929     case T_FLOAT:
1930     case T_INT:
1931       field_array[pos++] = get_const_type(type);
1932       break;
1933     case T_BOOLEAN:
1934     case T_CHAR:
1935     case T_BYTE:
1936     case T_SHORT:
1937       field_array[pos++] = TypeInt::INT;
1938       break;
1939     default:
1940       ShouldNotReachHere();
1941     }
1942     i++;
1943   }
1944 
1945   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1946 }
1947 
1948 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1949   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1950 }
1951 
1952 //------------------------------fields-----------------------------------------
1953 // Subroutine call type with space allocated for argument types
1954 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1955 const Type **TypeTuple::fields( uint arg_cnt ) {
1956   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1957   flds[TypeFunc::Control  ] = Type::CONTROL;
1958   flds[TypeFunc::I_O      ] = Type::ABIO;
1959   flds[TypeFunc::Memory   ] = Type::MEMORY;
1960   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1961   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1962 
1963   return flds;
1964 }
1965 
1966 //------------------------------meet-------------------------------------------
1967 // Compute the MEET of two types.  It returns a new Type object.
1968 const Type *TypeTuple::xmeet( const Type *t ) const {
1969   // Perform a fast test for common case; meeting the same types together.
1970   if( this == t ) return this;  // Meeting same type-rep?
1971 
1972   // Current &quot;this-&gt;_base&quot; is Tuple
1973   switch (t-&gt;base()) {          // switch on original type
1974 
1975   case Bottom:                  // Ye Olde Default
1976     return t;
1977 
1978   default:                      // All else is a mistake
1979     typerr(t);
1980 
1981   case Tuple: {                 // Meeting 2 signatures?
1982     const TypeTuple *x = t-&gt;is_tuple();
1983     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
1984     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
1985     for( uint i=0; i&lt;_cnt; i++ )
1986       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
1987     return TypeTuple::make(_cnt,fields);
1988   }
1989   case Top:
1990     break;
1991   }
1992   return this;                  // Return the double constant
1993 }
1994 
1995 //------------------------------xdual------------------------------------------
1996 // Dual: compute field-by-field dual
1997 const Type *TypeTuple::xdual() const {
1998   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
1999   for( uint i=0; i&lt;_cnt; i++ )
2000     fields[i] = _fields[i]-&gt;dual();
2001   return new TypeTuple(_cnt,fields);
2002 }
2003 
2004 //------------------------------eq---------------------------------------------
2005 // Structural equality check for Type representations
2006 bool TypeTuple::eq( const Type *t ) const {
2007   const TypeTuple *s = (const TypeTuple *)t;
2008   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2009   for (uint i = 0; i &lt; _cnt; i++)
2010     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2011       return false;             // Missed
2012   return true;
2013 }
2014 
2015 //------------------------------hash-------------------------------------------
2016 // Type-specific hashing function.
2017 int TypeTuple::hash(void) const {
2018   intptr_t sum = _cnt;
2019   for( uint i=0; i&lt;_cnt; i++ )
2020     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2021   return sum;
2022 }
2023 
2024 //------------------------------dump2------------------------------------------
2025 // Dump signature Type
2026 #ifndef PRODUCT
2027 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2028   st-&gt;print(&quot;{&quot;);
2029   if( !depth || d[this] ) {     // Check for recursive print
2030     st-&gt;print(&quot;...}&quot;);
2031     return;
2032   }
2033   d.Insert((void*)this, (void*)this);   // Stop recursion
2034   if( _cnt ) {
2035     uint i;
2036     for( i=0; i&lt;_cnt-1; i++ ) {
2037       st-&gt;print(&quot;%d:&quot;, i);
2038       _fields[i]-&gt;dump2(d, depth-1, st);
2039       st-&gt;print(&quot;, &quot;);
2040     }
2041     st-&gt;print(&quot;%d:&quot;, i);
2042     _fields[i]-&gt;dump2(d, depth-1, st);
2043   }
2044   st-&gt;print(&quot;}&quot;);
2045 }
2046 #endif
2047 
2048 //------------------------------singleton--------------------------------------
2049 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2050 // constants (Ldi nodes).  Singletons are integer, float or double constants
2051 // or a single symbol.
2052 bool TypeTuple::singleton(void) const {
2053   return false;                 // Never a singleton
2054 }
2055 
2056 bool TypeTuple::empty(void) const {
2057   for( uint i=0; i&lt;_cnt; i++ ) {
2058     if (_fields[i]-&gt;empty())  return true;
2059   }
2060   return false;
2061 }
2062 
2063 //=============================================================================
2064 // Convenience common pre-built types.
2065 
2066 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2067   // Certain normalizations keep us sane when comparing types.
2068   // We do not want arrayOop variables to differ only by the wideness
2069   // of their index types.  Pick minimum wideness, since that is the
2070   // forced wideness of small ranges anyway.
2071   if (size-&gt;_widen != Type::WidenMin)
2072     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2073   else
2074     return size;
2075 }
2076 
2077 //------------------------------make-------------------------------------------
2078 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {
2079   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2080     elem = elem-&gt;make_narrowoop();
2081   }
2082   size = normalize_array_size(size);
2083   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();
2084 }
2085 
2086 //------------------------------meet-------------------------------------------
2087 // Compute the MEET of two types.  It returns a new Type object.
2088 const Type *TypeAry::xmeet( const Type *t ) const {
2089   // Perform a fast test for common case; meeting the same types together.
2090   if( this == t ) return this;  // Meeting same type-rep?
2091 
2092   // Current &quot;this-&gt;_base&quot; is Ary
2093   switch (t-&gt;base()) {          // switch on original type
2094 
2095   case Bottom:                  // Ye Olde Default
2096     return t;
2097 
2098   default:                      // All else is a mistake
2099     typerr(t);
2100 
2101   case Array: {                 // Meeting 2 arrays?
2102     const TypeAry *a = t-&gt;is_ary();
2103     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2104                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2105                          _stable &amp;&amp; a-&gt;_stable);
2106   }
2107   case Top:
2108     break;
2109   }
2110   return this;                  // Return the double constant
2111 }
2112 
2113 //------------------------------xdual------------------------------------------
2114 // Dual: compute field-by-field dual
2115 const Type *TypeAry::xdual() const {
2116   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2117   size_dual = normalize_array_size(size_dual);
2118   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2119 }
2120 
2121 //------------------------------eq---------------------------------------------
2122 // Structural equality check for Type representations
2123 bool TypeAry::eq( const Type *t ) const {
2124   const TypeAry *a = (const TypeAry*)t;
2125   return _elem == a-&gt;_elem &amp;&amp;
2126     _stable == a-&gt;_stable &amp;&amp;
2127     _size == a-&gt;_size;
2128 }
2129 
2130 //------------------------------hash-------------------------------------------
2131 // Type-specific hashing function.
2132 int TypeAry::hash(void) const {
2133   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2134 }
2135 
2136 /**
2137  * Return same type without a speculative part in the element
2138  */
2139 const Type* TypeAry::remove_speculative() const {
2140   return make(_elem-&gt;remove_speculative(), _size, _stable);
2141 }
2142 
2143 /**
2144  * Return same type with cleaned up speculative part of element
2145  */
2146 const Type* TypeAry::cleanup_speculative() const {
2147   return make(_elem-&gt;cleanup_speculative(), _size, _stable);
2148 }
2149 
2150 /**
2151  * Return same type but with a different inline depth (used for speculation)
2152  *
2153  * @param depth  depth to meet with
2154  */
2155 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2156   if (!UseInlineDepthForSpeculativeTypes) {
2157     return this;
2158   }
2159   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2160 }
2161 
2162 //----------------------interface_vs_oop---------------------------------------
2163 #ifdef ASSERT
2164 bool TypeAry::interface_vs_oop(const Type *t) const {
2165   const TypeAry* t_ary = t-&gt;is_ary();
2166   if (t_ary) {
2167     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2168     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2169     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2170       return this_ptr-&gt;interface_vs_oop(t_ptr);
2171     }
2172   }
2173   return false;
2174 }
2175 #endif
2176 
2177 //------------------------------dump2------------------------------------------
2178 #ifndef PRODUCT
2179 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2180   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2181   _elem-&gt;dump2(d, depth, st);
2182   st-&gt;print(&quot;[&quot;);
2183   _size-&gt;dump2(d, depth, st);
2184   st-&gt;print(&quot;]&quot;);
2185 }
2186 #endif
2187 
2188 //------------------------------singleton--------------------------------------
2189 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2190 // constants (Ldi nodes).  Singletons are integer, float or double constants
2191 // or a single symbol.
2192 bool TypeAry::singleton(void) const {
2193   return false;                 // Never a singleton
2194 }
2195 
2196 bool TypeAry::empty(void) const {
2197   return _elem-&gt;empty() || _size-&gt;empty();
2198 }
2199 
2200 //--------------------------ary_must_be_exact----------------------------------
2201 bool TypeAry::ary_must_be_exact() const {
2202   if (!UseExactTypes)       return false;
2203   // This logic looks at the element type of an array, and returns true
2204   // if the element type is either a primitive or a final instance class.
2205   // In such cases, an array built on this ary must have no subclasses.
2206   if (_elem == BOTTOM)      return false;  // general array not exact
2207   if (_elem == TOP   )      return false;  // inverted general array not exact
2208   const TypeOopPtr*  toop = NULL;
2209   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2210     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2211   } else {
2212     toop = _elem-&gt;isa_oopptr();
2213   }
2214   if (!toop)                return true;   // a primitive type, like int
2215   ciKlass* tklass = toop-&gt;klass();
2216   if (tklass == NULL)       return false;  // unloaded class
2217   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2218   const TypeInstPtr* tinst;
2219   if (_elem-&gt;isa_narrowoop())
2220     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2221   else
2222     tinst = _elem-&gt;isa_instptr();
2223   if (tinst)
2224     return tklass-&gt;as_instance_klass()-&gt;is_final();
2225   const TypeAryPtr*  tap;
2226   if (_elem-&gt;isa_narrowoop())
2227     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2228   else
2229     tap = _elem-&gt;isa_aryptr();
2230   if (tap)
2231     return tap-&gt;ary()-&gt;ary_must_be_exact();
2232   return false;
2233 }
2234 
2235 //==============================TypeVect=======================================
2236 // Convenience common pre-built types.
2237 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2238 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2239 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2240 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2241 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2242 
2243 //------------------------------make-------------------------------------------
2244 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2245   BasicType elem_bt = elem-&gt;array_element_basic_type();
2246   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2247   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2248   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2249   int size = length * type2aelembytes(elem_bt);
2250   switch (Matcher::vector_ideal_reg(size)) {
2251   case Op_VecS:
2252     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2253   case Op_RegL:
2254   case Op_VecD:
2255   case Op_RegD:
2256     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2257   case Op_VecX:
2258     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2259   case Op_VecY:
2260     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2261   case Op_VecZ:
2262     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2263   }
2264  ShouldNotReachHere();
2265   return NULL;
2266 }
2267 
2268 //------------------------------meet-------------------------------------------
2269 // Compute the MEET of two types.  It returns a new Type object.
2270 const Type *TypeVect::xmeet( const Type *t ) const {
2271   // Perform a fast test for common case; meeting the same types together.
2272   if( this == t ) return this;  // Meeting same type-rep?
2273 
2274   // Current &quot;this-&gt;_base&quot; is Vector
2275   switch (t-&gt;base()) {          // switch on original type
2276 
2277   case Bottom:                  // Ye Olde Default
2278     return t;
2279 
2280   default:                      // All else is a mistake
2281     typerr(t);
2282 
2283   case VectorS:
2284   case VectorD:
2285   case VectorX:
2286   case VectorY:
2287   case VectorZ: {                // Meeting 2 vectors?
2288     const TypeVect* v = t-&gt;is_vect();
2289     assert(  base() == v-&gt;base(), &quot;&quot;);
2290     assert(length() == v-&gt;length(), &quot;&quot;);
2291     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2292     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2293   }
2294   case Top:
2295     break;
2296   }
2297   return this;
2298 }
2299 
2300 //------------------------------xdual------------------------------------------
2301 // Dual: compute field-by-field dual
2302 const Type *TypeVect::xdual() const {
2303   return new TypeVect(base(), _elem-&gt;dual(), _length);
2304 }
2305 
2306 //------------------------------eq---------------------------------------------
2307 // Structural equality check for Type representations
2308 bool TypeVect::eq(const Type *t) const {
2309   const TypeVect *v = t-&gt;is_vect();
2310   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2311 }
2312 
2313 //------------------------------hash-------------------------------------------
2314 // Type-specific hashing function.
2315 int TypeVect::hash(void) const {
2316   return (intptr_t)_elem + (intptr_t)_length;
2317 }
2318 
2319 //------------------------------singleton--------------------------------------
2320 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2321 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2322 // constant value (when vector is created with Replicate code).
2323 bool TypeVect::singleton(void) const {
2324 // There is no Con node for vectors yet.
2325 //  return _elem-&gt;singleton();
2326   return false;
2327 }
2328 
2329 bool TypeVect::empty(void) const {
2330   return _elem-&gt;empty();
2331 }
2332 
2333 //------------------------------dump2------------------------------------------
2334 #ifndef PRODUCT
2335 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2336   switch (base()) {
2337   case VectorS:
2338     st-&gt;print(&quot;vectors[&quot;); break;
2339   case VectorD:
2340     st-&gt;print(&quot;vectord[&quot;); break;
2341   case VectorX:
2342     st-&gt;print(&quot;vectorx[&quot;); break;
2343   case VectorY:
2344     st-&gt;print(&quot;vectory[&quot;); break;
2345   case VectorZ:
2346     st-&gt;print(&quot;vectorz[&quot;); break;
2347   default:
2348     ShouldNotReachHere();
2349   }
2350   st-&gt;print(&quot;%d]:{&quot;, _length);
2351   _elem-&gt;dump2(d, depth, st);
2352   st-&gt;print(&quot;}&quot;);
2353 }
2354 #endif
2355 
2356 
2357 //=============================================================================
2358 // Convenience common pre-built types.
2359 const TypePtr *TypePtr::NULL_PTR;
2360 const TypePtr *TypePtr::NOTNULL;
2361 const TypePtr *TypePtr::BOTTOM;
2362 
2363 //------------------------------meet-------------------------------------------
2364 // Meet over the PTR enum
2365 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2366   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2367   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2368   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2369   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2370   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2371   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2372   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2373 };
2374 
2375 //------------------------------make-------------------------------------------
2376 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {
2377   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2378 }
2379 
2380 //------------------------------cast_to_ptr_type-------------------------------
2381 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2382   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2383   if( ptr == _ptr ) return this;
2384   return make(_base, ptr, _offset, _speculative, _inline_depth);
2385 }
2386 
2387 //------------------------------get_con----------------------------------------
2388 intptr_t TypePtr::get_con() const {
2389   assert( _ptr == Null, &quot;&quot; );
2390   return _offset;
2391 }
2392 
2393 //------------------------------meet-------------------------------------------
2394 // Compute the MEET of two types.  It returns a new Type object.
2395 const Type *TypePtr::xmeet(const Type *t) const {
2396   const Type* res = xmeet_helper(t);
2397   if (res-&gt;isa_ptr() == NULL) {
2398     return res;
2399   }
2400 
2401   const TypePtr* res_ptr = res-&gt;is_ptr();
2402   if (res_ptr-&gt;speculative() != NULL) {
2403     // type-&gt;speculative() == NULL means that speculation is no better
2404     // than type, i.e. type-&gt;speculative() == type. So there are 2
2405     // ways to represent the fact that we have no useful speculative
2406     // data and we should use a single one to be able to test for
2407     // equality between types. Check whether type-&gt;speculative() ==
2408     // type and set speculative to NULL if it is the case.
2409     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2410       return res_ptr-&gt;remove_speculative();
2411     }
2412   }
2413 
2414   return res;
2415 }
2416 
2417 const Type *TypePtr::xmeet_helper(const Type *t) const {
2418   // Perform a fast test for common case; meeting the same types together.
2419   if( this == t ) return this;  // Meeting same type-rep?
2420 
2421   // Current &quot;this-&gt;_base&quot; is AnyPtr
2422   switch (t-&gt;base()) {          // switch on original type
2423   case Int:                     // Mixing ints &amp; oops happens when javac
2424   case Long:                    // reuses local variables
2425   case FloatTop:
2426   case FloatCon:
2427   case FloatBot:
2428   case DoubleTop:
2429   case DoubleCon:
2430   case DoubleBot:
2431   case NarrowOop:
2432   case NarrowKlass:
2433   case Bottom:                  // Ye Olde Default
2434     return Type::BOTTOM;
2435   case Top:
2436     return this;
2437 
2438   case AnyPtr: {                // Meeting to AnyPtrs
2439     const TypePtr *tp = t-&gt;is_ptr();
2440     const TypePtr* speculative = xmeet_speculative(tp);
2441     int depth = meet_inline_depth(tp-&gt;inline_depth());
2442     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2443   }
2444   case RawPtr:                  // For these, flip the call around to cut down
2445   case OopPtr:
2446   case InstPtr:                 // on the cases I have to handle.
2447   case AryPtr:
2448   case MetadataPtr:
2449   case KlassPtr:
2450     return t-&gt;xmeet(this);      // Call in reverse direction
2451   default:                      // All else is a mistake
2452     typerr(t);
2453 
2454   }
2455   return this;
2456 }
2457 
2458 //------------------------------meet_offset------------------------------------
2459 int TypePtr::meet_offset( int offset ) const {
2460   // Either is &#39;TOP&#39; offset?  Return the other offset!
2461   if( _offset == OffsetTop ) return offset;
2462   if( offset == OffsetTop ) return _offset;
2463   // If either is different, return &#39;BOTTOM&#39; offset
2464   if( _offset != offset ) return OffsetBot;
2465   return _offset;
2466 }
2467 
2468 //------------------------------dual_offset------------------------------------
2469 int TypePtr::dual_offset( ) const {
2470   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
2471   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
2472   return _offset;               // Map everything else into self
2473 }
2474 
2475 //------------------------------xdual------------------------------------------
2476 // Dual: compute field-by-field dual
2477 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2478   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2479 };
2480 const Type *TypePtr::xdual() const {
2481   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2482 }
2483 
2484 //------------------------------xadd_offset------------------------------------
2485 int TypePtr::xadd_offset( intptr_t offset ) const {
2486   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
2487   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;
2488   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
2489   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;
2490   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
2491   offset += (intptr_t)_offset;
2492   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;
2493 
2494   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
2495   // It is possible to construct a negative offset during PhaseCCP
2496 
2497   return (int)offset;        // Sum valid offsets
2498 }
2499 
2500 //------------------------------add_offset-------------------------------------
2501 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2502   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2503 }
2504 
2505 //------------------------------eq---------------------------------------------
2506 // Structural equality check for Type representations
2507 bool TypePtr::eq( const Type *t ) const {
2508   const TypePtr *a = (const TypePtr*)t;
2509   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2510 }
2511 
2512 //------------------------------hash-------------------------------------------
2513 // Type-specific hashing function.
2514 int TypePtr::hash(void) const {
2515   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));
2516 ;
2517 }
2518 
2519 /**
2520  * Return same type without a speculative part
2521  */
2522 const Type* TypePtr::remove_speculative() const {
2523   if (_speculative == NULL) {
2524     return this;
2525   }
2526   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2527   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2528 }
2529 
2530 /**
2531  * Return same type but drop speculative part if we know we won&#39;t use
2532  * it
2533  */
2534 const Type* TypePtr::cleanup_speculative() const {
2535   if (speculative() == NULL) {
2536     return this;
2537   }
2538   const Type* no_spec = remove_speculative();
2539   // If this is NULL_PTR then we don&#39;t need the speculative type
2540   // (with_inline_depth in case the current type inline depth is
2541   // InlineDepthTop)
2542   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2543     return no_spec;
2544   }
2545   if (above_centerline(speculative()-&gt;ptr())) {
2546     return no_spec;
2547   }
2548   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2549   // If the speculative may be null and is an inexact klass then it
2550   // doesn&#39;t help
2551   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2552       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2553     return no_spec;
2554   }
2555   return this;
2556 }
2557 
2558 /**
2559  * dual of the speculative part of the type
2560  */
2561 const TypePtr* TypePtr::dual_speculative() const {
2562   if (_speculative == NULL) {
2563     return NULL;
2564   }
2565   return _speculative-&gt;dual()-&gt;is_ptr();
2566 }
2567 
2568 /**
2569  * meet of the speculative parts of 2 types
2570  *
2571  * @param other  type to meet with
2572  */
2573 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2574   bool this_has_spec = (_speculative != NULL);
2575   bool other_has_spec = (other-&gt;speculative() != NULL);
2576 
2577   if (!this_has_spec &amp;&amp; !other_has_spec) {
2578     return NULL;
2579   }
2580 
2581   // If we are at a point where control flow meets and one branch has
2582   // a speculative type and the other has not, we meet the speculative
2583   // type of one branch with the actual type of the other. If the
2584   // actual type is exact and the speculative is as well, then the
2585   // result is a speculative type which is exact and we can continue
2586   // speculation further.
2587   const TypePtr* this_spec = _speculative;
2588   const TypePtr* other_spec = other-&gt;speculative();
2589 
2590   if (!this_has_spec) {
2591     this_spec = this;
2592   }
2593 
2594   if (!other_has_spec) {
2595     other_spec = other;
2596   }
2597 
2598   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2599 }
2600 
2601 /**
2602  * dual of the inline depth for this type (used for speculation)
2603  */
2604 int TypePtr::dual_inline_depth() const {
2605   return -inline_depth();
2606 }
2607 
2608 /**
2609  * meet of 2 inline depths (used for speculation)
2610  *
2611  * @param depth  depth to meet with
2612  */
2613 int TypePtr::meet_inline_depth(int depth) const {
2614   return MAX2(inline_depth(), depth);
2615 }
2616 
2617 /**
2618  * Are the speculative parts of 2 types equal?
2619  *
2620  * @param other  type to compare this one to
2621  */
2622 bool TypePtr::eq_speculative(const TypePtr* other) const {
2623   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2624     return _speculative == other-&gt;speculative();
2625   }
2626 
2627   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2628     return false;
2629   }
2630 
2631   return _speculative-&gt;eq(other-&gt;speculative());
2632 }
2633 
2634 /**
2635  * Hash of the speculative part of the type
2636  */
2637 int TypePtr::hash_speculative() const {
2638   if (_speculative == NULL) {
2639     return 0;
2640   }
2641 
2642   return _speculative-&gt;hash();
2643 }
2644 
2645 /**
2646  * add offset to the speculative part of the type
2647  *
2648  * @param offset  offset to add
2649  */
2650 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2651   if (_speculative == NULL) {
2652     return NULL;
2653   }
2654   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2655 }
2656 
2657 /**
2658  * return exact klass from the speculative type if there&#39;s one
2659  */
2660 ciKlass* TypePtr::speculative_type() const {
2661   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2662     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2663     if (speculative-&gt;klass_is_exact()) {
2664       return speculative-&gt;klass();
2665     }
2666   }
2667   return NULL;
2668 }
2669 
2670 /**
2671  * return true if speculative type may be null
2672  */
2673 bool TypePtr::speculative_maybe_null() const {
2674   if (_speculative != NULL) {
2675     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2676     return speculative-&gt;maybe_null();
2677   }
2678   return true;
2679 }
2680 
2681 bool TypePtr::speculative_always_null() const {
2682   if (_speculative != NULL) {
2683     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2684     return speculative == TypePtr::NULL_PTR;
2685   }
2686   return false;
2687 }
2688 
2689 /**
2690  * Same as TypePtr::speculative_type() but return the klass only if
2691  * the speculative tells us is not null
2692  */
2693 ciKlass* TypePtr::speculative_type_not_null() const {
2694   if (speculative_maybe_null()) {
2695     return NULL;
2696   }
2697   return speculative_type();
2698 }
2699 
2700 /**
2701  * Check whether new profiling would improve speculative type
2702  *
2703  * @param   exact_kls    class from profiling
2704  * @param   inline_depth inlining depth of profile point
2705  *
2706  * @return  true if type profile is valuable
2707  */
2708 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2709   // no profiling?
2710   if (exact_kls == NULL) {
2711     return false;
2712   }
2713   if (speculative() == TypePtr::NULL_PTR) {
2714     return false;
2715   }
2716   // no speculative type or non exact speculative type?
2717   if (speculative_type() == NULL) {
2718     return true;
2719   }
2720   // If the node already has an exact speculative type keep it,
2721   // unless it was provided by profiling that is at a deeper
2722   // inlining level. Profiling at a higher inlining depth is
2723   // expected to be less accurate.
2724   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2725     return false;
2726   }
2727   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2728   return inline_depth &lt; _speculative-&gt;inline_depth();
2729 }
2730 
2731 /**
2732  * Check whether new profiling would improve ptr (= tells us it is non
2733  * null)
2734  *
2735  * @param   ptr_kind always null or not null?
2736  *
2737  * @return  true if ptr profile is valuable
2738  */
2739 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
2740   // profiling doesn&#39;t tell us anything useful
2741   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
2742     return false;
2743   }
2744   // We already know this is not null
2745   if (!this-&gt;maybe_null()) {
2746     return false;
2747   }
2748   // We already know the speculative type cannot be null
2749   if (!speculative_maybe_null()) {
2750     return false;
2751   }
2752   // We already know this is always null
2753   if (this == TypePtr::NULL_PTR) {
2754     return false;
2755   }
2756   // We already know the speculative type is always null
2757   if (speculative_always_null()) {
2758     return false;
2759   }
2760   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2761     return false;
2762   }
2763   return true;
2764 }
2765 
2766 //------------------------------dump2------------------------------------------
2767 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2768   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2769 };
2770 
2771 #ifndef PRODUCT
2772 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2773   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2774   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
2775   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);
2776   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);
2777   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);
2778   dump_inline_depth(st);
2779   dump_speculative(st);
2780 }
2781 
2782 /**
2783  *dump the speculative part of the type
2784  */
2785 void TypePtr::dump_speculative(outputStream *st) const {
2786   if (_speculative != NULL) {
2787     st-&gt;print(&quot; (speculative=&quot;);
2788     _speculative-&gt;dump_on(st);
2789     st-&gt;print(&quot;)&quot;);
2790   }
2791 }
2792 
2793 /**
2794  *dump the inline depth of the type
2795  */
2796 void TypePtr::dump_inline_depth(outputStream *st) const {
2797   if (_inline_depth != InlineDepthBottom) {
2798     if (_inline_depth == InlineDepthTop) {
2799       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2800     } else {
2801       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2802     }
2803   }
2804 }
2805 #endif
2806 
2807 //------------------------------singleton--------------------------------------
2808 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2809 // constants
2810 bool TypePtr::singleton(void) const {
2811   // TopPTR, Null, AnyNull, Constant are all singletons
2812   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);
2813 }
2814 
2815 bool TypePtr::empty(void) const {
2816   return (_offset == OffsetTop) || above_centerline(_ptr);
2817 }
2818 
2819 //=============================================================================
2820 // Convenience common pre-built types.
2821 const TypeRawPtr *TypeRawPtr::BOTTOM;
2822 const TypeRawPtr *TypeRawPtr::NOTNULL;
2823 
2824 //------------------------------make-------------------------------------------
2825 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2826   assert( ptr != Constant, &quot;what is the constant?&quot; );
2827   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2828   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2829 }
2830 
2831 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2832   assert( bits, &quot;Use TypePtr for NULL&quot; );
2833   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2834 }
2835 
2836 //------------------------------cast_to_ptr_type-------------------------------
2837 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
2838   assert( ptr != Constant, &quot;what is the constant?&quot; );
2839   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2840   assert( _bits==0, &quot;Why cast a constant address?&quot;);
2841   if( ptr == _ptr ) return this;
2842   return make(ptr);
2843 }
2844 
2845 //------------------------------get_con----------------------------------------
2846 intptr_t TypeRawPtr::get_con() const {
2847   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
2848   return (intptr_t)_bits;
2849 }
2850 
2851 //------------------------------meet-------------------------------------------
2852 // Compute the MEET of two types.  It returns a new Type object.
2853 const Type *TypeRawPtr::xmeet( const Type *t ) const {
2854   // Perform a fast test for common case; meeting the same types together.
2855   if( this == t ) return this;  // Meeting same type-rep?
2856 
2857   // Current &quot;this-&gt;_base&quot; is RawPtr
2858   switch( t-&gt;base() ) {         // switch on original type
2859   case Bottom:                  // Ye Olde Default
2860     return t;
2861   case Top:
2862     return this;
2863   case AnyPtr:                  // Meeting to AnyPtrs
2864     break;
2865   case RawPtr: {                // might be top, bot, any/not or constant
2866     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
2867     enum PTR ptr = meet_ptr( tptr );
2868     if( ptr == Constant ) {     // Cannot be equal constants, so...
2869       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
2870       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
2871       ptr = NotNull;            // Fall down in lattice
2872     }
2873     return make( ptr );
2874   }
2875 
2876   case OopPtr:
2877   case InstPtr:
2878   case AryPtr:
2879   case MetadataPtr:
2880   case KlassPtr:
2881     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
2882   default:                      // All else is a mistake
2883     typerr(t);
2884   }
2885 
2886   // Found an AnyPtr type vs self-RawPtr type
2887   const TypePtr *tp = t-&gt;is_ptr();
2888   switch (tp-&gt;ptr()) {
2889   case TypePtr::TopPTR:  return this;
2890   case TypePtr::BotPTR:  return t;
2891   case TypePtr::Null:
2892     if( _ptr == TypePtr::TopPTR ) return t;
2893     return TypeRawPtr::BOTTOM;
2894   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
2895   case TypePtr::AnyNull:
2896     if( _ptr == TypePtr::Constant) return this;
2897     return make( meet_ptr(TypePtr::AnyNull) );
2898   default: ShouldNotReachHere();
2899   }
2900   return this;
2901 }
2902 
2903 //------------------------------xdual------------------------------------------
2904 // Dual: compute field-by-field dual
2905 const Type *TypeRawPtr::xdual() const {
2906   return new TypeRawPtr( dual_ptr(), _bits );
2907 }
2908 
2909 //------------------------------add_offset-------------------------------------
2910 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
2911   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
2912   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
2913   if( offset == 0 ) return this; // No change
2914   switch (_ptr) {
2915   case TypePtr::TopPTR:
2916   case TypePtr::BotPTR:
2917   case TypePtr::NotNull:
2918     return this;
2919   case TypePtr::Null:
2920   case TypePtr::Constant: {
2921     address bits = _bits+offset;
2922     if ( bits == 0 ) return TypePtr::NULL_PTR;
2923     return make( bits );
2924   }
2925   default:  ShouldNotReachHere();
2926   }
2927   return NULL;                  // Lint noise
2928 }
2929 
2930 //------------------------------eq---------------------------------------------
2931 // Structural equality check for Type representations
2932 bool TypeRawPtr::eq( const Type *t ) const {
2933   const TypeRawPtr *a = (const TypeRawPtr*)t;
2934   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
2935 }
2936 
2937 //------------------------------hash-------------------------------------------
2938 // Type-specific hashing function.
2939 int TypeRawPtr::hash(void) const {
2940   return (intptr_t)_bits + TypePtr::hash();
2941 }
2942 
2943 //------------------------------dump2------------------------------------------
2944 #ifndef PRODUCT
2945 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2946   if( _ptr == Constant )
2947     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2948   else
2949     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2950 }
2951 #endif
2952 
2953 //=============================================================================
2954 // Convenience common pre-built type.
2955 const TypeOopPtr *TypeOopPtr::BOTTOM;
2956 
2957 //------------------------------TypeOopPtr-------------------------------------
2958 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
2959                        int instance_id, const TypePtr* speculative, int inline_depth)
2960   : TypePtr(t, ptr, offset, speculative, inline_depth),
2961     _const_oop(o), _klass(k),
2962     _klass_is_exact(xk),
2963     _is_ptr_to_narrowoop(false),
2964     _is_ptr_to_narrowklass(false),
2965     _is_ptr_to_boxed_value(false),
2966     _instance_id(instance_id) {
2967   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
2968       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
2969     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);
2970   }
2971 #ifdef _LP64
2972   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {
2973     if (_offset == oopDesc::klass_offset_in_bytes()) {
2974       _is_ptr_to_narrowklass = UseCompressedClassPointers;
2975     } else if (klass() == NULL) {
2976       // Array with unknown body type
2977       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
2978       _is_ptr_to_narrowoop = UseCompressedOops;
2979     } else if (this-&gt;isa_aryptr()) {
2980       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;
2981                              _offset != arrayOopDesc::length_offset_in_bytes());
2982     } else if (klass()-&gt;is_instance_klass()) {
2983       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
2984       ciField* field = NULL;
2985       if (this-&gt;isa_klassptr()) {
2986         // Perm objects don&#39;t use compressed references
2987       } else if (_offset == OffsetBot || _offset == OffsetTop) {
2988         // unsafe access
2989         _is_ptr_to_narrowoop = UseCompressedOops;
2990       } else { // exclude unsafe ops
2991         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2992 
2993         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
2994             (_offset == java_lang_Class::klass_offset_in_bytes() ||
2995              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
2996           // Special hidden fields from the Class.
2997           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2998           _is_ptr_to_narrowoop = false;
2999         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3000                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3001           // Static fields
3002           assert(o != NULL, &quot;must be constant&quot;);
3003           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3004           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3005           assert(field != NULL, &quot;missing field&quot;);
3006           BasicType basic_elem_type = field-&gt;layout_type();
3007           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3008         } else {
3009           // Instance fields which contains a compressed oop references.
3010           field = ik-&gt;get_field_by_offset(_offset, false);
3011           if (field != NULL) {
3012             BasicType basic_elem_type = field-&gt;layout_type();
3013             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3014           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3015             // Compile::find_alias_type() cast exactness on all types to verify
3016             // that it does not affect alias type.
3017             _is_ptr_to_narrowoop = UseCompressedOops;
3018           } else {
3019             // Type for the copy start in LibraryCallKit::inline_native_clone().
3020             _is_ptr_to_narrowoop = UseCompressedOops;
3021           }
3022         }
3023       }
3024     }
3025   }
3026 #endif
3027 }
3028 
3029 //------------------------------make-------------------------------------------
3030 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3031                                      const TypePtr* speculative, int inline_depth) {
3032   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3033   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3034   bool      xk = false;
3035   ciObject* o = NULL;
3036   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3037 }
3038 
3039 
3040 //------------------------------cast_to_ptr_type-------------------------------
3041 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3042   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3043   if( ptr == _ptr ) return this;
3044   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3045 }
3046 
3047 //-----------------------------cast_to_instance_id----------------------------
3048 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3049   // There are no instances of a general oop.
3050   // Return self unchanged.
3051   return this;
3052 }
3053 
3054 //-----------------------------cast_to_exactness-------------------------------
3055 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3056   // There is no such thing as an exact general oop.
3057   // Return self unchanged.
3058   return this;
3059 }
3060 
3061 
3062 //------------------------------as_klass_type----------------------------------
3063 // Return the klass type corresponding to this instance or array type.
3064 // It is the type that is loaded from an object of this type.
3065 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3066   ciKlass* k = klass();
3067   bool    xk = klass_is_exact();
3068   if (k == NULL)
3069     return TypeKlassPtr::OBJECT;
3070   else
3071     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3072 }
3073 
3074 //------------------------------meet-------------------------------------------
3075 // Compute the MEET of two types.  It returns a new Type object.
3076 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3077   // Perform a fast test for common case; meeting the same types together.
3078   if( this == t ) return this;  // Meeting same type-rep?
3079 
3080   // Current &quot;this-&gt;_base&quot; is OopPtr
3081   switch (t-&gt;base()) {          // switch on original type
3082 
3083   case Int:                     // Mixing ints &amp; oops happens when javac
3084   case Long:                    // reuses local variables
3085   case FloatTop:
3086   case FloatCon:
3087   case FloatBot:
3088   case DoubleTop:
3089   case DoubleCon:
3090   case DoubleBot:
3091   case NarrowOop:
3092   case NarrowKlass:
3093   case Bottom:                  // Ye Olde Default
3094     return Type::BOTTOM;
3095   case Top:
3096     return this;
3097 
3098   default:                      // All else is a mistake
3099     typerr(t);
3100 
3101   case RawPtr:
3102   case MetadataPtr:
3103   case KlassPtr:
3104     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3105 
3106   case AnyPtr: {
3107     // Found an AnyPtr type vs self-OopPtr type
3108     const TypePtr *tp = t-&gt;is_ptr();
3109     int offset = meet_offset(tp-&gt;offset());
3110     PTR ptr = meet_ptr(tp-&gt;ptr());
3111     const TypePtr* speculative = xmeet_speculative(tp);
3112     int depth = meet_inline_depth(tp-&gt;inline_depth());
3113     switch (tp-&gt;ptr()) {
3114     case Null:
3115       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3116       // else fall through:
3117     case TopPTR:
3118     case AnyNull: {
3119       int instance_id = meet_instance_id(InstanceTop);
3120       return make(ptr, offset, instance_id, speculative, depth);
3121     }
3122     case BotPTR:
3123     case NotNull:
3124       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3125     default: typerr(t);
3126     }
3127   }
3128 
3129   case OopPtr: {                 // Meeting to other OopPtrs
3130     const TypeOopPtr *tp = t-&gt;is_oopptr();
3131     int instance_id = meet_instance_id(tp-&gt;instance_id());
3132     const TypePtr* speculative = xmeet_speculative(tp);
3133     int depth = meet_inline_depth(tp-&gt;inline_depth());
3134     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3135   }
3136 
3137   case InstPtr:                  // For these, flip the call around to cut down
3138   case AryPtr:
3139     return t-&gt;xmeet(this);      // Call in reverse direction
3140 
3141   } // End of switch
3142   return this;                  // Return the double constant
3143 }
3144 
3145 
3146 //------------------------------xdual------------------------------------------
3147 // Dual of a pure heap pointer.  No relevant klass or oop information.
3148 const Type *TypeOopPtr::xdual() const {
3149   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3150   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3151   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3152 }
3153 
3154 //--------------------------make_from_klass_common-----------------------------
3155 // Computes the element-type given a klass.
3156 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3157   if (klass-&gt;is_instance_klass()) {
3158     Compile* C = Compile::current();
3159     Dependencies* deps = C-&gt;dependencies();
3160     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3161     // Element is an instance
3162     bool klass_is_exact = false;
3163     if (klass-&gt;is_loaded()) {
3164       // Try to set klass_is_exact.
3165       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3166       klass_is_exact = ik-&gt;is_final();
3167       if (!klass_is_exact &amp;&amp; klass_change
3168           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3169         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3170         if (sub != NULL) {
3171           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3172           klass = ik = sub;
3173           klass_is_exact = sub-&gt;is_final();
3174         }
3175       }
3176       if (!klass_is_exact &amp;&amp; try_for_exact
3177           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3178         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3179           // Add a dependence; if concrete subclass added we need to recompile
3180           deps-&gt;assert_leaf_type(ik);
3181           klass_is_exact = true;
3182         }
3183       }
3184     }
3185     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);
3186   } else if (klass-&gt;is_obj_array_klass()) {
3187     // Element is an object array. Recursively call ourself.
3188     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);
3189     bool xk = etype-&gt;klass_is_exact();
3190     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3191     // We used to pass NotNull in here, asserting that the sub-arrays
3192     // are all not-null.  This is not true in generally, as code can
3193     // slam NULLs down in the subarrays.
3194     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);
3195     return arr;
3196   } else if (klass-&gt;is_type_array_klass()) {
3197     // Element is an typeArray
3198     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3199     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3200     // We used to pass NotNull in here, asserting that the array pointer
3201     // is not-null. That was not true in general.
3202     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);
3203     return arr;
3204   } else {
3205     ShouldNotReachHere();
3206     return NULL;
3207   }
3208 }
3209 
3210 //------------------------------make_from_constant-----------------------------
3211 // Make a java pointer from an oop constant
3212 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3213   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3214 
3215   const bool make_constant = require_constant || o-&gt;should_be_constant();
3216 
3217   ciKlass* klass = o-&gt;klass();
3218   if (klass-&gt;is_instance_klass()) {
3219     // Element is an instance
3220     if (make_constant) {
3221       return TypeInstPtr::make(o);
3222     } else {
3223       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);
3224     }
3225   } else if (klass-&gt;is_obj_array_klass()) {
3226     // Element is an object array. Recursively call ourself.
3227     const TypeOopPtr *etype =
3228       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());
3229     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3230     // We used to pass NotNull in here, asserting that the sub-arrays
3231     // are all not-null.  This is not true in generally, as code can
3232     // slam NULLs down in the subarrays.
3233     if (make_constant) {
3234       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3235     } else {
3236       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3237     }
3238   } else if (klass-&gt;is_type_array_klass()) {
3239     // Element is an typeArray
3240     const Type* etype =
3241       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3242     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3243     // We used to pass NotNull in here, asserting that the array pointer
3244     // is not-null. That was not true in general.
3245     if (make_constant) {
3246       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3247     } else {
3248       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3249     }
3250   }
3251 
3252   fatal(&quot;unhandled object type&quot;);
3253   return NULL;
3254 }
3255 
3256 //------------------------------get_con----------------------------------------
3257 intptr_t TypeOopPtr::get_con() const {
3258   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3259   assert( _offset &gt;= 0, &quot;&quot; );
3260 
3261   if (_offset != 0) {
3262     // After being ported to the compiler interface, the compiler no longer
3263     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3264     // to a handle at compile time.  This handle is embedded in the generated
3265     // code and dereferenced at the time the nmethod is made.  Until that time,
3266     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3267     // have access to the addresses!).  This does not seem to currently happen,
3268     // but this assertion here is to help prevent its occurence.
3269     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3270     ShouldNotReachHere();
3271   }
3272 
3273   return (intptr_t)const_oop()-&gt;constant_encoding();
3274 }
3275 
3276 
3277 //-----------------------------filter------------------------------------------
3278 // Do not allow interface-vs.-noninterface joins to collapse to top.
3279 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3280 
3281   const Type* ft = join_helper(kills, include_speculative);
3282   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3283   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3284 
3285   if (ft-&gt;empty()) {
3286     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3287     // interface.  This can happen because the bytecodes do not contain
3288     // enough type info to distinguish a Java-level interface variable
3289     // from a Java-level object variable.  If we meet 2 classes which
3290     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3291     // doesn&#39;t implement I, we have no way to tell if the result should
3292     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3293     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3294     // uplift the type.
3295     if (!empty()) {
3296       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3297         return kills;           // Uplift to interface
3298       }
3299       // Also check for evil cases of &#39;this&#39; being a class array
3300       // and &#39;kills&#39; expecting an array of interfaces.
3301       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3302       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3303         return kills;           // Uplift to array of interface
3304       }
3305     }
3306 
3307     return Type::TOP;           // Canonical empty value
3308   }
3309 
3310   // If we have an interface-typed Phi or cast and we narrow to a class type,
3311   // the join should report back the class.  However, if we have a J/L/Object
3312   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3313   // join report an interface back out.  This isn&#39;t possible but happens
3314   // because the type system doesn&#39;t interact well with interfaces.
3315   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3316       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3317       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3318     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3319     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3320   }
3321 
3322   return ft;
3323 }
3324 
3325 //------------------------------eq---------------------------------------------
3326 // Structural equality check for Type representations
3327 bool TypeOopPtr::eq( const Type *t ) const {
3328   const TypeOopPtr *a = (const TypeOopPtr*)t;
3329   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3330       _instance_id != a-&gt;_instance_id)  return false;
3331   ciObject* one = const_oop();
3332   ciObject* two = a-&gt;const_oop();
3333   if (one == NULL || two == NULL) {
3334     return (one == two) &amp;&amp; TypePtr::eq(t);
3335   } else {
3336     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3337   }
3338 }
3339 
3340 //------------------------------hash-------------------------------------------
3341 // Type-specific hashing function.
3342 int TypeOopPtr::hash(void) const {
3343   return
3344     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3345              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3346 }
3347 
3348 //------------------------------dump2------------------------------------------
3349 #ifndef PRODUCT
3350 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3351   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3352   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3353   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3354   switch( _offset ) {
3355   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
3356   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
3357   case         0: break;
3358   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
3359   }
3360   if (_instance_id == InstanceTop)
3361     st-&gt;print(&quot;,iid=top&quot;);
3362   else if (_instance_id != InstanceBot)
3363     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3364 
3365   dump_inline_depth(st);
3366   dump_speculative(st);
3367 }
3368 #endif
3369 
3370 //------------------------------singleton--------------------------------------
3371 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3372 // constants
3373 bool TypeOopPtr::singleton(void) const {
3374   // detune optimizer to not generate constant oop + constant offset as a constant!
3375   // TopPTR, Null, AnyNull, Constant are all singletons
3376   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
3377 }
3378 
3379 //------------------------------add_offset-------------------------------------
3380 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3381   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3382 }
3383 
3384 /**
3385  * Return same type without a speculative part
3386  */
3387 const Type* TypeOopPtr::remove_speculative() const {
3388   if (_speculative == NULL) {
3389     return this;
3390   }
3391   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3392   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3393 }
3394 
3395 /**
3396  * Return same type but drop speculative part if we know we won&#39;t use
3397  * it
3398  */
3399 const Type* TypeOopPtr::cleanup_speculative() const {
3400   // If the klass is exact and the ptr is not null then there&#39;s
3401   // nothing that the speculative type can help us with
3402   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3403     return remove_speculative();
3404   }
3405   return TypePtr::cleanup_speculative();
3406 }
3407 
3408 /**
3409  * Return same type but with a different inline depth (used for speculation)
3410  *
3411  * @param depth  depth to meet with
3412  */
3413 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3414   if (!UseInlineDepthForSpeculativeTypes) {
3415     return this;
3416   }
3417   return make(_ptr, _offset, _instance_id, _speculative, depth);
3418 }
3419 
3420 //------------------------------with_instance_id--------------------------------
3421 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3422   assert(_instance_id != -1, &quot;should be known&quot;);
3423   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3424 }
3425 
3426 //------------------------------meet_instance_id--------------------------------
3427 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3428   // Either is &#39;TOP&#39; instance?  Return the other instance!
3429   if( _instance_id == InstanceTop ) return  instance_id;
3430   if(  instance_id == InstanceTop ) return _instance_id;
3431   // If either is different, return &#39;BOTTOM&#39; instance
3432   if( _instance_id != instance_id ) return InstanceBot;
3433   return _instance_id;
3434 }
3435 
3436 //------------------------------dual_instance_id--------------------------------
3437 int TypeOopPtr::dual_instance_id( ) const {
3438   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3439   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3440   return _instance_id;              // Map everything else into self
3441 }
3442 
3443 /**
3444  * Check whether new profiling would improve speculative type
3445  *
3446  * @param   exact_kls    class from profiling
3447  * @param   inline_depth inlining depth of profile point
3448  *
3449  * @return  true if type profile is valuable
3450  */
3451 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3452   // no way to improve an already exact type
3453   if (klass_is_exact()) {
3454     return false;
3455   }
3456   return TypePtr::would_improve_type(exact_kls, inline_depth);
3457 }
3458 
3459 //=============================================================================
3460 // Convenience common pre-built types.
3461 const TypeInstPtr *TypeInstPtr::NOTNULL;
3462 const TypeInstPtr *TypeInstPtr::BOTTOM;
3463 const TypeInstPtr *TypeInstPtr::MIRROR;
3464 const TypeInstPtr *TypeInstPtr::MARK;
3465 const TypeInstPtr *TypeInstPtr::KLASS;
3466 
3467 //------------------------------TypeInstPtr-------------------------------------
3468 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,
3469                          int instance_id, const TypePtr* speculative, int inline_depth)
3470   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),
3471     _name(k-&gt;name()) {
3472    assert(k != NULL &amp;&amp;
3473           (k-&gt;is_loaded() || o == NULL),
3474           &quot;cannot have constants with non-loaded klass&quot;);
3475 };
3476 
3477 //------------------------------make-------------------------------------------
3478 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3479                                      ciKlass* k,
3480                                      bool xk,
3481                                      ciObject* o,
3482                                      int offset,
3483                                      int instance_id,
3484                                      const TypePtr* speculative,
3485                                      int inline_depth) {
3486   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3487   // Either const_oop() is NULL or else ptr is Constant
3488   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3489           &quot;constant pointers must have a value supplied&quot; );
3490   // Ptr is never Null
3491   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3492 
3493   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3494   if (!UseExactTypes)  xk = false;
3495   if (ptr == Constant) {
3496     // Note:  This case includes meta-object constants, such as methods.
3497     xk = true;
3498   } else if (k-&gt;is_loaded()) {
3499     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3500     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3501     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3502   }
3503 
3504   // Now hash this baby
3505   TypeInstPtr *result =
3506     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3507 
3508   return result;
3509 }
3510 
3511 /**
3512  *  Create constant type for a constant boxed value
3513  */
3514 const Type* TypeInstPtr::get_const_boxed_value() const {
3515   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3516   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3517   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3518   BasicType bt = constant.basic_type();
3519   switch (bt) {
3520     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3521     case T_INT:      return TypeInt::make(constant.as_int());
3522     case T_CHAR:     return TypeInt::make(constant.as_char());
3523     case T_BYTE:     return TypeInt::make(constant.as_byte());
3524     case T_SHORT:    return TypeInt::make(constant.as_short());
3525     case T_FLOAT:    return TypeF::make(constant.as_float());
3526     case T_DOUBLE:   return TypeD::make(constant.as_double());
3527     case T_LONG:     return TypeLong::make(constant.as_long());
3528     default:         break;
3529   }
3530   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3531   return NULL;
3532 }
3533 
3534 //------------------------------cast_to_ptr_type-------------------------------
3535 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3536   if( ptr == _ptr ) return this;
3537   // Reconstruct _sig info here since not a problem with later lazy
3538   // construction, _sig will show up on demand.
3539   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3540 }
3541 
3542 
3543 //-----------------------------cast_to_exactness-------------------------------
3544 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3545   if( klass_is_exact == _klass_is_exact ) return this;
3546   if (!UseExactTypes)  return this;
3547   if (!_klass-&gt;is_loaded())  return this;
3548   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3549   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3550   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3551   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3552 }
3553 
3554 //-----------------------------cast_to_instance_id----------------------------
3555 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3556   if( instance_id == _instance_id ) return this;
3557   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3558 }
3559 
3560 //------------------------------xmeet_unloaded---------------------------------
3561 // Compute the MEET of two InstPtrs when at least one is unloaded.
3562 // Assume classes are different since called after check for same name/class-loader
3563 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3564     int off = meet_offset(tinst-&gt;offset());
3565     PTR ptr = meet_ptr(tinst-&gt;ptr());
3566     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3567     const TypePtr* speculative = xmeet_speculative(tinst);
3568     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3569 
3570     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3571     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3572     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3573       //
3574       // Meet unloaded class with java/lang/Object
3575       //
3576       // Meet
3577       //          |                     Unloaded Class
3578       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3579       //  ===================================================================
3580       //   TOP    | ..........................Unloaded......................|
3581       //  AnyNull |  U-AN    |................Unloaded......................|
3582       // Constant | ... O-NN .................................. |   O-BOT   |
3583       //  NotNull | ... O-NN .................................. |   O-BOT   |
3584       //  BOTTOM  | ........................Object-BOTTOM ..................|
3585       //
3586       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3587       //
3588       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3589       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }
3590       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3591       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3592         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3593         else                                      { return TypeInstPtr::NOTNULL; }
3594       }
3595       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3596 
3597       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3598     }
3599 
3600     // Both are unloaded, not the same class, not Object
3601     // Or meet unloaded with a different loaded class, not java/lang/Object
3602     if( ptr != TypePtr::BotPTR ) {
3603       return TypeInstPtr::NOTNULL;
3604     }
3605     return TypeInstPtr::BOTTOM;
3606 }
3607 
3608 
3609 //------------------------------meet-------------------------------------------
3610 // Compute the MEET of two types.  It returns a new Type object.
3611 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3612   // Perform a fast test for common case; meeting the same types together.
3613   if( this == t ) return this;  // Meeting same type-rep?
3614 
3615   // Current &quot;this-&gt;_base&quot; is Pointer
3616   switch (t-&gt;base()) {          // switch on original type
3617 
3618   case Int:                     // Mixing ints &amp; oops happens when javac
3619   case Long:                    // reuses local variables
3620   case FloatTop:
3621   case FloatCon:
3622   case FloatBot:
3623   case DoubleTop:
3624   case DoubleCon:
3625   case DoubleBot:
3626   case NarrowOop:
3627   case NarrowKlass:
3628   case Bottom:                  // Ye Olde Default
3629     return Type::BOTTOM;
3630   case Top:
3631     return this;
3632 
3633   default:                      // All else is a mistake
3634     typerr(t);
3635 
3636   case MetadataPtr:
3637   case KlassPtr:
3638   case RawPtr: return TypePtr::BOTTOM;
3639 
3640   case AryPtr: {                // All arrays inherit from Object class
3641     const TypeAryPtr *tp = t-&gt;is_aryptr();
3642     int offset = meet_offset(tp-&gt;offset());
3643     PTR ptr = meet_ptr(tp-&gt;ptr());
3644     int instance_id = meet_instance_id(tp-&gt;instance_id());
3645     const TypePtr* speculative = xmeet_speculative(tp);
3646     int depth = meet_inline_depth(tp-&gt;inline_depth());
3647     switch (ptr) {
3648     case TopPTR:
3649     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3650       // For instances when a subclass meets a superclass we fall
3651       // below the centerline when the superclass is exact. We need to
3652       // do the same here.
3653       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3654         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3655       } else {
3656         // cannot subclass, so the meet has to fall badly below the centerline
3657         ptr = NotNull;
3658         instance_id = InstanceBot;
3659         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3660       }
3661     case Constant:
3662     case NotNull:
3663     case BotPTR:                // Fall down to object klass
3664       // LCA is object_klass, but if we subclass from the top we can do better
3665       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3666         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3667         // then we can subclass in the Java class hierarchy.
3668         // For instances when a subclass meets a superclass we fall
3669         // below the centerline when the superclass is exact. We need
3670         // to do the same here.
3671         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3672           // that is, tp&#39;s array type is a subtype of my klass
3673           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3674                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3675         }
3676       }
3677       // The other case cannot happen, since I cannot be a subtype of an array.
3678       // The meet falls down to Object class below centerline.
3679       if( ptr == Constant )
3680          ptr = NotNull;
3681       instance_id = InstanceBot;
3682       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3683     default: typerr(t);
3684     }
3685   }
3686 
3687   case OopPtr: {                // Meeting to OopPtrs
3688     // Found a OopPtr type vs self-InstPtr type
3689     const TypeOopPtr *tp = t-&gt;is_oopptr();
3690     int offset = meet_offset(tp-&gt;offset());
3691     PTR ptr = meet_ptr(tp-&gt;ptr());
3692     switch (tp-&gt;ptr()) {
3693     case TopPTR:
3694     case AnyNull: {
3695       int instance_id = meet_instance_id(InstanceTop);
3696       const TypePtr* speculative = xmeet_speculative(tp);
3697       int depth = meet_inline_depth(tp-&gt;inline_depth());
3698       return make(ptr, klass(), klass_is_exact(),
3699                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3700     }
3701     case NotNull:
3702     case BotPTR: {
3703       int instance_id = meet_instance_id(tp-&gt;instance_id());
3704       const TypePtr* speculative = xmeet_speculative(tp);
3705       int depth = meet_inline_depth(tp-&gt;inline_depth());
3706       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3707     }
3708     default: typerr(t);
3709     }
3710   }
3711 
3712   case AnyPtr: {                // Meeting to AnyPtrs
3713     // Found an AnyPtr type vs self-InstPtr type
3714     const TypePtr *tp = t-&gt;is_ptr();
3715     int offset = meet_offset(tp-&gt;offset());
3716     PTR ptr = meet_ptr(tp-&gt;ptr());
3717     int instance_id = meet_instance_id(InstanceTop);
3718     const TypePtr* speculative = xmeet_speculative(tp);
3719     int depth = meet_inline_depth(tp-&gt;inline_depth());
3720     switch (tp-&gt;ptr()) {
3721     case Null:
3722       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3723       // else fall through to AnyNull
3724     case TopPTR:
3725     case AnyNull: {
3726       return make(ptr, klass(), klass_is_exact(),
3727                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3728     }
3729     case NotNull:
3730     case BotPTR:
3731       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3732     default: typerr(t);
3733     }
3734   }
3735 
3736   /*
3737                  A-top         }
3738                /   |   \       }  Tops
3739            B-top A-any C-top   }
3740               | /  |  \ |      }  Any-nulls
3741            B-any   |   C-any   }
3742               |    |    |
3743            B-con A-con C-con   } constants; not comparable across classes
3744               |    |    |
3745            B-not   |   C-not   }
3746               | \  |  / |      }  not-nulls
3747            B-bot A-not C-bot   }
3748                \   |   /       }  Bottoms
3749                  A-bot         }
3750   */
3751 
3752   case InstPtr: {                // Meeting 2 Oops?
3753     // Found an InstPtr sub-type vs self-InstPtr type
3754     const TypeInstPtr *tinst = t-&gt;is_instptr();
3755     int off = meet_offset( tinst-&gt;offset() );
3756     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3757     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3758     const TypePtr* speculative = xmeet_speculative(tinst);
3759     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3760 
3761     // Check for easy case; klasses are equal (and perhaps not loaded!)
3762     // If we have constants, then we created oops so classes are loaded
3763     // and we can handle the constants further down.  This case handles
3764     // both-not-loaded or both-loaded classes
3765     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {
3766       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);
3767     }
3768 
3769     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3770     ciKlass* tinst_klass = tinst-&gt;klass();
3771     ciKlass* this_klass  = this-&gt;klass();
3772     bool tinst_xk = tinst-&gt;klass_is_exact();
3773     bool this_xk  = this-&gt;klass_is_exact();
3774     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3775       // One of these classes has not been loaded
3776       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3777 #ifndef PRODUCT
3778       if( PrintOpto &amp;&amp; Verbose ) {
3779         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3780         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3781         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3782       }
3783 #endif
3784       return unloaded_meet;
3785     }
3786 
3787     // Handle mixing oops and interfaces first.
3788     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3789                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3790       ciKlass *tmp = tinst_klass; // Swap interface around
3791       tinst_klass = this_klass;
3792       this_klass = tmp;
3793       bool tmp2 = tinst_xk;
3794       tinst_xk = this_xk;
3795       this_xk = tmp2;
3796     }
3797     if (tinst_klass-&gt;is_interface() &amp;&amp;
3798         !(this_klass-&gt;is_interface() ||
3799           // Treat java/lang/Object as an honorary interface,
3800           // because we need a bottom for the interface hierarchy.
3801           this_klass == ciEnv::current()-&gt;Object_klass())) {
3802       // Oop meets interface!
3803 
3804       // See if the oop subtypes (implements) interface.
3805       ciKlass *k;
3806       bool xk;
3807       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3808         // Oop indeed subtypes.  Now keep oop or interface depending
3809         // on whether we are both above the centerline or either is
3810         // below the centerline.  If we are on the centerline
3811         // (e.g., Constant vs. AnyNull interface), use the constant.
3812         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3813         // If we are keeping this_klass, keep its exactness too.
3814         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
3815       } else {                  // Does not implement, fall to Object
3816         // Oop does not implement interface, so mixing falls to Object
3817         // just like the verifier does (if both are above the
3818         // centerline fall to interface)
3819         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3820         xk = above_centerline(ptr) ? tinst_xk : false;
3821         // Watch out for Constant vs. AnyNull interface.
3822         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3823         instance_id = InstanceBot;
3824       }
3825       ciObject* o = NULL;  // the Constant value, if any
3826       if (ptr == Constant) {
3827         // Find out which constant.
3828         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3829       }
3830       return make(ptr, k, xk, o, off, instance_id, speculative, depth);
3831     }
3832 
3833     // Either oop vs oop or interface vs interface or interface vs Object
3834 
3835     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3836     // If we split one up &amp; one down AND they subtype, take the down man.
3837     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3838     // If both are up and they subtype, take the subtype class.
3839     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3840     // If both are down and they subtype, take the supertype class.
3841     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3842     // Constants treated as down.
3843 
3844     // Now, reorder the above list; observe that both-down+subtype is also
3845     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3846     // If we split one up &amp; one down AND they subtype, take the down man.
3847     // If both are up and they subtype, take the subtype class.
3848 
3849     // If both are down and they subtype, &quot;fall hard&quot;.
3850     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3851     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3852     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3853 
3854     // If a proper subtype is exact, and we return it, we return it exactly.
3855     // If a proper supertype is exact, there can be no subtyping relationship!
3856     // If both types are equal to the subtype, exactness is and-ed below the
3857     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3858 
3859     // Check for subtyping:
3860     ciKlass *subtype = NULL;
3861     bool subtype_exact = false;
3862     if( tinst_klass-&gt;equals(this_klass) ) {
3863       subtype = this_klass;
3864       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
3865     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3866       subtype = this_klass;     // Pick subtyping class
3867       subtype_exact = this_xk;
3868     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3869       subtype = tinst_klass;    // Pick subtyping class
3870       subtype_exact = tinst_xk;
3871     }
3872 
3873     if( subtype ) {
3874       if( above_centerline(ptr) ) { // both are up?
3875         this_klass = tinst_klass = subtype;
3876         this_xk = tinst_xk = subtype_exact;
3877       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3878         this_klass = tinst_klass; // tinst is down; keep down man
3879         this_xk = tinst_xk;
3880       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3881         tinst_klass = this_klass; // this is down; keep down man
3882         tinst_xk = this_xk;
3883       } else {
3884         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
3885       }
3886     }
3887 
3888     // Check for classes now being equal
3889     if (tinst_klass-&gt;equals(this_klass)) {
3890       // If the klasses are equal, the constants may still differ.  Fall to
3891       // NotNull if they do (neither constant is NULL; that is a special case
3892       // handled elsewhere).
3893       ciObject* o = NULL;             // Assume not constant when done
3894       ciObject* this_oop  = const_oop();
3895       ciObject* tinst_oop = tinst-&gt;const_oop();
3896       if( ptr == Constant ) {
3897         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3898             this_oop-&gt;equals(tinst_oop) )
3899           o = this_oop;
3900         else if (above_centerline(this -&gt;_ptr))
3901           o = tinst_oop;
3902         else if (above_centerline(tinst -&gt;_ptr))
3903           o = this_oop;
3904         else
3905           ptr = NotNull;
3906       }
3907       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);
3908     } // Else classes are not equal
3909 
3910     // Since klasses are different, we require a LCA in the Java
3911     // class hierarchy - which means we have to fall to at least NotNull.
3912     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3913       ptr = NotNull;
3914 
3915     instance_id = InstanceBot;
3916 
3917     // Now we find the LCA of Java classes
3918     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
3919     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);
3920   } // End of case InstPtr
3921 
3922   } // End of switch
3923   return this;                  // Return the double constant
3924 }
3925 
3926 
3927 //------------------------java_mirror_type--------------------------------------
3928 ciType* TypeInstPtr::java_mirror_type() const {
3929   // must be a singleton type
3930   if( const_oop() == NULL )  return NULL;
3931 
3932   // must be of type java.lang.Class
3933   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
3934 
3935   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3936 }
3937 
3938 
3939 //------------------------------xdual------------------------------------------
3940 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3941 // inheritance mechanism.
3942 const Type *TypeInstPtr::xdual() const {
3943   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3944 }
3945 
3946 //------------------------------eq---------------------------------------------
3947 // Structural equality check for Type representations
3948 bool TypeInstPtr::eq( const Type *t ) const {
3949   const TypeInstPtr *p = t-&gt;is_instptr();
3950   return
3951     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
3952     TypeOopPtr::eq(p);          // Check sub-type stuff
3953 }
3954 
3955 //------------------------------hash-------------------------------------------
3956 // Type-specific hashing function.
3957 int TypeInstPtr::hash(void) const {
3958   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());
3959   return hash;
3960 }
3961 
3962 //------------------------------dump2------------------------------------------
3963 // Dump oop Type
3964 #ifndef PRODUCT
3965 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3966   // Print the name of the klass.
3967   klass()-&gt;print_name_on(st);
3968 
3969   switch( _ptr ) {
3970   case Constant:
3971     // TO DO: Make CI print the hex address of the underlying oop.
3972     if (WizardMode || Verbose) {
3973       const_oop()-&gt;print_oop(st);
3974     }
3975   case BotPTR:
3976     if (!WizardMode &amp;&amp; !Verbose) {
3977       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3978       break;
3979     }
3980   case TopPTR:
3981   case AnyNull:
3982   case NotNull:
3983     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
3984     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3985     break;
3986   default:
3987     break;
3988   }
3989 
3990   if( _offset ) {               // Dump offset, if any
3991     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);
3992     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);
3993     else st-&gt;print(&quot;+%d&quot;, _offset);
3994   }
3995 
3996   st-&gt;print(&quot; *&quot;);
3997   if (_instance_id == InstanceTop)
3998     st-&gt;print(&quot;,iid=top&quot;);
3999   else if (_instance_id != InstanceBot)
4000     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4001 
4002   dump_inline_depth(st);
4003   dump_speculative(st);
4004 }
4005 #endif
4006 
4007 //------------------------------add_offset-------------------------------------
4008 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4009   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),
4010               _instance_id, add_offset_speculative(offset), _inline_depth);
4011 }
4012 
4013 const Type *TypeInstPtr::remove_speculative() const {
4014   if (_speculative == NULL) {
4015     return this;
4016   }
4017   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4018   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,
4019               _instance_id, NULL, _inline_depth);
4020 }
4021 
4022 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4023   if (!UseInlineDepthForSpeculativeTypes) {
4024     return this;
4025   }
4026   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);
4027 }
4028 
4029 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4030   assert(is_known_instance(), &quot;should be known&quot;);
4031   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);
4032 }
4033 
4034 //=============================================================================
4035 // Convenience common pre-built types.
4036 const TypeAryPtr *TypeAryPtr::RANGE;
4037 const TypeAryPtr *TypeAryPtr::OOPS;
4038 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4039 const TypeAryPtr *TypeAryPtr::BYTES;
4040 const TypeAryPtr *TypeAryPtr::SHORTS;
4041 const TypeAryPtr *TypeAryPtr::CHARS;
4042 const TypeAryPtr *TypeAryPtr::INTS;
4043 const TypeAryPtr *TypeAryPtr::LONGS;
4044 const TypeAryPtr *TypeAryPtr::FLOATS;
4045 const TypeAryPtr *TypeAryPtr::DOUBLES;
4046 
4047 //------------------------------make-------------------------------------------
4048 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4049                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4050   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4051          &quot;integral arrays must be pre-equipped with a class&quot;);
4052   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4053   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4054   if (!UseExactTypes)  xk = (ptr == Constant);
4055   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4056 }
4057 
4058 //------------------------------make-------------------------------------------
4059 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4060                                    int instance_id, const TypePtr* speculative, int inline_depth,
4061                                    bool is_autobox_cache) {
4062   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4063          &quot;integral arrays must be pre-equipped with a class&quot;);
4064   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4065   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4066   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4067   if (!UseExactTypes)  xk = (ptr == Constant);
4068   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4069 }
4070 
4071 //------------------------------cast_to_ptr_type-------------------------------
4072 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4073   if( ptr == _ptr ) return this;
4074   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4075 }
4076 
4077 
4078 //-----------------------------cast_to_exactness-------------------------------
4079 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4080   if( klass_is_exact == _klass_is_exact ) return this;
4081   if (!UseExactTypes)  return this;
4082   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4083   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4084 }
4085 
4086 //-----------------------------cast_to_instance_id----------------------------
4087 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4088   if( instance_id == _instance_id ) return this;
4089   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4090 }
4091 
4092 
4093 //-----------------------------max_array_length-------------------------------
4094 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4095 jint TypeAryPtr::max_array_length(BasicType etype) {
4096   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4097     if (etype == T_NARROWOOP) {
4098       etype = T_OBJECT;
4099     } else if (etype == T_ILLEGAL) { // bottom[]
4100       etype = T_BYTE; // will produce conservatively high value
4101     } else {
4102       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4103     }
4104   }
4105   return arrayOopDesc::max_array_length(etype);
4106 }
4107 
4108 //-----------------------------narrow_size_type-------------------------------
4109 // Narrow the given size type to the index range for the given array base type.
4110 // Return NULL if the resulting int type becomes empty.
4111 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4112   jint hi = size-&gt;_hi;
4113   jint lo = size-&gt;_lo;
4114   jint min_lo = 0;
4115   jint max_hi = max_array_length(elem()-&gt;basic_type());
4116   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4117   bool chg = false;
4118   if (lo &lt; min_lo) {
4119     lo = min_lo;
4120     if (size-&gt;is_con()) {
4121       hi = lo;
4122     }
4123     chg = true;
4124   }
4125   if (hi &gt; max_hi) {
4126     hi = max_hi;
4127     if (size-&gt;is_con()) {
4128       lo = hi;
4129     }
4130     chg = true;
4131   }
4132   // Negative length arrays will produce weird intermediate dead fast-path code
4133   if (lo &gt; hi)
4134     return TypeInt::ZERO;
4135   if (!chg)
4136     return size;
4137   return TypeInt::make(lo, hi, Type::WidenMin);
4138 }
4139 
4140 //-------------------------------cast_to_size----------------------------------
4141 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4142   assert(new_size != NULL, &quot;&quot;);
4143   new_size = narrow_size_type(new_size);
4144   if (new_size == size())  return this;
4145   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());
4146   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4147 }
4148 
4149 //------------------------------cast_to_stable---------------------------------
4150 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4151   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4152     return this;
4153 
4154   const Type* elem = this-&gt;elem();
4155   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4156 
4157   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4158     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4159     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4160   }
4161 
4162   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);
4163 
4164   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4165 }
4166 
4167 //-----------------------------stable_dimension--------------------------------
4168 int TypeAryPtr::stable_dimension() const {
4169   if (!is_stable())  return 0;
4170   int dim = 1;
4171   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4172   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4173     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4174   return dim;
4175 }
4176 
4177 //----------------------cast_to_autobox_cache-----------------------------------
4178 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4179   if (is_autobox_cache() == cache)  return this;
4180   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4181   if (etype == NULL)  return this;
4182   // The pointers in the autobox arrays are always non-null.
4183   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4184   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4185   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());
4186   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);
4187 }
4188 
4189 //------------------------------eq---------------------------------------------
4190 // Structural equality check for Type representations
4191 bool TypeAryPtr::eq( const Type *t ) const {
4192   const TypeAryPtr *p = t-&gt;is_aryptr();
4193   return
4194     _ary == p-&gt;_ary &amp;&amp;  // Check array
4195     TypeOopPtr::eq(p);  // Check sub-parts
4196 }
4197 
4198 //------------------------------hash-------------------------------------------
4199 // Type-specific hashing function.
4200 int TypeAryPtr::hash(void) const {
4201   return (intptr_t)_ary + TypeOopPtr::hash();
4202 }
4203 
4204 //------------------------------meet-------------------------------------------
4205 // Compute the MEET of two types.  It returns a new Type object.
4206 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4207   // Perform a fast test for common case; meeting the same types together.
4208   if( this == t ) return this;  // Meeting same type-rep?
4209   // Current &quot;this-&gt;_base&quot; is Pointer
4210   switch (t-&gt;base()) {          // switch on original type
4211 
4212   // Mixing ints &amp; oops happens when javac reuses local variables
4213   case Int:
4214   case Long:
4215   case FloatTop:
4216   case FloatCon:
4217   case FloatBot:
4218   case DoubleTop:
4219   case DoubleCon:
4220   case DoubleBot:
4221   case NarrowOop:
4222   case NarrowKlass:
4223   case Bottom:                  // Ye Olde Default
4224     return Type::BOTTOM;
4225   case Top:
4226     return this;
4227 
4228   default:                      // All else is a mistake
4229     typerr(t);
4230 
4231   case OopPtr: {                // Meeting to OopPtrs
4232     // Found a OopPtr type vs self-AryPtr type
4233     const TypeOopPtr *tp = t-&gt;is_oopptr();
4234     int offset = meet_offset(tp-&gt;offset());
4235     PTR ptr = meet_ptr(tp-&gt;ptr());
4236     int depth = meet_inline_depth(tp-&gt;inline_depth());
4237     const TypePtr* speculative = xmeet_speculative(tp);
4238     switch (tp-&gt;ptr()) {
4239     case TopPTR:
4240     case AnyNull: {
4241       int instance_id = meet_instance_id(InstanceTop);
4242       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4243                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4244     }
4245     case BotPTR:
4246     case NotNull: {
4247       int instance_id = meet_instance_id(tp-&gt;instance_id());
4248       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4249     }
4250     default: ShouldNotReachHere();
4251     }
4252   }
4253 
4254   case AnyPtr: {                // Meeting two AnyPtrs
4255     // Found an AnyPtr type vs self-AryPtr type
4256     const TypePtr *tp = t-&gt;is_ptr();
4257     int offset = meet_offset(tp-&gt;offset());
4258     PTR ptr = meet_ptr(tp-&gt;ptr());
4259     const TypePtr* speculative = xmeet_speculative(tp);
4260     int depth = meet_inline_depth(tp-&gt;inline_depth());
4261     switch (tp-&gt;ptr()) {
4262     case TopPTR:
4263       return this;
4264     case BotPTR:
4265     case NotNull:
4266       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4267     case Null:
4268       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4269       // else fall through to AnyNull
4270     case AnyNull: {
4271       int instance_id = meet_instance_id(InstanceTop);
4272       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4273                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4274     }
4275     default: ShouldNotReachHere();
4276     }
4277   }
4278 
4279   case MetadataPtr:
4280   case KlassPtr:
4281   case RawPtr: return TypePtr::BOTTOM;
4282 
4283   case AryPtr: {                // Meeting 2 references?
4284     const TypeAryPtr *tap = t-&gt;is_aryptr();
4285     int off = meet_offset(tap-&gt;offset());
4286     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4287     PTR ptr = meet_ptr(tap-&gt;ptr());
4288     int instance_id = meet_instance_id(tap-&gt;instance_id());
4289     const TypePtr* speculative = xmeet_speculative(tap);
4290     int depth = meet_inline_depth(tap-&gt;inline_depth());
4291     ciKlass* lazy_klass = NULL;
4292     if (tary-&gt;_elem-&gt;isa_int()) {
4293       // Integral array element types have irrelevant lattice relations.
4294       // It is the klass that determines array layout, not the element type.
4295       if (_klass == NULL)
4296         lazy_klass = tap-&gt;_klass;
4297       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4298         lazy_klass = _klass;
4299       } else {
4300         // Something like byte[int+] meets char[int+].
4301         // This must fall to bottom, not (int[-128..65535])[int+].
4302         instance_id = InstanceBot;
4303         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4304       }
4305     } else // Non integral arrays.
4306       // Must fall to bottom if exact klasses in upper lattice
4307       // are not equal or super klass is exact.
4308       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4309           // meet with top[] and bottom[] are processed further down:
4310           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;
4311           // both are exact and not equal:
4312           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4313            // &#39;tap&#39;  is exact and super or unrelated:
4314            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4315            // &#39;this&#39; is exact and super or unrelated:
4316            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
4317       if (above_centerline(ptr)) {
4318         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4319       }
4320       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4321     }
4322 
4323     bool xk = false;
4324     switch (tap-&gt;ptr()) {
4325     case AnyNull:
4326     case TopPTR:
4327       // Compute new klass on demand, do not use tap-&gt;_klass
4328       if (below_centerline(this-&gt;_ptr)) {
4329         xk = this-&gt;_klass_is_exact;
4330       } else {
4331         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4332       }
4333       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4334     case Constant: {
4335       ciObject* o = const_oop();
4336       if( _ptr == Constant ) {
4337         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4338           xk = (klass() == tap-&gt;klass());
4339           ptr = NotNull;
4340           o = NULL;
4341           instance_id = InstanceBot;
4342         } else {
4343           xk = true;
4344         }
4345       } else if(above_centerline(_ptr)) {
4346         o = tap-&gt;const_oop();
4347         xk = true;
4348       } else {
4349         // Only precise for identical arrays
4350         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4351       }
4352       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4353     }
4354     case NotNull:
4355     case BotPTR:
4356       // Compute new klass on demand, do not use tap-&gt;_klass
4357       if (above_centerline(this-&gt;_ptr))
4358             xk = tap-&gt;_klass_is_exact;
4359       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4360               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4361       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4362     default: ShouldNotReachHere();
4363     }
4364   }
4365 
4366   // All arrays inherit from Object class
4367   case InstPtr: {
4368     const TypeInstPtr *tp = t-&gt;is_instptr();
4369     int offset = meet_offset(tp-&gt;offset());
4370     PTR ptr = meet_ptr(tp-&gt;ptr());
4371     int instance_id = meet_instance_id(tp-&gt;instance_id());
4372     const TypePtr* speculative = xmeet_speculative(tp);
4373     int depth = meet_inline_depth(tp-&gt;inline_depth());
4374     switch (ptr) {
4375     case TopPTR:
4376     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4377       // For instances when a subclass meets a superclass we fall
4378       // below the centerline when the superclass is exact. We need to
4379       // do the same here.
4380       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4381         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4382       } else {
4383         // cannot subclass, so the meet has to fall badly below the centerline
4384         ptr = NotNull;
4385         instance_id = InstanceBot;
4386         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4387       }
4388     case Constant:
4389     case NotNull:
4390     case BotPTR:                // Fall down to object klass
4391       // LCA is object_klass, but if we subclass from the top we can do better
4392       if (above_centerline(tp-&gt;ptr())) {
4393         // If &#39;tp&#39;  is above the centerline and it is Object class
4394         // then we can subclass in the Java class hierarchy.
4395         // For instances when a subclass meets a superclass we fall
4396         // below the centerline when the superclass is exact. We need
4397         // to do the same here.
4398         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4399           // that is, my array type is a subtype of &#39;tp&#39; klass
4400           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4401                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4402         }
4403       }
4404       // The other case cannot happen, since t cannot be a subtype of an array.
4405       // The meet falls down to Object class below centerline.
4406       if( ptr == Constant )
4407          ptr = NotNull;
4408       instance_id = InstanceBot;
4409       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4410     default: typerr(t);
4411     }
4412   }
4413   }
4414   return this;                  // Lint noise
4415 }
4416 
4417 //------------------------------xdual------------------------------------------
4418 // Dual: compute field-by-field dual
4419 const Type *TypeAryPtr::xdual() const {
4420   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4421 }
4422 
4423 //----------------------interface_vs_oop---------------------------------------
4424 #ifdef ASSERT
4425 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4426   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4427   if (t_aryptr) {
4428     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4429   }
4430   return false;
4431 }
4432 #endif
4433 
4434 //------------------------------dump2------------------------------------------
4435 #ifndef PRODUCT
4436 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4437   _ary-&gt;dump2(d,depth,st);
4438   switch( _ptr ) {
4439   case Constant:
4440     const_oop()-&gt;print(st);
4441     break;
4442   case BotPTR:
4443     if (!WizardMode &amp;&amp; !Verbose) {
4444       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4445       break;
4446     }
4447   case TopPTR:
4448   case AnyNull:
4449   case NotNull:
4450     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4451     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4452     break;
4453   default:
4454     break;
4455   }
4456 
4457   if( _offset != 0 ) {
4458     int header_size = objArrayOopDesc::header_size() * wordSize;
4459     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);
4460     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);
4461     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);
4462     else {
4463       BasicType basic_elem_type = elem()-&gt;basic_type();
4464       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4465       int elem_size = type2aelembytes(basic_elem_type);
4466       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);
4467     }
4468   }
4469   st-&gt;print(&quot; *&quot;);
4470   if (_instance_id == InstanceTop)
4471     st-&gt;print(&quot;,iid=top&quot;);
4472   else if (_instance_id != InstanceBot)
4473     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4474 
4475   dump_inline_depth(st);
4476   dump_speculative(st);
4477 }
4478 #endif
4479 
4480 bool TypeAryPtr::empty(void) const {
4481   if (_ary-&gt;empty())       return true;
4482   return TypeOopPtr::empty();
4483 }
4484 
4485 //------------------------------add_offset-------------------------------------
4486 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4487   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
4488 }
4489 
4490 const Type *TypeAryPtr::remove_speculative() const {
4491   if (_speculative == NULL) {
4492     return this;
4493   }
4494   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4495   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);
4496 }
4497 
4498 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4499   if (!UseInlineDepthForSpeculativeTypes) {
4500     return this;
4501   }
4502   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);
4503 }
4504 
4505 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4506   assert(is_known_instance(), &quot;should be known&quot;);
4507   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4508 }
4509 
4510 //=============================================================================
4511 
4512 //------------------------------hash-------------------------------------------
4513 // Type-specific hashing function.
4514 int TypeNarrowPtr::hash(void) const {
4515   return _ptrtype-&gt;hash() + 7;
4516 }
4517 
4518 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4519   return _ptrtype-&gt;singleton();
4520 }
4521 
4522 bool TypeNarrowPtr::empty(void) const {
4523   return _ptrtype-&gt;empty();
4524 }
4525 
4526 intptr_t TypeNarrowPtr::get_con() const {
4527   return _ptrtype-&gt;get_con();
4528 }
4529 
4530 bool TypeNarrowPtr::eq( const Type *t ) const {
4531   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
4532   if (tc != NULL) {
4533     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
4534       return false;
4535     }
4536     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
4537   }
4538   return false;
4539 }
4540 
4541 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
4542   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
4543   return make_same_narrowptr(odual);
4544 }
4545 
4546 
4547 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
4548   if (isa_same_narrowptr(kills)) {
4549     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
4550     if (ft-&gt;empty())
4551       return Type::TOP;           // Canonical empty value
4552     if (ft-&gt;isa_ptr()) {
4553       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
4554     }
4555     return ft;
4556   } else if (kills-&gt;isa_ptr()) {
4557     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
4558     if (ft-&gt;empty())
4559       return Type::TOP;           // Canonical empty value
4560     return ft;
4561   } else {
4562     return Type::TOP;
4563   }
4564 }
4565 
4566 //------------------------------xmeet------------------------------------------
4567 // Compute the MEET of two types.  It returns a new Type object.
4568 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
4569   // Perform a fast test for common case; meeting the same types together.
4570   if( this == t ) return this;  // Meeting same type-rep?
4571 
4572   if (t-&gt;base() == base()) {
4573     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
4574     if (result-&gt;isa_ptr()) {
4575       return make_hash_same_narrowptr(result-&gt;is_ptr());
4576     }
4577     return result;
4578   }
4579 
4580   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4581   switch (t-&gt;base()) {          // switch on original type
4582 
4583   case Int:                     // Mixing ints &amp; oops happens when javac
4584   case Long:                    // reuses local variables
4585   case FloatTop:
4586   case FloatCon:
4587   case FloatBot:
4588   case DoubleTop:
4589   case DoubleCon:
4590   case DoubleBot:
4591   case AnyPtr:
4592   case RawPtr:
4593   case OopPtr:
4594   case InstPtr:
4595   case AryPtr:
4596   case MetadataPtr:
4597   case KlassPtr:
4598   case NarrowOop:
4599   case NarrowKlass:
4600 
4601   case Bottom:                  // Ye Olde Default
4602     return Type::BOTTOM;
4603   case Top:
4604     return this;
4605 
4606   default:                      // All else is a mistake
4607     typerr(t);
4608 
4609   } // End of switch
4610 
4611   return this;
4612 }
4613 
4614 #ifndef PRODUCT
4615 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4616   _ptrtype-&gt;dump2(d, depth, st);
4617 }
4618 #endif
4619 
4620 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4621 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4622 
4623 
4624 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4625   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
4626 }
4627 
4628 const Type* TypeNarrowOop::remove_speculative() const {
4629   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
4630 }
4631 
4632 const Type* TypeNarrowOop::cleanup_speculative() const {
4633   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
4634 }
4635 
4636 #ifndef PRODUCT
4637 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4638   st-&gt;print(&quot;narrowoop: &quot;);
4639   TypeNarrowPtr::dump2(d, depth, st);
4640 }
4641 #endif
4642 
4643 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
4644 
4645 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
4646   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
4647 }
4648 
4649 #ifndef PRODUCT
4650 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4651   st-&gt;print(&quot;narrowklass: &quot;);
4652   TypeNarrowPtr::dump2(d, depth, st);
4653 }
4654 #endif
4655 
4656 
4657 //------------------------------eq---------------------------------------------
4658 // Structural equality check for Type representations
4659 bool TypeMetadataPtr::eq( const Type *t ) const {
4660   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
4661   ciMetadata* one = metadata();
4662   ciMetadata* two = a-&gt;metadata();
4663   if (one == NULL || two == NULL) {
4664     return (one == two) &amp;&amp; TypePtr::eq(t);
4665   } else {
4666     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4667   }
4668 }
4669 
4670 //------------------------------hash-------------------------------------------
4671 // Type-specific hashing function.
4672 int TypeMetadataPtr::hash(void) const {
4673   return
4674     (metadata() ? metadata()-&gt;hash() : 0) +
4675     TypePtr::hash();
4676 }
4677 
4678 //------------------------------singleton--------------------------------------
4679 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4680 // constants
4681 bool TypeMetadataPtr::singleton(void) const {
4682   // detune optimizer to not generate constant metadata + constant offset as a constant!
4683   // TopPTR, Null, AnyNull, Constant are all singletons
4684   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4685 }
4686 
4687 //------------------------------add_offset-------------------------------------
4688 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4689   return make( _ptr, _metadata, xadd_offset(offset));
4690 }
4691 
4692 //-----------------------------filter------------------------------------------
4693 // Do not allow interface-vs.-noninterface joins to collapse to top.
4694 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4695   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4696   if (ft == NULL || ft-&gt;empty())
4697     return Type::TOP;           // Canonical empty value
4698   return ft;
4699 }
4700 
4701  //------------------------------get_con----------------------------------------
4702 intptr_t TypeMetadataPtr::get_con() const {
4703   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
4704   assert( _offset &gt;= 0, &quot;&quot; );
4705 
4706   if (_offset != 0) {
4707     // After being ported to the compiler interface, the compiler no longer
4708     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4709     // to a handle at compile time.  This handle is embedded in the generated
4710     // code and dereferenced at the time the nmethod is made.  Until that time,
4711     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4712     // have access to the addresses!).  This does not seem to currently happen,
4713     // but this assertion here is to help prevent its occurence.
4714     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4715     ShouldNotReachHere();
4716   }
4717 
4718   return (intptr_t)metadata()-&gt;constant_encoding();
4719 }
4720 
4721 //------------------------------cast_to_ptr_type-------------------------------
4722 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4723   if( ptr == _ptr ) return this;
4724   return make(ptr, metadata(), _offset);
4725 }
4726 
4727 //------------------------------meet-------------------------------------------
4728 // Compute the MEET of two types.  It returns a new Type object.
4729 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
4730   // Perform a fast test for common case; meeting the same types together.
4731   if( this == t ) return this;  // Meeting same type-rep?
4732 
4733   // Current &quot;this-&gt;_base&quot; is OopPtr
4734   switch (t-&gt;base()) {          // switch on original type
4735 
4736   case Int:                     // Mixing ints &amp; oops happens when javac
4737   case Long:                    // reuses local variables
4738   case FloatTop:
4739   case FloatCon:
4740   case FloatBot:
4741   case DoubleTop:
4742   case DoubleCon:
4743   case DoubleBot:
4744   case NarrowOop:
4745   case NarrowKlass:
4746   case Bottom:                  // Ye Olde Default
4747     return Type::BOTTOM;
4748   case Top:
4749     return this;
4750 
4751   default:                      // All else is a mistake
4752     typerr(t);
4753 
4754   case AnyPtr: {
4755     // Found an AnyPtr type vs self-OopPtr type
4756     const TypePtr *tp = t-&gt;is_ptr();
4757     int offset = meet_offset(tp-&gt;offset());
4758     PTR ptr = meet_ptr(tp-&gt;ptr());
4759     switch (tp-&gt;ptr()) {
4760     case Null:
4761       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4762       // else fall through:
4763     case TopPTR:
4764     case AnyNull: {
4765       return make(ptr, _metadata, offset);
4766     }
4767     case BotPTR:
4768     case NotNull:
4769       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4770     default: typerr(t);
4771     }
4772   }
4773 
4774   case RawPtr:
4775   case KlassPtr:
4776   case OopPtr:
4777   case InstPtr:
4778   case AryPtr:
4779     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4780 
4781   case MetadataPtr: {
4782     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
4783     int offset = meet_offset(tp-&gt;offset());
4784     PTR tptr = tp-&gt;ptr();
4785     PTR ptr = meet_ptr(tptr);
4786     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4787     if (tptr == TopPTR || _ptr == TopPTR ||
4788         metadata()-&gt;equals(tp-&gt;metadata())) {
4789       return make(ptr, md, offset);
4790     }
4791     // metadata is different
4792     if( ptr == Constant ) {  // Cannot be equal constants, so...
4793       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4794       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4795       ptr = NotNull;            // Fall down in lattice
4796     }
4797     return make(ptr, NULL, offset);
4798     break;
4799   }
4800   } // End of switch
4801   return this;                  // Return the double constant
4802 }
4803 
4804 
4805 //------------------------------xdual------------------------------------------
4806 // Dual of a pure metadata pointer.
4807 const Type *TypeMetadataPtr::xdual() const {
4808   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4809 }
4810 
4811 //------------------------------dump2------------------------------------------
4812 #ifndef PRODUCT
4813 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4814   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4815   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
4816   switch( _offset ) {
4817   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4818   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4819   case         0: break;
4820   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
4821   }
4822 }
4823 #endif
4824 
4825 
4826 //=============================================================================
4827 // Convenience common pre-built type.
4828 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4829 
4830 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):
4831   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4832 }
4833 
4834 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
4835   return make(Constant, m, 0);
4836 }
4837 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
4838   return make(Constant, m, 0);
4839 }
4840 
4841 //------------------------------make-------------------------------------------
4842 // Create a meta data constant
4843 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {
4844   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4845   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4846 }
4847 
4848 
4849 //=============================================================================
4850 // Convenience common pre-built types.
4851 
4852 // Not-null object klass or below
4853 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4854 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4855 
4856 //------------------------------TypeKlassPtr-----------------------------------
4857 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )
4858   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {
4859 }
4860 
4861 //------------------------------make-------------------------------------------
4862 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
4863 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {
4864   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);
4865   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
4866   TypeKlassPtr *r =
4867     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();
4868 
4869   return r;
4870 }
4871 
4872 //------------------------------eq---------------------------------------------
4873 // Structural equality check for Type representations
4874 bool TypeKlassPtr::eq( const Type *t ) const {
4875   const TypeKlassPtr *p = t-&gt;is_klassptr();
4876   return
4877     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4878     TypePtr::eq(p);
4879 }
4880 
4881 //------------------------------hash-------------------------------------------
4882 // Type-specific hashing function.
4883 int TypeKlassPtr::hash(void) const {
4884   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());
4885 }
4886 
4887 //------------------------------singleton--------------------------------------
4888 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4889 // constants
4890 bool TypeKlassPtr::singleton(void) const {
4891   // detune optimizer to not generate constant klass + constant offset as a constant!
4892   // TopPTR, Null, AnyNull, Constant are all singletons
4893   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4894 }
4895 
4896 // Do not allow interface-vs.-noninterface joins to collapse to top.
4897 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4898   // logic here mirrors the one from TypeOopPtr::filter. See comments
4899   // there.
4900   const Type* ft = join_helper(kills, include_speculative);
4901   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4902   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4903 
4904   if (ft-&gt;empty()) {
4905     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
4906       return kills;             // Uplift to interface
4907 
4908     return Type::TOP;           // Canonical empty value
4909   }
4910 
4911   // Interface klass type could be exact in opposite to interface type,
4912   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4913   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4914       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4915       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4916       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4917     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4918   }
4919 
4920   return ft;
4921 }
4922 
4923 //----------------------compute_klass------------------------------------------
4924 // Compute the defining klass for this class
4925 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4926   // Compute _klass based on element type.
4927   ciKlass* k_ary = NULL;
4928   const TypeInstPtr *tinst;
4929   const TypeAryPtr *tary;
4930   const Type* el = elem();
4931   if (el-&gt;isa_narrowoop()) {
4932     el = el-&gt;make_ptr();
4933   }
4934 
4935   // Get element klass
4936   if ((tinst = el-&gt;isa_instptr()) != NULL) {
4937     // Compute array klass from element klass
4938     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());
4939   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4940     // Compute array klass from element klass
4941     ciKlass* k_elem = tary-&gt;klass();
4942     // If element type is something like bottom[], k_elem will be null.
4943     if (k_elem != NULL)
4944       k_ary = ciObjArrayKlass::make(k_elem);
4945   } else if ((el-&gt;base() == Type::Top) ||
4946              (el-&gt;base() == Type::Bottom)) {
4947     // element type of Bottom occurs from meet of basic type
4948     // and object; Top occurs when doing join on Bottom.
4949     // Leave k_ary at NULL.
4950   } else {
4951     // Cannot compute array klass directly from basic type,
4952     // since subtypes of TypeInt all have basic type T_INT.
4953 #ifdef ASSERT
4954     if (verify &amp;&amp; el-&gt;isa_int()) {
4955       // Check simple cases when verifying klass.
4956       BasicType bt = T_ILLEGAL;
4957       if (el == TypeInt::BYTE) {
4958         bt = T_BYTE;
4959       } else if (el == TypeInt::SHORT) {
4960         bt = T_SHORT;
4961       } else if (el == TypeInt::CHAR) {
4962         bt = T_CHAR;
4963       } else if (el == TypeInt::INT) {
4964         bt = T_INT;
4965       } else {
4966         return _klass; // just return specified klass
4967       }
4968       return ciTypeArrayKlass::make(bt);
4969     }
4970 #endif
4971     assert(!el-&gt;isa_int(),
4972            &quot;integral arrays must be pre-equipped with a class&quot;);
4973     // Compute array klass directly from basic type
4974     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
4975   }
4976   return k_ary;
4977 }
4978 
4979 //------------------------------klass------------------------------------------
4980 // Return the defining klass for this class
4981 ciKlass* TypeAryPtr::klass() const {
4982   if( _klass ) return _klass;   // Return cached value, if possible
4983 
4984   // Oops, need to compute _klass and cache it
4985   ciKlass* k_ary = compute_klass();
4986 
4987   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
4988     // The _klass field acts as a cache of the underlying
4989     // ciKlass for this array type.  In order to set the field,
4990     // we need to cast away const-ness.
4991     //
4992     // IMPORTANT NOTE: we *never* set the _klass field for the
4993     // type TypeAryPtr::OOPS.  This Type is shared between all
4994     // active compilations.  However, the ciKlass which represents
4995     // this Type is *not* shared between compilations, so caching
4996     // this value would result in fetching a dangling pointer.
4997     //
4998     // Recomputing the underlying ciKlass for each request is
4999     // a bit less efficient than caching, but calls to
5000     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5001     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5002     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5003         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {
5004       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5005     }
5006   }
5007   return k_ary;
5008 }
5009 
5010 
5011 //------------------------------add_offset-------------------------------------
5012 // Access internals of klass object
5013 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5014   return make( _ptr, klass(), xadd_offset(offset) );
5015 }
5016 
5017 //------------------------------cast_to_ptr_type-------------------------------
5018 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5019   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5020   if( ptr == _ptr ) return this;
5021   return make(ptr, _klass, _offset);
5022 }
5023 
5024 
5025 //-----------------------------cast_to_exactness-------------------------------
5026 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5027   if( klass_is_exact == _klass_is_exact ) return this;
5028   if (!UseExactTypes)  return this;
5029   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);
5030 }
5031 
5032 
5033 //-----------------------------as_instance_type--------------------------------
5034 // Corresponding type for an instance of the given class.
5035 // It will be NotNull, and exact if and only if the klass type is exact.
5036 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5037   ciKlass* k = klass();
5038   bool    xk = klass_is_exact();
5039   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5040   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5041   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5042   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5043   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5044 }
5045 
5046 
5047 //------------------------------xmeet------------------------------------------
5048 // Compute the MEET of two types, return a new Type object.
5049 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5050   // Perform a fast test for common case; meeting the same types together.
5051   if( this == t ) return this;  // Meeting same type-rep?
5052 
5053   // Current &quot;this-&gt;_base&quot; is Pointer
5054   switch (t-&gt;base()) {          // switch on original type
5055 
5056   case Int:                     // Mixing ints &amp; oops happens when javac
5057   case Long:                    // reuses local variables
5058   case FloatTop:
5059   case FloatCon:
5060   case FloatBot:
5061   case DoubleTop:
5062   case DoubleCon:
5063   case DoubleBot:
5064   case NarrowOop:
5065   case NarrowKlass:
5066   case Bottom:                  // Ye Olde Default
5067     return Type::BOTTOM;
5068   case Top:
5069     return this;
5070 
5071   default:                      // All else is a mistake
5072     typerr(t);
5073 
5074   case AnyPtr: {                // Meeting to AnyPtrs
5075     // Found an AnyPtr type vs self-KlassPtr type
5076     const TypePtr *tp = t-&gt;is_ptr();
5077     int offset = meet_offset(tp-&gt;offset());
5078     PTR ptr = meet_ptr(tp-&gt;ptr());
5079     switch (tp-&gt;ptr()) {
5080     case TopPTR:
5081       return this;
5082     case Null:
5083       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5084     case AnyNull:
5085       return make( ptr, klass(), offset );
5086     case BotPTR:
5087     case NotNull:
5088       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5089     default: typerr(t);
5090     }
5091   }
5092 
5093   case RawPtr:
5094   case MetadataPtr:
5095   case OopPtr:
5096   case AryPtr:                  // Meet with AryPtr
5097   case InstPtr:                 // Meet with InstPtr
5098     return TypePtr::BOTTOM;
5099 
5100   //
5101   //             A-top         }
5102   //           /   |   \       }  Tops
5103   //       B-top A-any C-top   }
5104   //          | /  |  \ |      }  Any-nulls
5105   //       B-any   |   C-any   }
5106   //          |    |    |
5107   //       B-con A-con C-con   } constants; not comparable across classes
5108   //          |    |    |
5109   //       B-not   |   C-not   }
5110   //          | \  |  / |      }  not-nulls
5111   //       B-bot A-not C-bot   }
5112   //           \   |   /       }  Bottoms
5113   //             A-bot         }
5114   //
5115 
5116   case KlassPtr: {  // Meet two KlassPtr types
5117     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5118     int  off     = meet_offset(tkls-&gt;offset());
5119     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5120 
5121     // Check for easy case; klasses are equal (and perhaps not loaded!)
5122     // If we have constants, then we created oops so classes are loaded
5123     // and we can handle the constants further down.  This case handles
5124     // not-loaded classes
5125     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {
5126       return make( ptr, klass(), off );
5127     }
5128 
5129     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5130     ciKlass* tkls_klass = tkls-&gt;klass();
5131     ciKlass* this_klass = this-&gt;klass();
5132     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5133     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5134 
5135     // If &#39;this&#39; type is above the centerline and is a superclass of the
5136     // other, we can treat &#39;this&#39; as having the same type as the other.
5137     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5138         tkls_klass-&gt;is_subtype_of(this_klass)) {
5139       this_klass = tkls_klass;
5140     }
5141     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5142     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5143     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5144         this_klass-&gt;is_subtype_of(tkls_klass)) {
5145       tkls_klass = this_klass;
5146     }
5147 
5148     // Check for classes now being equal
5149     if (tkls_klass-&gt;equals(this_klass)) {
5150       // If the klasses are equal, the constants may still differ.  Fall to
5151       // NotNull if they do (neither constant is NULL; that is a special case
5152       // handled elsewhere).
5153       if( ptr == Constant ) {
5154         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5155             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5156         else if (above_centerline(this-&gt;ptr()));
5157         else if (above_centerline(tkls-&gt;ptr()));
5158         else
5159           ptr = NotNull;
5160       }
5161       return make( ptr, this_klass, off );
5162     } // Else classes are not equal
5163 
5164     // Since klasses are different, we require the LCA in the Java
5165     // class hierarchy - which means we have to fall to at least NotNull.
5166     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5167       ptr = NotNull;
5168     // Now we find the LCA of Java classes
5169     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5170     return   make( ptr, k, off );
5171   } // End of case KlassPtr
5172 
5173   } // End of switch
5174   return this;                  // Return the double constant
5175 }
5176 
5177 //------------------------------xdual------------------------------------------
5178 // Dual: compute field-by-field dual
5179 const Type    *TypeKlassPtr::xdual() const {
5180   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );
5181 }
5182 
5183 //------------------------------get_con----------------------------------------
5184 intptr_t TypeKlassPtr::get_con() const {
5185   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5186   assert( _offset &gt;= 0, &quot;&quot; );
5187 
5188   if (_offset != 0) {
5189     // After being ported to the compiler interface, the compiler no longer
5190     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5191     // to a handle at compile time.  This handle is embedded in the generated
5192     // code and dereferenced at the time the nmethod is made.  Until that time,
5193     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5194     // have access to the addresses!).  This does not seem to currently happen,
5195     // but this assertion here is to help prevent its occurence.
5196     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5197     ShouldNotReachHere();
5198   }
5199 
5200   return (intptr_t)klass()-&gt;constant_encoding();
5201 }
5202 //------------------------------dump2------------------------------------------
5203 // Dump Klass Type
5204 #ifndef PRODUCT
5205 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5206   switch( _ptr ) {
5207   case Constant:
5208     st-&gt;print(&quot;precise &quot;);
5209   case NotNull:
5210     {
5211       const char *name = klass()-&gt;name()-&gt;as_utf8();
5212       if( name ) {
5213         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5214       } else {
5215         ShouldNotReachHere();
5216       }
5217     }
5218   case BotPTR:
5219     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5220   case TopPTR:
5221   case AnyNull:
5222     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5223     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5224     break;
5225   default:
5226     break;
5227   }
5228 
5229   if( _offset ) {               // Dump offset, if any
5230     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }
5231     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }
5232     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }
5233   }
5234 
5235   st-&gt;print(&quot; *&quot;);
5236 }
5237 #endif
5238 
5239 
5240 
5241 //=============================================================================
5242 // Convenience common pre-built types.
5243 
5244 //------------------------------make-------------------------------------------
5245 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {
5246   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();
5247 }
5248 
5249 //------------------------------make-------------------------------------------
5250 const TypeFunc *TypeFunc::make(ciMethod* method) {
5251   Compile* C = Compile::current();
5252   const TypeFunc* tf = C-&gt;last_tf(method); // check cache
5253   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5254   const TypeTuple *domain;
5255   if (method-&gt;is_static()) {
5256     domain = TypeTuple::make_domain(NULL, method-&gt;signature());
5257   } else {
5258     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());
5259   }
5260   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());
5261   tf = TypeFunc::make(domain, range);
5262   C-&gt;set_last_tf(method, tf);  // fill cache
5263   return tf;
5264 }
5265 
5266 //------------------------------meet-------------------------------------------
5267 // Compute the MEET of two types.  It returns a new Type object.
5268 const Type *TypeFunc::xmeet( const Type *t ) const {
5269   // Perform a fast test for common case; meeting the same types together.
5270   if( this == t ) return this;  // Meeting same type-rep?
5271 
5272   // Current &quot;this-&gt;_base&quot; is Func
5273   switch (t-&gt;base()) {          // switch on original type
5274 
5275   case Bottom:                  // Ye Olde Default
5276     return t;
5277 
5278   default:                      // All else is a mistake
5279     typerr(t);
5280 
5281   case Top:
5282     break;
5283   }
5284   return this;                  // Return the double constant
5285 }
5286 
5287 //------------------------------xdual------------------------------------------
5288 // Dual: compute field-by-field dual
5289 const Type *TypeFunc::xdual() const {
5290   return this;
5291 }
5292 
5293 //------------------------------eq---------------------------------------------
5294 // Structural equality check for Type representations
5295 bool TypeFunc::eq( const Type *t ) const {
5296   const TypeFunc *a = (const TypeFunc*)t;
5297   return _domain == a-&gt;_domain &amp;&amp;
5298     _range == a-&gt;_range;
5299 }
5300 
5301 //------------------------------hash-------------------------------------------
5302 // Type-specific hashing function.
5303 int TypeFunc::hash(void) const {
5304   return (intptr_t)_domain + (intptr_t)_range;
5305 }
5306 
5307 //------------------------------dump2------------------------------------------
5308 // Dump Function Type
5309 #ifndef PRODUCT
5310 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5311   if( _range-&gt;cnt() &lt;= Parms )
5312     st-&gt;print(&quot;void&quot;);
5313   else {
5314     uint i;
5315     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {
5316       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5317       st-&gt;print(&quot;/&quot;);
5318     }
5319     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5320   }
5321   st-&gt;print(&quot; &quot;);
5322   st-&gt;print(&quot;( &quot;);
5323   if( !depth || d[this] ) {     // Check for recursive dump
5324     st-&gt;print(&quot;...)&quot;);
5325     return;
5326   }
5327   d.Insert((void*)this,(void*)this);    // Stop recursion
5328   if (Parms &lt; _domain-&gt;cnt())
5329     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5330   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {
5331     st-&gt;print(&quot;, &quot;);
5332     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5333   }
5334   st-&gt;print(&quot; )&quot;);
5335 }
5336 #endif
5337 
5338 //------------------------------singleton--------------------------------------
5339 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5340 // constants (Ldi nodes).  Singletons are integer, float or double constants
5341 // or a single symbol.
5342 bool TypeFunc::singleton(void) const {
5343   return false;                 // Never a singleton
5344 }
5345 
5346 bool TypeFunc::empty(void) const {
5347   return false;                 // Never empty
5348 }
5349 
5350 
5351 BasicType TypeFunc::return_type() const{
5352   if (range()-&gt;cnt() == TypeFunc::Parms) {
5353     return T_VOID;
5354   }
5355   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5356 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="mulnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 129 class PCTableNode;
 130 class PhaseCCP;
 131 class PhaseGVN;
 132 class PhaseIterGVN;
 133 class PhaseRegAlloc;
 134 class PhaseTransform;
 135 class PhaseValues;
 136 class PhiNode;
 137 class Pipeline;
 138 class ProjNode;
 139 class RangeCheckNode;
 140 class RegMask;
 141 class RegionNode;
 142 class RootNode;
 143 class SafePointNode;
 144 class SafePointScalarObjectNode;
 145 class StartNode;
 146 class State;
 147 class StoreNode;
 148 class SubNode;

 149 class Type;
 150 class TypeNode;
 151 class UnlockNode;
 152 class VectorNode;
 153 class LoadVectorNode;
 154 class StoreVectorNode;
 155 class VectorSet;
 156 typedef void (*NFunc)(Node&amp;,void*);
 157 extern &quot;C&quot; {
 158   typedef int (*C_sort_func_t)(const void *, const void *);
 159 }
 160 
 161 // The type of all node counts and indexes.
 162 // It must hold at least 16 bits, but must also be fast to load and store.
 163 // This type, if less than 32 bits, could limit the number of possible nodes.
 164 // (To make this type platform-specific, move to globalDefinitions_xxx.hpp.)
 165 typedef unsigned int node_idx_t;
 166 
 167 
 168 #ifndef OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 689     DEFINE_CLASS_ID(Mem,   Node, 4)
 690       DEFINE_CLASS_ID(Load,  Mem, 0)
 691         DEFINE_CLASS_ID(LoadVector,  Load, 0)
 692       DEFINE_CLASS_ID(Store, Mem, 1)
 693         DEFINE_CLASS_ID(StoreVector, Store, 0)
 694       DEFINE_CLASS_ID(LoadStore, Mem, 2)
 695         DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
 696           DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
 697         DEFINE_CLASS_ID(CompareAndExchangeNode, LoadStore, 1)
 698 
 699     DEFINE_CLASS_ID(Region, Node, 5)
 700       DEFINE_CLASS_ID(Loop, Region, 0)
 701         DEFINE_CLASS_ID(Root,                Loop, 0)
 702         DEFINE_CLASS_ID(CountedLoop,         Loop, 1)
 703         DEFINE_CLASS_ID(OuterStripMinedLoop, Loop, 2)
 704 
 705     DEFINE_CLASS_ID(Sub,   Node, 6)
 706       DEFINE_CLASS_ID(Cmp,   Sub, 0)
 707         DEFINE_CLASS_ID(FastLock,   Cmp, 0)
 708         DEFINE_CLASS_ID(FastUnlock, Cmp, 1)

 709 
 710     DEFINE_CLASS_ID(MergeMem, Node, 7)
 711     DEFINE_CLASS_ID(Bool,     Node, 8)
 712     DEFINE_CLASS_ID(AddP,     Node, 9)
 713     DEFINE_CLASS_ID(BoxLock,  Node, 10)
 714     DEFINE_CLASS_ID(Add,      Node, 11)
 715     DEFINE_CLASS_ID(Mul,      Node, 12)
 716     DEFINE_CLASS_ID(Vector,   Node, 13)
 717     DEFINE_CLASS_ID(ClearArray, Node, 14)
 718     DEFINE_CLASS_ID(Halt, Node, 15)
 719 
 720     _max_classes  = ClassMask_Halt
 721   };
 722   #undef DEFINE_CLASS_ID
 723 
 724   // Flags are sorted by usage frequency.
 725   enum NodeFlags {
 726     Flag_is_Copy                     = 0x01, // should be first bit to avoid shift
 727     Flag_rematerialize               = Flag_is_Copy &lt;&lt; 1,
 728     Flag_needs_anti_dependence_check = Flag_rematerialize &lt;&lt; 1,
</pre>
<hr />
<pre>
 858   DEFINE_CLASS_QUERY(Mem)
 859   DEFINE_CLASS_QUERY(MemBar)
 860   DEFINE_CLASS_QUERY(MemBarStoreStore)
 861   DEFINE_CLASS_QUERY(MergeMem)
 862   DEFINE_CLASS_QUERY(Mul)
 863   DEFINE_CLASS_QUERY(Multi)
 864   DEFINE_CLASS_QUERY(MultiBranch)
 865   DEFINE_CLASS_QUERY(OuterStripMinedLoop)
 866   DEFINE_CLASS_QUERY(OuterStripMinedLoopEnd)
 867   DEFINE_CLASS_QUERY(Parm)
 868   DEFINE_CLASS_QUERY(PCTable)
 869   DEFINE_CLASS_QUERY(Phi)
 870   DEFINE_CLASS_QUERY(Proj)
 871   DEFINE_CLASS_QUERY(Region)
 872   DEFINE_CLASS_QUERY(Root)
 873   DEFINE_CLASS_QUERY(SafePoint)
 874   DEFINE_CLASS_QUERY(SafePointScalarObject)
 875   DEFINE_CLASS_QUERY(Start)
 876   DEFINE_CLASS_QUERY(Store)
 877   DEFINE_CLASS_QUERY(Sub)

 878   DEFINE_CLASS_QUERY(Type)
 879   DEFINE_CLASS_QUERY(Vector)
 880   DEFINE_CLASS_QUERY(LoadVector)
 881   DEFINE_CLASS_QUERY(StoreVector)
 882   DEFINE_CLASS_QUERY(Unlock)
 883 
 884   #undef DEFINE_CLASS_QUERY
 885 
 886   // duplicate of is_MachSpillCopy()
 887   bool is_SpillCopy () const {
 888     return ((_class_id &amp; ClassMask_MachSpillCopy) == Class_MachSpillCopy);
 889   }
 890 
 891   bool is_Con () const { return (_flags &amp; Flag_is_Con) != 0; }
 892   // The data node which is safe to leave in dead loop during IGVN optimization.
 893   bool is_dead_loop_safe() const {
 894     return is_Phi() || (is_Proj() &amp;&amp; in(0) == NULL) ||
 895            ((_flags &amp; (Flag_is_dead_loop_safe | Flag_is_Con)) != 0 &amp;&amp;
 896             (!is_Proj() || !in(0)-&gt;is_Allocate()));
 897   }
</pre>
</td>
<td>
<hr />
<pre>
 129 class PCTableNode;
 130 class PhaseCCP;
 131 class PhaseGVN;
 132 class PhaseIterGVN;
 133 class PhaseRegAlloc;
 134 class PhaseTransform;
 135 class PhaseValues;
 136 class PhiNode;
 137 class Pipeline;
 138 class ProjNode;
 139 class RangeCheckNode;
 140 class RegMask;
 141 class RegionNode;
 142 class RootNode;
 143 class SafePointNode;
 144 class SafePointScalarObjectNode;
 145 class StartNode;
 146 class State;
 147 class StoreNode;
 148 class SubNode;
<span class="line-added"> 149 class SubTypeCheckNode;</span>
 150 class Type;
 151 class TypeNode;
 152 class UnlockNode;
 153 class VectorNode;
 154 class LoadVectorNode;
 155 class StoreVectorNode;
 156 class VectorSet;
 157 typedef void (*NFunc)(Node&amp;,void*);
 158 extern &quot;C&quot; {
 159   typedef int (*C_sort_func_t)(const void *, const void *);
 160 }
 161 
 162 // The type of all node counts and indexes.
 163 // It must hold at least 16 bits, but must also be fast to load and store.
 164 // This type, if less than 32 bits, could limit the number of possible nodes.
 165 // (To make this type platform-specific, move to globalDefinitions_xxx.hpp.)
 166 typedef unsigned int node_idx_t;
 167 
 168 
 169 #ifndef OPTO_DU_ITERATOR_ASSERT
</pre>
<hr />
<pre>
 690     DEFINE_CLASS_ID(Mem,   Node, 4)
 691       DEFINE_CLASS_ID(Load,  Mem, 0)
 692         DEFINE_CLASS_ID(LoadVector,  Load, 0)
 693       DEFINE_CLASS_ID(Store, Mem, 1)
 694         DEFINE_CLASS_ID(StoreVector, Store, 0)
 695       DEFINE_CLASS_ID(LoadStore, Mem, 2)
 696         DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
 697           DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
 698         DEFINE_CLASS_ID(CompareAndExchangeNode, LoadStore, 1)
 699 
 700     DEFINE_CLASS_ID(Region, Node, 5)
 701       DEFINE_CLASS_ID(Loop, Region, 0)
 702         DEFINE_CLASS_ID(Root,                Loop, 0)
 703         DEFINE_CLASS_ID(CountedLoop,         Loop, 1)
 704         DEFINE_CLASS_ID(OuterStripMinedLoop, Loop, 2)
 705 
 706     DEFINE_CLASS_ID(Sub,   Node, 6)
 707       DEFINE_CLASS_ID(Cmp,   Sub, 0)
 708         DEFINE_CLASS_ID(FastLock,   Cmp, 0)
 709         DEFINE_CLASS_ID(FastUnlock, Cmp, 1)
<span class="line-added"> 710         DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)</span>
 711 
 712     DEFINE_CLASS_ID(MergeMem, Node, 7)
 713     DEFINE_CLASS_ID(Bool,     Node, 8)
 714     DEFINE_CLASS_ID(AddP,     Node, 9)
 715     DEFINE_CLASS_ID(BoxLock,  Node, 10)
 716     DEFINE_CLASS_ID(Add,      Node, 11)
 717     DEFINE_CLASS_ID(Mul,      Node, 12)
 718     DEFINE_CLASS_ID(Vector,   Node, 13)
 719     DEFINE_CLASS_ID(ClearArray, Node, 14)
 720     DEFINE_CLASS_ID(Halt, Node, 15)
 721 
 722     _max_classes  = ClassMask_Halt
 723   };
 724   #undef DEFINE_CLASS_ID
 725 
 726   // Flags are sorted by usage frequency.
 727   enum NodeFlags {
 728     Flag_is_Copy                     = 0x01, // should be first bit to avoid shift
 729     Flag_rematerialize               = Flag_is_Copy &lt;&lt; 1,
 730     Flag_needs_anti_dependence_check = Flag_rematerialize &lt;&lt; 1,
</pre>
<hr />
<pre>
 860   DEFINE_CLASS_QUERY(Mem)
 861   DEFINE_CLASS_QUERY(MemBar)
 862   DEFINE_CLASS_QUERY(MemBarStoreStore)
 863   DEFINE_CLASS_QUERY(MergeMem)
 864   DEFINE_CLASS_QUERY(Mul)
 865   DEFINE_CLASS_QUERY(Multi)
 866   DEFINE_CLASS_QUERY(MultiBranch)
 867   DEFINE_CLASS_QUERY(OuterStripMinedLoop)
 868   DEFINE_CLASS_QUERY(OuterStripMinedLoopEnd)
 869   DEFINE_CLASS_QUERY(Parm)
 870   DEFINE_CLASS_QUERY(PCTable)
 871   DEFINE_CLASS_QUERY(Phi)
 872   DEFINE_CLASS_QUERY(Proj)
 873   DEFINE_CLASS_QUERY(Region)
 874   DEFINE_CLASS_QUERY(Root)
 875   DEFINE_CLASS_QUERY(SafePoint)
 876   DEFINE_CLASS_QUERY(SafePointScalarObject)
 877   DEFINE_CLASS_QUERY(Start)
 878   DEFINE_CLASS_QUERY(Store)
 879   DEFINE_CLASS_QUERY(Sub)
<span class="line-added"> 880   DEFINE_CLASS_QUERY(SubTypeCheck)</span>
 881   DEFINE_CLASS_QUERY(Type)
 882   DEFINE_CLASS_QUERY(Vector)
 883   DEFINE_CLASS_QUERY(LoadVector)
 884   DEFINE_CLASS_QUERY(StoreVector)
 885   DEFINE_CLASS_QUERY(Unlock)
 886 
 887   #undef DEFINE_CLASS_QUERY
 888 
 889   // duplicate of is_MachSpillCopy()
 890   bool is_SpillCopy () const {
 891     return ((_class_id &amp; ClassMask_MachSpillCopy) == Class_MachSpillCopy);
 892   }
 893 
 894   bool is_Con () const { return (_flags &amp; Flag_is_Con) != 0; }
 895   // The data node which is safe to leave in dead loop during IGVN optimization.
 896   bool is_dead_loop_safe() const {
 897     return is_Phi() || (is_Proj() &amp;&amp; in(0) == NULL) ||
 898            ((_flags &amp; (Flag_is_dead_loop_safe | Flag_is_Con)) != 0 &amp;&amp;
 899             (!is_Proj() || !in(0)-&gt;is_Allocate()));
 900   }
</pre>
</td>
</tr>
</table>
<center><a href="mulnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
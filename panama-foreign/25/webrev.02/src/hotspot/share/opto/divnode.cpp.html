<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/divnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/convertnode.hpp&quot;
  30 #include &quot;opto/divnode.hpp&quot;
  31 #include &quot;opto/machnode.hpp&quot;
  32 #include &quot;opto/movenode.hpp&quot;
  33 #include &quot;opto/matcher.hpp&quot;
  34 #include &quot;opto/mulnode.hpp&quot;
  35 #include &quot;opto/phaseX.hpp&quot;
  36 #include &quot;opto/subnode.hpp&quot;
  37 #include &quot;utilities/powerOfTwo.hpp&quot;
  38 
  39 // Portions of code courtesy of Clifford Click
  40 
  41 // Optimization - Graph Style
  42 
  43 #include &lt;math.h&gt;
  44 
  45 //----------------------magic_int_divide_constants-----------------------------
  46 // Compute magic multiplier and shift constant for converting a 32 bit divide
  47 // by constant into a multiply/shift/add series. Return false if calculations
  48 // fail.
  49 //
  50 // Borrowed almost verbatim from Hacker&#39;s Delight by Henry S. Warren, Jr. with
  51 // minor type name and parameter changes.
  52 static bool magic_int_divide_constants(jint d, jint &amp;M, jint &amp;s) {
  53   int32_t p;
  54   uint32_t ad, anc, delta, q1, r1, q2, r2, t;
  55   const uint32_t two31 = 0x80000000L;     // 2**31.
  56 
  57   ad = ABS(d);
  58   if (d == 0 || d == 1) return false;
  59   t = two31 + ((uint32_t)d &gt;&gt; 31);
  60   anc = t - 1 - t%ad;     // Absolute value of nc.
  61   p = 31;                 // Init. p.
  62   q1 = two31/anc;         // Init. q1 = 2**p/|nc|.
  63   r1 = two31 - q1*anc;    // Init. r1 = rem(2**p, |nc|).
  64   q2 = two31/ad;          // Init. q2 = 2**p/|d|.
  65   r2 = two31 - q2*ad;     // Init. r2 = rem(2**p, |d|).
  66   do {
  67     p = p + 1;
  68     q1 = 2*q1;            // Update q1 = 2**p/|nc|.
  69     r1 = 2*r1;            // Update r1 = rem(2**p, |nc|).
  70     if (r1 &gt;= anc) {      // (Must be an unsigned
  71       q1 = q1 + 1;        // comparison here).
  72       r1 = r1 - anc;
  73     }
  74     q2 = 2*q2;            // Update q2 = 2**p/|d|.
  75     r2 = 2*r2;            // Update r2 = rem(2**p, |d|).
  76     if (r2 &gt;= ad) {       // (Must be an unsigned
  77       q2 = q2 + 1;        // comparison here).
  78       r2 = r2 - ad;
  79     }
  80     delta = ad - r2;
  81   } while (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0));
  82 
  83   M = q2 + 1;
  84   if (d &lt; 0) M = -M;      // Magic number and
  85   s = p - 32;             // shift amount to return.
  86 
  87   return true;
  88 }
  89 
  90 //--------------------------transform_int_divide-------------------------------
  91 // Convert a division by constant divisor into an alternate Ideal graph.
  92 // Return NULL if no transformation occurs.
  93 static Node *transform_int_divide( PhaseGVN *phase, Node *dividend, jint divisor ) {
  94 
  95   // Check for invalid divisors
  96   assert( divisor != 0 &amp;&amp; divisor != min_jint,
  97           &quot;bad divisor for transforming to long multiply&quot; );
  98 
  99   bool d_pos = divisor &gt;= 0;
 100   jint d = d_pos ? divisor : -divisor;
 101   const int N = 32;
 102 
 103   // Result
 104   Node *q = NULL;
 105 
 106   if (d == 1) {
 107     // division by +/- 1
 108     if (!d_pos) {
 109       // Just negate the value
 110       q = new SubINode(phase-&gt;intcon(0), dividend);
 111     }
 112   } else if ( is_power_of_2(d) ) {
 113     // division by +/- a power of 2
 114 
 115     // See if we can simply do a shift without rounding
 116     bool needs_rounding = true;
 117     const Type *dt = phase-&gt;type(dividend);
 118     const TypeInt *dti = dt-&gt;isa_int();
 119     if (dti &amp;&amp; dti-&gt;_lo &gt;= 0) {
 120       // we don&#39;t need to round a positive dividend
 121       needs_rounding = false;
 122     } else if( dividend-&gt;Opcode() == Op_AndI ) {
 123       // An AND mask of sufficient size clears the low bits and
 124       // I can avoid rounding.
 125       const TypeInt *andconi_t = phase-&gt;type( dividend-&gt;in(2) )-&gt;isa_int();
 126       if( andconi_t &amp;&amp; andconi_t-&gt;is_con() ) {
 127         jint andconi = andconi_t-&gt;get_con();
 128         if( andconi &lt; 0 &amp;&amp; is_power_of_2(-andconi) &amp;&amp; (-andconi) &gt;= d ) {
 129           if( (-andconi) == d ) // Remove AND if it clears bits which will be shifted
 130             dividend = dividend-&gt;in(1);
 131           needs_rounding = false;
 132         }
 133       }
 134     }
 135 
 136     // Add rounding to the shift to handle the sign bit
 137     int l = log2_jint(d-1)+1;
 138     if (needs_rounding) {
 139       // Divide-by-power-of-2 can be made into a shift, but you have to do
 140       // more math for the rounding.  You need to add 0 for positive
 141       // numbers, and &quot;i-1&quot; for negative numbers.  Example: i=4, so the
 142       // shift is by 2.  You need to add 3 to negative dividends and 0 to
 143       // positive ones.  So (-7+3)&gt;&gt;2 becomes -1, (-4+3)&gt;&gt;2 becomes -1,
 144       // (-2+3)&gt;&gt;2 becomes 0, etc.
 145 
 146       // Compute 0 or -1, based on sign bit
 147       Node *sign = phase-&gt;transform(new RShiftINode(dividend, phase-&gt;intcon(N - 1)));
 148       // Mask sign bit to the low sign bits
 149       Node *round = phase-&gt;transform(new URShiftINode(sign, phase-&gt;intcon(N - l)));
 150       // Round up before shifting
 151       dividend = phase-&gt;transform(new AddINode(dividend, round));
 152     }
 153 
 154     // Shift for division
 155     q = new RShiftINode(dividend, phase-&gt;intcon(l));
 156 
 157     if (!d_pos) {
 158       q = new SubINode(phase-&gt;intcon(0), phase-&gt;transform(q));
 159     }
 160   } else {
 161     // Attempt the jint constant divide -&gt; multiply transform found in
 162     //   &quot;Division by Invariant Integers using Multiplication&quot;
 163     //     by Granlund and Montgomery
 164     // See also &quot;Hacker&#39;s Delight&quot;, chapter 10 by Warren.
 165 
 166     jint magic_const;
 167     jint shift_const;
 168     if (magic_int_divide_constants(d, magic_const, shift_const)) {
 169       Node *magic = phase-&gt;longcon(magic_const);
 170       Node *dividend_long = phase-&gt;transform(new ConvI2LNode(dividend));
 171 
 172       // Compute the high half of the dividend x magic multiplication
 173       Node *mul_hi = phase-&gt;transform(new MulLNode(dividend_long, magic));
 174 
 175       if (magic_const &lt; 0) {
 176         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(N)));
 177         mul_hi = phase-&gt;transform(new ConvL2INode(mul_hi));
 178 
 179         // The magic multiplier is too large for a 32 bit constant. We&#39;ve adjusted
 180         // it down by 2^32, but have to add 1 dividend back in after the multiplication.
 181         // This handles the &quot;overflow&quot; case described by Granlund and Montgomery.
 182         mul_hi = phase-&gt;transform(new AddINode(dividend, mul_hi));
 183 
 184         // Shift over the (adjusted) mulhi
 185         if (shift_const != 0) {
 186           mul_hi = phase-&gt;transform(new RShiftINode(mul_hi, phase-&gt;intcon(shift_const)));
 187         }
 188       } else {
 189         // No add is required, we can merge the shifts together.
 190         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(N + shift_const)));
 191         mul_hi = phase-&gt;transform(new ConvL2INode(mul_hi));
 192       }
 193 
 194       // Get a 0 or -1 from the sign of the dividend.
 195       Node *addend0 = mul_hi;
 196       Node *addend1 = phase-&gt;transform(new RShiftINode(dividend, phase-&gt;intcon(N-1)));
 197 
 198       // If the divisor is negative, swap the order of the input addends;
 199       // this has the effect of negating the quotient.
 200       if (!d_pos) {
 201         Node *temp = addend0; addend0 = addend1; addend1 = temp;
 202       }
 203 
 204       // Adjust the final quotient by subtracting -1 (adding 1)
 205       // from the mul_hi.
 206       q = new SubINode(addend0, addend1);
 207     }
 208   }
 209 
 210   return q;
 211 }
 212 
 213 //---------------------magic_long_divide_constants-----------------------------
 214 // Compute magic multiplier and shift constant for converting a 64 bit divide
 215 // by constant into a multiply/shift/add series. Return false if calculations
 216 // fail.
 217 //
 218 // Borrowed almost verbatim from Hacker&#39;s Delight by Henry S. Warren, Jr. with
 219 // minor type name and parameter changes.  Adjusted to 64 bit word width.
 220 static bool magic_long_divide_constants(jlong d, jlong &amp;M, jint &amp;s) {
 221   int64_t p;
 222   uint64_t ad, anc, delta, q1, r1, q2, r2, t;
 223   const uint64_t two63 = UCONST64(0x8000000000000000);     // 2**63.
 224 
 225   ad = ABS(d);
 226   if (d == 0 || d == 1) return false;
 227   t = two63 + ((uint64_t)d &gt;&gt; 63);
 228   anc = t - 1 - t%ad;     // Absolute value of nc.
 229   p = 63;                 // Init. p.
 230   q1 = two63/anc;         // Init. q1 = 2**p/|nc|.
 231   r1 = two63 - q1*anc;    // Init. r1 = rem(2**p, |nc|).
 232   q2 = two63/ad;          // Init. q2 = 2**p/|d|.
 233   r2 = two63 - q2*ad;     // Init. r2 = rem(2**p, |d|).
 234   do {
 235     p = p + 1;
 236     q1 = 2*q1;            // Update q1 = 2**p/|nc|.
 237     r1 = 2*r1;            // Update r1 = rem(2**p, |nc|).
 238     if (r1 &gt;= anc) {      // (Must be an unsigned
 239       q1 = q1 + 1;        // comparison here).
 240       r1 = r1 - anc;
 241     }
 242     q2 = 2*q2;            // Update q2 = 2**p/|d|.
 243     r2 = 2*r2;            // Update r2 = rem(2**p, |d|).
 244     if (r2 &gt;= ad) {       // (Must be an unsigned
 245       q2 = q2 + 1;        // comparison here).
 246       r2 = r2 - ad;
 247     }
 248     delta = ad - r2;
 249   } while (q1 &lt; delta || (q1 == delta &amp;&amp; r1 == 0));
 250 
 251   M = q2 + 1;
 252   if (d &lt; 0) M = -M;      // Magic number and
 253   s = p - 64;             // shift amount to return.
 254 
 255   return true;
 256 }
 257 
 258 //---------------------long_by_long_mulhi--------------------------------------
 259 // Generate ideal node graph for upper half of a 64 bit x 64 bit multiplication
 260 static Node* long_by_long_mulhi(PhaseGVN* phase, Node* dividend, jlong magic_const) {
 261   // If the architecture supports a 64x64 mulhi, there is
 262   // no need to synthesize it in ideal nodes.
 263   if (Matcher::has_match_rule(Op_MulHiL)) {
 264     Node* v = phase-&gt;longcon(magic_const);
 265     return new MulHiLNode(dividend, v);
 266   }
 267 
 268   // Taken from Hacker&#39;s Delight, Fig. 8-2. Multiply high signed.
 269   // (http://www.hackersdelight.org/HDcode/mulhs.c)
 270   //
 271   // int mulhs(int u, int v) {
 272   //    unsigned u0, v0, w0;
 273   //    int u1, v1, w1, w2, t;
 274   //
 275   //    u0 = u &amp; 0xFFFF;  u1 = u &gt;&gt; 16;
 276   //    v0 = v &amp; 0xFFFF;  v1 = v &gt;&gt; 16;
 277   //    w0 = u0*v0;
 278   //    t  = u1*v0 + (w0 &gt;&gt; 16);
 279   //    w1 = t &amp; 0xFFFF;
 280   //    w2 = t &gt;&gt; 16;
 281   //    w1 = u0*v1 + w1;
 282   //    return u1*v1 + w2 + (w1 &gt;&gt; 16);
 283   // }
 284   //
 285   // Note: The version above is for 32x32 multiplications, while the
 286   // following inline comments are adapted to 64x64.
 287 
 288   const int N = 64;
 289 
 290   // Dummy node to keep intermediate nodes alive during construction
 291   Node* hook = new Node(4);
 292 
 293   // u0 = u &amp; 0xFFFFFFFF;  u1 = u &gt;&gt; 32;
 294   Node* u0 = phase-&gt;transform(new AndLNode(dividend, phase-&gt;longcon(0xFFFFFFFF)));
 295   Node* u1 = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N / 2)));
 296   hook-&gt;init_req(0, u0);
 297   hook-&gt;init_req(1, u1);
 298 
 299   // v0 = v &amp; 0xFFFFFFFF;  v1 = v &gt;&gt; 32;
 300   Node* v0 = phase-&gt;longcon(magic_const &amp; 0xFFFFFFFF);
 301   Node* v1 = phase-&gt;longcon(magic_const &gt;&gt; (N / 2));
 302 
 303   // w0 = u0*v0;
 304   Node* w0 = phase-&gt;transform(new MulLNode(u0, v0));
 305 
 306   // t = u1*v0 + (w0 &gt;&gt; 32);
 307   Node* u1v0 = phase-&gt;transform(new MulLNode(u1, v0));
 308   Node* temp = phase-&gt;transform(new URShiftLNode(w0, phase-&gt;intcon(N / 2)));
 309   Node* t    = phase-&gt;transform(new AddLNode(u1v0, temp));
 310   hook-&gt;init_req(2, t);
 311 
 312   // w1 = t &amp; 0xFFFFFFFF;
 313   Node* w1 = phase-&gt;transform(new AndLNode(t, phase-&gt;longcon(0xFFFFFFFF)));
 314   hook-&gt;init_req(3, w1);
 315 
 316   // w2 = t &gt;&gt; 32;
 317   Node* w2 = phase-&gt;transform(new RShiftLNode(t, phase-&gt;intcon(N / 2)));
 318 
 319   // w1 = u0*v1 + w1;
 320   Node* u0v1 = phase-&gt;transform(new MulLNode(u0, v1));
 321   w1         = phase-&gt;transform(new AddLNode(u0v1, w1));
 322 
 323   // return u1*v1 + w2 + (w1 &gt;&gt; 32);
 324   Node* u1v1  = phase-&gt;transform(new MulLNode(u1, v1));
 325   Node* temp1 = phase-&gt;transform(new AddLNode(u1v1, w2));
 326   Node* temp2 = phase-&gt;transform(new RShiftLNode(w1, phase-&gt;intcon(N / 2)));
 327 
 328   // Remove the bogus extra edges used to keep things alive
 329   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
 330   if (igvn != NULL) {
 331     igvn-&gt;remove_dead_node(hook);
 332   } else {
 333     for (int i = 0; i &lt; 4; i++) {
 334       hook-&gt;set_req(i, NULL);
 335     }
 336   }
 337 
 338   return new AddLNode(temp1, temp2);
 339 }
 340 
 341 
 342 //--------------------------transform_long_divide------------------------------
 343 // Convert a division by constant divisor into an alternate Ideal graph.
 344 // Return NULL if no transformation occurs.
 345 static Node *transform_long_divide( PhaseGVN *phase, Node *dividend, jlong divisor ) {
 346   // Check for invalid divisors
 347   assert( divisor != 0L &amp;&amp; divisor != min_jlong,
 348           &quot;bad divisor for transforming to long multiply&quot; );
 349 
 350   bool d_pos = divisor &gt;= 0;
 351   jlong d = d_pos ? divisor : -divisor;
 352   const int N = 64;
 353 
 354   // Result
 355   Node *q = NULL;
 356 
 357   if (d == 1) {
 358     // division by +/- 1
 359     if (!d_pos) {
 360       // Just negate the value
 361       q = new SubLNode(phase-&gt;longcon(0), dividend);
 362     }
 363   } else if ( is_power_of_2(d) ) {
 364 
 365     // division by +/- a power of 2
 366 
 367     // See if we can simply do a shift without rounding
 368     bool needs_rounding = true;
 369     const Type *dt = phase-&gt;type(dividend);
 370     const TypeLong *dtl = dt-&gt;isa_long();
 371 
 372     if (dtl &amp;&amp; dtl-&gt;_lo &gt; 0) {
 373       // we don&#39;t need to round a positive dividend
 374       needs_rounding = false;
 375     } else if( dividend-&gt;Opcode() == Op_AndL ) {
 376       // An AND mask of sufficient size clears the low bits and
 377       // I can avoid rounding.
 378       const TypeLong *andconl_t = phase-&gt;type( dividend-&gt;in(2) )-&gt;isa_long();
 379       if( andconl_t &amp;&amp; andconl_t-&gt;is_con() ) {
 380         jlong andconl = andconl_t-&gt;get_con();
 381         if( andconl &lt; 0 &amp;&amp; is_power_of_2(-andconl) &amp;&amp; (-andconl) &gt;= d ) {
 382           if( (-andconl) == d ) // Remove AND if it clears bits which will be shifted
 383             dividend = dividend-&gt;in(1);
 384           needs_rounding = false;
 385         }
 386       }
 387     }
 388 
 389     // Add rounding to the shift to handle the sign bit
 390     int l = log2_long(d-1)+1;
 391     if (needs_rounding) {
 392       // Divide-by-power-of-2 can be made into a shift, but you have to do
 393       // more math for the rounding.  You need to add 0 for positive
 394       // numbers, and &quot;i-1&quot; for negative numbers.  Example: i=4, so the
 395       // shift is by 2.  You need to add 3 to negative dividends and 0 to
 396       // positive ones.  So (-7+3)&gt;&gt;2 becomes -1, (-4+3)&gt;&gt;2 becomes -1,
 397       // (-2+3)&gt;&gt;2 becomes 0, etc.
 398 
 399       // Compute 0 or -1, based on sign bit
 400       Node *sign = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N - 1)));
 401       // Mask sign bit to the low sign bits
 402       Node *round = phase-&gt;transform(new URShiftLNode(sign, phase-&gt;intcon(N - l)));
 403       // Round up before shifting
 404       dividend = phase-&gt;transform(new AddLNode(dividend, round));
 405     }
 406 
 407     // Shift for division
 408     q = new RShiftLNode(dividend, phase-&gt;intcon(l));
 409 
 410     if (!d_pos) {
 411       q = new SubLNode(phase-&gt;longcon(0), phase-&gt;transform(q));
 412     }
 413   } else if ( !Matcher::use_asm_for_ldiv_by_con(d) ) { // Use hardware DIV instruction when
 414                                                        // it is faster than code generated below.
 415     // Attempt the jlong constant divide -&gt; multiply transform found in
 416     //   &quot;Division by Invariant Integers using Multiplication&quot;
 417     //     by Granlund and Montgomery
 418     // See also &quot;Hacker&#39;s Delight&quot;, chapter 10 by Warren.
 419 
 420     jlong magic_const;
 421     jint shift_const;
 422     if (magic_long_divide_constants(d, magic_const, shift_const)) {
 423       // Compute the high half of the dividend x magic multiplication
 424       Node *mul_hi = phase-&gt;transform(long_by_long_mulhi(phase, dividend, magic_const));
 425 
 426       // The high half of the 128-bit multiply is computed.
 427       if (magic_const &lt; 0) {
 428         // The magic multiplier is too large for a 64 bit constant. We&#39;ve adjusted
 429         // it down by 2^64, but have to add 1 dividend back in after the multiplication.
 430         // This handles the &quot;overflow&quot; case described by Granlund and Montgomery.
 431         mul_hi = phase-&gt;transform(new AddLNode(dividend, mul_hi));
 432       }
 433 
 434       // Shift over the (adjusted) mulhi
 435       if (shift_const != 0) {
 436         mul_hi = phase-&gt;transform(new RShiftLNode(mul_hi, phase-&gt;intcon(shift_const)));
 437       }
 438 
 439       // Get a 0 or -1 from the sign of the dividend.
 440       Node *addend0 = mul_hi;
 441       Node *addend1 = phase-&gt;transform(new RShiftLNode(dividend, phase-&gt;intcon(N-1)));
 442 
 443       // If the divisor is negative, swap the order of the input addends;
 444       // this has the effect of negating the quotient.
 445       if (!d_pos) {
 446         Node *temp = addend0; addend0 = addend1; addend1 = temp;
 447       }
 448 
 449       // Adjust the final quotient by subtracting -1 (adding 1)
 450       // from the mul_hi.
 451       q = new SubLNode(addend0, addend1);
 452     }
 453   }
 454 
 455   return q;
 456 }
 457 
 458 //=============================================================================
 459 //------------------------------Identity---------------------------------------
 460 // If the divisor is 1, we are an identity on the dividend.
 461 Node* DivINode::Identity(PhaseGVN* phase) {
 462   return (phase-&gt;type( in(2) )-&gt;higher_equal(TypeInt::ONE)) ? in(1) : this;
 463 }
 464 
 465 //------------------------------Idealize---------------------------------------
 466 // Divides can be changed to multiplies and/or shifts
 467 Node *DivINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 468   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 469   // Don&#39;t bother trying to transform a dead node
 470   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 471 
 472   const Type *t = phase-&gt;type( in(2) );
 473   if( t == TypeInt::ONE )       // Identity?
 474     return NULL;                // Skip it
 475 
 476   const TypeInt *ti = t-&gt;isa_int();
 477   if( !ti ) return NULL;
 478 
 479   // Check for useless control input
 480   // Check for excluding div-zero case
 481   if (in(0) &amp;&amp; (ti-&gt;_hi &lt; 0 || ti-&gt;_lo &gt; 0)) {
 482     set_req(0, NULL);           // Yank control input
 483     return this;
 484   }
 485 
 486   if( !ti-&gt;is_con() ) return NULL;
 487   jint i = ti-&gt;get_con();       // Get divisor
 488 
 489   if (i == 0) return NULL;      // Dividing by zero constant does not idealize
 490 
 491   // Dividing by MININT does not optimize as a power-of-2 shift.
 492   if( i == min_jint ) return NULL;
 493 
 494   return transform_int_divide( phase, in(1), i );
 495 }
 496 
 497 //------------------------------Value------------------------------------------
 498 // A DivINode divides its inputs.  The third input is a Control input, used to
 499 // prevent hoisting the divide above an unsafe test.
 500 const Type* DivINode::Value(PhaseGVN* phase) const {
 501   // Either input is TOP ==&gt; the result is TOP
 502   const Type *t1 = phase-&gt;type( in(1) );
 503   const Type *t2 = phase-&gt;type( in(2) );
 504   if( t1 == Type::TOP ) return Type::TOP;
 505   if( t2 == Type::TOP ) return Type::TOP;
 506 
 507   // x/x == 1 since we always generate the dynamic divisor check for 0.
 508   if( phase-&gt;eqv( in(1), in(2) ) )
 509     return TypeInt::ONE;
 510 
 511   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 512   const Type *bot = bottom_type();
 513   if( (t1 == bot) || (t2 == bot) ||
 514       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 515     return bot;
 516 
 517   // Divide the two numbers.  We approximate.
 518   // If divisor is a constant and not zero
 519   const TypeInt *i1 = t1-&gt;is_int();
 520   const TypeInt *i2 = t2-&gt;is_int();
 521   int widen = MAX2(i1-&gt;_widen, i2-&gt;_widen);
 522 
 523   if( i2-&gt;is_con() &amp;&amp; i2-&gt;get_con() != 0 ) {
 524     int32_t d = i2-&gt;get_con(); // Divisor
 525     jint lo, hi;
 526     if( d &gt;= 0 ) {
 527       lo = i1-&gt;_lo/d;
 528       hi = i1-&gt;_hi/d;
 529     } else {
 530       if( d == -1 &amp;&amp; i1-&gt;_lo == min_jint ) {
 531         // &#39;min_jint/-1&#39; throws arithmetic exception during compilation
 532         lo = min_jint;
 533         // do not support holes, &#39;hi&#39; must go to either min_jint or max_jint:
 534         // [min_jint, -10]/[-1,-1] ==&gt; [min_jint] UNION [10,max_jint]
 535         hi = i1-&gt;_hi == min_jint ? min_jint : max_jint;
 536       } else {
 537         lo = i1-&gt;_hi/d;
 538         hi = i1-&gt;_lo/d;
 539       }
 540     }
 541     return TypeInt::make(lo, hi, widen);
 542   }
 543 
 544   // If the dividend is a constant
 545   if( i1-&gt;is_con() ) {
 546     int32_t d = i1-&gt;get_con();
 547     if( d &lt; 0 ) {
 548       if( d == min_jint ) {
 549         //  (-min_jint) == min_jint == (min_jint / -1)
 550         return TypeInt::make(min_jint, max_jint/2 + 1, widen);
 551       } else {
 552         return TypeInt::make(d, -d, widen);
 553       }
 554     }
 555     return TypeInt::make(-d, d, widen);
 556   }
 557 
 558   // Otherwise we give up all hope
 559   return TypeInt::INT;
 560 }
 561 
 562 
 563 //=============================================================================
 564 //------------------------------Identity---------------------------------------
 565 // If the divisor is 1, we are an identity on the dividend.
 566 Node* DivLNode::Identity(PhaseGVN* phase) {
 567   return (phase-&gt;type( in(2) )-&gt;higher_equal(TypeLong::ONE)) ? in(1) : this;
 568 }
 569 
 570 //------------------------------Idealize---------------------------------------
 571 // Dividing by a power of 2 is a shift.
 572 Node *DivLNode::Ideal( PhaseGVN *phase, bool can_reshape) {
 573   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 574   // Don&#39;t bother trying to transform a dead node
 575   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 576 
 577   const Type *t = phase-&gt;type( in(2) );
 578   if( t == TypeLong::ONE )      // Identity?
 579     return NULL;                // Skip it
 580 
 581   const TypeLong *tl = t-&gt;isa_long();
 582   if( !tl ) return NULL;
 583 
 584   // Check for useless control input
 585   // Check for excluding div-zero case
 586   if (in(0) &amp;&amp; (tl-&gt;_hi &lt; 0 || tl-&gt;_lo &gt; 0)) {
 587     set_req(0, NULL);           // Yank control input
 588     return this;
 589   }
 590 
 591   if( !tl-&gt;is_con() ) return NULL;
 592   jlong l = tl-&gt;get_con();      // Get divisor
 593 
 594   if (l == 0) return NULL;      // Dividing by zero constant does not idealize
 595 
 596   // Dividing by MINLONG does not optimize as a power-of-2 shift.
 597   if( l == min_jlong ) return NULL;
 598 
 599   return transform_long_divide( phase, in(1), l );
 600 }
 601 
 602 //------------------------------Value------------------------------------------
 603 // A DivLNode divides its inputs.  The third input is a Control input, used to
 604 // prevent hoisting the divide above an unsafe test.
 605 const Type* DivLNode::Value(PhaseGVN* phase) const {
 606   // Either input is TOP ==&gt; the result is TOP
 607   const Type *t1 = phase-&gt;type( in(1) );
 608   const Type *t2 = phase-&gt;type( in(2) );
 609   if( t1 == Type::TOP ) return Type::TOP;
 610   if( t2 == Type::TOP ) return Type::TOP;
 611 
 612   // x/x == 1 since we always generate the dynamic divisor check for 0.
 613   if( phase-&gt;eqv( in(1), in(2) ) )
 614     return TypeLong::ONE;
 615 
 616   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 617   const Type *bot = bottom_type();
 618   if( (t1 == bot) || (t2 == bot) ||
 619       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 620     return bot;
 621 
 622   // Divide the two numbers.  We approximate.
 623   // If divisor is a constant and not zero
 624   const TypeLong *i1 = t1-&gt;is_long();
 625   const TypeLong *i2 = t2-&gt;is_long();
 626   int widen = MAX2(i1-&gt;_widen, i2-&gt;_widen);
 627 
 628   if( i2-&gt;is_con() &amp;&amp; i2-&gt;get_con() != 0 ) {
 629     jlong d = i2-&gt;get_con();    // Divisor
 630     jlong lo, hi;
 631     if( d &gt;= 0 ) {
 632       lo = i1-&gt;_lo/d;
 633       hi = i1-&gt;_hi/d;
 634     } else {
 635       if( d == CONST64(-1) &amp;&amp; i1-&gt;_lo == min_jlong ) {
 636         // &#39;min_jlong/-1&#39; throws arithmetic exception during compilation
 637         lo = min_jlong;
 638         // do not support holes, &#39;hi&#39; must go to either min_jlong or max_jlong:
 639         // [min_jlong, -10]/[-1,-1] ==&gt; [min_jlong] UNION [10,max_jlong]
 640         hi = i1-&gt;_hi == min_jlong ? min_jlong : max_jlong;
 641       } else {
 642         lo = i1-&gt;_hi/d;
 643         hi = i1-&gt;_lo/d;
 644       }
 645     }
 646     return TypeLong::make(lo, hi, widen);
 647   }
 648 
 649   // If the dividend is a constant
 650   if( i1-&gt;is_con() ) {
 651     jlong d = i1-&gt;get_con();
 652     if( d &lt; 0 ) {
 653       if( d == min_jlong ) {
 654         //  (-min_jlong) == min_jlong == (min_jlong / -1)
 655         return TypeLong::make(min_jlong, max_jlong/2 + 1, widen);
 656       } else {
 657         return TypeLong::make(d, -d, widen);
 658       }
 659     }
 660     return TypeLong::make(-d, d, widen);
 661   }
 662 
 663   // Otherwise we give up all hope
 664   return TypeLong::LONG;
 665 }
 666 
 667 
 668 //=============================================================================
 669 //------------------------------Value------------------------------------------
 670 // An DivFNode divides its inputs.  The third input is a Control input, used to
 671 // prevent hoisting the divide above an unsafe test.
 672 const Type* DivFNode::Value(PhaseGVN* phase) const {
 673   // Either input is TOP ==&gt; the result is TOP
 674   const Type *t1 = phase-&gt;type( in(1) );
 675   const Type *t2 = phase-&gt;type( in(2) );
 676   if( t1 == Type::TOP ) return Type::TOP;
 677   if( t2 == Type::TOP ) return Type::TOP;
 678 
 679   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 680   const Type *bot = bottom_type();
 681   if( (t1 == bot) || (t2 == bot) ||
 682       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 683     return bot;
 684 
 685   // x/x == 1, we ignore 0/0.
 686   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 687   // Does not work for variables because of NaN&#39;s
 688   if( phase-&gt;eqv( in(1), in(2) ) &amp;&amp; t1-&gt;base() == Type::FloatCon)
 689     if (!g_isnan(t1-&gt;getf()) &amp;&amp; g_isfinite(t1-&gt;getf()) &amp;&amp; t1-&gt;getf() != 0.0) // could be negative ZERO or NaN
 690       return TypeF::ONE;
 691 
 692   if( t2 == TypeF::ONE )
 693     return t1;
 694 
 695   // If divisor is a constant and not zero, divide them numbers
 696   if( t1-&gt;base() == Type::FloatCon &amp;&amp;
 697       t2-&gt;base() == Type::FloatCon &amp;&amp;
 698       t2-&gt;getf() != 0.0 ) // could be negative zero
 699     return TypeF::make( t1-&gt;getf()/t2-&gt;getf() );
 700 
 701   // If the dividend is a constant zero
 702   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 703   // Test TypeF::ZERO is not sufficient as it could be negative zero
 704 
 705   if( t1 == TypeF::ZERO &amp;&amp; !g_isnan(t2-&gt;getf()) &amp;&amp; t2-&gt;getf() != 0.0 )
 706     return TypeF::ZERO;
 707 
 708   // Otherwise we give up all hope
 709   return Type::FLOAT;
 710 }
 711 
 712 //------------------------------isA_Copy---------------------------------------
 713 // Dividing by self is 1.
 714 // If the divisor is 1, we are an identity on the dividend.
 715 Node* DivFNode::Identity(PhaseGVN* phase) {
 716   return (phase-&gt;type( in(2) ) == TypeF::ONE) ? in(1) : this;
 717 }
 718 
 719 
 720 //------------------------------Idealize---------------------------------------
 721 Node *DivFNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 722   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 723   // Don&#39;t bother trying to transform a dead node
 724   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 725 
 726   const Type *t2 = phase-&gt;type( in(2) );
 727   if( t2 == TypeF::ONE )         // Identity?
 728     return NULL;                // Skip it
 729 
 730   const TypeF *tf = t2-&gt;isa_float_constant();
 731   if( !tf ) return NULL;
 732   if( tf-&gt;base() != Type::FloatCon ) return NULL;
 733 
 734   // Check for out of range values
 735   if( tf-&gt;is_nan() || !tf-&gt;is_finite() ) return NULL;
 736 
 737   // Get the value
 738   float f = tf-&gt;getf();
 739   int exp;
 740 
 741   // Only for special case of dividing by a power of 2
 742   if( frexp((double)f, &amp;exp) != 0.5 ) return NULL;
 743 
 744   // Limit the range of acceptable exponents
 745   if( exp &lt; -126 || exp &gt; 126 ) return NULL;
 746 
 747   // Compute the reciprocal
 748   float reciprocal = ((float)1.0) / f;
 749 
 750   assert( frexp((double)reciprocal, &amp;exp) == 0.5, &quot;reciprocal should be power of 2&quot; );
 751 
 752   // return multiplication by the reciprocal
 753   return (new MulFNode(in(1), phase-&gt;makecon(TypeF::make(reciprocal))));
 754 }
 755 
 756 //=============================================================================
 757 //------------------------------Value------------------------------------------
 758 // An DivDNode divides its inputs.  The third input is a Control input, used to
 759 // prevent hoisting the divide above an unsafe test.
 760 const Type* DivDNode::Value(PhaseGVN* phase) const {
 761   // Either input is TOP ==&gt; the result is TOP
 762   const Type *t1 = phase-&gt;type( in(1) );
 763   const Type *t2 = phase-&gt;type( in(2) );
 764   if( t1 == Type::TOP ) return Type::TOP;
 765   if( t2 == Type::TOP ) return Type::TOP;
 766 
 767   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 768   const Type *bot = bottom_type();
 769   if( (t1 == bot) || (t2 == bot) ||
 770       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 771     return bot;
 772 
 773   // x/x == 1, we ignore 0/0.
 774   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 775   // Does not work for variables because of NaN&#39;s
 776   if( phase-&gt;eqv( in(1), in(2) ) &amp;&amp; t1-&gt;base() == Type::DoubleCon)
 777     if (!g_isnan(t1-&gt;getd()) &amp;&amp; g_isfinite(t1-&gt;getd()) &amp;&amp; t1-&gt;getd() != 0.0) // could be negative ZERO or NaN
 778       return TypeD::ONE;
 779 
 780   if( t2 == TypeD::ONE )
 781     return t1;
 782 
 783 #if defined(IA32)
 784   if (!phase-&gt;C-&gt;method()-&gt;is_strict())
 785     // Can&#39;t trust native compilers to properly fold strict double
 786     // division with round-to-zero on this platform.
 787 #endif
 788     {
 789       // If divisor is a constant and not zero, divide them numbers
 790       if( t1-&gt;base() == Type::DoubleCon &amp;&amp;
 791           t2-&gt;base() == Type::DoubleCon &amp;&amp;
 792           t2-&gt;getd() != 0.0 ) // could be negative zero
 793         return TypeD::make( t1-&gt;getd()/t2-&gt;getd() );
 794     }
 795 
 796   // If the dividend is a constant zero
 797   // Note: if t1 and t2 are zero then result is NaN (JVMS page 213)
 798   // Test TypeF::ZERO is not sufficient as it could be negative zero
 799   if( t1 == TypeD::ZERO &amp;&amp; !g_isnan(t2-&gt;getd()) &amp;&amp; t2-&gt;getd() != 0.0 )
 800     return TypeD::ZERO;
 801 
 802   // Otherwise we give up all hope
 803   return Type::DOUBLE;
 804 }
 805 
 806 
 807 //------------------------------isA_Copy---------------------------------------
 808 // Dividing by self is 1.
 809 // If the divisor is 1, we are an identity on the dividend.
 810 Node* DivDNode::Identity(PhaseGVN* phase) {
 811   return (phase-&gt;type( in(2) ) == TypeD::ONE) ? in(1) : this;
 812 }
 813 
 814 //------------------------------Idealize---------------------------------------
 815 Node *DivDNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 816   if (in(0) &amp;&amp; remove_dead_region(phase, can_reshape))  return this;
 817   // Don&#39;t bother trying to transform a dead node
 818   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 819 
 820   const Type *t2 = phase-&gt;type( in(2) );
 821   if( t2 == TypeD::ONE )         // Identity?
 822     return NULL;                // Skip it
 823 
 824   const TypeD *td = t2-&gt;isa_double_constant();
 825   if( !td ) return NULL;
 826   if( td-&gt;base() != Type::DoubleCon ) return NULL;
 827 
 828   // Check for out of range values
 829   if( td-&gt;is_nan() || !td-&gt;is_finite() ) return NULL;
 830 
 831   // Get the value
 832   double d = td-&gt;getd();
 833   int exp;
 834 
 835   // Only for special case of dividing by a power of 2
 836   if( frexp(d, &amp;exp) != 0.5 ) return NULL;
 837 
 838   // Limit the range of acceptable exponents
 839   if( exp &lt; -1021 || exp &gt; 1022 ) return NULL;
 840 
 841   // Compute the reciprocal
 842   double reciprocal = 1.0 / d;
 843 
 844   assert( frexp(reciprocal, &amp;exp) == 0.5, &quot;reciprocal should be power of 2&quot; );
 845 
 846   // return multiplication by the reciprocal
 847   return (new MulDNode(in(1), phase-&gt;makecon(TypeD::make(reciprocal))));
 848 }
 849 
 850 //=============================================================================
 851 //------------------------------Idealize---------------------------------------
 852 Node *ModINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 853   // Check for dead control input
 854   if( in(0) &amp;&amp; remove_dead_region(phase, can_reshape) )  return this;
 855   // Don&#39;t bother trying to transform a dead node
 856   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
 857 
 858   // Get the modulus
 859   const Type *t = phase-&gt;type( in(2) );
 860   if( t == Type::TOP ) return NULL;
 861   const TypeInt *ti = t-&gt;is_int();
 862 
 863   // Check for useless control input
 864   // Check for excluding mod-zero case
 865   if (in(0) &amp;&amp; (ti-&gt;_hi &lt; 0 || ti-&gt;_lo &gt; 0)) {
 866     set_req(0, NULL);        // Yank control input
 867     return this;
 868   }
 869 
 870   // See if we are MOD&#39;ing by 2^k or 2^k-1.
 871   if( !ti-&gt;is_con() ) return NULL;
 872   jint con = ti-&gt;get_con();
 873 
 874   Node *hook = new Node(1);
 875 
 876   // First, special check for modulo 2^k-1
 877   if( con &gt;= 0 &amp;&amp; con &lt; max_jint &amp;&amp; is_power_of_2(con+1) ) {
 878     uint k = exact_log2(con+1);  // Extract k
 879 
 880     // Basic algorithm by David Detlefs.  See fastmod_int.java for gory details.
 881     static int unroll_factor[] = { 999, 999, 29, 14, 9, 7, 5, 4, 4, 3, 3, 2, 2, 2, 2, 2, 1 /*past here we assume 1 forever*/};
 882     int trip_count = 1;
 883     if( k &lt; ARRAY_SIZE(unroll_factor))  trip_count = unroll_factor[k];
 884 
 885     // If the unroll factor is not too large, and if conditional moves are
 886     // ok, then use this case
 887     if( trip_count &lt;= 5 &amp;&amp; ConditionalMoveLimit != 0 ) {
 888       Node *x = in(1);            // Value being mod&#39;d
 889       Node *divisor = in(2);      // Also is mask
 890 
 891       hook-&gt;init_req(0, x);       // Add a use to x to prevent him from dying
 892       // Generate code to reduce X rapidly to nearly 2^k-1.
 893       for( int i = 0; i &lt; trip_count; i++ ) {
 894         Node *xl = phase-&gt;transform( new AndINode(x,divisor) );
 895         Node *xh = phase-&gt;transform( new RShiftINode(x,phase-&gt;intcon(k)) ); // Must be signed
 896         x = phase-&gt;transform( new AddINode(xh,xl) );
 897         hook-&gt;set_req(0, x);
 898       }
 899 
 900       // Generate sign-fixup code.  Was original value positive?
 901       // int hack_res = (i &gt;= 0) ? divisor : 1;
 902       Node *cmp1 = phase-&gt;transform( new CmpINode( in(1), phase-&gt;intcon(0) ) );
 903       Node *bol1 = phase-&gt;transform( new BoolNode( cmp1, BoolTest::ge ) );
 904       Node *cmov1= phase-&gt;transform( new CMoveINode(bol1, phase-&gt;intcon(1), divisor, TypeInt::POS) );
 905       // if( x &gt;= hack_res ) x -= divisor;
 906       Node *sub  = phase-&gt;transform( new SubINode( x, divisor ) );
 907       Node *cmp2 = phase-&gt;transform( new CmpINode( x, cmov1 ) );
 908       Node *bol2 = phase-&gt;transform( new BoolNode( cmp2, BoolTest::ge ) );
 909       // Convention is to not transform the return value of an Ideal
 910       // since Ideal is expected to return a modified &#39;this&#39; or a new node.
 911       Node *cmov2= new CMoveINode(bol2, x, sub, TypeInt::INT);
 912       // cmov2 is now the mod
 913 
 914       // Now remove the bogus extra edges used to keep things alive
 915       if (can_reshape) {
 916         phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
 917       } else {
 918         hook-&gt;set_req(0, NULL);   // Just yank bogus edge during Parse phase
 919       }
 920       return cmov2;
 921     }
 922   }
 923 
 924   // Fell thru, the unroll case is not appropriate. Transform the modulo
 925   // into a long multiply/int multiply/subtract case
 926 
 927   // Cannot handle mod 0, and min_jint isn&#39;t handled by the transform
 928   if( con == 0 || con == min_jint ) return NULL;
 929 
 930   // Get the absolute value of the constant; at this point, we can use this
 931   jint pos_con = (con &gt;= 0) ? con : -con;
 932 
 933   // integer Mod 1 is always 0
 934   if( pos_con == 1 ) return new ConINode(TypeInt::ZERO);
 935 
 936   int log2_con = -1;
 937 
 938   // If this is a power of two, they maybe we can mask it
 939   if( is_power_of_2(pos_con) ) {
 940     log2_con = log2_intptr((intptr_t)pos_con);
 941 
 942     const Type *dt = phase-&gt;type(in(1));
 943     const TypeInt *dti = dt-&gt;isa_int();
 944 
 945     // See if this can be masked, if the dividend is non-negative
 946     if( dti &amp;&amp; dti-&gt;_lo &gt;= 0 )
 947       return ( new AndINode( in(1), phase-&gt;intcon( pos_con-1 ) ) );
 948   }
 949 
 950   // Save in(1) so that it cannot be changed or deleted
 951   hook-&gt;init_req(0, in(1));
 952 
 953   // Divide using the transform from DivI to MulL
 954   Node *result = transform_int_divide( phase, in(1), pos_con );
 955   if (result != NULL) {
 956     Node *divide = phase-&gt;transform(result);
 957 
 958     // Re-multiply, using a shift if this is a power of two
 959     Node *mult = NULL;
 960 
 961     if( log2_con &gt;= 0 )
 962       mult = phase-&gt;transform( new LShiftINode( divide, phase-&gt;intcon( log2_con ) ) );
 963     else
 964       mult = phase-&gt;transform( new MulINode( divide, phase-&gt;intcon( pos_con ) ) );
 965 
 966     // Finally, subtract the multiplied divided value from the original
 967     result = new SubINode( in(1), mult );
 968   }
 969 
 970   // Now remove the bogus extra edges used to keep things alive
 971   if (can_reshape) {
 972     phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
 973   } else {
 974     hook-&gt;set_req(0, NULL);       // Just yank bogus edge during Parse phase
 975   }
 976 
 977   // return the value
 978   return result;
 979 }
 980 
 981 //------------------------------Value------------------------------------------
 982 const Type* ModINode::Value(PhaseGVN* phase) const {
 983   // Either input is TOP ==&gt; the result is TOP
 984   const Type *t1 = phase-&gt;type( in(1) );
 985   const Type *t2 = phase-&gt;type( in(2) );
 986   if( t1 == Type::TOP ) return Type::TOP;
 987   if( t2 == Type::TOP ) return Type::TOP;
 988 
 989   // We always generate the dynamic check for 0.
 990   // 0 MOD X is 0
 991   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 992   // X MOD X is 0
 993   if( phase-&gt;eqv( in(1), in(2) ) ) return TypeInt::ZERO;
 994 
 995   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 996   const Type *bot = bottom_type();
 997   if( (t1 == bot) || (t2 == bot) ||
 998       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 999     return bot;
1000 
1001   const TypeInt *i1 = t1-&gt;is_int();
1002   const TypeInt *i2 = t2-&gt;is_int();
1003   if( !i1-&gt;is_con() || !i2-&gt;is_con() ) {
1004     if( i1-&gt;_lo &gt;= 0 &amp;&amp; i2-&gt;_lo &gt;= 0 )
1005       return TypeInt::POS;
1006     // If both numbers are not constants, we know little.
1007     return TypeInt::INT;
1008   }
1009   // Mod by zero?  Throw exception at runtime!
1010   if( !i2-&gt;get_con() ) return TypeInt::POS;
1011 
1012   // We must be modulo&#39;ing 2 float constants.
1013   // Check for min_jint % &#39;-1&#39;, result is defined to be &#39;0&#39;.
1014   if( i1-&gt;get_con() == min_jint &amp;&amp; i2-&gt;get_con() == -1 )
1015     return TypeInt::ZERO;
1016 
1017   return TypeInt::make( i1-&gt;get_con() % i2-&gt;get_con() );
1018 }
1019 
1020 
1021 //=============================================================================
1022 //------------------------------Idealize---------------------------------------
1023 Node *ModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1024   // Check for dead control input
1025   if( in(0) &amp;&amp; remove_dead_region(phase, can_reshape) )  return this;
1026   // Don&#39;t bother trying to transform a dead node
1027   if( in(0) &amp;&amp; in(0)-&gt;is_top() )  return NULL;
1028 
1029   // Get the modulus
1030   const Type *t = phase-&gt;type( in(2) );
1031   if( t == Type::TOP ) return NULL;
1032   const TypeLong *tl = t-&gt;is_long();
1033 
1034   // Check for useless control input
1035   // Check for excluding mod-zero case
1036   if (in(0) &amp;&amp; (tl-&gt;_hi &lt; 0 || tl-&gt;_lo &gt; 0)) {
1037     set_req(0, NULL);        // Yank control input
1038     return this;
1039   }
1040 
1041   // See if we are MOD&#39;ing by 2^k or 2^k-1.
1042   if( !tl-&gt;is_con() ) return NULL;
1043   jlong con = tl-&gt;get_con();
1044 
1045   Node *hook = new Node(1);
1046 
1047   // Expand mod
1048   if( con &gt;= 0 &amp;&amp; con &lt; max_jlong &amp;&amp; is_power_of_2(con+1) ) {
1049     uint k = exact_log2_long(con+1);  // Extract k
1050 
1051     // Basic algorithm by David Detlefs.  See fastmod_long.java for gory details.
1052     // Used to help a popular random number generator which does a long-mod
1053     // of 2^31-1 and shows up in SpecJBB and SciMark.
1054     static int unroll_factor[] = { 999, 999, 61, 30, 20, 15, 12, 10, 8, 7, 6, 6, 5, 5, 4, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1 /*past here we assume 1 forever*/};
1055     int trip_count = 1;
1056     if( k &lt; ARRAY_SIZE(unroll_factor)) trip_count = unroll_factor[k];
1057 
1058     // If the unroll factor is not too large, and if conditional moves are
1059     // ok, then use this case
1060     if( trip_count &lt;= 5 &amp;&amp; ConditionalMoveLimit != 0 ) {
1061       Node *x = in(1);            // Value being mod&#39;d
1062       Node *divisor = in(2);      // Also is mask
1063 
1064       hook-&gt;init_req(0, x);       // Add a use to x to prevent him from dying
1065       // Generate code to reduce X rapidly to nearly 2^k-1.
1066       for( int i = 0; i &lt; trip_count; i++ ) {
1067         Node *xl = phase-&gt;transform( new AndLNode(x,divisor) );
1068         Node *xh = phase-&gt;transform( new RShiftLNode(x,phase-&gt;intcon(k)) ); // Must be signed
1069         x = phase-&gt;transform( new AddLNode(xh,xl) );
1070         hook-&gt;set_req(0, x);    // Add a use to x to prevent him from dying
1071       }
1072 
1073       // Generate sign-fixup code.  Was original value positive?
1074       // long hack_res = (i &gt;= 0) ? divisor : CONST64(1);
1075       Node *cmp1 = phase-&gt;transform( new CmpLNode( in(1), phase-&gt;longcon(0) ) );
1076       Node *bol1 = phase-&gt;transform( new BoolNode( cmp1, BoolTest::ge ) );
1077       Node *cmov1= phase-&gt;transform( new CMoveLNode(bol1, phase-&gt;longcon(1), divisor, TypeLong::LONG) );
1078       // if( x &gt;= hack_res ) x -= divisor;
1079       Node *sub  = phase-&gt;transform( new SubLNode( x, divisor ) );
1080       Node *cmp2 = phase-&gt;transform( new CmpLNode( x, cmov1 ) );
1081       Node *bol2 = phase-&gt;transform( new BoolNode( cmp2, BoolTest::ge ) );
1082       // Convention is to not transform the return value of an Ideal
1083       // since Ideal is expected to return a modified &#39;this&#39; or a new node.
1084       Node *cmov2= new CMoveLNode(bol2, x, sub, TypeLong::LONG);
1085       // cmov2 is now the mod
1086 
1087       // Now remove the bogus extra edges used to keep things alive
1088       if (can_reshape) {
1089         phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
1090       } else {
1091         hook-&gt;set_req(0, NULL);   // Just yank bogus edge during Parse phase
1092       }
1093       return cmov2;
1094     }
1095   }
1096 
1097   // Fell thru, the unroll case is not appropriate. Transform the modulo
1098   // into a long multiply/int multiply/subtract case
1099 
1100   // Cannot handle mod 0, and min_jlong isn&#39;t handled by the transform
1101   if( con == 0 || con == min_jlong ) return NULL;
1102 
1103   // Get the absolute value of the constant; at this point, we can use this
1104   jlong pos_con = (con &gt;= 0) ? con : -con;
1105 
1106   // integer Mod 1 is always 0
1107   if( pos_con == 1 ) return new ConLNode(TypeLong::ZERO);
1108 
1109   int log2_con = -1;
1110 
1111   // If this is a power of two, then maybe we can mask it
1112   if( is_power_of_2(pos_con) ) {
1113     log2_con = exact_log2_long(pos_con);
1114 
1115     const Type *dt = phase-&gt;type(in(1));
1116     const TypeLong *dtl = dt-&gt;isa_long();
1117 
1118     // See if this can be masked, if the dividend is non-negative
1119     if( dtl &amp;&amp; dtl-&gt;_lo &gt;= 0 )
1120       return ( new AndLNode( in(1), phase-&gt;longcon( pos_con-1 ) ) );
1121   }
1122 
1123   // Save in(1) so that it cannot be changed or deleted
1124   hook-&gt;init_req(0, in(1));
1125 
1126   // Divide using the transform from DivL to MulL
1127   Node *result = transform_long_divide( phase, in(1), pos_con );
1128   if (result != NULL) {
1129     Node *divide = phase-&gt;transform(result);
1130 
1131     // Re-multiply, using a shift if this is a power of two
1132     Node *mult = NULL;
1133 
1134     if( log2_con &gt;= 0 )
1135       mult = phase-&gt;transform( new LShiftLNode( divide, phase-&gt;intcon( log2_con ) ) );
1136     else
1137       mult = phase-&gt;transform( new MulLNode( divide, phase-&gt;longcon( pos_con ) ) );
1138 
1139     // Finally, subtract the multiplied divided value from the original
1140     result = new SubLNode( in(1), mult );
1141   }
1142 
1143   // Now remove the bogus extra edges used to keep things alive
1144   if (can_reshape) {
1145     phase-&gt;is_IterGVN()-&gt;remove_dead_node(hook);
1146   } else {
1147     hook-&gt;set_req(0, NULL);       // Just yank bogus edge during Parse phase
1148   }
1149 
1150   // return the value
1151   return result;
1152 }
1153 
1154 //------------------------------Value------------------------------------------
1155 const Type* ModLNode::Value(PhaseGVN* phase) const {
1156   // Either input is TOP ==&gt; the result is TOP
1157   const Type *t1 = phase-&gt;type( in(1) );
1158   const Type *t2 = phase-&gt;type( in(2) );
1159   if( t1 == Type::TOP ) return Type::TOP;
1160   if( t2 == Type::TOP ) return Type::TOP;
1161 
1162   // We always generate the dynamic check for 0.
1163   // 0 MOD X is 0
1164   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1165   // X MOD X is 0
1166   if( phase-&gt;eqv( in(1), in(2) ) ) return TypeLong::ZERO;
1167 
1168   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1169   const Type *bot = bottom_type();
1170   if( (t1 == bot) || (t2 == bot) ||
1171       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1172     return bot;
1173 
1174   const TypeLong *i1 = t1-&gt;is_long();
1175   const TypeLong *i2 = t2-&gt;is_long();
1176   if( !i1-&gt;is_con() || !i2-&gt;is_con() ) {
1177     if( i1-&gt;_lo &gt;= CONST64(0) &amp;&amp; i2-&gt;_lo &gt;= CONST64(0) )
1178       return TypeLong::POS;
1179     // If both numbers are not constants, we know little.
1180     return TypeLong::LONG;
1181   }
1182   // Mod by zero?  Throw exception at runtime!
1183   if( !i2-&gt;get_con() ) return TypeLong::POS;
1184 
1185   // We must be modulo&#39;ing 2 float constants.
1186   // Check for min_jint % &#39;-1&#39;, result is defined to be &#39;0&#39;.
1187   if( i1-&gt;get_con() == min_jlong &amp;&amp; i2-&gt;get_con() == -1 )
1188     return TypeLong::ZERO;
1189 
1190   return TypeLong::make( i1-&gt;get_con() % i2-&gt;get_con() );
1191 }
1192 
1193 
1194 //=============================================================================
1195 //------------------------------Value------------------------------------------
1196 const Type* ModFNode::Value(PhaseGVN* phase) const {
1197   // Either input is TOP ==&gt; the result is TOP
1198   const Type *t1 = phase-&gt;type( in(1) );
1199   const Type *t2 = phase-&gt;type( in(2) );
1200   if( t1 == Type::TOP ) return Type::TOP;
1201   if( t2 == Type::TOP ) return Type::TOP;
1202 
1203   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1204   const Type *bot = bottom_type();
1205   if( (t1 == bot) || (t2 == bot) ||
1206       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1207     return bot;
1208 
1209   // If either number is not a constant, we know nothing.
1210   if ((t1-&gt;base() != Type::FloatCon) || (t2-&gt;base() != Type::FloatCon)) {
1211     return Type::FLOAT;         // note: x%x can be either NaN or 0
1212   }
1213 
1214   float f1 = t1-&gt;getf();
1215   float f2 = t2-&gt;getf();
1216   jint  x1 = jint_cast(f1);     // note:  *(int*)&amp;f1, not just (int)f1
1217   jint  x2 = jint_cast(f2);
1218 
1219   // If either is a NaN, return an input NaN
1220   if (g_isnan(f1))    return t1;
1221   if (g_isnan(f2))    return t2;
1222 
1223   // If an operand is infinity or the divisor is +/- zero, punt.
1224   if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jint)
1225     return Type::FLOAT;
1226 
1227   // We must be modulo&#39;ing 2 float constants.
1228   // Make sure that the sign of the fmod is equal to the sign of the dividend
1229   jint xr = jint_cast(fmod(f1, f2));
1230   if ((x1 ^ xr) &lt; 0) {
1231     xr ^= min_jint;
1232   }
1233 
1234   return TypeF::make(jfloat_cast(xr));
1235 }
1236 
1237 
1238 //=============================================================================
1239 //------------------------------Value------------------------------------------
1240 const Type* ModDNode::Value(PhaseGVN* phase) const {
1241   // Either input is TOP ==&gt; the result is TOP
1242   const Type *t1 = phase-&gt;type( in(1) );
1243   const Type *t2 = phase-&gt;type( in(2) );
1244   if( t1 == Type::TOP ) return Type::TOP;
1245   if( t2 == Type::TOP ) return Type::TOP;
1246 
1247   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
1248   const Type *bot = bottom_type();
1249   if( (t1 == bot) || (t2 == bot) ||
1250       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
1251     return bot;
1252 
1253   // If either number is not a constant, we know nothing.
1254   if ((t1-&gt;base() != Type::DoubleCon) || (t2-&gt;base() != Type::DoubleCon)) {
1255     return Type::DOUBLE;        // note: x%x can be either NaN or 0
1256   }
1257 
1258   double f1 = t1-&gt;getd();
1259   double f2 = t2-&gt;getd();
1260   jlong  x1 = jlong_cast(f1);   // note:  *(long*)&amp;f1, not just (long)f1
1261   jlong  x2 = jlong_cast(f2);
1262 
1263   // If either is a NaN, return an input NaN
1264   if (g_isnan(f1))    return t1;
1265   if (g_isnan(f2))    return t2;
1266 
1267   // If an operand is infinity or the divisor is +/- zero, punt.
1268   if (!g_isfinite(f1) || !g_isfinite(f2) || x2 == 0 || x2 == min_jlong)
1269     return Type::DOUBLE;
1270 
1271   // We must be modulo&#39;ing 2 double constants.
1272   // Make sure that the sign of the fmod is equal to the sign of the dividend
1273   jlong xr = jlong_cast(fmod(f1, f2));
1274   if ((x1 ^ xr) &lt; 0) {
1275     xr ^= min_jlong;
1276   }
1277 
1278   return TypeD::make(jdouble_cast(xr));
1279 }
1280 
1281 //=============================================================================
1282 
1283 DivModNode::DivModNode( Node *c, Node *dividend, Node *divisor ) : MultiNode(3) {
1284   init_req(0, c);
1285   init_req(1, dividend);
1286   init_req(2, divisor);
1287 }
1288 
1289 //------------------------------make------------------------------------------
1290 DivModINode* DivModINode::make(Node* div_or_mod) {
1291   Node* n = div_or_mod;
1292   assert(n-&gt;Opcode() == Op_DivI || n-&gt;Opcode() == Op_ModI,
1293          &quot;only div or mod input pattern accepted&quot;);
1294 
1295   DivModINode* divmod = new DivModINode(n-&gt;in(0), n-&gt;in(1), n-&gt;in(2));
1296   Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);
1297   Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);
1298   return divmod;
1299 }
1300 
1301 //------------------------------make------------------------------------------
1302 DivModLNode* DivModLNode::make(Node* div_or_mod) {
1303   Node* n = div_or_mod;
1304   assert(n-&gt;Opcode() == Op_DivL || n-&gt;Opcode() == Op_ModL,
1305          &quot;only div or mod input pattern accepted&quot;);
1306 
1307   DivModLNode* divmod = new DivModLNode(n-&gt;in(0), n-&gt;in(1), n-&gt;in(2));
1308   Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);
1309   Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);
1310   return divmod;
1311 }
1312 
1313 //------------------------------match------------------------------------------
1314 // return result(s) along with their RegMask info
1315 Node *DivModINode::match( const ProjNode *proj, const Matcher *match ) {
1316   uint ideal_reg = proj-&gt;ideal_reg();
1317   RegMask rm;
1318   if (proj-&gt;_con == div_proj_num) {
1319     rm = match-&gt;divI_proj_mask();
1320   } else {
1321     assert(proj-&gt;_con == mod_proj_num, &quot;must be div or mod projection&quot;);
1322     rm = match-&gt;modI_proj_mask();
1323   }
1324   return new MachProjNode(this, proj-&gt;_con, rm, ideal_reg);
1325 }
1326 
1327 
1328 //------------------------------match------------------------------------------
1329 // return result(s) along with their RegMask info
1330 Node *DivModLNode::match( const ProjNode *proj, const Matcher *match ) {
1331   uint ideal_reg = proj-&gt;ideal_reg();
1332   RegMask rm;
1333   if (proj-&gt;_con == div_proj_num) {
1334     rm = match-&gt;divL_proj_mask();
1335   } else {
1336     assert(proj-&gt;_con == mod_proj_num, &quot;must be div or mod projection&quot;);
1337     rm = match-&gt;modL_proj_mask();
1338   }
1339   return new MachProjNode(this, proj-&gt;_con, rm, ideal_reg);
1340 }
    </pre>
  </body>
</html>
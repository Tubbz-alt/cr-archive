<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="idealGraphPrinter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/intrinsicnode.hpp&quot;
  46 #include &quot;opto/idealKit.hpp&quot;
  47 #include &quot;opto/mathexactnode.hpp&quot;
  48 #include &quot;opto/movenode.hpp&quot;
  49 #include &quot;opto/mulnode.hpp&quot;
  50 #include &quot;opto/narrowptrnode.hpp&quot;
  51 #include &quot;opto/opaquenode.hpp&quot;
  52 #include &quot;opto/parse.hpp&quot;
  53 #include &quot;opto/runtime.hpp&quot;
  54 #include &quot;opto/rootnode.hpp&quot;
  55 #include &quot;opto/subnode.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;prims/unsafe.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  61 </span>
  62 
  63 class LibraryIntrinsic : public InlineCallGenerator {
  64   // Extend the set of intrinsics known to the runtime:
  65  public:
  66  private:
  67   bool             _is_virtual;
  68   bool             _does_virtual_dispatch;
  69   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  70   int8_t           _last_predicate; // Last generated predicate
  71   vmIntrinsics::ID _intrinsic_id;
  72 
  73  public:
  74   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  75     : InlineCallGenerator(m),
  76       _is_virtual(is_virtual),
  77       _does_virtual_dispatch(does_virtual_dispatch),
  78       _predicates_count((int8_t)predicates_count),
  79       _last_predicate((int8_t)-1),
  80       _intrinsic_id(id)
  81   {
</pre>
<hr />
<pre>
3682       // new array won&#39;t trigger an ArrayStoreException. That subtype
3683       // check can be optimized if we know something on the type of
3684       // the input array from type speculation.
3685       if (_gvn.type(klass_node)-&gt;singleton()) {
3686         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3687         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3688 
3689         int test = C-&gt;static_subtype_check(superk, subk);
3690         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3691           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3692           if (t_original-&gt;speculative_type() != NULL) {
3693             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3694           }
3695         }
3696       }
3697 
3698       bool validated = false;
3699       // Reason_class_check rather than Reason_intrinsic because we
3700       // want to intrinsify even if this traps.
3701       if (!too_many_traps(Deoptimization::Reason_class_check)) {
<span class="line-modified">3702         Node* not_subtype_ctrl = gen_subtype_check(load_object_klass(original),</span>
<span class="line-removed">3703                                                    klass_node);</span>
3704 
3705         if (not_subtype_ctrl != top()) {
3706           PreserveJVMState pjvms(this);
3707           set_control(not_subtype_ctrl);
3708           uncommon_trap(Deoptimization::Reason_class_check,
3709                         Deoptimization::Action_make_not_entrant);
3710           assert(stopped(), &quot;Should be stopped&quot;);
3711         }
3712         validated = true;
3713       }
3714 
3715       if (!stopped()) {
3716         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3717 
3718         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3719                                                 load_object_klass(original), klass_node);
3720         if (!is_copyOfRange) {
3721           ac-&gt;set_copyof(validated);
3722         } else {
3723           ac-&gt;set_copyofrange(validated);
</pre>
<hr />
<pre>
4749     // (7) src_offset + length must not exceed length of src.
4750     generate_limit_guard(src_offset, length,
4751                          load_array_length(src),
4752                          slow_region);
4753 
4754     // (8) dest_offset + length must not exceed length of dest.
4755     generate_limit_guard(dest_offset, length,
4756                          load_array_length(dest),
4757                          slow_region);
4758 
4759     // (6) length must not be negative.
4760     // This is also checked in generate_arraycopy() during macro expansion, but
4761     // we also have to check it here for the case where the ArrayCopyNode will
4762     // be eliminated by Escape Analysis.
4763     if (EliminateAllocations) {
4764       generate_negative_guard(length, slow_region);
4765       negative_length_guard_generated = true;
4766     }
4767 
4768     // (9) each element of an oop array must be assignable
<span class="line-removed">4769     Node* src_klass  = load_object_klass(src);</span>
4770     Node* dest_klass = load_object_klass(dest);
<span class="line-modified">4771     Node* not_subtype_ctrl = gen_subtype_check(src_klass, dest_klass);</span>
<span class="line-modified">4772 </span>
<span class="line-modified">4773     if (not_subtype_ctrl != top()) {</span>
<span class="line-modified">4774       PreserveJVMState pjvms(this);</span>
<span class="line-modified">4775       set_control(not_subtype_ctrl);</span>
<span class="line-modified">4776       uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="line-modified">4777                     Deoptimization::Action_make_not_entrant);</span>
<span class="line-modified">4778       assert(stopped(), &quot;Should be stopped&quot;);</span>


4779     }
4780     {
4781       PreserveJVMState pjvms(this);
4782       set_control(_gvn.transform(slow_region));
4783       uncommon_trap(Deoptimization::Reason_intrinsic,
4784                     Deoptimization::Action_make_not_entrant);
4785       assert(stopped(), &quot;Should be stopped&quot;);
4786     }
4787 
4788     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4789     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4790     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4791   }
4792 
4793   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4794 
4795   if (stopped()) {
4796     return true;
4797   }
4798 
</pre>
</td>
<td>
<hr />
<pre>
  41 #include &quot;opto/castnode.hpp&quot;
  42 #include &quot;opto/cfgnode.hpp&quot;
  43 #include &quot;opto/convertnode.hpp&quot;
  44 #include &quot;opto/countbitsnode.hpp&quot;
  45 #include &quot;opto/intrinsicnode.hpp&quot;
  46 #include &quot;opto/idealKit.hpp&quot;
  47 #include &quot;opto/mathexactnode.hpp&quot;
  48 #include &quot;opto/movenode.hpp&quot;
  49 #include &quot;opto/mulnode.hpp&quot;
  50 #include &quot;opto/narrowptrnode.hpp&quot;
  51 #include &quot;opto/opaquenode.hpp&quot;
  52 #include &quot;opto/parse.hpp&quot;
  53 #include &quot;opto/runtime.hpp&quot;
  54 #include &quot;opto/rootnode.hpp&quot;
  55 #include &quot;opto/subnode.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;prims/unsafe.hpp&quot;
  58 #include &quot;runtime/objectMonitor.hpp&quot;
  59 #include &quot;runtime/sharedRuntime.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
<span class="line-modified">  61 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  62 
  63 class LibraryIntrinsic : public InlineCallGenerator {
  64   // Extend the set of intrinsics known to the runtime:
  65  public:
  66  private:
  67   bool             _is_virtual;
  68   bool             _does_virtual_dispatch;
  69   int8_t           _predicates_count;  // Intrinsic is predicated by several conditions
  70   int8_t           _last_predicate; // Last generated predicate
  71   vmIntrinsics::ID _intrinsic_id;
  72 
  73  public:
  74   LibraryIntrinsic(ciMethod* m, bool is_virtual, int predicates_count, bool does_virtual_dispatch, vmIntrinsics::ID id)
  75     : InlineCallGenerator(m),
  76       _is_virtual(is_virtual),
  77       _does_virtual_dispatch(does_virtual_dispatch),
  78       _predicates_count((int8_t)predicates_count),
  79       _last_predicate((int8_t)-1),
  80       _intrinsic_id(id)
  81   {
</pre>
<hr />
<pre>
3682       // new array won&#39;t trigger an ArrayStoreException. That subtype
3683       // check can be optimized if we know something on the type of
3684       // the input array from type speculation.
3685       if (_gvn.type(klass_node)-&gt;singleton()) {
3686         ciKlass* subk   = _gvn.type(load_object_klass(original))-&gt;is_klassptr()-&gt;klass();
3687         ciKlass* superk = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;klass();
3688 
3689         int test = C-&gt;static_subtype_check(superk, subk);
3690         if (test != Compile::SSC_always_true &amp;&amp; test != Compile::SSC_always_false) {
3691           const TypeOopPtr* t_original = _gvn.type(original)-&gt;is_oopptr();
3692           if (t_original-&gt;speculative_type() != NULL) {
3693             original = maybe_cast_profiled_obj(original, t_original-&gt;speculative_type(), true);
3694           }
3695         }
3696       }
3697 
3698       bool validated = false;
3699       // Reason_class_check rather than Reason_intrinsic because we
3700       // want to intrinsify even if this traps.
3701       if (!too_many_traps(Deoptimization::Reason_class_check)) {
<span class="line-modified">3702         Node* not_subtype_ctrl = gen_subtype_check(original, klass_node);</span>

3703 
3704         if (not_subtype_ctrl != top()) {
3705           PreserveJVMState pjvms(this);
3706           set_control(not_subtype_ctrl);
3707           uncommon_trap(Deoptimization::Reason_class_check,
3708                         Deoptimization::Action_make_not_entrant);
3709           assert(stopped(), &quot;Should be stopped&quot;);
3710         }
3711         validated = true;
3712       }
3713 
3714       if (!stopped()) {
3715         newcopy = new_array(klass_node, length, 0);  // no arguments to push
3716 
3717         ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,
3718                                                 load_object_klass(original), klass_node);
3719         if (!is_copyOfRange) {
3720           ac-&gt;set_copyof(validated);
3721         } else {
3722           ac-&gt;set_copyofrange(validated);
</pre>
<hr />
<pre>
4748     // (7) src_offset + length must not exceed length of src.
4749     generate_limit_guard(src_offset, length,
4750                          load_array_length(src),
4751                          slow_region);
4752 
4753     // (8) dest_offset + length must not exceed length of dest.
4754     generate_limit_guard(dest_offset, length,
4755                          load_array_length(dest),
4756                          slow_region);
4757 
4758     // (6) length must not be negative.
4759     // This is also checked in generate_arraycopy() during macro expansion, but
4760     // we also have to check it here for the case where the ArrayCopyNode will
4761     // be eliminated by Escape Analysis.
4762     if (EliminateAllocations) {
4763       generate_negative_guard(length, slow_region);
4764       negative_length_guard_generated = true;
4765     }
4766 
4767     // (9) each element of an oop array must be assignable

4768     Node* dest_klass = load_object_klass(dest);
<span class="line-modified">4769     if (src != dest) {</span>
<span class="line-modified">4770       Node* not_subtype_ctrl = gen_subtype_check(src, dest_klass);</span>
<span class="line-modified">4771 </span>
<span class="line-modified">4772       if (not_subtype_ctrl != top()) {</span>
<span class="line-modified">4773         PreserveJVMState pjvms(this);</span>
<span class="line-modified">4774         set_control(not_subtype_ctrl);</span>
<span class="line-modified">4775         uncommon_trap(Deoptimization::Reason_intrinsic,</span>
<span class="line-modified">4776                       Deoptimization::Action_make_not_entrant);</span>
<span class="line-added">4777         assert(stopped(), &quot;Should be stopped&quot;);</span>
<span class="line-added">4778       }</span>
4779     }
4780     {
4781       PreserveJVMState pjvms(this);
4782       set_control(_gvn.transform(slow_region));
4783       uncommon_trap(Deoptimization::Reason_intrinsic,
4784                     Deoptimization::Action_make_not_entrant);
4785       assert(stopped(), &quot;Should be stopped&quot;);
4786     }
4787 
4788     const TypeKlassPtr* dest_klass_t = _gvn.type(dest_klass)-&gt;is_klassptr();
4789     const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t-&gt;klass());
4790     src = _gvn.transform(new CheckCastPPNode(control(), src, toop));
4791   }
4792 
4793   arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);
4794 
4795   if (stopped()) {
4796     return true;
4797   }
4798 
</pre>
</td>
</tr>
</table>
<center><a href="idealGraphPrinter.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopnode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
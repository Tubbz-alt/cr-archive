<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zAddress.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahNMethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
220   }
221   void do_oop(narrowOop* o) {
222     fatal(&quot;NMethods should not have compressed oops embedded.&quot;);
223   }
224 
225   GrowableArray&lt;oop*&gt;* oops() {
226     return &amp;_oops;
227   }
228 
229   bool has_oops() {
230     return !_oops.is_empty();
231   }
232 };
233 
234 void ShenandoahNMethod::assert_same_oops(bool allow_dead) {
235   ShenandoahNMethodOopDetector detector;
236   nm()-&gt;oops_do(&amp;detector, allow_dead);
237 
238   GrowableArray&lt;oop*&gt;* oops = detector.oops();
239 
<span class="line-modified">240   assert(oops-&gt;length() == oop_count(), &quot;Must match&quot;);</span>
<span class="line-removed">241 </span>
242   for (int index = 0; index &lt; _oops_count; index ++) {
243     assert(oops-&gt;contains(_oops[index]), &quot;Must contain this oop&quot;);
244   }
245 
246   for (oop* p = nm()-&gt;oops_begin(); p &lt; nm()-&gt;oops_end(); p ++) {


247     assert(oops-&gt;contains(p), &quot;Must contain this oop&quot;);
248   }





















249 }
250 
251 void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {
252   ShenandoahNMethodOopDetector detector;
253   nm-&gt;oops_do(&amp;detector, allow_dead);
254   assert(detector.oops()-&gt;length() == 0, &quot;Should not have oops&quot;);
255 }
256 #endif
257 
258 ShenandoahNMethodTable::ShenandoahNMethodTable() :
259   _heap(ShenandoahHeap::heap()),
260   _size(minSize),
261   _index(0),
262   _iteration_in_progress(false) {
263   _array = NEW_C_HEAP_ARRAY(ShenandoahNMethod*, _size, mtGC);
264 }
265 
266 ShenandoahNMethodTable::~ShenandoahNMethodTable() {
267   assert(_array != NULL, &quot;Sanity&quot;);
268   FREE_C_HEAP_ARRAY(ShenandoahNMethod*, _array);
269 }
270 
271 void ShenandoahNMethodTable::register_nmethod(nmethod* nm) {
272   assert(CodeCache_lock-&gt;owned_by_self(), &quot;Must have CodeCache_lock held&quot;);
273   assert(_index &gt;= 0 &amp;&amp; _index &lt;= _size, &quot;Sanity&quot;);
274 
275   ShenandoahNMethod* data = ShenandoahNMethod::gc_data(nm);
276   ShenandoahReentrantLocker data_locker(data != NULL ? data-&gt;lock() : NULL);
277 
278   if (data != NULL) {
279     assert(contain(nm), &quot;Must have been registered&quot;);

280     data-&gt;update();
281   } else {
282     data = ShenandoahNMethod::for_nmethod(nm);
283     if (data == NULL) {
284       assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),
285              &quot;Only possible when concurrent class unloading is off&quot;);
286       return;
287     }
288     ShenandoahNMethod::attach_gc_data(nm, data);
289     ShenandoahLocker locker(&amp;_lock);
290     log_register_nmethod(nm);
291     append(data);
292   }
293   // Disarm new nmethod
294   ShenandoahNMethod::disarm_nmethod(nm);
295 }
296 
297 void ShenandoahNMethodTable::unregister_nmethod(nmethod* nm) {
298   assert_locked_or_safepoint(CodeCache_lock);
299 
</pre>
</td>
<td>
<hr />
<pre>
220   }
221   void do_oop(narrowOop* o) {
222     fatal(&quot;NMethods should not have compressed oops embedded.&quot;);
223   }
224 
225   GrowableArray&lt;oop*&gt;* oops() {
226     return &amp;_oops;
227   }
228 
229   bool has_oops() {
230     return !_oops.is_empty();
231   }
232 };
233 
234 void ShenandoahNMethod::assert_same_oops(bool allow_dead) {
235   ShenandoahNMethodOopDetector detector;
236   nm()-&gt;oops_do(&amp;detector, allow_dead);
237 
238   GrowableArray&lt;oop*&gt;* oops = detector.oops();
239 
<span class="line-modified">240   int count = _oops_count;</span>

241   for (int index = 0; index &lt; _oops_count; index ++) {
242     assert(oops-&gt;contains(_oops[index]), &quot;Must contain this oop&quot;);
243   }
244 
245   for (oop* p = nm()-&gt;oops_begin(); p &lt; nm()-&gt;oops_end(); p ++) {
<span class="line-added">246     if (*p == Universe::non_oop_word()) continue;</span>
<span class="line-added">247     count++;</span>
248     assert(oops-&gt;contains(p), &quot;Must contain this oop&quot;);
249   }
<span class="line-added">250 </span>
<span class="line-added">251   if (oops-&gt;length() &lt; count) {</span>
<span class="line-added">252     stringStream debug_stream;</span>
<span class="line-added">253     debug_stream.print_cr(&quot;detected locs: %d&quot;, oops-&gt;length());</span>
<span class="line-added">254     for (int i = 0; i &lt; oops-&gt;length(); i++) {</span>
<span class="line-added">255       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(oops-&gt;at(i)));</span>
<span class="line-added">256     }</span>
<span class="line-added">257     debug_stream.print_cr(&quot;recorded oops: %d&quot;, _oops_count);</span>
<span class="line-added">258     for (int i = 0; i &lt; _oops_count; i++) {</span>
<span class="line-added">259       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(_oops[i]));</span>
<span class="line-added">260     }</span>
<span class="line-added">261     GrowableArray&lt;oop*&gt; check;</span>
<span class="line-added">262     bool non_immed;</span>
<span class="line-added">263     detect_reloc_oops(nm(), check, non_immed);</span>
<span class="line-added">264     debug_stream.print_cr(&quot;check oops: %d&quot;, check.length());</span>
<span class="line-added">265     for (int i = 0; i &lt; check.length(); i++) {</span>
<span class="line-added">266       debug_stream.print_cr(&quot;-&gt; &quot; PTR_FORMAT, p2i(check.at(i)));</span>
<span class="line-added">267     }</span>
<span class="line-added">268     fatal(&quot;Must match #detected: %d, #recorded: %d, #total: %d, begin: &quot; PTR_FORMAT &quot;, end: &quot; PTR_FORMAT &quot;\n%s&quot;,</span>
<span class="line-added">269           oops-&gt;length(), _oops_count, count, p2i(nm()-&gt;oops_begin()), p2i(nm()-&gt;oops_end()), debug_stream.as_string());</span>
<span class="line-added">270   }</span>
271 }
272 
273 void ShenandoahNMethod::assert_no_oops(nmethod* nm, bool allow_dead) {
274   ShenandoahNMethodOopDetector detector;
275   nm-&gt;oops_do(&amp;detector, allow_dead);
276   assert(detector.oops()-&gt;length() == 0, &quot;Should not have oops&quot;);
277 }
278 #endif
279 
280 ShenandoahNMethodTable::ShenandoahNMethodTable() :
281   _heap(ShenandoahHeap::heap()),
282   _size(minSize),
283   _index(0),
284   _iteration_in_progress(false) {
285   _array = NEW_C_HEAP_ARRAY(ShenandoahNMethod*, _size, mtGC);
286 }
287 
288 ShenandoahNMethodTable::~ShenandoahNMethodTable() {
289   assert(_array != NULL, &quot;Sanity&quot;);
290   FREE_C_HEAP_ARRAY(ShenandoahNMethod*, _array);
291 }
292 
293 void ShenandoahNMethodTable::register_nmethod(nmethod* nm) {
294   assert(CodeCache_lock-&gt;owned_by_self(), &quot;Must have CodeCache_lock held&quot;);
295   assert(_index &gt;= 0 &amp;&amp; _index &lt;= _size, &quot;Sanity&quot;);
296 
297   ShenandoahNMethod* data = ShenandoahNMethod::gc_data(nm);
298   ShenandoahReentrantLocker data_locker(data != NULL ? data-&gt;lock() : NULL);
299 
300   if (data != NULL) {
301     assert(contain(nm), &quot;Must have been registered&quot;);
<span class="line-added">302     assert(nm == data-&gt;nm(), &quot;Must be same nmethod&quot;);</span>
303     data-&gt;update();
304   } else {
305     data = ShenandoahNMethod::for_nmethod(nm);
306     if (data == NULL) {
307       assert(!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading(),
308              &quot;Only possible when concurrent class unloading is off&quot;);
309       return;
310     }
311     ShenandoahNMethod::attach_gc_data(nm, data);
312     ShenandoahLocker locker(&amp;_lock);
313     log_register_nmethod(nm);
314     append(data);
315   }
316   // Disarm new nmethod
317   ShenandoahNMethod::disarm_nmethod(nm);
318 }
319 
320 void ShenandoahNMethodTable::unregister_nmethod(nmethod* nm) {
321   assert_locked_or_safepoint(CodeCache_lock);
322 
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahHeap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../z/zAddress.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/parallel/psParallelCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="parallel_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shared/cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/parallel/psParallelCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1098   }
1099 
1100   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1101   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1102   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1103   if (maximum_compaction || cp == end_cp || interval_ended) {
1104     _maximum_compaction_gc_num = total_invocations();
1105     return sd.region_to_addr(cp);
1106   }
1107 
1108   HeapWord* const new_top = _space_info[id].new_top();
1109   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1110   const size_t space_used = space-&gt;used_in_words();
1111   const size_t space_capacity = space-&gt;capacity_in_words();
1112 
1113   const double cur_density = double(space_live) / space_capacity;
1114   const double deadwood_density =
1115     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1116   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1117 
<span class="line-modified">1118   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1119     tty-&gt;print_cr(&quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1120                   cur_density, deadwood_density, deadwood_goal);</span>
<span class="line-modified">1121     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1122                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1123                   space_live, space_used,</span>
<span class="line-modified">1124                   space_capacity);</span>
<span class="line-modified">1125   }</span>
1126 
1127   // XXX - Use binary search?
1128   HeapWord* dense_prefix = sd.region_to_addr(cp);
1129   const RegionData* full_cp = cp;
1130   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1131   while (cp &lt; end_cp) {
1132     HeapWord* region_destination = cp-&gt;destination();
1133     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
<span class="line-modified">1134     if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1135       tty-&gt;print_cr(&quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;</span>
<span class="line-modified">1136                     &quot;dp=&quot; PTR_FORMAT &quot; &quot; &quot;cdw=&quot; SIZE_FORMAT_W(8),</span>
<span class="line-modified">1137                     sd.region(cp), p2i(region_destination),</span>
<span class="line-modified">1138                     p2i(dense_prefix), cur_deadwood);</span>
<span class="line-modified">1139     }</span>
1140 
1141     if (cur_deadwood &gt;= deadwood_goal) {
1142       // Found the region that has the correct amount of deadwood to the left.
1143       // This typically occurs after crossing a fairly sparse set of regions, so
1144       // iterate backwards over those sparse regions, looking for the region
1145       // that has the lowest density of live objects &#39;to the right.&#39;
1146       size_t space_to_left = sd.region(cp) * region_size;
1147       size_t live_to_left = space_to_left - cur_deadwood;
1148       size_t space_to_right = space_capacity - space_to_left;
1149       size_t live_to_right = space_live - live_to_left;
1150       double density_to_right = double(live_to_right) / space_to_right;
1151       while (cp &gt; full_cp) {
1152         --cp;
1153         const size_t prev_region_live_to_right = live_to_right -
1154           cp-&gt;data_size();
1155         const size_t prev_region_space_to_right = space_to_right + region_size;
1156         double prev_region_density_to_right =
1157           double(prev_region_live_to_right) / prev_region_space_to_right;
1158         if (density_to_right &lt;= prev_region_density_to_right) {
1159           return dense_prefix;
1160         }
<span class="line-modified">1161         if (TraceParallelOldGCDensePrefix &amp;&amp; Verbose) {</span>
<span class="line-modified">1162           tty-&gt;print_cr(&quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;</span>
<span class="line-modified">1163                         &quot;pc_d2r=%10.8f&quot;, sd.region(cp), density_to_right,</span>
<span class="line-modified">1164                         prev_region_density_to_right);</span>
<span class="line-modified">1165         }</span>


1166         dense_prefix -= region_size;
1167         live_to_right = prev_region_live_to_right;
1168         space_to_right = prev_region_space_to_right;
1169         density_to_right = prev_region_density_to_right;
1170       }
1171       return dense_prefix;
1172     }
1173 
1174     dense_prefix += region_size;
1175     ++cp;
1176   }
1177 
1178   return dense_prefix;
1179 }
1180 
1181 #ifndef PRODUCT
1182 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1183                                                  const SpaceId id,
1184                                                  const bool maximum_compaction,
1185                                                  HeapWord* const addr)
1186 {
1187   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1188   RegionData* const cp = summary_data().region(region_idx);
1189   const MutableSpace* const space = _space_info[id].space();
1190   HeapWord* const new_top = _space_info[id].new_top();
1191 
1192   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1193   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1194   const size_t space_cap = space-&gt;capacity_in_words();
1195   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1196   const size_t live_to_right = new_top - cp-&gt;destination();
1197   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1198 
<span class="line-modified">1199   tty-&gt;print_cr(&quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;</span>
<span class="line-modified">1200                 &quot;spl=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1201                 &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;</span>
<span class="line-modified">1202                 &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT</span>
<span class="line-modified">1203                 &quot; ratio=%10.8f&quot;,</span>
<span class="line-modified">1204                 algorithm, p2i(addr), region_idx,</span>
<span class="line-modified">1205                 space_live,</span>
<span class="line-modified">1206                 dead_to_left, dead_to_left_pct,</span>
<span class="line-modified">1207                 dead_to_right, live_to_right,</span>
<span class="line-modified">1208                 double(dead_to_right) / live_to_right);</span>

1209 }
1210 #endif  // #ifndef PRODUCT
1211 
1212 // Return a fraction indicating how much of the generation can be treated as
1213 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1214 // based on the density of live objects in the generation to determine a limit,
1215 // which is then adjusted so the return value is min_percent when the density is
1216 // 1.
1217 //
1218 // The following table shows some return values for a different values of the
1219 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1220 // min_percent is 1.
1221 //
1222 //                          fraction allowed as dead wood
1223 //         -----------------------------------------------------------------
1224 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1225 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1226 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1227 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1228 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
</pre>
<hr />
<pre>
1396   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1397   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1398   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1399     total_invocations() == HeapFirstMaximumCompactionCount;
1400   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1401     _maximum_compaction_gc_num = total_invocations();
1402     return sd.region_to_addr(full_cp);
1403   }
1404 
1405   const size_t space_live = pointer_delta(new_top, bottom);
1406   const size_t space_used = space-&gt;used_in_words();
1407   const size_t space_capacity = space-&gt;capacity_in_words();
1408 
1409   const double density = double(space_live) / double(space_capacity);
1410   const size_t min_percent_free = MarkSweepDeadRatio;
1411   const double limiter = dead_wood_limiter(density, min_percent_free);
1412   const size_t dead_wood_max = space_used - space_live;
1413   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1414                                       dead_wood_max);
1415 
<span class="line-modified">1416   if (TraceParallelOldGCDensePrefix) {</span>
<span class="line-modified">1417     tty-&gt;print_cr(&quot;space_live=&quot; SIZE_FORMAT &quot; &quot; &quot;space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1418                   &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1419                   space_live, space_used,</span>
<span class="line-modified">1420                   space_capacity);</span>
<span class="line-modified">1421     tty-&gt;print_cr(&quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;</span>
<span class="line-modified">1422                   &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1423                   density, min_percent_free, limiter,</span>
<span class="line-modified">1424                   dead_wood_max, dead_wood_limit);</span>
<span class="line-modified">1425   }</span>
1426 
1427   // Locate the region with the desired amount of dead space to the left.
1428   const RegionData* const limit_cp =
1429     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1430 
1431   // Scan from the first region with dead space to the limit region and find the
1432   // one with the best (largest) reclaimed ratio.
1433   double best_ratio = 0.0;
1434   const RegionData* best_cp = full_cp;
1435   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1436     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1437     if (tmp_ratio &gt; best_ratio) {
1438       best_cp = cp;
1439       best_ratio = tmp_ratio;
1440     }
1441   }
1442 
1443   return sd.region_to_addr(best_cp);
1444 }
1445 
</pre>
<hr />
<pre>
1519     _mark_bitmap.mark_obj(obj_beg, obj_len);
1520     _summary_data.add_obj(obj_beg, obj_len);
1521     assert(start_array(id) != NULL, &quot;sanity&quot;);
1522     start_array(id)-&gt;allocate_block(obj_beg);
1523   }
1524 }
1525 
1526 void
1527 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1528 {
1529   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1530   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1531          &quot;should have been reset in summarize_spaces_quick()&quot;);
1532 
1533   const MutableSpace* space = _space_info[id].space();
1534   if (_space_info[id].new_top() != space-&gt;bottom()) {
1535     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1536     _space_info[id].set_dense_prefix(dense_prefix_end);
1537 
1538 #ifndef PRODUCT
<span class="line-modified">1539     if (TraceParallelOldGCDensePrefix) {</span>
1540       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1541                                dense_prefix_end);
1542       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1543       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1544     }
1545 #endif  // #ifndef PRODUCT
1546 
1547     // Recompute the summary data, taking into account the dense prefix.  If
1548     // every last byte will be reclaimed, then the existing summary data which
1549     // compacts everything can be left in place.
1550     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1551       // If dead space crosses the dense prefix boundary, it is (at least
1552       // partially) filled with a dummy object, marked live and added to the
1553       // summary data.  This simplifies the copy/update phase and must be done
1554       // before the final locations of objects are determined, to prevent
1555       // leaving a fragment of dead space that is too small to fill.
1556       fill_dense_prefix_end(id);
1557 
1558       // Compute the destination of each Region, and thus each object.
1559       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
</pre>
<hr />
<pre>
1593       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1594       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1595       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1596       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1597       src_space_id, space_names[src_space_id],
1598       dst_space_id, space_names[dst_space_id],
1599       p2i(src_beg), p2i(src_end),
1600       _summary_data.addr_to_region_idx(src_beg),
1601       _summary_data.addr_to_region_idx(src_end),
1602       p2i(dst_beg), p2i(dst_end),
1603       _summary_data.addr_to_region_idx(dst_beg),
1604       _summary_data.addr_to_region_idx(dst_end));
1605 }
1606 #endif  // #ifndef PRODUCT
1607 
1608 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1609                                       bool maximum_compaction)
1610 {
1611   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1612 
<span class="line-modified">1613 #ifdef  ASSERT</span>
<span class="line-modified">1614   if (TraceParallelOldGCMarkingPhase) {</span>
<span class="line-modified">1615     tty-&gt;print_cr(&quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1616                   &quot;add_obj_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1617                   add_obj_count, add_obj_size * HeapWordSize);</span>
<span class="line-modified">1618     tty-&gt;print_cr(&quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1619                   &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1620                   mark_bitmap_count, mark_bitmap_size * HeapWordSize);</span>
<span class="line-modified">1621   }</span>
<span class="line-modified">1622 #endif  // #ifdef ASSERT</span>
1623 
1624   // Quick summarization of each space into itself, to see how much is live.
1625   summarize_spaces_quick();
1626 
1627   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1628   NOT_PRODUCT(print_region_ranges());
1629   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1630 
1631   // The amount of live data that will end up in old space (assuming it fits).
1632   size_t old_space_total_live = 0;
1633   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1634     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1635                                           _space_info[id].space()-&gt;bottom());
1636   }
1637 
1638   MutableSpace* const old_space = _space_info[old_space_id].space();
1639   const size_t old_capacity = old_space-&gt;capacity_in_words();
1640   if (old_space_total_live &gt; old_capacity) {
1641     // XXX - should also try to expand
1642     maximum_compaction = true;
</pre>
</td>
<td>
<hr />
<pre>
1098   }
1099 
1100   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1101   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1102   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval;
1103   if (maximum_compaction || cp == end_cp || interval_ended) {
1104     _maximum_compaction_gc_num = total_invocations();
1105     return sd.region_to_addr(cp);
1106   }
1107 
1108   HeapWord* const new_top = _space_info[id].new_top();
1109   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1110   const size_t space_used = space-&gt;used_in_words();
1111   const size_t space_capacity = space-&gt;capacity_in_words();
1112 
1113   const double cur_density = double(space_live) / space_capacity;
1114   const double deadwood_density =
1115     (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;
1116   const size_t deadwood_goal = size_t(space_capacity * deadwood_density);
1117 
<span class="line-modified">1118   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1119       &quot;cur_dens=%5.3f dw_dens=%5.3f dw_goal=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1120       cur_density, deadwood_density, deadwood_goal);</span>
<span class="line-modified">1121   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1122       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1123       &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1124       space_live, space_used,</span>
<span class="line-modified">1125       space_capacity);</span>
1126 
1127   // XXX - Use binary search?
1128   HeapWord* dense_prefix = sd.region_to_addr(cp);
1129   const RegionData* full_cp = cp;
1130   const RegionData* const top_cp = sd.addr_to_region_ptr(space-&gt;top() - 1);
1131   while (cp &lt; end_cp) {
1132     HeapWord* region_destination = cp-&gt;destination();
1133     const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);
<span class="line-modified">1134 </span>
<span class="line-modified">1135     log_develop_trace(gc, compaction)(</span>
<span class="line-modified">1136         &quot;c#=&quot; SIZE_FORMAT_W(4) &quot; dst=&quot; PTR_FORMAT &quot; &quot;</span>
<span class="line-modified">1137         &quot;dp=&quot; PTR_FORMAT &quot; cdw=&quot; SIZE_FORMAT_W(8),</span>
<span class="line-modified">1138         sd.region(cp), p2i(region_destination),</span>
<span class="line-modified">1139         p2i(dense_prefix), cur_deadwood);</span>
1140 
1141     if (cur_deadwood &gt;= deadwood_goal) {
1142       // Found the region that has the correct amount of deadwood to the left.
1143       // This typically occurs after crossing a fairly sparse set of regions, so
1144       // iterate backwards over those sparse regions, looking for the region
1145       // that has the lowest density of live objects &#39;to the right.&#39;
1146       size_t space_to_left = sd.region(cp) * region_size;
1147       size_t live_to_left = space_to_left - cur_deadwood;
1148       size_t space_to_right = space_capacity - space_to_left;
1149       size_t live_to_right = space_live - live_to_left;
1150       double density_to_right = double(live_to_right) / space_to_right;
1151       while (cp &gt; full_cp) {
1152         --cp;
1153         const size_t prev_region_live_to_right = live_to_right -
1154           cp-&gt;data_size();
1155         const size_t prev_region_space_to_right = space_to_right + region_size;
1156         double prev_region_density_to_right =
1157           double(prev_region_live_to_right) / prev_region_space_to_right;
1158         if (density_to_right &lt;= prev_region_density_to_right) {
1159           return dense_prefix;
1160         }
<span class="line-modified">1161 </span>
<span class="line-modified">1162         log_develop_trace(gc, compaction)(</span>
<span class="line-modified">1163             &quot;backing up from c=&quot; SIZE_FORMAT_W(4) &quot; d2r=%10.8f &quot;</span>
<span class="line-modified">1164             &quot;pc_d2r=%10.8f&quot;,</span>
<span class="line-modified">1165             sd.region(cp), density_to_right,</span>
<span class="line-added">1166             prev_region_density_to_right);</span>
<span class="line-added">1167 </span>
1168         dense_prefix -= region_size;
1169         live_to_right = prev_region_live_to_right;
1170         space_to_right = prev_region_space_to_right;
1171         density_to_right = prev_region_density_to_right;
1172       }
1173       return dense_prefix;
1174     }
1175 
1176     dense_prefix += region_size;
1177     ++cp;
1178   }
1179 
1180   return dense_prefix;
1181 }
1182 
1183 #ifndef PRODUCT
1184 void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,
1185                                                  const SpaceId id,
1186                                                  const bool maximum_compaction,
1187                                                  HeapWord* const addr)
1188 {
1189   const size_t region_idx = summary_data().addr_to_region_idx(addr);
1190   RegionData* const cp = summary_data().region(region_idx);
1191   const MutableSpace* const space = _space_info[id].space();
1192   HeapWord* const new_top = _space_info[id].new_top();
1193 
1194   const size_t space_live = pointer_delta(new_top, space-&gt;bottom());
1195   const size_t dead_to_left = pointer_delta(addr, cp-&gt;destination());
1196   const size_t space_cap = space-&gt;capacity_in_words();
1197   const double dead_to_left_pct = double(dead_to_left) / space_cap;
1198   const size_t live_to_right = new_top - cp-&gt;destination();
1199   const size_t dead_to_right = space-&gt;top() - addr - live_to_right;
1200 
<span class="line-modified">1201   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1202       &quot;%s=&quot; PTR_FORMAT &quot; dpc=&quot; SIZE_FORMAT_W(5) &quot; &quot;</span>
<span class="line-modified">1203       &quot;spl=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1204       &quot;d2l=&quot; SIZE_FORMAT &quot; d2l%%=%6.4f &quot;</span>
<span class="line-modified">1205       &quot;d2r=&quot; SIZE_FORMAT &quot; l2r=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1206       &quot;ratio=%10.8f&quot;,</span>
<span class="line-modified">1207       algorithm, p2i(addr), region_idx,</span>
<span class="line-modified">1208       space_live,</span>
<span class="line-modified">1209       dead_to_left, dead_to_left_pct,</span>
<span class="line-modified">1210       dead_to_right, live_to_right,</span>
<span class="line-added">1211       double(dead_to_right) / live_to_right);</span>
1212 }
1213 #endif  // #ifndef PRODUCT
1214 
1215 // Return a fraction indicating how much of the generation can be treated as
1216 // &quot;dead wood&quot; (i.e., not reclaimed).  The function uses a normal distribution
1217 // based on the density of live objects in the generation to determine a limit,
1218 // which is then adjusted so the return value is min_percent when the density is
1219 // 1.
1220 //
1221 // The following table shows some return values for a different values of the
1222 // standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and
1223 // min_percent is 1.
1224 //
1225 //                          fraction allowed as dead wood
1226 //         -----------------------------------------------------------------
1227 // density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95
1228 // ------- ---------- ---------- ---------- ---------- ---------- ----------
1229 // 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000
1230 // 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941
1231 // 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272
</pre>
<hr />
<pre>
1399   assert(total_invocations() &gt;= _maximum_compaction_gc_num, &quot;sanity&quot;);
1400   const size_t gcs_since_max = total_invocations() - _maximum_compaction_gc_num;
1401   const bool interval_ended = gcs_since_max &gt; HeapMaximumCompactionInterval ||
1402     total_invocations() == HeapFirstMaximumCompactionCount;
1403   if (maximum_compaction || full_cp == top_cp || interval_ended) {
1404     _maximum_compaction_gc_num = total_invocations();
1405     return sd.region_to_addr(full_cp);
1406   }
1407 
1408   const size_t space_live = pointer_delta(new_top, bottom);
1409   const size_t space_used = space-&gt;used_in_words();
1410   const size_t space_capacity = space-&gt;capacity_in_words();
1411 
1412   const double density = double(space_live) / double(space_capacity);
1413   const size_t min_percent_free = MarkSweepDeadRatio;
1414   const double limiter = dead_wood_limiter(density, min_percent_free);
1415   const size_t dead_wood_max = space_used - space_live;
1416   const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),
1417                                       dead_wood_max);
1418 
<span class="line-modified">1419   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1420       &quot;space_live=&quot; SIZE_FORMAT &quot; space_used=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1421       &quot;space_cap=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1422       space_live, space_used,</span>
<span class="line-modified">1423       space_capacity);</span>
<span class="line-modified">1424   log_develop_debug(gc, compaction)(</span>
<span class="line-modified">1425       &quot;dead_wood_limiter(%6.4f, &quot; SIZE_FORMAT &quot;)=%6.4f &quot;</span>
<span class="line-modified">1426       &quot;dead_wood_max=&quot; SIZE_FORMAT &quot; dead_wood_limit=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1427       density, min_percent_free, limiter,</span>
<span class="line-modified">1428       dead_wood_max, dead_wood_limit);</span>
1429 
1430   // Locate the region with the desired amount of dead space to the left.
1431   const RegionData* const limit_cp =
1432     dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);
1433 
1434   // Scan from the first region with dead space to the limit region and find the
1435   // one with the best (largest) reclaimed ratio.
1436   double best_ratio = 0.0;
1437   const RegionData* best_cp = full_cp;
1438   for (const RegionData* cp = full_cp; cp &lt; limit_cp; ++cp) {
1439     double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);
1440     if (tmp_ratio &gt; best_ratio) {
1441       best_cp = cp;
1442       best_ratio = tmp_ratio;
1443     }
1444   }
1445 
1446   return sd.region_to_addr(best_cp);
1447 }
1448 
</pre>
<hr />
<pre>
1522     _mark_bitmap.mark_obj(obj_beg, obj_len);
1523     _summary_data.add_obj(obj_beg, obj_len);
1524     assert(start_array(id) != NULL, &quot;sanity&quot;);
1525     start_array(id)-&gt;allocate_block(obj_beg);
1526   }
1527 }
1528 
1529 void
1530 PSParallelCompact::summarize_space(SpaceId id, bool maximum_compaction)
1531 {
1532   assert(id &lt; last_space_id, &quot;id out of range&quot;);
1533   assert(_space_info[id].dense_prefix() == _space_info[id].space()-&gt;bottom(),
1534          &quot;should have been reset in summarize_spaces_quick()&quot;);
1535 
1536   const MutableSpace* space = _space_info[id].space();
1537   if (_space_info[id].new_top() != space-&gt;bottom()) {
1538     HeapWord* dense_prefix_end = compute_dense_prefix(id, maximum_compaction);
1539     _space_info[id].set_dense_prefix(dense_prefix_end);
1540 
1541 #ifndef PRODUCT
<span class="line-modified">1542     if (log_is_enabled(Debug, gc, compaction)) {</span>
1543       print_dense_prefix_stats(&quot;ratio&quot;, id, maximum_compaction,
1544                                dense_prefix_end);
1545       HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);
1546       print_dense_prefix_stats(&quot;density&quot;, id, maximum_compaction, addr);
1547     }
1548 #endif  // #ifndef PRODUCT
1549 
1550     // Recompute the summary data, taking into account the dense prefix.  If
1551     // every last byte will be reclaimed, then the existing summary data which
1552     // compacts everything can be left in place.
1553     if (!maximum_compaction &amp;&amp; dense_prefix_end != space-&gt;bottom()) {
1554       // If dead space crosses the dense prefix boundary, it is (at least
1555       // partially) filled with a dummy object, marked live and added to the
1556       // summary data.  This simplifies the copy/update phase and must be done
1557       // before the final locations of objects are determined, to prevent
1558       // leaving a fragment of dead space that is too small to fill.
1559       fill_dense_prefix_end(id);
1560 
1561       // Compute the destination of each Region, and thus each object.
1562       _summary_data.summarize_dense_prefix(space-&gt;bottom(), dense_prefix_end);
</pre>
<hr />
<pre>
1596       &quot;src=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1597       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT &quot; &quot;
1598       &quot;dst=&quot; PTR_FORMAT &quot;-&quot; PTR_FORMAT &quot; &quot;
1599       SIZE_FORMAT &quot;-&quot; SIZE_FORMAT,
1600       src_space_id, space_names[src_space_id],
1601       dst_space_id, space_names[dst_space_id],
1602       p2i(src_beg), p2i(src_end),
1603       _summary_data.addr_to_region_idx(src_beg),
1604       _summary_data.addr_to_region_idx(src_end),
1605       p2i(dst_beg), p2i(dst_end),
1606       _summary_data.addr_to_region_idx(dst_beg),
1607       _summary_data.addr_to_region_idx(dst_end));
1608 }
1609 #endif  // #ifndef PRODUCT
1610 
1611 void PSParallelCompact::summary_phase(ParCompactionManager* cm,
1612                                       bool maximum_compaction)
1613 {
1614   GCTraceTime(Info, gc, phases) tm(&quot;Summary Phase&quot;, &amp;_gc_timer);
1615 
<span class="line-modified">1616   log_develop_debug(gc, marking)(</span>
<span class="line-modified">1617       &quot;add_obj_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1618       &quot;add_obj_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1619       add_obj_count,</span>
<span class="line-modified">1620       add_obj_size * HeapWordSize);</span>
<span class="line-modified">1621   log_develop_debug(gc, marking)(</span>
<span class="line-modified">1622       &quot;mark_bitmap_count=&quot; SIZE_FORMAT &quot; &quot;</span>
<span class="line-modified">1623       &quot;mark_bitmap_bytes=&quot; SIZE_FORMAT,</span>
<span class="line-modified">1624       mark_bitmap_count,</span>
<span class="line-modified">1625       mark_bitmap_size * HeapWordSize);</span>
1626 
1627   // Quick summarization of each space into itself, to see how much is live.
1628   summarize_spaces_quick();
1629 
1630   log_develop_trace(gc, compaction)(&quot;summary phase:  after summarizing each space to self&quot;);
1631   NOT_PRODUCT(print_region_ranges());
1632   NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));
1633 
1634   // The amount of live data that will end up in old space (assuming it fits).
1635   size_t old_space_total_live = 0;
1636   for (unsigned int id = old_space_id; id &lt; last_space_id; ++id) {
1637     old_space_total_live += pointer_delta(_space_info[id].new_top(),
1638                                           _space_info[id].space()-&gt;bottom());
1639   }
1640 
1641   MutableSpace* const old_space = _space_info[old_space_id].space();
1642   const size_t old_capacity = old_space-&gt;capacity_in_words();
1643   if (old_space_total_live &gt; old_capacity) {
1644     // XXX - should also try to expand
1645     maximum_compaction = true;
</pre>
</td>
</tr>
</table>
<center><a href="parallel_globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../shared/cardTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
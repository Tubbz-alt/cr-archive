<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/gc/shared/oopStorage.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  27 #include &quot;gc/shared/oopStorageParState.inline.hpp&quot;
  28 #include &quot;logging/log.hpp&quot;
  29 #include &quot;logging/logStream.hpp&quot;
  30 #include &quot;memory/allocation.inline.hpp&quot;
  31 #include &quot;runtime/atomic.hpp&quot;
  32 #include &quot;runtime/globals.hpp&quot;
  33 #include &quot;runtime/handles.inline.hpp&quot;
  34 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  35 #include &quot;runtime/mutex.hpp&quot;
  36 #include &quot;runtime/mutexLocker.hpp&quot;
  37 #include &quot;runtime/orderAccess.hpp&quot;
  38 #include &quot;runtime/os.hpp&quot;
  39 #include &quot;runtime/safepoint.hpp&quot;
  40 #include &quot;runtime/stubRoutines.hpp&quot;
  41 #include &quot;runtime/thread.hpp&quot;
  42 #include &quot;utilities/align.hpp&quot;
  43 #include &quot;utilities/count_trailing_zeros.hpp&quot;
  44 #include &quot;utilities/debug.hpp&quot;
  45 #include &quot;utilities/globalDefinitions.hpp&quot;
  46 #include &quot;utilities/macros.hpp&quot;
  47 #include &quot;utilities/ostream.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  48 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  49 
  50 OopStorage::AllocationListEntry::AllocationListEntry() : _prev(NULL), _next(NULL) {}
  51 
  52 OopStorage::AllocationListEntry::~AllocationListEntry() {
  53   assert(_prev == NULL, &quot;deleting attached block&quot;);
  54   assert(_next == NULL, &quot;deleting attached block&quot;);
  55 }
  56 
  57 OopStorage::AllocationList::AllocationList() : _head(NULL), _tail(NULL) {}
  58 
  59 OopStorage::AllocationList::~AllocationList() {
  60   // ~OopStorage() empties its lists before destroying them.
  61   assert(_head == NULL, &quot;deleting non-empty block list&quot;);
  62   assert(_tail == NULL, &quot;deleting non-empty block list&quot;);
  63 }
  64 
  65 void OopStorage::AllocationList::push_front(const Block&amp; block) {
  66   const Block* old = _head;
  67   if (old == NULL) {
  68     assert(_tail == NULL, &quot;invariant&quot;);
  69     _head = _tail = &amp;block;
  70   } else {
  71     block.allocation_list_entry()._next = old;
  72     old-&gt;allocation_list_entry()._prev = &amp;block;
  73     _head = &amp;block;
  74   }
  75 }
  76 
  77 void OopStorage::AllocationList::push_back(const Block&amp; block) {
  78   const Block* old = _tail;
  79   if (old == NULL) {
  80     assert(_head == NULL, &quot;invariant&quot;);
  81     _head = _tail = &amp;block;
  82   } else {
  83     old-&gt;allocation_list_entry()._next = &amp;block;
  84     block.allocation_list_entry()._prev = old;
  85     _tail = &amp;block;
  86   }
  87 }
  88 
  89 void OopStorage::AllocationList::unlink(const Block&amp; block) {
  90   const AllocationListEntry&amp; block_entry = block.allocation_list_entry();
  91   const Block* prev_blk = block_entry._prev;
  92   const Block* next_blk = block_entry._next;
  93   block_entry._prev = NULL;
  94   block_entry._next = NULL;
  95   if ((prev_blk == NULL) &amp;&amp; (next_blk == NULL)) {
  96     assert(_head == &amp;block, &quot;invariant&quot;);
  97     assert(_tail == &amp;block, &quot;invariant&quot;);
  98     _head = _tail = NULL;
  99   } else if (prev_blk == NULL) {
 100     assert(_head == &amp;block, &quot;invariant&quot;);
 101     next_blk-&gt;allocation_list_entry()._prev = NULL;
 102     _head = next_blk;
 103   } else if (next_blk == NULL) {
 104     assert(_tail == &amp;block, &quot;invariant&quot;);
 105     prev_blk-&gt;allocation_list_entry()._next = NULL;
 106     _tail = prev_blk;
 107   } else {
 108     next_blk-&gt;allocation_list_entry()._prev = prev_blk;
 109     prev_blk-&gt;allocation_list_entry()._next = next_blk;
 110   }
 111 }
 112 
 113 OopStorage::ActiveArray::ActiveArray(size_t size) :
 114   _size(size),
 115   _block_count(0),
 116   _refcount(0)
 117 {}
 118 
 119 OopStorage::ActiveArray::~ActiveArray() {
 120   assert(_refcount == 0, &quot;precondition&quot;);
 121 }
 122 
 123 OopStorage::ActiveArray* OopStorage::ActiveArray::create(size_t size, AllocFailType alloc_fail) {
 124   size_t size_in_bytes = blocks_offset() + sizeof(Block*) * size;
 125   void* mem = NEW_C_HEAP_ARRAY3(char, size_in_bytes, mtGC, CURRENT_PC, alloc_fail);
 126   if (mem == NULL) return NULL;
 127   return new (mem) ActiveArray(size);
 128 }
 129 
 130 void OopStorage::ActiveArray::destroy(ActiveArray* ba) {
 131   ba-&gt;~ActiveArray();
 132   FREE_C_HEAP_ARRAY(char, ba);
 133 }
 134 
 135 size_t OopStorage::ActiveArray::size() const {
 136   return _size;
 137 }
 138 
 139 size_t OopStorage::ActiveArray::block_count() const {
 140   return _block_count;
 141 }
 142 
 143 size_t OopStorage::ActiveArray::block_count_acquire() const {
 144   return Atomic::load_acquire(&amp;_block_count);
 145 }
 146 
 147 void OopStorage::ActiveArray::increment_refcount() const {
 148   int new_value = Atomic::add(&amp;_refcount, 1);
 149   assert(new_value &gt;= 1, &quot;negative refcount %d&quot;, new_value - 1);
 150 }
 151 
 152 bool OopStorage::ActiveArray::decrement_refcount() const {
 153   int new_value = Atomic::sub(&amp;_refcount, 1);
 154   assert(new_value &gt;= 0, &quot;negative refcount %d&quot;, new_value);
 155   return new_value == 0;
 156 }
 157 
 158 bool OopStorage::ActiveArray::push(Block* block) {
 159   size_t index = _block_count;
 160   if (index &lt; _size) {
 161     block-&gt;set_active_index(index);
 162     *block_ptr(index) = block;
 163     // Use a release_store to ensure all the setup is complete before
 164     // making the block visible.
 165     Atomic::release_store(&amp;_block_count, index + 1);
 166     return true;
 167   } else {
 168     return false;
 169   }
 170 }
 171 
 172 void OopStorage::ActiveArray::remove(Block* block) {
 173   assert(_block_count &gt; 0, &quot;array is empty&quot;);
 174   size_t index = block-&gt;active_index();
 175   assert(*block_ptr(index) == block, &quot;block not present&quot;);
 176   size_t last_index = _block_count - 1;
 177   Block* last_block = *block_ptr(last_index);
 178   last_block-&gt;set_active_index(index);
 179   *block_ptr(index) = last_block;
 180   _block_count = last_index;
 181 }
 182 
 183 void OopStorage::ActiveArray::copy_from(const ActiveArray* from) {
 184   assert(_block_count == 0, &quot;array must be empty&quot;);
 185   size_t count = from-&gt;_block_count;
 186   assert(count &lt;= _size, &quot;precondition&quot;);
 187   Block* const* from_ptr = from-&gt;block_ptr(0);
 188   Block** to_ptr = block_ptr(0);
 189   for (size_t i = 0; i &lt; count; ++i) {
 190     Block* block = *from_ptr++;
 191     assert(block-&gt;active_index() == i, &quot;invariant&quot;);
 192     *to_ptr++ = block;
 193   }
 194   _block_count = count;
 195 }
 196 
 197 // Blocks start with an array of BitsPerWord oop entries.  That array
 198 // is divided into conceptual BytesPerWord sections of BitsPerByte
 199 // entries.  Blocks are allocated aligned on section boundaries, for
 200 // the convenience of mapping from an entry to the containing block;
 201 // see block_for_ptr().  Aligning on section boundary rather than on
 202 // the full _data wastes a lot less space, but makes for a bit more
 203 // work in block_for_ptr().
 204 
 205 const unsigned section_size = BitsPerByte;
 206 const unsigned section_count = BytesPerWord;
 207 const unsigned block_alignment = sizeof(oop) * section_size;
 208 
 209 OopStorage::Block::Block(const OopStorage* owner, void* memory) :
 210   _data(),
 211   _allocated_bitmask(0),
 212   _owner_address(reinterpret_cast&lt;intptr_t&gt;(owner)),
 213   _memory(memory),
 214   _active_index(0),
 215   _allocation_list_entry(),
 216   _deferred_updates_next(NULL),
 217   _release_refcount(0)
 218 {
 219   STATIC_ASSERT(_data_pos == 0);
 220   STATIC_ASSERT(section_size * section_count == ARRAY_SIZE(_data));
 221   assert(offset_of(Block, _data) == _data_pos, &quot;invariant&quot;);
 222   assert(owner != NULL, &quot;NULL owner&quot;);
 223   assert(is_aligned(this, block_alignment), &quot;misaligned block&quot;);
 224 }
 225 
 226 OopStorage::Block::~Block() {
 227   assert(_release_refcount == 0, &quot;deleting block while releasing&quot;);
 228   assert(_deferred_updates_next == NULL, &quot;deleting block with deferred update&quot;);
 229   // Clear fields used by block_for_ptr and entry validation, which
 230   // might help catch bugs.  Volatile to prevent dead-store elimination.
 231   const_cast&lt;uintx volatile&amp;&gt;(_allocated_bitmask) = 0;
 232   const_cast&lt;intptr_t volatile&amp;&gt;(_owner_address) = 0;
 233 }
 234 
 235 size_t OopStorage::Block::allocation_size() {
 236   // _data must be first member, so aligning Block aligns _data.
 237   STATIC_ASSERT(_data_pos == 0);
 238   return sizeof(Block) + block_alignment - sizeof(void*);
 239 }
 240 
 241 size_t OopStorage::Block::allocation_alignment_shift() {
 242   return exact_log2(block_alignment);
 243 }
 244 
 245 inline bool is_full_bitmask(uintx bitmask) { return ~bitmask == 0; }
 246 inline bool is_empty_bitmask(uintx bitmask) { return bitmask == 0; }
 247 
 248 bool OopStorage::Block::is_full() const {
 249   return is_full_bitmask(allocated_bitmask());
 250 }
 251 
 252 bool OopStorage::Block::is_empty() const {
 253   return is_empty_bitmask(allocated_bitmask());
 254 }
 255 
 256 uintx OopStorage::Block::bitmask_for_entry(const oop* ptr) const {
 257   return bitmask_for_index(get_index(ptr));
 258 }
 259 
 260 // An empty block is not yet deletable if either:
 261 // (1) There is a release() operation currently operating on it.
 262 // (2) It is in the deferred updates list.
 263 // For interaction with release(), these must follow the empty check,
 264 // and the order of these checks is important.
 265 bool OopStorage::Block::is_safe_to_delete() const {
 266   assert(is_empty(), &quot;precondition&quot;);
 267   OrderAccess::loadload();
 268   return (Atomic::load_acquire(&amp;_release_refcount) == 0) &amp;&amp;
 269          (Atomic::load_acquire(&amp;_deferred_updates_next) == NULL);
 270 }
 271 
 272 OopStorage::Block* OopStorage::Block::deferred_updates_next() const {
 273   return _deferred_updates_next;
 274 }
 275 
 276 void OopStorage::Block::set_deferred_updates_next(Block* block) {
 277   _deferred_updates_next = block;
 278 }
 279 
 280 bool OopStorage::Block::contains(const oop* ptr) const {
 281   const oop* base = get_pointer(0);
 282   return (base &lt;= ptr) &amp;&amp; (ptr &lt; (base + ARRAY_SIZE(_data)));
 283 }
 284 
 285 size_t OopStorage::Block::active_index() const {
 286   return _active_index;
 287 }
 288 
 289 void OopStorage::Block::set_active_index(size_t index) {
 290   _active_index = index;
 291 }
 292 
 293 size_t OopStorage::Block::active_index_safe(const Block* block) {
 294   STATIC_ASSERT(sizeof(intptr_t) == sizeof(block-&gt;_active_index));
 295   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 296   return SafeFetchN((intptr_t*)&amp;block-&gt;_active_index, 0);
 297 }
 298 
 299 unsigned OopStorage::Block::get_index(const oop* ptr) const {
 300   assert(contains(ptr), PTR_FORMAT &quot; not in block &quot; PTR_FORMAT, p2i(ptr), p2i(this));
 301   return static_cast&lt;unsigned&gt;(ptr - get_pointer(0));
 302 }
 303 
 304 oop* OopStorage::Block::allocate() {
 305   // Use CAS loop because release may change bitmask outside of lock.
 306   uintx allocated = allocated_bitmask();
 307   while (true) {
 308     assert(!is_full_bitmask(allocated), &quot;attempt to allocate from full block&quot;);
 309     unsigned index = count_trailing_zeros(~allocated);
 310     uintx new_value = allocated | bitmask_for_index(index);
 311     uintx fetched = Atomic::cmpxchg(&amp;_allocated_bitmask, allocated, new_value);
 312     if (fetched == allocated) {
 313       return get_pointer(index); // CAS succeeded; return entry for index.
 314     }
 315     allocated = fetched;       // CAS failed; retry with latest value.
 316   }
 317 }
 318 
 319 OopStorage::Block* OopStorage::Block::new_block(const OopStorage* owner) {
 320   // _data must be first member: aligning block =&gt; aligning _data.
 321   STATIC_ASSERT(_data_pos == 0);
 322   size_t size_needed = allocation_size();
 323   void* memory = NEW_C_HEAP_ARRAY_RETURN_NULL(char, size_needed, mtGC);
 324   if (memory == NULL) {
 325     return NULL;
 326   }
 327   void* block_mem = align_up(memory, block_alignment);
 328   assert(sizeof(Block) + pointer_delta(block_mem, memory, 1) &lt;= size_needed,
 329          &quot;allocated insufficient space for aligned block&quot;);
 330   return ::new (block_mem) Block(owner, memory);
 331 }
 332 
 333 void OopStorage::Block::delete_block(const Block&amp; block) {
 334   void* memory = block._memory;
 335   block.Block::~Block();
 336   FREE_C_HEAP_ARRAY(char, memory);
 337 }
 338 
 339 // This can return a false positive if ptr is not contained by some
 340 // block.  For some uses, it is a precondition that ptr is valid,
 341 // e.g. contained in some block in owner&#39;s _active_array.  Other uses
 342 // require additional validation of the result.
 343 OopStorage::Block*
 344 OopStorage::Block::block_for_ptr(const OopStorage* owner, const oop* ptr) {
 345   assert(CanUseSafeFetchN(), &quot;precondition&quot;);
 346   STATIC_ASSERT(_data_pos == 0);
 347   // Const-ness of ptr is not related to const-ness of containing block.
 348   // Blocks are allocated section-aligned, so get the containing section.
 349   oop* section_start = align_down(const_cast&lt;oop*&gt;(ptr), block_alignment);
 350   // Start with a guess that the containing section is the last section,
 351   // so the block starts section_count-1 sections earlier.
 352   oop* section = section_start - (section_size * (section_count - 1));
 353   // Walk up through the potential block start positions, looking for
 354   // the owner in the expected location.  If we&#39;re below the actual block
 355   // start position, the value at the owner position will be some oop
 356   // (possibly NULL), which can never match the owner.
 357   intptr_t owner_addr = reinterpret_cast&lt;intptr_t&gt;(owner);
 358   for (unsigned i = 0; i &lt; section_count; ++i, section += section_size) {
 359     Block* candidate = reinterpret_cast&lt;Block*&gt;(section);
 360     if (SafeFetchN(&amp;candidate-&gt;_owner_address, 0) == owner_addr) {
 361       return candidate;
 362     }
 363   }
 364   return NULL;
 365 }
 366 
 367 //////////////////////////////////////////////////////////////////////////////
 368 // Allocation
 369 //
 370 // Allocation involves the _allocation_list, which contains a subset of the
 371 // blocks owned by a storage object.  This is a doubly-linked list, linked
 372 // through dedicated fields in the blocks.  Full blocks are removed from this
 373 // list, though they are still present in the _active_array.  Empty blocks are
 374 // kept at the end of the _allocation_list, to make it easy for empty block
 375 // deletion to find them.
 376 //
 377 // allocate(), and delete_empty_blocks() lock the
 378 // _allocation_mutex while performing any list and array modifications.
 379 //
 380 // allocate() and release() update a block&#39;s _allocated_bitmask using CAS
 381 // loops.  This prevents loss of updates even though release() performs
 382 // its updates without any locking.
 383 //
 384 // allocate() obtains the entry from the first block in the _allocation_list,
 385 // and updates that block&#39;s _allocated_bitmask to indicate the entry is in
 386 // use.  If this makes the block full (all entries in use), the block is
 387 // removed from the _allocation_list so it won&#39;t be considered by future
 388 // allocations until some entries in it are released.
 389 //
 390 // release() is performed lock-free. (Note: This means it can&#39;t notify the
 391 // service thread of pending cleanup work.  It must be lock-free because
 392 // it is called in all kinds of contexts where even quite low ranked locks
 393 // may be held.)  release() first looks up the block for
 394 // the entry, using address alignment to find the enclosing block (thereby
 395 // avoiding iteration over the _active_array).  Once the block has been
 396 // determined, its _allocated_bitmask needs to be updated, and its position in
 397 // the _allocation_list may need to be updated.  There are two cases:
 398 //
 399 // (a) If the block is neither full nor would become empty with the release of
 400 // the entry, only its _allocated_bitmask needs to be updated.  But if the CAS
 401 // update fails, the applicable case may change for the retry.
 402 //
 403 // (b) Otherwise, the _allocation_list also needs to be modified.  This requires
 404 // locking the _allocation_mutex.  To keep the release() operation lock-free,
 405 // rather than updating the _allocation_list itself, it instead performs a
 406 // lock-free push of the block onto the _deferred_updates list.  Entries on
 407 // that list are processed by allocate() and delete_empty_blocks(), while
 408 // they already hold the necessary lock.  That processing makes the block&#39;s
 409 // list state consistent with its current _allocated_bitmask.  The block is
 410 // added to the _allocation_list if not already present and the bitmask is not
 411 // full.  The block is moved to the end of the _allocation_list if the bitmask
 412 // is empty, for ease of empty block deletion processing.
 413 
 414 oop* OopStorage::allocate() {
 415   MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 416 
 417   Block* block = block_for_allocation();
 418   if (block == NULL) return NULL; // Block allocation failed.
 419   assert(!block-&gt;is_full(), &quot;invariant&quot;);
 420   if (block-&gt;is_empty()) {
 421     // Transitioning from empty to not empty.
 422     log_trace(oopstorage, blocks)(&quot;%s: block not empty &quot; PTR_FORMAT, name(), p2i(block));
 423   }
 424   oop* result = block-&gt;allocate();
 425   assert(result != NULL, &quot;allocation failed&quot;);
 426   assert(!block-&gt;is_empty(), &quot;postcondition&quot;);
 427   Atomic::inc(&amp;_allocation_count); // release updates outside lock.
 428   if (block-&gt;is_full()) {
 429     // Transitioning from not full to full.
 430     // Remove full blocks from consideration by future allocates.
 431     log_trace(oopstorage, blocks)(&quot;%s: block full &quot; PTR_FORMAT, name(), p2i(block));
 432     _allocation_list.unlink(*block);
 433   }
 434   log_trace(oopstorage, ref)(&quot;%s: allocated &quot; PTR_FORMAT, name(), p2i(result));
 435   return result;
 436 }
 437 
 438 bool OopStorage::try_add_block() {
 439   assert_lock_strong(_allocation_mutex);
 440   Block* block;
 441   {
 442     MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 443     block = Block::new_block(this);
 444   }
 445   if (block == NULL) return false;
 446 
 447   // Add new block to the _active_array, growing if needed.
 448   if (!_active_array-&gt;push(block)) {
 449     if (expand_active_array()) {
 450       guarantee(_active_array-&gt;push(block), &quot;push failed after expansion&quot;);
 451     } else {
 452       log_debug(oopstorage, blocks)(&quot;%s: failed active array expand&quot;, name());
 453       Block::delete_block(*block);
 454       return false;
 455     }
 456   }
 457   // Add to end of _allocation_list.  The mutex release allowed other
 458   // threads to add blocks to the _allocation_list.  We prefer to
 459   // allocate from non-empty blocks, to allow empty blocks to be
 460   // deleted.  But we don&#39;t bother notifying about the empty block
 461   // because we&#39;re (probably) about to allocate an entry from it.
 462   _allocation_list.push_back(*block);
 463   log_debug(oopstorage, blocks)(&quot;%s: new block &quot; PTR_FORMAT, name(), p2i(block));
 464   return true;
 465 }
 466 
 467 OopStorage::Block* OopStorage::block_for_allocation() {
 468   assert_lock_strong(_allocation_mutex);
 469   while (true) {
 470     // Use the first block in _allocation_list for the allocation.
 471     Block* block = _allocation_list.head();
 472     if (block != NULL) {
 473       return block;
 474     } else if (reduce_deferred_updates()) {
 475       // Might have added a block to the _allocation_list, so retry.
 476     } else if (try_add_block()) {
 477       // Successfully added a new block to the list, so retry.
 478       assert(_allocation_list.chead() != NULL, &quot;invariant&quot;);
 479     } else if (_allocation_list.chead() != NULL) {
 480       // Trying to add a block failed, but some other thread added to the
 481       // list while we&#39;d dropped the lock over the new block allocation.
 482     } else if (!reduce_deferred_updates()) { // Once more before failure.
 483       // Attempt to add a block failed, no other thread added a block,
 484       // and no deferred updated added a block, then allocation failed.
 485       log_info(oopstorage, blocks)(&quot;%s: failed block allocation&quot;, name());
 486       return NULL;
 487     }
 488   }
 489 }
 490 
 491 // Create a new, larger, active array with the same content as the
 492 // current array, and then replace, relinquishing the old array.
 493 // Return true if the array was successfully expanded, false to
 494 // indicate allocation failure.
 495 bool OopStorage::expand_active_array() {
 496   assert_lock_strong(_allocation_mutex);
 497   ActiveArray* old_array = _active_array;
 498   size_t new_size = 2 * old_array-&gt;size();
 499   log_debug(oopstorage, blocks)(&quot;%s: expand active array &quot; SIZE_FORMAT,
 500                                 name(), new_size);
 501   ActiveArray* new_array = ActiveArray::create(new_size, AllocFailStrategy::RETURN_NULL);
 502   if (new_array == NULL) return false;
 503   new_array-&gt;copy_from(old_array);
 504   replace_active_array(new_array);
 505   relinquish_block_array(old_array);
 506   return true;
 507 }
 508 
 509 // Make new_array the _active_array.  Increments new_array&#39;s refcount
 510 // to account for the new reference.  The assignment is atomic wrto
 511 // obtain_active_array; once this function returns, it is safe for the
 512 // caller to relinquish the old array.
 513 void OopStorage::replace_active_array(ActiveArray* new_array) {
 514   // Caller has the old array that is the current value of _active_array.
 515   // Update new_array refcount to account for the new reference.
 516   new_array-&gt;increment_refcount();
 517   // Install new_array, ensuring its initialization is complete first.
 518   Atomic::release_store(&amp;_active_array, new_array);
 519   // Wait for any readers that could read the old array from _active_array.
 520   // Can&#39;t use GlobalCounter here, because this is called from allocate(),
 521   // which may be called in the scope of a GlobalCounter critical section
 522   // when inserting a StringTable entry.
 523   _protect_active.synchronize();
 524   // All obtain critical sections that could see the old array have
 525   // completed, having incremented the refcount of the old array.  The
 526   // caller can now safely relinquish the old array.
 527 }
 528 
 529 // Atomically (wrto replace_active_array) get the active array and
 530 // increment its refcount.  This provides safe access to the array,
 531 // even if an allocate operation expands and replaces the value of
 532 // _active_array.  The caller must relinquish the array when done
 533 // using it.
 534 OopStorage::ActiveArray* OopStorage::obtain_active_array() const {
 535   SingleWriterSynchronizer::CriticalSection cs(&amp;_protect_active);
 536   ActiveArray* result = Atomic::load_acquire(&amp;_active_array);
 537   result-&gt;increment_refcount();
 538   return result;
 539 }
 540 
 541 // Decrement refcount of array and destroy if refcount is zero.
 542 void OopStorage::relinquish_block_array(ActiveArray* array) const {
 543   if (array-&gt;decrement_refcount()) {
 544     assert(array != _active_array, &quot;invariant&quot;);
 545     ActiveArray::destroy(array);
 546   }
 547 }
 548 
 549 class OopStorage::WithActiveArray : public StackObj {
 550   const OopStorage* _storage;
 551   ActiveArray* _active_array;
 552 
 553 public:
 554   WithActiveArray(const OopStorage* storage) :
 555     _storage(storage),
 556     _active_array(storage-&gt;obtain_active_array())
 557   {}
 558 
 559   ~WithActiveArray() {
 560     _storage-&gt;relinquish_block_array(_active_array);
 561   }
 562 
 563   ActiveArray&amp; active_array() const {
 564     return *_active_array;
 565   }
 566 };
 567 
 568 OopStorage::Block* OopStorage::find_block_or_null(const oop* ptr) const {
 569   assert(ptr != NULL, &quot;precondition&quot;);
 570   return Block::block_for_ptr(this, ptr);
 571 }
 572 
 573 static void log_release_transitions(uintx releasing,
 574                                     uintx old_allocated,
 575                                     const OopStorage* owner,
 576                                     const void* block) {
 577   LogTarget(Trace, oopstorage, blocks) lt;
 578   if (lt.is_enabled()) {
 579     LogStream ls(lt);
 580     if (is_full_bitmask(old_allocated)) {
 581       ls.print_cr(&quot;%s: block not full &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));
 582     }
 583     if (releasing == old_allocated) {
 584       ls.print_cr(&quot;%s: block empty &quot; PTR_FORMAT, owner-&gt;name(), p2i(block));
 585     }
 586   }
 587 }
 588 
 589 void OopStorage::Block::release_entries(uintx releasing, OopStorage* owner) {
 590   assert(releasing != 0, &quot;preconditon&quot;);
 591   // Prevent empty block deletion when transitioning to empty.
 592   Atomic::inc(&amp;_release_refcount);
 593 
 594   // Atomically update allocated bitmask.
 595   uintx old_allocated = _allocated_bitmask;
 596   while (true) {
 597     assert((releasing &amp; ~old_allocated) == 0, &quot;releasing unallocated entries&quot;);
 598     uintx new_value = old_allocated ^ releasing;
 599     uintx fetched = Atomic::cmpxchg(&amp;_allocated_bitmask, old_allocated, new_value);
 600     if (fetched == old_allocated) break; // Successful update.
 601     old_allocated = fetched;             // Retry with updated bitmask.
 602   }
 603 
 604   // Now that the bitmask has been updated, if we have a state transition
 605   // (updated bitmask is empty or old bitmask was full), atomically push
 606   // this block onto the deferred updates list.  Some future call to
 607   // reduce_deferred_updates will make any needed changes related to this
 608   // block and _allocation_list.  This deferral avoids _allocation_list
 609   // updates and the associated locking here.
 610   if ((releasing == old_allocated) || is_full_bitmask(old_allocated)) {
 611     // Log transitions.  Both transitions are possible in a single update.
 612     log_release_transitions(releasing, old_allocated, owner, this);
 613     // Attempt to claim responsibility for adding this block to the deferred
 614     // list, by setting the link to non-NULL by self-looping.  If this fails,
 615     // then someone else has made such a claim and the deferred update has not
 616     // yet been processed and will include our change, so we don&#39;t need to do
 617     // anything further.
 618     if (Atomic::replace_if_null(&amp;_deferred_updates_next, this)) {
 619       // Successfully claimed.  Push, with self-loop for end-of-list.
 620       Block* head = owner-&gt;_deferred_updates;
 621       while (true) {
 622         _deferred_updates_next = (head == NULL) ? this : head;
 623         Block* fetched = Atomic::cmpxchg(&amp;owner-&gt;_deferred_updates, head, this);
 624         if (fetched == head) break; // Successful update.
 625         head = fetched;             // Retry with updated head.
 626       }
 627       // Only request cleanup for to-empty transitions, not for from-full.
 628       // There isn&#39;t any rush to process from-full transitions.  Allocation
 629       // will reduce deferrals before allocating new blocks, so may process
 630       // some.  And the service thread will drain the entire deferred list
 631       // if there are any pending to-empty transitions.
 632       if (releasing == old_allocated) {
 633         owner-&gt;record_needs_cleanup();
 634       }
 635       log_trace(oopstorage, blocks)(&quot;%s: deferred update &quot; PTR_FORMAT,
 636                                     owner-&gt;name(), p2i(this));
 637     }
 638   }
 639   // Release hold on empty block deletion.
 640   Atomic::dec(&amp;_release_refcount);
 641 }
 642 
 643 // Process one available deferred update.  Returns true if one was processed.
 644 bool OopStorage::reduce_deferred_updates() {
 645   assert_lock_strong(_allocation_mutex);
 646   // Atomically pop a block off the list, if any available.
 647   // No ABA issue because this is only called by one thread at a time.
 648   // The atomicity is wrto pushes by release().
 649   Block* block = Atomic::load_acquire(&amp;_deferred_updates);
 650   while (true) {
 651     if (block == NULL) return false;
 652     // Try atomic pop of block from list.
 653     Block* tail = block-&gt;deferred_updates_next();
 654     if (block == tail) tail = NULL; // Handle self-loop end marker.
 655     Block* fetched = Atomic::cmpxchg(&amp;_deferred_updates, block, tail);
 656     if (fetched == block) break; // Update successful.
 657     block = fetched;             // Retry with updated block.
 658   }
 659   block-&gt;set_deferred_updates_next(NULL); // Clear tail after updating head.
 660   // Ensure bitmask read after pop is complete, including clearing tail, for
 661   // ordering with release().  Without this, we may be processing a stale
 662   // bitmask state here while blocking a release() operation from recording
 663   // the deferred update needed for its bitmask change.
 664   OrderAccess::fence();
 665   // Process popped block.
 666   uintx allocated = block-&gt;allocated_bitmask();
 667 
 668   // Make membership in list consistent with bitmask state.
 669   if ((_allocation_list.ctail() != NULL) &amp;&amp;
 670       ((_allocation_list.ctail() == block) ||
 671        (_allocation_list.next(*block) != NULL))) {
 672     // Block is in the _allocation_list.
 673     assert(!is_full_bitmask(allocated), &quot;invariant&quot;);
 674   } else if (!is_full_bitmask(allocated)) {
 675     // Block is not in the _allocation_list, but now should be.
 676     _allocation_list.push_front(*block);
 677   } // Else block is full and not in list, which is correct.
 678 
 679   // Move empty block to end of list, for possible deletion.
 680   if (is_empty_bitmask(allocated)) {
 681     _allocation_list.unlink(*block);
 682     _allocation_list.push_back(*block);
 683   }
 684 
 685   log_trace(oopstorage, blocks)(&quot;%s: processed deferred update &quot; PTR_FORMAT,
 686                                 name(), p2i(block));
 687   return true;              // Processed one pending update.
 688 }
 689 
 690 inline void check_release_entry(const oop* entry) {
 691   assert(entry != NULL, &quot;Releasing NULL&quot;);
 692   assert(*entry == NULL, &quot;Releasing uncleared entry: &quot; PTR_FORMAT, p2i(entry));
 693 }
 694 
 695 void OopStorage::release(const oop* ptr) {
 696   check_release_entry(ptr);
 697   Block* block = find_block_or_null(ptr);
 698   assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptr));
 699   log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptr));
 700   block-&gt;release_entries(block-&gt;bitmask_for_entry(ptr), this);
 701   Atomic::dec(&amp;_allocation_count);
 702 }
 703 
 704 void OopStorage::release(const oop* const* ptrs, size_t size) {
 705   size_t i = 0;
 706   while (i &lt; size) {
 707     check_release_entry(ptrs[i]);
 708     Block* block = find_block_or_null(ptrs[i]);
 709     assert(block != NULL, &quot;%s: invalid release &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 710     log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(ptrs[i]));
 711     size_t count = 0;
 712     uintx releasing = 0;
 713     for ( ; i &lt; size; ++i) {
 714       const oop* entry = ptrs[i];
 715       check_release_entry(entry);
 716       // If entry not in block, finish block and resume outer loop with entry.
 717       if (!block-&gt;contains(entry)) break;
 718       // Add entry to releasing bitmap.
 719       log_trace(oopstorage, ref)(&quot;%s: released &quot; PTR_FORMAT, name(), p2i(entry));
 720       uintx entry_bitmask = block-&gt;bitmask_for_entry(entry);
 721       assert((releasing &amp; entry_bitmask) == 0,
 722              &quot;Duplicate entry: &quot; PTR_FORMAT, p2i(entry));
 723       releasing |= entry_bitmask;
 724       ++count;
 725     }
 726     // Release the contiguous entries that are in block.
 727     block-&gt;release_entries(releasing, this);
 728     Atomic::sub(&amp;_allocation_count, count);
 729   }
 730 }
 731 
 732 const size_t initial_active_array_size = 8;
 733 
 734 OopStorage::OopStorage(const char* name,
 735                        Mutex* allocation_mutex,
 736                        Mutex* active_mutex) :
 737   _name(os::strdup(name)),
 738   _active_array(ActiveArray::create(initial_active_array_size)),
 739   _allocation_list(),
 740   _deferred_updates(NULL),
 741   _allocation_mutex(allocation_mutex),
 742   _active_mutex(active_mutex),
 743   _allocation_count(0),
 744   _concurrent_iteration_count(0),
 745   _needs_cleanup(false)
 746 {
 747   _active_array-&gt;increment_refcount();
 748   assert(_active_mutex-&gt;rank() &lt; _allocation_mutex-&gt;rank(),
 749          &quot;%s: active_mutex must have lower rank than allocation_mutex&quot;, _name);
 750   assert(Service_lock-&gt;rank() &lt; _active_mutex-&gt;rank(),
 751          &quot;%s: active_mutex must have higher rank than Service_lock&quot;, _name);
 752   assert(_active_mutex-&gt;_safepoint_check_required == Mutex::_safepoint_check_never,
 753          &quot;%s: active mutex requires never safepoint check&quot;, _name);
 754   assert(_allocation_mutex-&gt;_safepoint_check_required == Mutex::_safepoint_check_never,
 755          &quot;%s: allocation mutex requires never safepoint check&quot;, _name);
 756 }
 757 
 758 void OopStorage::delete_empty_block(const Block&amp; block) {
 759   assert(block.is_empty(), &quot;discarding non-empty block&quot;);
 760   log_debug(oopstorage, blocks)(&quot;%s: delete empty block &quot; PTR_FORMAT, name(), p2i(&amp;block));
 761   Block::delete_block(block);
 762 }
 763 
 764 OopStorage::~OopStorage() {
 765   Block* block;
 766   while ((block = _deferred_updates) != NULL) {
 767     _deferred_updates = block-&gt;deferred_updates_next();
 768     block-&gt;set_deferred_updates_next(NULL);
 769   }
 770   while ((block = _allocation_list.head()) != NULL) {
 771     _allocation_list.unlink(*block);
 772   }
 773   bool unreferenced = _active_array-&gt;decrement_refcount();
 774   assert(unreferenced, &quot;deleting storage while _active_array is referenced&quot;);
 775   for (size_t i = _active_array-&gt;block_count(); 0 &lt; i; ) {
 776     block = _active_array-&gt;at(--i);
 777     Block::delete_block(*block);
 778   }
 779   ActiveArray::destroy(_active_array);
 780   os::free(const_cast&lt;char*&gt;(_name));
 781 }
 782 
 783 // Managing service thread notifications.
 784 //
 785 // We don&#39;t want cleanup work to linger indefinitely, but we also don&#39;t want
 786 // to run the service thread too often.  We&#39;re also very limited in what we
 787 // can do in a release operation, where cleanup work is created.
 788 //
 789 // When a release operation changes a block&#39;s state to empty, it records the
 790 // need for cleanup in both the associated storage object and in the global
 791 // request state.  A safepoint cleanup task notifies the service thread when
 792 // there may be cleanup work for any storage object, based on the global
 793 // request state.  But that notification is deferred if the service thread
 794 // has run recently, and we also avoid duplicate notifications.  The service
 795 // thread updates the timestamp and resets the state flags on every iteration.
 796 
 797 // Global cleanup request state.
 798 static volatile bool needs_cleanup_requested = false;
 799 
 800 // Flag for avoiding duplicate notifications.
 801 static bool needs_cleanup_triggered = false;
 802 
 803 // Time after which a notification can be made.
 804 static jlong cleanup_trigger_permit_time = 0;
 805 
 806 // Minimum time since last service thread check before notification is
 807 // permitted.  The value of 500ms was an arbitrary choice; frequent, but not
 808 // too frequent.
 809 const jlong cleanup_trigger_defer_period = 500 * NANOSECS_PER_MILLISEC;
 810 
 811 void OopStorage::trigger_cleanup_if_needed() {
 812   MonitorLocker ml(Service_lock, Monitor::_no_safepoint_check_flag);
 813   if (Atomic::load(&amp;needs_cleanup_requested) &amp;&amp;
 814       !needs_cleanup_triggered &amp;&amp;
 815       (os::javaTimeNanos() &gt; cleanup_trigger_permit_time)) {
 816     needs_cleanup_triggered = true;
 817     ml.notify_all();
 818   }
 819 }
 820 
 821 bool OopStorage::has_cleanup_work_and_reset() {
 822   assert_lock_strong(Service_lock);
 823   cleanup_trigger_permit_time =
 824     os::javaTimeNanos() + cleanup_trigger_defer_period;
 825   needs_cleanup_triggered = false;
 826   // Set the request flag false and return its old value.
 827   // Needs to be atomic to avoid dropping a concurrent request.
 828   // Can&#39;t use Atomic::xchg, which may not support bool.
 829   return Atomic::cmpxchg(&amp;needs_cleanup_requested, true, false);
 830 }
 831 
 832 // Record that cleanup is needed, without notifying the Service thread.
 833 // Used by release(), where we can&#39;t lock even Service_lock.
 834 void OopStorage::record_needs_cleanup() {
 835   // Set local flag first, else service thread could wake up and miss
 836   // the request.  This order may instead (rarely) unnecessarily notify.
 837   Atomic::release_store(&amp;_needs_cleanup, true);
 838   Atomic::release_store_fence(&amp;needs_cleanup_requested, true);
 839 }
 840 
 841 bool OopStorage::delete_empty_blocks() {
 842   // Service thread might have oopstorage work, but not for this object.
 843   // Check for deferred updates even though that&#39;s not a service thread
 844   // trigger; since we&#39;re here, we might as well process them.
 845   if (!Atomic::load_acquire(&amp;_needs_cleanup) &amp;&amp;
 846       (Atomic::load_acquire(&amp;_deferred_updates) == NULL)) {
 847     return false;
 848   }
 849 
 850   MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 851 
 852   // Clear the request before processing.
 853   Atomic::release_store_fence(&amp;_needs_cleanup, false);
 854 
 855   // Other threads could be adding to the empty block count or the
 856   // deferred update list while we&#39;re working.  Set an upper bound on
 857   // how many updates we&#39;ll process and blocks we&#39;ll try to release,
 858   // so other threads can&#39;t cause an unbounded stay in this function.
 859   // We add a bit of slop because the reduce_deferred_updates clause
 860   // can cause blocks to be double counted.  If there are few blocks
 861   // and many of them are deferred and empty, we might hit the limit
 862   // and spin the caller without doing very much work.  Otherwise,
 863   // we don&#39;t normally hit the limit anyway, instead running out of
 864   // work to do.
 865   size_t limit = block_count() + 10;
 866 
 867   for (size_t i = 0; i &lt; limit; ++i) {
 868     // Process deferred updates, which might make empty blocks available.
 869     // Continue checking once deletion starts, since additional updates
 870     // might become available while we&#39;re working.
 871     if (reduce_deferred_updates()) {
 872       // Be safepoint-polite while looping.
 873       MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 874       ThreadBlockInVM tbiv(JavaThread::current());
 875     } else {
 876       Block* block = _allocation_list.tail();
 877       if ((block == NULL) || !block-&gt;is_empty()) {
 878         return false;
 879       } else if (!block-&gt;is_safe_to_delete()) {
 880         // Look for other work while waiting for block to be deletable.
 881         break;
 882       }
 883 
 884       // Try to delete the block.  First, try to remove from _active_array.
 885       {
 886         MutexLocker aml(_active_mutex, Mutex::_no_safepoint_check_flag);
 887         // Don&#39;t interfere with an active concurrent iteration.
 888         // Instead, give up immediately.  There is more work to do,
 889         // but don&#39;t re-notify, to avoid useless spinning of the
 890         // service thread.  Instead, iteration completion notifies.
 891         if (_concurrent_iteration_count &gt; 0) return true;
 892         _active_array-&gt;remove(block);
 893       }
 894       // Remove block from _allocation_list and delete it.
 895       _allocation_list.unlink(*block);
 896       // Be safepoint-polite while deleting and looping.
 897       MutexUnlocker ul(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 898       delete_empty_block(*block);
 899       ThreadBlockInVM tbiv(JavaThread::current());
 900     }
 901   }
 902   // Exceeded work limit or can&#39;t delete last block.  This will
 903   // cause the service thread to loop, giving other subtasks an
 904   // opportunity to run too.  There&#39;s no need for a notification,
 905   // because we are part of the service thread (unless gtesting).
 906   record_needs_cleanup();
 907   return true;
 908 }
 909 
 910 OopStorage::EntryStatus OopStorage::allocation_status(const oop* ptr) const {
 911   const Block* block = find_block_or_null(ptr);
 912   if (block != NULL) {
 913     // Prevent block deletion and _active_array modification.
 914     MutexLocker ml(_allocation_mutex, Mutex::_no_safepoint_check_flag);
 915     // Block could be a false positive, so get index carefully.
 916     size_t index = Block::active_index_safe(block);
 917     if ((index &lt; _active_array-&gt;block_count()) &amp;&amp;
 918         (block == _active_array-&gt;at(index)) &amp;&amp;
 919         block-&gt;contains(ptr)) {
 920       if ((block-&gt;allocated_bitmask() &amp; block-&gt;bitmask_for_entry(ptr)) != 0) {
 921         return ALLOCATED_ENTRY;
 922       } else {
 923         return UNALLOCATED_ENTRY;
 924       }
 925     }
 926   }
 927   return INVALID_ENTRY;
 928 }
 929 
 930 size_t OopStorage::allocation_count() const {
 931   return _allocation_count;
 932 }
 933 
 934 size_t OopStorage::block_count() const {
 935   WithActiveArray wab(this);
 936   // Count access is racy, but don&#39;t care.
 937   return wab.active_array().block_count();
 938 }
 939 
 940 size_t OopStorage::total_memory_usage() const {
 941   size_t total_size = sizeof(OopStorage);
 942   total_size += strlen(name()) + 1;
 943   total_size += sizeof(ActiveArray);
 944   WithActiveArray wab(this);
 945   const ActiveArray&amp; blocks = wab.active_array();
 946   // Count access is racy, but don&#39;t care.
 947   total_size += blocks.block_count() * Block::allocation_size();
 948   total_size += blocks.size() * sizeof(Block*);
 949   return total_size;
 950 }
 951 
 952 // Parallel iteration support
 953 
 954 uint OopStorage::BasicParState::default_estimated_thread_count(bool concurrent) {
 955   uint configured = concurrent ? ConcGCThreads : ParallelGCThreads;
 956   return MAX2(1u, configured);  // Never estimate zero threads.
 957 }
 958 
 959 OopStorage::BasicParState::BasicParState(const OopStorage* storage,
 960                                          uint estimated_thread_count,
 961                                          bool concurrent) :
 962   _storage(storage),
 963   _active_array(_storage-&gt;obtain_active_array()),
 964   _block_count(0),              // initialized properly below
 965   _next_block(0),
 966   _estimated_thread_count(estimated_thread_count),
 967   _concurrent(concurrent)
 968 {
 969   assert(estimated_thread_count &gt; 0, &quot;estimated thread count must be positive&quot;);
 970   update_concurrent_iteration_count(1);
 971   // Get the block count *after* iteration state updated, so concurrent
 972   // empty block deletion is suppressed and can&#39;t reduce the count.  But
 973   // ensure the count we use was written after the block with that count
 974   // was fully initialized; see ActiveArray::push.
 975   _block_count = _active_array-&gt;block_count_acquire();
 976 }
 977 
 978 OopStorage::BasicParState::~BasicParState() {
 979   _storage-&gt;relinquish_block_array(_active_array);
 980   update_concurrent_iteration_count(-1);
 981   if (_concurrent) {
 982     // We may have deferred some cleanup work.
 983     const_cast&lt;OopStorage*&gt;(_storage)-&gt;record_needs_cleanup();
 984   }
 985 }
 986 
 987 void OopStorage::BasicParState::update_concurrent_iteration_count(int value) {
 988   if (_concurrent) {
 989     MutexLocker ml(_storage-&gt;_active_mutex, Mutex::_no_safepoint_check_flag);
 990     _storage-&gt;_concurrent_iteration_count += value;
 991     assert(_storage-&gt;_concurrent_iteration_count &gt;= 0, &quot;invariant&quot;);
 992   }
 993 }
 994 
 995 bool OopStorage::BasicParState::claim_next_segment(IterationData* data) {
 996   data-&gt;_processed += data-&gt;_segment_end - data-&gt;_segment_start;
 997   size_t start = Atomic::load_acquire(&amp;_next_block);
 998   if (start &gt;= _block_count) {
 999     return finish_iteration(data); // No more blocks available.
1000   }
1001   // Try to claim several at a time, but not *too* many.  We want to
1002   // avoid deciding there are many available and selecting a large
1003   // quantity, get delayed, and then end up claiming most or all of
1004   // the remaining largish amount of work, leaving nothing for other
1005   // threads to do.  But too small a step can lead to contention
1006   // over _next_block, esp. when the work per block is small.
1007   size_t max_step = 10;
1008   size_t remaining = _block_count - start;
1009   size_t step = MIN2(max_step, 1 + (remaining / _estimated_thread_count));
1010   // Atomic::add with possible overshoot.  This can perform better
1011   // than a CAS loop on some platforms when there is contention.
1012   // We can cope with the uncertainty by recomputing start/end from
1013   // the result of the add, and dealing with potential overshoot.
1014   size_t end = Atomic::add(&amp;_next_block, step);
1015   // _next_block may have changed, so recompute start from result of add.
1016   start = end - step;
1017   // _next_block may have changed so much that end has overshot.
1018   end = MIN2(end, _block_count);
1019   // _next_block may have changed so much that even start has overshot.
1020   if (start &lt; _block_count) {
1021     // Record claimed segment for iteration.
1022     data-&gt;_segment_start = start;
1023     data-&gt;_segment_end = end;
1024     return true;                // Success.
1025   } else {
1026     // No more blocks to claim.
1027     return finish_iteration(data);
1028   }
1029 }
1030 
1031 bool OopStorage::BasicParState::finish_iteration(const IterationData* data) const {
1032   log_info(oopstorage, blocks, stats)
1033           (&quot;Parallel iteration on %s: blocks = &quot; SIZE_FORMAT
1034            &quot;, processed = &quot; SIZE_FORMAT &quot; (%2.f%%)&quot;,
1035            _storage-&gt;name(), _block_count, data-&gt;_processed,
1036            percent_of(data-&gt;_processed, _block_count));
1037   return false;
1038 }
1039 
1040 const char* OopStorage::name() const { return _name; }
1041 
1042 #ifndef PRODUCT
1043 
1044 void OopStorage::print_on(outputStream* st) const {
1045   size_t allocations = _allocation_count;
1046   size_t blocks = _active_array-&gt;block_count();
1047 
1048   double data_size = section_size * section_count;
1049   double alloc_percentage = percent_of((double)allocations, blocks * data_size);
1050 
1051   st-&gt;print(&quot;%s: &quot; SIZE_FORMAT &quot; entries in &quot; SIZE_FORMAT &quot; blocks (%.F%%), &quot; SIZE_FORMAT &quot; bytes&quot;,
1052             name(), allocations, blocks, alloc_percentage, total_memory_usage());
1053   if (_concurrent_iteration_count &gt; 0) {
1054     st-&gt;print(&quot;, concurrent iteration active&quot;);
1055   }
1056 }
1057 
1058 #endif // !PRODUCT
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
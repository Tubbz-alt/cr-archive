<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/filemap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arena.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/filemap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1730   }
1731 }
1732 
1733 void FileMapInfo::map_heap_regions() {
1734   if (has_heap_regions()) {
1735     map_heap_regions_impl();
1736   }
1737 
1738   if (!HeapShared::closed_archive_heap_region_mapped()) {
1739     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1740            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1741   }
1742 
1743   if (!HeapShared::open_archive_heap_region_mapped()) {
1744     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1745   }
1746 }
1747 
1748 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1749                                 int max, int* num, bool is_open_archive) {
<span class="line-modified">1750   MemRegion * regions = new MemRegion[max];</span>








1751   FileMapRegion* si;
1752   int region_num = 0;
1753 
1754   for (int i = first;
1755            i &lt; first + max; i++) {
1756     si = space_at(i);
1757     size_t size = si-&gt;used();
1758     if (size &gt; 0) {
1759       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1760       regions[region_num] = MemRegion(start, size / HeapWordSize);
1761       region_num ++;
1762       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1763                     i, p2i(start), size);
1764     }
1765   }
1766 
1767   if (region_num == 0) {
1768     return false; // no archived java heap data
1769   }
1770 
</pre>
<hr />
<pre>
1790     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),
1791                                 addr, regions[i].byte_size(), si-&gt;read_only(),
1792                                 si-&gt;allow_exec());
1793     if (base == NULL || base != addr) {
1794       // dealloc the regions from java heap
1795       dealloc_archive_heap_regions(regions, region_num);
1796       log_info(cds)(&quot;UseSharedSpaces: Unable to map at required address in java heap. &quot;
1797                     INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot; bytes&quot;,
1798                     p2i(addr), regions[i].byte_size());
1799       return false;
1800     }
1801 
1802     if (VerifySharedSpaces &amp;&amp; !region_crc_check(addr, regions[i].byte_size(), si-&gt;crc())) {
1803       // dealloc the regions from java heap
1804       dealloc_archive_heap_regions(regions, region_num);
1805       log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);
1806       return false;
1807     }
1808   }
1809 

1810   // the shared heap data is mapped successfully
1811   *heap_mem = regions;
1812   *num = region_num;
1813   return true;
1814 }
1815 
1816 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1817   if (!_heap_pointers_need_patching) {
1818     return;
1819   }
1820 
1821   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1822                                         num_closed_archive_heap_ranges,
1823                                         MetaspaceShared::first_closed_archive_heap_region);
1824 
1825   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1826                                         num_open_archive_heap_ranges,
1827                                         MetaspaceShared::first_open_archive_heap_region);
1828 }
1829 
</pre>
</td>
<td>
<hr />
<pre>
1730   }
1731 }
1732 
1733 void FileMapInfo::map_heap_regions() {
1734   if (has_heap_regions()) {
1735     map_heap_regions_impl();
1736   }
1737 
1738   if (!HeapShared::closed_archive_heap_region_mapped()) {
1739     assert(closed_archive_heap_ranges == NULL &amp;&amp;
1740            num_closed_archive_heap_ranges == 0, &quot;sanity&quot;);
1741   }
1742 
1743   if (!HeapShared::open_archive_heap_region_mapped()) {
1744     assert(open_archive_heap_ranges == NULL &amp;&amp; num_open_archive_heap_ranges == 0, &quot;sanity&quot;);
1745   }
1746 }
1747 
1748 bool FileMapInfo::map_heap_data(MemRegion **heap_mem, int first,
1749                                 int max, int* num, bool is_open_archive) {
<span class="line-modified">1750   MemRegion* regions = MemRegion::create_array(max, mtInternal);</span>
<span class="line-added">1751 </span>
<span class="line-added">1752   struct Cleanup {</span>
<span class="line-added">1753     MemRegion* _regions;</span>
<span class="line-added">1754     bool _aborted;</span>
<span class="line-added">1755     Cleanup(MemRegion* regions) : _regions(regions), _aborted(true) { }</span>
<span class="line-added">1756     ~Cleanup() { if (_aborted) { FREE_C_HEAP_ARRAY(MemRegion, _regions); } }</span>
<span class="line-added">1757   } cleanup(regions);</span>
<span class="line-added">1758 </span>
1759   FileMapRegion* si;
1760   int region_num = 0;
1761 
1762   for (int i = first;
1763            i &lt; first + max; i++) {
1764     si = space_at(i);
1765     size_t size = si-&gt;used();
1766     if (size &gt; 0) {
1767       HeapWord* start = (HeapWord*)start_address_as_decoded_from_archive(si);
1768       regions[region_num] = MemRegion(start, size / HeapWordSize);
1769       region_num ++;
1770       log_info(cds)(&quot;Trying to map heap data: region[%d] at &quot; INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT_W(8) &quot; bytes&quot;,
1771                     i, p2i(start), size);
1772     }
1773   }
1774 
1775   if (region_num == 0) {
1776     return false; // no archived java heap data
1777   }
1778 
</pre>
<hr />
<pre>
1798     char* base = os::map_memory(_fd, _full_path, si-&gt;file_offset(),
1799                                 addr, regions[i].byte_size(), si-&gt;read_only(),
1800                                 si-&gt;allow_exec());
1801     if (base == NULL || base != addr) {
1802       // dealloc the regions from java heap
1803       dealloc_archive_heap_regions(regions, region_num);
1804       log_info(cds)(&quot;UseSharedSpaces: Unable to map at required address in java heap. &quot;
1805                     INTPTR_FORMAT &quot;, size = &quot; SIZE_FORMAT &quot; bytes&quot;,
1806                     p2i(addr), regions[i].byte_size());
1807       return false;
1808     }
1809 
1810     if (VerifySharedSpaces &amp;&amp; !region_crc_check(addr, regions[i].byte_size(), si-&gt;crc())) {
1811       // dealloc the regions from java heap
1812       dealloc_archive_heap_regions(regions, region_num);
1813       log_info(cds)(&quot;UseSharedSpaces: mapped heap regions are corrupt&quot;);
1814       return false;
1815     }
1816   }
1817 
<span class="line-added">1818   cleanup._aborted = false;</span>
1819   // the shared heap data is mapped successfully
1820   *heap_mem = regions;
1821   *num = region_num;
1822   return true;
1823 }
1824 
1825 void FileMapInfo::patch_archived_heap_embedded_pointers() {
1826   if (!_heap_pointers_need_patching) {
1827     return;
1828   }
1829 
1830   patch_archived_heap_embedded_pointers(closed_archive_heap_ranges,
1831                                         num_closed_archive_heap_ranges,
1832                                         MetaspaceShared::first_closed_archive_heap_region);
1833 
1834   patch_archived_heap_embedded_pointers(open_archive_heap_ranges,
1835                                         num_open_archive_heap_ranges,
1836                                         MetaspaceShared::first_open_archive_heap_region);
1837 }
1838 
</pre>
</td>
</tr>
</table>
<center><a href="arena.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/c1_LIRAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;c1/c1_CodeStubs.hpp&quot;
  30 #include &quot;c1/c1_Compilation.hpp&quot;
  31 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  32 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  33 #include &quot;c1/c1_Runtime1.hpp&quot;
  34 #include &quot;c1/c1_ValueStack.hpp&quot;
  35 #include &quot;ci/ciArrayKlass.hpp&quot;
  36 #include &quot;ci/ciInstance.hpp&quot;
  37 #include &quot;code/compiledIC.hpp&quot;
  38 #include &quot;gc/shared/collectedHeap.hpp&quot;
  39 #include &quot;nativeInst_aarch64.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;runtime/frame.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;vmreg_aarch64.inline.hpp&quot;
  44 
  45 
  46 
  47 #ifndef PRODUCT
  48 #define COMMENT(x)   do { __ block_comment(x); } while (0)
  49 #else
  50 #define COMMENT(x)
  51 #endif
  52 
  53 NEEDS_CLEANUP // remove this definitions ?
  54 const Register IC_Klass    = rscratch2;   // where the IC klass is cached
  55 const Register SYNC_header = r0;   // synchronization header
  56 const Register SHIFT_count = r0;   // where count for shift operations must be
  57 
  58 #define __ _masm-&gt;
  59 
  60 
  61 static void select_different_registers(Register preserve,
  62                                        Register extra,
  63                                        Register &amp;tmp1,
  64                                        Register &amp;tmp2) {
  65   if (tmp1 == preserve) {
  66     assert_different_registers(tmp1, tmp2, extra);
  67     tmp1 = extra;
  68   } else if (tmp2 == preserve) {
  69     assert_different_registers(tmp1, tmp2, extra);
  70     tmp2 = extra;
  71   }
  72   assert_different_registers(preserve, tmp1, tmp2);
  73 }
  74 
  75 
  76 
  77 static void select_different_registers(Register preserve,
  78                                        Register extra,
  79                                        Register &amp;tmp1,
  80                                        Register &amp;tmp2,
  81                                        Register &amp;tmp3) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, tmp3, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, tmp3, extra);
  87     tmp2 = extra;
  88   } else if (tmp3 == preserve) {
  89     assert_different_registers(tmp1, tmp2, tmp3, extra);
  90     tmp3 = extra;
  91   }
  92   assert_different_registers(preserve, tmp1, tmp2, tmp3);
  93 }
  94 
  95 
  96 bool LIR_Assembler::is_small_constant(LIR_Opr opr) { Unimplemented(); return false; }
  97 
  98 
  99 LIR_Opr LIR_Assembler::receiverOpr() {
 100   return FrameMap::receiver_opr;
 101 }
 102 
 103 LIR_Opr LIR_Assembler::osrBufferPointer() {
 104   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 105 }
 106 
 107 //--------------fpu register translations-----------------------
 108 
 109 
 110 address LIR_Assembler::float_constant(float f) {
 111   address const_addr = __ float_constant(f);
 112   if (const_addr == NULL) {
 113     bailout(&quot;const section overflow&quot;);
 114     return __ code()-&gt;consts()-&gt;start();
 115   } else {
 116     return const_addr;
 117   }
 118 }
 119 
 120 
 121 address LIR_Assembler::double_constant(double d) {
 122   address const_addr = __ double_constant(d);
 123   if (const_addr == NULL) {
 124     bailout(&quot;const section overflow&quot;);
 125     return __ code()-&gt;consts()-&gt;start();
 126   } else {
 127     return const_addr;
 128   }
 129 }
 130 
 131 address LIR_Assembler::int_constant(jlong n) {
 132   address const_addr = __ long_constant(n);
 133   if (const_addr == NULL) {
 134     bailout(&quot;const section overflow&quot;);
 135     return __ code()-&gt;consts()-&gt;start();
 136   } else {
 137     return const_addr;
 138   }
 139 }
 140 
 141 void LIR_Assembler::breakpoint() { Unimplemented(); }
 142 
 143 void LIR_Assembler::push(LIR_Opr opr) { Unimplemented(); }
 144 
 145 void LIR_Assembler::pop(LIR_Opr opr) { Unimplemented(); }
 146 
 147 bool LIR_Assembler::is_literal_address(LIR_Address* addr) { Unimplemented(); return false; }
 148 //-------------------------------------------
 149 
 150 static Register as_reg(LIR_Opr op) {
 151   return op-&gt;is_double_cpu() ? op-&gt;as_register_lo() : op-&gt;as_register();
 152 }
 153 
 154 static jlong as_long(LIR_Opr data) {
 155   jlong result;
 156   switch (data-&gt;type()) {
 157   case T_INT:
 158     result = (data-&gt;as_jint());
 159     break;
 160   case T_LONG:
 161     result = (data-&gt;as_jlong());
 162     break;
 163   default:
 164     ShouldNotReachHere();
 165     result = 0;  // unreachable
 166   }
 167   return result;
 168 }
 169 
 170 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 171   Register base = addr-&gt;base()-&gt;as_pointer_register();
 172   LIR_Opr opr = addr-&gt;index();
 173   if (opr-&gt;is_cpu_register()) {
 174     Register index;
 175     if (opr-&gt;is_single_cpu())
 176       index = opr-&gt;as_register();
 177     else
 178       index = opr-&gt;as_register_lo();
 179     assert(addr-&gt;disp() == 0, &quot;must be&quot;);
 180     switch(opr-&gt;type()) {
 181       case T_INT:
 182         return Address(base, index, Address::sxtw(addr-&gt;scale()));
 183       case T_LONG:
 184         return Address(base, index, Address::lsl(addr-&gt;scale()));
 185       default:
 186         ShouldNotReachHere();
 187       }
 188   } else  {
 189     intptr_t addr_offset = intptr_t(addr-&gt;disp());
 190     if (Address::offset_ok_for_immed(addr_offset, addr-&gt;scale()))
 191       return Address(base, addr_offset, Address::lsl(addr-&gt;scale()));
 192     else {
 193       __ mov(tmp, addr_offset);
 194       return Address(base, tmp, Address::lsl(addr-&gt;scale()));
 195     }
 196   }
 197   return Address();
 198 }
 199 
 200 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 201   ShouldNotReachHere();
 202   return Address();
 203 }
 204 
 205 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 206   return as_Address(addr, rscratch1);
 207 }
 208 
 209 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 210   return as_Address(addr, rscratch1);  // Ouch
 211   // FIXME: This needs to be much more clever.  See x86.
 212 }
 213 
 214 
 215 void LIR_Assembler::osr_entry() {
 216   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 217   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 218   ValueStack* entry_state = osr_entry-&gt;state();
 219   int number_of_locks = entry_state-&gt;locks_size();
 220 
 221   // we jump here if osr happens with the interpreter
 222   // state set up to continue at the beginning of the
 223   // loop that triggered osr - in particular, we have
 224   // the following registers setup:
 225   //
 226   // r2: osr buffer
 227   //
 228 
 229   // build frame
 230   ciMethod* m = compilation()-&gt;method();
 231   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 232 
 233   // OSR buffer is
 234   //
 235   // locals[nlocals-1..0]
 236   // monitors[0..number_of_locks]
 237   //
 238   // locals is a direct copy of the interpreter frame so in the osr buffer
 239   // so first slot in the local array is the last local from the interpreter
 240   // and last slot is local[0] (receiver) from the interpreter
 241   //
 242   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 243   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 244   // in the interpreter frame (the method lock if a sync method)
 245 
 246   // Initialize monitors in the compiled activation.
 247   //   r2: pointer to osr buffer
 248   //
 249   // All other registers are dead at this point and the locals will be
 250   // copied into place by code emitted in the IR.
 251 
 252   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 253   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 254     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 255       (2 * BytesPerWord) * (number_of_locks - 1);
 256     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 257     // the OSR buffer using 2 word entries: first the lock and then
 258     // the oop.
 259     for (int i = 0; i &lt; number_of_locks; i++) {
 260       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 261 #ifdef ASSERT
 262       // verify the interpreter&#39;s monitor has a non-null object
 263       {
 264         Label L;
 265         __ ldr(rscratch1, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 266         __ cbnz(rscratch1, L);
 267         __ stop(&quot;locked object is NULL&quot;);
 268         __ bind(L);
 269       }
 270 #endif
 271       __ ldr(r19, Address(OSR_buf, slot_offset + 0));
 272       __ str(r19, frame_map()-&gt;address_for_monitor_lock(i));
 273       __ ldr(r19, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 274       __ str(r19, frame_map()-&gt;address_for_monitor_object(i));
 275     }
 276   }
 277 }
 278 
 279 
 280 // inline cache check; done before the frame is built.
 281 int LIR_Assembler::check_icache() {
 282   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 283   Register ic_klass = IC_Klass;
 284   int start_offset = __ offset();
 285   __ inline_cache_check(receiver, ic_klass);
 286 
 287   // if icache check fails, then jump to runtime routine
 288   // Note: RECEIVER must still contain the receiver!
 289   Label dont;
 290   __ br(Assembler::EQ, dont);
 291   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 292 
 293   // We align the verified entry point unless the method body
 294   // (including its inline cache check) will fit in a single 64-byte
 295   // icache line.
 296   if (! method()-&gt;is_accessor() || __ offset() - start_offset &gt; 4 * 4) {
 297     // force alignment after the cache check.
 298     __ align(CodeEntryAlignment);
 299   }
 300 
 301   __ bind(dont);
 302   return start_offset;
 303 }
 304 
 305 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 306   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 307   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 308 
 309   Label L_skip_barrier;
 310 
 311   __ mov_metadata(rscratch2, method-&gt;holder()-&gt;constant_encoding());
 312   __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier /*L_fast_path*/);
 313   __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 314   __ bind(L_skip_barrier);
 315 }
 316 
 317 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 318   if (o == NULL) {
 319     __ mov(reg, zr);
 320   } else {
 321     __ movoop(reg, o, /*immediate*/true);
 322   }
 323 }
 324 
 325 void LIR_Assembler::deoptimize_trap(CodeEmitInfo *info) {
 326   address target = NULL;
 327   relocInfo::relocType reloc_type = relocInfo::none;
 328 
 329   switch (patching_id(info)) {
 330   case PatchingStub::access_field_id:
 331     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 332     reloc_type = relocInfo::section_word_type;
 333     break;
 334   case PatchingStub::load_klass_id:
 335     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 336     reloc_type = relocInfo::metadata_type;
 337     break;
 338   case PatchingStub::load_mirror_id:
 339     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 340     reloc_type = relocInfo::oop_type;
 341     break;
 342   case PatchingStub::load_appendix_id:
 343     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 344     reloc_type = relocInfo::oop_type;
 345     break;
 346   default: ShouldNotReachHere();
 347   }
 348 
 349   __ far_call(RuntimeAddress(target));
 350   add_call_info_here(info);
 351 }
 352 
 353 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 354   deoptimize_trap(info);
 355 }
 356 
 357 
 358 // This specifies the rsp decrement needed to build the frame
 359 int LIR_Assembler::initial_frame_size_in_bytes() const {
 360   // if rounding, must let FrameMap know!
 361 
 362   // The frame_map records size in slots (32bit word)
 363 
 364   // subtract two words to account for return address and link
 365   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 366 }
 367 
 368 
 369 int LIR_Assembler::emit_exception_handler() {
 370   // if the last instruction is a call (typically to do a throw which
 371   // is coming at the end after block reordering) the return address
 372   // must still point into the code area in order to avoid assertion
 373   // failures when searching for the corresponding bci =&gt; add a nop
 374   // (was bug 5/14/1999 - gri)
 375   __ nop();
 376 
 377   // generate code for exception handler
 378   address handler_base = __ start_a_stub(exception_handler_size());
 379   if (handler_base == NULL) {
 380     // not enough space left for the handler
 381     bailout(&quot;exception handler overflow&quot;);
 382     return -1;
 383   }
 384 
 385   int offset = code_offset();
 386 
 387   // the exception oop and pc are in r0, and r3
 388   // no other registers need to be preserved, so invalidate them
 389   __ invalidate_registers(false, true, true, false, true, true);
 390 
 391   // check that there is really an exception
 392   __ verify_not_null_oop(r0);
 393 
 394   // search an exception handler (r0: exception oop, r3: throwing pc)
 395   __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));  __ should_not_reach_here();
 396   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 397   __ end_a_stub();
 398 
 399   return offset;
 400 }
 401 
 402 
 403 // Emit the code to remove the frame from the stack in the exception
 404 // unwind path.
 405 int LIR_Assembler::emit_unwind_handler() {
 406 #ifndef PRODUCT
 407   if (CommentedAssembly) {
 408     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 409   }
 410 #endif
 411 
 412   int offset = code_offset();
 413 
 414   // Fetch the exception from TLS and clear out exception related thread state
 415   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
 416   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
 417   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
 418 
 419   __ bind(_unwind_handler_entry);
 420   __ verify_not_null_oop(r0);
 421   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 422     __ mov(r19, r0);  // Preserve the exception
 423   }
 424 
 425   // Preform needed unlocking
 426   MonitorExitStub* stub = NULL;
 427   if (method()-&gt;is_synchronized()) {
 428     monitor_address(0, FrameMap::r0_opr);
 429     stub = new MonitorExitStub(FrameMap::r0_opr, true, 0);
 430     __ unlock_object(r5, r4, r0, *stub-&gt;entry());
 431     __ bind(*stub-&gt;continuation());
 432   }
 433 
 434   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 435     __ call_Unimplemented();
 436 #if 0
 437     __ movptr(Address(rsp, 0), rax);
 438     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 439     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 440 #endif
 441   }
 442 
 443   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 444     __ mov(r0, r19);  // Restore the exception
 445   }
 446 
 447   // remove the activation and dispatch to the unwind handler
 448   __ block_comment(&quot;remove_frame and dispatch to the unwind handler&quot;);
 449   __ remove_frame(initial_frame_size_in_bytes());
 450   __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 451 
 452   // Emit the slow path assembly
 453   if (stub != NULL) {
 454     stub-&gt;emit_code(this);
 455   }
 456 
 457   return offset;
 458 }
 459 
 460 
 461 int LIR_Assembler::emit_deopt_handler() {
 462   // if the last instruction is a call (typically to do a throw which
 463   // is coming at the end after block reordering) the return address
 464   // must still point into the code area in order to avoid assertion
 465   // failures when searching for the corresponding bci =&gt; add a nop
 466   // (was bug 5/14/1999 - gri)
 467   __ nop();
 468 
 469   // generate code for exception handler
 470   address handler_base = __ start_a_stub(deopt_handler_size());
 471   if (handler_base == NULL) {
 472     // not enough space left for the handler
 473     bailout(&quot;deopt handler overflow&quot;);
 474     return -1;
 475   }
 476 
 477   int offset = code_offset();
 478 
 479   __ adr(lr, pc());
 480   __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 481   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 482   __ end_a_stub();
 483 
 484   return offset;
 485 }
 486 
 487 void LIR_Assembler::add_debug_info_for_branch(address adr, CodeEmitInfo* info) {
 488   _masm-&gt;code_section()-&gt;relocate(adr, relocInfo::poll_type);
 489   int pc_offset = code_offset();
 490   flush_debug_info(pc_offset);
 491   info-&gt;record_debug_info(compilation()-&gt;debug_info_recorder(), pc_offset);
 492   if (info-&gt;exception_handlers() != NULL) {
 493     compilation()-&gt;add_exception_handlers_for_pco(pc_offset, info-&gt;exception_handlers());
 494   }
 495 }
 496 
 497 void LIR_Assembler::return_op(LIR_Opr result) {
 498   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == r0, &quot;word returns are in r0,&quot;);
 499 
 500   // Pop the stack before the safepoint code
 501   __ remove_frame(initial_frame_size_in_bytes());
 502 
 503   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 504     __ reserved_stack_check();
 505   }
 506 
 507   address polling_page(os::get_polling_page());
 508   __ read_polling_page(rscratch1, polling_page, relocInfo::poll_return_type);
 509   __ ret(lr);
 510 }
 511 
 512 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 513   address polling_page(os::get_polling_page());
 514   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 515   assert(os::is_poll_address(polling_page), &quot;should be&quot;);
 516   __ get_polling_page(rscratch1, polling_page, relocInfo::poll_type);
 517   add_debug_info_for_branch(info);  // This isn&#39;t just debug info:
 518                                     // it&#39;s the oop map
 519   __ read_polling_page(rscratch1, relocInfo::poll_type);
 520   return __ offset();
 521 }
 522 
 523 
 524 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 525   if (from_reg == r31_sp)
 526     from_reg = sp;
 527   if (to_reg == r31_sp)
 528     to_reg = sp;
 529   __ mov(to_reg, from_reg);
 530 }
 531 
 532 void LIR_Assembler::swap_reg(Register a, Register b) { Unimplemented(); }
 533 
 534 
 535 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 536   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 537   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 538   LIR_Const* c = src-&gt;as_constant_ptr();
 539 
 540   switch (c-&gt;type()) {
 541     case T_INT: {
 542       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 543       __ movw(dest-&gt;as_register(), c-&gt;as_jint());
 544       break;
 545     }
 546 
 547     case T_ADDRESS: {
 548       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 549       __ mov(dest-&gt;as_register(), c-&gt;as_jint());
 550       break;
 551     }
 552 
 553     case T_LONG: {
 554       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 555       __ mov(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 556       break;
 557     }
 558 
 559     case T_OBJECT: {
 560         if (patch_code == lir_patch_none) {
 561           jobject2reg(c-&gt;as_jobject(), dest-&gt;as_register());
 562         } else {
 563           jobject2reg_with_patching(dest-&gt;as_register(), info);
 564         }
 565       break;
 566     }
 567 
 568     case T_METADATA: {
 569       if (patch_code != lir_patch_none) {
 570         klass2reg_with_patching(dest-&gt;as_register(), info);
 571       } else {
 572         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 573       }
 574       break;
 575     }
 576 
 577     case T_FLOAT: {
 578       if (__ operand_valid_for_float_immediate(c-&gt;as_jfloat())) {
 579         __ fmovs(dest-&gt;as_float_reg(), (c-&gt;as_jfloat()));
 580       } else {
 581         __ adr(rscratch1, InternalAddress(float_constant(c-&gt;as_jfloat())));
 582         __ ldrs(dest-&gt;as_float_reg(), Address(rscratch1));
 583       }
 584       break;
 585     }
 586 
 587     case T_DOUBLE: {
 588       if (__ operand_valid_for_float_immediate(c-&gt;as_jdouble())) {
 589         __ fmovd(dest-&gt;as_double_reg(), (c-&gt;as_jdouble()));
 590       } else {
 591         __ adr(rscratch1, InternalAddress(double_constant(c-&gt;as_jdouble())));
 592         __ ldrd(dest-&gt;as_double_reg(), Address(rscratch1));
 593       }
 594       break;
 595     }
 596 
 597     default:
 598       ShouldNotReachHere();
 599   }
 600 }
 601 
 602 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 603   LIR_Const* c = src-&gt;as_constant_ptr();
 604   switch (c-&gt;type()) {
 605   case T_OBJECT:
 606     {
 607       if (! c-&gt;as_jobject())
 608         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 609       else {
 610         const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 611         reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 612       }
 613     }
 614     break;
 615   case T_ADDRESS:
 616     {
 617       const2reg(src, FrameMap::rscratch1_opr, lir_patch_none, NULL);
 618       reg2stack(FrameMap::rscratch1_opr, dest, c-&gt;type(), false);
 619     }
 620   case T_INT:
 621   case T_FLOAT:
 622     {
 623       Register reg = zr;
 624       if (c-&gt;as_jint_bits() == 0)
 625         __ strw(zr, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 626       else {
 627         __ movw(rscratch1, c-&gt;as_jint_bits());
 628         __ strw(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 629       }
 630     }
 631     break;
 632   case T_LONG:
 633   case T_DOUBLE:
 634     {
 635       Register reg = zr;
 636       if (c-&gt;as_jlong_bits() == 0)
 637         __ str(zr, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 638                                                  lo_word_offset_in_bytes));
 639       else {
 640         __ mov(rscratch1, (intptr_t)c-&gt;as_jlong_bits());
 641         __ str(rscratch1, frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 642                                                         lo_word_offset_in_bytes));
 643       }
 644     }
 645     break;
 646   default:
 647     ShouldNotReachHere();
 648   }
 649 }
 650 
 651 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 652   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 653   LIR_Const* c = src-&gt;as_constant_ptr();
 654   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 655 
 656   void (Assembler::* insn)(Register Rt, const Address &amp;adr);
 657 
 658   switch (type) {
 659   case T_ADDRESS:
 660     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 661     insn = &amp;Assembler::str;
 662     break;
 663   case T_LONG:
 664     assert(c-&gt;as_jlong() == 0, &quot;should be&quot;);
 665     insn = &amp;Assembler::str;
 666     break;
 667   case T_INT:
 668     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 669     insn = &amp;Assembler::strw;
 670     break;
 671   case T_OBJECT:
 672   case T_ARRAY:
 673     assert(c-&gt;as_jobject() == 0, &quot;should be&quot;);
 674     if (UseCompressedOops &amp;&amp; !wide) {
 675       insn = &amp;Assembler::strw;
 676     } else {
 677       insn = &amp;Assembler::str;
 678     }
 679     break;
 680   case T_CHAR:
 681   case T_SHORT:
 682     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 683     insn = &amp;Assembler::strh;
 684     break;
 685   case T_BOOLEAN:
 686   case T_BYTE:
 687     assert(c-&gt;as_jint() == 0, &quot;should be&quot;);
 688     insn = &amp;Assembler::strb;
 689     break;
 690   default:
 691     ShouldNotReachHere();
 692     insn = &amp;Assembler::str;  // unreachable
 693   }
 694 
 695   if (info) add_debug_info_for_null_check_here(info);
 696   (_masm-&gt;*insn)(zr, as_Address(to_addr, rscratch1));
 697 }
 698 
 699 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 700   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 701   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 702 
 703   // move between cpu-registers
 704   if (dest-&gt;is_single_cpu()) {
 705     if (src-&gt;type() == T_LONG) {
 706       // Can do LONG -&gt; OBJECT
 707       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 708       return;
 709     }
 710     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 711     if (src-&gt;type() == T_OBJECT) {
 712       __ verify_oop(src-&gt;as_register());
 713     }
 714     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 715 
 716   } else if (dest-&gt;is_double_cpu()) {
 717     if (is_reference_type(src-&gt;type())) {
 718       // Surprising to me but we can see move of a long to t_object
 719       __ verify_oop(src-&gt;as_register());
 720       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 721       return;
 722     }
 723     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 724     Register f_lo = src-&gt;as_register_lo();
 725     Register f_hi = src-&gt;as_register_hi();
 726     Register t_lo = dest-&gt;as_register_lo();
 727     Register t_hi = dest-&gt;as_register_hi();
 728     assert(f_hi == f_lo, &quot;must be same&quot;);
 729     assert(t_hi == t_lo, &quot;must be same&quot;);
 730     move_regs(f_lo, t_lo);
 731 
 732   } else if (dest-&gt;is_single_fpu()) {
 733     __ fmovs(dest-&gt;as_float_reg(), src-&gt;as_float_reg());
 734 
 735   } else if (dest-&gt;is_double_fpu()) {
 736     __ fmovd(dest-&gt;as_double_reg(), src-&gt;as_double_reg());
 737 
 738   } else {
 739     ShouldNotReachHere();
 740   }
 741 }
 742 
 743 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 744   if (src-&gt;is_single_cpu()) {
 745     if (is_reference_type(type)) {
 746       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 747       __ verify_oop(src-&gt;as_register());
 748     } else if (type == T_METADATA || type == T_DOUBLE || type == T_ADDRESS) {
 749       __ str(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 750     } else {
 751       __ strw(src-&gt;as_register(), frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
 752     }
 753 
 754   } else if (src-&gt;is_double_cpu()) {
 755     Address dest_addr_LO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 756     __ str(src-&gt;as_register_lo(), dest_addr_LO);
 757 
 758   } else if (src-&gt;is_single_fpu()) {
 759     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 760     __ strs(src-&gt;as_float_reg(), dest_addr);
 761 
 762   } else if (src-&gt;is_double_fpu()) {
 763     Address dest_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 764     __ strd(src-&gt;as_double_reg(), dest_addr);
 765 
 766   } else {
 767     ShouldNotReachHere();
 768   }
 769 
 770 }
 771 
 772 
 773 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 774   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 775   PatchingStub* patch = NULL;
 776   Register compressed_src = rscratch1;
 777 
 778   if (patch_code != lir_patch_none) {
 779     deoptimize_trap(info);
 780     return;
 781   }
 782 
 783   if (is_reference_type(type)) {
 784     __ verify_oop(src-&gt;as_register());
 785 
 786     if (UseCompressedOops &amp;&amp; !wide) {
 787       __ encode_heap_oop(compressed_src, src-&gt;as_register());
 788     } else {
 789       compressed_src = src-&gt;as_register();
 790     }
 791   }
 792 
 793   int null_check_here = code_offset();
 794   switch (type) {
 795     case T_FLOAT: {
 796       __ strs(src-&gt;as_float_reg(), as_Address(to_addr));
 797       break;
 798     }
 799 
 800     case T_DOUBLE: {
 801       __ strd(src-&gt;as_double_reg(), as_Address(to_addr));
 802       break;
 803     }
 804 
 805     case T_ARRAY:   // fall through
 806     case T_OBJECT:  // fall through
 807       if (UseCompressedOops &amp;&amp; !wide) {
 808         __ strw(compressed_src, as_Address(to_addr, rscratch2));
 809       } else {
 810          __ str(compressed_src, as_Address(to_addr));
 811       }
 812       break;
 813     case T_METADATA:
 814       // We get here to store a method pointer to the stack to pass to
 815       // a dtrace runtime call. This can&#39;t work on 64 bit with
 816       // compressed klass ptrs: T_METADATA can be a compressed klass
 817       // ptr or a 64 bit method pointer.
 818       ShouldNotReachHere();
 819       __ str(src-&gt;as_register(), as_Address(to_addr));
 820       break;
 821     case T_ADDRESS:
 822       __ str(src-&gt;as_register(), as_Address(to_addr));
 823       break;
 824     case T_INT:
 825       __ strw(src-&gt;as_register(), as_Address(to_addr));
 826       break;
 827 
 828     case T_LONG: {
 829       __ str(src-&gt;as_register_lo(), as_Address_lo(to_addr));
 830       break;
 831     }
 832 
 833     case T_BYTE:    // fall through
 834     case T_BOOLEAN: {
 835       __ strb(src-&gt;as_register(), as_Address(to_addr));
 836       break;
 837     }
 838 
 839     case T_CHAR:    // fall through
 840     case T_SHORT:
 841       __ strh(src-&gt;as_register(), as_Address(to_addr));
 842       break;
 843 
 844     default:
 845       ShouldNotReachHere();
 846   }
 847   if (info != NULL) {
 848     add_debug_info_for_null_check(null_check_here, info);
 849   }
 850 }
 851 
 852 
 853 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
 854   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
 855   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 856 
 857   if (dest-&gt;is_single_cpu()) {
 858     if (is_reference_type(type)) {
 859       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 860       __ verify_oop(dest-&gt;as_register());
 861     } else if (type == T_METADATA || type == T_ADDRESS) {
 862       __ ldr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 863     } else {
 864       __ ldrw(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
 865     }
 866 
 867   } else if (dest-&gt;is_double_cpu()) {
 868     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 869     __ ldr(dest-&gt;as_register_lo(), src_addr_LO);
 870 
 871   } else if (dest-&gt;is_single_fpu()) {
 872     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
 873     __ ldrs(dest-&gt;as_float_reg(), src_addr);
 874 
 875   } else if (dest-&gt;is_double_fpu()) {
 876     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
 877     __ ldrd(dest-&gt;as_double_reg(), src_addr);
 878 
 879   } else {
 880     ShouldNotReachHere();
 881   }
 882 }
 883 
 884 
 885 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 886   address target = NULL;
 887   relocInfo::relocType reloc_type = relocInfo::none;
 888 
 889   switch (patching_id(info)) {
 890   case PatchingStub::access_field_id:
 891     target = Runtime1::entry_for(Runtime1::access_field_patching_id);
 892     reloc_type = relocInfo::section_word_type;
 893     break;
 894   case PatchingStub::load_klass_id:
 895     target = Runtime1::entry_for(Runtime1::load_klass_patching_id);
 896     reloc_type = relocInfo::metadata_type;
 897     break;
 898   case PatchingStub::load_mirror_id:
 899     target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);
 900     reloc_type = relocInfo::oop_type;
 901     break;
 902   case PatchingStub::load_appendix_id:
 903     target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);
 904     reloc_type = relocInfo::oop_type;
 905     break;
 906   default: ShouldNotReachHere();
 907   }
 908 
 909   __ far_call(RuntimeAddress(target));
 910   add_call_info_here(info);
 911 }
 912 
 913 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
 914 
 915   LIR_Opr temp;
 916   if (type == T_LONG || type == T_DOUBLE)
 917     temp = FrameMap::rscratch1_long_opr;
 918   else
 919     temp = FrameMap::rscratch1_opr;
 920 
 921   stack2reg(src, temp, src-&gt;type());
 922   reg2stack(temp, dest, dest-&gt;type(), false);
 923 }
 924 
 925 
 926 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
 927   LIR_Address* addr = src-&gt;as_address_ptr();
 928   LIR_Address* from_addr = src-&gt;as_address_ptr();
 929 
 930   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
 931     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
 932   }
 933 
 934   if (patch_code != lir_patch_none) {
 935     deoptimize_trap(info);
 936     return;
 937   }
 938 
 939   if (info != NULL) {
 940     add_debug_info_for_null_check_here(info);
 941   }
 942   int null_check_here = code_offset();
 943   switch (type) {
 944     case T_FLOAT: {
 945       __ ldrs(dest-&gt;as_float_reg(), as_Address(from_addr));
 946       break;
 947     }
 948 
 949     case T_DOUBLE: {
 950       __ ldrd(dest-&gt;as_double_reg(), as_Address(from_addr));
 951       break;
 952     }
 953 
 954     case T_ARRAY:   // fall through
 955     case T_OBJECT:  // fall through
 956       if (UseCompressedOops &amp;&amp; !wide) {
 957         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 958       } else {
 959          __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 960       }
 961       break;
 962     case T_METADATA:
 963       // We get here to store a method pointer to the stack to pass to
 964       // a dtrace runtime call. This can&#39;t work on 64 bit with
 965       // compressed klass ptrs: T_METADATA can be a compressed klass
 966       // ptr or a 64 bit method pointer.
 967       ShouldNotReachHere();
 968       __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 969       break;
 970     case T_ADDRESS:
 971       // FIXME: OMG this is a horrible kludge.  Any offset from an
 972       // address that matches klass_offset_in_bytes() will be loaded
 973       // as a word, not a long.
 974       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
 975         __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 976       } else {
 977         __ ldr(dest-&gt;as_register(), as_Address(from_addr));
 978       }
 979       break;
 980     case T_INT:
 981       __ ldrw(dest-&gt;as_register(), as_Address(from_addr));
 982       break;
 983 
 984     case T_LONG: {
 985       __ ldr(dest-&gt;as_register_lo(), as_Address_lo(from_addr));
 986       break;
 987     }
 988 
 989     case T_BYTE:
 990       __ ldrsb(dest-&gt;as_register(), as_Address(from_addr));
 991       break;
 992     case T_BOOLEAN: {
 993       __ ldrb(dest-&gt;as_register(), as_Address(from_addr));
 994       break;
 995     }
 996 
 997     case T_CHAR:
 998       __ ldrh(dest-&gt;as_register(), as_Address(from_addr));
 999       break;
1000     case T_SHORT:
1001       __ ldrsh(dest-&gt;as_register(), as_Address(from_addr));
1002       break;
1003 
1004     default:
1005       ShouldNotReachHere();
1006   }
1007 
1008   if (is_reference_type(type)) {
1009     if (UseCompressedOops &amp;&amp; !wide) {
1010       __ decode_heap_oop(dest-&gt;as_register());
1011     }
1012 
1013     if (!UseZGC) {
1014       // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1015       __ verify_oop(dest-&gt;as_register());
1016     }
1017   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1018     if (UseCompressedClassPointers) {
1019       __ decode_klass_not_null(dest-&gt;as_register());
1020     }
1021   }
1022 }
1023 
1024 
1025 int LIR_Assembler::array_element_size(BasicType type) const {
1026   int elem_size = type2aelembytes(type);
1027   return exact_log2(elem_size);
1028 }
1029 
1030 
1031 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1032   switch (op-&gt;code()) {
1033   case lir_idiv:
1034   case lir_irem:
1035     arithmetic_idiv(op-&gt;code(),
1036                     op-&gt;in_opr1(),
1037                     op-&gt;in_opr2(),
1038                     op-&gt;in_opr3(),
1039                     op-&gt;result_opr(),
1040                     op-&gt;info());
1041     break;
1042   case lir_fmad:
1043     __ fmaddd(op-&gt;result_opr()-&gt;as_double_reg(),
1044               op-&gt;in_opr1()-&gt;as_double_reg(),
1045               op-&gt;in_opr2()-&gt;as_double_reg(),
1046               op-&gt;in_opr3()-&gt;as_double_reg());
1047     break;
1048   case lir_fmaf:
1049     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(),
1050               op-&gt;in_opr1()-&gt;as_float_reg(),
1051               op-&gt;in_opr2()-&gt;as_float_reg(),
1052               op-&gt;in_opr3()-&gt;as_float_reg());
1053     break;
1054   default:      ShouldNotReachHere(); break;
1055   }
1056 }
1057 
1058 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1059 #ifdef ASSERT
1060   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1061   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1062   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1063 #endif
1064 
1065   if (op-&gt;cond() == lir_cond_always) {
1066     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1067     __ b(*(op-&gt;label()));
1068   } else {
1069     Assembler::Condition acond;
1070     if (op-&gt;code() == lir_cond_float_branch) {
1071       bool is_unordered = (op-&gt;ublock() == op-&gt;block());
1072       // Assembler::EQ does not permit unordered branches, so we add
1073       // another branch here.  Likewise, Assembler::NE does not permit
1074       // ordered branches.
1075       if ((is_unordered &amp;&amp; op-&gt;cond() == lir_cond_equal)
1076           || (!is_unordered &amp;&amp; op-&gt;cond() == lir_cond_notEqual))
1077         __ br(Assembler::VS, *(op-&gt;ublock()-&gt;label()));
1078       switch(op-&gt;cond()) {
1079       case lir_cond_equal:        acond = Assembler::EQ; break;
1080       case lir_cond_notEqual:     acond = Assembler::NE; break;
1081       case lir_cond_less:         acond = (is_unordered ? Assembler::LT : Assembler::LO); break;
1082       case lir_cond_lessEqual:    acond = (is_unordered ? Assembler::LE : Assembler::LS); break;
1083       case lir_cond_greaterEqual: acond = (is_unordered ? Assembler::HS : Assembler::GE); break;
1084       case lir_cond_greater:      acond = (is_unordered ? Assembler::HI : Assembler::GT); break;
1085       default:                    ShouldNotReachHere();
1086         acond = Assembler::EQ;  // unreachable
1087       }
1088     } else {
1089       switch (op-&gt;cond()) {
1090         case lir_cond_equal:        acond = Assembler::EQ; break;
1091         case lir_cond_notEqual:     acond = Assembler::NE; break;
1092         case lir_cond_less:         acond = Assembler::LT; break;
1093         case lir_cond_lessEqual:    acond = Assembler::LE; break;
1094         case lir_cond_greaterEqual: acond = Assembler::GE; break;
1095         case lir_cond_greater:      acond = Assembler::GT; break;
1096         case lir_cond_belowEqual:   acond = Assembler::LS; break;
1097         case lir_cond_aboveEqual:   acond = Assembler::HS; break;
1098         default:                    ShouldNotReachHere();
1099           acond = Assembler::EQ;  // unreachable
1100       }
1101     }
1102     __ br(acond,*(op-&gt;label()));
1103   }
1104 }
1105 
1106 
1107 
1108 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1109   LIR_Opr src  = op-&gt;in_opr();
1110   LIR_Opr dest = op-&gt;result_opr();
1111 
1112   switch (op-&gt;bytecode()) {
1113     case Bytecodes::_i2f:
1114       {
1115         __ scvtfws(dest-&gt;as_float_reg(), src-&gt;as_register());
1116         break;
1117       }
1118     case Bytecodes::_i2d:
1119       {
1120         __ scvtfwd(dest-&gt;as_double_reg(), src-&gt;as_register());
1121         break;
1122       }
1123     case Bytecodes::_l2d:
1124       {
1125         __ scvtfd(dest-&gt;as_double_reg(), src-&gt;as_register_lo());
1126         break;
1127       }
1128     case Bytecodes::_l2f:
1129       {
1130         __ scvtfs(dest-&gt;as_float_reg(), src-&gt;as_register_lo());
1131         break;
1132       }
1133     case Bytecodes::_f2d:
1134       {
1135         __ fcvts(dest-&gt;as_double_reg(), src-&gt;as_float_reg());
1136         break;
1137       }
1138     case Bytecodes::_d2f:
1139       {
1140         __ fcvtd(dest-&gt;as_float_reg(), src-&gt;as_double_reg());
1141         break;
1142       }
1143     case Bytecodes::_i2c:
1144       {
1145         __ ubfx(dest-&gt;as_register(), src-&gt;as_register(), 0, 16);
1146         break;
1147       }
1148     case Bytecodes::_i2l:
1149       {
1150         __ sxtw(dest-&gt;as_register_lo(), src-&gt;as_register());
1151         break;
1152       }
1153     case Bytecodes::_i2s:
1154       {
1155         __ sxth(dest-&gt;as_register(), src-&gt;as_register());
1156         break;
1157       }
1158     case Bytecodes::_i2b:
1159       {
1160         __ sxtb(dest-&gt;as_register(), src-&gt;as_register());
1161         break;
1162       }
1163     case Bytecodes::_l2i:
1164       {
1165         _masm-&gt;block_comment(&quot;FIXME: This could be a no-op&quot;);
1166         __ uxtw(dest-&gt;as_register(), src-&gt;as_register_lo());
1167         break;
1168       }
1169     case Bytecodes::_d2l:
1170       {
1171         __ fcvtzd(dest-&gt;as_register_lo(), src-&gt;as_double_reg());
1172         break;
1173       }
1174     case Bytecodes::_f2i:
1175       {
1176         __ fcvtzsw(dest-&gt;as_register(), src-&gt;as_float_reg());
1177         break;
1178       }
1179     case Bytecodes::_f2l:
1180       {
1181         __ fcvtzs(dest-&gt;as_register_lo(), src-&gt;as_float_reg());
1182         break;
1183       }
1184     case Bytecodes::_d2i:
1185       {
1186         __ fcvtzdw(dest-&gt;as_register(), src-&gt;as_double_reg());
1187         break;
1188       }
1189     default: ShouldNotReachHere();
1190   }
1191 }
1192 
1193 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1194   if (op-&gt;init_check()) {
1195     __ ldrb(rscratch1, Address(op-&gt;klass()-&gt;as_register(),
1196                                InstanceKlass::init_state_offset()));
1197     __ cmpw(rscratch1, InstanceKlass::fully_initialized);
1198     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1199     __ br(Assembler::NE, *op-&gt;stub()-&gt;entry());
1200   }
1201   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1202                      op-&gt;tmp1()-&gt;as_register(),
1203                      op-&gt;tmp2()-&gt;as_register(),
1204                      op-&gt;header_size(),
1205                      op-&gt;object_size(),
1206                      op-&gt;klass()-&gt;as_register(),
1207                      *op-&gt;stub()-&gt;entry());
1208   __ bind(*op-&gt;stub()-&gt;continuation());
1209 }
1210 
1211 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1212   Register len =  op-&gt;len()-&gt;as_register();
1213   __ uxtw(len, len);
1214 
1215   if (UseSlowPath ||
1216       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1217       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1218     __ b(*op-&gt;stub()-&gt;entry());
1219   } else {
1220     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1221     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1222     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1223     if (len == tmp1) {
1224       tmp1 = tmp3;
1225     } else if (len == tmp2) {
1226       tmp2 = tmp3;
1227     } else if (len == tmp3) {
1228       // everything is ok
1229     } else {
1230       __ mov(tmp3, len);
1231     }
1232     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1233                       len,
1234                       tmp1,
1235                       tmp2,
1236                       arrayOopDesc::header_size(op-&gt;type()),
1237                       array_element_size(op-&gt;type()),
1238                       op-&gt;klass()-&gt;as_register(),
1239                       *op-&gt;stub()-&gt;entry());
1240   }
1241   __ bind(*op-&gt;stub()-&gt;continuation());
1242 }
1243 
1244 void LIR_Assembler::type_profile_helper(Register mdo,
1245                                         ciMethodData *md, ciProfileData *data,
1246                                         Register recv, Label* update_done) {
1247   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1248     Label next_test;
1249     // See if the receiver is receiver[n].
1250     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1251     __ ldr(rscratch1, Address(rscratch2));
1252     __ cmp(recv, rscratch1);
1253     __ br(Assembler::NE, next_test);
1254     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1255     __ addptr(data_addr, DataLayout::counter_increment);
1256     __ b(*update_done);
1257     __ bind(next_test);
1258   }
1259 
1260   // Didn&#39;t find receiver; find next empty slot and fill it in
1261   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1262     Label next_test;
1263     __ lea(rscratch2,
1264            Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1265     Address recv_addr(rscratch2);
1266     __ ldr(rscratch1, recv_addr);
1267     __ cbnz(rscratch1, next_test);
1268     __ str(recv, recv_addr);
1269     __ mov(rscratch1, DataLayout::counter_increment);
1270     __ lea(rscratch2, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))));
1271     __ str(rscratch1, Address(rscratch2));
1272     __ b(*update_done);
1273     __ bind(next_test);
1274   }
1275 }
1276 
1277 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1278   // we always need a stub for the failure case.
1279   CodeStub* stub = op-&gt;stub();
1280   Register obj = op-&gt;object()-&gt;as_register();
1281   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1282   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1283   Register dst = op-&gt;result_opr()-&gt;as_register();
1284   ciKlass* k = op-&gt;klass();
1285   Register Rtmp1 = noreg;
1286 
1287   // check if it needs to be profiled
1288   ciMethodData* md;
1289   ciProfileData* data;
1290 
1291   const bool should_profile = op-&gt;should_profile();
1292 
1293   if (should_profile) {
1294     ciMethod* method = op-&gt;profiled_method();
1295     assert(method != NULL, &quot;Should have method&quot;);
1296     int bci = op-&gt;profiled_bci();
1297     md = method-&gt;method_data_or_null();
1298     assert(md != NULL, &quot;Sanity&quot;);
1299     data = md-&gt;bci_to_data(bci);
1300     assert(data != NULL,                &quot;need data for type check&quot;);
1301     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1302   }
1303   Label profile_cast_success, profile_cast_failure;
1304   Label *success_target = should_profile ? &amp;profile_cast_success : success;
1305   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
1306 
1307   if (obj == k_RInfo) {
1308     k_RInfo = dst;
1309   } else if (obj == klass_RInfo) {
1310     klass_RInfo = dst;
1311   }
1312   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1313     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1314   } else {
1315     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1316     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1317   }
1318 
1319   assert_different_registers(obj, k_RInfo, klass_RInfo);
1320 
1321     if (should_profile) {
1322       Label not_null;
1323       __ cbnz(obj, not_null);
1324       // Object is null; update MDO and exit
1325       Register mdo  = klass_RInfo;
1326       __ mov_metadata(mdo, md-&gt;constant_encoding());
1327       Address data_addr
1328         = __ form_address(rscratch2, mdo,
1329                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1330                           0);
1331       __ ldrb(rscratch1, data_addr);
1332       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1333       __ strb(rscratch1, data_addr);
1334       __ b(*obj_is_null);
1335       __ bind(not_null);
1336     } else {
1337       __ cbz(obj, *obj_is_null);
1338     }
1339 
1340   if (!k-&gt;is_loaded()) {
1341     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1342   } else {
1343     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1344   }
1345   __ verify_oop(obj);
1346 
1347   if (op-&gt;fast_check()) {
1348     // get object class
1349     // not a safepoint as obj null check happens earlier
1350     __ load_klass(rscratch1, obj);
1351     __ cmp( rscratch1, k_RInfo);
1352 
1353     __ br(Assembler::NE, *failure_target);
1354     // successful cast, fall through to profile or jump
1355   } else {
1356     // get object class
1357     // not a safepoint as obj null check happens earlier
1358     __ load_klass(klass_RInfo, obj);
1359     if (k-&gt;is_loaded()) {
1360       // See if we get an immediate positive hit
1361       __ ldr(rscratch1, Address(klass_RInfo, long(k-&gt;super_check_offset())));
1362       __ cmp(k_RInfo, rscratch1);
1363       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1364         __ br(Assembler::NE, *failure_target);
1365         // successful cast, fall through to profile or jump
1366       } else {
1367         // See if we get an immediate positive hit
1368         __ br(Assembler::EQ, *success_target);
1369         // check for self
1370         __ cmp(klass_RInfo, k_RInfo);
1371         __ br(Assembler::EQ, *success_target);
1372 
1373         __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1374         __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1375         __ ldr(klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1376         // result is a boolean
1377         __ cbzw(klass_RInfo, *failure_target);
1378         // successful cast, fall through to profile or jump
1379       }
1380     } else {
1381       // perform the fast part of the checking logic
1382       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1383       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1384       __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1385       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1386       __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1387       // result is a boolean
1388       __ cbz(k_RInfo, *failure_target);
1389       // successful cast, fall through to profile or jump
1390     }
1391   }
1392   if (should_profile) {
1393     Register mdo  = klass_RInfo, recv = k_RInfo;
1394     __ bind(profile_cast_success);
1395     __ mov_metadata(mdo, md-&gt;constant_encoding());
1396     __ load_klass(recv, obj);
1397     Label update_done;
1398     type_profile_helper(mdo, md, data, recv, success);
1399     __ b(*success);
1400 
1401     __ bind(profile_cast_failure);
1402     __ mov_metadata(mdo, md-&gt;constant_encoding());
1403     Address counter_addr
1404       = __ form_address(rscratch2, mdo,
1405                         md-&gt;byte_offset_of_slot(data, CounterData::count_offset()),
1406                         0);
1407     __ ldr(rscratch1, counter_addr);
1408     __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1409     __ str(rscratch1, counter_addr);
1410     __ b(*failure);
1411   }
1412   __ b(*success);
1413 }
1414 
1415 
1416 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1417   const bool should_profile = op-&gt;should_profile();
1418 
1419   LIR_Code code = op-&gt;code();
1420   if (code == lir_store_check) {
1421     Register value = op-&gt;object()-&gt;as_register();
1422     Register array = op-&gt;array()-&gt;as_register();
1423     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1424     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1425     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1426 
1427     CodeStub* stub = op-&gt;stub();
1428 
1429     // check if it needs to be profiled
1430     ciMethodData* md;
1431     ciProfileData* data;
1432 
1433     if (should_profile) {
1434       ciMethod* method = op-&gt;profiled_method();
1435       assert(method != NULL, &quot;Should have method&quot;);
1436       int bci = op-&gt;profiled_bci();
1437       md = method-&gt;method_data_or_null();
1438       assert(md != NULL, &quot;Sanity&quot;);
1439       data = md-&gt;bci_to_data(bci);
1440       assert(data != NULL,                &quot;need data for type check&quot;);
1441       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1442     }
1443     Label profile_cast_success, profile_cast_failure, done;
1444     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
1445     Label *failure_target = should_profile ? &amp;profile_cast_failure : stub-&gt;entry();
1446 
1447     if (should_profile) {
1448       Label not_null;
1449       __ cbnz(value, not_null);
1450       // Object is null; update MDO and exit
1451       Register mdo  = klass_RInfo;
1452       __ mov_metadata(mdo, md-&gt;constant_encoding());
1453       Address data_addr
1454         = __ form_address(rscratch2, mdo,
1455                           md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()),
1456                           0);
1457       __ ldrb(rscratch1, data_addr);
1458       __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());
1459       __ strb(rscratch1, data_addr);
1460       __ b(done);
1461       __ bind(not_null);
1462     } else {
1463       __ cbz(value, done);
1464     }
1465 
1466     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1467     __ load_klass(k_RInfo, array);
1468     __ load_klass(klass_RInfo, value);
1469 
1470     // get instance klass (it&#39;s already uncompressed)
1471     __ ldr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1472     // perform the fast part of the checking logic
1473     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1474     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1475     __ stp(klass_RInfo, k_RInfo, Address(__ pre(sp, -2 * wordSize)));
1476     __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1477     __ ldp(k_RInfo, klass_RInfo, Address(__ post(sp, 2 * wordSize)));
1478     // result is a boolean
1479     __ cbzw(k_RInfo, *failure_target);
1480     // fall through to the success case
1481 
1482     if (should_profile) {
1483       Register mdo  = klass_RInfo, recv = k_RInfo;
1484       __ bind(profile_cast_success);
1485       __ mov_metadata(mdo, md-&gt;constant_encoding());
1486       __ load_klass(recv, value);
1487       Label update_done;
1488       type_profile_helper(mdo, md, data, recv, &amp;done);
1489       __ b(done);
1490 
1491       __ bind(profile_cast_failure);
1492       __ mov_metadata(mdo, md-&gt;constant_encoding());
1493       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1494       __ lea(rscratch2, counter_addr);
1495       __ ldr(rscratch1, Address(rscratch2));
1496       __ sub(rscratch1, rscratch1, DataLayout::counter_increment);
1497       __ str(rscratch1, Address(rscratch2));
1498       __ b(*stub-&gt;entry());
1499     }
1500 
1501     __ bind(done);
1502   } else if (code == lir_checkcast) {
1503     Register obj = op-&gt;object()-&gt;as_register();
1504     Register dst = op-&gt;result_opr()-&gt;as_register();
1505     Label success;
1506     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1507     __ bind(success);
1508     if (dst != obj) {
1509       __ mov(dst, obj);
1510     }
1511   } else if (code == lir_instanceof) {
1512     Register obj = op-&gt;object()-&gt;as_register();
1513     Register dst = op-&gt;result_opr()-&gt;as_register();
1514     Label success, failure, done;
1515     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1516     __ bind(failure);
1517     __ mov(dst, zr);
1518     __ b(done);
1519     __ bind(success);
1520     __ mov(dst, 1);
1521     __ bind(done);
1522   } else {
1523     ShouldNotReachHere();
1524   }
1525 }
1526 
1527 void LIR_Assembler::casw(Register addr, Register newval, Register cmpval) {
1528   __ cmpxchg(addr, cmpval, newval, Assembler::word, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1529   __ cset(rscratch1, Assembler::NE);
1530   __ membar(__ AnyAny);
1531 }
1532 
1533 void LIR_Assembler::casl(Register addr, Register newval, Register cmpval) {
1534   __ cmpxchg(addr, cmpval, newval, Assembler::xword, /* acquire*/ true, /* release*/ true, /* weak*/ false, rscratch1);
1535   __ cset(rscratch1, Assembler::NE);
1536   __ membar(__ AnyAny);
1537 }
1538 
1539 
1540 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1541   assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
1542   Register addr;
1543   if (op-&gt;addr()-&gt;is_register()) {
1544     addr = as_reg(op-&gt;addr());
1545   } else {
1546     assert(op-&gt;addr()-&gt;is_address(), &quot;what else?&quot;);
1547     LIR_Address* addr_ptr = op-&gt;addr()-&gt;as_address_ptr();
1548     assert(addr_ptr-&gt;disp() == 0, &quot;need 0 disp&quot;);
1549     assert(addr_ptr-&gt;index() == LIR_OprDesc::illegalOpr(), &quot;need 0 index&quot;);
1550     addr = as_reg(addr_ptr-&gt;base());
1551   }
1552   Register newval = as_reg(op-&gt;new_value());
1553   Register cmpval = as_reg(op-&gt;cmp_value());
1554 
1555   if (op-&gt;code() == lir_cas_obj) {
1556     if (UseCompressedOops) {
1557       Register t1 = op-&gt;tmp1()-&gt;as_register();
1558       assert(op-&gt;tmp1()-&gt;is_valid(), &quot;must be&quot;);
1559       __ encode_heap_oop(t1, cmpval);
1560       cmpval = t1;
1561       __ encode_heap_oop(rscratch2, newval);
1562       newval = rscratch2;
1563       casw(addr, newval, cmpval);
1564     } else {
1565       casl(addr, newval, cmpval);
1566     }
1567   } else if (op-&gt;code() == lir_cas_int) {
1568     casw(addr, newval, cmpval);
1569   } else {
1570     casl(addr, newval, cmpval);
1571   }
1572 }
1573 
1574 
1575 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1576 
1577   Assembler::Condition acond, ncond;
1578   switch (condition) {
1579   case lir_cond_equal:        acond = Assembler::EQ; ncond = Assembler::NE; break;
1580   case lir_cond_notEqual:     acond = Assembler::NE; ncond = Assembler::EQ; break;
1581   case lir_cond_less:         acond = Assembler::LT; ncond = Assembler::GE; break;
1582   case lir_cond_lessEqual:    acond = Assembler::LE; ncond = Assembler::GT; break;
1583   case lir_cond_greaterEqual: acond = Assembler::GE; ncond = Assembler::LT; break;
1584   case lir_cond_greater:      acond = Assembler::GT; ncond = Assembler::LE; break;
1585   case lir_cond_belowEqual:
1586   case lir_cond_aboveEqual:
1587   default:                    ShouldNotReachHere();
1588     acond = Assembler::EQ; ncond = Assembler::NE;  // unreachable
1589   }
1590 
1591   assert(result-&gt;is_single_cpu() || result-&gt;is_double_cpu(),
1592          &quot;expect single register for result&quot;);
1593   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1594       &amp;&amp; opr1-&gt;type() == T_INT &amp;&amp; opr2-&gt;type() == T_INT) {
1595     jint val1 = opr1-&gt;as_jint();
1596     jint val2 = opr2-&gt;as_jint();
1597     if (val1 == 0 &amp;&amp; val2 == 1) {
1598       __ cset(result-&gt;as_register(), ncond);
1599       return;
1600     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1601       __ cset(result-&gt;as_register(), acond);
1602       return;
1603     }
1604   }
1605 
1606   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_constant()
1607       &amp;&amp; opr1-&gt;type() == T_LONG &amp;&amp; opr2-&gt;type() == T_LONG) {
1608     jlong val1 = opr1-&gt;as_jlong();
1609     jlong val2 = opr2-&gt;as_jlong();
1610     if (val1 == 0 &amp;&amp; val2 == 1) {
1611       __ cset(result-&gt;as_register_lo(), ncond);
1612       return;
1613     } else if (val1 == 1 &amp;&amp; val2 == 0) {
1614       __ cset(result-&gt;as_register_lo(), acond);
1615       return;
1616     }
1617   }
1618 
1619   if (opr1-&gt;is_stack()) {
1620     stack2reg(opr1, FrameMap::rscratch1_opr, result-&gt;type());
1621     opr1 = FrameMap::rscratch1_opr;
1622   } else if (opr1-&gt;is_constant()) {
1623     LIR_Opr tmp
1624       = opr1-&gt;type() == T_LONG ? FrameMap::rscratch1_long_opr : FrameMap::rscratch1_opr;
1625     const2reg(opr1, tmp, lir_patch_none, NULL);
1626     opr1 = tmp;
1627   }
1628 
1629   if (opr2-&gt;is_stack()) {
1630     stack2reg(opr2, FrameMap::rscratch2_opr, result-&gt;type());
1631     opr2 = FrameMap::rscratch2_opr;
1632   } else if (opr2-&gt;is_constant()) {
1633     LIR_Opr tmp
1634       = opr2-&gt;type() == T_LONG ? FrameMap::rscratch2_long_opr : FrameMap::rscratch2_opr;
1635     const2reg(opr2, tmp, lir_patch_none, NULL);
1636     opr2 = tmp;
1637   }
1638 
1639   if (result-&gt;type() == T_LONG)
1640     __ csel(result-&gt;as_register_lo(), opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo(), acond);
1641   else
1642     __ csel(result-&gt;as_register(), opr1-&gt;as_register(), opr2-&gt;as_register(), acond);
1643 }
1644 
1645 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1646   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
1647 
1648   if (left-&gt;is_single_cpu()) {
1649     Register lreg = left-&gt;as_register();
1650     Register dreg = as_reg(dest);
1651 
1652     if (right-&gt;is_single_cpu()) {
1653       // cpu register - cpu register
1654 
1655       assert(left-&gt;type() == T_INT &amp;&amp; right-&gt;type() == T_INT &amp;&amp; dest-&gt;type() == T_INT,
1656              &quot;should be&quot;);
1657       Register rreg = right-&gt;as_register();
1658       switch (code) {
1659       case lir_add: __ addw (dest-&gt;as_register(), lreg, rreg); break;
1660       case lir_sub: __ subw (dest-&gt;as_register(), lreg, rreg); break;
1661       case lir_mul: __ mulw (dest-&gt;as_register(), lreg, rreg); break;
1662       default:      ShouldNotReachHere();
1663       }
1664 
1665     } else if (right-&gt;is_double_cpu()) {
1666       Register rreg = right-&gt;as_register_lo();
1667       // single_cpu + double_cpu: can happen with obj+long
1668       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1669       switch (code) {
1670       case lir_add: __ add(dreg, lreg, rreg); break;
1671       case lir_sub: __ sub(dreg, lreg, rreg); break;
1672       default: ShouldNotReachHere();
1673       }
1674     } else if (right-&gt;is_constant()) {
1675       // cpu register - constant
1676       jlong c;
1677 
1678       // FIXME.  This is fugly: we really need to factor all this logic.
1679       switch(right-&gt;type()) {
1680       case T_LONG:
1681         c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1682         break;
1683       case T_INT:
1684       case T_ADDRESS:
1685         c = right-&gt;as_constant_ptr()-&gt;as_jint();
1686         break;
1687       default:
1688         ShouldNotReachHere();
1689         c = 0;  // unreachable
1690         break;
1691       }
1692 
1693       assert(code == lir_add || code == lir_sub, &quot;mismatched arithmetic op&quot;);
1694       if (c == 0 &amp;&amp; dreg == lreg) {
1695         COMMENT(&quot;effective nop elided&quot;);
1696         return;
1697       }
1698       switch(left-&gt;type()) {
1699       case T_INT:
1700         switch (code) {
1701         case lir_add: __ addw(dreg, lreg, c); break;
1702         case lir_sub: __ subw(dreg, lreg, c); break;
1703         default: ShouldNotReachHere();
1704         }
1705         break;
1706       case T_OBJECT:
1707       case T_ADDRESS:
1708         switch (code) {
1709         case lir_add: __ add(dreg, lreg, c); break;
1710         case lir_sub: __ sub(dreg, lreg, c); break;
1711         default: ShouldNotReachHere();
1712         }
1713         break;
1714       default:
1715         ShouldNotReachHere();
1716       }
1717     } else {
1718       ShouldNotReachHere();
1719     }
1720 
1721   } else if (left-&gt;is_double_cpu()) {
1722     Register lreg_lo = left-&gt;as_register_lo();
1723 
1724     if (right-&gt;is_double_cpu()) {
1725       // cpu register - cpu register
1726       Register rreg_lo = right-&gt;as_register_lo();
1727       switch (code) {
1728       case lir_add: __ add (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1729       case lir_sub: __ sub (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1730       case lir_mul: __ mul (dest-&gt;as_register_lo(), lreg_lo, rreg_lo); break;
1731       case lir_div: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, false, rscratch1); break;
1732       case lir_rem: __ corrected_idivq(dest-&gt;as_register_lo(), lreg_lo, rreg_lo, true, rscratch1); break;
1733       default:
1734         ShouldNotReachHere();
1735       }
1736 
1737     } else if (right-&gt;is_constant()) {
1738       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1739       Register dreg = as_reg(dest);
1740       switch (code) {
1741         case lir_add:
1742         case lir_sub:
1743           if (c == 0 &amp;&amp; dreg == lreg_lo) {
1744             COMMENT(&quot;effective nop elided&quot;);
1745             return;
1746           }
1747           code == lir_add ? __ add(dreg, lreg_lo, c) : __ sub(dreg, lreg_lo, c);
1748           break;
1749         case lir_div:
1750           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);
1751           if (c == 1) {
1752             // move lreg_lo to dreg if divisor is 1
1753             __ mov(dreg, lreg_lo);
1754           } else {
1755             unsigned int shift = exact_log2_long(c);
1756             // use rscratch1 as intermediate result register
1757             __ asr(rscratch1, lreg_lo, 63);
1758             __ add(rscratch1, lreg_lo, rscratch1, Assembler::LSR, 64 - shift);
1759             __ asr(dreg, rscratch1, shift);
1760           }
1761           break;
1762         case lir_rem:
1763           assert(c &gt; 0 &amp;&amp; is_power_of_2_long(c), &quot;divisor must be power-of-2 constant&quot;);
1764           if (c == 1) {
1765             // move 0 to dreg if divisor is 1
1766             __ mov(dreg, zr);
1767           } else {
1768             // use rscratch1 as intermediate result register
1769             __ negs(rscratch1, lreg_lo);
1770             __ andr(dreg, lreg_lo, c - 1);
1771             __ andr(rscratch1, rscratch1, c - 1);
1772             __ csneg(dreg, dreg, rscratch1, Assembler::MI);
1773           }
1774           break;
1775         default:
1776           ShouldNotReachHere();
1777       }
1778     } else {
1779       ShouldNotReachHere();
1780     }
1781   } else if (left-&gt;is_single_fpu()) {
1782     assert(right-&gt;is_single_fpu(), &quot;right hand side of float arithmetics needs to be float register&quot;);
1783     switch (code) {
1784     case lir_add: __ fadds (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1785     case lir_sub: __ fsubs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1786     case lir_mul_strictfp: // fall through
1787     case lir_mul: __ fmuls (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1788     case lir_div_strictfp: // fall through
1789     case lir_div: __ fdivs (dest-&gt;as_float_reg(), left-&gt;as_float_reg(), right-&gt;as_float_reg()); break;
1790     default:
1791       ShouldNotReachHere();
1792     }
1793   } else if (left-&gt;is_double_fpu()) {
1794     if (right-&gt;is_double_fpu()) {
1795       // fpu register - fpu register
1796       switch (code) {
1797       case lir_add: __ faddd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1798       case lir_sub: __ fsubd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1799       case lir_mul_strictfp: // fall through
1800       case lir_mul: __ fmuld (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1801       case lir_div_strictfp: // fall through
1802       case lir_div: __ fdivd (dest-&gt;as_double_reg(), left-&gt;as_double_reg(), right-&gt;as_double_reg()); break;
1803       default:
1804         ShouldNotReachHere();
1805       }
1806     } else {
1807       if (right-&gt;is_constant()) {
1808         ShouldNotReachHere();
1809       }
1810       ShouldNotReachHere();
1811     }
1812   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
1813     assert(left == dest, &quot;left and dest must be equal&quot;);
1814     ShouldNotReachHere();
1815   } else {
1816     ShouldNotReachHere();
1817   }
1818 }
1819 
1820 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) { Unimplemented(); }
1821 
1822 
1823 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op) {
1824   switch(code) {
1825   case lir_abs : __ fabsd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1826   case lir_sqrt: __ fsqrtd(dest-&gt;as_double_reg(), value-&gt;as_double_reg()); break;
1827   default      : ShouldNotReachHere();
1828   }
1829 }
1830 
1831 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
1832 
1833   assert(left-&gt;is_single_cpu() || left-&gt;is_double_cpu(), &quot;expect single or double register&quot;);
1834   Register Rleft = left-&gt;is_single_cpu() ? left-&gt;as_register() :
1835                                            left-&gt;as_register_lo();
1836    if (dst-&gt;is_single_cpu()) {
1837      Register Rdst = dst-&gt;as_register();
1838      if (right-&gt;is_constant()) {
1839        switch (code) {
1840          case lir_logic_and: __ andw (Rdst, Rleft, right-&gt;as_jint()); break;
1841          case lir_logic_or:  __ orrw (Rdst, Rleft, right-&gt;as_jint()); break;
1842          case lir_logic_xor: __ eorw (Rdst, Rleft, right-&gt;as_jint()); break;
1843          default: ShouldNotReachHere(); break;
1844        }
1845      } else {
1846        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1847                                                   right-&gt;as_register_lo();
1848        switch (code) {
1849          case lir_logic_and: __ andw (Rdst, Rleft, Rright); break;
1850          case lir_logic_or:  __ orrw (Rdst, Rleft, Rright); break;
1851          case lir_logic_xor: __ eorw (Rdst, Rleft, Rright); break;
1852          default: ShouldNotReachHere(); break;
1853        }
1854      }
1855    } else {
1856      Register Rdst = dst-&gt;as_register_lo();
1857      if (right-&gt;is_constant()) {
1858        switch (code) {
1859          case lir_logic_and: __ andr (Rdst, Rleft, right-&gt;as_jlong()); break;
1860          case lir_logic_or:  __ orr (Rdst, Rleft, right-&gt;as_jlong()); break;
1861          case lir_logic_xor: __ eor (Rdst, Rleft, right-&gt;as_jlong()); break;
1862          default: ShouldNotReachHere(); break;
1863        }
1864      } else {
1865        Register Rright = right-&gt;is_single_cpu() ? right-&gt;as_register() :
1866                                                   right-&gt;as_register_lo();
1867        switch (code) {
1868          case lir_logic_and: __ andr (Rdst, Rleft, Rright); break;
1869          case lir_logic_or:  __ orr (Rdst, Rleft, Rright); break;
1870          case lir_logic_xor: __ eor (Rdst, Rleft, Rright); break;
1871          default: ShouldNotReachHere(); break;
1872        }
1873      }
1874    }
1875 }
1876 
1877 
1878 
1879 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr illegal, LIR_Opr result, CodeEmitInfo* info) {
1880 
1881   // opcode check
1882   assert((code == lir_idiv) || (code == lir_irem), &quot;opcode must be idiv or irem&quot;);
1883   bool is_irem = (code == lir_irem);
1884 
1885   // operand check
1886   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
1887   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
1888   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
1889   Register lreg = left-&gt;as_register();
1890   Register dreg = result-&gt;as_register();
1891 
1892   // power-of-2 constant check and codegen
1893   if (right-&gt;is_constant()) {
1894     int c = right-&gt;as_constant_ptr()-&gt;as_jint();
1895     assert(c &gt; 0 &amp;&amp; is_power_of_2(c), &quot;divisor must be power-of-2 constant&quot;);
1896     if (is_irem) {
1897       if (c == 1) {
1898         // move 0 to dreg if divisor is 1
1899         __ movw(dreg, zr);
1900       } else {
1901         // use rscratch1 as intermediate result register
1902         __ negsw(rscratch1, lreg);
1903         __ andw(dreg, lreg, c - 1);
1904         __ andw(rscratch1, rscratch1, c - 1);
1905         __ csnegw(dreg, dreg, rscratch1, Assembler::MI);
1906       }
1907     } else {
1908       if (c == 1) {
1909         // move lreg to dreg if divisor is 1
1910         __ movw(dreg, lreg);
1911       } else {
1912         unsigned int shift = exact_log2(c);
1913         // use rscratch1 as intermediate result register
1914         __ asrw(rscratch1, lreg, 31);
1915         __ addw(rscratch1, lreg, rscratch1, Assembler::LSR, 32 - shift);
1916         __ asrw(dreg, rscratch1, shift);
1917       }
1918     }
1919   } else {
1920     Register rreg = right-&gt;as_register();
1921     __ corrected_idivl(dreg, lreg, rreg, is_irem, rscratch1);
1922   }
1923 }
1924 
1925 
1926 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1927   if (opr1-&gt;is_constant() &amp;&amp; opr2-&gt;is_single_cpu()) {
1928     // tableswitch
1929     Register reg = as_reg(opr2);
1930     struct tableswitch &amp;table = switches[opr1-&gt;as_constant_ptr()-&gt;as_jint()];
1931     __ tableswitch(reg, table._first_key, table._last_key, table._branches, table._after);
1932   } else if (opr1-&gt;is_single_cpu() || opr1-&gt;is_double_cpu()) {
1933     Register reg1 = as_reg(opr1);
1934     if (opr2-&gt;is_single_cpu()) {
1935       // cpu register - cpu register
1936       Register reg2 = opr2-&gt;as_register();
1937       if (is_reference_type(opr1-&gt;type())) {
1938         __ cmpoop(reg1, reg2);
1939       } else {
1940         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
1941         __ cmpw(reg1, reg2);
1942       }
1943       return;
1944     }
1945     if (opr2-&gt;is_double_cpu()) {
1946       // cpu register - cpu register
1947       Register reg2 = opr2-&gt;as_register_lo();
1948       __ cmp(reg1, reg2);
1949       return;
1950     }
1951 
1952     if (opr2-&gt;is_constant()) {
1953       bool is_32bit = false; // width of register operand
1954       jlong imm;
1955 
1956       switch(opr2-&gt;type()) {
1957       case T_INT:
1958         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1959         is_32bit = true;
1960         break;
1961       case T_LONG:
1962         imm = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1963         break;
1964       case T_ADDRESS:
1965         imm = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1966         break;
1967       case T_METADATA:
1968         imm = (intptr_t)(opr2-&gt;as_constant_ptr()-&gt;as_metadata());
1969         break;
1970       case T_OBJECT:
1971       case T_ARRAY:
1972         jobject2reg(opr2-&gt;as_constant_ptr()-&gt;as_jobject(), rscratch1);
1973         __ cmpoop(reg1, rscratch1);
1974         return;
1975       default:
1976         ShouldNotReachHere();
1977         imm = 0;  // unreachable
1978         break;
1979       }
1980 
1981       if (Assembler::operand_valid_for_add_sub_immediate(imm)) {
1982         if (is_32bit)
1983           __ cmpw(reg1, imm);
1984         else
1985           __ subs(zr, reg1, imm);
1986         return;
1987       } else {
1988         __ mov(rscratch1, imm);
1989         if (is_32bit)
1990           __ cmpw(reg1, rscratch1);
1991         else
1992           __ cmp(reg1, rscratch1);
1993         return;
1994       }
1995     } else
1996       ShouldNotReachHere();
1997   } else if (opr1-&gt;is_single_fpu()) {
1998     FloatRegister reg1 = opr1-&gt;as_float_reg();
1999     assert(opr2-&gt;is_single_fpu(), &quot;expect single float register&quot;);
2000     FloatRegister reg2 = opr2-&gt;as_float_reg();
2001     __ fcmps(reg1, reg2);
2002   } else if (opr1-&gt;is_double_fpu()) {
2003     FloatRegister reg1 = opr1-&gt;as_double_reg();
2004     assert(opr2-&gt;is_double_fpu(), &quot;expect double float register&quot;);
2005     FloatRegister reg2 = opr2-&gt;as_double_reg();
2006     __ fcmpd(reg1, reg2);
2007   } else {
2008     ShouldNotReachHere();
2009   }
2010 }
2011 
2012 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
2013   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2014     bool is_unordered_less = (code == lir_ucmp_fd2i);
2015     if (left-&gt;is_single_fpu()) {
2016       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
2017     } else if (left-&gt;is_double_fpu()) {
2018       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
2019     } else {
2020       ShouldNotReachHere();
2021     }
2022   } else if (code == lir_cmp_l2i) {
2023     Label done;
2024     __ cmp(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2025     __ mov(dst-&gt;as_register(), (u_int64_t)-1L);
2026     __ br(Assembler::LT, done);
2027     __ csinc(dst-&gt;as_register(), zr, zr, Assembler::EQ);
2028     __ bind(done);
2029   } else {
2030     ShouldNotReachHere();
2031   }
2032 }
2033 
2034 
2035 void LIR_Assembler::align_call(LIR_Code code) {  }
2036 
2037 
2038 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2039   address call = __ trampoline_call(Address(op-&gt;addr(), rtype));
2040   if (call == NULL) {
2041     bailout(&quot;trampoline stub overflow&quot;);
2042     return;
2043   }
2044   add_call_info(code_offset(), op-&gt;info());
2045 }
2046 
2047 
2048 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2049   address call = __ ic_call(op-&gt;addr());
2050   if (call == NULL) {
2051     bailout(&quot;trampoline stub overflow&quot;);
2052     return;
2053   }
2054   add_call_info(code_offset(), op-&gt;info());
2055 }
2056 
2057 
2058 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2059 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2060   ShouldNotReachHere();
2061 }
2062 
2063 
2064 void LIR_Assembler::emit_static_call_stub() {
2065   address call_pc = __ pc();
2066   address stub = __ start_a_stub(call_stub_size());
2067   if (stub == NULL) {
2068     bailout(&quot;static call stub overflow&quot;);
2069     return;
2070   }
2071 
2072   int start = __ offset();
2073 
2074   __ relocate(static_stub_Relocation::spec(call_pc));
2075   __ emit_static_call_stub();
2076 
2077   assert(__ offset() - start + CompiledStaticCall::to_trampoline_stub_size()
2078         &lt;= call_stub_size(), &quot;stub too big&quot;);
2079   __ end_a_stub();
2080 }
2081 
2082 
2083 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2084   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2085   assert(exceptionPC-&gt;as_register() == r3, &quot;must match&quot;);
2086 
2087   // exception object is not added to oop map by LinearScan
2088   // (LinearScan assumes that no oops are in fixed registers)
2089   info-&gt;add_register_oop(exceptionOop);
2090   Runtime1::StubID unwind_id;
2091 
2092   // get current pc information
2093   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2094   int pc_for_athrow_offset = __ offset();
2095   InternalAddress pc_for_athrow(__ pc());
2096   __ adr(exceptionPC-&gt;as_register(), pc_for_athrow);
2097   add_call_info(pc_for_athrow_offset, info); // for exception handler
2098 
2099   __ verify_not_null_oop(r0);
2100   // search an exception handler (r0: exception oop, r3: throwing pc)
2101   if (compilation()-&gt;has_fpu_code()) {
2102     unwind_id = Runtime1::handle_exception_id;
2103   } else {
2104     unwind_id = Runtime1::handle_exception_nofpu_id;
2105   }
2106   __ far_call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2107 
2108   // FIXME: enough room for two byte trap   ????
2109   __ nop();
2110 }
2111 
2112 
2113 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
2114   assert(exceptionOop-&gt;as_register() == r0, &quot;must match&quot;);
2115 
2116   __ b(_unwind_handler_entry);
2117 }
2118 
2119 
2120 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2121   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2122   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2123 
2124   switch (left-&gt;type()) {
2125     case T_INT: {
2126       switch (code) {
2127       case lir_shl:  __ lslvw (dreg, lreg, count-&gt;as_register()); break;
2128       case lir_shr:  __ asrvw (dreg, lreg, count-&gt;as_register()); break;
2129       case lir_ushr: __ lsrvw (dreg, lreg, count-&gt;as_register()); break;
2130       default:
2131         ShouldNotReachHere();
2132         break;
2133       }
2134       break;
2135     case T_LONG:
2136     case T_ADDRESS:
2137     case T_OBJECT:
2138       switch (code) {
2139       case lir_shl:  __ lslv (dreg, lreg, count-&gt;as_register()); break;
2140       case lir_shr:  __ asrv (dreg, lreg, count-&gt;as_register()); break;
2141       case lir_ushr: __ lsrv (dreg, lreg, count-&gt;as_register()); break;
2142       default:
2143         ShouldNotReachHere();
2144         break;
2145       }
2146       break;
2147     default:
2148       ShouldNotReachHere();
2149       break;
2150     }
2151   }
2152 }
2153 
2154 
2155 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2156   Register dreg = dest-&gt;is_single_cpu() ? dest-&gt;as_register() : dest-&gt;as_register_lo();
2157   Register lreg = left-&gt;is_single_cpu() ? left-&gt;as_register() : left-&gt;as_register_lo();
2158 
2159   switch (left-&gt;type()) {
2160     case T_INT: {
2161       switch (code) {
2162       case lir_shl:  __ lslw (dreg, lreg, count); break;
2163       case lir_shr:  __ asrw (dreg, lreg, count); break;
2164       case lir_ushr: __ lsrw (dreg, lreg, count); break;
2165       default:
2166         ShouldNotReachHere();
2167         break;
2168       }
2169       break;
2170     case T_LONG:
2171     case T_ADDRESS:
2172     case T_OBJECT:
2173       switch (code) {
2174       case lir_shl:  __ lsl (dreg, lreg, count); break;
2175       case lir_shr:  __ asr (dreg, lreg, count); break;
2176       case lir_ushr: __ lsr (dreg, lreg, count); break;
2177       default:
2178         ShouldNotReachHere();
2179         break;
2180       }
2181       break;
2182     default:
2183       ShouldNotReachHere();
2184       break;
2185     }
2186   }
2187 }
2188 
2189 
2190 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
2191   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2192   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2193   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2194   __ str (r, Address(sp, offset_from_rsp_in_bytes));
2195 }
2196 
2197 
2198 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
2199   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2200   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2201   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2202   __ mov (rscratch1, c);
2203   __ str (rscratch1, Address(sp, offset_from_rsp_in_bytes));
2204 }
2205 
2206 
2207 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
2208   ShouldNotReachHere();
2209   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
2210   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
2211   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
2212   __ lea(rscratch1, __ constant_oop_address(o));
2213   __ str(rscratch1, Address(sp, offset_from_rsp_in_bytes));
2214 }
2215 
2216 
2217 // This code replaces a call to arraycopy; no exception may
2218 // be thrown in this code, they must be thrown in the System.arraycopy
2219 // activation frame; we could save some checks if this would not be the case
2220 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
2221   ciArrayKlass* default_type = op-&gt;expected_type();
2222   Register src = op-&gt;src()-&gt;as_register();
2223   Register dst = op-&gt;dst()-&gt;as_register();
2224   Register src_pos = op-&gt;src_pos()-&gt;as_register();
2225   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
2226   Register length  = op-&gt;length()-&gt;as_register();
2227   Register tmp = op-&gt;tmp()-&gt;as_register();
2228 
2229   __ resolve(ACCESS_READ, src);
2230   __ resolve(ACCESS_WRITE, dst);
2231 
2232   CodeStub* stub = op-&gt;stub();
2233   int flags = op-&gt;flags();
2234   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
2235   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
2236 
2237   // if we don&#39;t know anything, just go through the generic arraycopy
2238   if (default_type == NULL // || basic_type == T_OBJECT
2239       ) {
2240     Label done;
2241     assert(src == r1 &amp;&amp; src_pos == r2, &quot;mismatch in calling convention&quot;);
2242 
2243     // Save the arguments in case the generic arraycopy fails and we
2244     // have to fall back to the JNI stub
2245     __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2246     __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2247     __ str(src,              Address(sp, 4*BytesPerWord));
2248 
2249     address copyfunc_addr = StubRoutines::generic_arraycopy();
2250     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
2251 
2252     // The arguments are in java calling convention so we shift them
2253     // to C convention
2254     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
2255     __ mov(c_rarg0, j_rarg0);
2256     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
2257     __ mov(c_rarg1, j_rarg1);
2258     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
2259     __ mov(c_rarg2, j_rarg2);
2260     assert_different_registers(c_rarg3, j_rarg4);
2261     __ mov(c_rarg3, j_rarg3);
2262     __ mov(c_rarg4, j_rarg4);
2263 #ifndef PRODUCT
2264     if (PrintC1Statistics) {
2265       __ incrementw(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
2266     }
2267 #endif
2268     __ far_call(RuntimeAddress(copyfunc_addr));
2269 
2270     __ cbz(r0, *stub-&gt;continuation());
2271 
2272     // Reload values from the stack so they are where the stub
2273     // expects them.
2274     __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2275     __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2276     __ ldr(src,              Address(sp, 4*BytesPerWord));
2277 
2278     // r0 is -1^K where K == partial copied count
2279     __ eonw(rscratch1, r0, zr);
2280     // adjust length down and src/end pos up by partial copied count
2281     __ subw(length, length, rscratch1);
2282     __ addw(src_pos, src_pos, rscratch1);
2283     __ addw(dst_pos, dst_pos, rscratch1);
2284     __ b(*stub-&gt;entry());
2285 
2286     __ bind(*stub-&gt;continuation());
2287     return;
2288   }
2289 
2290   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
2291 
2292   int elem_size = type2aelembytes(basic_type);
2293   int shift_amount;
2294   int scale = exact_log2(elem_size);
2295 
2296   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
2297   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
2298   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
2299   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
2300 
2301   // test for NULL
2302   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
2303     __ cbz(src, *stub-&gt;entry());
2304   }
2305   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
2306     __ cbz(dst, *stub-&gt;entry());
2307   }
2308 
2309   // If the compiler was not able to prove that exact type of the source or the destination
2310   // of the arraycopy is an array type, check at runtime if the source or the destination is
2311   // an instance type.
2312   if (flags &amp; LIR_OpArrayCopy::type_check) {
2313     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
2314       __ load_klass(tmp, dst);
2315       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2316       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2317       __ br(Assembler::GE, *stub-&gt;entry());
2318     }
2319 
2320     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
2321       __ load_klass(tmp, src);
2322       __ ldrw(rscratch1, Address(tmp, in_bytes(Klass::layout_helper_offset())));
2323       __ cmpw(rscratch1, Klass::_lh_neutral_value);
2324       __ br(Assembler::GE, *stub-&gt;entry());
2325     }
2326   }
2327 
2328   // check if negative
2329   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
2330     __ cmpw(src_pos, 0);
2331     __ br(Assembler::LT, *stub-&gt;entry());
2332   }
2333   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
2334     __ cmpw(dst_pos, 0);
2335     __ br(Assembler::LT, *stub-&gt;entry());
2336   }
2337 
2338   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
2339     __ cmpw(length, 0);
2340     __ br(Assembler::LT, *stub-&gt;entry());
2341   }
2342 
2343   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
2344     __ addw(tmp, src_pos, length);
2345     __ ldrw(rscratch1, src_length_addr);
2346     __ cmpw(tmp, rscratch1);
2347     __ br(Assembler::HI, *stub-&gt;entry());
2348   }
2349   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
2350     __ addw(tmp, dst_pos, length);
2351     __ ldrw(rscratch1, dst_length_addr);
2352     __ cmpw(tmp, rscratch1);
2353     __ br(Assembler::HI, *stub-&gt;entry());
2354   }
2355 
2356   if (flags &amp; LIR_OpArrayCopy::type_check) {
2357     // We don&#39;t know the array types are compatible
2358     if (basic_type != T_OBJECT) {
2359       // Simple test for basic type arrays
2360       if (UseCompressedClassPointers) {
2361         __ ldrw(tmp, src_klass_addr);
2362         __ ldrw(rscratch1, dst_klass_addr);
2363         __ cmpw(tmp, rscratch1);
2364       } else {
2365         __ ldr(tmp, src_klass_addr);
2366         __ ldr(rscratch1, dst_klass_addr);
2367         __ cmp(tmp, rscratch1);
2368       }
2369       __ br(Assembler::NE, *stub-&gt;entry());
2370     } else {
2371       // For object arrays, if src is a sub class of dst then we can
2372       // safely do the copy.
2373       Label cont, slow;
2374 
2375 #define PUSH(r1, r2)                                    \
2376       stp(r1, r2, __ pre(sp, -2 * wordSize));
2377 
2378 #define POP(r1, r2)                                     \
2379       ldp(r1, r2, __ post(sp, 2 * wordSize));
2380 
2381       __ PUSH(src, dst);
2382 
2383       __ load_klass(src, src);
2384       __ load_klass(dst, dst);
2385 
2386       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
2387 
2388       __ PUSH(src, dst);
2389       __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
2390       __ POP(src, dst);
2391 
2392       __ cbnz(src, cont);
2393 
2394       __ bind(slow);
2395       __ POP(src, dst);
2396 
2397       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2398       if (copyfunc_addr != NULL) { // use stub if available
2399         // src is not a sub class of dst so we have to do a
2400         // per-element check.
2401 
2402         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2403         if ((flags &amp; mask) != mask) {
2404           // Check that at least both of them object arrays.
2405           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2406 
2407           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2408             __ load_klass(tmp, src);
2409           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2410             __ load_klass(tmp, dst);
2411           }
2412           int lh_offset = in_bytes(Klass::layout_helper_offset());
2413           Address klass_lh_addr(tmp, lh_offset);
2414           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2415           __ ldrw(rscratch1, klass_lh_addr);
2416           __ mov(rscratch2, objArray_lh);
2417           __ eorw(rscratch1, rscratch1, rscratch2);
2418           __ cbnzw(rscratch1, *stub-&gt;entry());
2419         }
2420 
2421        // Spill because stubs can use any register they like and it&#39;s
2422        // easier to restore just those that we care about.
2423         __ stp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2424         __ stp(length,  src_pos, Address(sp, 2*BytesPerWord));
2425         __ str(src,              Address(sp, 4*BytesPerWord));
2426 
2427         __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2428         __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2429         assert_different_registers(c_rarg0, dst, dst_pos, length);
2430         __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2431         __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2432         assert_different_registers(c_rarg1, dst, length);
2433         __ uxtw(c_rarg2, length);
2434         assert_different_registers(c_rarg2, dst);
2435 
2436         __ load_klass(c_rarg4, dst);
2437         __ ldr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
2438         __ ldrw(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
2439         __ far_call(RuntimeAddress(copyfunc_addr));
2440 
2441 #ifndef PRODUCT
2442         if (PrintC1Statistics) {
2443           Label failed;
2444           __ cbnz(r0, failed);
2445           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
2446           __ bind(failed);
2447         }
2448 #endif
2449 
2450         __ cbz(r0, *stub-&gt;continuation());
2451 
2452 #ifndef PRODUCT
2453         if (PrintC1Statistics) {
2454           __ incrementw(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
2455         }
2456 #endif
2457         assert_different_registers(dst, dst_pos, length, src_pos, src, r0, rscratch1);
2458 
2459         // Restore previously spilled arguments
2460         __ ldp(dst,     dst_pos, Address(sp, 0*BytesPerWord));
2461         __ ldp(length,  src_pos, Address(sp, 2*BytesPerWord));
2462         __ ldr(src,              Address(sp, 4*BytesPerWord));
2463 
2464         // return value is -1^K where K is partial copied count
2465         __ eonw(rscratch1, r0, zr);
2466         // adjust length down and src/end pos up by partial copied count
2467         __ subw(length, length, rscratch1);
2468         __ addw(src_pos, src_pos, rscratch1);
2469         __ addw(dst_pos, dst_pos, rscratch1);
2470       }
2471 
2472       __ b(*stub-&gt;entry());
2473 
2474       __ bind(cont);
2475       __ POP(src, dst);
2476     }
2477   }
2478 
2479 #ifdef ASSERT
2480   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2481     // Sanity check the known type with the incoming class.  For the
2482     // primitive case the types must match exactly with src.klass and
2483     // dst.klass each exactly matching the default type.  For the
2484     // object array case, if no type check is needed then either the
2485     // dst type is exactly the expected type and the src type is a
2486     // subtype which we can&#39;t check or src is the same array as dst
2487     // but not necessarily exactly of type default_type.
2488     Label known_ok, halt;
2489     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
2490     if (UseCompressedClassPointers) {
2491       __ encode_klass_not_null(tmp);
2492     }
2493 
2494     if (basic_type != T_OBJECT) {
2495 
2496       if (UseCompressedClassPointers) {
2497         __ ldrw(rscratch1, dst_klass_addr);
2498         __ cmpw(tmp, rscratch1);
2499       } else {
2500         __ ldr(rscratch1, dst_klass_addr);
2501         __ cmp(tmp, rscratch1);
2502       }
2503       __ br(Assembler::NE, halt);
2504       if (UseCompressedClassPointers) {
2505         __ ldrw(rscratch1, src_klass_addr);
2506         __ cmpw(tmp, rscratch1);
2507       } else {
2508         __ ldr(rscratch1, src_klass_addr);
2509         __ cmp(tmp, rscratch1);
2510       }
2511       __ br(Assembler::EQ, known_ok);
2512     } else {
2513       if (UseCompressedClassPointers) {
2514         __ ldrw(rscratch1, dst_klass_addr);
2515         __ cmpw(tmp, rscratch1);
2516       } else {
2517         __ ldr(rscratch1, dst_klass_addr);
2518         __ cmp(tmp, rscratch1);
2519       }
2520       __ br(Assembler::EQ, known_ok);
2521       __ cmp(src, dst);
2522       __ br(Assembler::EQ, known_ok);
2523     }
2524     __ bind(halt);
2525     __ stop(&quot;incorrect type information in arraycopy&quot;);
2526     __ bind(known_ok);
2527   }
2528 #endif
2529 
2530 #ifndef PRODUCT
2531   if (PrintC1Statistics) {
2532     __ incrementw(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
2533   }
2534 #endif
2535 
2536   __ lea(c_rarg0, Address(src, src_pos, Address::uxtw(scale)));
2537   __ add(c_rarg0, c_rarg0, arrayOopDesc::base_offset_in_bytes(basic_type));
2538   assert_different_registers(c_rarg0, dst, dst_pos, length);
2539   __ lea(c_rarg1, Address(dst, dst_pos, Address::uxtw(scale)));
2540   __ add(c_rarg1, c_rarg1, arrayOopDesc::base_offset_in_bytes(basic_type));
2541   assert_different_registers(c_rarg1, dst, length);
2542   __ uxtw(c_rarg2, length);
2543   assert_different_registers(c_rarg2, dst);
2544 
2545   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2546   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2547   const char *name;
2548   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2549 
2550  CodeBlob *cb = CodeCache::find_blob(entry);
2551  if (cb) {
2552    __ far_call(RuntimeAddress(entry));
2553  } else {
2554    __ call_VM_leaf(entry, 3);
2555  }
2556 
2557   __ bind(*stub-&gt;continuation());
2558 }
2559 
2560 
2561 
2562 
2563 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2564   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
2565   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2566   Register lock = op-&gt;lock_opr()-&gt;as_register();
2567   if (!UseFastLocking) {
2568     __ b(*op-&gt;stub()-&gt;entry());
2569   } else if (op-&gt;code() == lir_lock) {
2570     Register scratch = noreg;
2571     if (UseBiasedLocking) {
2572       scratch = op-&gt;scratch_opr()-&gt;as_register();
2573     }
2574     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2575     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
2576     // add debug info for NullPointerException only if one is possible
2577     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
2578     if (op-&gt;info() != NULL) {
2579       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
2580     }
2581     // done
2582   } else if (op-&gt;code() == lir_unlock) {
2583     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2584     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2585   } else {
2586     Unimplemented();
2587   }
2588   __ bind(*op-&gt;stub()-&gt;continuation());
2589 }
2590 
2591 
2592 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2593   ciMethod* method = op-&gt;profiled_method();
2594   int bci          = op-&gt;profiled_bci();
2595   ciMethod* callee = op-&gt;profiled_callee();
2596 
2597   // Update counter for all call types
2598   ciMethodData* md = method-&gt;method_data_or_null();
2599   assert(md != NULL, &quot;Sanity&quot;);
2600   ciProfileData* data = md-&gt;bci_to_data(bci);
2601   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2602   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2603   Register mdo  = op-&gt;mdo()-&gt;as_register();
2604   __ mov_metadata(mdo, md-&gt;constant_encoding());
2605   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
2606   // Perform additional virtual call profiling for invokevirtual and
2607   // invokeinterface bytecodes
2608   if (op-&gt;should_profile_receiver_type()) {
2609     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2610     Register recv = op-&gt;recv()-&gt;as_register();
2611     assert_different_registers(mdo, recv);
2612     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2613     ciKlass* known_klass = op-&gt;known_holder();
2614     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2615       // We know the type that will be seen at this call site; we can
2616       // statically update the MethodData* rather than needing to do
2617       // dynamic tests on the receiver type
2618 
2619       // NOTE: we should probably put a lock around this search to
2620       // avoid collisions by concurrent compilations
2621       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2622       uint i;
2623       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2624         ciKlass* receiver = vc_data-&gt;receiver(i);
2625         if (known_klass-&gt;equals(receiver)) {
2626           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2627           __ addptr(data_addr, DataLayout::counter_increment);
2628           return;
2629         }
2630       }
2631 
2632       // Receiver type not found in profile data; select an empty slot
2633 
2634       // Note that this is less efficient than it should be because it
2635       // always does a write to the receiver part of the
2636       // VirtualCallData rather than just the first time
2637       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2638         ciKlass* receiver = vc_data-&gt;receiver(i);
2639         if (receiver == NULL) {
2640           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
2641           __ mov_metadata(rscratch1, known_klass-&gt;constant_encoding());
2642           __ lea(rscratch2, recv_addr);
2643           __ str(rscratch1, Address(rscratch2));
2644           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
2645           __ addptr(data_addr, DataLayout::counter_increment);
2646           return;
2647         }
2648       }
2649     } else {
2650       __ load_klass(recv, recv);
2651       Label update_done;
2652       type_profile_helper(mdo, md, data, recv, &amp;update_done);
2653       // Receiver did not match any saved receiver and there is no empty row for it.
2654       // Increment total counter to indicate polymorphic case.
2655       __ addptr(counter_addr, DataLayout::counter_increment);
2656 
2657       __ bind(update_done);
2658     }
2659   } else {
2660     // Static call
2661     __ addptr(counter_addr, DataLayout::counter_increment);
2662   }
2663 }
2664 
2665 
2666 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
2667   Unimplemented();
2668 }
2669 
2670 
2671 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
2672   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
2673 }
2674 
2675 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2676   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2677   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2678   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2679   Register crc = op-&gt;crc()-&gt;as_register();
2680   Register val = op-&gt;val()-&gt;as_register();
2681   Register res = op-&gt;result_opr()-&gt;as_register();
2682 
2683   assert_different_registers(val, crc, res);
2684   unsigned long offset;
2685   __ adrp(res, ExternalAddress(StubRoutines::crc_table_addr()), offset);
2686   if (offset) __ add(res, res, offset);
2687 
2688   __ mvnw(crc, crc); // ~crc
2689   __ update_byte_crc32(crc, val, res);
2690   __ mvnw(res, crc); // ~crc
2691 }
2692 
2693 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2694   COMMENT(&quot;emit_profile_type {&quot;);
2695   Register obj = op-&gt;obj()-&gt;as_register();
2696   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
2697   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2698   ciKlass* exact_klass = op-&gt;exact_klass();
2699   intptr_t current_klass = op-&gt;current_klass();
2700   bool not_null = op-&gt;not_null();
2701   bool no_conflict = op-&gt;no_conflict();
2702 
2703   Label update, next, none;
2704 
2705   bool do_null = !not_null;
2706   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2707   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2708 
2709   assert(do_null || do_update, &quot;why are we here?&quot;);
2710   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2711   assert(mdo_addr.base() != rscratch1, &quot;wrong register&quot;);
2712 
2713   __ verify_oop(obj);
2714 
2715   if (tmp != obj) {
2716     __ mov(tmp, obj);
2717   }
2718   if (do_null) {
2719     __ cbnz(tmp, update);
2720     if (!TypeEntries::was_null_seen(current_klass)) {
2721       __ ldr(rscratch2, mdo_addr);
2722       __ orr(rscratch2, rscratch2, TypeEntries::null_seen);
2723       __ str(rscratch2, mdo_addr);
2724     }
2725     if (do_update) {
2726 #ifndef ASSERT
2727       __ b(next);
2728     }
2729 #else
2730       __ b(next);
2731     }
2732   } else {
2733     __ cbnz(tmp, update);
2734     __ stop(&quot;unexpected null obj&quot;);
2735 #endif
2736   }
2737 
2738   __ bind(update);
2739 
2740   if (do_update) {
2741 #ifdef ASSERT
2742     if (exact_klass != NULL) {
2743       Label ok;
2744       __ load_klass(tmp, tmp);
2745       __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2746       __ eor(rscratch1, tmp, rscratch1);
2747       __ cbz(rscratch1, ok);
2748       __ stop(&quot;exact klass and actual klass differ&quot;);
2749       __ bind(ok);
2750     }
2751 #endif
2752     if (!no_conflict) {
2753       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2754         if (exact_klass != NULL) {
2755           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2756         } else {
2757           __ load_klass(tmp, tmp);
2758         }
2759 
2760         __ ldr(rscratch2, mdo_addr);
2761         __ eor(tmp, tmp, rscratch2);
2762         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2763         // klass seen before, nothing to do. The unknown bit may have been
2764         // set already but no need to check.
2765         __ cbz(rscratch1, next);
2766 
2767         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2768 
2769         if (TypeEntries::is_type_none(current_klass)) {
2770           __ cbz(rscratch2, none);
2771           __ cmp(rscratch2, (u1)TypeEntries::null_seen);
2772           __ br(Assembler::EQ, none);
2773           // There is a chance that the checks above (re-reading profiling
2774           // data from memory) fail if another thread has just set the
2775           // profiling to this obj&#39;s klass
2776           __ dmb(Assembler::ISHLD);
2777           __ ldr(rscratch2, mdo_addr);
2778           __ eor(tmp, tmp, rscratch2);
2779           __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2780           __ cbz(rscratch1, next);
2781         }
2782       } else {
2783         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2784                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2785 
2786         __ ldr(tmp, mdo_addr);
2787         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2788       }
2789 
2790       // different than before. Cannot keep accurate profile.
2791       __ ldr(rscratch2, mdo_addr);
2792       __ orr(rscratch2, rscratch2, TypeEntries::type_unknown);
2793       __ str(rscratch2, mdo_addr);
2794 
2795       if (TypeEntries::is_type_none(current_klass)) {
2796         __ b(next);
2797 
2798         __ bind(none);
2799         // first time here. Set profile type.
2800         __ str(tmp, mdo_addr);
2801       }
2802     } else {
2803       // There&#39;s a single possible klass at this profile point
2804       assert(exact_klass != NULL, &quot;should be&quot;);
2805       if (TypeEntries::is_type_none(current_klass)) {
2806         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
2807         __ ldr(rscratch2, mdo_addr);
2808         __ eor(tmp, tmp, rscratch2);
2809         __ andr(rscratch1, tmp, TypeEntries::type_klass_mask);
2810         __ cbz(rscratch1, next);
2811 #ifdef ASSERT
2812         {
2813           Label ok;
2814           __ ldr(rscratch1, mdo_addr);
2815           __ cbz(rscratch1, ok);
2816           __ cmp(rscratch1, (u1)TypeEntries::null_seen);
2817           __ br(Assembler::EQ, ok);
2818           // may have been set by another thread
2819           __ dmb(Assembler::ISHLD);
2820           __ mov_metadata(rscratch1, exact_klass-&gt;constant_encoding());
2821           __ ldr(rscratch2, mdo_addr);
2822           __ eor(rscratch2, rscratch1, rscratch2);
2823           __ andr(rscratch2, rscratch2, TypeEntries::type_mask);
2824           __ cbz(rscratch2, ok);
2825 
2826           __ stop(&quot;unexpected profiling mismatch&quot;);
2827           __ bind(ok);
2828         }
2829 #endif
2830         // first time here. Set profile type.
2831         __ ldr(tmp, mdo_addr);
2832       } else {
2833         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2834                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2835 
2836         __ ldr(tmp, mdo_addr);
2837         __ tbnz(tmp, exact_log2(TypeEntries::type_unknown), next); // already unknown. Nothing to do anymore.
2838 
2839         __ orr(tmp, tmp, TypeEntries::type_unknown);
2840         __ str(tmp, mdo_addr);
2841         // FIXME: Write barrier needed here?
2842       }
2843     }
2844 
2845     __ bind(next);
2846   }
2847   COMMENT(&quot;} emit_profile_type&quot;);
2848 }
2849 
2850 
2851 void LIR_Assembler::align_backward_branch_target() {
2852 }
2853 
2854 
2855 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2856   // tmp must be unused
2857   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2858 
2859   if (left-&gt;is_single_cpu()) {
2860     assert(dest-&gt;is_single_cpu(), &quot;expect single result reg&quot;);
2861     __ negw(dest-&gt;as_register(), left-&gt;as_register());
2862   } else if (left-&gt;is_double_cpu()) {
2863     assert(dest-&gt;is_double_cpu(), &quot;expect double result reg&quot;);
2864     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2865   } else if (left-&gt;is_single_fpu()) {
2866     assert(dest-&gt;is_single_fpu(), &quot;expect single float result reg&quot;);
2867     __ fnegs(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2868   } else {
2869     assert(left-&gt;is_double_fpu(), &quot;expect double float operand reg&quot;);
2870     assert(dest-&gt;is_double_fpu(), &quot;expect double float result reg&quot;);
2871     __ fnegd(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2872   }
2873 }
2874 
2875 
2876 void LIR_Assembler::leal(LIR_Opr addr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2877   if (patch_code != lir_patch_none) {
2878     deoptimize_trap(info);
2879     return;
2880   }
2881 
2882   __ lea(dest-&gt;as_register_lo(), as_Address(addr-&gt;as_address_ptr()));
2883 }
2884 
2885 
2886 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2887   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
2888 
2889   CodeBlob *cb = CodeCache::find_blob(dest);
2890   if (cb) {
2891     __ far_call(RuntimeAddress(dest));
2892   } else {
2893     __ mov(rscratch1, RuntimeAddress(dest));
2894     __ blr(rscratch1);
2895   }
2896 
2897   if (info != NULL) {
2898     add_call_info_here(info);
2899   }
2900   __ maybe_isb();
2901 }
2902 
2903 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2904   if (dest-&gt;is_address() || src-&gt;is_address()) {
2905     move_op(src, dest, type, lir_patch_none, info,
2906             /*pop_fpu_stack*/false, /*unaligned*/false, /*wide*/false);
2907   } else {
2908     ShouldNotReachHere();
2909   }
2910 }
2911 
2912 #ifdef ASSERT
2913 // emit run-time assertion
2914 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2915   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
2916 
2917   if (op-&gt;in_opr1()-&gt;is_valid()) {
2918     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
2919     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
2920   } else {
2921     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
2922     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
2923   }
2924 
2925   Label ok;
2926   if (op-&gt;condition() != lir_cond_always) {
2927     Assembler::Condition acond = Assembler::AL;
2928     switch (op-&gt;condition()) {
2929       case lir_cond_equal:        acond = Assembler::EQ;  break;
2930       case lir_cond_notEqual:     acond = Assembler::NE;  break;
2931       case lir_cond_less:         acond = Assembler::LT;  break;
2932       case lir_cond_lessEqual:    acond = Assembler::LE;  break;
2933       case lir_cond_greaterEqual: acond = Assembler::GE;  break;
2934       case lir_cond_greater:      acond = Assembler::GT;  break;
2935       case lir_cond_belowEqual:   acond = Assembler::LS;  break;
2936       case lir_cond_aboveEqual:   acond = Assembler::HS;  break;
2937       default:                    ShouldNotReachHere();
2938     }
2939     __ br(acond, ok);
2940   }
2941   if (op-&gt;halt()) {
2942     const char* str = __ code_string(op-&gt;msg());
2943     __ stop(str);
2944   } else {
2945     breakpoint();
2946   }
2947   __ bind(ok);
2948 }
2949 #endif
2950 
2951 #ifndef PRODUCT
2952 #define COMMENT(x)   do { __ block_comment(x); } while (0)
2953 #else
2954 #define COMMENT(x)
2955 #endif
2956 
2957 void LIR_Assembler::membar() {
2958   COMMENT(&quot;membar&quot;);
2959   __ membar(MacroAssembler::AnyAny);
2960 }
2961 
2962 void LIR_Assembler::membar_acquire() {
2963   __ membar(Assembler::LoadLoad|Assembler::LoadStore);
2964 }
2965 
2966 void LIR_Assembler::membar_release() {
2967   __ membar(Assembler::LoadStore|Assembler::StoreStore);
2968 }
2969 
2970 void LIR_Assembler::membar_loadload() {
2971   __ membar(Assembler::LoadLoad);
2972 }
2973 
2974 void LIR_Assembler::membar_storestore() {
2975   __ membar(MacroAssembler::StoreStore);
2976 }
2977 
2978 void LIR_Assembler::membar_loadstore() { __ membar(MacroAssembler::LoadStore); }
2979 
2980 void LIR_Assembler::membar_storeload() { __ membar(MacroAssembler::StoreLoad); }
2981 
2982 void LIR_Assembler::on_spin_wait() {
2983   Unimplemented();
2984 }
2985 
2986 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2987   __ mov(result_reg-&gt;as_register(), rthread);
2988 }
2989 
2990 
2991 void LIR_Assembler::peephole(LIR_List *lir) {
2992 #if 0
2993   if (tableswitch_count &gt;= max_tableswitches)
2994     return;
2995 
2996   /*
2997     This finite-state automaton recognizes sequences of compare-and-
2998     branch instructions.  We will turn them into a tableswitch.  You
2999     could argue that C1 really shouldn&#39;t be doing this sort of
3000     optimization, but without it the code is really horrible.
3001   */
3002 
3003   enum { start_s, cmp1_s, beq_s, cmp_s } state;
3004   int first_key, last_key = -2147483648;
3005   int next_key = 0;
3006   int start_insn = -1;
3007   int last_insn = -1;
3008   Register reg = noreg;
3009   LIR_Opr reg_opr;
3010   state = start_s;
3011 
3012   LIR_OpList* inst = lir-&gt;instructions_list();
3013   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3014     LIR_Op* op = inst-&gt;at(i);
3015     switch (state) {
3016     case start_s:
3017       first_key = -1;
3018       start_insn = i;
3019       switch (op-&gt;code()) {
3020       case lir_cmp:
3021         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3022         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3023         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3024             &amp;&amp; opr2-&gt;is_constant()
3025             &amp;&amp; opr2-&gt;type() == T_INT) {
3026           reg_opr = opr1;
3027           reg = opr1-&gt;as_register();
3028           first_key = opr2-&gt;as_constant_ptr()-&gt;as_jint();
3029           next_key = first_key + 1;
3030           state = cmp_s;
3031           goto next_state;
3032         }
3033         break;
3034       }
3035       break;
3036     case cmp_s:
3037       switch (op-&gt;code()) {
3038       case lir_branch:
3039         if (op-&gt;as_OpBranch()-&gt;cond() == lir_cond_equal) {
3040           state = beq_s;
3041           last_insn = i;
3042           goto next_state;
3043         }
3044       }
3045       state = start_s;
3046       break;
3047     case beq_s:
3048       switch (op-&gt;code()) {
3049       case lir_cmp: {
3050         LIR_Opr opr1 = op-&gt;as_Op2()-&gt;in_opr1();
3051         LIR_Opr opr2 = op-&gt;as_Op2()-&gt;in_opr2();
3052         if (opr1-&gt;is_cpu_register() &amp;&amp; opr1-&gt;is_single_cpu()
3053             &amp;&amp; opr1-&gt;as_register() == reg
3054             &amp;&amp; opr2-&gt;is_constant()
3055             &amp;&amp; opr2-&gt;type() == T_INT
3056             &amp;&amp; opr2-&gt;as_constant_ptr()-&gt;as_jint() == next_key) {
3057           last_key = next_key;
3058           next_key++;
3059           state = cmp_s;
3060           goto next_state;
3061         }
3062       }
3063       }
3064       last_key = next_key;
3065       state = start_s;
3066       break;
3067     default:
3068       assert(false, &quot;impossible state&quot;);
3069     }
3070     if (state == start_s) {
3071       if (first_key &lt; last_key - 5L &amp;&amp; reg != noreg) {
3072         {
3073           // printf(&quot;found run register %d starting at insn %d low value %d high value %d\n&quot;,
3074           //        reg-&gt;encoding(),
3075           //        start_insn, first_key, last_key);
3076           //   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3077           //     inst-&gt;at(i)-&gt;print();
3078           //     tty-&gt;print(&quot;\n&quot;);
3079           //   }
3080           //   tty-&gt;print(&quot;\n&quot;);
3081         }
3082 
3083         struct tableswitch *sw = &amp;switches[tableswitch_count];
3084         sw-&gt;_insn_index = start_insn, sw-&gt;_first_key = first_key,
3085           sw-&gt;_last_key = last_key, sw-&gt;_reg = reg;
3086         inst-&gt;insert_before(last_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_after));
3087         {
3088           // Insert the new table of branches
3089           int offset = last_insn;
3090           for (int n = first_key; n &lt; last_key; n++) {
3091             inst-&gt;insert_before
3092               (last_insn + 1,
3093                new LIR_OpBranch(lir_cond_always, T_ILLEGAL,
3094                                 inst-&gt;at(offset)-&gt;as_OpBranch()-&gt;label()));
3095             offset -= 2, i++;
3096           }
3097         }
3098         // Delete all the old compare-and-branch instructions
3099         for (int n = first_key; n &lt; last_key; n++) {
3100           inst-&gt;remove_at(start_insn);
3101           inst-&gt;remove_at(start_insn);
3102         }
3103         // Insert the tableswitch instruction
3104         inst-&gt;insert_before(start_insn,
3105                             new LIR_Op2(lir_cmp, lir_cond_always,
3106                                         LIR_OprFact::intConst(tableswitch_count),
3107                                         reg_opr));
3108         inst-&gt;insert_before(start_insn + 1, new LIR_OpLabel(&amp;sw-&gt;_branches));
3109         tableswitch_count++;
3110       }
3111       reg = noreg;
3112       last_key = -2147483648;
3113     }
3114   next_state:
3115     ;
3116   }
3117 #endif
3118 }
3119 
3120 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp_op) {
3121   Address addr = as_Address(src-&gt;as_address_ptr());
3122   BasicType type = src-&gt;type();
3123   bool is_oop = is_reference_type(type);
3124 
3125   void (MacroAssembler::* add)(Register prev, RegisterOrConstant incr, Register addr);
3126   void (MacroAssembler::* xchg)(Register prev, Register newv, Register addr);
3127 
3128   switch(type) {
3129   case T_INT:
3130     xchg = &amp;MacroAssembler::atomic_xchgalw;
3131     add = &amp;MacroAssembler::atomic_addalw;
3132     break;
3133   case T_LONG:
3134     xchg = &amp;MacroAssembler::atomic_xchgal;
3135     add = &amp;MacroAssembler::atomic_addal;
3136     break;
3137   case T_OBJECT:
3138   case T_ARRAY:
3139     if (UseCompressedOops) {
3140       xchg = &amp;MacroAssembler::atomic_xchgalw;
3141       add = &amp;MacroAssembler::atomic_addalw;
3142     } else {
3143       xchg = &amp;MacroAssembler::atomic_xchgal;
3144       add = &amp;MacroAssembler::atomic_addal;
3145     }
3146     break;
3147   default:
3148     ShouldNotReachHere();
3149     xchg = &amp;MacroAssembler::atomic_xchgal;
3150     add = &amp;MacroAssembler::atomic_addal; // unreachable
3151   }
3152 
3153   switch (code) {
3154   case lir_xadd:
3155     {
3156       RegisterOrConstant inc;
3157       Register tmp = as_reg(tmp_op);
3158       Register dst = as_reg(dest);
3159       if (data-&gt;is_constant()) {
3160         inc = RegisterOrConstant(as_long(data));
3161         assert_different_registers(dst, addr.base(), tmp,
3162                                    rscratch1, rscratch2);
3163       } else {
3164         inc = RegisterOrConstant(as_reg(data));
3165         assert_different_registers(inc.as_register(), dst, addr.base(), tmp,
3166                                    rscratch1, rscratch2);
3167       }
3168       __ lea(tmp, addr);
3169       (_masm-&gt;*add)(dst, inc, tmp);
3170       break;
3171     }
3172   case lir_xchg:
3173     {
3174       Register tmp = tmp_op-&gt;as_register();
3175       Register obj = as_reg(data);
3176       Register dst = as_reg(dest);
3177       if (is_oop &amp;&amp; UseCompressedOops) {
3178         __ encode_heap_oop(rscratch2, obj);
3179         obj = rscratch2;
3180       }
3181       assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);
3182       __ lea(tmp, addr);
3183       (_masm-&gt;*xchg)(dst, obj, tmp);
3184       if (is_oop &amp;&amp; UseCompressedOops) {
3185         __ decode_heap_oop(dst);
3186       }
3187     }
3188     break;
3189   default:
3190     ShouldNotReachHere();
3191   }
3192   __ membar(__ AnyAny);
3193 }
3194 
3195 #undef __
    </pre>
  </body>
</html>
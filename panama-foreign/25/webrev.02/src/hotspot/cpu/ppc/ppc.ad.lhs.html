<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2012, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 //
   25 
   26 //
   27 // PPC64 Architecture Description File
   28 //
   29 
   30 //----------REGISTER DEFINITION BLOCK------------------------------------------
   31 // This information is used by the matcher and the register allocator to
   32 // describe individual registers and classes of registers within the target
   33 // architecture.
   34 register %{
   35 //----------Architecture Description Register Definitions----------------------
   36 // General Registers
   37 // &quot;reg_def&quot;  name (register save type, C convention save type,
   38 //                  ideal register type, encoding);
   39 //
   40 // Register Save Types:
   41 //
   42 //   NS  = No-Save:     The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method, &amp;
   44 //                      that they do not need to be saved at call sites.
   45 //
   46 //   SOC = Save-On-Call: The register allocator assumes that these registers
   47 //                      can be used without saving upon entry to the method,
   48 //                      but that they must be saved at call sites.
   49 //                      These are called &quot;volatiles&quot; on ppc.
   50 //
   51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, but they do not need to be saved at call
   54 //                      sites.
   55 //                      These are called &quot;nonvolatiles&quot; on ppc.
   56 //
   57 //   AS  = Always-Save:   The register allocator assumes that these registers
   58 //                      must be saved before using them upon entry to the
   59 //                      method, &amp; that they must be saved at call sites.
   60 //
   61 // Ideal Register Type is used to determine how to save &amp; restore a
   62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   64 //
   65 // The encoding number is the actual bit-pattern placed into the opcodes.
   66 //
   67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
   68 // Supplement Version 1.7 as of 2003-10-29.
   69 //
   70 // For each 64-bit register we must define two registers: the register
   71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   72 // e.g. R3_H, which is needed by the allocator, but is not used
   73 // for stores, loads, etc.
   74 
   75 // ----------------------------
   76 // Integer/Long Registers
   77 // ----------------------------
   78 
   79   // PPC64 has 32 64-bit integer registers.
   80 
   81   // types: v = volatile, nv = non-volatile, s = system
   82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
   83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
   84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
   85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
   86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
   87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
   88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
   89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
   90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
   91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
   92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
   93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
   94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
   95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
   96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
   97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
   98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
   99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
  100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
  101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
  102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
  103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
  104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
  105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
  106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
  107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
  108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
  109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
  110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
  111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
  112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
  113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
  114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
  115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
  116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
  117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
  118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
  119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
  120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
  121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
  122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
  123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
  124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
  125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
  126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
  127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
  128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
  129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
  130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
  131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
  132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
  133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
  134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
  135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
  136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
  137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
  138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
  139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
  140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
  141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
  142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
  143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
  144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
  145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
  146 
  147 
  148 // ----------------------------
  149 // Float/Double Registers
  150 // ----------------------------
  151 
  152   // Double Registers
  153   // The rules of ADL require that double registers be defined in pairs.
  154   // Each pair must be two 32-bit values, but not necessarily a pair of
  155   // single float registers. In each pair, ADLC-assigned register numbers
  156   // must be adjacent, with the lower number even. Finally, when the
  157   // CPU stores such a register pair to memory, the word associated with
  158   // the lower ADLC-assigned number must be stored to the lower address.
  159 
  160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
  161   // or double precision floating-point value.
  162 
  163   // types: v = volatile, nv = non-volatile, s = system
  164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
  165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
  166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
  167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
  168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
  169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
  170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
  171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
  172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
  173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
  174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
  175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
  176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
  177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
  178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
  179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
  180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
  181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
  182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
  183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
  184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
  185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
  186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
  187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
  188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
  189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
  190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
  191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
  192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
  193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
  194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
  195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
  196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
  197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
  198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
  199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
  200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
  201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
  202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
  203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
  204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
  205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
  206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
  207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
  208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
  209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
  210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
  211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
  212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
  213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
  214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
  215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
  216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
  217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
  218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
  219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
  220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
  221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
  222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
  223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
  224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
  225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
  226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
  227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
  228 
  229 // ----------------------------
  230 // Special Registers
  231 // ----------------------------
  232 
  233 // Condition Codes Flag Registers
  234 
  235   // PPC64 has 8 condition code &quot;registers&quot; which are all contained
  236   // in the CR register.
  237 
  238   // types: v = volatile, nv = non-volatile, s = system
  239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
  240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
  241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
  242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
  243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
  244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
  245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
  246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
  247 
  248   // Special registers of PPC64
  249 
  250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
  251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
  252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
  253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
  254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
  255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
  256 
  257 // ----------------------------
  258 // Vector-Scalar Registers
  259 // ----------------------------
  260   reg_def VSR0 ( SOC, SOC, Op_VecX, 0, NULL);
  261   reg_def VSR1 ( SOC, SOC, Op_VecX, 1, NULL);
  262   reg_def VSR2 ( SOC, SOC, Op_VecX, 2, NULL);
  263   reg_def VSR3 ( SOC, SOC, Op_VecX, 3, NULL);
  264   reg_def VSR4 ( SOC, SOC, Op_VecX, 4, NULL);
  265   reg_def VSR5 ( SOC, SOC, Op_VecX, 5, NULL);
  266   reg_def VSR6 ( SOC, SOC, Op_VecX, 6, NULL);
  267   reg_def VSR7 ( SOC, SOC, Op_VecX, 7, NULL);
  268   reg_def VSR8 ( SOC, SOC, Op_VecX, 8, NULL);
  269   reg_def VSR9 ( SOC, SOC, Op_VecX, 9, NULL);
  270   reg_def VSR10 ( SOC, SOC, Op_VecX, 10, NULL);
  271   reg_def VSR11 ( SOC, SOC, Op_VecX, 11, NULL);
  272   reg_def VSR12 ( SOC, SOC, Op_VecX, 12, NULL);
  273   reg_def VSR13 ( SOC, SOC, Op_VecX, 13, NULL);
  274   reg_def VSR14 ( SOC, SOC, Op_VecX, 14, NULL);
  275   reg_def VSR15 ( SOC, SOC, Op_VecX, 15, NULL);
  276   reg_def VSR16 ( SOC, SOC, Op_VecX, 16, NULL);
  277   reg_def VSR17 ( SOC, SOC, Op_VecX, 17, NULL);
  278   reg_def VSR18 ( SOC, SOC, Op_VecX, 18, NULL);
  279   reg_def VSR19 ( SOC, SOC, Op_VecX, 19, NULL);
  280   reg_def VSR20 ( SOC, SOC, Op_VecX, 20, NULL);
  281   reg_def VSR21 ( SOC, SOC, Op_VecX, 21, NULL);
  282   reg_def VSR22 ( SOC, SOC, Op_VecX, 22, NULL);
  283   reg_def VSR23 ( SOC, SOC, Op_VecX, 23, NULL);
  284   reg_def VSR24 ( SOC, SOC, Op_VecX, 24, NULL);
  285   reg_def VSR25 ( SOC, SOC, Op_VecX, 25, NULL);
  286   reg_def VSR26 ( SOC, SOC, Op_VecX, 26, NULL);
  287   reg_def VSR27 ( SOC, SOC, Op_VecX, 27, NULL);
  288   reg_def VSR28 ( SOC, SOC, Op_VecX, 28, NULL);
  289   reg_def VSR29 ( SOC, SOC, Op_VecX, 29, NULL);
  290   reg_def VSR30 ( SOC, SOC, Op_VecX, 30, NULL);
  291   reg_def VSR31 ( SOC, SOC, Op_VecX, 31, NULL);
  292   reg_def VSR32 ( SOC, SOC, Op_VecX, 32, NULL);
  293   reg_def VSR33 ( SOC, SOC, Op_VecX, 33, NULL);
  294   reg_def VSR34 ( SOC, SOC, Op_VecX, 34, NULL);
  295   reg_def VSR35 ( SOC, SOC, Op_VecX, 35, NULL);
  296   reg_def VSR36 ( SOC, SOC, Op_VecX, 36, NULL);
  297   reg_def VSR37 ( SOC, SOC, Op_VecX, 37, NULL);
  298   reg_def VSR38 ( SOC, SOC, Op_VecX, 38, NULL);
  299   reg_def VSR39 ( SOC, SOC, Op_VecX, 39, NULL);
  300   reg_def VSR40 ( SOC, SOC, Op_VecX, 40, NULL);
  301   reg_def VSR41 ( SOC, SOC, Op_VecX, 41, NULL);
  302   reg_def VSR42 ( SOC, SOC, Op_VecX, 42, NULL);
  303   reg_def VSR43 ( SOC, SOC, Op_VecX, 43, NULL);
  304   reg_def VSR44 ( SOC, SOC, Op_VecX, 44, NULL);
  305   reg_def VSR45 ( SOC, SOC, Op_VecX, 45, NULL);
  306   reg_def VSR46 ( SOC, SOC, Op_VecX, 46, NULL);
  307   reg_def VSR47 ( SOC, SOC, Op_VecX, 47, NULL);
  308   reg_def VSR48 ( SOC, SOC, Op_VecX, 48, NULL);
  309   reg_def VSR49 ( SOC, SOC, Op_VecX, 49, NULL);
  310   reg_def VSR50 ( SOC, SOC, Op_VecX, 50, NULL);
  311   reg_def VSR51 ( SOC, SOC, Op_VecX, 51, NULL);
  312   reg_def VSR52 ( SOC, SOC, Op_VecX, 52, NULL);
  313   reg_def VSR53 ( SOC, SOC, Op_VecX, 53, NULL);
  314   reg_def VSR54 ( SOC, SOC, Op_VecX, 54, NULL);
  315   reg_def VSR55 ( SOC, SOC, Op_VecX, 55, NULL);
  316   reg_def VSR56 ( SOC, SOC, Op_VecX, 56, NULL);
  317   reg_def VSR57 ( SOC, SOC, Op_VecX, 57, NULL);
  318   reg_def VSR58 ( SOC, SOC, Op_VecX, 58, NULL);
  319   reg_def VSR59 ( SOC, SOC, Op_VecX, 59, NULL);
  320   reg_def VSR60 ( SOC, SOC, Op_VecX, 60, NULL);
  321   reg_def VSR61 ( SOC, SOC, Op_VecX, 61, NULL);
  322   reg_def VSR62 ( SOC, SOC, Op_VecX, 62, NULL);
  323   reg_def VSR63 ( SOC, SOC, Op_VecX, 63, NULL);
  324 
  325 // ----------------------------
  326 // Specify priority of register selection within phases of register
  327 // allocation. Highest priority is first. A useful heuristic is to
  328 // give registers a low priority when they are required by machine
  329 // instructions, like EAX and EDX on I486, and choose no-save registers
  330 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
  331 // which participate in fixed calling sequences should come last.
  332 // Registers which are used as pairs must fall on an even boundary.
  333 
  334 // It&#39;s worth about 1% on SPEC geomean to get this right.
  335 
  336 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  337 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
  338 // R3_num. Therefore, R3_num may not be (and in reality is not)
  339 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
  340 // assumptions on ordering, e.g. R3_num may be less than R2_num.
  341 // Additionally, the function
  342 //   static enum RC rc_class(OptoReg::Name reg )
  343 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  344 // and its current implementation relies on chunk0 and chunk1 having a
  345 // size of 64 each.
  346 
  347 // If you change this allocation class, please have a look at the
  348 // default values for the parameters RoundRobinIntegerRegIntervalStart
  349 // and RoundRobinFloatRegIntervalStart
  350 
  351 alloc_class chunk0 (
  352   // Chunk0 contains *all* 64 integer registers halves.
  353 
  354   // &quot;non-volatile&quot; registers
  355   R14, R14_H,
  356   R15, R15_H,
  357   R17, R17_H,
  358   R18, R18_H,
  359   R19, R19_H,
  360   R20, R20_H,
  361   R21, R21_H,
  362   R22, R22_H,
  363   R23, R23_H,
  364   R24, R24_H,
  365   R25, R25_H,
  366   R26, R26_H,
  367   R27, R27_H,
  368   R28, R28_H,
  369   R29, R29_H,
  370   R30, R30_H,
  371   R31, R31_H,
  372 
  373   // scratch/special registers
  374   R11, R11_H,
  375   R12, R12_H,
  376 
  377   // argument registers
  378   R10, R10_H,
  379   R9,  R9_H,
  380   R8,  R8_H,
  381   R7,  R7_H,
  382   R6,  R6_H,
  383   R5,  R5_H,
  384   R4,  R4_H,
  385   R3,  R3_H,
  386 
  387   // special registers, not available for allocation
  388   R16, R16_H,     // R16_thread
  389   R13, R13_H,     // system thread id
  390   R2,  R2_H,      // may be used for TOC
  391   R1,  R1_H,      // SP
  392   R0,  R0_H       // R0 (scratch)
  393 );
  394 
  395 // If you change this allocation class, please have a look at the
  396 // default values for the parameters RoundRobinIntegerRegIntervalStart
  397 // and RoundRobinFloatRegIntervalStart
  398 
  399 alloc_class chunk1 (
  400   // Chunk1 contains *all* 64 floating-point registers halves.
  401 
  402   // scratch register
  403   F0,  F0_H,
  404 
  405   // argument registers
  406   F13, F13_H,
  407   F12, F12_H,
  408   F11, F11_H,
  409   F10, F10_H,
  410   F9,  F9_H,
  411   F8,  F8_H,
  412   F7,  F7_H,
  413   F6,  F6_H,
  414   F5,  F5_H,
  415   F4,  F4_H,
  416   F3,  F3_H,
  417   F2,  F2_H,
  418   F1,  F1_H,
  419 
  420   // non-volatile registers
  421   F14, F14_H,
  422   F15, F15_H,
  423   F16, F16_H,
  424   F17, F17_H,
  425   F18, F18_H,
  426   F19, F19_H,
  427   F20, F20_H,
  428   F21, F21_H,
  429   F22, F22_H,
  430   F23, F23_H,
  431   F24, F24_H,
  432   F25, F25_H,
  433   F26, F26_H,
  434   F27, F27_H,
  435   F28, F28_H,
  436   F29, F29_H,
  437   F30, F30_H,
  438   F31, F31_H
  439 );
  440 
  441 alloc_class chunk2 (
  442   // Chunk2 contains *all* 8 condition code registers.
  443 
  444   CCR0,
  445   CCR1,
  446   CCR2,
  447   CCR3,
  448   CCR4,
  449   CCR5,
  450   CCR6,
  451   CCR7
  452 );
  453 
  454 alloc_class chunk3 (
  455   VSR0,
  456   VSR1,
  457   VSR2,
  458   VSR3,
  459   VSR4,
  460   VSR5,
  461   VSR6,
  462   VSR7,
  463   VSR8,
  464   VSR9,
  465   VSR10,
  466   VSR11,
  467   VSR12,
  468   VSR13,
  469   VSR14,
  470   VSR15,
  471   VSR16,
  472   VSR17,
  473   VSR18,
  474   VSR19,
  475   VSR20,
  476   VSR21,
  477   VSR22,
  478   VSR23,
  479   VSR24,
  480   VSR25,
  481   VSR26,
  482   VSR27,
  483   VSR28,
  484   VSR29,
  485   VSR30,
  486   VSR31,
  487   VSR32,
  488   VSR33,
  489   VSR34,
  490   VSR35,
  491   VSR36,
  492   VSR37,
  493   VSR38,
  494   VSR39,
  495   VSR40,
  496   VSR41,
  497   VSR42,
  498   VSR43,
  499   VSR44,
  500   VSR45,
  501   VSR46,
  502   VSR47,
  503   VSR48,
  504   VSR49,
  505   VSR50,
  506   VSR51,
  507   VSR52,
  508   VSR53,
  509   VSR54,
  510   VSR55,
  511   VSR56,
  512   VSR57,
  513   VSR58,
  514   VSR59,
  515   VSR60,
  516   VSR61,
  517   VSR62,
  518   VSR63
  519 );
  520 
  521 alloc_class chunk4 (
  522   // special registers
  523   // These registers are not allocated, but used for nodes generated by postalloc expand.
  524   SR_XER,
  525   SR_LR,
  526   SR_CTR,
  527   SR_VRSAVE,
  528   SR_SPEFSCR,
  529   SR_PPR
  530 );
  531 
  532 //-------Architecture Description Register Classes-----------------------
  533 
  534 // Several register classes are automatically defined based upon
  535 // information in this architecture description.
  536 
  537 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  538 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
  539 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  540 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  541 //
  542 
  543 // ----------------------------
  544 // 32 Bit Register Classes
  545 // ----------------------------
  546 
  547 // We specify registers twice, once as read/write, and once read-only.
  548 // We use the read-only registers for source operands. With this, we
  549 // can include preset read only registers in this class, as a hard-coded
  550 // &#39;0&#39;-register. (We used to simulate this on ppc.)
  551 
  552 // 32 bit registers that can be read and written i.e. these registers
  553 // can be dest (or src) of normal instructions.
  554 reg_class bits32_reg_rw(
  555 /*R0*/              // R0
  556 /*R1*/              // SP
  557   R2,               // TOC
  558   R3,
  559   R4,
  560   R5,
  561   R6,
  562   R7,
  563   R8,
  564   R9,
  565   R10,
  566   R11,
  567   R12,
  568 /*R13*/             // system thread id
  569   R14,
  570   R15,
  571 /*R16*/             // R16_thread
  572   R17,
  573   R18,
  574   R19,
  575   R20,
  576   R21,
  577   R22,
  578   R23,
  579   R24,
  580   R25,
  581   R26,
  582   R27,
  583   R28,
  584 /*R29,*/             // global TOC
  585   R30,
  586   R31
  587 );
  588 
  589 // 32 bit registers that can only be read i.e. these registers can
  590 // only be src of all instructions.
  591 reg_class bits32_reg_ro(
  592 /*R0*/              // R0
  593 /*R1*/              // SP
  594   R2                // TOC
  595   R3,
  596   R4,
  597   R5,
  598   R6,
  599   R7,
  600   R8,
  601   R9,
  602   R10,
  603   R11,
  604   R12,
  605 /*R13*/             // system thread id
  606   R14,
  607   R15,
  608 /*R16*/             // R16_thread
  609   R17,
  610   R18,
  611   R19,
  612   R20,
  613   R21,
  614   R22,
  615   R23,
  616   R24,
  617   R25,
  618   R26,
  619   R27,
  620   R28,
  621 /*R29,*/
  622   R30,
  623   R31
  624 );
  625 
  626 reg_class rscratch1_bits32_reg(R11);
  627 reg_class rscratch2_bits32_reg(R12);
  628 reg_class rarg1_bits32_reg(R3);
  629 reg_class rarg2_bits32_reg(R4);
  630 reg_class rarg3_bits32_reg(R5);
  631 reg_class rarg4_bits32_reg(R6);
  632 
  633 // ----------------------------
  634 // 64 Bit Register Classes
  635 // ----------------------------
  636 // 64-bit build means 64-bit pointers means hi/lo pairs
  637 
  638 reg_class rscratch1_bits64_reg(R11_H, R11);
  639 reg_class rscratch2_bits64_reg(R12_H, R12);
  640 reg_class rarg1_bits64_reg(R3_H, R3);
  641 reg_class rarg2_bits64_reg(R4_H, R4);
  642 reg_class rarg3_bits64_reg(R5_H, R5);
  643 reg_class rarg4_bits64_reg(R6_H, R6);
  644 // Thread register, &#39;written&#39; by tlsLoadP, see there.
  645 reg_class thread_bits64_reg(R16_H, R16);
  646 
  647 reg_class r19_bits64_reg(R19_H, R19);
  648 
  649 // 64 bit registers that can be read and written i.e. these registers
  650 // can be dest (or src) of normal instructions.
  651 reg_class bits64_reg_rw(
  652 /*R0_H,  R0*/     // R0
  653 /*R1_H,  R1*/     // SP
  654   R2_H,  R2,      // TOC
  655   R3_H,  R3,
  656   R4_H,  R4,
  657   R5_H,  R5,
  658   R6_H,  R6,
  659   R7_H,  R7,
  660   R8_H,  R8,
  661   R9_H,  R9,
  662   R10_H, R10,
  663   R11_H, R11,
  664   R12_H, R12,
  665 /*R13_H, R13*/   // system thread id
  666   R14_H, R14,
  667   R15_H, R15,
  668 /*R16_H, R16*/   // R16_thread
  669   R17_H, R17,
  670   R18_H, R18,
  671   R19_H, R19,
  672   R20_H, R20,
  673   R21_H, R21,
  674   R22_H, R22,
  675   R23_H, R23,
  676   R24_H, R24,
  677   R25_H, R25,
  678   R26_H, R26,
  679   R27_H, R27,
  680   R28_H, R28,
  681 /*R29_H, R29,*/
  682   R30_H, R30,
  683   R31_H, R31
  684 );
  685 
  686 // 64 bit registers used excluding r2, r11 and r12
  687 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
  688 // r2, r11 and r12 internally.
  689 reg_class bits64_reg_leaf_call(
  690 /*R0_H,  R0*/     // R0
  691 /*R1_H,  R1*/     // SP
  692 /*R2_H,  R2*/     // TOC
  693   R3_H,  R3,
  694   R4_H,  R4,
  695   R5_H,  R5,
  696   R6_H,  R6,
  697   R7_H,  R7,
  698   R8_H,  R8,
  699   R9_H,  R9,
  700   R10_H, R10,
  701 /*R11_H, R11*/
  702 /*R12_H, R12*/
  703 /*R13_H, R13*/   // system thread id
  704   R14_H, R14,
  705   R15_H, R15,
  706 /*R16_H, R16*/   // R16_thread
  707   R17_H, R17,
  708   R18_H, R18,
  709   R19_H, R19,
  710   R20_H, R20,
  711   R21_H, R21,
  712   R22_H, R22,
  713   R23_H, R23,
  714   R24_H, R24,
  715   R25_H, R25,
  716   R26_H, R26,
  717   R27_H, R27,
  718   R28_H, R28,
  719 /*R29_H, R29,*/
  720   R30_H, R30,
  721   R31_H, R31
  722 );
  723 
  724 // Used to hold the TOC to avoid collisions with expanded DynamicCall
  725 // which uses r19 as inline cache internally and expanded LeafCall which uses
  726 // r2, r11 and r12 internally.
  727 reg_class bits64_constant_table_base(
  728 /*R0_H,  R0*/     // R0
  729 /*R1_H,  R1*/     // SP
  730 /*R2_H,  R2*/     // TOC
  731   R3_H,  R3,
  732   R4_H,  R4,
  733   R5_H,  R5,
  734   R6_H,  R6,
  735   R7_H,  R7,
  736   R8_H,  R8,
  737   R9_H,  R9,
  738   R10_H, R10,
  739 /*R11_H, R11*/
  740 /*R12_H, R12*/
  741 /*R13_H, R13*/   // system thread id
  742   R14_H, R14,
  743   R15_H, R15,
  744 /*R16_H, R16*/   // R16_thread
  745   R17_H, R17,
  746   R18_H, R18,
  747 /*R19_H, R19*/
  748   R20_H, R20,
  749   R21_H, R21,
  750   R22_H, R22,
  751   R23_H, R23,
  752   R24_H, R24,
  753   R25_H, R25,
  754   R26_H, R26,
  755   R27_H, R27,
  756   R28_H, R28,
  757 /*R29_H, R29,*/
  758   R30_H, R30,
  759   R31_H, R31
  760 );
  761 
  762 // 64 bit registers that can only be read i.e. these registers can
  763 // only be src of all instructions.
  764 reg_class bits64_reg_ro(
  765 /*R0_H,  R0*/     // R0
  766   R1_H,  R1,
  767   R2_H,  R2,       // TOC
  768   R3_H,  R3,
  769   R4_H,  R4,
  770   R5_H,  R5,
  771   R6_H,  R6,
  772   R7_H,  R7,
  773   R8_H,  R8,
  774   R9_H,  R9,
  775   R10_H, R10,
  776   R11_H, R11,
  777   R12_H, R12,
  778 /*R13_H, R13*/   // system thread id
  779   R14_H, R14,
  780   R15_H, R15,
  781   R16_H, R16,    // R16_thread
  782   R17_H, R17,
  783   R18_H, R18,
  784   R19_H, R19,
  785   R20_H, R20,
  786   R21_H, R21,
  787   R22_H, R22,
  788   R23_H, R23,
  789   R24_H, R24,
  790   R25_H, R25,
  791   R26_H, R26,
  792   R27_H, R27,
  793   R28_H, R28,
  794 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
  795   R30_H, R30,
  796   R31_H, R31
  797 );
  798 
  799 
  800 // ----------------------------
  801 // Special Class for Condition Code Flags Register
  802 
  803 reg_class int_flags(
  804 /*CCR0*/             // scratch
  805 /*CCR1*/             // scratch
  806 /*CCR2*/             // nv!
  807 /*CCR3*/             // nv!
  808 /*CCR4*/             // nv!
  809   CCR5,
  810   CCR6,
  811   CCR7
  812 );
  813 
  814 reg_class int_flags_ro(
  815   CCR0,
  816   CCR1,
  817   CCR2,
  818   CCR3,
  819   CCR4,
  820   CCR5,
  821   CCR6,
  822   CCR7
  823 );
  824 
  825 reg_class int_flags_CR0(CCR0);
  826 reg_class int_flags_CR1(CCR1);
  827 reg_class int_flags_CR6(CCR6);
  828 reg_class ctr_reg(SR_CTR);
  829 
  830 // ----------------------------
  831 // Float Register Classes
  832 // ----------------------------
  833 
  834 reg_class flt_reg(
  835   F0,
  836   F1,
  837   F2,
  838   F3,
  839   F4,
  840   F5,
  841   F6,
  842   F7,
  843   F8,
  844   F9,
  845   F10,
  846   F11,
  847   F12,
  848   F13,
  849   F14,              // nv!
  850   F15,              // nv!
  851   F16,              // nv!
  852   F17,              // nv!
  853   F18,              // nv!
  854   F19,              // nv!
  855   F20,              // nv!
  856   F21,              // nv!
  857   F22,              // nv!
  858   F23,              // nv!
  859   F24,              // nv!
  860   F25,              // nv!
  861   F26,              // nv!
  862   F27,              // nv!
  863   F28,              // nv!
  864   F29,              // nv!
  865   F30,              // nv!
  866   F31               // nv!
  867 );
  868 
  869 // Double precision float registers have virtual `high halves&#39; that
  870 // are needed by the allocator.
  871 reg_class dbl_reg(
  872   F0,  F0_H,
  873   F1,  F1_H,
  874   F2,  F2_H,
  875   F3,  F3_H,
  876   F4,  F4_H,
  877   F5,  F5_H,
  878   F6,  F6_H,
  879   F7,  F7_H,
  880   F8,  F8_H,
  881   F9,  F9_H,
  882   F10, F10_H,
  883   F11, F11_H,
  884   F12, F12_H,
  885   F13, F13_H,
  886   F14, F14_H,    // nv!
  887   F15, F15_H,    // nv!
  888   F16, F16_H,    // nv!
  889   F17, F17_H,    // nv!
  890   F18, F18_H,    // nv!
  891   F19, F19_H,    // nv!
  892   F20, F20_H,    // nv!
  893   F21, F21_H,    // nv!
  894   F22, F22_H,    // nv!
  895   F23, F23_H,    // nv!
  896   F24, F24_H,    // nv!
  897   F25, F25_H,    // nv!
  898   F26, F26_H,    // nv!
  899   F27, F27_H,    // nv!
  900   F28, F28_H,    // nv!
  901   F29, F29_H,    // nv!
  902   F30, F30_H,    // nv!
  903   F31, F31_H     // nv!
  904 );
  905 
  906 // ----------------------------
  907 // Vector-Scalar Register Class
  908 // ----------------------------
  909 
  910 reg_class vs_reg(
  911   // Attention: Only these ones are saved &amp; restored at safepoint by RegisterSaver.
  912   VSR32,
  913   VSR33,
  914   VSR34,
  915   VSR35,
  916   VSR36,
  917   VSR37,
  918   VSR38,
  919   VSR39,
  920   VSR40,
  921   VSR41,
  922   VSR42,
  923   VSR43,
  924   VSR44,
  925   VSR45,
  926   VSR46,
  927   VSR47,
  928   VSR48,
  929   VSR49,
  930   VSR50,
  931   VSR51
  932   // VSR52-VSR63 // nv!
  933 );
  934 
  935  %}
  936 
  937 //----------DEFINITION BLOCK---------------------------------------------------
  938 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  939 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  940 // Format:
  941 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  942 // Generated Code in ad_&lt;arch&gt;.hpp
  943 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  944 //        // value == &lt;int_value&gt;
  945 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  946 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  947 //
  948 definitions %{
  949   // The default cost (of an ALU instruction).
  950   int_def DEFAULT_COST_LOW        (     30,      30);
  951   int_def DEFAULT_COST            (    100,     100);
  952   int_def HUGE_COST               (1000000, 1000000);
  953 
  954   // Memory refs
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
  975 #include &quot;opto/convertnode.hpp&quot;
  976 
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
  985 // Should the Matcher clone shifts on addressing modes, expecting them
  986 // to be subsumed into complex addressing expressions or compute them
  987 // into registers?
  988 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
  989   return clone_base_plus_offset_address(m, mstack, address_visited);
  990 }
  991 
  992 void Compile::reshape_address(AddPNode* addp) {
  993 }
  994 
  995 // Optimize load-acquire.
  996 //
  997 // Check if acquire is unnecessary due to following operation that does
  998 // acquire anyways.
  999 // Walk the pattern:
 1000 //
 1001 //      n: Load.acq
 1002 //           |
 1003 //      MemBarAcquire
 1004 //       |         |
 1005 //  Proj(ctrl)  Proj(mem)
 1006 //       |         |
 1007 //   MemBarRelease/Volatile
 1008 //
 1009 bool followed_by_acquire(const Node *load) {
 1010   assert(load-&gt;is_Load(), &quot;So far implemented only for loads.&quot;);
 1011 
 1012   // Find MemBarAcquire.
 1013   const Node *mba = NULL;
 1014   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 1015     const Node *out = load-&gt;fast_out(i);
 1016     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 1017       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 1018       mba = out;
 1019       break;
 1020     }
 1021   }
 1022   if (!mba) return false;
 1023 
 1024   // Find following MemBar node.
 1025   //
 1026   // The following node must be reachable by control AND memory
 1027   // edge to assure no other operations are in between the two nodes.
 1028   //
 1029   // So first get the Proj node, mem_proj, to use it to iterate forward.
 1030   Node *mem_proj = NULL;
 1031   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 1032     mem_proj = mba-&gt;fast_out(i);      // Runs out of bounds and asserts if Proj not found.
 1033     assert(mem_proj-&gt;is_Proj(), &quot;only projections here&quot;);
 1034     ProjNode *proj = mem_proj-&gt;as_Proj();
 1035     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 1036         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 1037       break;
 1038   }
 1039   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, &quot;Graph broken&quot;);
 1040 
 1041   // Search MemBar behind Proj. If there are other memory operations
 1042   // behind the Proj we lost.
 1043   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 1044     Node *x = mem_proj-&gt;fast_out(j);
 1045     // Proj might have an edge to a store or load node which precedes the membar.
 1046     if (x-&gt;is_Mem()) return false;
 1047 
 1048     // On PPC64 release and volatile are implemented by an instruction
 1049     // that also has acquire semantics. I.e. there is no need for an
 1050     // acquire before these.
 1051     int xop = x-&gt;Opcode();
 1052     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 1053       // Make sure we&#39;re not missing Call/Phi/MergeMem by checking
 1054       // control edges. The control edge must directly lead back
 1055       // to the MemBarAcquire
 1056       Node *ctrl_proj = x-&gt;in(0);
 1057       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 1058         return true;
 1059       }
 1060     }
 1061   }
 1062 
 1063   return false;
 1064 }
 1065 
 1066 #define __ _masm.
 1067 
 1068 // Tertiary op of a LoadP or StoreP encoding.
 1069 #define REGP_OP true
 1070 
 1071 // ****************************************************************************
 1072 
 1073 // REQUIRED FUNCTIONALITY
 1074 
 1075 // !!!!! Special hack to get all type of calls to specify the byte offset
 1076 //       from the start of the call to the point where the return address
 1077 //       will point.
 1078 
 1079 // PPC port: Removed use of lazy constant construct.
 1080 
 1081 int MachCallStaticJavaNode::ret_addr_offset() {
 1082   // It&#39;s only a single branch-and-link instruction.
 1083   return 4;
 1084 }
 1085 
 1086 int MachCallDynamicJavaNode::ret_addr_offset() {
 1087   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 1088   // postalloc expanded calls if we use inline caches and do not update method data.
 1089   if (UseInlineCaches)
 1090     return 4;
 1091 
 1092   int vtable_index = this-&gt;_vtable_index;
 1093   if (vtable_index &lt; 0) {
 1094     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 1095     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 1096     return 12;
 1097   } else {
 1098     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 1099     return 24;
 1100   }
 1101 }
 1102 
 1103 int MachCallRuntimeNode::ret_addr_offset() {
 1104 #if defined(ABI_ELFv2)
 1105   return 28;
 1106 #else
 1107   return 40;
 1108 #endif
 1109 }
 1110 
 1111 //=============================================================================
 1112 
 1113 // condition code conversions
 1114 
 1115 static int cc_to_boint(int cc) {
 1116   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 1117 }
 1118 
 1119 static int cc_to_inverse_boint(int cc) {
 1120   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 1121 }
 1122 
 1123 static int cc_to_biint(int cc, int flags_reg) {
 1124   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 1125 }
 1126 
 1127 //=============================================================================
 1128 
 1129 // Compute padding required for nodes which need alignment. The padding
 1130 // is the number of bytes (not instructions) which will be inserted before
 1131 // the instruction. The padding must match the size of a NOP instruction.
 1132 
 1133 // Currently not used on this platform.
 1134 
 1135 //=============================================================================
 1136 
 1137 // Indicate if the safepoint node needs the polling page as an input.
 1138 bool SafePointNode::needs_polling_address_input() {
 1139   // The address is loaded from thread by a seperate node.
 1140   return true;
 1141 }
 1142 
 1143 //=============================================================================
 1144 
 1145 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 1146 void emit_break(CodeBuffer &amp;cbuf) {
 1147   MacroAssembler _masm(&amp;cbuf);
 1148   __ illtrap();
 1149 }
 1150 
 1151 #ifndef PRODUCT
 1152 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1153   st-&gt;print(&quot;BREAKPOINT&quot;);
 1154 }
 1155 #endif
 1156 
 1157 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1158   emit_break(cbuf);
 1159 }
 1160 
 1161 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 1162   return MachNode::size(ra_);
 1163 }
 1164 
 1165 //=============================================================================
 1166 
 1167 void emit_nop(CodeBuffer &amp;cbuf) {
 1168   MacroAssembler _masm(&amp;cbuf);
 1169   __ nop();
 1170 }
 1171 
 1172 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
 1173   *((int*)(cbuf.insts_end())) = value;
 1174   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
 1175 }
 1176 
 1177 //=============================================================================
 1178 
 1179 %} // interrupt source
 1180 
 1181 source_hpp %{ // Header information of the source block.
 1182 
 1183 //--------------------------------------------------------------
 1184 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
 1185 //--------------------------------------------------------------
 1186 
 1187 class CallStubImpl {
 1188 
 1189  public:
 1190 
 1191   // Emit call stub, compiled java to interpreter.
 1192   static void emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);
 1193 
 1194   // Size of call trampoline stub.
 1195   // This doesn&#39;t need to be accurate to the byte, but it
 1196   // must be larger than or equal to the real size of the stub.
 1197   static uint size_call_trampoline() {
 1198     return MacroAssembler::trampoline_stub_size;
 1199   }
 1200 
 1201   // number of relocations needed by a call trampoline stub
 1202   static uint reloc_call_trampoline() {
 1203     return 5;
 1204   }
 1205 
 1206 };
 1207 
 1208 %} // end source_hpp
 1209 
 1210 source %{
 1211 
 1212 // Emit a trampoline stub for a call to a target which is too far away.
 1213 //
 1214 // code sequences:
 1215 //
 1216 // call-site:
 1217 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1218 //
 1219 // Related trampoline stub for this call-site in the stub section:
 1220 //   load the call target from the constant pool
 1221 //   branch via CTR (LR/link still points to the call-site above)
 1222 
 1223 void CallStubImpl::emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {
 1224   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
 1225   if (stub == NULL) {
 1226     ciEnv::current()-&gt;record_out_of_memory_failure();
 1227   }
 1228 }
 1229 
 1230 //=============================================================================
 1231 
 1232 // Emit an inline branch-and-link call and a related trampoline stub.
 1233 //
 1234 // code sequences:
 1235 //
 1236 // call-site:
 1237 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1238 //
 1239 // Related trampoline stub for this call-site in the stub section:
 1240 //   load the call target from the constant pool
 1241 //   branch via CTR (LR/link still points to the call-site above)
 1242 //
 1243 
 1244 typedef struct {
 1245   int insts_call_instruction_offset;
 1246   int ret_addr_offset;
 1247 } EmitCallOffsets;
 1248 
 1249 // Emit a branch-and-link instruction that branches to a trampoline.
 1250 // - Remember the offset of the branch-and-link instruction.
 1251 // - Add a relocation at the branch-and-link instruction.
 1252 // - Emit a branch-and-link.
 1253 // - Remember the return pc offset.
 1254 EmitCallOffsets emit_call_with_trampoline_stub(MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {
 1255   EmitCallOffsets offsets = { -1, -1 };
 1256   const int start_offset = __ offset();
 1257   offsets.insts_call_instruction_offset = __ offset();
 1258 
 1259   // No entry point given, use the current pc.
 1260   if (entry_point == NULL) entry_point = __ pc();
 1261 
 1262   // Put the entry point as a constant into the constant pool.
 1263   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
 1264   if (entry_point_toc_addr == NULL) {
 1265     ciEnv::current()-&gt;record_out_of_memory_failure();
 1266     return offsets;
 1267   }
 1268   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 1269 
 1270   // Emit the trampoline stub which will be related to the branch-and-link below.
 1271   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
 1272   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
 1273   __ relocate(rtype);
 1274 
 1275   // Note: At this point we do not have the address of the trampoline
 1276   // stub, and the entry point might be too far away for bl, so __ pc()
 1277   // serves as dummy and the bl will be patched later.
 1278   __ bl((address) __ pc());
 1279 
 1280   offsets.ret_addr_offset = __ offset() - start_offset;
 1281 
 1282   return offsets;
 1283 }
 1284 
 1285 //=============================================================================
 1286 
 1287 // Factory for creating loadConL* nodes for large/small constant pool.
 1288 
 1289 static inline jlong replicate_immF(float con) {
 1290   // Replicate float con 2 times and pack into vector.
 1291   int val = *((int*)&amp;con);
 1292   jlong lval = val;
 1293   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1294   return lval;
 1295 }
 1296 
 1297 //=============================================================================
 1298 
 1299 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
 1300 int Compile::ConstantTable::calculate_table_base_offset() const {
 1301   return 0;  // absolute addressing, no offset
 1302 }
 1303 
 1304 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1305 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1306   iRegPdstOper *op_dst = new iRegPdstOper();
 1307   MachNode *m1 = new loadToc_hiNode();
 1308   MachNode *m2 = new loadToc_loNode();
 1309 
 1310   m1-&gt;add_req(NULL);
 1311   m2-&gt;add_req(NULL, m1);
 1312   m1-&gt;_opnds[0] = op_dst;
 1313   m2-&gt;_opnds[0] = op_dst;
 1314   m2-&gt;_opnds[1] = op_dst;
 1315   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1316   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1317   nodes-&gt;push(m1);
 1318   nodes-&gt;push(m2);
 1319 }
 1320 
 1321 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1322   // Is postalloc expanded.
 1323   ShouldNotReachHere();
 1324 }
 1325 
 1326 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1327   return 0;
 1328 }
 1329 
 1330 #ifndef PRODUCT
 1331 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1332   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1333 }
 1334 #endif
 1335 
 1336 //=============================================================================
 1337 
 1338 #ifndef PRODUCT
 1339 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1340   Compile* C = ra_-&gt;C;
 1341   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;
 1342 
 1343   st-&gt;print(&quot;PROLOG\n\t&quot;);
 1344   if (C-&gt;need_stack_bang(framesize)) {
 1345     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1346   }
 1347 
 1348   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1349     st-&gt;print(&quot;save return pc\n\t&quot;);
 1350     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1351   }
 1352 }
 1353 #endif
 1354 
 1355 // Macro used instead of the common __ to emulate the pipes of PPC.
 1356 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1357 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1358 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1359 // code and can update its internal data. The following mechanism is used to achieve this:
 1360 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1361 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1362 #if 0 // TODO: PPC port
 1363 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1364                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1365                 _masm.
 1366 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1367                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1368 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1369                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1370 #else
 1371 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1372                   Unimplemented();                                                    \
 1373                 _masm.
 1374 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1375                   Unimplemented()
 1376 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1377                   Unimplemented()
 1378 #endif
 1379 
 1380 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1381   Compile* C = ra_-&gt;C;
 1382   MacroAssembler _masm(&amp;cbuf);
 1383 
 1384   const long framesize = C-&gt;frame_size_in_bytes();
 1385   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1386 
 1387   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1388 
 1389   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1390   const Register callers_sp           = R21;
 1391   const Register push_frame_temp      = R22;
 1392   const Register toc_temp             = R23;
 1393   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1394 
 1395   if (method_is_frameless) {
 1396     // Add nop at beginning of all frameless methods to prevent any
 1397     // oop instructions from getting overwritten by make_not_entrant
 1398     // (patching attempt would fail).
 1399     ___(nop) nop();
 1400   } else {
 1401     // Get return pc.
 1402     ___(mflr) mflr(return_pc);
 1403   }
 1404 
 1405   if (C-&gt;clinit_barrier_on_entry()) {
 1406     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1407 
 1408     Label L_skip_barrier;
 1409     Register klass = toc_temp;
 1410 
 1411     // Notify OOP recorder (don&#39;t need the relocation)
 1412     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1413     __ load_const_optimized(klass, md.value(), R0);
 1414     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1415 
 1416     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1417     __ mtctr(klass);
 1418     __ bctr();
 1419 
 1420     __ bind(L_skip_barrier);
 1421   }
 1422 
 1423   // Calls to C2R adapters often do not accept exceptional returns.
 1424   // We require that their callers must bang for them. But be
 1425   // careful, because some VM calls (such as call site linkage) can
 1426   // use several kilobytes of stack. But the stack safety zone should
 1427   // account for that. See bugs 4446381, 4468289, 4497237.
 1428 
 1429   int bangsize = C-&gt;bang_size_in_bytes();
 1430   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
 1431   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
 1432     // Unfortunately we cannot use the function provided in
 1433     // assembler.cpp as we have to emulate the pipes. So I had to
 1434     // insert the code of generate_stack_overflow_check(), see
 1435     // assembler.cpp for some illuminative comments.
 1436     const int page_size = os::vm_page_size();
 1437     int bang_end = JavaThread::stack_shadow_zone_size();
 1438 
 1439     // This is how far the previous frame&#39;s stack banging extended.
 1440     const int bang_end_safe = bang_end;
 1441 
 1442     if (bangsize &gt; page_size) {
 1443       bang_end += bangsize;
 1444     }
 1445 
 1446     int bang_offset = bang_end_safe;
 1447 
 1448     while (bang_offset &lt;= bang_end) {
 1449       // Need at least one stack bang at end of shadow zone.
 1450 
 1451       // Again I had to copy code, this time from assembler_ppc.cpp,
 1452       // bang_stack_with_offset - see there for comments.
 1453 
 1454       // Stack grows down, caller passes positive offset.
 1455       assert(bang_offset &gt; 0, &quot;must bang with positive offset&quot;);
 1456 
 1457       long stdoffset = -bang_offset;
 1458 
 1459       if (Assembler::is_simm(stdoffset, 16)) {
 1460         // Signed 16 bit offset, a simple std is ok.
 1461         if (UseLoadInstructionsForStackBangingPPC64) {
 1462           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
 1463         } else {
 1464           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
 1465         }
 1466       } else if (Assembler::is_simm(stdoffset, 31)) {
 1467         // Use largeoffset calculations for addis &amp; ld/std.
 1468         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1469         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1470 
 1471         Register tmp = R11;
 1472         ___(addis) addis(tmp, R1_SP, hi);
 1473         if (UseLoadInstructionsForStackBangingPPC64) {
 1474           ___(ld) ld(R0, lo, tmp);
 1475         } else {
 1476           ___(std) std(R0, lo, tmp);
 1477         }
 1478       } else {
 1479         ShouldNotReachHere();
 1480       }
 1481 
 1482       bang_offset += page_size;
 1483     }
 1484     // R11 trashed
 1485   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging
 1486 
 1487   unsigned int bytes = (unsigned int)framesize;
 1488   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1489   ciMethod *currMethod = C-&gt;method();
 1490 
 1491   // Optimized version for most common case.
 1492   if (UsePower6SchedulerPPC64 &amp;&amp;
 1493       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1494       !(false /* ConstantsALot TODO: PPC port*/)) {
 1495     ___(or) mr(callers_sp, R1_SP);
 1496     ___(std) std(return_pc, _abi(lr), R1_SP);
 1497     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1498     return;
 1499   }
 1500 
 1501   if (!method_is_frameless) {
 1502     // Get callers sp.
 1503     ___(or) mr(callers_sp, R1_SP);
 1504 
 1505     // Push method&#39;s frame, modifies SP.
 1506     assert(Assembler::is_uimm(framesize, 32U), &quot;wrong type&quot;);
 1507     // The ABI is already accounted for in &#39;framesize&#39; via the
 1508     // &#39;out_preserve&#39; area.
 1509     Register tmp = push_frame_temp;
 1510     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
 1511     if (Assembler::is_simm(-offset, 16)) {
 1512       ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1513     } else {
 1514       long x = -offset;
 1515       // Had to insert load_const(tmp, -offset).
 1516       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
 1517       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
 1518       ___(rldicr) sldi(tmp, tmp, 32);
 1519       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
 1520       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1521 
 1522       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1523     }
 1524   }
 1525 #if 0 // TODO: PPC port
 1526   // For testing large constant pools, emit a lot of constants to constant pool.
 1527   // &quot;Randomize&quot; const_size.
 1528   if (ConstantsALot) {
 1529     const int num_consts = const_size();
 1530     for (int i = 0; i &lt; num_consts; i++) {
 1531       __ long_constant(0xB0B5B00BBABE);
 1532     }
 1533   }
 1534 #endif
 1535   if (!method_is_frameless) {
 1536     // Save return pc.
 1537     ___(std) std(return_pc, _abi(lr), callers_sp);
 1538   }
 1539 
 1540   C-&gt;set_frame_complete(cbuf.insts_size());
 1541 }
 1542 #undef ___
 1543 #undef ___stop
 1544 #undef ___advance
 1545 
 1546 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1547   // Variable size. determine dynamically.
 1548   return MachNode::size(ra_);
 1549 }
 1550 
 1551 int MachPrologNode::reloc() const {
 1552   // Return number of relocatable values contained in this instruction.
 1553   return 1; // 1 reloc entry for load_const(toc).
 1554 }
 1555 
 1556 //=============================================================================
 1557 
 1558 #ifndef PRODUCT
 1559 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1560   Compile* C = ra_-&gt;C;
 1561 
 1562   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1563   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1564   st-&gt;print(&quot;pop frame\n\t&quot;);
 1565 
 1566   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1567     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1568   }
 1569 }
 1570 #endif
 1571 
 1572 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1573   Compile* C = ra_-&gt;C;
 1574   MacroAssembler _masm(&amp;cbuf);
 1575 
 1576   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;
 1577   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1578 
 1579   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1580   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1581   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1582   const Register polling_page     = R12;
 1583 
 1584   if (!method_is_frameless) {
 1585     // Restore return pc relative to callers&#39; sp.
 1586     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1587   }
 1588 
 1589   if (method_needs_polling) {
 1590     if (SafepointMechanism::uses_thread_local_poll()) {
 1591       __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1592     } else {
 1593       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page());
 1594     }
 1595   }
 1596 
 1597   if (!method_is_frameless) {
 1598     // Move return pc to LR.
 1599     __ mtlr(return_pc);
 1600     // Pop frame (fixed frame-size).
 1601     __ addi(R1_SP, R1_SP, (int)framesize);
 1602   }
 1603 
 1604   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1605     __ reserved_stack_check(return_pc);
 1606   }
 1607 
 1608   if (method_needs_polling) {
 1609     // We need to mark the code position where the load from the safepoint
 1610     // polling page was emitted as relocInfo::poll_return_type here.
 1611     __ relocate(relocInfo::poll_return_type);
 1612     __ load_from_polling_page(polling_page);
 1613   }
 1614 }
 1615 
 1616 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1617   // Variable size. Determine dynamically.
 1618   return MachNode::size(ra_);
 1619 }
 1620 
 1621 int MachEpilogNode::reloc() const {
 1622   // Return number of relocatable values contained in this instruction.
 1623   return 1; // 1 for load_from_polling_page.
 1624 }
 1625 
 1626 const Pipeline * MachEpilogNode::pipeline() const {
 1627   return MachNode::pipeline_class();
 1628 }
 1629 
 1630 // This method seems to be obsolete. It is declared in machnode.hpp
 1631 // and defined in all *.ad files, but it is never called. Should we
 1632 // get rid of it?
 1633 int MachEpilogNode::safepoint_offset() const {
 1634   assert(do_polling(), &quot;no return for this epilog node&quot;);
 1635   return 0;
 1636 }
 1637 
 1638 #if 0 // TODO: PPC port
 1639 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1640   MacroAssembler _masm(&amp;cbuf);
 1641   if (LoadPollAddressFromThread) {
 1642     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
 1643   } else {
 1644     _masm.nop();
 1645   }
 1646 }
 1647 
 1648 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
 1649   if (LoadPollAddressFromThread) {
 1650     return 4;
 1651   } else {
 1652     return 4;
 1653   }
 1654 }
 1655 
 1656 #ifndef PRODUCT
 1657 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1658   st-&gt;print_cr(&quot; LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread&quot;);
 1659 }
 1660 #endif
 1661 
 1662 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
 1663   return RSCRATCH1_BITS64_REG_mask();
 1664 }
 1665 #endif // PPC port
 1666 
 1667 // =============================================================================
 1668 
 1669 // Figure out which register class each belongs in: rc_int, rc_float, rc_vs or
 1670 // rc_stack.
 1671 enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };
 1672 
 1673 static enum RC rc_class(OptoReg::Name reg) {
 1674   // Return the register class for the given register. The given register
 1675   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
 1676   // enumeration in adGlobals_ppc.hpp.
 1677 
 1678   if (reg == OptoReg::Bad) return rc_bad;
 1679 
 1680   // We have 64 integer register halves, starting at index 0.
 1681   if (reg &lt; 64) return rc_int;
 1682 
 1683   // We have 64 floating-point register halves, starting at index 64.
 1684   if (reg &lt; 64+64) return rc_float;
 1685 
 1686   // We have 64 vector-scalar registers, starting at index 128.
 1687   if (reg &lt; 64+64+64) return rc_vs;
 1688 
 1689   // Between float regs &amp; stack are the flags regs.
 1690   assert(OptoReg::is_stack(reg) || reg &lt; 64+64+64, &quot;blow up if spilling flags&quot;);
 1691 
 1692   return rc_stack;
 1693 }
 1694 
 1695 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
 1696                         bool do_print, Compile* C, outputStream *st) {
 1697 
 1698   assert(opcode == Assembler::LD_OPCODE   ||
 1699          opcode == Assembler::STD_OPCODE  ||
 1700          opcode == Assembler::LWZ_OPCODE  ||
 1701          opcode == Assembler::STW_OPCODE  ||
 1702          opcode == Assembler::LFD_OPCODE  ||
 1703          opcode == Assembler::STFD_OPCODE ||
 1704          opcode == Assembler::LFS_OPCODE  ||
 1705          opcode == Assembler::STFS_OPCODE,
 1706          &quot;opcode not supported&quot;);
 1707 
 1708   if (cbuf) {
 1709     int d =
 1710       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
 1711         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
 1712       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
 1713     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
 1714   }
 1715 #ifndef PRODUCT
 1716   else if (do_print) {
 1717     st-&gt;print(&quot;%-7s %s, [R1_SP + #%d+%d] \t// spill copy&quot;,
 1718               op_str,
 1719               Matcher::regName[reg],
 1720               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
 1721   }
 1722 #endif
 1723   return 4; // size
 1724 }
 1725 
 1726 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1727   Compile* C = ra_-&gt;C;
 1728 
 1729   // Get registers to move.
 1730   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1731   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1732   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1733   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1734 
 1735   enum RC src_hi_rc = rc_class(src_hi);
 1736   enum RC src_lo_rc = rc_class(src_lo);
 1737   enum RC dst_hi_rc = rc_class(dst_hi);
 1738   enum RC dst_lo_rc = rc_class(dst_lo);
 1739 
 1740   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1741   if (src_hi != OptoReg::Bad)
 1742     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
 1743            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
 1744            &quot;expected aligned-adjacent pairs&quot;);
 1745   // Generate spill code!
 1746   int size = 0;
 1747 
 1748   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1749     return size;            // Self copy, no move.
 1750 
 1751   if (bottom_type()-&gt;isa_vect() != NULL &amp;&amp; ideal_reg() == Op_VecX) {
 1752     // Memory-&gt;Memory Spill.
 1753     if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1754       int src_offset = ra_-&gt;reg2offset(src_lo);
 1755       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1756       if (cbuf) {
 1757         MacroAssembler _masm(cbuf);
 1758         __ ld(R0, src_offset, R1_SP);
 1759         __ std(R0, dst_offset, R1_SP);
 1760         __ ld(R0, src_offset+8, R1_SP);
 1761         __ std(R0, dst_offset+8, R1_SP);
 1762       }
 1763       size += 16;
 1764     }
 1765     // VectorSRegister-&gt;Memory Spill.
 1766     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
 1767       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1768       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1769       if (cbuf) {
 1770         MacroAssembler _masm(cbuf);
 1771         __ addi(R0, R1_SP, dst_offset);
 1772         __ stxvd2x(Rsrc, R0);
 1773       }
 1774       size += 8;
 1775     }
 1776     // Memory-&gt;VectorSRegister Spill.
 1777     else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
 1778       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1779       int src_offset = ra_-&gt;reg2offset(src_lo);
 1780       if (cbuf) {
 1781         MacroAssembler _masm(cbuf);
 1782         __ addi(R0, R1_SP, src_offset);
 1783         __ lxvd2x(Rdst, R0);
 1784       }
 1785       size += 8;
 1786     }
 1787     // VectorSRegister-&gt;VectorSRegister.
 1788     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
 1789       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1790       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1791       if (cbuf) {
 1792         MacroAssembler _masm(cbuf);
 1793         __ xxlor(Rdst, Rsrc, Rsrc);
 1794       }
 1795       size += 4;
 1796     }
 1797     else {
 1798       ShouldNotReachHere(); // No VSR spill.
 1799     }
 1800     return size;
 1801   }
 1802 
 1803   // --------------------------------------
 1804   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1805   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1806     int src_offset = ra_-&gt;reg2offset(src_lo);
 1807     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1808     if (src_hi != OptoReg::Bad) {
 1809       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
 1810              &quot;expected same type of move for high parts&quot;);
 1811       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
 1812       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1813       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1814     } else {
 1815       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
 1816       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1817       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1818     }
 1819     return size;
 1820   }
 1821 
 1822   // --------------------------------------
 1823   // Check for float-&gt;int copy; requires a trip through memory.
 1824   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1825     Unimplemented();
 1826   }
 1827 
 1828   // --------------------------------------
 1829   // Check for integer reg-reg copy.
 1830   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1831       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1832       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1833       size = (Rsrc != Rdst) ? 4 : 0;
 1834 
 1835       if (cbuf) {
 1836         MacroAssembler _masm(cbuf);
 1837         if (size) {
 1838           __ mr(Rdst, Rsrc);
 1839         }
 1840       }
 1841 #ifndef PRODUCT
 1842       else if (!do_size) {
 1843         if (size) {
 1844           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1845         } else {
 1846           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR-NOP&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1847         }
 1848       }
 1849 #endif
 1850       return size;
 1851   }
 1852 
 1853   // Check for integer store.
 1854   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1855     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1856     if (src_hi != OptoReg::Bad) {
 1857       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
 1858              &quot;expected same type of move for high parts&quot;);
 1859       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1860     } else {
 1861       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1862     }
 1863     return size;
 1864   }
 1865 
 1866   // Check for integer load.
 1867   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1868     int src_offset = ra_-&gt;reg2offset(src_lo);
 1869     if (src_hi != OptoReg::Bad) {
 1870       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
 1871              &quot;expected same type of move for high parts&quot;);
 1872       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1873     } else {
 1874       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1875     }
 1876     return size;
 1877   }
 1878 
 1879   // Check for float reg-reg copy.
 1880   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1881     if (cbuf) {
 1882       MacroAssembler _masm(cbuf);
 1883       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1884       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1885       __ fmr(Rdst, Rsrc);
 1886     }
 1887 #ifndef PRODUCT
 1888     else if (!do_size) {
 1889       st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;FMR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1890     }
 1891 #endif
 1892     return 4;
 1893   }
 1894 
 1895   // Check for float store.
 1896   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1897     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1898     if (src_hi != OptoReg::Bad) {
 1899       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
 1900              &quot;expected same type of move for high parts&quot;);
 1901       size += ld_st_helper(cbuf, &quot;STFD&quot;, Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1902     } else {
 1903       size += ld_st_helper(cbuf, &quot;STFS&quot;, Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1904     }
 1905     return size;
 1906   }
 1907 
 1908   // Check for float load.
 1909   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1910     int src_offset = ra_-&gt;reg2offset(src_lo);
 1911     if (src_hi != OptoReg::Bad) {
 1912       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
 1913              &quot;expected same type of move for high parts&quot;);
 1914       size += ld_st_helper(cbuf, &quot;LFD &quot;, Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1915     } else {
 1916       size += ld_st_helper(cbuf, &quot;LFS &quot;, Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1917     }
 1918     return size;
 1919   }
 1920 
 1921   // --------------------------------------------------------------------
 1922   // Check for hi bits still needing moving. Only happens for misaligned
 1923   // arguments to native calls.
 1924   if (src_hi == dst_hi)
 1925     return size;               // Self copy; no move.
 1926 
 1927   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1928   ShouldNotReachHere(); // Unimplemented
 1929   return 0;
 1930 }
 1931 
 1932 #ifndef PRODUCT
 1933 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1934   if (!ra_)
 1935     st-&gt;print(&quot;N%d = SpillCopy(N%d)&quot;, _idx, in(1)-&gt;_idx);
 1936   else
 1937     implementation(NULL, ra_, false, st);
 1938 }
 1939 #endif
 1940 
 1941 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1942   implementation(&amp;cbuf, ra_, false, NULL);
 1943 }
 1944 
 1945 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1946   return implementation(NULL, ra_, true, NULL);
 1947 }
 1948 
 1949 #if 0 // TODO: PPC port
 1950 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
 1951 #ifndef PRODUCT
 1952   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
 1953 #endif
 1954   assert(ra_-&gt;node_regs_max_index() != 0, &quot;&quot;);
 1955 
 1956   // Get registers to move.
 1957   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
 1958   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
 1959   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
 1960   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
 1961 
 1962   enum RC src_lo_rc = rc_class(src_lo);
 1963   enum RC dst_lo_rc = rc_class(dst_lo);
 1964 
 1965   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1966     return ppc64Opcode_none;            // Self copy, no move.
 1967 
 1968   // --------------------------------------
 1969   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1970   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1971     return ppc64Opcode_compound;
 1972   }
 1973 
 1974   // --------------------------------------
 1975   // Check for float-&gt;int copy; requires a trip through memory.
 1976   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1977     Unimplemented();
 1978   }
 1979 
 1980   // --------------------------------------
 1981   // Check for integer reg-reg copy.
 1982   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1983     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1984     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1985     if (Rsrc == Rdst) {
 1986       return ppc64Opcode_none;
 1987     } else {
 1988       return ppc64Opcode_or;
 1989     }
 1990   }
 1991 
 1992   // Check for integer store.
 1993   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1994     if (src_hi != OptoReg::Bad) {
 1995       return ppc64Opcode_std;
 1996     } else {
 1997       return ppc64Opcode_stw;
 1998     }
 1999   }
 2000 
 2001   // Check for integer load.
 2002   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 2003     if (src_hi != OptoReg::Bad) {
 2004       return ppc64Opcode_ld;
 2005     } else {
 2006       return ppc64Opcode_lwz;
 2007     }
 2008   }
 2009 
 2010   // Check for float reg-reg copy.
 2011   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 2012     return ppc64Opcode_fmr;
 2013   }
 2014 
 2015   // Check for float store.
 2016   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 2017     if (src_hi != OptoReg::Bad) {
 2018       return ppc64Opcode_stfd;
 2019     } else {
 2020       return ppc64Opcode_stfs;
 2021     }
 2022   }
 2023 
 2024   // Check for float load.
 2025   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 2026     if (src_hi != OptoReg::Bad) {
 2027       return ppc64Opcode_lfd;
 2028     } else {
 2029       return ppc64Opcode_lfs;
 2030     }
 2031   }
 2032 
 2033   // --------------------------------------------------------------------
 2034   // Check for hi bits still needing moving. Only happens for misaligned
 2035   // arguments to native calls.
 2036   if (src_hi == dst_hi) {
 2037     return ppc64Opcode_none;               // Self copy; no move.
 2038   }
 2039 
 2040   ShouldNotReachHere();
 2041   return ppc64Opcode_undefined;
 2042 }
 2043 #endif // PPC port
 2044 
 2045 #ifndef PRODUCT
 2046 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2047   st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
 2048 }
 2049 #endif
 2050 
 2051 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
 2052   MacroAssembler _masm(&amp;cbuf);
 2053   // _count contains the number of nops needed for padding.
 2054   for (int i = 0; i &lt; _count; i++) {
 2055     __ nop();
 2056   }
 2057 }
 2058 
 2059 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 2060   return _count * 4;
 2061 }
 2062 
 2063 #ifndef PRODUCT
 2064 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2065   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2066   char reg_str[128];
 2067   ra_-&gt;dump_register(this, reg_str);
 2068   st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
 2069 }
 2070 #endif
 2071 
 2072 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2073   MacroAssembler _masm(&amp;cbuf);
 2074 
 2075   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2076   int reg    = ra_-&gt;get_encode(this);
 2077 
 2078   if (Assembler::is_simm(offset, 16)) {
 2079     __ addi(as_Register(reg), R1, offset);
 2080   } else {
 2081     ShouldNotReachHere();
 2082   }
 2083 }
 2084 
 2085 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 2086   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 2087   return 4;
 2088 }
 2089 
 2090 #ifndef PRODUCT
 2091 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2092   st-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 2093   st-&gt;print_cr(&quot;...&quot;);
 2094 }
 2095 #endif
 2096 
 2097 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2098   // This is the unverified entry point.
 2099   MacroAssembler _masm(&amp;cbuf);
 2100 
 2101   // Inline_cache contains a klass.
 2102   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
 2103   Register receiver_klass = R12_scratch2;  // tmp
 2104 
 2105   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
 2106   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
 2107 
 2108   // Check for NULL argument if we don&#39;t have implicit null checks.
 2109   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
 2110     if (TrapBasedNullChecks) {
 2111       __ trap_null_check(R3_ARG1);
 2112     } else {
 2113       Label valid;
 2114       __ cmpdi(CCR0, R3_ARG1, 0);
 2115       __ bne_predict_taken(CCR0, valid);
 2116       // We have a null argument, branch to ic_miss_stub.
 2117       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2118                            relocInfo::runtime_call_type);
 2119       __ bind(valid);
 2120     }
 2121   }
 2122   // Assume argument is not NULL, load klass from receiver.
 2123   __ load_klass(receiver_klass, R3_ARG1);
 2124 
 2125   if (TrapBasedICMissChecks) {
 2126     __ trap_ic_miss_check(receiver_klass, ic_klass);
 2127   } else {
 2128     Label valid;
 2129     __ cmpd(CCR0, receiver_klass, ic_klass);
 2130     __ beq_predict_taken(CCR0, valid);
 2131     // We have an unexpected klass, branch to ic_miss_stub.
 2132     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2133                          relocInfo::runtime_call_type);
 2134     __ bind(valid);
 2135   }
 2136 
 2137   // Argument is valid and klass is as expected, continue.
 2138 }
 2139 
 2140 #if 0 // TODO: PPC port
 2141 // Optimize UEP code on z (save a load_const() call in main path).
 2142 int MachUEPNode::ep_offset() {
 2143   return 0;
 2144 }
 2145 #endif
 2146 
 2147 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 2148   // Variable size. Determine dynamically.
 2149   return MachNode::size(ra_);
 2150 }
 2151 
 2152 //=============================================================================
 2153 
 2154 %} // interrupt source
 2155 
 2156 source_hpp %{ // Header information of the source block.
 2157 
 2158 class HandlerImpl {
 2159 
 2160  public:
 2161 
 2162   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 2163   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 2164 
 2165   static uint size_exception_handler() {
 2166     // The exception_handler is a b64_patchable.
 2167     return MacroAssembler::b64_patchable_size;
 2168   }
 2169 
 2170   static uint size_deopt_handler() {
 2171     // The deopt_handler is a bl64_patchable.
 2172     return MacroAssembler::bl64_patchable_size;
 2173   }
 2174 
 2175 };
 2176 
 2177 %} // end source_hpp
 2178 
 2179 source %{
 2180 
 2181 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 2182   MacroAssembler _masm(&amp;cbuf);
 2183 
 2184   address base = __ start_a_stub(size_exception_handler());
 2185   if (base == NULL) return 0; // CodeBuffer::expand failed
 2186 
 2187   int offset = __ offset();
 2188   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
 2189                        relocInfo::runtime_call_type);
 2190   assert(__ offset() - offset == (int)size_exception_handler(), &quot;must be fixed size&quot;);
 2191   __ end_a_stub();
 2192 
 2193   return offset;
 2194 }
 2195 
 2196 // The deopt_handler is like the exception handler, but it calls to
 2197 // the deoptimization blob instead of jumping to the exception blob.
 2198 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 2199   MacroAssembler _masm(&amp;cbuf);
 2200 
 2201   address base = __ start_a_stub(size_deopt_handler());
 2202   if (base == NULL) return 0; // CodeBuffer::expand failed
 2203 
 2204   int offset = __ offset();
 2205   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
 2206                         relocInfo::runtime_call_type);
 2207   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2208   __ end_a_stub();
 2209 
 2210   return offset;
 2211 }
 2212 
 2213 //=============================================================================
 2214 
 2215 // Use a frame slots bias for frameless methods if accessing the stack.
 2216 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2217   if (as_Register(reg_enc) == R1_SP) {
 2218     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2219   }
 2220   return 0;
 2221 }
 2222 
 2223 const bool Matcher::match_rule_supported(int opcode) {
 2224   if (!has_match_rule(opcode))
 2225     return false;
 2226 
 2227   bool ret_value = true;
 2228   switch (opcode) {
 2229   case Op_SqrtD:
 2230     return VM_Version::has_fsqrt();
 2231   case Op_CountLeadingZerosI:
 2232   case Op_CountLeadingZerosL:
 2233     if (!UseCountLeadingZerosInstructionsPPC64)
 2234       return false;
 2235     break;
 2236   case Op_CountTrailingZerosI:
 2237   case Op_CountTrailingZerosL:
 2238     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2239         !UseCountTrailingZerosInstructionsPPC64)
 2240       return false;
 2241     break;
 2242 
 2243   case Op_PopCountI:
 2244   case Op_PopCountL:
 2245     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2246 
 2247   case Op_StrComp:
 2248     return SpecialStringCompareTo;
 2249   case Op_StrEquals:
 2250     return SpecialStringEquals;
 2251   case Op_StrIndexOf:
 2252   case Op_StrIndexOfChar:
 2253     return SpecialStringIndexOf;
 2254   case Op_AddVB:
 2255   case Op_AddVS:
 2256   case Op_AddVI:
 2257   case Op_AddVF:
 2258   case Op_AddVD:
 2259   case Op_SubVB:
 2260   case Op_SubVS:
 2261   case Op_SubVI:
 2262   case Op_SubVF:
 2263   case Op_SubVD:
 2264   case Op_MulVS:
 2265   case Op_MulVF:
 2266   case Op_MulVD:
 2267   case Op_DivVF:
 2268   case Op_DivVD:
 2269   case Op_AbsVF:
 2270   case Op_AbsVD:
 2271   case Op_NegVF:
 2272   case Op_NegVD:
 2273   case Op_SqrtVF:
 2274   case Op_SqrtVD:
 2275   case Op_AddVL:
 2276   case Op_SubVL:
 2277   case Op_MulVI:
 2278   case Op_RoundDoubleModeV:
 2279     return SuperwordUseVSX;
 2280   case Op_PopCountVI:
 2281     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2282   case Op_FmaVF:
 2283   case Op_FmaVD:
 2284     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2285   case Op_Digit:
 2286   case Op_LowerCase:
 2287   case Op_UpperCase:
 2288   case Op_Whitespace:
 2289     return UseCharacterCompareIntrinsics;
 2290 
 2291   case Op_CacheWB:
 2292   case Op_CacheWBPreSync:
 2293   case Op_CacheWBPostSync:
 2294     if (!VM_Version::supports_data_cache_line_flush()) {
 2295       ret_value = false;
 2296     }
 2297     break;
 2298   }
 2299 
 2300   return ret_value;  // Per default match rules are supported.
 2301 }
 2302 
 2303 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 2304 
 2305   // TODO
 2306   // identify extra cases that we might want to provide match rules for
 2307   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2308   bool ret_value = match_rule_supported(opcode);
 2309   // Add rules here.
 2310 
 2311   return ret_value;  // Per default match rules are supported.
 2312 }
 2313 
 2314 const bool Matcher::has_predicated_vectors(void) {
 2315   return false;
 2316 }
 2317 
 2318 const int Matcher::float_pressure(int default_pressure_threshold) {
 2319   return default_pressure_threshold;
 2320 }
 2321 
 2322 int Matcher::regnum_to_fpu_offset(int regnum) {
 2323   // No user for this method?
 2324   Unimplemented();
 2325   return 999;
 2326 }
 2327 
 2328 const bool Matcher::convL2FSupported(void) {
 2329   // fcfids can do the conversion (&gt;= Power7).
 2330   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
 2331   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
 2332 }
 2333 
 2334 // Vector width in bytes.
 2335 const int Matcher::vector_width_in_bytes(BasicType bt) {
 2336   if (SuperwordUseVSX) {
 2337     assert(MaxVectorSize == 16, &quot;&quot;);
 2338     return 16;
 2339   } else {
 2340     assert(MaxVectorSize == 8, &quot;&quot;);
 2341     return 8;
 2342   }
 2343 }
 2344 
 2345 // Vector ideal reg.
 2346 const uint Matcher::vector_ideal_reg(int size) {
 2347   if (SuperwordUseVSX) {
 2348     assert(MaxVectorSize == 16 &amp;&amp; size == 16, &quot;&quot;);
 2349     return Op_VecX;
 2350   } else {
 2351     assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 2352     return Op_RegL;
 2353   }
 2354 }
 2355 
 2356 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 2357   fatal(&quot;vector shift is not supported&quot;);
 2358   return Node::NotAMachineReg;
 2359 }
 2360 
 2361 // Limits on vector size (number of elements) loaded into vector.
 2362 const int Matcher::max_vector_size(const BasicType bt) {
 2363   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 2364   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2365 }
 2366 
 2367 const int Matcher::min_vector_size(const BasicType bt) {
 2368   return max_vector_size(bt); // Same as max.
 2369 }
 2370 
 2371 // PPC implementation uses VSX load/store instructions (if
 2372 // SuperwordUseVSX) which support 4 byte but not arbitrary alignment
 2373 const bool Matcher::misaligned_vectors_ok() {
 2374   return false;
 2375 }
 2376 
 2377 // PPC AES support not yet implemented
 2378 const bool Matcher::pass_original_key_for_aes() {
 2379   return false;
 2380 }
 2381 
 2382 // RETURNS: whether this branch offset is short enough that a short
 2383 // branch can be used.
 2384 //
 2385 // If the platform does not provide any short branch variants, then
 2386 // this method should return `false&#39; for offset 0.
 2387 //
 2388 // `Compile::Fill_buffer&#39; will decide on basis of this information
 2389 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 2390 //
 2391 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2392 // information whether to replace particular branch sites by short
 2393 // ones.
 2394 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2395   // Is the offset within the range of a ppc64 pc relative branch?
 2396   bool b;
 2397 
 2398   const int safety_zone = 3 * BytesPerInstWord;
 2399   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2400                          29 - 16 + 1 + 2);
 2401   return b;
 2402 }
 2403 
 2404 const bool Matcher::isSimpleConstant64(jlong value) {
 2405   // Probably always true, even if a temp register is required.
 2406   return true;
 2407 }
 2408 /* TODO: PPC port
 2409 // Make a new machine dependent decode node (with its operands).
 2410 MachTypeNode *Matcher::make_decode_node() {
 2411   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,
 2412          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2413   MachTypeNode *decode = new decodeN_unscaledNode();
 2414   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2415   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2416   return decode;
 2417 }
 2418 */
 2419 
 2420 // false =&gt; size gets scaled to BytesPerLong, ok.
 2421 const bool Matcher::init_array_count_is_in_bytes = false;
 2422 
 2423 // Use conditional move (CMOVL) on Power7.
 2424 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2425 
 2426 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2427 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2428 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2429 
 2430 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2431 const bool Matcher::require_postalloc_expand = true;
 2432 
 2433 // Do we need to mask the count passed to shift instructions or does
 2434 // the cpu only look at the lower 5/6 bits anyway?
 2435 // PowerPC requires masked shift counts.
 2436 const bool Matcher::need_masked_shift_count = true;
 2437 
 2438 // No support for generic vector operands.
 2439 const bool Matcher::supports_generic_vector_operands  = false;
 2440 
 2441 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 2442   ShouldNotReachHere(); // generic vector operands not supported
 2443   return NULL;
 2444 }
 2445 
 2446 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2447   ShouldNotReachHere();  // generic vector operands not supported
 2448   return false;
 2449 }
 2450 
 2451 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2452   ShouldNotReachHere();  // generic vector operands not supported
 2453   return false;
 2454 }
 2455 
 2456 // This affects two different things:
 2457 //  - how Decode nodes are matched
 2458 //  - how ImplicitNullCheck opportunities are recognized
 2459 // If true, the matcher will try to remove all Decodes and match them
 2460 // (as operands) into nodes. NullChecks are not prepared to deal with
 2461 // Decodes by final_graph_reshaping().
 2462 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2463 // for a NullCheck. The matcher matches the Decode node into a register.
 2464 // Implicit_null_check optimization moves the Decode along with the
 2465 // memory operation back up before the NullCheck.
 2466 bool Matcher::narrow_oop_use_complex_address() {
 2467   // TODO: PPC port if (MatchDecodeNodes) return true;
 2468   return false;
 2469 }
 2470 
 2471 bool Matcher::narrow_klass_use_complex_address() {
 2472   NOT_LP64(ShouldNotCallThis());
 2473   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2474   // TODO: PPC port if (MatchDecodeNodes) return true;
 2475   return false;
 2476 }
 2477 
 2478 bool Matcher::const_oop_prefer_decode() {
 2479   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 2480   return CompressedOops::base() == NULL;
 2481 }
 2482 
 2483 bool Matcher::const_klass_prefer_decode() {
 2484   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2485   return CompressedKlassPointers::base() == NULL;
 2486 }
 2487 
 2488 // Is it better to copy float constants, or load them directly from memory?
 2489 // Intel can load a float constant from a direct address, requiring no
 2490 // extra registers. Most RISCs will have to materialize an address into a
 2491 // register first, so they would do better to copy the constant from stack.
 2492 const bool Matcher::rematerialize_float_constants = false;
 2493 
 2494 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2495 // needed. Else we split the double into 2 integer pieces and move it
 2496 // piece-by-piece. Only happens when passing doubles into C code as the
 2497 // Java calling convention forces doubles to be aligned.
 2498 const bool Matcher::misaligned_doubles_ok = true;
 2499 
 2500 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2501  Unimplemented();
 2502 }
 2503 
 2504 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 2505 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2506 
 2507 // Do floats take an entire double register or just half?
 2508 //
 2509 // A float occupies a ppc64 double register. For the allocator, a
 2510 // ppc64 double register appears as a pair of float registers.
 2511 bool Matcher::float_in_double() { return true; }
 2512 
 2513 // Do ints take an entire long register or just half?
 2514 // The relevant question is how the int is callee-saved:
 2515 // the whole long is written but de-opt&#39;ing will have to extract
 2516 // the relevant 32 bits.
 2517 const bool Matcher::int_in_long = true;
 2518 
 2519 // Constants for c2c and c calling conventions.
 2520 
 2521 const MachRegisterNumbers iarg_reg[8] = {
 2522   R3_num, R4_num, R5_num, R6_num,
 2523   R7_num, R8_num, R9_num, R10_num
 2524 };
 2525 
 2526 const MachRegisterNumbers farg_reg[13] = {
 2527   F1_num, F2_num, F3_num, F4_num,
 2528   F5_num, F6_num, F7_num, F8_num,
 2529   F9_num, F10_num, F11_num, F12_num,
 2530   F13_num
 2531 };
 2532 
 2533 const MachRegisterNumbers vsarg_reg[64] = {
 2534   VSR0_num, VSR1_num, VSR2_num, VSR3_num,
 2535   VSR4_num, VSR5_num, VSR6_num, VSR7_num,
 2536   VSR8_num, VSR9_num, VSR10_num, VSR11_num,
 2537   VSR12_num, VSR13_num, VSR14_num, VSR15_num,
 2538   VSR16_num, VSR17_num, VSR18_num, VSR19_num,
 2539   VSR20_num, VSR21_num, VSR22_num, VSR23_num,
 2540   VSR24_num, VSR23_num, VSR24_num, VSR25_num,
 2541   VSR28_num, VSR29_num, VSR30_num, VSR31_num,
 2542   VSR32_num, VSR33_num, VSR34_num, VSR35_num,
 2543   VSR36_num, VSR37_num, VSR38_num, VSR39_num,
 2544   VSR40_num, VSR41_num, VSR42_num, VSR43_num,
 2545   VSR44_num, VSR45_num, VSR46_num, VSR47_num,
 2546   VSR48_num, VSR49_num, VSR50_num, VSR51_num,
 2547   VSR52_num, VSR53_num, VSR54_num, VSR55_num,
 2548   VSR56_num, VSR57_num, VSR58_num, VSR59_num,
 2549   VSR60_num, VSR61_num, VSR62_num, VSR63_num
 2550 };
 2551 
 2552 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
 2553 
 2554 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
 2555 
 2556 const int num_vsarg_registers = sizeof(vsarg_reg) / sizeof(vsarg_reg[0]);
 2557 
 2558 // Return whether or not this register is ever used as an argument. This
 2559 // function is used on startup to build the trampoline stubs in generateOptoStub.
 2560 // Registers not mentioned will be killed by the VM call in the trampoline, and
 2561 // arguments in those registers not be available to the callee.
 2562 bool Matcher::can_be_java_arg(int reg) {
 2563   // We return true for all registers contained in iarg_reg[] and
 2564   // farg_reg[] and their virtual halves.
 2565   // We must include the virtual halves in order to get STDs and LDs
 2566   // instead of STWs and LWs in the trampoline stubs.
 2567 
 2568   if (   reg == R3_num  || reg == R3_H_num
 2569       || reg == R4_num  || reg == R4_H_num
 2570       || reg == R5_num  || reg == R5_H_num
 2571       || reg == R6_num  || reg == R6_H_num
 2572       || reg == R7_num  || reg == R7_H_num
 2573       || reg == R8_num  || reg == R8_H_num
 2574       || reg == R9_num  || reg == R9_H_num
 2575       || reg == R10_num || reg == R10_H_num)
 2576     return true;
 2577 
 2578   if (   reg == F1_num  || reg == F1_H_num
 2579       || reg == F2_num  || reg == F2_H_num
 2580       || reg == F3_num  || reg == F3_H_num
 2581       || reg == F4_num  || reg == F4_H_num
 2582       || reg == F5_num  || reg == F5_H_num
 2583       || reg == F6_num  || reg == F6_H_num
 2584       || reg == F7_num  || reg == F7_H_num
 2585       || reg == F8_num  || reg == F8_H_num
 2586       || reg == F9_num  || reg == F9_H_num
 2587       || reg == F10_num || reg == F10_H_num
 2588       || reg == F11_num || reg == F11_H_num
 2589       || reg == F12_num || reg == F12_H_num
 2590       || reg == F13_num || reg == F13_H_num)
 2591     return true;
 2592 
 2593   return false;
 2594 }
 2595 
 2596 bool Matcher::is_spillable_arg(int reg) {
 2597   return can_be_java_arg(reg);
 2598 }
 2599 
 2600 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 2601   return false;
 2602 }
 2603 
 2604 // Register for DIVI projection of divmodI.
 2605 RegMask Matcher::divI_proj_mask() {
 2606   ShouldNotReachHere();
 2607   return RegMask();
 2608 }
 2609 
 2610 // Register for MODI projection of divmodI.
 2611 RegMask Matcher::modI_proj_mask() {
 2612   ShouldNotReachHere();
 2613   return RegMask();
 2614 }
 2615 
 2616 // Register for DIVL projection of divmodL.
 2617 RegMask Matcher::divL_proj_mask() {
 2618   ShouldNotReachHere();
 2619   return RegMask();
 2620 }
 2621 
 2622 // Register for MODL projection of divmodL.
 2623 RegMask Matcher::modL_proj_mask() {
 2624   ShouldNotReachHere();
 2625   return RegMask();
 2626 }
 2627 
 2628 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 2629   return RegMask();
 2630 }
 2631 
 2632 const bool Matcher::convi2l_type_required = true;
 2633 
 2634 %}
 2635 
 2636 //----------ENCODING BLOCK-----------------------------------------------------
 2637 // This block specifies the encoding classes used by the compiler to output
 2638 // byte streams. Encoding classes are parameterized macros used by
 2639 // Machine Instruction Nodes in order to generate the bit encoding of the
 2640 // instruction. Operands specify their base encoding interface with the
 2641 // interface keyword. There are currently supported four interfaces,
 2642 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 2643 // operand to generate a function which returns its register number when
 2644 // queried. CONST_INTER causes an operand to generate a function which
 2645 // returns the value of the constant when queried. MEMORY_INTER causes an
 2646 // operand to generate four functions which return the Base Register, the
 2647 // Index Register, the Scale Value, and the Offset Value of the operand when
 2648 // queried. COND_INTER causes an operand to generate six functions which
 2649 // return the encoding code (ie - encoding bits for the instruction)
 2650 // associated with each basic boolean condition for a conditional instruction.
 2651 //
 2652 // Instructions specify two basic values for encoding. Again, a function
 2653 // is available to check if the constant displacement is an oop. They use the
 2654 // ins_encode keyword to specify their encoding classes (which must be
 2655 // a sequence of enc_class names, and their parameters, specified in
 2656 // the encoding block), and they use the
 2657 // opcode keyword to specify, in order, their primary, secondary, and
 2658 // tertiary opcode. Only the opcode sections which a particular instruction
 2659 // needs for encoding need to be specified.
 2660 encode %{
 2661   enc_class enc_unimplemented %{
 2662     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2663     MacroAssembler _masm(&amp;cbuf);
 2664     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 2665   %}
 2666 
 2667   enc_class enc_untested %{
 2668 #ifdef ASSERT
 2669     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2670     MacroAssembler _masm(&amp;cbuf);
 2671     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 2672 #else
 2673     // TODO: PPC port $archOpcode(ppc64Opcode_none);
 2674 #endif
 2675   %}
 2676 
 2677   enc_class enc_lbz(iRegIdst dst, memory mem) %{
 2678     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
 2679     MacroAssembler _masm(&amp;cbuf);
 2680     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2681     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2682   %}
 2683 
 2684   // Load acquire.
 2685   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
 2686     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2687     MacroAssembler _masm(&amp;cbuf);
 2688     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2689     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2690     __ twi_0($dst$$Register);
 2691     __ isync();
 2692   %}
 2693 
 2694   enc_class enc_lhz(iRegIdst dst, memory mem) %{
 2695     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
 2696 
 2697     MacroAssembler _masm(&amp;cbuf);
 2698     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2699     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2700   %}
 2701 
 2702   // Load acquire.
 2703   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
 2704     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2705 
 2706     MacroAssembler _masm(&amp;cbuf);
 2707     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2708     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2709     __ twi_0($dst$$Register);
 2710     __ isync();
 2711   %}
 2712 
 2713   enc_class enc_lwz(iRegIdst dst, memory mem) %{
 2714     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
 2715 
 2716     MacroAssembler _masm(&amp;cbuf);
 2717     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2718     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2719   %}
 2720 
 2721   // Load acquire.
 2722   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
 2723     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2724 
 2725     MacroAssembler _masm(&amp;cbuf);
 2726     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2727     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2728     __ twi_0($dst$$Register);
 2729     __ isync();
 2730   %}
 2731 
 2732   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
 2733     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2734     MacroAssembler _masm(&amp;cbuf);
 2735     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2736     // Operand &#39;ds&#39; requires 4-alignment.
 2737     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2738     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2739   %}
 2740 
 2741   // Load acquire.
 2742   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
 2743     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2744     MacroAssembler _masm(&amp;cbuf);
 2745     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2746     // Operand &#39;ds&#39; requires 4-alignment.
 2747     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2748     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2749     __ twi_0($dst$$Register);
 2750     __ isync();
 2751   %}
 2752 
 2753   enc_class enc_lfd(RegF dst, memory mem) %{
 2754     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 2755     MacroAssembler _masm(&amp;cbuf);
 2756     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2757     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 2758   %}
 2759 
 2760   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
 2761     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2762 
 2763     MacroAssembler _masm(&amp;cbuf);
 2764     int toc_offset = 0;
 2765 
 2766     address const_toc_addr;
 2767     // Create a non-oop constant, no relocation needed.
 2768     // If it is an IC, it has a virtual_call_Relocation.
 2769     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2770     if (const_toc_addr == NULL) {
 2771       ciEnv::current()-&gt;record_out_of_memory_failure();
 2772       return;
 2773     }
 2774 
 2775     // Get the constant&#39;s TOC offset.
 2776     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2777 
 2778     // Keep the current instruction offset in mind.
 2779     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2780 
 2781     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2782   %}
 2783 
 2784   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2785     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2786 
 2787     MacroAssembler _masm(&amp;cbuf);
 2788 
 2789     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 2790       address const_toc_addr;
 2791       // Create a non-oop constant, no relocation needed.
 2792       // If it is an IC, it has a virtual_call_Relocation.
 2793       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2794       if (const_toc_addr == NULL) {
 2795         ciEnv::current()-&gt;record_out_of_memory_failure();
 2796         return;
 2797       }
 2798 
 2799       // Get the constant&#39;s TOC offset.
 2800       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2801       // Store the toc offset of the constant.
 2802       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2803 
 2804       // Also keep the current instruction offset in mind.
 2805       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2806     }
 2807 
 2808     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2809   %}
 2810 
 2811 %} // encode
 2812 
 2813 source %{
 2814 
 2815 typedef struct {
 2816   loadConL_hiNode *_large_hi;
 2817   loadConL_loNode *_large_lo;
 2818   loadConLNode    *_small;
 2819   MachNode        *_last;
 2820 } loadConLNodesTuple;
 2821 
 2822 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2823                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
 2824   loadConLNodesTuple nodes;
 2825 
 2826   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2827   if (large_constant_pool) {
 2828     // Create new nodes.
 2829     loadConL_hiNode *m1 = new loadConL_hiNode();
 2830     loadConL_loNode *m2 = new loadConL_loNode();
 2831 
 2832     // inputs for new nodes
 2833     m1-&gt;add_req(NULL, toc);
 2834     m2-&gt;add_req(NULL, m1);
 2835 
 2836     // operands for new nodes
 2837     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2838     m1-&gt;_opnds[1] = immSrc;             // src
 2839     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2840     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2841     m2-&gt;_opnds[1] = immSrc;             // src
 2842     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 2843 
 2844     // Initialize ins_attrib TOC fields.
 2845     m1-&gt;_const_toc_offset = -1;
 2846     m2-&gt;_const_toc_offset_hi_node = m1;
 2847 
 2848     // Initialize ins_attrib instruction offset.
 2849     m1-&gt;_cbuf_insts_offset = -1;
 2850 
 2851     // register allocation for new nodes
 2852     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2853     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2854 
 2855     // Create result.
 2856     nodes._large_hi = m1;
 2857     nodes._large_lo = m2;
 2858     nodes._small = NULL;
 2859     nodes._last = nodes._large_lo;
 2860     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2861   } else {
 2862     loadConLNode *m2 = new loadConLNode();
 2863 
 2864     // inputs for new nodes
 2865     m2-&gt;add_req(NULL, toc);
 2866 
 2867     // operands for new nodes
 2868     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2869     m2-&gt;_opnds[1] = immSrc;             // src
 2870     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2871 
 2872     // Initialize ins_attrib instruction offset.
 2873     m2-&gt;_cbuf_insts_offset = -1;
 2874 
 2875     // register allocation for new nodes
 2876     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2877 
 2878     // Create result.
 2879     nodes._large_hi = NULL;
 2880     nodes._large_lo = NULL;
 2881     nodes._small = m2;
 2882     nodes._last = nodes._small;
 2883     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2884   }
 2885 
 2886   return nodes;
 2887 }
 2888 
 2889 typedef struct {
 2890   loadConL_hiNode *_large_hi;
 2891   loadConL_loNode *_large_lo;
 2892   mtvsrdNode      *_moved;
 2893   xxspltdNode     *_replicated;
 2894   loadConLNode    *_small;
 2895   MachNode        *_last;
 2896 } loadConLReplicatedNodesTuple;
 2897 
 2898 loadConLReplicatedNodesTuple loadConLReplicatedNodesTuple_create(Compile *C, PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2899                                                  vecXOper *dst, immI_0Oper *zero,
 2900                                                  OptoReg::Name reg_second, OptoReg::Name reg_first,
 2901                                                  OptoReg::Name reg_vec_second, OptoReg::Name reg_vec_first) {
 2902   loadConLReplicatedNodesTuple nodes;
 2903 
 2904   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2905   if (large_constant_pool) {
 2906     // Create new nodes.
 2907     loadConL_hiNode *m1 = new  loadConL_hiNode();
 2908     loadConL_loNode *m2 = new  loadConL_loNode();
 2909     mtvsrdNode *m3 = new  mtvsrdNode();
 2910     xxspltdNode *m4 = new  xxspltdNode();
 2911 
 2912     // inputs for new nodes
 2913     m1-&gt;add_req(NULL, toc);
 2914     m2-&gt;add_req(NULL, m1);
 2915     m3-&gt;add_req(NULL, m2);
 2916     m4-&gt;add_req(NULL, m3);
 2917 
 2918     // operands for new nodes
 2919     m1-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2920     m1-&gt;_opnds[1] = immSrc;              // src
 2921     m1-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2922 
 2923     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2924     m2-&gt;_opnds[1] = immSrc;              // src
 2925     m2-&gt;_opnds[2] = new  iRegLdstOper(); // base
 2926 
 2927     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2928     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2929 
 2930     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2931     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2932     m4-&gt;_opnds[2] = zero;
 2933 
 2934     // Initialize ins_attrib TOC fields.
 2935     m1-&gt;_const_toc_offset = -1;
 2936     m2-&gt;_const_toc_offset_hi_node = m1;
 2937 
 2938     // Initialize ins_attrib instruction offset.
 2939     m1-&gt;_cbuf_insts_offset = -1;
 2940 
 2941     // register allocation for new nodes
 2942     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2943     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2944     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2945     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2946     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2947 
 2948     // Create result.
 2949     nodes._large_hi = m1;
 2950     nodes._large_lo = m2;
 2951     nodes._moved = m3;
 2952     nodes._replicated = m4;
 2953     nodes._small = NULL;
 2954     nodes._last = nodes._replicated;
 2955     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2956   } else {
 2957     loadConLNode *m2 = new  loadConLNode();
 2958     mtvsrdNode *m3 = new  mtvsrdNode();
 2959     xxspltdNode *m4 = new  xxspltdNode();
 2960 
 2961     // inputs for new nodes
 2962     m2-&gt;add_req(NULL, toc);
 2963 
 2964     // operands for new nodes
 2965     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2966     m2-&gt;_opnds[1] = immSrc;              // src
 2967     m2-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2968 
 2969     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2970     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2971 
 2972     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2973     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2974     m4-&gt;_opnds[2] = zero;
 2975 
 2976     // Initialize ins_attrib instruction offset.
 2977     m2-&gt;_cbuf_insts_offset = -1;
 2978     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2979     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2980     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2981 
 2982     // register allocation for new nodes
 2983     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2984 
 2985     // Create result.
 2986     nodes._large_hi = NULL;
 2987     nodes._large_lo = NULL;
 2988     nodes._small = m2;
 2989     nodes._moved = m3;
 2990     nodes._replicated = m4;
 2991     nodes._last = nodes._replicated;
 2992     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2993   }
 2994 
 2995   return nodes;
 2996 }
 2997 
 2998 %} // source
 2999 
 3000 encode %{
 3001   // Postalloc expand emitter for loading a long constant from the method&#39;s TOC.
 3002   // Enc_class needed as consttanttablebase is not supported by postalloc
 3003   // expand.
 3004   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
 3005     // Create new nodes.
 3006     loadConLNodesTuple loadConLNodes =
 3007       loadConLNodesTuple_create(ra_, n_toc, op_src,
 3008                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3009 
 3010     // Push new nodes.
 3011     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3012     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3013 
 3014     // some asserts
 3015     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3016     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3017   %}
 3018 
 3019   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
 3020     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3021 
 3022     MacroAssembler _masm(&amp;cbuf);
 3023     int toc_offset = 0;
 3024 
 3025     intptr_t val = $src$$constant;
 3026     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3027     address const_toc_addr;
 3028     if (constant_reloc == relocInfo::oop_type) {
 3029       // Create an oop constant and a corresponding relocation.
 3030       AddressLiteral a = __ allocate_oop_address((jobject)val);
 3031       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3032       __ relocate(a.rspec());
 3033     } else if (constant_reloc == relocInfo::metadata_type) {
 3034       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3035       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3036       __ relocate(a.rspec());
 3037     } else {
 3038       // Create a non-oop constant, no relocation needed.
 3039       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3040     }
 3041 
 3042     if (const_toc_addr == NULL) {
 3043       ciEnv::current()-&gt;record_out_of_memory_failure();
 3044       return;
 3045     }
 3046     // Get the constant&#39;s TOC offset.
 3047     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3048 
 3049     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3050   %}
 3051 
 3052   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3053     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3054 
 3055     MacroAssembler _masm(&amp;cbuf);
 3056     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 3057       intptr_t val = $src$$constant;
 3058       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3059       address const_toc_addr;
 3060       if (constant_reloc == relocInfo::oop_type) {
 3061         // Create an oop constant and a corresponding relocation.
 3062         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3063         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3064         __ relocate(a.rspec());
 3065       } else if (constant_reloc == relocInfo::metadata_type) {
 3066         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3067         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3068         __ relocate(a.rspec());
 3069       } else {  // non-oop pointers, e.g. card mark base, heap top
 3070         // Create a non-oop constant, no relocation needed.
 3071         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3072       }
 3073 
 3074       if (const_toc_addr == NULL) {
 3075         ciEnv::current()-&gt;record_out_of_memory_failure();
 3076         return;
 3077       }
 3078       // Get the constant&#39;s TOC offset.
 3079       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 3080       // Store the toc offset of the constant.
 3081       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 3082     }
 3083 
 3084     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 3085   %}
 3086 
 3087   // Postalloc expand emitter for loading a ptr constant from the method&#39;s TOC.
 3088   // Enc_class needed as consttanttablebase is not supported by postalloc
 3089   // expand.
 3090   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
 3091     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3092     if (large_constant_pool) {
 3093       // Create new nodes.
 3094       loadConP_hiNode *m1 = new loadConP_hiNode();
 3095       loadConP_loNode *m2 = new loadConP_loNode();
 3096 
 3097       // inputs for new nodes
 3098       m1-&gt;add_req(NULL, n_toc);
 3099       m2-&gt;add_req(NULL, m1);
 3100 
 3101       // operands for new nodes
 3102       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3103       m1-&gt;_opnds[1] = op_src;             // src
 3104       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3105       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3106       m2-&gt;_opnds[1] = op_src;             // src
 3107       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 3108 
 3109       // Initialize ins_attrib TOC fields.
 3110       m1-&gt;_const_toc_offset = -1;
 3111       m2-&gt;_const_toc_offset_hi_node = m1;
 3112 
 3113       // Register allocation for new nodes.
 3114       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3115       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3116 
 3117       nodes-&gt;push(m1);
 3118       nodes-&gt;push(m2);
 3119       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3120     } else {
 3121       loadConPNode *m2 = new loadConPNode();
 3122 
 3123       // inputs for new nodes
 3124       m2-&gt;add_req(NULL, n_toc);
 3125 
 3126       // operands for new nodes
 3127       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3128       m2-&gt;_opnds[1] = op_src;             // src
 3129       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3130 
 3131       // Register allocation for new nodes.
 3132       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3133 
 3134       nodes-&gt;push(m2);
 3135       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3136     }
 3137   %}
 3138 
 3139   // Enc_class needed as consttanttablebase is not supported by postalloc
 3140   // expand.
 3141   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
 3142     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3143 
 3144     MachNode *m2;
 3145     if (large_constant_pool) {
 3146       m2 = new loadConFCompNode();
 3147     } else {
 3148       m2 = new loadConFNode();
 3149     }
 3150     // inputs for new nodes
 3151     m2-&gt;add_req(NULL, n_toc);
 3152 
 3153     // operands for new nodes
 3154     m2-&gt;_opnds[0] = op_dst;
 3155     m2-&gt;_opnds[1] = op_src;
 3156     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3157 
 3158     // register allocation for new nodes
 3159     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3160     nodes-&gt;push(m2);
 3161   %}
 3162 
 3163   // Enc_class needed as consttanttablebase is not supported by postalloc
 3164   // expand.
 3165   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
 3166     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3167 
 3168     MachNode *m2;
 3169     if (large_constant_pool) {
 3170       m2 = new loadConDCompNode();
 3171     } else {
 3172       m2 = new loadConDNode();
 3173     }
 3174     // inputs for new nodes
 3175     m2-&gt;add_req(NULL, n_toc);
 3176 
 3177     // operands for new nodes
 3178     m2-&gt;_opnds[0] = op_dst;
 3179     m2-&gt;_opnds[1] = op_src;
 3180     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3181 
 3182     // register allocation for new nodes
 3183     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3184     nodes-&gt;push(m2);
 3185   %}
 3186 
 3187   enc_class enc_stw(iRegIsrc src, memory mem) %{
 3188     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
 3189     MacroAssembler _masm(&amp;cbuf);
 3190     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3191     __ stw($src$$Register, Idisp, $mem$$base$$Register);
 3192   %}
 3193 
 3194   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
 3195     // TODO: PPC port $archOpcode(ppc64Opcode_std);
 3196     MacroAssembler _masm(&amp;cbuf);
 3197     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3198     // Operand &#39;ds&#39; requires 4-alignment.
 3199     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 3200     __ std($src$$Register, Idisp, $mem$$base$$Register);
 3201   %}
 3202 
 3203   enc_class enc_stfs(RegF src, memory mem) %{
 3204     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
 3205     MacroAssembler _masm(&amp;cbuf);
 3206     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3207     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3208   %}
 3209 
 3210   enc_class enc_stfd(RegF src, memory mem) %{
 3211     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
 3212     MacroAssembler _masm(&amp;cbuf);
 3213     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3214     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3215   %}
 3216 
 3217   // Use release_store for card-marking to ensure that previous
 3218   // oop-stores are visible before the card-mark change.
 3219   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 3220     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3221     // FIXME: Implement this as a cmove and use a fixed condition code
 3222     // register which is written on every transition to compiled code,
 3223     // e.g. in call-stub and when returning from runtime stubs.
 3224     //
 3225     // Proposed code sequence for the cmove implementation:
 3226     //
 3227     // Label skip_release;
 3228     // __ beq(CCRfixed, skip_release);
 3229     // __ release();
 3230     // __ bind(skip_release);
 3231     // __ stb(card mark);
 3232 
 3233     MacroAssembler _masm(&amp;cbuf);
 3234     Label skip_storestore;
 3235 
 3236 #if 0 // TODO: PPC port
 3237     // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
 3238     // StoreStore barrier conditionally.
 3239     __ lwz(R0, 0, $releaseFieldAddr$$Register);
 3240     __ cmpwi($crx$$CondRegister, R0, 0);
 3241     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
 3242 #endif
 3243     __ li(R0, 0);
 3244     __ membar(Assembler::StoreStore);
 3245 #if 0 // TODO: PPC port
 3246     __ bind(skip_storestore);
 3247 #endif
 3248 
 3249     // Do the store.
 3250     if ($mem$$index == 0) {
 3251       __ stb(R0, $mem$$disp, $mem$$base$$Register);
 3252     } else {
 3253       assert(0 == $mem$$disp, &quot;no displacement possible with indexed load/stores on ppc&quot;);
 3254       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
 3255     }
 3256   %}
 3257 
 3258   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
 3259 
 3260     if (VM_Version::has_isel()) {
 3261       // use isel instruction with Power 7
 3262       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3263       encodeP_subNode    *n_sub_base = new encodeP_subNode();
 3264       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3265       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
 3266 
 3267       n_compare-&gt;add_req(n_region, n_src);
 3268       n_compare-&gt;_opnds[0] = op_crx;
 3269       n_compare-&gt;_opnds[1] = op_src;
 3270       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3271 
 3272       n_sub_base-&gt;add_req(n_region, n_src);
 3273       n_sub_base-&gt;_opnds[0] = op_dst;
 3274       n_sub_base-&gt;_opnds[1] = op_src;
 3275       n_sub_base-&gt;_bottom_type = _bottom_type;
 3276 
 3277       n_shift-&gt;add_req(n_region, n_sub_base);
 3278       n_shift-&gt;_opnds[0] = op_dst;
 3279       n_shift-&gt;_opnds[1] = op_dst;
 3280       n_shift-&gt;_bottom_type = _bottom_type;
 3281 
 3282       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
 3283       n_cond_set-&gt;_opnds[0] = op_dst;
 3284       n_cond_set-&gt;_opnds[1] = op_crx;
 3285       n_cond_set-&gt;_opnds[2] = op_dst;
 3286       n_cond_set-&gt;_bottom_type = _bottom_type;
 3287 
 3288       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3289       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3290       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3291       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3292 
 3293       nodes-&gt;push(n_compare);
 3294       nodes-&gt;push(n_sub_base);
 3295       nodes-&gt;push(n_shift);
 3296       nodes-&gt;push(n_cond_set);
 3297 
 3298     } else {
 3299       // before Power 7
 3300       moveRegNode        *n_move     = new moveRegNode();
 3301       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3302       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3303       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
 3304 
 3305       n_move-&gt;add_req(n_region, n_src);
 3306       n_move-&gt;_opnds[0] = op_dst;
 3307       n_move-&gt;_opnds[1] = op_src;
 3308       ra_-&gt;set_oop(n_move, true); // Until here, &#39;n_move&#39; still produces an oop.
 3309 
 3310       n_compare-&gt;add_req(n_region, n_src);
 3311       n_compare-&gt;add_prec(n_move);
 3312 
 3313       n_compare-&gt;_opnds[0] = op_crx;
 3314       n_compare-&gt;_opnds[1] = op_src;
 3315       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3316 
 3317       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
 3318       n_sub_base-&gt;_opnds[0] = op_dst;
 3319       n_sub_base-&gt;_opnds[1] = op_crx;
 3320       n_sub_base-&gt;_opnds[2] = op_src;
 3321       n_sub_base-&gt;_bottom_type = _bottom_type;
 3322 
 3323       n_shift-&gt;add_req(n_region, n_sub_base);
 3324       n_shift-&gt;_opnds[0] = op_dst;
 3325       n_shift-&gt;_opnds[1] = op_dst;
 3326       n_shift-&gt;_bottom_type = _bottom_type;
 3327 
 3328       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3329       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3330       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3331       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3332 
 3333       nodes-&gt;push(n_move);
 3334       nodes-&gt;push(n_compare);
 3335       nodes-&gt;push(n_sub_base);
 3336       nodes-&gt;push(n_shift);
 3337     }
 3338 
 3339     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3340   %}
 3341 
 3342   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
 3343 
 3344     encodeP_subNode *n1 = new encodeP_subNode();
 3345     n1-&gt;add_req(n_region, n_src);
 3346     n1-&gt;_opnds[0] = op_dst;
 3347     n1-&gt;_opnds[1] = op_src;
 3348     n1-&gt;_bottom_type = _bottom_type;
 3349 
 3350     encodeP_shiftNode *n2 = new encodeP_shiftNode();
 3351     n2-&gt;add_req(n_region, n1);
 3352     n2-&gt;_opnds[0] = op_dst;
 3353     n2-&gt;_opnds[1] = op_dst;
 3354     n2-&gt;_bottom_type = _bottom_type;
 3355     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3356     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3357 
 3358     nodes-&gt;push(n1);
 3359     nodes-&gt;push(n2);
 3360     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3361   %}
 3362 
 3363   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 3364     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
 3365     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 3366 
 3367     n_compare-&gt;add_req(n_region, n_src);
 3368     n_compare-&gt;_opnds[0] = op_crx;
 3369     n_compare-&gt;_opnds[1] = op_src;
 3370     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 3371 
 3372     n_shift-&gt;add_req(n_region, n_src);
 3373     n_shift-&gt;_opnds[0] = op_dst;
 3374     n_shift-&gt;_opnds[1] = op_src;
 3375     n_shift-&gt;_bottom_type = _bottom_type;
 3376 
 3377     if (VM_Version::has_isel()) {
 3378       // use isel instruction with Power 7
 3379 
 3380       decodeN_addNode *n_add_base = new decodeN_addNode();
 3381       n_add_base-&gt;add_req(n_region, n_shift);
 3382       n_add_base-&gt;_opnds[0] = op_dst;
 3383       n_add_base-&gt;_opnds[1] = op_dst;
 3384       n_add_base-&gt;_bottom_type = _bottom_type;
 3385 
 3386       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 3387       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
 3388       n_cond_set-&gt;_opnds[0] = op_dst;
 3389       n_cond_set-&gt;_opnds[1] = op_crx;
 3390       n_cond_set-&gt;_opnds[2] = op_dst;
 3391       n_cond_set-&gt;_bottom_type = _bottom_type;
 3392 
 3393       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3394       ra_-&gt;set_oop(n_cond_set, true);
 3395 
 3396       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3397       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3398       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3399       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3400 
 3401       nodes-&gt;push(n_compare);
 3402       nodes-&gt;push(n_shift);
 3403       nodes-&gt;push(n_add_base);
 3404       nodes-&gt;push(n_cond_set);
 3405 
 3406     } else {
 3407       // before Power 7
 3408       cond_add_baseNode *n_add_base = new cond_add_baseNode();
 3409 
 3410       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
 3411       n_add_base-&gt;_opnds[0] = op_dst;
 3412       n_add_base-&gt;_opnds[1] = op_crx;
 3413       n_add_base-&gt;_opnds[2] = op_dst;
 3414       n_add_base-&gt;_bottom_type = _bottom_type;
 3415 
 3416       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3417       ra_-&gt;set_oop(n_add_base, true);
 3418 
 3419       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3420       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3421       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3422 
 3423       nodes-&gt;push(n_compare);
 3424       nodes-&gt;push(n_shift);
 3425       nodes-&gt;push(n_add_base);
 3426     }
 3427   %}
 3428 
 3429   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
 3430     decodeN_shiftNode *n1 = new decodeN_shiftNode();
 3431     n1-&gt;add_req(n_region, n_src);
 3432     n1-&gt;_opnds[0] = op_dst;
 3433     n1-&gt;_opnds[1] = op_src;
 3434     n1-&gt;_bottom_type = _bottom_type;
 3435 
 3436     decodeN_addNode *n2 = new decodeN_addNode();
 3437     n2-&gt;add_req(n_region, n1);
 3438     n2-&gt;_opnds[0] = op_dst;
 3439     n2-&gt;_opnds[1] = op_dst;
 3440     n2-&gt;_bottom_type = _bottom_type;
 3441     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3442     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3443 
 3444     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3445     ra_-&gt;set_oop(n2, true);
 3446 
 3447     nodes-&gt;push(n1);
 3448     nodes-&gt;push(n2);
 3449   %}
 3450 
 3451   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
 3452     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3453 
 3454     MacroAssembler _masm(&amp;cbuf);
 3455     int cc        = $cmp$$cmpcode;
 3456     int flags_reg = $crx$$reg;
 3457     Label done;
 3458     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3459     // Branch if not (cmp crx).
 3460     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
 3461     __ mr($dst$$Register, $src$$Register);
 3462     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3463     __ bind(done);
 3464   %}
 3465 
 3466   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
 3467     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3468 
 3469     MacroAssembler _masm(&amp;cbuf);
 3470     Label done;
 3471     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3472     // Branch if not (cmp crx).
 3473     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 3474     __ li($dst$$Register, $src$$constant);
 3475     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3476     __ bind(done);
 3477   %}
 3478 
 3479   // This enc_class is needed so that scheduler gets proper
 3480   // input mapping for latency computation.
 3481   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 3482     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
 3483     MacroAssembler _masm(&amp;cbuf);
 3484     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
 3485   %}
 3486 
 3487   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3488     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3489 
 3490     MacroAssembler _masm(&amp;cbuf);
 3491 
 3492     Label done;
 3493     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
 3494     __ li($dst$$Register, $zero$$constant);
 3495     __ beq($crx$$CondRegister, done);
 3496     __ li($dst$$Register, $notzero$$constant);
 3497     __ bind(done);
 3498   %}
 3499 
 3500   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3501     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3502 
 3503     MacroAssembler _masm(&amp;cbuf);
 3504 
 3505     Label done;
 3506     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
 3507     __ li($dst$$Register, $zero$$constant);
 3508     __ beq($crx$$CondRegister, done);
 3509     __ li($dst$$Register, $notzero$$constant);
 3510     __ bind(done);
 3511   %}
 3512 
 3513   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
 3514     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3515 
 3516     MacroAssembler _masm(&amp;cbuf);
 3517     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3518     Label done;
 3519     __ bso($crx$$CondRegister, done);
 3520     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 3521     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3522     __ bind(done);
 3523   %}
 3524 
 3525   enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
 3526     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3527 
 3528     MacroAssembler _masm(&amp;cbuf);
 3529     Label done;
 3530     __ bso($crx$$CondRegister, done);
 3531     __ mffprd($dst$$Register, $src$$FloatRegister);
 3532     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3533     __ bind(done);
 3534   %}
 3535 
 3536   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3537     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3538 
 3539     MacroAssembler _masm(&amp;cbuf);
 3540     Label d;   // dummy
 3541     __ bind(d);
 3542     Label* p = ($lbl$$label);
 3543     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3544     // determine the size of the encoded instruction.
 3545     Label&amp; l = (NULL == p)? d : *(p);
 3546     int cc = $cmp$$cmpcode;
 3547     int flags_reg = $crx$$reg;
 3548     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3549     int bhint = Assembler::bhintNoHint;
 3550 
 3551     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3552       if (_prob &lt;= PROB_NEVER) {
 3553         bhint = Assembler::bhintIsNotTaken;
 3554       } else if (_prob &gt;= PROB_ALWAYS) {
 3555         bhint = Assembler::bhintIsTaken;
 3556       }
 3557     }
 3558 
 3559     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3560           cc_to_biint(cc, flags_reg),
 3561           l);
 3562   %}
 3563 
 3564   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3565     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3566     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3567     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3568 
 3569     MacroAssembler _masm(&amp;cbuf);
 3570     Label d;    // dummy
 3571     __ bind(d);
 3572     Label* p = ($lbl$$label);
 3573     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3574     // determine the size of the encoded instruction.
 3575     Label&amp; l = (NULL == p)? d : *(p);
 3576     int cc = $cmp$$cmpcode;
 3577     int flags_reg = $crx$$reg;
 3578     int bhint = Assembler::bhintNoHint;
 3579 
 3580     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3581       if (_prob &lt;= PROB_NEVER) {
 3582         bhint = Assembler::bhintIsNotTaken;
 3583       } else if (_prob &gt;= PROB_ALWAYS) {
 3584         bhint = Assembler::bhintIsTaken;
 3585       }
 3586     }
 3587 
 3588     // Tell the conditional far branch to optimize itself when being relocated.
 3589     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3590                   cc_to_biint(cc, flags_reg),
 3591                   l,
 3592                   MacroAssembler::bc_far_optimize_on_relocate);
 3593   %}
 3594 
 3595   // Branch used with Power6 scheduling (can be shortened without changing the node).
 3596   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3597     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3598     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3599     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3600 
 3601     MacroAssembler _masm(&amp;cbuf);
 3602     Label d;   // dummy
 3603     __ bind(d);
 3604     Label* p = ($lbl$$label);
 3605     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3606     // determine the size of the encoded instruction.
 3607     Label&amp; l = (NULL == p)? d : *(p);
 3608     int cc = $cmp$$cmpcode;
 3609     int flags_reg = $crx$$reg;
 3610     int bhint = Assembler::bhintNoHint;
 3611 
 3612     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3613       if (_prob &lt;= PROB_NEVER) {
 3614         bhint = Assembler::bhintIsNotTaken;
 3615       } else if (_prob &gt;= PROB_ALWAYS) {
 3616         bhint = Assembler::bhintIsTaken;
 3617       }
 3618     }
 3619 
 3620 #if 0 // TODO: PPC port
 3621     if (_size == 8) {
 3622       // Tell the conditional far branch to optimize itself when being relocated.
 3623       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3624                     cc_to_biint(cc, flags_reg),
 3625                     l,
 3626                     MacroAssembler::bc_far_optimize_on_relocate);
 3627     } else {
 3628       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3629                     cc_to_biint(cc, flags_reg),
 3630                     l);
 3631     }
 3632 #endif
 3633     Unimplemented();
 3634   %}
 3635 
 3636   // Postalloc expand emitter for loading a replicatef float constant from
 3637   // the method&#39;s TOC.
 3638   // Enc_class needed as consttanttablebase is not supported by postalloc
 3639   // expand.
 3640   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
 3641     // Create new nodes.
 3642 
 3643     // Make an operand with the bit pattern to load as float.
 3644     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3645 
 3646     loadConLNodesTuple loadConLNodes =
 3647       loadConLNodesTuple_create(ra_, n_toc, op_repl,
 3648                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3649 
 3650     // Push new nodes.
 3651     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3652     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3653 
 3654     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3655     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3656   %}
 3657 
 3658   enc_class postalloc_expand_load_replF_constant_vsx(vecX dst, immF src, iRegLdst toc, iRegLdst tmp) %{
 3659     // Create new nodes.
 3660 
 3661     // Make an operand with the bit pattern to load as float.
 3662     immLOper *op_repl = new  immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3663     immI_0Oper *op_zero = new  immI_0Oper(0);
 3664 
 3665     loadConLReplicatedNodesTuple loadConLNodes =
 3666       loadConLReplicatedNodesTuple_create(C, ra_, n_toc, op_repl, op_dst, op_zero,
 3667                                 ra_-&gt;get_reg_second(n_tmp), ra_-&gt;get_reg_first(n_tmp),
 3668                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3669 
 3670     // Push new nodes.
 3671     if (loadConLNodes._large_hi) { nodes-&gt;push(loadConLNodes._large_hi); }
 3672     if (loadConLNodes._large_lo) { nodes-&gt;push(loadConLNodes._large_lo); }
 3673     if (loadConLNodes._moved)    { nodes-&gt;push(loadConLNodes._moved); }
 3674     if (loadConLNodes._last)     { nodes-&gt;push(loadConLNodes._last); }
 3675 
 3676     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3677   %}
 3678 
 3679   // This enc_class is needed so that scheduler gets proper
 3680   // input mapping for latency computation.
 3681   enc_class enc_poll(immI dst, iRegLdst poll) %{
 3682     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3683     // Fake operand dst needed for PPC scheduler.
 3684     assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
 3685 
 3686     MacroAssembler _masm(&amp;cbuf);
 3687     // Mark the code position where the load from the safepoint
 3688     // polling page was emitted as relocInfo::poll_type.
 3689     __ relocate(relocInfo::poll_type);
 3690     __ load_from_polling_page($poll$$Register);
 3691   %}
 3692 
 3693   // A Java static call or a runtime call.
 3694   //
 3695   // Branch-and-link relative to a trampoline.
 3696   // The trampoline loads the target address and does a long branch to there.
 3697   // In case we call java, the trampoline branches to a interpreter_stub
 3698   // which loads the inline cache and the real call target from the constant pool.
 3699   //
 3700   // This basically looks like this:
 3701   //
 3702   // &gt;&gt;&gt;&gt; consts      -+  -+
 3703   //                   |   |- offset1
 3704   // [call target1]    | &lt;-+
 3705   // [IC cache]        |- offset2
 3706   // [call target2] &lt;--+
 3707   //
 3708   // &lt;&lt;&lt;&lt; consts
 3709   // &gt;&gt;&gt;&gt; insts
 3710   //
 3711   // bl offset16               -+  -+             ??? // How many bits available?
 3712   //                            |   |
 3713   // &lt;&lt;&lt;&lt; insts                 |   |
 3714   // &gt;&gt;&gt;&gt; stubs                 |   |
 3715   //                            |   |- trampoline_stub_Reloc
 3716   // trampoline stub:           | &lt;-+
 3717   //   r2 = toc                 |
 3718   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
 3719   //   mtctr r2                 |
 3720   //   bctr                     |- static_stub_Reloc
 3721   // comp_to_interp_stub:   &lt;---+
 3722   //   r1 = toc
 3723   //   ICreg = [r1 + IC_offset]         // Load IC from const section
 3724   //   r1    = [r1 + offset2]           // Load call target2 from const section
 3725   //   mtctr r1
 3726   //   bctr
 3727   //
 3728   // &lt;&lt;&lt;&lt; stubs
 3729   //
 3730   // The call instruction in the code either
 3731   // - Branches directly to a compiled method if the offset is encodable in instruction.
 3732   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
 3733   // - Branches to the compiled_to_interp stub if the target is interpreted.
 3734   //
 3735   // Further there are three relocations from the loads to the constants in
 3736   // the constant section.
 3737   //
 3738   // Usage of r1 and r2 in the stubs allows to distinguish them.
 3739   enc_class enc_java_static_call(method meth) %{
 3740     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3741 
 3742     MacroAssembler _masm(&amp;cbuf);
 3743     address entry_point = (address)$meth$$method;
 3744 
 3745     if (!_method) {
 3746       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
 3747       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
 3748     } else {
 3749       // Remember the offset not the address.
 3750       const int start_offset = __ offset();
 3751 
 3752       // The trampoline stub.
 3753       // No entry point given, use the current pc.
 3754       // Make sure branch fits into
 3755       if (entry_point == 0) entry_point = __ pc();
 3756 
 3757       // Put the entry point as a constant into the constant pool.
 3758       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
 3759       if (entry_point_toc_addr == NULL) {
 3760         ciEnv::current()-&gt;record_out_of_memory_failure();
 3761         return;
 3762       }
 3763       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 3764 
 3765       // Emit the trampoline stub which will be related to the branch-and-link below.
 3766       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
 3767       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
 3768       int method_index = resolved_method_index(cbuf);
 3769       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 3770                   : static_call_Relocation::spec(method_index));
 3771 
 3772       // The real call.
 3773       // Note: At this point we do not have the address of the trampoline
 3774       // stub, and the entry point might be too far away for bl, so __ pc()
 3775       // serves as dummy and the bl will be patched later.
 3776       cbuf.set_insts_mark();
 3777       __ bl(__ pc());  // Emits a relocation.
 3778 
 3779       // The stub for call to interpreter.
 3780       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3781       if (stub == NULL) {
 3782         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3783         return;
 3784       }
 3785     }
 3786   %}
 3787 
 3788   // Second node of expanded dynamic call - the call.
 3789   enc_class enc_java_dynamic_call_sched(method meth) %{
 3790     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3791 
 3792     MacroAssembler _masm(&amp;cbuf);
 3793 
 3794     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {
 3795       // Create a call trampoline stub for the given method.
 3796       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3797       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3798       if (entry_point_const == NULL) {
 3799         ciEnv::current()-&gt;record_out_of_memory_failure();
 3800         return;
 3801       }
 3802       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3803       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3804       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3805 
 3806       // Build relocation at call site with ic position as data.
 3807       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3808              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3809              &quot;must have one, but can&#39;t have both&quot;);
 3810       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3811              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3812              &quot;must contain instruction offset&quot;);
 3813       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3814         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
 3815         : _load_ic_node-&gt;_cbuf_insts_offset;
 3816       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
 3817       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
 3818              &quot;should be load from TOC&quot;);
 3819       int method_index = resolved_method_index(cbuf);
 3820       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 3821     }
 3822 
 3823     // At this point I do not have the address of the trampoline stub,
 3824     // and the entry point might be too far away for bl. Pc() serves
 3825     // as dummy and bl will be patched later.
 3826     __ bl((address) __ pc());
 3827   %}
 3828 
 3829   // postalloc expand emitter for virtual calls.
 3830   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
 3831 
 3832     // Create the nodes for loading the IC from the TOC.
 3833     loadConLNodesTuple loadConLNodes_IC =
 3834       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
 3835                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
 3836 
 3837     // Create the call node.
 3838     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
 3839     call-&gt;_method_handle_invoke = _method_handle_invoke;
 3840     call-&gt;_vtable_index      = _vtable_index;
 3841     call-&gt;_method            = _method;
 3842     call-&gt;_bci               = _bci;
 3843     call-&gt;_optimized_virtual = _optimized_virtual;
 3844     call-&gt;_tf                = _tf;
 3845     call-&gt;_entry_point       = _entry_point;
 3846     call-&gt;_cnt               = _cnt;
 3847     call-&gt;_argsize           = _argsize;
 3848     call-&gt;_oop_map           = _oop_map;
 3849     call-&gt;_jvms              = _jvms;
 3850     call-&gt;_jvmadj            = _jvmadj;
 3851     call-&gt;_in_rms            = _in_rms;
 3852     call-&gt;_nesting           = _nesting;
 3853     call-&gt;_override_symbolic_info = _override_symbolic_info;
 3854 
 3855     // New call needs all inputs of old call.
 3856     // Req...
 3857     for (uint i = 0; i &lt; req(); ++i) {
 3858       // The expanded node does not need toc any more.
 3859       // Add the inline cache constant here instead. This expresses the
 3860       // register of the inline cache must be live at the call.
 3861       // Else we would have to adapt JVMState by -1.
 3862       if (i == mach_constant_base_node_input()) {
 3863         call-&gt;add_req(loadConLNodes_IC._last);
 3864       } else {
 3865         call-&gt;add_req(in(i));
 3866       }
 3867     }
 3868     // ...as well as prec
 3869     for (uint i = req(); i &lt; len(); ++i) {
 3870       call-&gt;add_prec(in(i));
 3871     }
 3872 
 3873     // Remember nodes loading the inline cache into r19.
 3874     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
 3875     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
 3876 
 3877     // Operands for new nodes.
 3878     call-&gt;_opnds[0] = _opnds[0];
 3879     call-&gt;_opnds[1] = _opnds[1];
 3880 
 3881     // Only the inline cache is associated with a register.
 3882     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), &quot;ic reg should be R19&quot;);
 3883 
 3884     // Push new nodes.
 3885     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
 3886     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
 3887     nodes-&gt;push(call);
 3888   %}
 3889 
 3890   // Compound version of call dynamic
 3891   // Toc is only passed so that it can be used in ins_encode statement.
 3892   // In the code we have to use $constanttablebase.
 3893   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
 3894     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3895     MacroAssembler _masm(&amp;cbuf);
 3896     int start_offset = __ offset();
 3897 
 3898     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
 3899 #if 0
 3900     int vtable_index = this-&gt;_vtable_index;
 3901     if (_vtable_index &lt; 0) {
 3902       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 3903       assert(_vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 3904       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
 3905 
 3906       // Virtual call relocation will point to ic load.
 3907       address virtual_call_meta_addr = __ pc();
 3908       // Load a clear inline cache.
 3909       AddressLiteral empty_ic((address) Universe::non_oop_word());
 3910       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
 3911       if (!success) {
 3912         ciEnv::current()-&gt;record_out_of_memory_failure();
 3913         return;
 3914       }
 3915       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
 3916       // to determine who we intended to call.
 3917       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 3918       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
 3919       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3920              &quot;Fix constant in ret_addr_offset()&quot;);
 3921     } else {
 3922       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 3923       // Go thru the vtable. Get receiver klass. Receiver already
 3924       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 3925       // interpreter expects method in R19_method.
 3926 
 3927       __ load_klass(R11_scratch1, R3);
 3928 
 3929       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
 3930       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 3931       __ li(R19_method, v_off);
 3932       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
 3933       // NOTE: for vtable dispatches, the vtable entry will never be
 3934       // null. However it may very well end up in handle_wrong_method
 3935       // if the method is abstract for the particular class.
 3936       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
 3937       // Call target. Either compiled code or C2I adapter.
 3938       __ mtctr(R11_scratch1);
 3939       __ bctrl();
 3940       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
 3941         tty-&gt;print(&quot; %d, %d\n&quot;, ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
 3942       }
 3943       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3944              &quot;Fix constant in ret_addr_offset()&quot;);
 3945     }
 3946 #endif
 3947     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
 3948   %}
 3949 
 3950   // a runtime call
 3951   enc_class enc_java_to_runtime_call (method meth) %{
 3952     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3953 
 3954     MacroAssembler _masm(&amp;cbuf);
 3955     const address start_pc = __ pc();
 3956 
 3957 #if defined(ABI_ELFv2)
 3958     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
 3959     __ call_c(entry, relocInfo::runtime_call_type);
 3960 #else
 3961     // The function we&#39;re going to call.
 3962     FunctionDescriptor fdtemp;
 3963     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
 3964 
 3965     Register Rtoc = R12_scratch2;
 3966     // Calculate the method&#39;s TOC.
 3967     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
 3968     // Put entry, env, toc into the constant pool, this needs up to 3 constant
 3969     // pool entries; call_c_using_toc will optimize the call.
 3970     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
 3971     if (!success) {
 3972       ciEnv::current()-&gt;record_out_of_memory_failure();
 3973       return;
 3974     }
 3975 #endif
 3976 
 3977     // Check the ret_addr_offset.
 3978     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
 3979            &quot;Fix constant in ret_addr_offset()&quot;);
 3980   %}
 3981 
 3982   // Move to ctr for leaf call.
 3983   // This enc_class is needed so that scheduler gets proper
 3984   // input mapping for latency computation.
 3985   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
 3986     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
 3987     MacroAssembler _masm(&amp;cbuf);
 3988     __ mtctr($src$$Register);
 3989   %}
 3990 
 3991   // Postalloc expand emitter for runtime leaf calls.
 3992   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
 3993     loadConLNodesTuple loadConLNodes_Entry;
 3994 #if defined(ABI_ELFv2)
 3995     jlong entry_address = (jlong) this-&gt;entry_point();
 3996     assert(entry_address, &quot;need address here&quot;);
 3997     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 3998                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 3999 #else
 4000     // Get the struct that describes the function we are about to call.
 4001     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
 4002     assert(fd, &quot;need fd here&quot;);
 4003     jlong entry_address = (jlong) fd-&gt;entry();
 4004     // new nodes
 4005     loadConLNodesTuple loadConLNodes_Env;
 4006     loadConLNodesTuple loadConLNodes_Toc;
 4007 
 4008     // Create nodes and operands for loading the entry point.
 4009     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4010                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4011 
 4012 
 4013     // Create nodes and operands for loading the env pointer.
 4014     if (fd-&gt;env() != NULL) {
 4015       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
 4016                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4017     } else {
 4018       loadConLNodes_Env._large_hi = NULL;
 4019       loadConLNodes_Env._large_lo = NULL;
 4020       loadConLNodes_Env._small    = NULL;
 4021       loadConLNodes_Env._last = new loadConL16Node();
 4022       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
 4023       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
 4024       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4025     }
 4026 
 4027     // Create nodes and operands for loading the Toc point.
 4028     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
 4029                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
 4030 #endif // ABI_ELFv2
 4031     // mtctr node
 4032     MachNode *mtctr = new CallLeafDirect_mtctrNode();
 4033 
 4034     assert(loadConLNodes_Entry._last != NULL, &quot;entry must exist&quot;);
 4035     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
 4036 
 4037     mtctr-&gt;_opnds[0] = new iRegLdstOper();
 4038     mtctr-&gt;_opnds[1] = new iRegLdstOper();
 4039 
 4040     // call node
 4041     MachCallLeafNode *call = new CallLeafDirectNode();
 4042 
 4043     call-&gt;_opnds[0] = _opnds[0];
 4044     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
 4045 
 4046     // Make the new call node look like the old one.
 4047     call-&gt;_name        = _name;
 4048     call-&gt;_tf          = _tf;
 4049     call-&gt;_entry_point = _entry_point;
 4050     call-&gt;_cnt         = _cnt;
 4051     call-&gt;_argsize     = _argsize;
 4052     call-&gt;_oop_map     = _oop_map;
 4053     guarantee(!_jvms, &quot;You must clone the jvms and adapt the offsets by fix_jvms().&quot;);
 4054     call-&gt;_jvms        = NULL;
 4055     call-&gt;_jvmadj      = _jvmadj;
 4056     call-&gt;_in_rms      = _in_rms;
 4057     call-&gt;_nesting     = _nesting;
 4058 
 4059 
 4060     // New call needs all inputs of old call.
 4061     // Req...
 4062     for (uint i = 0; i &lt; req(); ++i) {
 4063       if (i != mach_constant_base_node_input()) {
 4064         call-&gt;add_req(in(i));
 4065       }
 4066     }
 4067 
 4068     // These must be reqired edges, as the registers are live up to
 4069     // the call. Else the constants are handled as kills.
 4070     call-&gt;add_req(mtctr);
 4071 #if !defined(ABI_ELFv2)
 4072     call-&gt;add_req(loadConLNodes_Env._last);
 4073     call-&gt;add_req(loadConLNodes_Toc._last);
 4074 #endif
 4075 
 4076     // ...as well as prec
 4077     for (uint i = req(); i &lt; len(); ++i) {
 4078       call-&gt;add_prec(in(i));
 4079     }
 4080 
 4081     // registers
 4082     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
 4083 
 4084     // Insert the new nodes.
 4085     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
 4086     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
 4087 #if !defined(ABI_ELFv2)
 4088     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
 4089     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
 4090     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
 4091     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
 4092 #endif
 4093     nodes-&gt;push(mtctr);
 4094     nodes-&gt;push(call);
 4095   %}
 4096 %}
 4097 
 4098 //----------FRAME--------------------------------------------------------------
 4099 // Definition of frame structure and management information.
 4100 
 4101 frame %{
 4102   // What direction does stack grow in (assumed to be same for native &amp; Java).
 4103   stack_direction(TOWARDS_LOW);
 4104 
 4105   // These two registers define part of the calling convention between
 4106   // compiled code and the interpreter.
 4107 
 4108   // Inline Cache Register or method for I2C.
 4109   inline_cache_reg(R19); // R19_method
 4110 
 4111   // Method Oop Register when calling interpreter.
 4112   interpreter_method_oop_reg(R19); // R19_method
 4113 
 4114   // Optional: name the operand used by cisc-spilling to access
 4115   // [stack_pointer + offset].
 4116   cisc_spilling_operand_name(indOffset);
 4117 
 4118   // Number of stack slots consumed by a Monitor enter.
 4119   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
 4120 
 4121   // Compiled code&#39;s Frame Pointer.
 4122   frame_pointer(R1); // R1_SP
 4123 
 4124   // Interpreter stores its frame pointer in a register which is
 4125   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 4126   // interpreted java to compiled java.
 4127   //
 4128   // R14_state holds pointer to caller&#39;s cInterpreter.
 4129   interpreter_frame_pointer(R14); // R14_state
 4130 
 4131   stack_alignment(frame::alignment_in_bytes);
 4132 
 4133   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
 4134 
 4135   // Number of outgoing stack slots killed above the
 4136   // out_preserve_stack_slots for calls to C. Supports the var-args
 4137   // backing area for register parms.
 4138   //
 4139   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 4140 
 4141   // The after-PROLOG location of the return address. Location of
 4142   // return address specifies a type (REG or STACK) and a number
 4143   // representing the register number (i.e. - use a register name) or
 4144   // stack slot.
 4145   //
 4146   // A: Link register is stored in stack slot ...
 4147   // M:  ... but it&#39;s in the caller&#39;s frame according to PPC-64 ABI.
 4148   // J: Therefore, we make sure that the link register is also in R11_scratch1
 4149   //    at the end of the prolog.
 4150   // B: We use R20, now.
 4151   //return_addr(REG R20);
 4152 
 4153   // G: After reading the comments made by all the luminaries on their
 4154   //    failure to tell the compiler where the return address really is,
 4155   //    I hardly dare to try myself.  However, I&#39;m convinced it&#39;s in slot
 4156   //    4 what apparently works and saves us some spills.
 4157   return_addr(STACK 4);
 4158 
 4159   // This is the body of the function
 4160   //
 4161   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
 4162   //                                  uint length,      // length of array
 4163   //                                  bool is_outgoing)
 4164   //
 4165   // The `sig&#39; array is to be updated. sig[j] represents the location
 4166   // of the j-th argument, either a register or a stack slot.
 4167 
 4168   // Comment taken from i486.ad:
 4169   // Body of function which returns an integer array locating
 4170   // arguments either in registers or in stack slots. Passed an array
 4171   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4172   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4173   // arguments for a CALLEE. Incoming stack arguments are
 4174   // automatically biased by the preserve_stack_slots field above.
 4175   calling_convention %{
 4176     // No difference between ingoing/outgoing. Just pass false.
 4177     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 4178   %}
 4179 
 4180   // Comment taken from i486.ad:
 4181   // Body of function which returns an integer array locating
 4182   // arguments either in registers or in stack slots. Passed an array
 4183   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4184   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4185   // arguments for a CALLEE. Incoming stack arguments are
 4186   // automatically biased by the preserve_stack_slots field above.
 4187   c_calling_convention %{
 4188     // This is obviously always outgoing.
 4189     // C argument in register AND stack slot.
 4190     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4191   %}
 4192 
 4193   // Location of native (C/C++) and interpreter return values. This
 4194   // is specified to be the same as Java. In the 32-bit VM, long
 4195   // values are actually returned from native calls in O0:O1 and
 4196   // returned to the interpreter in I0:I1. The copying to and from
 4197   // the register pairs is done by the appropriate call and epilog
 4198   // opcodes. This simplifies the register allocator.
 4199   c_return_value %{
 4200     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4201             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4202             &quot;only return normal values&quot;);
 4203     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4204     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4205     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4206     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4207   %}
 4208 
 4209   // Location of compiled Java return values.  Same as C
 4210   return_value %{
 4211     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4212             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4213             &quot;only return normal values&quot;);
 4214     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4215     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4216     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4217     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4218   %}
 4219 %}
 4220 
 4221 
 4222 //----------ATTRIBUTES---------------------------------------------------------
 4223 
 4224 //----------Operand Attributes-------------------------------------------------
 4225 op_attrib op_cost(1);          // Required cost attribute.
 4226 
 4227 //----------Instruction Attributes---------------------------------------------
 4228 
 4229 // Cost attribute. required.
 4230 ins_attrib ins_cost(DEFAULT_COST);
 4231 
 4232 // Is this instruction a non-matching short branch variant of some
 4233 // long branch? Not required.
 4234 ins_attrib ins_short_branch(0);
 4235 
 4236 ins_attrib ins_is_TrapBasedCheckNode(true);
 4237 
 4238 // Number of constants.
 4239 // This instruction uses the given number of constants
 4240 // (optional attribute).
 4241 // This is needed to determine in time whether the constant pool will
 4242 // exceed 4000 entries. Before postalloc_expand the overall number of constants
 4243 // is determined. It&#39;s also used to compute the constant pool size
 4244 // in Output().
 4245 ins_attrib ins_num_consts(0);
 4246 
 4247 // Required alignment attribute (must be a power of 2) specifies the
 4248 // alignment that some part of the instruction (not necessarily the
 4249 // start) requires. If &gt; 1, a compute_padding() function must be
 4250 // provided for the instruction.
 4251 ins_attrib ins_alignment(1);
 4252 
 4253 // Enforce/prohibit rematerializations.
 4254 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 4255 //   then rematerialization of that instruction is prohibited and the
 4256 //   instruction&#39;s value will be spilled if necessary.
 4257 //   Causes that MachNode::rematerialize() returns false.
 4258 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 4259 //   then rematerialization should be enforced and a copy of the instruction
 4260 //   should be inserted if possible; rematerialization is not guaranteed.
 4261 //   Note: this may result in rematerializations in front of every use.
 4262 //   Causes that MachNode::rematerialize() can return true.
 4263 // (optional attribute)
 4264 ins_attrib ins_cannot_rematerialize(false);
 4265 ins_attrib ins_should_rematerialize(false);
 4266 
 4267 // Instruction has variable size depending on alignment.
 4268 ins_attrib ins_variable_size_depending_on_alignment(false);
 4269 
 4270 // Instruction is a nop.
 4271 ins_attrib ins_is_nop(false);
 4272 
 4273 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
 4274 ins_attrib ins_use_mach_if_fast_lock_node(false);
 4275 
 4276 // Field for the toc offset of a constant.
 4277 //
 4278 // This is needed if the toc offset is not encodable as an immediate in
 4279 // the PPC load instruction. If so, the upper (hi) bits of the offset are
 4280 // added to the toc, and from this a load with immediate is performed.
 4281 // With postalloc expand, we get two nodes that require the same offset
 4282 // but which don&#39;t know about each other. The offset is only known
 4283 // when the constant is added to the constant pool during emitting.
 4284 // It is generated in the &#39;hi&#39;-node adding the upper bits, and saved
 4285 // in this node.  The &#39;lo&#39;-node has a link to the &#39;hi&#39;-node and reads
 4286 // the offset from there when it gets encoded.
 4287 ins_attrib ins_field_const_toc_offset(0);
 4288 ins_attrib ins_field_const_toc_offset_hi_node(0);
 4289 
 4290 // A field that can hold the instructions offset in the code buffer.
 4291 // Set in the nodes emitter.
 4292 ins_attrib ins_field_cbuf_insts_offset(-1);
 4293 
 4294 // Fields for referencing a call&#39;s load-IC-node.
 4295 // If the toc offset can not be encoded as an immediate in a load, we
 4296 // use two nodes.
 4297 ins_attrib ins_field_load_ic_hi_node(0);
 4298 ins_attrib ins_field_load_ic_node(0);
 4299 
 4300 //----------OPERANDS-----------------------------------------------------------
 4301 // Operand definitions must precede instruction definitions for correct
 4302 // parsing in the ADLC because operands constitute user defined types
 4303 // which are used in instruction definitions.
 4304 //
 4305 // Formats are generated automatically for constants and base registers.
 4306 
 4307 operand vecX() %{
 4308   constraint(ALLOC_IN_RC(vs_reg));
 4309   match(VecX);
 4310 
 4311   format %{ %}
 4312   interface(REG_INTER);
 4313 %}
 4314 
 4315 //----------Simple Operands----------------------------------------------------
 4316 // Immediate Operands
 4317 
 4318 // Integer Immediate: 32-bit
 4319 operand immI() %{
 4320   match(ConI);
 4321   op_cost(40);
 4322   format %{ %}
 4323   interface(CONST_INTER);
 4324 %}
 4325 
 4326 operand immI8() %{
 4327   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
 4328   op_cost(0);
 4329   match(ConI);
 4330   format %{ %}
 4331   interface(CONST_INTER);
 4332 %}
 4333 
 4334 // Integer Immediate: 16-bit
 4335 operand immI16() %{
 4336   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4337   op_cost(0);
 4338   match(ConI);
 4339   format %{ %}
 4340   interface(CONST_INTER);
 4341 %}
 4342 
 4343 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4344 operand immIhi16() %{
 4345   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4346   match(ConI);
 4347   op_cost(0);
 4348   format %{ %}
 4349   interface(CONST_INTER);
 4350 %}
 4351 
 4352 operand immInegpow2() %{
<a name="1" id="anc1"></a><span class="line-modified"> 4353   predicate(is_power_of_2_long((jlong) (julong) (juint) (-(n-&gt;get_int()))));</span>
 4354   match(ConI);
 4355   op_cost(0);
 4356   format %{ %}
 4357   interface(CONST_INTER);
 4358 %}
 4359 
 4360 operand immIpow2minus1() %{
<a name="2" id="anc2"></a><span class="line-modified"> 4361   predicate(is_power_of_2_long((((jlong) (n-&gt;get_int()))+1)));</span>
 4362   match(ConI);
 4363   op_cost(0);
 4364   format %{ %}
 4365   interface(CONST_INTER);
 4366 %}
 4367 
 4368 operand immIpowerOf2() %{
<a name="3" id="anc3"></a><span class="line-modified"> 4369   predicate(is_power_of_2_long((((jlong) (julong) (juint) (n-&gt;get_int())))));</span>
 4370   match(ConI);
 4371   op_cost(0);
 4372   format %{ %}
 4373   interface(CONST_INTER);
 4374 %}
 4375 
 4376 // Unsigned Integer Immediate: the values 0-31
 4377 operand uimmI5() %{
 4378   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4379   match(ConI);
 4380   op_cost(0);
 4381   format %{ %}
 4382   interface(CONST_INTER);
 4383 %}
 4384 
 4385 // Unsigned Integer Immediate: 6-bit
 4386 operand uimmI6() %{
 4387   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4388   match(ConI);
 4389   op_cost(0);
 4390   format %{ %}
 4391   interface(CONST_INTER);
 4392 %}
 4393 
 4394 // Unsigned Integer Immediate:  6-bit int, greater than 32
 4395 operand uimmI6_ge32() %{
 4396   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
 4397   match(ConI);
 4398   op_cost(0);
 4399   format %{ %}
 4400   interface(CONST_INTER);
 4401 %}
 4402 
 4403 // Unsigned Integer Immediate: 15-bit
 4404 operand uimmI15() %{
 4405   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
 4406   match(ConI);
 4407   op_cost(0);
 4408   format %{ %}
 4409   interface(CONST_INTER);
 4410 %}
 4411 
 4412 // Unsigned Integer Immediate: 16-bit
 4413 operand uimmI16() %{
 4414   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
 4415   match(ConI);
 4416   op_cost(0);
 4417   format %{ %}
 4418   interface(CONST_INTER);
 4419 %}
 4420 
 4421 // constant &#39;int 0&#39;.
 4422 operand immI_0() %{
 4423   predicate(n-&gt;get_int() == 0);
 4424   match(ConI);
 4425   op_cost(0);
 4426   format %{ %}
 4427   interface(CONST_INTER);
 4428 %}
 4429 
 4430 // constant &#39;int 1&#39;.
 4431 operand immI_1() %{
 4432   predicate(n-&gt;get_int() == 1);
 4433   match(ConI);
 4434   op_cost(0);
 4435   format %{ %}
 4436   interface(CONST_INTER);
 4437 %}
 4438 
 4439 // constant &#39;int -1&#39;.
 4440 operand immI_minus1() %{
 4441   predicate(n-&gt;get_int() == -1);
 4442   match(ConI);
 4443   op_cost(0);
 4444   format %{ %}
 4445   interface(CONST_INTER);
 4446 %}
 4447 
 4448 // int value 16.
 4449 operand immI_16() %{
 4450   predicate(n-&gt;get_int() == 16);
 4451   match(ConI);
 4452   op_cost(0);
 4453   format %{ %}
 4454   interface(CONST_INTER);
 4455 %}
 4456 
 4457 // int value 24.
 4458 operand immI_24() %{
 4459   predicate(n-&gt;get_int() == 24);
 4460   match(ConI);
 4461   op_cost(0);
 4462   format %{ %}
 4463   interface(CONST_INTER);
 4464 %}
 4465 
 4466 // Compressed oops constants
 4467 // Pointer Immediate
 4468 operand immN() %{
 4469   match(ConN);
 4470 
 4471   op_cost(10);
 4472   format %{ %}
 4473   interface(CONST_INTER);
 4474 %}
 4475 
 4476 // NULL Pointer Immediate
 4477 operand immN_0() %{
 4478   predicate(n-&gt;get_narrowcon() == 0);
 4479   match(ConN);
 4480 
 4481   op_cost(0);
 4482   format %{ %}
 4483   interface(CONST_INTER);
 4484 %}
 4485 
 4486 // Compressed klass constants
 4487 operand immNKlass() %{
 4488   match(ConNKlass);
 4489 
 4490   op_cost(0);
 4491   format %{ %}
 4492   interface(CONST_INTER);
 4493 %}
 4494 
 4495 // This operand can be used to avoid matching of an instruct
 4496 // with chain rule.
 4497 operand immNKlass_NM() %{
 4498   match(ConNKlass);
 4499   predicate(false);
 4500   op_cost(0);
 4501   format %{ %}
 4502   interface(CONST_INTER);
 4503 %}
 4504 
 4505 // Pointer Immediate: 64-bit
 4506 operand immP() %{
 4507   match(ConP);
 4508   op_cost(0);
 4509   format %{ %}
 4510   interface(CONST_INTER);
 4511 %}
 4512 
 4513 // Operand to avoid match of loadConP.
 4514 // This operand can be used to avoid matching of an instruct
 4515 // with chain rule.
 4516 operand immP_NM() %{
 4517   match(ConP);
 4518   predicate(false);
 4519   op_cost(0);
 4520   format %{ %}
 4521   interface(CONST_INTER);
 4522 %}
 4523 
 4524 // costant &#39;pointer 0&#39;.
 4525 operand immP_0() %{
 4526   predicate(n-&gt;get_ptr() == 0);
 4527   match(ConP);
 4528   op_cost(0);
 4529   format %{ %}
 4530   interface(CONST_INTER);
 4531 %}
 4532 
 4533 // pointer 0x0 or 0x1
 4534 operand immP_0or1() %{
 4535   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
 4536   match(ConP);
 4537   op_cost(0);
 4538   format %{ %}
 4539   interface(CONST_INTER);
 4540 %}
 4541 
 4542 operand immL() %{
 4543   match(ConL);
 4544   op_cost(40);
 4545   format %{ %}
 4546   interface(CONST_INTER);
 4547 %}
 4548 
 4549 operand immLmax30() %{
 4550   predicate((n-&gt;get_long() &lt;= 30));
 4551   match(ConL);
 4552   op_cost(0);
 4553   format %{ %}
 4554   interface(CONST_INTER);
 4555 %}
 4556 
 4557 // Long Immediate: 16-bit
 4558 operand immL16() %{
 4559   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
 4560   match(ConL);
 4561   op_cost(0);
 4562   format %{ %}
 4563   interface(CONST_INTER);
 4564 %}
 4565 
 4566 // Long Immediate: 16-bit, 4-aligned
 4567 operand immL16Alg4() %{
 4568   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
 4569   match(ConL);
 4570   op_cost(0);
 4571   format %{ %}
 4572   interface(CONST_INTER);
 4573 %}
 4574 
 4575 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4576 operand immL32hi16() %{
 4577   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
 4578   match(ConL);
 4579   op_cost(0);
 4580   format %{ %}
 4581   interface(CONST_INTER);
 4582 %}
 4583 
 4584 // Long Immediate: 32-bit
 4585 operand immL32() %{
 4586   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4587   match(ConL);
 4588   op_cost(0);
 4589   format %{ %}
 4590   interface(CONST_INTER);
 4591 %}
 4592 
 4593 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4594 operand immLhighest16() %{
 4595   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4596   match(ConL);
 4597   op_cost(0);
 4598   format %{ %}
 4599   interface(CONST_INTER);
 4600 %}
 4601 
 4602 operand immLnegpow2() %{
<a name="4" id="anc4"></a><span class="line-modified"> 4603   predicate(is_power_of_2_long((jlong)-(n-&gt;get_long())));</span>
 4604   match(ConL);
 4605   op_cost(0);
 4606   format %{ %}
 4607   interface(CONST_INTER);
 4608 %}
 4609 
 4610 operand immLpow2minus1() %{
<a name="5" id="anc5"></a><span class="line-modified"> 4611   predicate(is_power_of_2_long((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;</span>
 4612             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4613   match(ConL);
 4614   op_cost(0);
 4615   format %{ %}
 4616   interface(CONST_INTER);
 4617 %}
 4618 
 4619 // constant &#39;long 0&#39;.
 4620 operand immL_0() %{
 4621   predicate(n-&gt;get_long() == 0L);
 4622   match(ConL);
 4623   op_cost(0);
 4624   format %{ %}
 4625   interface(CONST_INTER);
 4626 %}
 4627 
 4628 // constat &#39; long -1&#39;.
 4629 operand immL_minus1() %{
 4630   predicate(n-&gt;get_long() == -1L);
 4631   match(ConL);
 4632   op_cost(0);
 4633   format %{ %}
 4634   interface(CONST_INTER);
 4635 %}
 4636 
 4637 // Long Immediate: low 32-bit mask
 4638 operand immL_32bits() %{
 4639   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 4640   match(ConL);
 4641   op_cost(0);
 4642   format %{ %}
 4643   interface(CONST_INTER);
 4644 %}
 4645 
 4646 // Unsigned Long Immediate: 16-bit
 4647 operand uimmL16() %{
 4648   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
 4649   match(ConL);
 4650   op_cost(0);
 4651   format %{ %}
 4652   interface(CONST_INTER);
 4653 %}
 4654 
 4655 // Float Immediate
 4656 operand immF() %{
 4657   match(ConF);
 4658   op_cost(40);
 4659   format %{ %}
 4660   interface(CONST_INTER);
 4661 %}
 4662 
 4663 // Float Immediate: +0.0f.
 4664 operand immF_0() %{
 4665   predicate(jint_cast(n-&gt;getf()) == 0);
 4666   match(ConF);
 4667 
 4668   op_cost(0);
 4669   format %{ %}
 4670   interface(CONST_INTER);
 4671 %}
 4672 
 4673 // Double Immediate
 4674 operand immD() %{
 4675   match(ConD);
 4676   op_cost(40);
 4677   format %{ %}
 4678   interface(CONST_INTER);
 4679 %}
 4680 
 4681 // Double Immediate: +0.0d.
 4682 operand immD_0() %{
 4683   predicate(jlong_cast(n-&gt;getd()) == 0);
 4684   match(ConD);
 4685 
 4686   op_cost(0);
 4687   format %{ %}
 4688   interface(CONST_INTER);
 4689 %}
 4690 
 4691 // Integer Register Operands
 4692 // Integer Destination Register
 4693 // See definition of reg_class bits32_reg_rw.
 4694 operand iRegIdst() %{
 4695   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4696   match(RegI);
 4697   match(rscratch1RegI);
 4698   match(rscratch2RegI);
 4699   match(rarg1RegI);
 4700   match(rarg2RegI);
 4701   match(rarg3RegI);
 4702   match(rarg4RegI);
 4703   format %{ %}
 4704   interface(REG_INTER);
 4705 %}
 4706 
 4707 // Integer Source Register
 4708 // See definition of reg_class bits32_reg_ro.
 4709 operand iRegIsrc() %{
 4710   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4711   match(RegI);
 4712   match(rscratch1RegI);
 4713   match(rscratch2RegI);
 4714   match(rarg1RegI);
 4715   match(rarg2RegI);
 4716   match(rarg3RegI);
 4717   match(rarg4RegI);
 4718   format %{ %}
 4719   interface(REG_INTER);
 4720 %}
 4721 
 4722 operand rscratch1RegI() %{
 4723   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
 4724   match(iRegIdst);
 4725   format %{ %}
 4726   interface(REG_INTER);
 4727 %}
 4728 
 4729 operand rscratch2RegI() %{
 4730   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
 4731   match(iRegIdst);
 4732   format %{ %}
 4733   interface(REG_INTER);
 4734 %}
 4735 
 4736 operand rarg1RegI() %{
 4737   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
 4738   match(iRegIdst);
 4739   format %{ %}
 4740   interface(REG_INTER);
 4741 %}
 4742 
 4743 operand rarg2RegI() %{
 4744   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
 4745   match(iRegIdst);
 4746   format %{ %}
 4747   interface(REG_INTER);
 4748 %}
 4749 
 4750 operand rarg3RegI() %{
 4751   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
 4752   match(iRegIdst);
 4753   format %{ %}
 4754   interface(REG_INTER);
 4755 %}
 4756 
 4757 operand rarg4RegI() %{
 4758   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
 4759   match(iRegIdst);
 4760   format %{ %}
 4761   interface(REG_INTER);
 4762 %}
 4763 
 4764 operand rarg1RegL() %{
 4765   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4766   match(iRegLdst);
 4767   format %{ %}
 4768   interface(REG_INTER);
 4769 %}
 4770 
 4771 operand rarg2RegL() %{
 4772   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4773   match(iRegLdst);
 4774   format %{ %}
 4775   interface(REG_INTER);
 4776 %}
 4777 
 4778 operand rarg3RegL() %{
 4779   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4780   match(iRegLdst);
 4781   format %{ %}
 4782   interface(REG_INTER);
 4783 %}
 4784 
 4785 operand rarg4RegL() %{
 4786   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4787   match(iRegLdst);
 4788   format %{ %}
 4789   interface(REG_INTER);
 4790 %}
 4791 
 4792 // Pointer Destination Register
 4793 // See definition of reg_class bits64_reg_rw.
 4794 operand iRegPdst() %{
 4795   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4796   match(RegP);
 4797   match(rscratch1RegP);
 4798   match(rscratch2RegP);
 4799   match(rarg1RegP);
 4800   match(rarg2RegP);
 4801   match(rarg3RegP);
 4802   match(rarg4RegP);
 4803   format %{ %}
 4804   interface(REG_INTER);
 4805 %}
 4806 
 4807 // Pointer Destination Register
 4808 // Operand not using r11 and r12 (killed in epilog).
 4809 operand iRegPdstNoScratch() %{
 4810   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
 4811   match(RegP);
 4812   match(rarg1RegP);
 4813   match(rarg2RegP);
 4814   match(rarg3RegP);
 4815   match(rarg4RegP);
 4816   format %{ %}
 4817   interface(REG_INTER);
 4818 %}
 4819 
 4820 // Pointer Source Register
 4821 // See definition of reg_class bits64_reg_ro.
 4822 operand iRegPsrc() %{
 4823   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4824   match(RegP);
 4825   match(iRegPdst);
 4826   match(rscratch1RegP);
 4827   match(rscratch2RegP);
 4828   match(rarg1RegP);
 4829   match(rarg2RegP);
 4830   match(rarg3RegP);
 4831   match(rarg4RegP);
 4832   match(threadRegP);
 4833   format %{ %}
 4834   interface(REG_INTER);
 4835 %}
 4836 
 4837 // Thread operand.
 4838 operand threadRegP() %{
 4839   constraint(ALLOC_IN_RC(thread_bits64_reg));
 4840   match(iRegPdst);
 4841   format %{ &quot;R16&quot; %}
 4842   interface(REG_INTER);
 4843 %}
 4844 
 4845 operand rscratch1RegP() %{
 4846   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4847   match(iRegPdst);
 4848   format %{ &quot;R11&quot; %}
 4849   interface(REG_INTER);
 4850 %}
 4851 
 4852 operand rscratch2RegP() %{
 4853   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4854   match(iRegPdst);
 4855   format %{ %}
 4856   interface(REG_INTER);
 4857 %}
 4858 
 4859 operand rarg1RegP() %{
 4860   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4861   match(iRegPdst);
 4862   format %{ %}
 4863   interface(REG_INTER);
 4864 %}
 4865 
 4866 operand rarg2RegP() %{
 4867   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4868   match(iRegPdst);
 4869   format %{ %}
 4870   interface(REG_INTER);
 4871 %}
 4872 
 4873 operand rarg3RegP() %{
 4874   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4875   match(iRegPdst);
 4876   format %{ %}
 4877   interface(REG_INTER);
 4878 %}
 4879 
 4880 operand rarg4RegP() %{
 4881   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4882   match(iRegPdst);
 4883   format %{ %}
 4884   interface(REG_INTER);
 4885 %}
 4886 
 4887 operand iRegNsrc() %{
 4888   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4889   match(RegN);
 4890   match(iRegNdst);
 4891 
 4892   format %{ %}
 4893   interface(REG_INTER);
 4894 %}
 4895 
 4896 operand iRegNdst() %{
 4897   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4898   match(RegN);
 4899 
 4900   format %{ %}
 4901   interface(REG_INTER);
 4902 %}
 4903 
 4904 // Long Destination Register
 4905 // See definition of reg_class bits64_reg_rw.
 4906 operand iRegLdst() %{
 4907   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4908   match(RegL);
 4909   match(rscratch1RegL);
 4910   match(rscratch2RegL);
 4911   format %{ %}
 4912   interface(REG_INTER);
 4913 %}
 4914 
 4915 // Long Source Register
 4916 // See definition of reg_class bits64_reg_ro.
 4917 operand iRegLsrc() %{
 4918   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4919   match(RegL);
 4920   match(iRegLdst);
 4921   match(rscratch1RegL);
 4922   match(rscratch2RegL);
 4923   format %{ %}
 4924   interface(REG_INTER);
 4925 %}
 4926 
 4927 // Special operand for ConvL2I.
 4928 operand iRegL2Isrc(iRegLsrc reg) %{
 4929   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4930   match(ConvL2I reg);
 4931   format %{ &quot;ConvL2I($reg)&quot; %}
 4932   interface(REG_INTER)
 4933 %}
 4934 
 4935 operand rscratch1RegL() %{
 4936   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4937   match(RegL);
 4938   format %{ %}
 4939   interface(REG_INTER);
 4940 %}
 4941 
 4942 operand rscratch2RegL() %{
 4943   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4944   match(RegL);
 4945   format %{ %}
 4946   interface(REG_INTER);
 4947 %}
 4948 
 4949 // Condition Code Flag Registers
 4950 operand flagsReg() %{
 4951   constraint(ALLOC_IN_RC(int_flags));
 4952   match(RegFlags);
 4953   format %{ %}
 4954   interface(REG_INTER);
 4955 %}
 4956 
 4957 operand flagsRegSrc() %{
 4958   constraint(ALLOC_IN_RC(int_flags_ro));
 4959   match(RegFlags);
 4960   match(flagsReg);
 4961   match(flagsRegCR0);
 4962   format %{ %}
 4963   interface(REG_INTER);
 4964 %}
 4965 
 4966 // Condition Code Flag Register CR0
 4967 operand flagsRegCR0() %{
 4968   constraint(ALLOC_IN_RC(int_flags_CR0));
 4969   match(RegFlags);
 4970   format %{ &quot;CR0&quot; %}
 4971   interface(REG_INTER);
 4972 %}
 4973 
 4974 operand flagsRegCR1() %{
 4975   constraint(ALLOC_IN_RC(int_flags_CR1));
 4976   match(RegFlags);
 4977   format %{ &quot;CR1&quot; %}
 4978   interface(REG_INTER);
 4979 %}
 4980 
 4981 operand flagsRegCR6() %{
 4982   constraint(ALLOC_IN_RC(int_flags_CR6));
 4983   match(RegFlags);
 4984   format %{ &quot;CR6&quot; %}
 4985   interface(REG_INTER);
 4986 %}
 4987 
 4988 operand regCTR() %{
 4989   constraint(ALLOC_IN_RC(ctr_reg));
 4990   // RegFlags should work. Introducing a RegSpecial type would cause a
 4991   // lot of changes.
 4992   match(RegFlags);
 4993   format %{&quot;SR_CTR&quot; %}
 4994   interface(REG_INTER);
 4995 %}
 4996 
 4997 operand regD() %{
 4998   constraint(ALLOC_IN_RC(dbl_reg));
 4999   match(RegD);
 5000   format %{ %}
 5001   interface(REG_INTER);
 5002 %}
 5003 
 5004 operand regF() %{
 5005   constraint(ALLOC_IN_RC(flt_reg));
 5006   match(RegF);
 5007   format %{ %}
 5008   interface(REG_INTER);
 5009 %}
 5010 
 5011 // Special Registers
 5012 
 5013 // Method Register
 5014 operand inline_cache_regP(iRegPdst reg) %{
 5015   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
 5016   match(reg);
 5017   format %{ %}
 5018   interface(REG_INTER);
 5019 %}
 5020 
 5021 operand compiler_method_oop_regP(iRegPdst reg) %{
 5022   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5023   match(reg);
 5024   format %{ %}
 5025   interface(REG_INTER);
 5026 %}
 5027 
 5028 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5029   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5030   match(reg);
 5031   format %{ %}
 5032   interface(REG_INTER);
 5033 %}
 5034 
 5035 // Operands to remove register moves in unscaled mode.
 5036 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5037 operand iRegP2N(iRegPsrc reg) %{
 5038   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);
 5039   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5040   match(EncodeP reg);
 5041   format %{ &quot;$reg&quot; %}
 5042   interface(REG_INTER)
 5043 %}
 5044 
 5045 operand iRegN2P(iRegNsrc reg) %{
 5046   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5047   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5048   match(DecodeN reg);
 5049   format %{ &quot;$reg&quot; %}
 5050   interface(REG_INTER)
 5051 %}
 5052 
 5053 operand iRegN2P_klass(iRegNsrc reg) %{
 5054   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5055   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5056   match(DecodeNKlass reg);
 5057   format %{ &quot;$reg&quot; %}
 5058   interface(REG_INTER)
 5059 %}
 5060 
 5061 //----------Complex Operands---------------------------------------------------
 5062 // Indirect Memory Reference
 5063 operand indirect(iRegPsrc reg) %{
 5064   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5065   match(reg);
 5066   op_cost(100);
 5067   format %{ &quot;[$reg]&quot; %}
 5068   interface(MEMORY_INTER) %{
 5069     base($reg);
 5070     index(0x0);
 5071     scale(0x0);
 5072     disp(0x0);
 5073   %}
 5074 %}
 5075 
 5076 // Indirect with Offset
 5077 operand indOffset16(iRegPsrc reg, immL16 offset) %{
 5078   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5079   match(AddP reg offset);
 5080   op_cost(100);
 5081   format %{ &quot;[$reg + $offset]&quot; %}
 5082   interface(MEMORY_INTER) %{
 5083     base($reg);
 5084     index(0x0);
 5085     scale(0x0);
 5086     disp($offset);
 5087   %}
 5088 %}
 5089 
 5090 // Indirect with 4-aligned Offset
 5091 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
 5092   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5093   match(AddP reg offset);
 5094   op_cost(100);
 5095   format %{ &quot;[$reg + $offset]&quot; %}
 5096   interface(MEMORY_INTER) %{
 5097     base($reg);
 5098     index(0x0);
 5099     scale(0x0);
 5100     disp($offset);
 5101   %}
 5102 %}
 5103 
 5104 //----------Complex Operands for Compressed OOPs-------------------------------
 5105 // Compressed OOPs with narrow_oop_shift == 0.
 5106 
 5107 // Indirect Memory Reference, compressed OOP
 5108 operand indirectNarrow(iRegNsrc reg) %{
 5109   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5110   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5111   match(DecodeN reg);
 5112   op_cost(100);
 5113   format %{ &quot;[$reg]&quot; %}
 5114   interface(MEMORY_INTER) %{
 5115     base($reg);
 5116     index(0x0);
 5117     scale(0x0);
 5118     disp(0x0);
 5119   %}
 5120 %}
 5121 
 5122 operand indirectNarrow_klass(iRegNsrc reg) %{
 5123   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5124   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5125   match(DecodeNKlass reg);
 5126   op_cost(100);
 5127   format %{ &quot;[$reg]&quot; %}
 5128   interface(MEMORY_INTER) %{
 5129     base($reg);
 5130     index(0x0);
 5131     scale(0x0);
 5132     disp(0x0);
 5133   %}
 5134 %}
 5135 
 5136 // Indirect with Offset, compressed OOP
 5137 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5138   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5139   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5140   match(AddP (DecodeN reg) offset);
 5141   op_cost(100);
 5142   format %{ &quot;[$reg + $offset]&quot; %}
 5143   interface(MEMORY_INTER) %{
 5144     base($reg);
 5145     index(0x0);
 5146     scale(0x0);
 5147     disp($offset);
 5148   %}
 5149 %}
 5150 
 5151 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
 5152   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5153   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5154   match(AddP (DecodeNKlass reg) offset);
 5155   op_cost(100);
 5156   format %{ &quot;[$reg + $offset]&quot; %}
 5157   interface(MEMORY_INTER) %{
 5158     base($reg);
 5159     index(0x0);
 5160     scale(0x0);
 5161     disp($offset);
 5162   %}
 5163 %}
 5164 
 5165 // Indirect with 4-aligned Offset, compressed OOP
 5166 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5167   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5168   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5169   match(AddP (DecodeN reg) offset);
 5170   op_cost(100);
 5171   format %{ &quot;[$reg + $offset]&quot; %}
 5172   interface(MEMORY_INTER) %{
 5173     base($reg);
 5174     index(0x0);
 5175     scale(0x0);
 5176     disp($offset);
 5177   %}
 5178 %}
 5179 
 5180 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
 5181   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5182   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5183   match(AddP (DecodeNKlass reg) offset);
 5184   op_cost(100);
 5185   format %{ &quot;[$reg + $offset]&quot; %}
 5186   interface(MEMORY_INTER) %{
 5187     base($reg);
 5188     index(0x0);
 5189     scale(0x0);
 5190     disp($offset);
 5191   %}
 5192 %}
 5193 
 5194 //----------Special Memory Operands--------------------------------------------
 5195 // Stack Slot Operand
 5196 //
 5197 // This operand is used for loading and storing temporary values on
 5198 // the stack where a match requires a value to flow through memory.
 5199 operand stackSlotI(sRegI reg) %{
 5200   constraint(ALLOC_IN_RC(stack_slots));
 5201   op_cost(100);
 5202   //match(RegI);
 5203   format %{ &quot;[sp+$reg]&quot; %}
 5204   interface(MEMORY_INTER) %{
 5205     base(0x1);   // R1_SP
 5206     index(0x0);
 5207     scale(0x0);
 5208     disp($reg);  // Stack Offset
 5209   %}
 5210 %}
 5211 
 5212 operand stackSlotL(sRegL reg) %{
 5213   constraint(ALLOC_IN_RC(stack_slots));
 5214   op_cost(100);
 5215   //match(RegL);
 5216   format %{ &quot;[sp+$reg]&quot; %}
 5217   interface(MEMORY_INTER) %{
 5218     base(0x1);   // R1_SP
 5219     index(0x0);
 5220     scale(0x0);
 5221     disp($reg);  // Stack Offset
 5222   %}
 5223 %}
 5224 
 5225 operand stackSlotP(sRegP reg) %{
 5226   constraint(ALLOC_IN_RC(stack_slots));
 5227   op_cost(100);
 5228   //match(RegP);
 5229   format %{ &quot;[sp+$reg]&quot; %}
 5230   interface(MEMORY_INTER) %{
 5231     base(0x1);   // R1_SP
 5232     index(0x0);
 5233     scale(0x0);
 5234     disp($reg);  // Stack Offset
 5235   %}
 5236 %}
 5237 
 5238 operand stackSlotF(sRegF reg) %{
 5239   constraint(ALLOC_IN_RC(stack_slots));
 5240   op_cost(100);
 5241   //match(RegF);
 5242   format %{ &quot;[sp+$reg]&quot; %}
 5243   interface(MEMORY_INTER) %{
 5244     base(0x1);   // R1_SP
 5245     index(0x0);
 5246     scale(0x0);
 5247     disp($reg);  // Stack Offset
 5248   %}
 5249 %}
 5250 
 5251 operand stackSlotD(sRegD reg) %{
 5252   constraint(ALLOC_IN_RC(stack_slots));
 5253   op_cost(100);
 5254   //match(RegD);
 5255   format %{ &quot;[sp+$reg]&quot; %}
 5256   interface(MEMORY_INTER) %{
 5257     base(0x1);   // R1_SP
 5258     index(0x0);
 5259     scale(0x0);
 5260     disp($reg);  // Stack Offset
 5261   %}
 5262 %}
 5263 
 5264 // Operands for expressing Control Flow
 5265 // NOTE: Label is a predefined operand which should not be redefined in
 5266 //       the AD file. It is generically handled within the ADLC.
 5267 
 5268 //----------Conditional Branch Operands----------------------------------------
 5269 // Comparison Op
 5270 //
 5271 // This is the operation of the comparison, and is limited to the
 5272 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
 5273 // (!=).
 5274 //
 5275 // Other attributes of the comparison, such as unsignedness, are specified
 5276 // by the comparison instruction that sets a condition code flags register.
 5277 // That result is represented by a flags operand whose subtype is appropriate
 5278 // to the unsignedness (etc.) of the comparison.
 5279 //
 5280 // Later, the instruction which matches both the Comparison Op (a Bool) and
 5281 // the flags (produced by the Cmp) specifies the coding of the comparison op
 5282 // by matching a specific subtype of Bool operand below.
 5283 
 5284 // When used for floating point comparisons: unordered same as less.
 5285 operand cmpOp() %{
 5286   match(Bool);
 5287   format %{ &quot;&quot; %}
 5288   interface(COND_INTER) %{
 5289                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always &#39;100&#39;.
 5290                            //           BO          &amp;  BI
 5291     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
 5292     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
 5293     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
 5294     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
 5295     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
 5296     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
 5297     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
 5298     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
 5299   %}
 5300 %}
 5301 
 5302 //----------OPERAND CLASSES----------------------------------------------------
 5303 // Operand Classes are groups of operands that are used to simplify
 5304 // instruction definitions by not requiring the AD writer to specify
 5305 // seperate instructions for every form of operand when the
 5306 // instruction accepts multiple operand types with the same basic
 5307 // encoding and format. The classic case of this is memory operands.
 5308 // Indirect is not included since its use is limited to Compare &amp; Swap.
 5309 
 5310 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
 5311 // Memory operand where offsets are 4-aligned. Required for ld, std.
 5312 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
 5313 opclass indirectMemory(indirect, indirectNarrow);
 5314 
 5315 // Special opclass for I and ConvL2I.
 5316 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
 5317 
 5318 // Operand classes to match encode and decode. iRegN_P2N is only used
 5319 // for storeN. I have never seen an encode node elsewhere.
 5320 opclass iRegN_P2N(iRegNsrc, iRegP2N);
 5321 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
 5322 
 5323 //----------PIPELINE-----------------------------------------------------------
 5324 
 5325 pipeline %{
 5326 
 5327 // See J.M.Tendler et al. &quot;Power4 system microarchitecture&quot;, IBM
 5328 // J. Res. &amp; Dev., No. 1, Jan. 2002.
 5329 
 5330 //----------ATTRIBUTES---------------------------------------------------------
 5331 attributes %{
 5332 
 5333   // Power4 instructions are of fixed length.
 5334   fixed_size_instructions;
 5335 
 5336   // TODO: if `bundle&#39; means number of instructions fetched
 5337   // per cycle, this is 8. If `bundle&#39; means Power4 `group&#39;, that is
 5338   // max instructions issued per cycle, this is 5.
 5339   max_instructions_per_bundle = 8;
 5340 
 5341   // A Power4 instruction is 4 bytes long.
 5342   instruction_unit_size = 4;
 5343 
 5344   // The Power4 processor fetches 64 bytes...
 5345   instruction_fetch_unit_size = 64;
 5346 
 5347   // ...in one line
 5348   instruction_fetch_units = 1
 5349 
 5350   // Unused, list one so that array generated by adlc is not empty.
 5351   // Aix compiler chokes if _nop_count = 0.
 5352   nops(fxNop);
 5353 %}
 5354 
 5355 //----------RESOURCES----------------------------------------------------------
 5356 // Resources are the functional units available to the machine
 5357 resources(
 5358    PPC_BR,         // branch unit
 5359    PPC_CR,         // condition unit
 5360    PPC_FX1,        // integer arithmetic unit 1
 5361    PPC_FX2,        // integer arithmetic unit 2
 5362    PPC_LDST1,      // load/store unit 1
 5363    PPC_LDST2,      // load/store unit 2
 5364    PPC_FP1,        // float arithmetic unit 1
 5365    PPC_FP2,        // float arithmetic unit 2
 5366    PPC_LDST = PPC_LDST1 | PPC_LDST2,
 5367    PPC_FX = PPC_FX1 | PPC_FX2,
 5368    PPC_FP = PPC_FP1 | PPC_FP2
 5369  );
 5370 
 5371 //----------PIPELINE DESCRIPTION-----------------------------------------------
 5372 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 5373 pipe_desc(
 5374    // Power4 longest pipeline path
 5375    PPC_IF,   // instruction fetch
 5376    PPC_IC,
 5377    //PPC_BP, // branch prediction
 5378    PPC_D0,   // decode
 5379    PPC_D1,   // decode
 5380    PPC_D2,   // decode
 5381    PPC_D3,   // decode
 5382    PPC_Xfer1,
 5383    PPC_GD,   // group definition
 5384    PPC_MP,   // map
 5385    PPC_ISS,  // issue
 5386    PPC_RF,   // resource fetch
 5387    PPC_EX1,  // execute (all units)
 5388    PPC_EX2,  // execute (FP, LDST)
 5389    PPC_EX3,  // execute (FP, LDST)
 5390    PPC_EX4,  // execute (FP)
 5391    PPC_EX5,  // execute (FP)
 5392    PPC_EX6,  // execute (FP)
 5393    PPC_WB,   // write back
 5394    PPC_Xfer2,
 5395    PPC_CP
 5396  );
 5397 
 5398 //----------PIPELINE CLASSES---------------------------------------------------
 5399 // Pipeline Classes describe the stages in which input and output are
 5400 // referenced by the hardware pipeline.
 5401 
 5402 // Simple pipeline classes.
 5403 
 5404 // Default pipeline class.
 5405 pipe_class pipe_class_default() %{
 5406   single_instruction;
 5407   fixed_latency(2);
 5408 %}
 5409 
 5410 // Pipeline class for empty instructions.
 5411 pipe_class pipe_class_empty() %{
 5412   single_instruction;
 5413   fixed_latency(0);
 5414 %}
 5415 
 5416 // Pipeline class for compares.
 5417 pipe_class pipe_class_compare() %{
 5418   single_instruction;
 5419   fixed_latency(16);
 5420 %}
 5421 
 5422 // Pipeline class for traps.
 5423 pipe_class pipe_class_trap() %{
 5424   single_instruction;
 5425   fixed_latency(100);
 5426 %}
 5427 
 5428 // Pipeline class for memory operations.
 5429 pipe_class pipe_class_memory() %{
 5430   single_instruction;
 5431   fixed_latency(16);
 5432 %}
 5433 
 5434 // Pipeline class for call.
 5435 pipe_class pipe_class_call() %{
 5436   single_instruction;
 5437   fixed_latency(100);
 5438 %}
 5439 
 5440 // Define the class for the Nop node.
 5441 define %{
 5442    MachNop = pipe_class_default;
 5443 %}
 5444 
 5445 %}
 5446 
 5447 //----------INSTRUCTIONS-------------------------------------------------------
 5448 
 5449 // Naming of instructions:
 5450 //   opA_operB / opA_operB_operC:
 5451 //     Operation &#39;op&#39; with one or two source operands &#39;oper&#39;. Result
 5452 //     type is A, source operand types are B and C.
 5453 //     Iff A == B == C, B and C are left out.
 5454 //
 5455 // The instructions are ordered according to the following scheme:
 5456 //  - loads
 5457 //  - load constants
 5458 //  - prefetch
 5459 //  - store
 5460 //  - encode/decode
 5461 //  - membar
 5462 //  - conditional moves
 5463 //  - compare &amp; swap
 5464 //  - arithmetic and logic operations
 5465 //    * int: Add, Sub, Mul, Div, Mod
 5466 //    * int: lShift, arShift, urShift, rot
 5467 //    * float: Add, Sub, Mul, Div
 5468 //    * and, or, xor ...
 5469 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
 5470 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
 5471 //  - conv (low level type cast requiring bit changes (sign extend etc)
 5472 //  - compares, range &amp; zero checks.
 5473 //  - branches
 5474 //  - complex operations, intrinsics, min, max, replicate
 5475 //  - lock
 5476 //  - Calls
 5477 //
 5478 // If there are similar instructions with different types they are sorted:
 5479 // int before float
 5480 // small before big
 5481 // signed before unsigned
 5482 // e.g., loadS before loadUS before loadI before loadF.
 5483 
 5484 
 5485 //----------Load/Store Instructions--------------------------------------------
 5486 
 5487 //----------Load Instructions--------------------------------------------------
 5488 
 5489 // Converts byte to int.
 5490 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
 5491 // reuses the &#39;amount&#39; operand, but adlc expects that operand specification
 5492 // and operands in match rule are equivalent.
 5493 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
 5494   effect(DEF dst, USE src);
 5495   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
 5496   size(4);
 5497   ins_encode %{
 5498     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
 5499     __ extsb($dst$$Register, $src$$Register);
 5500   %}
 5501   ins_pipe(pipe_class_default);
 5502 %}
 5503 
 5504 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
 5505   // match-rule, false predicate
 5506   match(Set dst (LoadB mem));
 5507   predicate(false);
 5508 
 5509   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5510   size(4);
 5511   ins_encode( enc_lbz(dst, mem) );
 5512   ins_pipe(pipe_class_memory);
 5513 %}
 5514 
 5515 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
 5516   // match-rule, false predicate
 5517   match(Set dst (LoadB mem));
 5518   predicate(false);
 5519 
 5520   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5521             &quot;TWI     $dst\n\t&quot;
 5522             &quot;ISYNC&quot; %}
 5523   size(12);
 5524   ins_encode( enc_lbz_ac(dst, mem) );
 5525   ins_pipe(pipe_class_memory);
 5526 %}
 5527 
 5528 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5529 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
 5530   match(Set dst (LoadB mem));
 5531   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5532   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5533   expand %{
 5534     iRegIdst tmp;
 5535     loadUB_indirect(tmp, mem);
 5536     convB2I_reg_2(dst, tmp);
 5537   %}
 5538 %}
 5539 
 5540 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
 5541   match(Set dst (LoadB mem));
 5542   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5543   expand %{
 5544     iRegIdst tmp;
 5545     loadUB_indirect_ac(tmp, mem);
 5546     convB2I_reg_2(dst, tmp);
 5547   %}
 5548 %}
 5549 
 5550 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
 5551   // match-rule, false predicate
 5552   match(Set dst (LoadB mem));
 5553   predicate(false);
 5554 
 5555   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5556   size(4);
 5557   ins_encode( enc_lbz(dst, mem) );
 5558   ins_pipe(pipe_class_memory);
 5559 %}
 5560 
 5561 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
 5562   // match-rule, false predicate
 5563   match(Set dst (LoadB mem));
 5564   predicate(false);
 5565 
 5566   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5567             &quot;TWI     $dst\n\t&quot;
 5568             &quot;ISYNC&quot; %}
 5569   size(12);
 5570   ins_encode( enc_lbz_ac(dst, mem) );
 5571   ins_pipe(pipe_class_memory);
 5572 %}
 5573 
 5574 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5575 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
 5576   match(Set dst (LoadB mem));
 5577   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5578   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5579 
 5580   expand %{
 5581     iRegIdst tmp;
 5582     loadUB_indOffset16(tmp, mem);
 5583     convB2I_reg_2(dst, tmp);
 5584   %}
 5585 %}
 5586 
 5587 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
 5588   match(Set dst (LoadB mem));
 5589   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5590 
 5591   expand %{
 5592     iRegIdst tmp;
 5593     loadUB_indOffset16_ac(tmp, mem);
 5594     convB2I_reg_2(dst, tmp);
 5595   %}
 5596 %}
 5597 
 5598 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 5599 instruct loadUB(iRegIdst dst, memory mem) %{
 5600   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5601   match(Set dst (LoadUB mem));
 5602   ins_cost(MEMORY_REF_COST);
 5603 
 5604   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int&quot; %}
 5605   size(4);
 5606   ins_encode( enc_lbz(dst, mem) );
 5607   ins_pipe(pipe_class_memory);
 5608 %}
 5609 
 5610 // Load  Unsigned Byte (8bit UNsigned) acquire.
 5611 instruct loadUB_ac(iRegIdst dst, memory mem) %{
 5612   match(Set dst (LoadUB mem));
 5613   ins_cost(3*MEMORY_REF_COST);
 5614 
 5615   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t&quot;
 5616             &quot;TWI     $dst\n\t&quot;
 5617             &quot;ISYNC&quot; %}
 5618   size(12);
 5619   ins_encode( enc_lbz_ac(dst, mem) );
 5620   ins_pipe(pipe_class_memory);
 5621 %}
 5622 
 5623 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 5624 instruct loadUB2L(iRegLdst dst, memory mem) %{
 5625   match(Set dst (ConvI2L (LoadUB mem)));
 5626   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5627   ins_cost(MEMORY_REF_COST);
 5628 
 5629   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long&quot; %}
 5630   size(4);
 5631   ins_encode( enc_lbz(dst, mem) );
 5632   ins_pipe(pipe_class_memory);
 5633 %}
 5634 
 5635 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
 5636   match(Set dst (ConvI2L (LoadUB mem)));
 5637   ins_cost(3*MEMORY_REF_COST);
 5638 
 5639   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t&quot;
 5640             &quot;TWI     $dst\n\t&quot;
 5641             &quot;ISYNC&quot; %}
 5642   size(12);
 5643   ins_encode( enc_lbz_ac(dst, mem) );
 5644   ins_pipe(pipe_class_memory);
 5645 %}
 5646 
 5647 // Load Short (16bit signed)
 5648 instruct loadS(iRegIdst dst, memory mem) %{
 5649   match(Set dst (LoadS mem));
 5650   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5651   ins_cost(MEMORY_REF_COST);
 5652 
 5653   format %{ &quot;LHA     $dst, $mem&quot; %}
 5654   size(4);
 5655   ins_encode %{
 5656     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
 5657     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5658     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5659   %}
 5660   ins_pipe(pipe_class_memory);
 5661 %}
 5662 
 5663 // Load Short (16bit signed) acquire.
 5664 instruct loadS_ac(iRegIdst dst, memory mem) %{
 5665   match(Set dst (LoadS mem));
 5666   ins_cost(3*MEMORY_REF_COST);
 5667 
 5668   format %{ &quot;LHA     $dst, $mem\t acquire\n\t&quot;
 5669             &quot;TWI     $dst\n\t&quot;
 5670             &quot;ISYNC&quot; %}
 5671   size(12);
 5672   ins_encode %{
 5673     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 5674     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5675     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5676     __ twi_0($dst$$Register);
 5677     __ isync();
 5678   %}
 5679   ins_pipe(pipe_class_memory);
 5680 %}
 5681 
 5682 // Load Char (16bit unsigned)
 5683 instruct loadUS(iRegIdst dst, memory mem) %{
 5684   match(Set dst (LoadUS mem));
 5685   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5686   ins_cost(MEMORY_REF_COST);
 5687 
 5688   format %{ &quot;LHZ     $dst, $mem&quot; %}
 5689   size(4);
 5690   ins_encode( enc_lhz(dst, mem) );
 5691   ins_pipe(pipe_class_memory);
 5692 %}
 5693 
 5694 // Load Char (16bit unsigned) acquire.
 5695 instruct loadUS_ac(iRegIdst dst, memory mem) %{
 5696   match(Set dst (LoadUS mem));
 5697   ins_cost(3*MEMORY_REF_COST);
 5698 
 5699   format %{ &quot;LHZ     $dst, $mem \t// acquire\n\t&quot;
 5700             &quot;TWI     $dst\n\t&quot;
 5701             &quot;ISYNC&quot; %}
 5702   size(12);
 5703   ins_encode( enc_lhz_ac(dst, mem) );
 5704   ins_pipe(pipe_class_memory);
 5705 %}
 5706 
 5707 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 5708 instruct loadUS2L(iRegLdst dst, memory mem) %{
 5709   match(Set dst (ConvI2L (LoadUS mem)));
 5710   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5711   ins_cost(MEMORY_REF_COST);
 5712 
 5713   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long&quot; %}
 5714   size(4);
 5715   ins_encode( enc_lhz(dst, mem) );
 5716   ins_pipe(pipe_class_memory);
 5717 %}
 5718 
 5719 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
 5720 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
 5721   match(Set dst (ConvI2L (LoadUS mem)));
 5722   ins_cost(3*MEMORY_REF_COST);
 5723 
 5724   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t&quot;
 5725             &quot;TWI     $dst\n\t&quot;
 5726             &quot;ISYNC&quot; %}
 5727   size(12);
 5728   ins_encode( enc_lhz_ac(dst, mem) );
 5729   ins_pipe(pipe_class_memory);
 5730 %}
 5731 
 5732 // Load Integer.
 5733 instruct loadI(iRegIdst dst, memory mem) %{
 5734   match(Set dst (LoadI mem));
 5735   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5736   ins_cost(MEMORY_REF_COST);
 5737 
 5738   format %{ &quot;LWZ     $dst, $mem&quot; %}
 5739   size(4);
 5740   ins_encode( enc_lwz(dst, mem) );
 5741   ins_pipe(pipe_class_memory);
 5742 %}
 5743 
 5744 // Load Integer acquire.
 5745 instruct loadI_ac(iRegIdst dst, memory mem) %{
 5746   match(Set dst (LoadI mem));
 5747   ins_cost(3*MEMORY_REF_COST);
 5748 
 5749   format %{ &quot;LWZ     $dst, $mem \t// load acquire\n\t&quot;
 5750             &quot;TWI     $dst\n\t&quot;
 5751             &quot;ISYNC&quot; %}
 5752   size(12);
 5753   ins_encode( enc_lwz_ac(dst, mem) );
 5754   ins_pipe(pipe_class_memory);
 5755 %}
 5756 
 5757 // Match loading integer and casting it to unsigned int in
 5758 // long register.
 5759 // LoadI + ConvI2L + AndL 0xffffffff.
 5760 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
 5761   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5762   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5763   ins_cost(MEMORY_REF_COST);
 5764 
 5765   format %{ &quot;LWZ     $dst, $mem \t// zero-extend to long&quot; %}
 5766   size(4);
 5767   ins_encode( enc_lwz(dst, mem) );
 5768   ins_pipe(pipe_class_memory);
 5769 %}
 5770 
 5771 // Match loading integer and casting it to long.
 5772 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
 5773   match(Set dst (ConvI2L (LoadI mem)));
 5774   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5775   ins_cost(MEMORY_REF_COST);
 5776 
 5777   format %{ &quot;LWA     $dst, $mem \t// loadI2L&quot; %}
 5778   size(4);
 5779   ins_encode %{
 5780     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5781     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5782     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5783   %}
 5784   ins_pipe(pipe_class_memory);
 5785 %}
 5786 
 5787 // Match loading integer and casting it to long - acquire.
 5788 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
 5789   match(Set dst (ConvI2L (LoadI mem)));
 5790   ins_cost(3*MEMORY_REF_COST);
 5791 
 5792   format %{ &quot;LWA     $dst, $mem \t// loadI2L acquire&quot;
 5793             &quot;TWI     $dst\n\t&quot;
 5794             &quot;ISYNC&quot; %}
 5795   size(12);
 5796   ins_encode %{
 5797     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5798     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5799     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5800     __ twi_0($dst$$Register);
 5801     __ isync();
 5802   %}
 5803   ins_pipe(pipe_class_memory);
 5804 %}
 5805 
 5806 // Load Long - aligned
 5807 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
 5808   match(Set dst (LoadL mem));
 5809   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5810   ins_cost(MEMORY_REF_COST);
 5811 
 5812   format %{ &quot;LD      $dst, $mem \t// long&quot; %}
 5813   size(4);
 5814   ins_encode( enc_ld(dst, mem) );
 5815   ins_pipe(pipe_class_memory);
 5816 %}
 5817 
 5818 // Load Long - aligned acquire.
 5819 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
 5820   match(Set dst (LoadL mem));
 5821   ins_cost(3*MEMORY_REF_COST);
 5822 
 5823   format %{ &quot;LD      $dst, $mem \t// long acquire\n\t&quot;
 5824             &quot;TWI     $dst\n\t&quot;
 5825             &quot;ISYNC&quot; %}
 5826   size(12);
 5827   ins_encode( enc_ld_ac(dst, mem) );
 5828   ins_pipe(pipe_class_memory);
 5829 %}
 5830 
 5831 // Load Long - UNaligned
 5832 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
 5833   match(Set dst (LoadL_unaligned mem));
 5834   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 5835   ins_cost(MEMORY_REF_COST);
 5836 
 5837   format %{ &quot;LD      $dst, $mem \t// unaligned long&quot; %}
 5838   size(4);
 5839   ins_encode( enc_ld(dst, mem) );
 5840   ins_pipe(pipe_class_memory);
 5841 %}
 5842 
 5843 // Load nodes for superwords
 5844 
 5845 // Load Aligned Packed Byte
 5846 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
 5847   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 5848   match(Set dst (LoadVector mem));
 5849   ins_cost(MEMORY_REF_COST);
 5850 
 5851   format %{ &quot;LD      $dst, $mem \t// load 8-byte Vector&quot; %}
 5852   size(4);
 5853   ins_encode( enc_ld(dst, mem) );
 5854   ins_pipe(pipe_class_memory);
 5855 %}
 5856 
 5857 // Load Aligned Packed Byte
 5858 instruct loadV16(vecX dst, indirect mem) %{
 5859   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 5860   match(Set dst (LoadVector mem));
 5861   ins_cost(MEMORY_REF_COST);
 5862 
 5863   format %{ &quot;LXVD2X      $dst, $mem \t// load 16-byte Vector&quot; %}
 5864   size(4);
 5865   ins_encode %{
 5866     __ lxvd2x($dst$$VectorSRegister, $mem$$Register);
 5867   %}
 5868   ins_pipe(pipe_class_default);
 5869 %}
 5870 
 5871 // Load Range, range = array length (=jint)
 5872 instruct loadRange(iRegIdst dst, memory mem) %{
 5873   match(Set dst (LoadRange mem));
 5874   ins_cost(MEMORY_REF_COST);
 5875 
 5876   format %{ &quot;LWZ     $dst, $mem \t// range&quot; %}
 5877   size(4);
 5878   ins_encode( enc_lwz(dst, mem) );
 5879   ins_pipe(pipe_class_memory);
 5880 %}
 5881 
 5882 // Load Compressed Pointer
 5883 instruct loadN(iRegNdst dst, memory mem) %{
 5884   match(Set dst (LoadN mem));
 5885   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5886   ins_cost(MEMORY_REF_COST);
 5887 
 5888   format %{ &quot;LWZ     $dst, $mem \t// load compressed ptr&quot; %}
 5889   size(4);
 5890   ins_encode( enc_lwz(dst, mem) );
 5891   ins_pipe(pipe_class_memory);
 5892 %}
 5893 
 5894 // Load Compressed Pointer acquire.
 5895 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5896   match(Set dst (LoadN mem));
 5897   ins_cost(3*MEMORY_REF_COST);
 5898 
 5899   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5900             &quot;TWI     $dst\n\t&quot;
 5901             &quot;ISYNC&quot; %}
 5902   size(12);
 5903   ins_encode( enc_lwz_ac(dst, mem) );
 5904   ins_pipe(pipe_class_memory);
 5905 %}
 5906 
 5907 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5908 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5909   match(Set dst (DecodeN (LoadN mem)));
 5910   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);
 5911   ins_cost(MEMORY_REF_COST);
 5912 
 5913   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5914   size(4);
 5915   ins_encode( enc_lwz(dst, mem) );
 5916   ins_pipe(pipe_class_memory);
 5917 %}
 5918 
 5919 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5920   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 5921   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;
 5922             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5923   ins_cost(MEMORY_REF_COST);
 5924 
 5925   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5926   size(4);
 5927   ins_encode( enc_lwz(dst, mem) );
 5928   ins_pipe(pipe_class_memory);
 5929 %}
 5930 
 5931 // Load Pointer
 5932 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5933   match(Set dst (LoadP mem));
 5934   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5935   ins_cost(MEMORY_REF_COST);
 5936 
 5937   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5938   size(4);
 5939   ins_encode( enc_ld(dst, mem) );
 5940   ins_pipe(pipe_class_memory);
 5941 %}
 5942 
 5943 // Load Pointer acquire.
 5944 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
 5945   match(Set dst (LoadP mem));
 5946   ins_cost(3*MEMORY_REF_COST);
 5947 
 5948   format %{ &quot;LD      $dst, $mem \t// ptr acquire\n\t&quot;
 5949             &quot;TWI     $dst\n\t&quot;
 5950             &quot;ISYNC&quot; %}
 5951   size(12);
 5952   ins_encode( enc_ld_ac(dst, mem) );
 5953   ins_pipe(pipe_class_memory);
 5954 %}
 5955 
 5956 // LoadP + CastP2L
 5957 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
 5958   match(Set dst (CastP2X (LoadP mem)));
 5959   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5960   ins_cost(MEMORY_REF_COST);
 5961 
 5962   format %{ &quot;LD      $dst, $mem \t// ptr + p2x&quot; %}
 5963   size(4);
 5964   ins_encode( enc_ld(dst, mem) );
 5965   ins_pipe(pipe_class_memory);
 5966 %}
 5967 
 5968 // Load compressed klass pointer.
 5969 instruct loadNKlass(iRegNdst dst, memory mem) %{
 5970   match(Set dst (LoadNKlass mem));
 5971   ins_cost(MEMORY_REF_COST);
 5972 
 5973   format %{ &quot;LWZ     $dst, $mem \t// compressed klass ptr&quot; %}
 5974   size(4);
 5975   ins_encode( enc_lwz(dst, mem) );
 5976   ins_pipe(pipe_class_memory);
 5977 %}
 5978 
 5979 // Load Klass Pointer
 5980 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
 5981   match(Set dst (LoadKlass mem));
 5982   ins_cost(MEMORY_REF_COST);
 5983 
 5984   format %{ &quot;LD      $dst, $mem \t// klass ptr&quot; %}
 5985   size(4);
 5986   ins_encode( enc_ld(dst, mem) );
 5987   ins_pipe(pipe_class_memory);
 5988 %}
 5989 
 5990 // Load Float
 5991 instruct loadF(regF dst, memory mem) %{
 5992   match(Set dst (LoadF mem));
 5993   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5994   ins_cost(MEMORY_REF_COST);
 5995 
 5996   format %{ &quot;LFS     $dst, $mem&quot; %}
 5997   size(4);
 5998   ins_encode %{
 5999     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6000     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6001     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6002   %}
 6003   ins_pipe(pipe_class_memory);
 6004 %}
 6005 
 6006 // Load Float acquire.
 6007 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
 6008   match(Set dst (LoadF mem));
 6009   effect(TEMP cr0);
 6010   ins_cost(3*MEMORY_REF_COST);
 6011 
 6012   format %{ &quot;LFS     $dst, $mem \t// acquire\n\t&quot;
 6013             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6014             &quot;BNE     cr0, next\n&quot;
 6015             &quot;next:\n\t&quot;
 6016             &quot;ISYNC&quot; %}
 6017   size(16);
 6018   ins_encode %{
 6019     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6020     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6021     Label next;
 6022     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6023     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6024     __ bne(CCR0, next);
 6025     __ bind(next);
 6026     __ isync();
 6027   %}
 6028   ins_pipe(pipe_class_memory);
 6029 %}
 6030 
 6031 // Load Double - aligned
 6032 instruct loadD(regD dst, memory mem) %{
 6033   match(Set dst (LoadD mem));
 6034   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6035   ins_cost(MEMORY_REF_COST);
 6036 
 6037   format %{ &quot;LFD     $dst, $mem&quot; %}
 6038   size(4);
 6039   ins_encode( enc_lfd(dst, mem) );
 6040   ins_pipe(pipe_class_memory);
 6041 %}
 6042 
 6043 // Load Double - aligned acquire.
 6044 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
 6045   match(Set dst (LoadD mem));
 6046   effect(TEMP cr0);
 6047   ins_cost(3*MEMORY_REF_COST);
 6048 
 6049   format %{ &quot;LFD     $dst, $mem \t// acquire\n\t&quot;
 6050             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6051             &quot;BNE     cr0, next\n&quot;
 6052             &quot;next:\n\t&quot;
 6053             &quot;ISYNC&quot; %}
 6054   size(16);
 6055   ins_encode %{
 6056     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6057     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6058     Label next;
 6059     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6060     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6061     __ bne(CCR0, next);
 6062     __ bind(next);
 6063     __ isync();
 6064   %}
 6065   ins_pipe(pipe_class_memory);
 6066 %}
 6067 
 6068 // Load Double - UNaligned
 6069 instruct loadD_unaligned(regD dst, memory mem) %{
 6070   match(Set dst (LoadD_unaligned mem));
 6071   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 6072   ins_cost(MEMORY_REF_COST);
 6073 
 6074   format %{ &quot;LFD     $dst, $mem&quot; %}
 6075   size(4);
 6076   ins_encode( enc_lfd(dst, mem) );
 6077   ins_pipe(pipe_class_memory);
 6078 %}
 6079 
 6080 //----------Constants--------------------------------------------------------
 6081 
 6082 // Load MachConstantTableBase: add hi offset to global toc.
 6083 // TODO: Handle hidden register r29 in bundler!
 6084 instruct loadToc_hi(iRegLdst dst) %{
 6085   effect(DEF dst);
 6086   ins_cost(DEFAULT_COST);
 6087 
 6088   format %{ &quot;ADDIS   $dst, R29, DISP.hi \t// load TOC hi&quot; %}
 6089   size(4);
 6090   ins_encode %{
 6091     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6092     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
 6093   %}
 6094   ins_pipe(pipe_class_default);
 6095 %}
 6096 
 6097 // Load MachConstantTableBase: add lo offset to global toc.
 6098 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
 6099   effect(DEF dst, USE src);
 6100   ins_cost(DEFAULT_COST);
 6101 
 6102   format %{ &quot;ADDI    $dst, $src, DISP.lo \t// load TOC lo&quot; %}
 6103   size(4);
 6104   ins_encode %{
 6105     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6106     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
 6107   %}
 6108   ins_pipe(pipe_class_default);
 6109 %}
 6110 
 6111 // Load 16-bit integer constant 0xssss????
 6112 instruct loadConI16(iRegIdst dst, immI16 src) %{
 6113   match(Set dst src);
 6114 
 6115   format %{ &quot;LI      $dst, $src&quot; %}
 6116   size(4);
 6117   ins_encode %{
 6118     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6119     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6120   %}
 6121   ins_pipe(pipe_class_default);
 6122 %}
 6123 
 6124 // Load integer constant 0x????0000
 6125 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
 6126   match(Set dst src);
 6127   ins_cost(DEFAULT_COST);
 6128 
 6129   format %{ &quot;LIS     $dst, $src.hi&quot; %}
 6130   size(4);
 6131   ins_encode %{
 6132     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6133     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
 6134     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6135   %}
 6136   ins_pipe(pipe_class_default);
 6137 %}
 6138 
 6139 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
 6140 // and sign extended), this adds the low 16 bits.
 6141 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 6142   // no match-rule, false predicate
 6143   effect(DEF dst, USE src1, USE src2);
 6144   predicate(false);
 6145 
 6146   format %{ &quot;ORI     $dst, $src1.hi, $src2.lo&quot; %}
 6147   size(4);
 6148   ins_encode %{
 6149     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6150     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6151   %}
 6152   ins_pipe(pipe_class_default);
 6153 %}
 6154 
 6155 instruct loadConI_Ex(iRegIdst dst, immI src) %{
 6156   match(Set dst src);
 6157   ins_cost(DEFAULT_COST*2);
 6158 
 6159   expand %{
 6160     // Would like to use $src$$constant.
 6161     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
 6162     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6163     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
 6164     iRegIdst tmpI;
 6165     loadConIhi16(tmpI, srcHi);
 6166     loadConI32_lo16(dst, tmpI, srcLo);
 6167   %}
 6168 %}
 6169 
 6170 // No constant pool entries required.
 6171 instruct loadConL16(iRegLdst dst, immL16 src) %{
 6172   match(Set dst src);
 6173 
 6174   format %{ &quot;LI      $dst, $src \t// long&quot; %}
 6175   size(4);
 6176   ins_encode %{
 6177     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6178     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
 6179   %}
 6180   ins_pipe(pipe_class_default);
 6181 %}
 6182 
 6183 // Load long constant 0xssssssss????0000
 6184 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
 6185   match(Set dst src);
 6186   ins_cost(DEFAULT_COST);
 6187 
 6188   format %{ &quot;LIS     $dst, $src.hi \t// long&quot; %}
 6189   size(4);
 6190   ins_encode %{
 6191     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6192     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6193   %}
 6194   ins_pipe(pipe_class_default);
 6195 %}
 6196 
 6197 // To load a 32 bit constant: merge lower 16 bits into already loaded
 6198 // high 16 bits.
 6199 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 6200   // no match-rule, false predicate
 6201   effect(DEF dst, USE src1, USE src2);
 6202   predicate(false);
 6203 
 6204   format %{ &quot;ORI     $dst, $src1, $src2.lo&quot; %}
 6205   size(4);
 6206   ins_encode %{
 6207     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6208     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6209   %}
 6210   ins_pipe(pipe_class_default);
 6211 %}
 6212 
 6213 // Load 32-bit long constant
 6214 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
 6215   match(Set dst src);
 6216   ins_cost(DEFAULT_COST*2);
 6217 
 6218   expand %{
 6219     // Would like to use $src$$constant.
 6220     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
 6221     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6222     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
 6223     iRegLdst tmpL;
 6224     loadConL32hi16(tmpL, srcHi);
 6225     loadConL32_lo16(dst, tmpL, srcLo);
 6226   %}
 6227 %}
 6228 
 6229 // Load long constant 0x????000000000000.
 6230 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
 6231   match(Set dst src);
 6232   ins_cost(DEFAULT_COST);
 6233 
 6234   expand %{
 6235     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
 6236     immI shift32 %{ 32 %}
 6237     iRegLdst tmpL;
 6238     loadConL32hi16(tmpL, srcHi);
 6239     lshiftL_regL_immI(dst, tmpL, shift32);
 6240   %}
 6241 %}
 6242 
 6243 // Expand node for constant pool load: small offset.
 6244 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
 6245   effect(DEF dst, USE src, USE toc);
 6246   ins_cost(MEMORY_REF_COST);
 6247 
 6248   ins_num_consts(1);
 6249   // Needed so that CallDynamicJavaDirect can compute the address of this
 6250   // instruction for relocation.
 6251   ins_field_cbuf_insts_offset(int);
 6252 
 6253   format %{ &quot;LD      $dst, offset, $toc \t// load long $src from TOC&quot; %}
 6254   size(4);
 6255   ins_encode( enc_load_long_constL(dst, src, toc) );
 6256   ins_pipe(pipe_class_memory);
 6257 %}
 6258 
 6259 // Expand node for constant pool load: large offset.
 6260 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
 6261   effect(DEF dst, USE src, USE toc);
 6262   predicate(false);
 6263 
 6264   ins_num_consts(1);
 6265   ins_field_const_toc_offset(int);
 6266   // Needed so that CallDynamicJavaDirect can compute the address of this
 6267   // instruction for relocation.
 6268   ins_field_cbuf_insts_offset(int);
 6269 
 6270   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6271   size(4);
 6272   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6273   ins_pipe(pipe_class_default);
 6274 %}
 6275 
 6276 // Expand node for constant pool load: large offset.
 6277 // No constant pool entries required.
 6278 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6279   effect(DEF dst, USE src, USE base);
 6280   predicate(false);
 6281 
 6282   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6283 
 6284   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6285   size(4);
 6286   ins_encode %{
 6287     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6288     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6289     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6290   %}
 6291   ins_pipe(pipe_class_memory);
 6292 %}
 6293 
 6294 // Load long constant from constant table. Expand in case of
 6295 // offset &gt; 16 bit is needed.
 6296 // Adlc adds toc node MachConstantTableBase.
 6297 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6298   match(Set dst src);
 6299   ins_cost(MEMORY_REF_COST);
 6300 
 6301   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6302   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6303   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6304 %}
 6305 
 6306 // Load NULL as compressed oop.
 6307 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6308   match(Set dst src);
 6309   ins_cost(DEFAULT_COST);
 6310 
 6311   format %{ &quot;LI      $dst, $src \t// compressed ptr&quot; %}
 6312   size(4);
 6313   ins_encode %{
 6314     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6315     __ li($dst$$Register, 0);
 6316   %}
 6317   ins_pipe(pipe_class_default);
 6318 %}
 6319 
 6320 // Load hi part of compressed oop constant.
 6321 instruct loadConN_hi(iRegNdst dst, immN src) %{
 6322   effect(DEF dst, USE src);
 6323   ins_cost(DEFAULT_COST);
 6324 
 6325   format %{ &quot;LIS     $dst, $src \t// narrow oop hi&quot; %}
 6326   size(4);
 6327   ins_encode %{
 6328     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6329     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
 6330   %}
 6331   ins_pipe(pipe_class_default);
 6332 %}
 6333 
 6334 // Add lo part of compressed oop constant to already loaded hi part.
 6335 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
 6336   effect(DEF dst, USE src1, USE src2);
 6337   ins_cost(DEFAULT_COST);
 6338 
 6339   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow oop lo&quot; %}
 6340   size(4);
 6341   ins_encode %{
 6342     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6343     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6344     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
 6345     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 6346     __ relocate(rspec, 1);
 6347     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
 6348   %}
 6349   ins_pipe(pipe_class_default);
 6350 %}
 6351 
 6352 instruct rldicl(iRegLdst dst, iRegLsrc src, immI16 shift, immI16 mask_begin) %{
 6353   effect(DEF dst, USE src, USE shift, USE mask_begin);
 6354 
 6355   size(4);
 6356   ins_encode %{
 6357     __ rldicl($dst$$Register, $src$$Register, $shift$$constant, $mask_begin$$constant);
 6358   %}
 6359   ins_pipe(pipe_class_default);
 6360 %}
 6361 
 6362 // Needed to postalloc expand loadConN: ConN is loaded as ConI
 6363 // leaving the upper 32 bits with sign-extension bits.
 6364 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
 6365 // TODO: Eventually call this maskN_regN_FFFFFFFF.
 6366 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
 6367   effect(DEF dst, USE src);
 6368   predicate(false);
 6369 
 6370   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6371   size(4);
 6372   ins_encode %{
 6373     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6374     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6375   %}
 6376   ins_pipe(pipe_class_default);
 6377 %}
 6378 
 6379 // Optimize DecodeN for disjoint base.
 6380 // Load base of compressed oops into a register
 6381 instruct loadBase(iRegLdst dst) %{
 6382   effect(DEF dst);
 6383 
 6384   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6385   ins_encode %{
 6386     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6387     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
 6388   %}
 6389   ins_pipe(pipe_class_default);
 6390 %}
 6391 
 6392 // Loading ConN must be postalloc expanded so that edges between
 6393 // the nodes are safe. They may not interfere with a safepoint.
 6394 // GL TODO: This needs three instructions: better put this into the constant pool.
 6395 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6396   match(Set dst src);
 6397   ins_cost(DEFAULT_COST*2);
 6398 
 6399   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6400   postalloc_expand %{
 6401     MachNode *m1 = new loadConN_hiNode();
 6402     MachNode *m2 = new loadConN_loNode();
 6403     MachNode *m3 = new clearMs32bNode();
 6404     m1-&gt;add_req(NULL);
 6405     m2-&gt;add_req(NULL, m1);
 6406     m3-&gt;add_req(NULL, m2);
 6407     m1-&gt;_opnds[0] = op_dst;
 6408     m1-&gt;_opnds[1] = op_src;
 6409     m2-&gt;_opnds[0] = op_dst;
 6410     m2-&gt;_opnds[1] = op_dst;
 6411     m2-&gt;_opnds[2] = op_src;
 6412     m3-&gt;_opnds[0] = op_dst;
 6413     m3-&gt;_opnds[1] = op_dst;
 6414     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6415     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6416     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6417     nodes-&gt;push(m1);
 6418     nodes-&gt;push(m2);
 6419     nodes-&gt;push(m3);
 6420   %}
 6421 %}
 6422 
 6423 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6424 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6425 // not a narrow oop.
 6426 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6427   match(Set dst src);
 6428   effect(DEF dst, USE src);
 6429   ins_cost(DEFAULT_COST);
 6430 
 6431   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6432   size(4);
 6433   ins_encode %{
 6434     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6435     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
 6436     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6437   %}
 6438   ins_pipe(pipe_class_default);
 6439 %}
 6440 
 6441 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6442 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6443   match(Set dst src1);
 6444   effect(TEMP src2);
 6445   ins_cost(DEFAULT_COST);
 6446 
 6447   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6448   size(4);
 6449   ins_encode %{
 6450     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6451     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6452   %}
 6453   ins_pipe(pipe_class_default);
 6454 %}
 6455 
 6456 // This needs a match rule so that build_oop_map knows this is
 6457 // not a narrow oop.
 6458 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6459   match(Set dst src1);
 6460   effect(TEMP src2);
 6461   ins_cost(DEFAULT_COST);
 6462 
 6463   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6464   size(4);
 6465   ins_encode %{
 6466     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6467     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
 6468     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6469     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6470     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6471 
 6472     __ relocate(rspec, 1);
 6473     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6474   %}
 6475   ins_pipe(pipe_class_default);
 6476 %}
 6477 
 6478 // Loading ConNKlass must be postalloc expanded so that edges between
 6479 // the nodes are safe. They may not interfere with a safepoint.
 6480 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6481   match(Set dst src);
 6482   ins_cost(DEFAULT_COST*2);
 6483 
 6484   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6485   postalloc_expand %{
 6486     // Load high bits into register. Sign extended.
 6487     MachNode *m1 = new loadConNKlass_hiNode();
 6488     m1-&gt;add_req(NULL);
 6489     m1-&gt;_opnds[0] = op_dst;
 6490     m1-&gt;_opnds[1] = op_src;
 6491     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6492     nodes-&gt;push(m1);
 6493 
 6494     MachNode *m2 = m1;
 6495     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {
 6496       // Value might be 1-extended. Mask out these bits.
 6497       m2 = new loadConNKlass_maskNode();
 6498       m2-&gt;add_req(NULL, m1);
 6499       m2-&gt;_opnds[0] = op_dst;
 6500       m2-&gt;_opnds[1] = op_src;
 6501       m2-&gt;_opnds[2] = op_dst;
 6502       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6503       nodes-&gt;push(m2);
 6504     }
 6505 
 6506     MachNode *m3 = new loadConNKlass_loNode();
 6507     m3-&gt;add_req(NULL, m2);
 6508     m3-&gt;_opnds[0] = op_dst;
 6509     m3-&gt;_opnds[1] = op_src;
 6510     m3-&gt;_opnds[2] = op_dst;
 6511     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6512     nodes-&gt;push(m3);
 6513   %}
 6514 %}
 6515 
 6516 // 0x1 is used in object initialization (initial object header).
 6517 // No constant pool entries required.
 6518 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
 6519   match(Set dst src);
 6520 
 6521   format %{ &quot;LI      $dst, $src \t// ptr&quot; %}
 6522   size(4);
 6523   ins_encode %{
 6524     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6525     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6526   %}
 6527   ins_pipe(pipe_class_default);
 6528 %}
 6529 
 6530 // Expand node for constant pool load: small offset.
 6531 // The match rule is needed to generate the correct bottom_type(),
 6532 // however this node should never match. The use of predicate is not
 6533 // possible since ADLC forbids predicates for chain rules. The higher
 6534 // costs do not prevent matching in this case. For that reason the
 6535 // operand immP_NM with predicate(false) is used.
 6536 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6537   match(Set dst src);
 6538   effect(TEMP toc);
 6539 
 6540   ins_num_consts(1);
 6541 
 6542   format %{ &quot;LD      $dst, offset, $toc \t// load ptr $src from TOC&quot; %}
 6543   size(4);
 6544   ins_encode( enc_load_long_constP(dst, src, toc) );
 6545   ins_pipe(pipe_class_memory);
 6546 %}
 6547 
 6548 // Expand node for constant pool load: large offset.
 6549 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6550   effect(DEF dst, USE src, USE toc);
 6551   predicate(false);
 6552 
 6553   ins_num_consts(1);
 6554   ins_field_const_toc_offset(int);
 6555 
 6556   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6557   size(4);
 6558   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6559   ins_pipe(pipe_class_default);
 6560 %}
 6561 
 6562 // Expand node for constant pool load: large offset.
 6563 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6564   match(Set dst src);
 6565   effect(TEMP base);
 6566 
 6567   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6568 
 6569   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6570   size(4);
 6571   ins_encode %{
 6572     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 6573     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;
 6574     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6575   %}
 6576   ins_pipe(pipe_class_memory);
 6577 %}
 6578 
 6579 // Load pointer constant from constant table. Expand in case an
 6580 // offset &gt; 16 bit is needed.
 6581 // Adlc adds toc node MachConstantTableBase.
 6582 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6583   match(Set dst src);
 6584   ins_cost(MEMORY_REF_COST);
 6585 
 6586   // This rule does not use &quot;expand&quot; because then
 6587   // the result type is not known to be an Oop.  An ADLC
 6588   // enhancement will be needed to make that work - not worth it!
 6589 
 6590   // If this instruction rematerializes, it prolongs the live range
 6591   // of the toc node, causing illegal graphs.
 6592   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6593   ins_cannot_rematerialize(true);
 6594 
 6595   format %{ &quot;LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded&quot; %}
 6596   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
 6597 %}
 6598 
 6599 // Expand node for constant pool load: small offset.
 6600 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
 6601   effect(DEF dst, USE src, USE toc);
 6602   ins_cost(MEMORY_REF_COST);
 6603 
 6604   ins_num_consts(1);
 6605 
 6606   format %{ &quot;LFS     $dst, offset, $toc \t// load float $src from TOC&quot; %}
 6607   size(4);
 6608   ins_encode %{
 6609     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6610     address float_address = __ float_constant($src$$constant);
 6611     if (float_address == NULL) {
 6612       ciEnv::current()-&gt;record_out_of_memory_failure();
 6613       return;
 6614     }
 6615     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
 6616   %}
 6617   ins_pipe(pipe_class_memory);
 6618 %}
 6619 
 6620 // Expand node for constant pool load: large offset.
 6621 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
 6622   effect(DEF dst, USE src, USE toc);
 6623   ins_cost(MEMORY_REF_COST);
 6624 
 6625   ins_num_consts(1);
 6626 
 6627   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6628             &quot;LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t&quot;
 6629             &quot;ADDIS   $toc, $toc, -offset_hi&quot;%}
 6630   size(12);
 6631   ins_encode %{
 6632     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6633     FloatRegister Rdst    = $dst$$FloatRegister;
 6634     Register Rtoc         = $toc$$Register;
 6635     address float_address = __ float_constant($src$$constant);
 6636     if (float_address == NULL) {
 6637       ciEnv::current()-&gt;record_out_of_memory_failure();
 6638       return;
 6639     }
 6640     int offset            = __ offset_to_method_toc(float_address);
 6641     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6642     int lo = offset - hi * (1&lt;&lt;16);
 6643 
 6644     __ addis(Rtoc, Rtoc, hi);
 6645     __ lfs(Rdst, lo, Rtoc);
 6646     __ addis(Rtoc, Rtoc, -hi);
 6647   %}
 6648   ins_pipe(pipe_class_memory);
 6649 %}
 6650 
 6651 // Adlc adds toc node MachConstantTableBase.
 6652 instruct loadConF_Ex(regF dst, immF src) %{
 6653   match(Set dst src);
 6654   ins_cost(MEMORY_REF_COST);
 6655 
 6656   // See loadConP.
 6657   ins_cannot_rematerialize(true);
 6658 
 6659   format %{ &quot;LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6660   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
 6661 %}
 6662 
 6663 // Expand node for constant pool load: small offset.
 6664 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
 6665   effect(DEF dst, USE src, USE toc);
 6666   ins_cost(MEMORY_REF_COST);
 6667 
 6668   ins_num_consts(1);
 6669 
 6670   format %{ &quot;LFD     $dst, offset, $toc \t// load double $src from TOC&quot; %}
 6671   size(4);
 6672   ins_encode %{
 6673     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 6674     address float_address = __ double_constant($src$$constant);
 6675     if (float_address == NULL) {
 6676       ciEnv::current()-&gt;record_out_of_memory_failure();
 6677       return;
 6678     }
 6679     int offset =  __ offset_to_method_toc(float_address);
 6680     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
 6681   %}
 6682   ins_pipe(pipe_class_memory);
 6683 %}
 6684 
 6685 // Expand node for constant pool load: large offset.
 6686 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
 6687   effect(DEF dst, USE src, USE toc);
 6688   ins_cost(MEMORY_REF_COST);
 6689 
 6690   ins_num_consts(1);
 6691 
 6692   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6693             &quot;LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t&quot;
 6694             &quot;ADDIS   $toc, $toc, -offset_hi&quot; %}
 6695   size(12);
 6696   ins_encode %{
 6697     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6698     FloatRegister Rdst    = $dst$$FloatRegister;
 6699     Register      Rtoc    = $toc$$Register;
 6700     address float_address = __ double_constant($src$$constant);
 6701     if (float_address == NULL) {
 6702       ciEnv::current()-&gt;record_out_of_memory_failure();
 6703       return;
 6704     }
 6705     int offset = __ offset_to_method_toc(float_address);
 6706     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6707     int lo = offset - hi * (1&lt;&lt;16);
 6708 
 6709     __ addis(Rtoc, Rtoc, hi);
 6710     __ lfd(Rdst, lo, Rtoc);
 6711     __ addis(Rtoc, Rtoc, -hi);
 6712   %}
 6713   ins_pipe(pipe_class_memory);
 6714 %}
 6715 
 6716 // Adlc adds toc node MachConstantTableBase.
 6717 instruct loadConD_Ex(regD dst, immD src) %{
 6718   match(Set dst src);
 6719   ins_cost(MEMORY_REF_COST);
 6720 
 6721   // See loadConP.
 6722   ins_cannot_rematerialize(true);
 6723 
 6724   format %{ &quot;ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6725   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
 6726 %}
 6727 
 6728 // Prefetch instructions.
 6729 // Must be safe to execute with invalid address (cannot fault).
 6730 
 6731 // Special prefetch versions which use the dcbz instruction.
 6732 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
 6733   match(PrefetchAllocation (AddP mem src));
 6734   predicate(AllocatePrefetchStyle == 3);
 6735   ins_cost(MEMORY_REF_COST);
 6736 
 6737   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many with zero&quot; %}
 6738   size(4);
 6739   ins_encode %{
 6740     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6741     __ dcbz($src$$Register, $mem$$base$$Register);
 6742   %}
 6743   ins_pipe(pipe_class_memory);
 6744 %}
 6745 
 6746 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
 6747   match(PrefetchAllocation mem);
 6748   predicate(AllocatePrefetchStyle == 3);
 6749   ins_cost(MEMORY_REF_COST);
 6750 
 6751   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many with zero&quot; %}
 6752   size(4);
 6753   ins_encode %{
 6754     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6755     __ dcbz($mem$$base$$Register);
 6756   %}
 6757   ins_pipe(pipe_class_memory);
 6758 %}
 6759 
 6760 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
 6761   match(PrefetchAllocation (AddP mem src));
 6762   predicate(AllocatePrefetchStyle != 3);
 6763   ins_cost(MEMORY_REF_COST);
 6764 
 6765   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many&quot; %}
 6766   size(4);
 6767   ins_encode %{
 6768     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6769     __ dcbtst($src$$Register, $mem$$base$$Register);
 6770   %}
 6771   ins_pipe(pipe_class_memory);
 6772 %}
 6773 
 6774 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
 6775   match(PrefetchAllocation mem);
 6776   predicate(AllocatePrefetchStyle != 3);
 6777   ins_cost(MEMORY_REF_COST);
 6778 
 6779   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many&quot; %}
 6780   size(4);
 6781   ins_encode %{
 6782     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6783     __ dcbtst($mem$$base$$Register);
 6784   %}
 6785   ins_pipe(pipe_class_memory);
 6786 %}
 6787 
 6788 //----------Store Instructions-------------------------------------------------
 6789 
 6790 // Store Byte
 6791 instruct storeB(memory mem, iRegIsrc src) %{
 6792   match(Set mem (StoreB mem src));
 6793   ins_cost(MEMORY_REF_COST);
 6794 
 6795   format %{ &quot;STB     $src, $mem \t// byte&quot; %}
 6796   size(4);
 6797   ins_encode %{
 6798     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
 6799     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6800     __ stb($src$$Register, Idisp, $mem$$base$$Register);
 6801   %}
 6802   ins_pipe(pipe_class_memory);
 6803 %}
 6804 
 6805 // Store Char/Short
 6806 instruct storeC(memory mem, iRegIsrc src) %{
 6807   match(Set mem (StoreC mem src));
 6808   ins_cost(MEMORY_REF_COST);
 6809 
 6810   format %{ &quot;STH     $src, $mem \t// short&quot; %}
 6811   size(4);
 6812   ins_encode %{
 6813     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
 6814     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6815     __ sth($src$$Register, Idisp, $mem$$base$$Register);
 6816   %}
 6817   ins_pipe(pipe_class_memory);
 6818 %}
 6819 
 6820 // Store Integer
 6821 instruct storeI(memory mem, iRegIsrc src) %{
 6822   match(Set mem (StoreI mem src));
 6823   ins_cost(MEMORY_REF_COST);
 6824 
 6825   format %{ &quot;STW     $src, $mem&quot; %}
 6826   size(4);
 6827   ins_encode( enc_stw(src, mem) );
 6828   ins_pipe(pipe_class_memory);
 6829 %}
 6830 
 6831 // ConvL2I + StoreI.
 6832 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
 6833   match(Set mem (StoreI mem (ConvL2I src)));
 6834   ins_cost(MEMORY_REF_COST);
 6835 
 6836   format %{ &quot;STW     l2i($src), $mem&quot; %}
 6837   size(4);
 6838   ins_encode( enc_stw(src, mem) );
 6839   ins_pipe(pipe_class_memory);
 6840 %}
 6841 
 6842 // Store Long
 6843 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
 6844   match(Set mem (StoreL mem src));
 6845   ins_cost(MEMORY_REF_COST);
 6846 
 6847   format %{ &quot;STD     $src, $mem \t// long&quot; %}
 6848   size(4);
 6849   ins_encode( enc_std(src, mem) );
 6850   ins_pipe(pipe_class_memory);
 6851 %}
 6852 
 6853 // Store super word nodes.
 6854 
 6855 // Store Aligned Packed Byte long register to memory
 6856 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
 6857   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 6858   match(Set mem (StoreVector mem src));
 6859   ins_cost(MEMORY_REF_COST);
 6860 
 6861   format %{ &quot;STD     $mem, $src \t// packed8B&quot; %}
 6862   size(4);
 6863   ins_encode( enc_std(src, mem) );
 6864   ins_pipe(pipe_class_memory);
 6865 %}
 6866 
 6867 // Store Packed Byte long register to memory
 6868 instruct storeV16(indirect mem, vecX src) %{
 6869   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 6870   match(Set mem (StoreVector mem src));
 6871   ins_cost(MEMORY_REF_COST);
 6872 
 6873   format %{ &quot;STXVD2X     $mem, $src \t// store 16-byte Vector&quot; %}
 6874   size(4);
 6875   ins_encode %{
 6876     __ stxvd2x($src$$VectorSRegister, $mem$$Register);
 6877   %}
 6878   ins_pipe(pipe_class_default);
 6879 %}
 6880 
 6881 // Store Compressed Oop
 6882 instruct storeN(memory dst, iRegN_P2N src) %{
 6883   match(Set dst (StoreN dst src));
 6884   ins_cost(MEMORY_REF_COST);
 6885 
 6886   format %{ &quot;STW     $src, $dst \t// compressed oop&quot; %}
 6887   size(4);
 6888   ins_encode( enc_stw(src, dst) );
 6889   ins_pipe(pipe_class_memory);
 6890 %}
 6891 
 6892 // Store Compressed KLass
 6893 instruct storeNKlass(memory dst, iRegN_P2N src) %{
 6894   match(Set dst (StoreNKlass dst src));
 6895   ins_cost(MEMORY_REF_COST);
 6896 
 6897   format %{ &quot;STW     $src, $dst \t// compressed klass&quot; %}
 6898   size(4);
 6899   ins_encode( enc_stw(src, dst) );
 6900   ins_pipe(pipe_class_memory);
 6901 %}
 6902 
 6903 // Store Pointer
 6904 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
 6905   match(Set dst (StoreP dst src));
 6906   ins_cost(MEMORY_REF_COST);
 6907 
 6908   format %{ &quot;STD     $src, $dst \t// ptr&quot; %}
 6909   size(4);
 6910   ins_encode( enc_std(src, dst) );
 6911   ins_pipe(pipe_class_memory);
 6912 %}
 6913 
 6914 // Store Float
 6915 instruct storeF(memory mem, regF src) %{
 6916   match(Set mem (StoreF mem src));
 6917   ins_cost(MEMORY_REF_COST);
 6918 
 6919   format %{ &quot;STFS    $src, $mem&quot; %}
 6920   size(4);
 6921   ins_encode( enc_stfs(src, mem) );
 6922   ins_pipe(pipe_class_memory);
 6923 %}
 6924 
 6925 // Store Double
 6926 instruct storeD(memory mem, regD src) %{
 6927   match(Set mem (StoreD mem src));
 6928   ins_cost(MEMORY_REF_COST);
 6929 
 6930   format %{ &quot;STFD    $src, $mem&quot; %}
 6931   size(4);
 6932   ins_encode( enc_stfd(src, mem) );
 6933   ins_pipe(pipe_class_memory);
 6934 %}
 6935 
 6936 //----------Store Instructions With Zeros--------------------------------------
 6937 
 6938 // Card-mark for CMS garbage collection.
 6939 // This cardmark does an optimization so that it must not always
 6940 // do a releasing store. For this, it gets the address of
 6941 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6942 // (Using releaseFieldAddr in the match rule is a hack.)
 6943 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6944   match(Set mem (StoreCM mem releaseFieldAddr));
 6945   effect(TEMP crx);
 6946   predicate(false);
 6947   ins_cost(MEMORY_REF_COST);
 6948 
 6949   // See loadConP.
 6950   ins_cannot_rematerialize(true);
 6951 
 6952   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6953   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6954   ins_pipe(pipe_class_memory);
 6955 %}
 6956 
 6957 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6958   match(Set mem (StoreCM mem zero));
 6959   predicate(UseG1GC);
 6960   ins_cost(MEMORY_REF_COST);
 6961 
 6962   ins_cannot_rematerialize(true);
 6963 
 6964   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6965   size(8);
 6966   ins_encode %{
 6967     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6968     __ li(R0, 0);
 6969     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6970     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6971     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6972   %}
 6973   ins_pipe(pipe_class_memory);
 6974 %}
 6975 
 6976 // Convert oop pointer into compressed form.
 6977 
 6978 // Nodes for postalloc expand.
 6979 
 6980 // Shift node for expand.
 6981 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6982   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6983   match(Set dst (EncodeP src));
 6984   predicate(false);
 6985 
 6986   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6987   size(4);
 6988   ins_encode %{
 6989     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6990     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 6991   %}
 6992   ins_pipe(pipe_class_default);
 6993 %}
 6994 
 6995 // Add node for expand.
 6996 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 6997   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6998   match(Set dst (EncodeP src));
 6999   predicate(false);
 7000 
 7001   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7002   ins_encode %{
 7003     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7004     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7005   %}
 7006   ins_pipe(pipe_class_default);
 7007 %}
 7008 
 7009 // Conditional sub base.
 7010 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7011   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7012   match(Set dst (EncodeP (Binary crx src1)));
 7013   predicate(false);
 7014 
 7015   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7016             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7017             &quot;done:&quot; %}
 7018   ins_encode %{
 7019     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7020     Label done;
 7021     __ beq($crx$$CondRegister, done);
 7022     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
 7023     __ bind(done);
 7024   %}
 7025   ins_pipe(pipe_class_default);
 7026 %}
 7027 
 7028 // Power 7 can use isel instruction
 7029 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7030   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7031   match(Set dst (EncodeP (Binary crx src1)));
 7032   predicate(false);
 7033 
 7034   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7035   size(4);
 7036   ins_encode %{
 7037     // This is a Power7 instruction for which no machine description exists.
 7038     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7039     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7040   %}
 7041   ins_pipe(pipe_class_default);
 7042 %}
 7043 
 7044 // Disjoint narrow oop base.
 7045 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7046   match(Set dst (EncodeP src));
 7047   predicate(CompressedOops::base_disjoint());
 7048 
 7049   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7050   size(4);
 7051   ins_encode %{
 7052     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7053     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
 7054   %}
 7055   ins_pipe(pipe_class_default);
 7056 %}
 7057 
 7058 // shift != 0, base != 0
 7059 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7060   match(Set dst (EncodeP src));
 7061   effect(TEMP crx);
 7062   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7063             CompressedOops::shift() != 0 &amp;&amp;
 7064             CompressedOops::base_overlaps());
 7065 
 7066   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7067   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7068 %}
 7069 
 7070 // shift != 0, base != 0
 7071 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7072   match(Set dst (EncodeP src));
 7073   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
 7074             CompressedOops::shift() != 0 &amp;&amp;
 7075             CompressedOops::base_overlaps());
 7076 
 7077   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7078   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7079 %}
 7080 
 7081 // shift != 0, base == 0
 7082 // TODO: This is the same as encodeP_shift. Merge!
 7083 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7084   match(Set dst (EncodeP src));
 7085   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7086             CompressedOops::base() ==0);
 7087 
 7088   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7089   size(4);
 7090   ins_encode %{
 7091     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7092     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7093   %}
 7094   ins_pipe(pipe_class_default);
 7095 %}
 7096 
 7097 // Compressed OOPs with narrow_oop_shift == 0.
 7098 // shift == 0, base == 0
 7099 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7100   match(Set dst (EncodeP src));
 7101   predicate(CompressedOops::shift() == 0);
 7102 
 7103   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7104   // variable size, 0 or 4.
 7105   ins_encode %{
 7106     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7107     __ mr_if_needed($dst$$Register, $src$$Register);
 7108   %}
 7109   ins_pipe(pipe_class_default);
 7110 %}
 7111 
 7112 // Decode nodes.
 7113 
 7114 // Shift node for expand.
 7115 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7116   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7117   match(Set dst (DecodeN src));
 7118   predicate(false);
 7119 
 7120   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7121   size(4);
 7122   ins_encode %{
 7123     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7124     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7125   %}
 7126   ins_pipe(pipe_class_default);
 7127 %}
 7128 
 7129 // Add node for expand.
 7130 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7131   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7132   match(Set dst (DecodeN src));
 7133   predicate(false);
 7134 
 7135   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7136   ins_encode %{
 7137     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7138     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7139   %}
 7140   ins_pipe(pipe_class_default);
 7141 %}
 7142 
 7143 // conditianal add base for expand
 7144 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7145   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7146   // NOTICE that the rule is nonsense - we just have to make sure that:
 7147   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7148   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7149   match(Set dst (DecodeN (Binary crx src)));
 7150   predicate(false);
 7151 
 7152   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7153             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7154             &quot;done:&quot; %}
 7155   ins_encode %{
 7156     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7157     Label done;
 7158     __ beq($crx$$CondRegister, done);
 7159     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7160     __ bind(done);
 7161   %}
 7162   ins_pipe(pipe_class_default);
 7163 %}
 7164 
 7165 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7166   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7167   // NOTICE that the rule is nonsense - we just have to make sure that:
 7168   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7169   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7170   match(Set dst (DecodeN (Binary crx src1)));
 7171   predicate(false);
 7172 
 7173   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7174   size(4);
 7175   ins_encode %{
 7176     // This is a Power7 instruction for which no machine description exists.
 7177     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7178     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7179   %}
 7180   ins_pipe(pipe_class_default);
 7181 %}
 7182 
 7183 //  shift != 0, base != 0
 7184 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7185   match(Set dst (DecodeN src));
 7186   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7187              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7188             CompressedOops::shift() != 0 &amp;&amp;
 7189             CompressedOops::base() != 0);
 7190   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7191   effect(TEMP crx);
 7192 
 7193   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7194   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7195 %}
 7196 
 7197 // shift != 0, base == 0
 7198 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7199   match(Set dst (DecodeN src));
 7200   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7201             CompressedOops::base() == 0);
 7202 
 7203   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7204   size(4);
 7205   ins_encode %{
 7206     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7207     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7208   %}
 7209   ins_pipe(pipe_class_default);
 7210 %}
 7211 
 7212 // Optimize DecodeN for disjoint base.
 7213 // Shift narrow oop and or it into register that already contains the heap base.
 7214 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7215 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7216   match(Set dst (DecodeN src));
 7217   effect(TEMP base);
 7218   predicate(false);
 7219 
 7220   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7221   size(4);
 7222   ins_encode %{
 7223     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
 7224     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
 7225   %}
 7226   ins_pipe(pipe_class_default);
 7227 %}
 7228 
 7229 // Optimize DecodeN for disjoint base.
 7230 // This node requires only one cycle on the critical path.
 7231 // We must postalloc_expand as we can not express use_def effects where
 7232 // the used register is L and the def&#39;ed register P.
 7233 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7234   match(Set dst (DecodeN src));
 7235   effect(TEMP_DEF dst);
 7236   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7237              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7238             CompressedOops::base_disjoint());
 7239   ins_cost(DEFAULT_COST);
 7240 
 7241   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7242             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7243   postalloc_expand %{
 7244     loadBaseNode *n1 = new loadBaseNode();
 7245     n1-&gt;add_req(NULL);
 7246     n1-&gt;_opnds[0] = op_dst;
 7247 
 7248     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7249     n2-&gt;add_req(n_region, n_src, n1);
 7250     n2-&gt;_opnds[0] = op_dst;
 7251     n2-&gt;_opnds[1] = op_src;
 7252     n2-&gt;_opnds[2] = op_dst;
 7253     n2-&gt;_bottom_type = _bottom_type;
 7254 
 7255     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7256     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7257 
 7258     nodes-&gt;push(n1);
 7259     nodes-&gt;push(n2);
 7260   %}
 7261 %}
 7262 
 7263 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7264   match(Set dst (DecodeN src));
 7265   effect(TEMP_DEF dst, TEMP crx);
 7266   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7267              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7268             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());
 7269   ins_cost(3 * DEFAULT_COST);
 7270 
 7271   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7272   postalloc_expand %{
 7273     loadBaseNode *n1 = new loadBaseNode();
 7274     n1-&gt;add_req(NULL);
 7275     n1-&gt;_opnds[0] = op_dst;
 7276 
 7277     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7278     n_compare-&gt;add_req(n_region, n_src);
 7279     n_compare-&gt;_opnds[0] = op_crx;
 7280     n_compare-&gt;_opnds[1] = op_src;
 7281     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7282 
 7283     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7284     n2-&gt;add_req(n_region, n_src, n1);
 7285     n2-&gt;_opnds[0] = op_dst;
 7286     n2-&gt;_opnds[1] = op_src;
 7287     n2-&gt;_opnds[2] = op_dst;
 7288     n2-&gt;_bottom_type = _bottom_type;
 7289 
 7290     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 7291     n_cond_set-&gt;add_req(n_region, n_compare, n2);
 7292     n_cond_set-&gt;_opnds[0] = op_dst;
 7293     n_cond_set-&gt;_opnds[1] = op_crx;
 7294     n_cond_set-&gt;_opnds[2] = op_dst;
 7295     n_cond_set-&gt;_bottom_type = _bottom_type;
 7296 
 7297     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7298     ra_-&gt;set_oop(n_cond_set, true);
 7299 
 7300     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7301     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7302     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7303     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7304 
 7305     nodes-&gt;push(n1);
 7306     nodes-&gt;push(n_compare);
 7307     nodes-&gt;push(n2);
 7308     nodes-&gt;push(n_cond_set);
 7309   %}
 7310 %}
 7311 
 7312 // src != 0, shift != 0, base != 0
 7313 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7314   match(Set dst (DecodeN src));
 7315   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7316              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7317             CompressedOops::shift() != 0 &amp;&amp;
 7318             CompressedOops::base() != 0);
 7319   ins_cost(2 * DEFAULT_COST);
 7320 
 7321   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7322   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7323 %}
 7324 
 7325 // Compressed OOPs with narrow_oop_shift == 0.
 7326 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7327   match(Set dst (DecodeN src));
 7328   predicate(CompressedOops::shift() == 0);
 7329   ins_cost(DEFAULT_COST);
 7330 
 7331   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7332   // variable size, 0 or 4.
 7333   ins_encode %{
 7334     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7335     __ mr_if_needed($dst$$Register, $src$$Register);
 7336   %}
 7337   ins_pipe(pipe_class_default);
 7338 %}
 7339 
 7340 // Convert compressed oop into int for vectors alignment masking.
 7341 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7342   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7343   predicate(CompressedOops::shift() == 0);
 7344   ins_cost(DEFAULT_COST);
 7345 
 7346   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7347   // variable size, 0 or 4.
 7348   ins_encode %{
 7349     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7350     __ mr_if_needed($dst$$Register, $src$$Register);
 7351   %}
 7352   ins_pipe(pipe_class_default);
 7353 %}
 7354 
 7355 // Convert klass pointer into compressed form.
 7356 
 7357 // Nodes for postalloc expand.
 7358 
 7359 // Shift node for expand.
 7360 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7361   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7362   match(Set dst (EncodePKlass src));
 7363   predicate(false);
 7364 
 7365   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7366   size(4);
 7367   ins_encode %{
 7368     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7369     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7370   %}
 7371   ins_pipe(pipe_class_default);
 7372 %}
 7373 
 7374 // Add node for expand.
 7375 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7376   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7377   match(Set dst (EncodePKlass (Binary base src)));
 7378   predicate(false);
 7379 
 7380   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7381   size(4);
 7382   ins_encode %{
 7383     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7384     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7385   %}
 7386   ins_pipe(pipe_class_default);
 7387 %}
 7388 
 7389 // Disjoint narrow oop base.
 7390 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7391   match(Set dst (EncodePKlass src));
 7392   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 7393 
 7394   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7395   size(4);
 7396   ins_encode %{
 7397     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7398     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
 7399   %}
 7400   ins_pipe(pipe_class_default);
 7401 %}
 7402 
 7403 // shift != 0, base != 0
 7404 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7405   match(Set dst (EncodePKlass (Binary base src)));
 7406   predicate(false);
 7407 
 7408   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7409   postalloc_expand %{
 7410     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7411     n1-&gt;add_req(n_region, n_base, n_src);
 7412     n1-&gt;_opnds[0] = op_dst;
 7413     n1-&gt;_opnds[1] = op_base;
 7414     n1-&gt;_opnds[2] = op_src;
 7415     n1-&gt;_bottom_type = _bottom_type;
 7416 
 7417     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7418     n2-&gt;add_req(n_region, n1);
 7419     n2-&gt;_opnds[0] = op_dst;
 7420     n2-&gt;_opnds[1] = op_dst;
 7421     n2-&gt;_bottom_type = _bottom_type;
 7422     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7423     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7424 
 7425     nodes-&gt;push(n1);
 7426     nodes-&gt;push(n2);
 7427   %}
 7428 %}
 7429 
 7430 // shift != 0, base != 0
 7431 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7432   match(Set dst (EncodePKlass src));
 7433   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7434   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 7435 
 7436   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7437   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7438   expand %{
 7439     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
 7440     iRegLdst base;
 7441     loadConL_Ex(base, baseImm);
 7442     encodePKlass_not_null_Ex(dst, base, src);
 7443   %}
 7444 %}
 7445 
 7446 // Decode nodes.
 7447 
 7448 // Shift node for expand.
 7449 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7450   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7451   match(Set dst (DecodeNKlass src));
 7452   predicate(false);
 7453 
 7454   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7455   size(4);
 7456   ins_encode %{
 7457     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7458     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7459   %}
 7460   ins_pipe(pipe_class_default);
 7461 %}
 7462 
 7463 // Add node for expand.
 7464 
 7465 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7466   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7467   match(Set dst (DecodeNKlass (Binary base src)));
 7468   predicate(false);
 7469 
 7470   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7471   size(4);
 7472   ins_encode %{
 7473     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7474     __ add($dst$$Register, $base$$Register, $src$$Register);
 7475   %}
 7476   ins_pipe(pipe_class_default);
 7477 %}
 7478 
 7479 // src != 0, shift != 0, base != 0
 7480 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
 7481   match(Set dst (DecodeNKlass (Binary base src)));
 7482   //effect(kill src); // We need a register for the immediate result after shifting.
 7483   predicate(false);
 7484 
 7485   format %{ &quot;DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded&quot; %}
 7486   postalloc_expand %{
 7487     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
 7488     n1-&gt;add_req(n_region, n_base, n_src);
 7489     n1-&gt;_opnds[0] = op_dst;
 7490     n1-&gt;_opnds[1] = op_base;
 7491     n1-&gt;_opnds[2] = op_src;
 7492     n1-&gt;_bottom_type = _bottom_type;
 7493 
 7494     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7495     n2-&gt;add_req(n_region, n1);
 7496     n2-&gt;_opnds[0] = op_dst;
 7497     n2-&gt;_opnds[1] = op_dst;
 7498     n2-&gt;_bottom_type = _bottom_type;
 7499 
 7500     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7501     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7502 
 7503     nodes-&gt;push(n1);
 7504     nodes-&gt;push(n2);
 7505   %}
 7506 %}
 7507 
 7508 // src != 0, shift != 0, base != 0
 7509 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7510   match(Set dst (DecodeNKlass src));
 7511   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7512   //           CompressedKlassPointers::base() != 0);
 7513 
 7514   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7515 
 7516   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7517   expand %{
 7518     // We add first, then we shift. Like this, we can get along with one register less.
 7519     // But we have to load the base pre-shifted.
 7520     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}
 7521     iRegLdst base;
 7522     loadConL_Ex(base, baseImm);
 7523     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7524   %}
 7525 %}
 7526 
 7527 //----------MemBar Instructions-----------------------------------------------
 7528 // Memory barrier flavors
 7529 
 7530 instruct membar_acquire() %{
 7531   match(LoadFence);
 7532   ins_cost(4*MEMORY_REF_COST);
 7533 
 7534   format %{ &quot;MEMBAR-acquire&quot; %}
 7535   size(4);
 7536   ins_encode %{
 7537     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7538     __ acquire();
 7539   %}
 7540   ins_pipe(pipe_class_default);
 7541 %}
 7542 
 7543 instruct unnecessary_membar_acquire() %{
 7544   match(MemBarAcquire);
 7545   ins_cost(0);
 7546 
 7547   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty&quot; %}
 7548   size(0);
 7549   ins_encode( /*empty*/ );
 7550   ins_pipe(pipe_class_default);
 7551 %}
 7552 
 7553 instruct membar_acquire_lock() %{
 7554   match(MemBarAcquireLock);
 7555   ins_cost(0);
 7556 
 7557   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)&quot; %}
 7558   size(0);
 7559   ins_encode( /*empty*/ );
 7560   ins_pipe(pipe_class_default);
 7561 %}
 7562 
 7563 instruct membar_release() %{
 7564   match(MemBarRelease);
 7565   match(StoreFence);
 7566   ins_cost(4*MEMORY_REF_COST);
 7567 
 7568   format %{ &quot;MEMBAR-release&quot; %}
 7569   size(4);
 7570   ins_encode %{
 7571     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7572     __ release();
 7573   %}
 7574   ins_pipe(pipe_class_default);
 7575 %}
 7576 
 7577 instruct membar_storestore() %{
 7578   match(MemBarStoreStore);
 7579   ins_cost(4*MEMORY_REF_COST);
 7580 
 7581   format %{ &quot;MEMBAR-store-store&quot; %}
 7582   size(4);
 7583   ins_encode %{
 7584     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7585     __ membar(Assembler::StoreStore);
 7586   %}
 7587   ins_pipe(pipe_class_default);
 7588 %}
 7589 
 7590 instruct membar_release_lock() %{
 7591   match(MemBarReleaseLock);
 7592   ins_cost(0);
 7593 
 7594   format %{ &quot; -- \t// redundant MEMBAR-release - empty (release in FastUnlock)&quot; %}
 7595   size(0);
 7596   ins_encode( /*empty*/ );
 7597   ins_pipe(pipe_class_default);
 7598 %}
 7599 
 7600 instruct membar_volatile() %{
 7601   match(MemBarVolatile);
 7602   ins_cost(4*MEMORY_REF_COST);
 7603 
 7604   format %{ &quot;MEMBAR-volatile&quot; %}
 7605   size(4);
 7606   ins_encode %{
 7607     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
 7608     __ fence();
 7609   %}
 7610   ins_pipe(pipe_class_default);
 7611 %}
 7612 
 7613 // This optimization is wrong on PPC. The following pattern is not supported:
 7614 //  MemBarVolatile
 7615 //   ^        ^
 7616 //   |        |
 7617 //  CtrlProj MemProj
 7618 //   ^        ^
 7619 //   |        |
 7620 //   |       Load
 7621 //   |
 7622 //  MemBarVolatile
 7623 //
 7624 //  The first MemBarVolatile could get optimized out! According to
 7625 //  Vladimir, this pattern can not occur on Oracle platforms.
 7626 //  However, it does occur on PPC64 (because of membars in
 7627 //  inline_unsafe_load_store).
 7628 //
 7629 // Add this node again if we found a good solution for inline_unsafe_load_store().
 7630 // Don&#39;t forget to look at the implementation of post_store_load_barrier again,
 7631 // we did other fixes in that method.
 7632 //instruct unnecessary_membar_volatile() %{
 7633 //  match(MemBarVolatile);
 7634 //  predicate(Matcher::post_store_load_barrier(n));
 7635 //  ins_cost(0);
 7636 //
 7637 //  format %{ &quot; -- \t// redundant MEMBAR-volatile - empty&quot; %}
 7638 //  size(0);
 7639 //  ins_encode( /*empty*/ );
 7640 //  ins_pipe(pipe_class_default);
 7641 //%}
 7642 
 7643 instruct membar_CPUOrder() %{
 7644   match(MemBarCPUOrder);
 7645   ins_cost(0);
 7646 
 7647   format %{ &quot; -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent.&quot; %}
 7648   size(0);
 7649   ins_encode( /*empty*/ );
 7650   ins_pipe(pipe_class_default);
 7651 %}
 7652 
 7653 //----------Conditional Move---------------------------------------------------
 7654 
 7655 // Cmove using isel.
 7656 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7657   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7658   predicate(VM_Version::has_isel());
 7659   ins_cost(DEFAULT_COST);
 7660 
 7661   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7662   size(4);
 7663   ins_encode %{
 7664     // This is a Power7 instruction for which no machine description
 7665     // exists. Anyways, the scheduler should be off on Power7.
 7666     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7667     int cc        = $cmp$$cmpcode;
 7668     __ isel($dst$$Register, $crx$$CondRegister,
 7669             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7670   %}
 7671   ins_pipe(pipe_class_default);
 7672 %}
 7673 
 7674 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7675   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7676   predicate(!VM_Version::has_isel());
 7677   ins_cost(DEFAULT_COST+BRANCH_COST);
 7678 
 7679   ins_variable_size_depending_on_alignment(true);
 7680 
 7681   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7682   // Worst case is branch + move + stop, no stop without scheduler
 7683   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7684   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7685   ins_pipe(pipe_class_default);
 7686 %}
 7687 
 7688 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
 7689   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7690   ins_cost(DEFAULT_COST+BRANCH_COST);
 7691 
 7692   ins_variable_size_depending_on_alignment(true);
 7693 
 7694   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7695   // Worst case is branch + move + stop, no stop without scheduler
 7696   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7697   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7698   ins_pipe(pipe_class_default);
 7699 %}
 7700 
 7701 // Cmove using isel.
 7702 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7703   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7704   predicate(VM_Version::has_isel());
 7705   ins_cost(DEFAULT_COST);
 7706 
 7707   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7708   size(4);
 7709   ins_encode %{
 7710     // This is a Power7 instruction for which no machine description
 7711     // exists. Anyways, the scheduler should be off on Power7.
 7712     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7713     int cc        = $cmp$$cmpcode;
 7714     __ isel($dst$$Register, $crx$$CondRegister,
 7715             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7716   %}
 7717   ins_pipe(pipe_class_default);
 7718 %}
 7719 
 7720 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7721   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7722   predicate(!VM_Version::has_isel());
 7723   ins_cost(DEFAULT_COST+BRANCH_COST);
 7724 
 7725   ins_variable_size_depending_on_alignment(true);
 7726 
 7727   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7728   // Worst case is branch + move + stop, no stop without scheduler.
 7729   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7730   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7731   ins_pipe(pipe_class_default);
 7732 %}
 7733 
 7734 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
 7735   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7736   ins_cost(DEFAULT_COST+BRANCH_COST);
 7737 
 7738   ins_variable_size_depending_on_alignment(true);
 7739 
 7740   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7741   // Worst case is branch + move + stop, no stop without scheduler.
 7742   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7743   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7744   ins_pipe(pipe_class_default);
 7745 %}
 7746 
 7747 // Cmove using isel.
 7748 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7749   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7750   predicate(VM_Version::has_isel());
 7751   ins_cost(DEFAULT_COST);
 7752 
 7753   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7754   size(4);
 7755   ins_encode %{
 7756     // This is a Power7 instruction for which no machine description
 7757     // exists. Anyways, the scheduler should be off on Power7.
 7758     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7759     int cc        = $cmp$$cmpcode;
 7760     __ isel($dst$$Register, $crx$$CondRegister,
 7761             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7762   %}
 7763   ins_pipe(pipe_class_default);
 7764 %}
 7765 
 7766 // Conditional move for RegN. Only cmov(reg, reg).
 7767 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7768   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7769   predicate(!VM_Version::has_isel());
 7770   ins_cost(DEFAULT_COST+BRANCH_COST);
 7771 
 7772   ins_variable_size_depending_on_alignment(true);
 7773 
 7774   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7775   // Worst case is branch + move + stop, no stop without scheduler.
 7776   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7777   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7778   ins_pipe(pipe_class_default);
 7779 %}
 7780 
 7781 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
 7782   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7783   ins_cost(DEFAULT_COST+BRANCH_COST);
 7784 
 7785   ins_variable_size_depending_on_alignment(true);
 7786 
 7787   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7788   // Worst case is branch + move + stop, no stop without scheduler.
 7789   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7790   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7791   ins_pipe(pipe_class_default);
 7792 %}
 7793 
 7794 // Cmove using isel.
 7795 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
 7796   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7797   predicate(VM_Version::has_isel());
 7798   ins_cost(DEFAULT_COST);
 7799 
 7800   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7801   size(4);
 7802   ins_encode %{
 7803     // This is a Power7 instruction for which no machine description
 7804     // exists. Anyways, the scheduler should be off on Power7.
 7805     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7806     int cc        = $cmp$$cmpcode;
 7807     __ isel($dst$$Register, $crx$$CondRegister,
 7808             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7809   %}
 7810   ins_pipe(pipe_class_default);
 7811 %}
 7812 
 7813 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
 7814   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7815   predicate(!VM_Version::has_isel());
 7816   ins_cost(DEFAULT_COST+BRANCH_COST);
 7817 
 7818   ins_variable_size_depending_on_alignment(true);
 7819 
 7820   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7821   // Worst case is branch + move + stop, no stop without scheduler.
 7822   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7823   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7824   ins_pipe(pipe_class_default);
 7825 %}
 7826 
 7827 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
 7828   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7829   ins_cost(DEFAULT_COST+BRANCH_COST);
 7830 
 7831   ins_variable_size_depending_on_alignment(true);
 7832 
 7833   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7834   // Worst case is branch + move + stop, no stop without scheduler.
 7835   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7836   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7837   ins_pipe(pipe_class_default);
 7838 %}
 7839 
 7840 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
 7841   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
 7842   ins_cost(DEFAULT_COST+BRANCH_COST);
 7843 
 7844   ins_variable_size_depending_on_alignment(true);
 7845 
 7846   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7847   // Worst case is branch + move + stop, no stop without scheduler.
 7848   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7849   ins_encode %{
 7850     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7851     Label done;
 7852     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7853     // Branch if not (cmp crx).
 7854     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7855     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7856     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7857     __ bind(done);
 7858   %}
 7859   ins_pipe(pipe_class_default);
 7860 %}
 7861 
 7862 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
 7863   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
 7864   ins_cost(DEFAULT_COST+BRANCH_COST);
 7865 
 7866   ins_variable_size_depending_on_alignment(true);
 7867 
 7868   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7869   // Worst case is branch + move + stop, no stop without scheduler.
 7870   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7871   ins_encode %{
 7872     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7873     Label done;
 7874     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7875     // Branch if not (cmp crx).
 7876     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7877     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7878     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7879     __ bind(done);
 7880   %}
 7881   ins_pipe(pipe_class_default);
 7882 %}
 7883 
 7884 //----------Conditional_store--------------------------------------------------
 7885 // Conditional-store of the updated heap-top.
 7886 // Used during allocation of the shared heap.
 7887 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
 7888 
 7889 // As compareAndSwapL, but return flag register instead of boolean value in
 7890 // int register.
 7891 // Used by sun/misc/AtomicLongCSImpl.java.
 7892 // Mem_ptr must be a memory operand, else this node does not get
 7893 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7894 // can be rematerialized which leads to errors.
 7895 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
 7896   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
 7897   effect(TEMP cr0);
 7898   format %{ &quot;CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7899   ins_encode %{
 7900     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7901     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
 7902                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7903                 noreg, NULL, true);
 7904   %}
 7905   ins_pipe(pipe_class_default);
 7906 %}
 7907 
 7908 // As compareAndSwapP, but return flag register instead of boolean value in
 7909 // int register.
 7910 // This instruction is matched if UseTLAB is off.
 7911 // Mem_ptr must be a memory operand, else this node does not get
 7912 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7913 // can be rematerialized which leads to errors.
 7914 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
 7915   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
 7916   ins_cost(2*MEMORY_REF_COST);
 7917 
 7918   format %{ &quot;STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7919   ins_encode %{
 7920     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
 7921     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
 7922   %}
 7923   ins_pipe(pipe_class_memory);
 7924 %}
 7925 
 7926 // Implement LoadPLocked. Must be ordered against changes of the memory location
 7927 // by storePConditional.
 7928 // Don&#39;t know whether this is ever used.
 7929 instruct loadPLocked(iRegPdst dst, memory mem) %{
 7930   match(Set dst (LoadPLocked mem));
 7931   ins_cost(2*MEMORY_REF_COST);
 7932 
 7933   format %{ &quot;LDARX   $dst, $mem \t// loadPLocked\n\t&quot; %}
 7934   size(4);
 7935   ins_encode %{
 7936     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
 7937     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 7938   %}
 7939   ins_pipe(pipe_class_memory);
 7940 %}
 7941 
 7942 //----------Compare-And-Swap---------------------------------------------------
 7943 
 7944 // CompareAndSwap{P,I,L} have more than one output, therefore &quot;CmpI
 7945 // (CompareAndSwap ...)&quot; or &quot;If (CmpI (CompareAndSwap ..))&quot;  cannot be
 7946 // matched.
 7947 
 7948 // Strong versions:
 7949 
 7950 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7951   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7952   predicate(VM_Version::has_lqarx());
 7953   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7954   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7955   ins_encode %{
 7956     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7957     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7958     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7959                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7960                 $res$$Register, true);
 7961     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7962       __ isync();
 7963     } else {
 7964       __ sync();
 7965     }
 7966   %}
 7967   ins_pipe(pipe_class_default);
 7968 %}
 7969 
 7970 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 7971   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7972   predicate(!VM_Version::has_lqarx());
 7973   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 7974   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7975   ins_encode %{
 7976     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7977     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7978     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 7979                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7980                 $res$$Register, true);
 7981     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7982       __ isync();
 7983     } else {
 7984       __ sync();
 7985     }
 7986   %}
 7987   ins_pipe(pipe_class_default);
 7988 %}
 7989 
 7990 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7991   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 7992   predicate(VM_Version::has_lqarx());
 7993   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7994   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7995   ins_encode %{
 7996     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7997     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7998     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7999                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8000                 $res$$Register, true);
 8001     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8002       __ isync();
 8003     } else {
 8004       __ sync();
 8005     }
 8006   %}
 8007   ins_pipe(pipe_class_default);
 8008 %}
 8009 
 8010 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8011   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8012   predicate(!VM_Version::has_lqarx());
 8013   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8014   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8015   ins_encode %{
 8016     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8017     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8018     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8019                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8020                 $res$$Register, true);
 8021     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8022       __ isync();
 8023     } else {
 8024       __ sync();
 8025     }
 8026   %}
 8027   ins_pipe(pipe_class_default);
 8028 %}
 8029 
 8030 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8031   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
 8032   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8033   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8034   ins_encode %{
 8035     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8036     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8037     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8038                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8039                 $res$$Register, true);
 8040     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8041       __ isync();
 8042     } else {
 8043       __ sync();
 8044     }
 8045   %}
 8046   ins_pipe(pipe_class_default);
 8047 %}
 8048 
 8049 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8050   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
 8051   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8052   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8053   ins_encode %{
 8054     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8055     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8056     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8057                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8058                 $res$$Register, true);
 8059     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8060       __ isync();
 8061     } else {
 8062       __ sync();
 8063     }
 8064   %}
 8065   ins_pipe(pipe_class_default);
 8066 %}
 8067 
 8068 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8069   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
 8070   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8071   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8072   ins_encode %{
 8073     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8074     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8075     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8076                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8077                 $res$$Register, NULL, true);
 8078     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8079       __ isync();
 8080     } else {
 8081       __ sync();
 8082     }
 8083   %}
 8084   ins_pipe(pipe_class_default);
 8085 %}
 8086 
 8087 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8088   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
 8089   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8090   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8091   ins_encode %{
 8092     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8093     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8094     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8095                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8096                 $res$$Register, NULL, true);
 8097     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8098       __ isync();
 8099     } else {
 8100       __ sync();
 8101     }
 8102   %}
 8103   ins_pipe(pipe_class_default);
 8104 %}
 8105 
 8106 // Weak versions:
 8107 
 8108 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8109   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8110   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8111   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8112   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8113   ins_encode %{
 8114     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8115     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8116     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8117                 MacroAssembler::MemBarNone,
 8118                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8119   %}
 8120   ins_pipe(pipe_class_default);
 8121 %}
 8122 
 8123 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8124   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8125   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8126   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8127   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8128   ins_encode %{
 8129     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8130     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8131     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8132                 MacroAssembler::MemBarNone,
 8133                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8134   %}
 8135   ins_pipe(pipe_class_default);
 8136 %}
 8137 
 8138 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8139   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8140   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8141   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8142   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8143   ins_encode %{
 8144     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8145     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8146     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8147                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8148                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8149   %}
 8150   ins_pipe(pipe_class_default);
 8151 %}
 8152 
 8153 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8154   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8155   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8156   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8157   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8158   ins_encode %{
 8159     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8160     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8161     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8162                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8163                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8164   %}
 8165   ins_pipe(pipe_class_default);
 8166 %}
 8167 
 8168 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8169   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8170   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8171   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8172   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8173   ins_encode %{
 8174     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8175     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8176     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8177                 MacroAssembler::MemBarNone,
 8178                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8179   %}
 8180   ins_pipe(pipe_class_default);
 8181 %}
 8182 
 8183 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8184   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8185   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8186   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8187   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8188   ins_encode %{
 8189     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8190     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8191     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8192                 MacroAssembler::MemBarNone,
 8193                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8194   %}
 8195   ins_pipe(pipe_class_default);
 8196 %}
 8197 
 8198 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8199   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8200   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8201   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8202   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8203   ins_encode %{
 8204     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8205     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8206     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8207                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8208                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8209   %}
 8210   ins_pipe(pipe_class_default);
 8211 %}
 8212 
 8213 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8214   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8215   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8216   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8217   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8218   ins_encode %{
 8219     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8220     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8221     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8222                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8223                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8224   %}
 8225   ins_pipe(pipe_class_default);
 8226 %}
 8227 
 8228 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8229   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8230   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8231   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8232   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8233   ins_encode %{
 8234     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8235     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8236     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8237                 MacroAssembler::MemBarNone,
 8238                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8239   %}
 8240   ins_pipe(pipe_class_default);
 8241 %}
 8242 
 8243 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8244   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8245   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8246   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8247   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8248   ins_encode %{
 8249     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8250     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8251     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8252     // value is never passed to caller.
 8253     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8254                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8255                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8256   %}
 8257   ins_pipe(pipe_class_default);
 8258 %}
 8259 
 8260 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8261   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8262   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8263   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8264   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8265   ins_encode %{
 8266     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8267     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8268     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8269                 MacroAssembler::MemBarNone,
 8270                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8271   %}
 8272   ins_pipe(pipe_class_default);
 8273 %}
 8274 
 8275 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8276   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8277   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8278   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8279   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8280   ins_encode %{
 8281     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8282     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8283     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8284     // value is never passed to caller.
 8285     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8286                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8287                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8288   %}
 8289   ins_pipe(pipe_class_default);
 8290 %}
 8291 
 8292 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8293   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8294   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8295   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8296   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8297   ins_encode %{
 8298     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8299     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8300     // value is never passed to caller.
 8301     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8302                 MacroAssembler::MemBarNone,
 8303                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8304   %}
 8305   ins_pipe(pipe_class_default);
 8306 %}
 8307 
 8308 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8309   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8310   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8311   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8312   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8313   ins_encode %{
 8314     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8315     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8316     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8317     // value is never passed to caller.
 8318     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8319                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8320                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8321   %}
 8322   ins_pipe(pipe_class_default);
 8323 %}
 8324 
 8325 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8326   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8327   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8328   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8329   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8330   ins_encode %{
 8331     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8332     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8333     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8334                 MacroAssembler::MemBarNone,
 8335                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8336   %}
 8337   ins_pipe(pipe_class_default);
 8338 %}
 8339 
 8340 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8341   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8342   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8343   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8344   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8345   ins_encode %{
 8346     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8347     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8348     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8349     // value is never passed to caller.
 8350     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8351                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8352                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8353   %}
 8354   ins_pipe(pipe_class_default);
 8355 %}
 8356 
 8357 // CompareAndExchange
 8358 
 8359 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8360   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8361   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8362   effect(TEMP_DEF res, TEMP cr0);
 8363   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8364   ins_encode %{
 8365     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8366     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8367     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8368                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8369                 noreg, true);
 8370   %}
 8371   ins_pipe(pipe_class_default);
 8372 %}
 8373 
 8374 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8375   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8376   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8377   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8378   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8379   ins_encode %{
 8380     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8381     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8382     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8383                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8384                 noreg, true);
 8385   %}
 8386   ins_pipe(pipe_class_default);
 8387 %}
 8388 
 8389 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8390   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8391   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8392   effect(TEMP_DEF res, TEMP cr0);
 8393   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8394   ins_encode %{
 8395     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8396     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8397     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8398                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8399                 noreg, true);
 8400     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8401       __ isync();
 8402     } else {
 8403       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8404       __ sync();
 8405     }
 8406   %}
 8407   ins_pipe(pipe_class_default);
 8408 %}
 8409 
 8410 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8411   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8412   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8413   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8414   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8415   ins_encode %{
 8416     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8417     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8418     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8419                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8420                 noreg, true);
 8421     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8422       __ isync();
 8423     } else {
 8424       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8425       __ sync();
 8426     }
 8427   %}
 8428   ins_pipe(pipe_class_default);
 8429 %}
 8430 
 8431 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8432   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8433   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8434   effect(TEMP_DEF res, TEMP cr0);
 8435   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8436   ins_encode %{
 8437     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8438     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8439     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8440                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8441                 noreg, true);
 8442   %}
 8443   ins_pipe(pipe_class_default);
 8444 %}
 8445 
 8446 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8447   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8448   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8449   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8450   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8451   ins_encode %{
 8452     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8453     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8454     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8455                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8456                 noreg, true);
 8457   %}
 8458   ins_pipe(pipe_class_default);
 8459 %}
 8460 
 8461 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8462   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8463   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8464   effect(TEMP_DEF res, TEMP cr0);
 8465   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8466   ins_encode %{
 8467     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8468     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8469     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8470                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8471                 noreg, true);
 8472     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8473       __ isync();
 8474     } else {
 8475       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8476       __ sync();
 8477     }
 8478   %}
 8479   ins_pipe(pipe_class_default);
 8480 %}
 8481 
 8482 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8483   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8484   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8485   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8486   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8487   ins_encode %{
 8488     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8489     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8490     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8491                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8492                 noreg, true);
 8493     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8494       __ isync();
 8495     } else {
 8496       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8497       __ sync();
 8498     }
 8499   %}
 8500   ins_pipe(pipe_class_default);
 8501 %}
 8502 
 8503 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8504   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8505   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8506   effect(TEMP_DEF res, TEMP cr0);
 8507   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8508   ins_encode %{
 8509     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8510     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8511     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8512                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8513                 noreg, true);
 8514   %}
 8515   ins_pipe(pipe_class_default);
 8516 %}
 8517 
 8518 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8519   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8520   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8521   effect(TEMP_DEF res, TEMP cr0);
 8522   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8523   ins_encode %{
 8524     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8525     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8526     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8527                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8528                 noreg, true);
 8529     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8530       __ isync();
 8531     } else {
 8532       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8533       __ sync();
 8534     }
 8535   %}
 8536   ins_pipe(pipe_class_default);
 8537 %}
 8538 
 8539 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8540   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8541   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8542   effect(TEMP_DEF res, TEMP cr0);
 8543   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8544   ins_encode %{
 8545     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8546     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8547     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8548                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8549                 noreg, true);
 8550   %}
 8551   ins_pipe(pipe_class_default);
 8552 %}
 8553 
 8554 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8555   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8556   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8557   effect(TEMP_DEF res, TEMP cr0);
 8558   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8559   ins_encode %{
 8560     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8561     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8562     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8563                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8564                 noreg, true);
 8565     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8566       __ isync();
 8567     } else {
 8568       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8569       __ sync();
 8570     }
 8571   %}
 8572   ins_pipe(pipe_class_default);
 8573 %}
 8574 
 8575 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8576   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8577   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8578   effect(TEMP_DEF res, TEMP cr0);
 8579   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8580   ins_encode %{
 8581     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8582     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8583     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8584                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8585                 noreg, NULL, true);
 8586   %}
 8587   ins_pipe(pipe_class_default);
 8588 %}
 8589 
 8590 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8591   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8592   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8593   effect(TEMP_DEF res, TEMP cr0);
 8594   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8595   ins_encode %{
 8596     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8597     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8598     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8599                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8600                 noreg, NULL, true);
 8601     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8602       __ isync();
 8603     } else {
 8604       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8605       __ sync();
 8606     }
 8607   %}
 8608   ins_pipe(pipe_class_default);
 8609 %}
 8610 
 8611 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8612   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8613   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8614   effect(TEMP_DEF res, TEMP cr0);
 8615   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8616   ins_encode %{
 8617     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8618     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8619     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8620                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8621                 noreg, NULL, true);
 8622   %}
 8623   ins_pipe(pipe_class_default);
 8624 %}
 8625 
 8626 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8627   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8628   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8629   effect(TEMP_DEF res, TEMP cr0);
 8630   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8631   ins_encode %{
 8632     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8633     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8634     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8635                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8636                 noreg, NULL, true);
 8637     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8638       __ isync();
 8639     } else {
 8640       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8641       __ sync();
 8642     }
 8643   %}
 8644   ins_pipe(pipe_class_default);
 8645 %}
 8646 
 8647 // Special RMW
 8648 
 8649 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8650   match(Set res (GetAndAddB mem_ptr src));
 8651   predicate(VM_Version::has_lqarx());
 8652   effect(TEMP_DEF res, TEMP cr0);
 8653   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8654   ins_encode %{
 8655     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8656                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8657     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8658       __ isync();
 8659     } else {
 8660       __ sync();
 8661     }
 8662   %}
 8663   ins_pipe(pipe_class_default);
 8664 %}
 8665 
 8666 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8667   match(Set res (GetAndAddB mem_ptr src));
 8668   predicate(!VM_Version::has_lqarx());
 8669   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8670   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8671   ins_encode %{
 8672     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8673                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8674     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8675       __ isync();
 8676     } else {
 8677       __ sync();
 8678     }
 8679   %}
 8680   ins_pipe(pipe_class_default);
 8681 %}
 8682 
 8683 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8684   match(Set res (GetAndAddS mem_ptr src));
 8685   predicate(VM_Version::has_lqarx());
 8686   effect(TEMP_DEF res, TEMP cr0);
 8687   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8688   ins_encode %{
 8689     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8690                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8691     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8692       __ isync();
 8693     } else {
 8694       __ sync();
 8695     }
 8696   %}
 8697   ins_pipe(pipe_class_default);
 8698 %}
 8699 
 8700 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8701   match(Set res (GetAndAddS mem_ptr src));
 8702   predicate(!VM_Version::has_lqarx());
 8703   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8704   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8705   ins_encode %{
 8706     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8707                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8708     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8709       __ isync();
 8710     } else {
 8711       __ sync();
 8712     }
 8713   %}
 8714   ins_pipe(pipe_class_default);
 8715 %}
 8716 
 8717 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8718   match(Set res (GetAndAddI mem_ptr src));
 8719   effect(TEMP_DEF res, TEMP cr0);
 8720   format %{ &quot;GetAndAddI $res, $mem_ptr, $src&quot; %}
 8721   ins_encode %{
 8722     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8723                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8724     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8725       __ isync();
 8726     } else {
 8727       __ sync();
 8728     }
 8729   %}
 8730   ins_pipe(pipe_class_default);
 8731 %}
 8732 
 8733 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8734   match(Set res (GetAndAddL mem_ptr src));
 8735   effect(TEMP_DEF res, TEMP cr0);
 8736   format %{ &quot;GetAndAddL $res, $mem_ptr, $src&quot; %}
 8737   ins_encode %{
 8738     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8739                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8740     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8741       __ isync();
 8742     } else {
 8743       __ sync();
 8744     }
 8745   %}
 8746   ins_pipe(pipe_class_default);
 8747 %}
 8748 
 8749 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8750   match(Set res (GetAndSetB mem_ptr src));
 8751   predicate(VM_Version::has_lqarx());
 8752   effect(TEMP_DEF res, TEMP cr0);
 8753   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8754   ins_encode %{
 8755     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8756                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8757     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8758       __ isync();
 8759     } else {
 8760       __ sync();
 8761     }
 8762   %}
 8763   ins_pipe(pipe_class_default);
 8764 %}
 8765 
 8766 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8767   match(Set res (GetAndSetB mem_ptr src));
 8768   predicate(!VM_Version::has_lqarx());
 8769   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8770   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8771   ins_encode %{
 8772     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8773                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8774     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8775       __ isync();
 8776     } else {
 8777       __ sync();
 8778     }
 8779   %}
 8780   ins_pipe(pipe_class_default);
 8781 %}
 8782 
 8783 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8784   match(Set res (GetAndSetS mem_ptr src));
 8785   predicate(VM_Version::has_lqarx());
 8786   effect(TEMP_DEF res, TEMP cr0);
 8787   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8788   ins_encode %{
 8789     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8790                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8791     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8792       __ isync();
 8793     } else {
 8794       __ sync();
 8795     }
 8796   %}
 8797   ins_pipe(pipe_class_default);
 8798 %}
 8799 
 8800 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8801   match(Set res (GetAndSetS mem_ptr src));
 8802   predicate(!VM_Version::has_lqarx());
 8803   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8804   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8805   ins_encode %{
 8806     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8807                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8808     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8809       __ isync();
 8810     } else {
 8811       __ sync();
 8812     }
 8813   %}
 8814   ins_pipe(pipe_class_default);
 8815 %}
 8816 
 8817 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8818   match(Set res (GetAndSetI mem_ptr src));
 8819   effect(TEMP_DEF res, TEMP cr0);
 8820   format %{ &quot;GetAndSetI $res, $mem_ptr, $src&quot; %}
 8821   ins_encode %{
 8822     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8823                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8824     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8825       __ isync();
 8826     } else {
 8827       __ sync();
 8828     }
 8829   %}
 8830   ins_pipe(pipe_class_default);
 8831 %}
 8832 
 8833 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8834   match(Set res (GetAndSetL mem_ptr src));
 8835   effect(TEMP_DEF res, TEMP cr0);
 8836   format %{ &quot;GetAndSetL $res, $mem_ptr, $src&quot; %}
 8837   ins_encode %{
 8838     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8839                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8840     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8841       __ isync();
 8842     } else {
 8843       __ sync();
 8844     }
 8845   %}
 8846   ins_pipe(pipe_class_default);
 8847 %}
 8848 
 8849 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
 8850   match(Set res (GetAndSetP mem_ptr src));
 8851   effect(TEMP_DEF res, TEMP cr0);
 8852   format %{ &quot;GetAndSetP $res, $mem_ptr, $src&quot; %}
 8853   ins_encode %{
 8854     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8855                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8856     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8857       __ isync();
 8858     } else {
 8859       __ sync();
 8860     }
 8861   %}
 8862   ins_pipe(pipe_class_default);
 8863 %}
 8864 
 8865 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
 8866   match(Set res (GetAndSetN mem_ptr src));
 8867   effect(TEMP_DEF res, TEMP cr0);
 8868   format %{ &quot;GetAndSetN $res, $mem_ptr, $src&quot; %}
 8869   ins_encode %{
 8870     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8871                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8872     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8873       __ isync();
 8874     } else {
 8875       __ sync();
 8876     }
 8877   %}
 8878   ins_pipe(pipe_class_default);
 8879 %}
 8880 
 8881 //----------Arithmetic Instructions--------------------------------------------
 8882 // Addition Instructions
 8883 
 8884 // Register Addition
 8885 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
 8886   match(Set dst (AddI src1 src2));
 8887   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8888   size(4);
 8889   ins_encode %{
 8890     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8891     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8892   %}
 8893   ins_pipe(pipe_class_default);
 8894 %}
 8895 
 8896 // Expand does not work with above instruct. (??)
 8897 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 8898   // no match-rule
 8899   effect(DEF dst, USE src1, USE src2);
 8900   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8901   size(4);
 8902   ins_encode %{
 8903     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8904     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8905   %}
 8906   ins_pipe(pipe_class_default);
 8907 %}
 8908 
 8909 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
 8910   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
 8911   ins_cost(DEFAULT_COST*3);
 8912 
 8913   expand %{
 8914     // FIXME: we should do this in the ideal world.
 8915     iRegIdst tmp1;
 8916     iRegIdst tmp2;
 8917     addI_reg_reg(tmp1, src1, src2);
 8918     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
 8919     addI_reg_reg(dst, tmp1, tmp2);
 8920   %}
 8921 %}
 8922 
 8923 // Immediate Addition
 8924 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 8925   match(Set dst (AddI src1 src2));
 8926   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 8927   size(4);
 8928   ins_encode %{
 8929     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 8930     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 8931   %}
 8932   ins_pipe(pipe_class_default);
 8933 %}
 8934 
 8935 // Immediate Addition with 16-bit shifted operand
 8936 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
 8937   match(Set dst (AddI src1 src2));
 8938   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 8939   size(4);
 8940   ins_encode %{
 8941     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 8942     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 8943   %}
 8944   ins_pipe(pipe_class_default);
 8945 %}
 8946 
 8947 // Long Addition
 8948 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8949   match(Set dst (AddL src1 src2));
 8950   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8951   size(4);
 8952   ins_encode %{
 8953     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8954     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8955   %}
 8956   ins_pipe(pipe_class_default);
 8957 %}
 8958 
 8959 // Expand does not work with above instruct. (??)
 8960 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8961   // no match-rule
 8962   effect(DEF dst, USE src1, USE src2);
 8963   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8964   size(4);
 8965   ins_encode %{
 8966     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8967     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8968   %}
 8969   ins_pipe(pipe_class_default);
 8970 %}
 8971 
 8972 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
 8973   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
 8974   ins_cost(DEFAULT_COST*3);
 8975 
 8976   expand %{
 8977     // FIXME: we should do this in the ideal world.
 8978     iRegLdst tmp1;
 8979     iRegLdst tmp2;
 8980     addL_reg_reg(tmp1, src1, src2);
 8981     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
 8982     addL_reg_reg(dst, tmp1, tmp2);
 8983   %}
 8984 %}
 8985 
 8986 // AddL + ConvL2I.
 8987 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8988   match(Set dst (ConvL2I (AddL src1 src2)));
 8989 
 8990   format %{ &quot;ADD     $dst, $src1, $src2 \t// long + l2i&quot; %}
 8991   size(4);
 8992   ins_encode %{
 8993     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8994     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8995   %}
 8996   ins_pipe(pipe_class_default);
 8997 %}
 8998 
 8999 // No constant pool entries required.
 9000 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9001   match(Set dst (AddL src1 src2));
 9002 
 9003   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9004   size(4);
 9005   ins_encode %{
 9006     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9007     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9008   %}
 9009   ins_pipe(pipe_class_default);
 9010 %}
 9011 
 9012 // Long Immediate Addition with 16-bit shifted operand.
 9013 // No constant pool entries required.
 9014 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
 9015   match(Set dst (AddL src1 src2));
 9016 
 9017   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9018   size(4);
 9019   ins_encode %{
 9020     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9021     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9022   %}
 9023   ins_pipe(pipe_class_default);
 9024 %}
 9025 
 9026 // Pointer Register Addition
 9027 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
 9028   match(Set dst (AddP src1 src2));
 9029   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 9030   size(4);
 9031   ins_encode %{
 9032     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9033     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9034   %}
 9035   ins_pipe(pipe_class_default);
 9036 %}
 9037 
 9038 // Pointer Immediate Addition
 9039 // No constant pool entries required.
 9040 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
 9041   match(Set dst (AddP src1 src2));
 9042 
 9043   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9044   size(4);
 9045   ins_encode %{
 9046     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9047     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9048   %}
 9049   ins_pipe(pipe_class_default);
 9050 %}
 9051 
 9052 // Pointer Immediate Addition with 16-bit shifted operand.
 9053 // No constant pool entries required.
 9054 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
 9055   match(Set dst (AddP src1 src2));
 9056 
 9057   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9058   size(4);
 9059   ins_encode %{
 9060     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9061     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9062   %}
 9063   ins_pipe(pipe_class_default);
 9064 %}
 9065 
 9066 //---------------------
 9067 // Subtraction Instructions
 9068 
 9069 // Register Subtraction
 9070 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9071   match(Set dst (SubI src1 src2));
 9072   format %{ &quot;SUBF    $dst, $src2, $src1&quot; %}
 9073   size(4);
 9074   ins_encode %{
 9075     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9076     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9077   %}
 9078   ins_pipe(pipe_class_default);
 9079 %}
 9080 
 9081 // Immediate Subtraction
 9082 // Immediate Subtraction: The compiler converts &quot;x-c0&quot; into &quot;x+ -c0&quot; (see SubLNode::Ideal),
 9083 // Don&#39;t try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
 9084 
 9085 // SubI from constant (using subfic).
 9086 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
 9087   match(Set dst (SubI src1 src2));
 9088   format %{ &quot;SUBI    $dst, $src1, $src2&quot; %}
 9089 
 9090   size(4);
 9091   ins_encode %{
 9092     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
 9093     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
 9094   %}
 9095   ins_pipe(pipe_class_default);
 9096 %}
 9097 
 9098 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
 9099 // positive integers and 0xF...F for negative ones.
 9100 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
 9101   // no match-rule, false predicate
 9102   effect(DEF dst, USE src);
 9103   predicate(false);
 9104 
 9105   format %{ &quot;SRAWI   $dst, $src, #31&quot; %}
 9106   size(4);
 9107   ins_encode %{
 9108     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9109     __ srawi($dst$$Register, $src$$Register, 0x1f);
 9110   %}
 9111   ins_pipe(pipe_class_default);
 9112 %}
 9113 
 9114 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
 9115   match(Set dst (AbsI src));
 9116   ins_cost(DEFAULT_COST*3);
 9117 
 9118   expand %{
 9119     iRegIdst tmp1;
 9120     iRegIdst tmp2;
 9121     signmask32I_regI(tmp1, src);
 9122     xorI_reg_reg(tmp2, tmp1, src);
 9123     subI_reg_reg(dst, tmp2, tmp1);
 9124   %}
 9125 %}
 9126 
 9127 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
 9128   match(Set dst (SubI zero src2));
 9129   format %{ &quot;NEG     $dst, $src2&quot; %}
 9130   size(4);
 9131   ins_encode %{
 9132     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9133     __ neg($dst$$Register, $src2$$Register);
 9134   %}
 9135   ins_pipe(pipe_class_default);
 9136 %}
 9137 
 9138 // Long subtraction
 9139 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9140   match(Set dst (SubL src1 src2));
 9141   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long&quot; %}
 9142   size(4);
 9143   ins_encode %{
 9144     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9145     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9146   %}
 9147   ins_pipe(pipe_class_default);
 9148 %}
 9149 
 9150 // SubL + convL2I.
 9151 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9152   match(Set dst (ConvL2I (SubL src1 src2)));
 9153 
 9154   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long + l2i&quot; %}
 9155   size(4);
 9156   ins_encode %{
 9157     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9158     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9159   %}
 9160   ins_pipe(pipe_class_default);
 9161 %}
 9162 
 9163 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9164 // positive longs and 0xF...F for negative ones.
 9165 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
 9166   // no match-rule, false predicate
 9167   effect(DEF dst, USE src);
 9168   predicate(false);
 9169 
 9170   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9171   size(4);
 9172   ins_encode %{
 9173     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9174     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9175   %}
 9176   ins_pipe(pipe_class_default);
 9177 %}
 9178 
 9179 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9180 // positive longs and 0xF...F for negative ones.
 9181 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
 9182   // no match-rule, false predicate
 9183   effect(DEF dst, USE src);
 9184   predicate(false);
 9185 
 9186   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9187   size(4);
 9188   ins_encode %{
 9189     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9190     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9191   %}
 9192   ins_pipe(pipe_class_default);
 9193 %}
 9194 
 9195 // Long negation
 9196 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
 9197   match(Set dst (SubL zero src2));
 9198   format %{ &quot;NEG     $dst, $src2 \t// long&quot; %}
 9199   size(4);
 9200   ins_encode %{
 9201     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9202     __ neg($dst$$Register, $src2$$Register);
 9203   %}
 9204   ins_pipe(pipe_class_default);
 9205 %}
 9206 
 9207 // NegL + ConvL2I.
 9208 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
 9209   match(Set dst (ConvL2I (SubL zero src2)));
 9210 
 9211   format %{ &quot;NEG     $dst, $src2 \t// long + l2i&quot; %}
 9212   size(4);
 9213   ins_encode %{
 9214     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9215     __ neg($dst$$Register, $src2$$Register);
 9216   %}
 9217   ins_pipe(pipe_class_default);
 9218 %}
 9219 
 9220 // Multiplication Instructions
 9221 // Integer Multiplication
 9222 
 9223 // Register Multiplication
 9224 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9225   match(Set dst (MulI src1 src2));
 9226   ins_cost(DEFAULT_COST);
 9227 
 9228   format %{ &quot;MULLW   $dst, $src1, $src2&quot; %}
 9229   size(4);
 9230   ins_encode %{
 9231     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
 9232     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
 9233   %}
 9234   ins_pipe(pipe_class_default);
 9235 %}
 9236 
 9237 // Immediate Multiplication
 9238 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 9239   match(Set dst (MulI src1 src2));
 9240   ins_cost(DEFAULT_COST);
 9241 
 9242   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9243   size(4);
 9244   ins_encode %{
 9245     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9246     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9247   %}
 9248   ins_pipe(pipe_class_default);
 9249 %}
 9250 
 9251 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9252   match(Set dst (MulL src1 src2));
 9253   ins_cost(DEFAULT_COST);
 9254 
 9255   format %{ &quot;MULLD   $dst $src1, $src2 \t// long&quot; %}
 9256   size(4);
 9257   ins_encode %{
 9258     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
 9259     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
 9260   %}
 9261   ins_pipe(pipe_class_default);
 9262 %}
 9263 
 9264 // Multiply high for optimized long division by constant.
 9265 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9266   match(Set dst (MulHiL src1 src2));
 9267   ins_cost(DEFAULT_COST);
 9268 
 9269   format %{ &quot;MULHD   $dst $src1, $src2 \t// long&quot; %}
 9270   size(4);
 9271   ins_encode %{
 9272     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
 9273     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
 9274   %}
 9275   ins_pipe(pipe_class_default);
 9276 %}
 9277 
 9278 // Immediate Multiplication
 9279 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9280   match(Set dst (MulL src1 src2));
 9281   ins_cost(DEFAULT_COST);
 9282 
 9283   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9284   size(4);
 9285   ins_encode %{
 9286     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9287     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9288   %}
 9289   ins_pipe(pipe_class_default);
 9290 %}
 9291 
 9292 // Integer Division with Immediate -1: Negate.
 9293 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
 9294   match(Set dst (DivI src1 src2));
 9295   ins_cost(DEFAULT_COST);
 9296 
 9297   format %{ &quot;NEG     $dst, $src1 \t// /-1&quot; %}
 9298   size(4);
 9299   ins_encode %{
 9300     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9301     __ neg($dst$$Register, $src1$$Register);
 9302   %}
 9303   ins_pipe(pipe_class_default);
 9304 %}
 9305 
 9306 // Integer Division with constant, but not -1.
 9307 // We should be able to improve this by checking the type of src2.
 9308 // It might well be that src2 is known to be positive.
 9309 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9310   match(Set dst (DivI src1 src2));
 9311   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
 9312   ins_cost(2*DEFAULT_COST);
 9313 
 9314   format %{ &quot;DIVW    $dst, $src1, $src2 \t// /not-1&quot; %}
 9315   size(4);
 9316   ins_encode %{
 9317     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
 9318     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
 9319   %}
 9320   ins_pipe(pipe_class_default);
 9321 %}
 9322 
 9323 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
 9324   effect(USE_DEF dst, USE src1, USE crx);
 9325   predicate(false);
 9326 
 9327   ins_variable_size_depending_on_alignment(true);
 9328 
 9329   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9330   // Worst case is branch + move + stop, no stop without scheduler.
 9331   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9332   ins_encode %{
 9333     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9334     Label done;
 9335     __ bne($crx$$CondRegister, done);
 9336     __ neg($dst$$Register, $src1$$Register);
 9337     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9338     __ bind(done);
 9339   %}
 9340   ins_pipe(pipe_class_default);
 9341 %}
 9342 
 9343 // Integer Division with Registers not containing constants.
 9344 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9345   match(Set dst (DivI src1 src2));
 9346   ins_cost(10*DEFAULT_COST);
 9347 
 9348   expand %{
 9349     immI16 imm %{ (int)-1 %}
 9350     flagsReg tmp1;
 9351     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9352     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9353     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9354   %}
 9355 %}
 9356 
 9357 // Long Division with Immediate -1: Negate.
 9358 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
 9359   match(Set dst (DivL src1 src2));
 9360   ins_cost(DEFAULT_COST);
 9361 
 9362   format %{ &quot;NEG     $dst, $src1 \t// /-1, long&quot; %}
 9363   size(4);
 9364   ins_encode %{
 9365     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9366     __ neg($dst$$Register, $src1$$Register);
 9367   %}
 9368   ins_pipe(pipe_class_default);
 9369 %}
 9370 
 9371 // Long Division with constant, but not -1.
 9372 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9373   match(Set dst (DivL src1 src2));
 9374   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
 9375   ins_cost(2*DEFAULT_COST);
 9376 
 9377   format %{ &quot;DIVD    $dst, $src1, $src2 \t// /not-1, long&quot; %}
 9378   size(4);
 9379   ins_encode %{
 9380     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
 9381     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
 9382   %}
 9383   ins_pipe(pipe_class_default);
 9384 %}
 9385 
 9386 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
 9387   effect(USE_DEF dst, USE src1, USE crx);
 9388   predicate(false);
 9389 
 9390   ins_variable_size_depending_on_alignment(true);
 9391 
 9392   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9393   // Worst case is branch + move + stop, no stop without scheduler.
 9394   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9395   ins_encode %{
 9396     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9397     Label done;
 9398     __ bne($crx$$CondRegister, done);
 9399     __ neg($dst$$Register, $src1$$Register);
 9400     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9401     __ bind(done);
 9402   %}
 9403   ins_pipe(pipe_class_default);
 9404 %}
 9405 
 9406 // Long Division with Registers not containing constants.
 9407 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9408   match(Set dst (DivL src1 src2));
 9409   ins_cost(10*DEFAULT_COST);
 9410 
 9411   expand %{
 9412     immL16 imm %{ (int)-1 %}
 9413     flagsReg tmp1;
 9414     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9415     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9416     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9417   %}
 9418 %}
 9419 
 9420 // Integer Remainder with registers.
 9421 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9422   match(Set dst (ModI src1 src2));
 9423   ins_cost(10*DEFAULT_COST);
 9424 
 9425   expand %{
 9426     immI16 imm %{ (int)-1 %}
 9427     flagsReg tmp1;
 9428     iRegIdst tmp2;
 9429     iRegIdst tmp3;
 9430     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
 9431     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
 9432     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
 9433     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
 9434     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
 9435   %}
 9436 %}
 9437 
 9438 // Long Remainder with registers
 9439 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9440   match(Set dst (ModL src1 src2));
 9441   ins_cost(10*DEFAULT_COST);
 9442 
 9443   expand %{
 9444     immL16 imm %{ (int)-1 %}
 9445     flagsReg tmp1;
 9446     iRegLdst tmp2;
 9447     iRegLdst tmp3;
 9448     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
 9449     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
 9450     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
 9451     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
 9452     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
 9453   %}
 9454 %}
 9455 
 9456 // Integer Shift Instructions
 9457 
 9458 // Register Shift Left
 9459 
 9460 // Clear all but the lowest #mask bits.
 9461 // Used to normalize shift amounts in registers.
 9462 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
 9463   // no match-rule, false predicate
 9464   effect(DEF dst, USE src, USE mask);
 9465   predicate(false);
 9466 
 9467   format %{ &quot;MASK    $dst, $src, $mask \t// clear $mask upper bits&quot; %}
 9468   size(4);
 9469   ins_encode %{
 9470     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9471     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
 9472   %}
 9473   ins_pipe(pipe_class_default);
 9474 %}
 9475 
 9476 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9477   // no match-rule, false predicate
 9478   effect(DEF dst, USE src1, USE src2);
 9479   predicate(false);
 9480 
 9481   format %{ &quot;SLW     $dst, $src1, $src2&quot; %}
 9482   size(4);
 9483   ins_encode %{
 9484     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
 9485     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
 9486   %}
 9487   ins_pipe(pipe_class_default);
 9488 %}
 9489 
 9490 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9491   match(Set dst (LShiftI src1 src2));
 9492   ins_cost(DEFAULT_COST*2);
 9493   expand %{
 9494     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9495     iRegIdst tmpI;
 9496     maskI_reg_imm(tmpI, src2, mask);
 9497     lShiftI_reg_reg(dst, src1, tmpI);
 9498   %}
 9499 %}
 9500 
 9501 // Register Shift Left Immediate
 9502 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9503   match(Set dst (LShiftI src1 src2));
 9504 
 9505   format %{ &quot;SLWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9506   size(4);
 9507   ins_encode %{
 9508     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9509     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9510   %}
 9511   ins_pipe(pipe_class_default);
 9512 %}
 9513 
 9514 // AndI with negpow2-constant + LShiftI
 9515 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9516   match(Set dst (LShiftI (AndI src1 src2) src3));
 9517   predicate(UseRotateAndMaskInstructionsPPC64);
 9518 
 9519   format %{ &quot;RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)&quot; %}
 9520   size(4);
 9521   ins_encode %{
 9522     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9523     long src2      = $src2$$constant;
 9524     long src3      = $src3$$constant;
 9525     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9526     if (maskbits &gt;= 32) {
 9527       __ li($dst$$Register, 0); // addi
 9528     } else {
 9529       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
 9530     }
 9531   %}
 9532   ins_pipe(pipe_class_default);
 9533 %}
 9534 
 9535 // RShiftI + AndI with negpow2-constant + LShiftI
 9536 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9537   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
 9538   predicate(UseRotateAndMaskInstructionsPPC64);
 9539 
 9540   format %{ &quot;RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)&quot; %}
 9541   size(4);
 9542   ins_encode %{
 9543     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9544     long src2      = $src2$$constant;
 9545     long src3      = $src3$$constant;
 9546     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9547     if (maskbits &gt;= 32) {
 9548       __ li($dst$$Register, 0); // addi
 9549     } else {
 9550       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
 9551     }
 9552   %}
 9553   ins_pipe(pipe_class_default);
 9554 %}
 9555 
 9556 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9557   // no match-rule, false predicate
 9558   effect(DEF dst, USE src1, USE src2);
 9559   predicate(false);
 9560 
 9561   format %{ &quot;SLD     $dst, $src1, $src2&quot; %}
 9562   size(4);
 9563   ins_encode %{
 9564     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
 9565     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
 9566   %}
 9567   ins_pipe(pipe_class_default);
 9568 %}
 9569 
 9570 // Register Shift Left
 9571 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9572   match(Set dst (LShiftL src1 src2));
 9573   ins_cost(DEFAULT_COST*2);
 9574   expand %{
 9575     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9576     iRegIdst tmpI;
 9577     maskI_reg_imm(tmpI, src2, mask);
 9578     lShiftL_regL_regI(dst, src1, tmpI);
 9579   %}
 9580 %}
 9581 
 9582 // Register Shift Left Immediate
 9583 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9584   match(Set dst (LShiftL src1 src2));
 9585   format %{ &quot;SLDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9586   size(4);
 9587   ins_encode %{
 9588     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9589     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9590   %}
 9591   ins_pipe(pipe_class_default);
 9592 %}
 9593 
 9594 // If we shift more than 32 bits, we need not convert I2L.
 9595 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
 9596   match(Set dst (LShiftL (ConvI2L src1) src2));
 9597   ins_cost(DEFAULT_COST);
 9598 
 9599   size(4);
 9600   format %{ &quot;SLDI    $dst, i2l($src1), $src2&quot; %}
 9601   ins_encode %{
 9602     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9603     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9604   %}
 9605   ins_pipe(pipe_class_default);
 9606 %}
 9607 
 9608 // Shift a postivie int to the left.
 9609 // Clrlsldi clears the upper 32 bits and shifts.
 9610 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
 9611   match(Set dst (LShiftL (ConvI2L src1) src2));
 9612   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
 9613 
 9614   format %{ &quot;SLDI    $dst, i2l(positive_int($src1)), $src2&quot; %}
 9615   size(4);
 9616   ins_encode %{
 9617     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
 9618     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
 9619   %}
 9620   ins_pipe(pipe_class_default);
 9621 %}
 9622 
 9623 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9624   // no match-rule, false predicate
 9625   effect(DEF dst, USE src1, USE src2);
 9626   predicate(false);
 9627 
 9628   format %{ &quot;SRAW    $dst, $src1, $src2&quot; %}
 9629   size(4);
 9630   ins_encode %{
 9631     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
 9632     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
 9633   %}
 9634   ins_pipe(pipe_class_default);
 9635 %}
 9636 
 9637 // Register Arithmetic Shift Right
 9638 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9639   match(Set dst (RShiftI src1 src2));
 9640   ins_cost(DEFAULT_COST*2);
 9641   expand %{
 9642     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9643     iRegIdst tmpI;
 9644     maskI_reg_imm(tmpI, src2, mask);
 9645     arShiftI_reg_reg(dst, src1, tmpI);
 9646   %}
 9647 %}
 9648 
 9649 // Register Arithmetic Shift Right Immediate
 9650 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9651   match(Set dst (RShiftI src1 src2));
 9652 
 9653   format %{ &quot;SRAWI   $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9654   size(4);
 9655   ins_encode %{
 9656     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9657     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9658   %}
 9659   ins_pipe(pipe_class_default);
 9660 %}
 9661 
 9662 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9663   // no match-rule, false predicate
 9664   effect(DEF dst, USE src1, USE src2);
 9665   predicate(false);
 9666 
 9667   format %{ &quot;SRAD    $dst, $src1, $src2&quot; %}
 9668   size(4);
 9669   ins_encode %{
 9670     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
 9671     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
 9672   %}
 9673   ins_pipe(pipe_class_default);
 9674 %}
 9675 
 9676 // Register Shift Right Arithmetic Long
 9677 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9678   match(Set dst (RShiftL src1 src2));
 9679   ins_cost(DEFAULT_COST*2);
 9680 
 9681   expand %{
 9682     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9683     iRegIdst tmpI;
 9684     maskI_reg_imm(tmpI, src2, mask);
 9685     arShiftL_regL_regI(dst, src1, tmpI);
 9686   %}
 9687 %}
 9688 
 9689 // Register Shift Right Immediate
 9690 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9691   match(Set dst (RShiftL src1 src2));
 9692 
 9693   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9694   size(4);
 9695   ins_encode %{
 9696     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9697     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9698   %}
 9699   ins_pipe(pipe_class_default);
 9700 %}
 9701 
 9702 // RShiftL + ConvL2I
 9703 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9704   match(Set dst (ConvL2I (RShiftL src1 src2)));
 9705 
 9706   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9707   size(4);
 9708   ins_encode %{
 9709     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9710     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9711   %}
 9712   ins_pipe(pipe_class_default);
 9713 %}
 9714 
 9715 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9716   // no match-rule, false predicate
 9717   effect(DEF dst, USE src1, USE src2);
 9718   predicate(false);
 9719 
 9720   format %{ &quot;SRW     $dst, $src1, $src2&quot; %}
 9721   size(4);
 9722   ins_encode %{
 9723     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
 9724     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
 9725   %}
 9726   ins_pipe(pipe_class_default);
 9727 %}
 9728 
 9729 // Register Shift Right
 9730 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9731   match(Set dst (URShiftI src1 src2));
 9732   ins_cost(DEFAULT_COST*2);
 9733 
 9734   expand %{
 9735     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9736     iRegIdst tmpI;
 9737     maskI_reg_imm(tmpI, src2, mask);
 9738     urShiftI_reg_reg(dst, src1, tmpI);
 9739   %}
 9740 %}
 9741 
 9742 // Register Shift Right Immediate
 9743 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9744   match(Set dst (URShiftI src1 src2));
 9745 
 9746   format %{ &quot;SRWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9747   size(4);
 9748   ins_encode %{
 9749     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9750     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9751   %}
 9752   ins_pipe(pipe_class_default);
 9753 %}
 9754 
 9755 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9756   // no match-rule, false predicate
 9757   effect(DEF dst, USE src1, USE src2);
 9758   predicate(false);
 9759 
 9760   format %{ &quot;SRD     $dst, $src1, $src2&quot; %}
 9761   size(4);
 9762   ins_encode %{
 9763     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
 9764     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
 9765   %}
 9766   ins_pipe(pipe_class_default);
 9767 %}
 9768 
 9769 // Register Shift Right
 9770 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9771   match(Set dst (URShiftL src1 src2));
 9772   ins_cost(DEFAULT_COST*2);
 9773 
 9774   expand %{
 9775     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9776     iRegIdst tmpI;
 9777     maskI_reg_imm(tmpI, src2, mask);
 9778     urShiftL_regL_regI(dst, src1, tmpI);
 9779   %}
 9780 %}
 9781 
 9782 // Register Shift Right Immediate
 9783 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9784   match(Set dst (URShiftL src1 src2));
 9785 
 9786   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9787   size(4);
 9788   ins_encode %{
 9789     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9790     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9791   %}
 9792   ins_pipe(pipe_class_default);
 9793 %}
 9794 
 9795 // URShiftL + ConvL2I.
 9796 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9797   match(Set dst (ConvL2I (URShiftL src1 src2)));
 9798 
 9799   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9800   size(4);
 9801   ins_encode %{
 9802     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9803     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9804   %}
 9805   ins_pipe(pipe_class_default);
 9806 %}
 9807 
 9808 // Register Shift Right Immediate with a CastP2X
 9809 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
 9810   match(Set dst (URShiftL (CastP2X src1) src2));
 9811 
 9812   format %{ &quot;SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift&quot; %}
 9813   size(4);
 9814   ins_encode %{
 9815     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9816     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9817   %}
 9818   ins_pipe(pipe_class_default);
 9819 %}
 9820 
 9821 // Bitfield Extract: URShiftI + AndI
 9822 instruct andI_urShiftI_regI_immI_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immI src2, immIpow2minus1 src3) %{
 9823   match(Set dst (AndI (URShiftI src1 src2) src3));
 9824 
 9825   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// int bitfield extract&quot; %}
 9826   size(4);
 9827   ins_encode %{
 9828     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9829     int rshift = ($src2$$constant) &amp; 0x1f;
 9830     int length = log2_long(((jlong) $src3$$constant) + 1);
 9831     if (rshift + length &gt; 32) {
 9832       // if necessary, adjust mask to omit rotated bits.
 9833       length = 32 - rshift;
 9834     }
 9835     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9836   %}
 9837   ins_pipe(pipe_class_default);
 9838 %}
 9839 
 9840 // Bitfield Extract: URShiftL + AndL
 9841 instruct andL_urShiftL_regL_immI_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immI src2, immLpow2minus1 src3) %{
 9842   match(Set dst (AndL (URShiftL src1 src2) src3));
 9843 
 9844   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// long bitfield extract&quot; %}
 9845   size(4);
 9846   ins_encode %{
 9847     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9848     int rshift  = ($src2$$constant) &amp; 0x3f;
 9849     int length = log2_long(((jlong) $src3$$constant) + 1);
 9850     if (rshift + length &gt; 64) {
 9851       // if necessary, adjust mask to omit rotated bits.
 9852       length = 64 - rshift;
 9853     }
 9854     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9855   %}
 9856   ins_pipe(pipe_class_default);
 9857 %}
 9858 
 9859 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
 9860   match(Set dst (ConvL2I (ConvI2L src)));
 9861 
 9862   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;int&quot; %}
 9863   size(4);
 9864   ins_encode %{
 9865     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
 9866     __ extsw($dst$$Register, $src$$Register);
 9867   %}
 9868   ins_pipe(pipe_class_default);
 9869 %}
 9870 
 9871 //----------Rotate Instructions------------------------------------------------
 9872 
 9873 // Rotate Left by 8-bit immediate
 9874 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
 9875   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 9876   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9877 
 9878   format %{ &quot;ROTLWI  $dst, $src, $lshift&quot; %}
 9879   size(4);
 9880   ins_encode %{
 9881     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9882     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
 9883   %}
 9884   ins_pipe(pipe_class_default);
 9885 %}
 9886 
 9887 // Rotate Right by 8-bit immediate
 9888 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
 9889   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 9890   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9891 
 9892   format %{ &quot;ROTRWI  $dst, $rshift&quot; %}
 9893   size(4);
 9894   ins_encode %{
 9895     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9896     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
 9897   %}
 9898   ins_pipe(pipe_class_default);
 9899 %}
 9900 
 9901 //----------Floating Point Arithmetic Instructions-----------------------------
 9902 
 9903 // Add float single precision
 9904 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 9905   match(Set dst (AddF src1 src2));
 9906 
 9907   format %{ &quot;FADDS   $dst, $src1, $src2&quot; %}
 9908   size(4);
 9909   ins_encode %{
 9910     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
 9911     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9912   %}
 9913   ins_pipe(pipe_class_default);
 9914 %}
 9915 
 9916 // Add float double precision
 9917 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 9918   match(Set dst (AddD src1 src2));
 9919 
 9920   format %{ &quot;FADD    $dst, $src1, $src2&quot; %}
 9921   size(4);
 9922   ins_encode %{
 9923     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
 9924     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9925   %}
 9926   ins_pipe(pipe_class_default);
 9927 %}
 9928 
 9929 // Sub float single precision
 9930 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 9931   match(Set dst (SubF src1 src2));
 9932 
 9933   format %{ &quot;FSUBS   $dst, $src1, $src2&quot; %}
 9934   size(4);
 9935   ins_encode %{
 9936     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
 9937     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9938   %}
 9939   ins_pipe(pipe_class_default);
 9940 %}
 9941 
 9942 // Sub float double precision
 9943 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 9944   match(Set dst (SubD src1 src2));
 9945   format %{ &quot;FSUB    $dst, $src1, $src2&quot; %}
 9946   size(4);
 9947   ins_encode %{
 9948     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
 9949     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9950   %}
 9951   ins_pipe(pipe_class_default);
 9952 %}
 9953 
 9954 // Mul float single precision
 9955 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 9956   match(Set dst (MulF src1 src2));
 9957   format %{ &quot;FMULS   $dst, $src1, $src2&quot; %}
 9958   size(4);
 9959   ins_encode %{
 9960     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
 9961     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9962   %}
 9963   ins_pipe(pipe_class_default);
 9964 %}
 9965 
 9966 // Mul float double precision
 9967 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 9968   match(Set dst (MulD src1 src2));
 9969   format %{ &quot;FMUL    $dst, $src1, $src2&quot; %}
 9970   size(4);
 9971   ins_encode %{
 9972     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
 9973     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9974   %}
 9975   ins_pipe(pipe_class_default);
 9976 %}
 9977 
 9978 // Div float single precision
 9979 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 9980   match(Set dst (DivF src1 src2));
 9981   format %{ &quot;FDIVS   $dst, $src1, $src2&quot; %}
 9982   size(4);
 9983   ins_encode %{
 9984     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
 9985     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9986   %}
 9987   ins_pipe(pipe_class_default);
 9988 %}
 9989 
 9990 // Div float double precision
 9991 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 9992   match(Set dst (DivD src1 src2));
 9993   format %{ &quot;FDIV    $dst, $src1, $src2&quot; %}
 9994   size(4);
 9995   ins_encode %{
 9996     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
 9997     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9998   %}
 9999   ins_pipe(pipe_class_default);
10000 %}
10001 
10002 // Absolute float single precision
10003 instruct absF_reg(regF dst, regF src) %{
10004   match(Set dst (AbsF src));
10005   format %{ &quot;FABS    $dst, $src \t// float&quot; %}
10006   size(4);
10007   ins_encode %{
10008     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10009     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10010   %}
10011   ins_pipe(pipe_class_default);
10012 %}
10013 
10014 // Absolute float double precision
10015 instruct absD_reg(regD dst, regD src) %{
10016   match(Set dst (AbsD src));
10017   format %{ &quot;FABS    $dst, $src \t// double&quot; %}
10018   size(4);
10019   ins_encode %{
10020     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10021     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10022   %}
10023   ins_pipe(pipe_class_default);
10024 %}
10025 
10026 instruct negF_reg(regF dst, regF src) %{
10027   match(Set dst (NegF src));
10028   format %{ &quot;FNEG    $dst, $src \t// float&quot; %}
10029   size(4);
10030   ins_encode %{
10031     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10032     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10033   %}
10034   ins_pipe(pipe_class_default);
10035 %}
10036 
10037 instruct negD_reg(regD dst, regD src) %{
10038   match(Set dst (NegD src));
10039   format %{ &quot;FNEG    $dst, $src \t// double&quot; %}
10040   size(4);
10041   ins_encode %{
10042     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10043     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10044   %}
10045   ins_pipe(pipe_class_default);
10046 %}
10047 
10048 // AbsF + NegF.
10049 instruct negF_absF_reg(regF dst, regF src) %{
10050   match(Set dst (NegF (AbsF src)));
10051   format %{ &quot;FNABS   $dst, $src \t// float&quot; %}
10052   size(4);
10053   ins_encode %{
10054     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10055     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10056   %}
10057   ins_pipe(pipe_class_default);
10058 %}
10059 
10060 // AbsD + NegD.
10061 instruct negD_absD_reg(regD dst, regD src) %{
10062   match(Set dst (NegD (AbsD src)));
10063   format %{ &quot;FNABS   $dst, $src \t// double&quot; %}
10064   size(4);
10065   ins_encode %{
10066     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10067     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10068   %}
10069   ins_pipe(pipe_class_default);
10070 %}
10071 
10072 // VM_Version::has_fsqrt() decides if this node will be used.
10073 // Sqrt float double precision
10074 instruct sqrtD_reg(regD dst, regD src) %{
10075   match(Set dst (SqrtD src));
10076   format %{ &quot;FSQRT   $dst, $src&quot; %}
10077   size(4);
10078   ins_encode %{
10079     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
10080     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
10081   %}
10082   ins_pipe(pipe_class_default);
10083 %}
10084 
10085 // Single-precision sqrt.
10086 instruct sqrtF_reg(regF dst, regF src) %{
10087   match(Set dst (SqrtF src));
10088   predicate(VM_Version::has_fsqrts());
10089   ins_cost(DEFAULT_COST);
10090 
10091   format %{ &quot;FSQRTS  $dst, $src&quot; %}
10092   size(4);
10093   ins_encode %{
10094     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
10095     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
10096   %}
10097   ins_pipe(pipe_class_default);
10098 %}
10099 
10100 instruct roundDouble_nop(regD dst) %{
10101   match(Set dst (RoundDouble dst));
10102   ins_cost(0);
10103 
10104   format %{ &quot; -- \t// RoundDouble not needed - empty&quot; %}
10105   size(0);
10106   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10107   ins_encode( /*empty*/ );
10108   ins_pipe(pipe_class_default);
10109 %}
10110 
10111 instruct roundFloat_nop(regF dst) %{
10112   match(Set dst (RoundFloat dst));
10113   ins_cost(0);
10114 
10115   format %{ &quot; -- \t// RoundFloat not needed - empty&quot; %}
10116   size(0);
10117   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10118   ins_encode( /*empty*/ );
10119   ins_pipe(pipe_class_default);
10120 %}
10121 
10122 
10123 // Multiply-Accumulate
10124 // src1 * src2 + src3
10125 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10126   match(Set dst (FmaF src3 (Binary src1 src2)));
10127 
10128   format %{ &quot;FMADDS  $dst, $src1, $src2, $src3&quot; %}
10129   size(4);
10130   ins_encode %{
10131     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
10132     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10133   %}
10134   ins_pipe(pipe_class_default);
10135 %}
10136 
10137 // src1 * src2 + src3
10138 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10139   match(Set dst (FmaD src3 (Binary src1 src2)));
10140 
10141   format %{ &quot;FMADD   $dst, $src1, $src2, $src3&quot; %}
10142   size(4);
10143   ins_encode %{
10144     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
10145     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10146   %}
10147   ins_pipe(pipe_class_default);
10148 %}
10149 
10150 // -src1 * src2 + src3 = -(src1*src2-src3)
10151 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10152   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
10153   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
10154 
10155   format %{ &quot;FNMSUBS $dst, $src1, $src2, $src3&quot; %}
10156   size(4);
10157   ins_encode %{
10158     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
10159     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10160   %}
10161   ins_pipe(pipe_class_default);
10162 %}
10163 
10164 // -src1 * src2 + src3 = -(src1*src2-src3)
10165 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10166   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
10167   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
10168 
10169   format %{ &quot;FNMSUB  $dst, $src1, $src2, $src3&quot; %}
10170   size(4);
10171   ins_encode %{
10172     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
10173     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10174   %}
10175   ins_pipe(pipe_class_default);
10176 %}
10177 
10178 // -src1 * src2 - src3 = -(src1*src2+src3)
10179 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10180   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
10181   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
10182 
10183   format %{ &quot;FNMADDS $dst, $src1, $src2, $src3&quot; %}
10184   size(4);
10185   ins_encode %{
10186     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
10187     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10188   %}
10189   ins_pipe(pipe_class_default);
10190 %}
10191 
10192 // -src1 * src2 - src3 = -(src1*src2+src3)
10193 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10194   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
10195   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
10196 
10197   format %{ &quot;FNMADD  $dst, $src1, $src2, $src3&quot; %}
10198   size(4);
10199   ins_encode %{
10200     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
10201     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10202   %}
10203   ins_pipe(pipe_class_default);
10204 %}
10205 
10206 // src1 * src2 - src3
10207 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10208   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
10209 
10210   format %{ &quot;FMSUBS  $dst, $src1, $src2, $src3&quot; %}
10211   size(4);
10212   ins_encode %{
10213     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
10214     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10215   %}
10216   ins_pipe(pipe_class_default);
10217 %}
10218 
10219 // src1 * src2 - src3
10220 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10221   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
10222 
10223   format %{ &quot;FMSUB   $dst, $src1, $src2, $src3&quot; %}
10224   size(4);
10225   ins_encode %{
10226     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
10227     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10228   %}
10229   ins_pipe(pipe_class_default);
10230 %}
10231 
10232 
10233 //----------Logical Instructions-----------------------------------------------
10234 
10235 // And Instructions
10236 
10237 // Register And
10238 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10239   match(Set dst (AndI src1 src2));
10240   format %{ &quot;AND     $dst, $src1, $src2&quot; %}
10241   size(4);
10242   ins_encode %{
10243     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10244     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10245   %}
10246   ins_pipe(pipe_class_default);
10247 %}
10248 
10249 // Left shifted Immediate And
10250 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
10251   match(Set dst (AndI src1 src2));
10252   effect(KILL cr0);
10253   format %{ &quot;ANDIS   $dst, $src1, $src2.hi&quot; %}
10254   size(4);
10255   ins_encode %{
10256     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
10257     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
10258   %}
10259   ins_pipe(pipe_class_default);
10260 %}
10261 
10262 // Immediate And
10263 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
10264   match(Set dst (AndI src1 src2));
10265   effect(KILL cr0);
10266 
10267   format %{ &quot;ANDI    $dst, $src1, $src2&quot; %}
10268   size(4);
10269   ins_encode %{
10270     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10271     // FIXME: avoid andi_ ?
10272     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10273   %}
10274   ins_pipe(pipe_class_default);
10275 %}
10276 
10277 // Immediate And where the immediate is a negative power of 2.
10278 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
10279   match(Set dst (AndI src1 src2));
10280   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10281   size(4);
10282   ins_encode %{
10283     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10284     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
10285   %}
10286   ins_pipe(pipe_class_default);
10287 %}
10288 
10289 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
10290   match(Set dst (AndI src1 src2));
10291   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10292   size(4);
10293   ins_encode %{
10294     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10295     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10296   %}
10297   ins_pipe(pipe_class_default);
10298 %}
10299 
10300 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
10301   match(Set dst (AndI src1 src2));
10302   predicate(UseRotateAndMaskInstructionsPPC64);
10303   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10304   size(4);
10305   ins_encode %{
10306     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10307     __ rlwinm($dst$$Register, $src1$$Register, 0,
10308               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
10309   %}
10310   ins_pipe(pipe_class_default);
10311 %}
10312 
10313 // Register And Long
10314 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10315   match(Set dst (AndL src1 src2));
10316   ins_cost(DEFAULT_COST);
10317 
10318   format %{ &quot;AND     $dst, $src1, $src2 \t// long&quot; %}
10319   size(4);
10320   ins_encode %{
10321     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10322     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10323   %}
10324   ins_pipe(pipe_class_default);
10325 %}
10326 
10327 // Immediate And long
10328 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
10329   match(Set dst (AndL src1 src2));
10330   effect(KILL cr0);
10331 
10332   format %{ &quot;ANDI    $dst, $src1, $src2 \t// long&quot; %}
10333   size(4);
10334   ins_encode %{
10335     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10336     // FIXME: avoid andi_ ?
10337     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10338   %}
10339   ins_pipe(pipe_class_default);
10340 %}
10341 
10342 // Immediate And Long where the immediate is a negative power of 2.
10343 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
10344   match(Set dst (AndL src1 src2));
10345   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10346   size(4);
10347   ins_encode %{
10348     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10349     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
10350   %}
10351   ins_pipe(pipe_class_default);
10352 %}
10353 
10354 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10355   match(Set dst (AndL src1 src2));
10356   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10357   size(4);
10358   ins_encode %{
10359     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10360     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10361   %}
10362   ins_pipe(pipe_class_default);
10363 %}
10364 
10365 // AndL + ConvL2I.
10366 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10367   match(Set dst (ConvL2I (AndL src1 src2)));
10368   ins_cost(DEFAULT_COST);
10369 
10370   format %{ &quot;ANDDI   $dst, $src1, $src2 \t// long + l2i&quot; %}
10371   size(4);
10372   ins_encode %{
10373     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10374     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10375   %}
10376   ins_pipe(pipe_class_default);
10377 %}
10378 
10379 // Or Instructions
10380 
10381 // Register Or
10382 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10383   match(Set dst (OrI src1 src2));
10384   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10385   size(4);
10386   ins_encode %{
10387     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10388     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10389   %}
10390   ins_pipe(pipe_class_default);
10391 %}
10392 
10393 // Expand does not work with above instruct. (??)
10394 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10395   // no match-rule
10396   effect(DEF dst, USE src1, USE src2);
10397   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10398   size(4);
10399   ins_encode %{
10400     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10401     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10402   %}
10403   ins_pipe(pipe_class_default);
10404 %}
10405 
10406 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10407   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
10408   ins_cost(DEFAULT_COST*3);
10409 
10410   expand %{
10411     // FIXME: we should do this in the ideal world.
10412     iRegIdst tmp1;
10413     iRegIdst tmp2;
10414     orI_reg_reg(tmp1, src1, src2);
10415     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
10416     orI_reg_reg(dst, tmp1, tmp2);
10417   %}
10418 %}
10419 
10420 // Immediate Or
10421 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10422   match(Set dst (OrI src1 src2));
10423   format %{ &quot;ORI     $dst, $src1, $src2&quot; %}
10424   size(4);
10425   ins_encode %{
10426     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10427     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
10428   %}
10429   ins_pipe(pipe_class_default);
10430 %}
10431 
10432 // Register Or Long
10433 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10434   match(Set dst (OrL src1 src2));
10435   ins_cost(DEFAULT_COST);
10436 
10437   size(4);
10438   format %{ &quot;OR      $dst, $src1, $src2 \t// long&quot; %}
10439   ins_encode %{
10440     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10441     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10442   %}
10443   ins_pipe(pipe_class_default);
10444 %}
10445 
10446 // OrL + ConvL2I.
10447 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10448   match(Set dst (ConvL2I (OrL src1 src2)));
10449   ins_cost(DEFAULT_COST);
10450 
10451   format %{ &quot;OR      $dst, $src1, $src2 \t// long + l2i&quot; %}
10452   size(4);
10453   ins_encode %{
10454     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10455     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10456   %}
10457   ins_pipe(pipe_class_default);
10458 %}
10459 
10460 // Immediate Or long
10461 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
10462   match(Set dst (OrL src1 con));
10463   ins_cost(DEFAULT_COST);
10464 
10465   format %{ &quot;ORI     $dst, $src1, $con \t// long&quot; %}
10466   size(4);
10467   ins_encode %{
10468     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10469     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
10470   %}
10471   ins_pipe(pipe_class_default);
10472 %}
10473 
10474 // Xor Instructions
10475 
10476 // Register Xor
10477 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10478   match(Set dst (XorI src1 src2));
10479   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10480   size(4);
10481   ins_encode %{
10482     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10483     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10484   %}
10485   ins_pipe(pipe_class_default);
10486 %}
10487 
10488 // Expand does not work with above instruct. (??)
10489 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10490   // no match-rule
10491   effect(DEF dst, USE src1, USE src2);
10492   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10493   size(4);
10494   ins_encode %{
10495     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10496     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10497   %}
10498   ins_pipe(pipe_class_default);
10499 %}
10500 
10501 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10502   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
10503   ins_cost(DEFAULT_COST*3);
10504 
10505   expand %{
10506     // FIXME: we should do this in the ideal world.
10507     iRegIdst tmp1;
10508     iRegIdst tmp2;
10509     xorI_reg_reg(tmp1, src1, src2);
10510     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
10511     xorI_reg_reg(dst, tmp1, tmp2);
10512   %}
10513 %}
10514 
10515 // Immediate Xor
10516 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10517   match(Set dst (XorI src1 src2));
10518   format %{ &quot;XORI    $dst, $src1, $src2&quot; %}
10519   size(4);
10520   ins_encode %{
10521     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10522     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10523   %}
10524   ins_pipe(pipe_class_default);
10525 %}
10526 
10527 // Register Xor Long
10528 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10529   match(Set dst (XorL src1 src2));
10530   ins_cost(DEFAULT_COST);
10531 
10532   format %{ &quot;XOR     $dst, $src1, $src2 \t// long&quot; %}
10533   size(4);
10534   ins_encode %{
10535     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10536     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10537   %}
10538   ins_pipe(pipe_class_default);
10539 %}
10540 
10541 // XorL + ConvL2I.
10542 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10543   match(Set dst (ConvL2I (XorL src1 src2)));
10544   ins_cost(DEFAULT_COST);
10545 
10546   format %{ &quot;XOR     $dst, $src1, $src2 \t// long + l2i&quot; %}
10547   size(4);
10548   ins_encode %{
10549     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10550     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10551   %}
10552   ins_pipe(pipe_class_default);
10553 %}
10554 
10555 // Immediate Xor Long
10556 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10557   match(Set dst (XorL src1 src2));
10558   ins_cost(DEFAULT_COST);
10559 
10560   format %{ &quot;XORI    $dst, $src1, $src2 \t// long&quot; %}
10561   size(4);
10562   ins_encode %{
10563     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10564     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10565   %}
10566   ins_pipe(pipe_class_default);
10567 %}
10568 
10569 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10570   match(Set dst (XorI src1 src2));
10571   ins_cost(DEFAULT_COST);
10572 
10573   format %{ &quot;NOT     $dst, $src1 ($src2)&quot; %}
10574   size(4);
10575   ins_encode %{
10576     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10577     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10578   %}
10579   ins_pipe(pipe_class_default);
10580 %}
10581 
10582 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10583   match(Set dst (XorL src1 src2));
10584   ins_cost(DEFAULT_COST);
10585 
10586   format %{ &quot;NOT     $dst, $src1 ($src2) \t// long&quot; %}
10587   size(4);
10588   ins_encode %{
10589     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10590     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10591   %}
10592   ins_pipe(pipe_class_default);
10593 %}
10594 
10595 // And-complement
10596 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10597   match(Set dst (AndI (XorI src1 src2) src3));
10598   ins_cost(DEFAULT_COST);
10599 
10600   format %{ &quot;ANDW    $dst, xori($src1, $src2), $src3&quot; %}
10601   size(4);
10602   ins_encode( enc_andc(dst, src3, src1) );
10603   ins_pipe(pipe_class_default);
10604 %}
10605 
10606 // And-complement
10607 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10608   // no match-rule, false predicate
10609   effect(DEF dst, USE src1, USE src2);
10610   predicate(false);
10611 
10612   format %{ &quot;ANDC    $dst, $src1, $src2&quot; %}
10613   size(4);
10614   ins_encode %{
10615     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10616     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10617   %}
10618   ins_pipe(pipe_class_default);
10619 %}
10620 
10621 //----------Moves between int/long and float/double----------------------------
10622 //
10623 // The following rules move values from int/long registers/stack-locations
10624 // to float/double registers/stack-locations and vice versa, without doing any
10625 // conversions. These rules are used to implement the bit-conversion methods
10626 // of java.lang.Float etc., e.g.
10627 //   int   floatToIntBits(float value)
10628 //   float intBitsToFloat(int bits)
10629 //
10630 // Notes on the implementation on ppc64:
10631 // For Power7 and earlier, the rules are limited to those which move between a
10632 // register and a stack-location, because we always have to go through memory
10633 // when moving between a float register and an integer register.
10634 // This restriction is removed in Power8 with the introduction of the mtfprd
10635 // and mffprd instructions.
10636 
10637 instruct moveL2D_reg(regD dst, iRegLsrc src) %{
10638   match(Set dst (MoveL2D src));
10639   predicate(VM_Version::has_mtfprd());
10640 
10641   format %{ &quot;MTFPRD  $dst, $src&quot; %}
10642   size(4);
10643   ins_encode %{
10644     __ mtfprd($dst$$FloatRegister, $src$$Register);
10645   %}
10646   ins_pipe(pipe_class_default);
10647 %}
10648 
10649 instruct moveI2D_reg(regD dst, iRegIsrc src) %{
10650   // no match-rule, false predicate
10651   effect(DEF dst, USE src);
10652   predicate(false);
10653 
10654   format %{ &quot;MTFPRWA $dst, $src&quot; %}
10655   size(4);
10656   ins_encode %{
10657     __ mtfprwa($dst$$FloatRegister, $src$$Register);
10658   %}
10659   ins_pipe(pipe_class_default);
10660 %}
10661 
10662 //---------- Chain stack slots between similar types --------
10663 
10664 // These are needed so that the rules below can match.
10665 
10666 // Load integer from stack slot
10667 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10668   match(Set dst src);
10669   ins_cost(MEMORY_REF_COST);
10670 
10671   format %{ &quot;LWZ     $dst, $src&quot; %}
10672   size(4);
10673   ins_encode( enc_lwz(dst, src) );
10674   ins_pipe(pipe_class_memory);
10675 %}
10676 
10677 // Store integer to stack slot
10678 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10679   match(Set dst src);
10680   ins_cost(MEMORY_REF_COST);
10681 
10682   format %{ &quot;STW     $src, $dst \t// stk&quot; %}
10683   size(4);
10684   ins_encode( enc_stw(src, dst) ); // rs=rt
10685   ins_pipe(pipe_class_memory);
10686 %}
10687 
10688 // Load long from stack slot
10689 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10690   match(Set dst src);
10691   ins_cost(MEMORY_REF_COST);
10692 
10693   format %{ &quot;LD      $dst, $src \t// long&quot; %}
10694   size(4);
10695   ins_encode( enc_ld(dst, src) );
10696   ins_pipe(pipe_class_memory);
10697 %}
10698 
10699 // Store long to stack slot
10700 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10701   match(Set dst src);
10702   ins_cost(MEMORY_REF_COST);
10703 
10704   format %{ &quot;STD     $src, $dst \t// long&quot; %}
10705   size(4);
10706   ins_encode( enc_std(src, dst) ); // rs=rt
10707   ins_pipe(pipe_class_memory);
10708 %}
10709 
10710 //----------Moves between int and float
10711 
10712 // Move float value from float stack-location to integer register.
10713 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10714   match(Set dst (MoveF2I src));
10715   ins_cost(MEMORY_REF_COST);
10716 
10717   format %{ &quot;LWZ     $dst, $src \t// MoveF2I&quot; %}
10718   size(4);
10719   ins_encode( enc_lwz(dst, src) );
10720   ins_pipe(pipe_class_memory);
10721 %}
10722 
10723 // Move float value from float register to integer stack-location.
10724 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10725   match(Set dst (MoveF2I src));
10726   ins_cost(MEMORY_REF_COST);
10727 
10728   format %{ &quot;STFS    $src, $dst \t// MoveF2I&quot; %}
10729   size(4);
10730   ins_encode( enc_stfs(src, dst) );
10731   ins_pipe(pipe_class_memory);
10732 %}
10733 
10734 // Move integer value from integer stack-location to float register.
10735 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10736   match(Set dst (MoveI2F src));
10737   ins_cost(MEMORY_REF_COST);
10738 
10739   format %{ &quot;LFS     $dst, $src \t// MoveI2F&quot; %}
10740   size(4);
10741   ins_encode %{
10742     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10743     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10744     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10745   %}
10746   ins_pipe(pipe_class_memory);
10747 %}
10748 
10749 // Move integer value from integer register to float stack-location.
10750 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10751   match(Set dst (MoveI2F src));
10752   ins_cost(MEMORY_REF_COST);
10753 
10754   format %{ &quot;STW     $src, $dst \t// MoveI2F&quot; %}
10755   size(4);
10756   ins_encode( enc_stw(src, dst) );
10757   ins_pipe(pipe_class_memory);
10758 %}
10759 
10760 //----------Moves between long and float
10761 
10762 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10763   // no match-rule, false predicate
10764   effect(DEF dst, USE src);
10765   predicate(false);
10766 
10767   format %{ &quot;storeD  $src, $dst \t// STACK&quot; %}
10768   size(4);
10769   ins_encode( enc_stfd(src, dst) );
10770   ins_pipe(pipe_class_default);
10771 %}
10772 
10773 //----------Moves between long and double
10774 
10775 // Move double value from double stack-location to long register.
10776 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10777   match(Set dst (MoveD2L src));
10778   ins_cost(MEMORY_REF_COST);
10779   size(4);
10780   format %{ &quot;LD      $dst, $src \t// MoveD2L&quot; %}
10781   ins_encode( enc_ld(dst, src) );
10782   ins_pipe(pipe_class_memory);
10783 %}
10784 
10785 // Move double value from double register to long stack-location.
10786 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10787   match(Set dst (MoveD2L src));
10788   effect(DEF dst, USE src);
10789   ins_cost(MEMORY_REF_COST);
10790 
10791   format %{ &quot;STFD    $src, $dst \t// MoveD2L&quot; %}
10792   size(4);
10793   ins_encode( enc_stfd(src, dst) );
10794   ins_pipe(pipe_class_memory);
10795 %}
10796 
10797 // Move long value from long stack-location to double register.
10798 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10799   match(Set dst (MoveL2D src));
10800   ins_cost(MEMORY_REF_COST);
10801 
10802   format %{ &quot;LFD     $dst, $src \t// MoveL2D&quot; %}
10803   size(4);
10804   ins_encode( enc_lfd(dst, src) );
10805   ins_pipe(pipe_class_memory);
10806 %}
10807 
10808 // Move long value from long register to double stack-location.
10809 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10810   match(Set dst (MoveL2D src));
10811   ins_cost(MEMORY_REF_COST);
10812 
10813   format %{ &quot;STD     $src, $dst \t// MoveL2D&quot; %}
10814   size(4);
10815   ins_encode( enc_std(src, dst) );
10816   ins_pipe(pipe_class_memory);
10817 %}
10818 
10819 //----------Register Move Instructions-----------------------------------------
10820 
10821 // Replicate for Superword
10822 
10823 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10824   predicate(false);
10825   effect(DEF dst, USE src);
10826 
10827   format %{ &quot;MR      $dst, $src \t// replicate &quot; %}
10828   // variable size, 0 or 4.
10829   ins_encode %{
10830     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10831     __ mr_if_needed($dst$$Register, $src$$Register);
10832   %}
10833   ins_pipe(pipe_class_default);
10834 %}
10835 
10836 //----------Cast instructions (Java-level type cast)---------------------------
10837 
10838 // Cast Long to Pointer for unsafe natives.
10839 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10840   match(Set dst (CastX2P src));
10841 
10842   format %{ &quot;MR      $dst, $src \t// Long-&gt;Ptr&quot; %}
10843   // variable size, 0 or 4.
10844   ins_encode %{
10845     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10846     __ mr_if_needed($dst$$Register, $src$$Register);
10847   %}
10848  ins_pipe(pipe_class_default);
10849 %}
10850 
10851 // Cast Pointer to Long for unsafe natives.
10852 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10853   match(Set dst (CastP2X src));
10854 
10855   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Long&quot; %}
10856   // variable size, 0 or 4.
10857   ins_encode %{
10858     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10859     __ mr_if_needed($dst$$Register, $src$$Register);
10860   %}
10861   ins_pipe(pipe_class_default);
10862 %}
10863 
10864 instruct castPP(iRegPdst dst) %{
10865   match(Set dst (CastPP dst));
10866   format %{ &quot; -- \t// castPP of $dst&quot; %}
10867   size(0);
10868   ins_encode( /*empty*/ );
10869   ins_pipe(pipe_class_default);
10870 %}
10871 
10872 instruct castII(iRegIdst dst) %{
10873   match(Set dst (CastII dst));
10874   format %{ &quot; -- \t// castII of $dst&quot; %}
10875   size(0);
10876   ins_encode( /*empty*/ );
10877   ins_pipe(pipe_class_default);
10878 %}
10879 
10880 instruct castLL(iRegLdst dst) %{
10881   match(Set dst (CastLL dst));
10882   format %{ &quot; -- \t// castLL of $dst&quot; %}
10883   size(0);
10884   ins_encode( /*empty*/ );
10885   ins_pipe(pipe_class_default);
10886 %}
10887 
10888 instruct checkCastPP(iRegPdst dst) %{
10889   match(Set dst (CheckCastPP dst));
10890   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10891   size(0);
10892   ins_encode( /*empty*/ );
10893   ins_pipe(pipe_class_default);
10894 %}
10895 
10896 //----------Convert instructions-----------------------------------------------
10897 
10898 // Convert to boolean.
10899 
10900 // int_to_bool(src) : { 1   if src != 0
10901 //                    { 0   else
10902 //
10903 // strategy:
10904 // 1) Count leading zeros of 32 bit-value src,
10905 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10906 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10907 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10908 
10909 // convI2Bool
10910 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10911   match(Set dst (Conv2B src));
10912   predicate(UseCountLeadingZerosInstructionsPPC64);
10913   ins_cost(DEFAULT_COST);
10914 
10915   expand %{
10916     immI shiftAmount %{ 0x5 %}
10917     uimmI16 mask %{ 0x1 %}
10918     iRegIdst tmp1;
10919     iRegIdst tmp2;
10920     countLeadingZerosI(tmp1, src);
10921     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10922     xorI_reg_uimm16(dst, tmp2, mask);
10923   %}
10924 %}
10925 
10926 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10927   match(Set dst (Conv2B src));
10928   effect(TEMP crx);
10929   predicate(!UseCountLeadingZerosInstructionsPPC64);
10930   ins_cost(DEFAULT_COST);
10931 
10932   format %{ &quot;CMPWI   $crx, $src, #0 \t// convI2B&quot;
10933             &quot;LI      $dst, #0\n\t&quot;
10934             &quot;BEQ     $crx, done\n\t&quot;
10935             &quot;LI      $dst, #1\n&quot;
10936             &quot;done:&quot; %}
10937   size(16);
10938   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10939   ins_pipe(pipe_class_compare);
10940 %}
10941 
10942 // ConvI2B + XorI
10943 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10944   match(Set dst (XorI (Conv2B src) mask));
10945   predicate(UseCountLeadingZerosInstructionsPPC64);
10946   ins_cost(DEFAULT_COST);
10947 
10948   expand %{
10949     immI shiftAmount %{ 0x5 %}
10950     iRegIdst tmp1;
10951     countLeadingZerosI(tmp1, src);
10952     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10953   %}
10954 %}
10955 
10956 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10957   match(Set dst (XorI (Conv2B src) mask));
10958   effect(TEMP crx);
10959   predicate(!UseCountLeadingZerosInstructionsPPC64);
10960   ins_cost(DEFAULT_COST);
10961 
10962   format %{ &quot;CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)&quot;
10963             &quot;LI      $dst, #1\n\t&quot;
10964             &quot;BEQ     $crx, done\n\t&quot;
10965             &quot;LI      $dst, #0\n&quot;
10966             &quot;done:&quot; %}
10967   size(16);
10968   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10969   ins_pipe(pipe_class_compare);
10970 %}
10971 
10972 // AndI 0b0..010..0 + ConvI2B
10973 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10974   match(Set dst (Conv2B (AndI src mask)));
10975   predicate(UseRotateAndMaskInstructionsPPC64);
10976   ins_cost(DEFAULT_COST);
10977 
10978   format %{ &quot;RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))&quot; %}
10979   size(4);
10980   ins_encode %{
10981     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10982     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10983   %}
10984   ins_pipe(pipe_class_default);
10985 %}
10986 
10987 // Convert pointer to boolean.
10988 //
10989 // ptr_to_bool(src) : { 1   if src != 0
10990 //                    { 0   else
10991 //
10992 // strategy:
10993 // 1) Count leading zeros of 64 bit-value src,
10994 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10995 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10996 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10997 
10998 // ConvP2B
10999 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
11000   match(Set dst (Conv2B src));
11001   predicate(UseCountLeadingZerosInstructionsPPC64);
11002   ins_cost(DEFAULT_COST);
11003 
11004   expand %{
11005     immI shiftAmount %{ 0x6 %}
11006     uimmI16 mask %{ 0x1 %}
11007     iRegIdst tmp1;
11008     iRegIdst tmp2;
11009     countLeadingZerosP(tmp1, src);
11010     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
11011     xorI_reg_uimm16(dst, tmp2, mask);
11012   %}
11013 %}
11014 
11015 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
11016   match(Set dst (Conv2B src));
11017   effect(TEMP crx);
11018   predicate(!UseCountLeadingZerosInstructionsPPC64);
11019   ins_cost(DEFAULT_COST);
11020 
11021   format %{ &quot;CMPDI   $crx, $src, #0 \t// convP2B&quot;
11022             &quot;LI      $dst, #0\n\t&quot;
11023             &quot;BEQ     $crx, done\n\t&quot;
11024             &quot;LI      $dst, #1\n&quot;
11025             &quot;done:&quot; %}
11026   size(16);
11027   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
11028   ins_pipe(pipe_class_compare);
11029 %}
11030 
11031 // ConvP2B + XorI
11032 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
11033   match(Set dst (XorI (Conv2B src) mask));
11034   predicate(UseCountLeadingZerosInstructionsPPC64);
11035   ins_cost(DEFAULT_COST);
11036 
11037   expand %{
11038     immI shiftAmount %{ 0x6 %}
11039     iRegIdst tmp1;
11040     countLeadingZerosP(tmp1, src);
11041     urShiftI_reg_imm(dst, tmp1, shiftAmount);
11042   %}
11043 %}
11044 
11045 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
11046   match(Set dst (XorI (Conv2B src) mask));
11047   effect(TEMP crx);
11048   predicate(!UseCountLeadingZerosInstructionsPPC64);
11049   ins_cost(DEFAULT_COST);
11050 
11051   format %{ &quot;CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)&quot;
11052             &quot;LI      $dst, #1\n\t&quot;
11053             &quot;BEQ     $crx, done\n\t&quot;
11054             &quot;LI      $dst, #0\n&quot;
11055             &quot;done:&quot; %}
11056   size(16);
11057   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
11058   ins_pipe(pipe_class_compare);
11059 %}
11060 
11061 // if src1 &lt; src2, return -1 else return 0
11062 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
11063   match(Set dst (CmpLTMask src1 src2));
11064   ins_cost(DEFAULT_COST*4);
11065 
11066   expand %{
11067     iRegLdst src1s;
11068     iRegLdst src2s;
11069     iRegLdst diff;
11070     convI2L_reg(src1s, src1); // Ensure proper sign extension.
11071     convI2L_reg(src2s, src2); // Ensure proper sign extension.
11072     subL_reg_reg(diff, src1s, src2s);
11073     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
11074     signmask64I_regL(dst, diff);
11075   %}
11076 %}
11077 
11078 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
11079   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
11080   format %{ &quot;SRAWI   $dst, $src1, $src2 \t// CmpLTMask&quot; %}
11081   size(4);
11082   ins_encode %{
11083     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
11084     __ srawi($dst$$Register, $src1$$Register, 0x1f);
11085   %}
11086   ins_pipe(pipe_class_default);
11087 %}
11088 
11089 //----------Arithmetic Conversion Instructions---------------------------------
11090 
11091 // Convert to Byte  -- nop
11092 // Convert to Short -- nop
11093 
11094 // Convert to Int
11095 
11096 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
11097   match(Set dst (RShiftI (LShiftI src amount) amount));
11098   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
11099   size(4);
11100   ins_encode %{
11101     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
11102     __ extsb($dst$$Register, $src$$Register);
11103   %}
11104   ins_pipe(pipe_class_default);
11105 %}
11106 
11107 instruct extsh(iRegIdst dst, iRegIsrc src) %{
11108   effect(DEF dst, USE src);
11109 
11110   size(4);
11111   ins_encode %{
11112     __ extsh($dst$$Register, $src$$Register);
11113   %}
11114   ins_pipe(pipe_class_default);
11115 %}
11116 
11117 // LShiftI 16 + RShiftI 16 converts short to int.
11118 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
11119   match(Set dst (RShiftI (LShiftI src amount) amount));
11120   format %{ &quot;EXTSH   $dst, $src \t// short-&gt;int&quot; %}
11121   size(4);
11122   ins_encode %{
11123     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
11124     __ extsh($dst$$Register, $src$$Register);
11125   %}
11126   ins_pipe(pipe_class_default);
11127 %}
11128 
11129 // ConvL2I + ConvI2L: Sign extend int in long register.
11130 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
11131   match(Set dst (ConvI2L (ConvL2I src)));
11132 
11133   format %{ &quot;EXTSW   $dst, $src \t// long-&gt;long&quot; %}
11134   size(4);
11135   ins_encode %{
11136     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11137     __ extsw($dst$$Register, $src$$Register);
11138   %}
11139   ins_pipe(pipe_class_default);
11140 %}
11141 
11142 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
11143   match(Set dst (ConvL2I src));
11144   format %{ &quot;MR      $dst, $src \t// long-&gt;int&quot; %}
11145   // variable size, 0 or 4
11146   ins_encode %{
11147     // TODO: PPC port $archOpcode(ppc64Opcode_or);
11148     __ mr_if_needed($dst$$Register, $src$$Register);
11149   %}
11150   ins_pipe(pipe_class_default);
11151 %}
11152 
11153 instruct convD2IRaw_regD(regD dst, regD src) %{
11154   // no match-rule, false predicate
11155   effect(DEF dst, USE src);
11156   predicate(false);
11157 
11158   format %{ &quot;FCTIWZ $dst, $src \t// convD2I, $src != NaN&quot; %}
11159   size(4);
11160   ins_encode %{
11161     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
11162     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11163   %}
11164   ins_pipe(pipe_class_default);
11165 %}
11166 
11167 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
11168   // no match-rule, false predicate
11169   effect(DEF dst, USE crx, USE src);
11170   predicate(false);
11171 
11172   ins_variable_size_depending_on_alignment(true);
11173 
11174   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11175   // Worst case is branch + move + stop, no stop without scheduler.
11176   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11177   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11178   ins_pipe(pipe_class_default);
11179 %}
11180 
11181 instruct cmovI_bso_reg(iRegIdst dst, flagsRegSrc crx, regD src) %{
11182   // no match-rule, false predicate
11183   effect(DEF dst, USE crx, USE src);
11184   predicate(false);
11185 
11186   ins_variable_size_depending_on_alignment(true);
11187 
11188   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11189   // Worst case is branch + move + stop, no stop without scheduler.
11190   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11191   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11192   ins_pipe(pipe_class_default);
11193 %}
11194 
11195 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
11196   // no match-rule, false predicate
11197   effect(DEF dst, USE crx, USE mem);
11198   predicate(false);
11199 
11200   format %{ &quot;CmovI   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11201   postalloc_expand %{
11202     //
11203     // replaces
11204     //
11205     //   region  dst  crx  mem
11206     //    \       |    |   /
11207     //     dst=cmovI_bso_stackSlotL_conLvalue0
11208     //
11209     // with
11210     //
11211     //   region  dst
11212     //    \       /
11213     //     dst=loadConI16(0)
11214     //      |
11215     //      ^  region  dst  crx  mem
11216     //      |   \       |    |    /
11217     //      dst=cmovI_bso_stackSlotL
11218     //
11219 
11220     // Create new nodes.
11221     MachNode *m1 = new loadConI16Node();
11222     MachNode *m2 = new cmovI_bso_stackSlotLNode();
11223 
11224     // inputs for new nodes
11225     m1-&gt;add_req(n_region);
11226     m2-&gt;add_req(n_region, n_crx, n_mem);
11227 
11228     // precedences for new nodes
11229     m2-&gt;add_prec(m1);
11230 
11231     // operands for new nodes
11232     m1-&gt;_opnds[0] = op_dst;
11233     m1-&gt;_opnds[1] = new immI16Oper(0);
11234 
11235     m2-&gt;_opnds[0] = op_dst;
11236     m2-&gt;_opnds[1] = op_crx;
11237     m2-&gt;_opnds[2] = op_mem;
11238 
11239     // registers for new nodes
11240     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11241     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11242 
11243     // Insert new nodes.
11244     nodes-&gt;push(m1);
11245     nodes-&gt;push(m2);
11246   %}
11247 %}
11248 
11249 instruct cmovI_bso_reg_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, regD src) %{
11250   // no match-rule, false predicate
11251   effect(DEF dst, USE crx, USE src);
11252   predicate(false);
11253 
11254   format %{ &quot;CmovI   $dst, $crx, $src \t// postalloc expanded&quot; %}
11255   postalloc_expand %{
11256     //
11257     // replaces
11258     //
11259     //   region  dst  crx  src
11260     //    \       |    |   /
11261     //     dst=cmovI_bso_reg_conLvalue0
11262     //
11263     // with
11264     //
11265     //   region  dst
11266     //    \       /
11267     //     dst=loadConI16(0)
11268     //      |
11269     //      ^  region  dst  crx  src
11270     //      |   \       |    |    /
11271     //      dst=cmovI_bso_reg
11272     //
11273 
11274     // Create new nodes.
11275     MachNode *m1 = new loadConI16Node();
11276     MachNode *m2 = new cmovI_bso_regNode();
11277 
11278     // inputs for new nodes
11279     m1-&gt;add_req(n_region);
11280     m2-&gt;add_req(n_region, n_crx, n_src);
11281 
11282     // precedences for new nodes
11283     m2-&gt;add_prec(m1);
11284 
11285     // operands for new nodes
11286     m1-&gt;_opnds[0] = op_dst;
11287     m1-&gt;_opnds[1] = new immI16Oper(0);
11288 
11289     m2-&gt;_opnds[0] = op_dst;
11290     m2-&gt;_opnds[1] = op_crx;
11291     m2-&gt;_opnds[2] = op_src;
11292 
11293     // registers for new nodes
11294     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11295     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11296 
11297     // Insert new nodes.
11298     nodes-&gt;push(m1);
11299     nodes-&gt;push(m2);
11300   %}
11301 %}
11302 
11303 // Double to Int conversion, NaN is mapped to 0.
11304 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
11305   match(Set dst (ConvD2I src));
11306   predicate(!VM_Version::has_mtfprd());
11307   ins_cost(DEFAULT_COST);
11308 
11309   expand %{
11310     regD tmpD;
11311     stackSlotL tmpS;
11312     flagsReg crx;
11313     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11314     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11315     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11316     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11317   %}
11318 %}
11319 
11320 // Double to Int conversion, NaN is mapped to 0. Special version for Power8.
11321 instruct convD2I_reg_mffprd_ExEx(iRegIdst dst, regD src) %{
11322   match(Set dst (ConvD2I src));
11323   predicate(VM_Version::has_mtfprd());
11324   ins_cost(DEFAULT_COST);
11325 
11326   expand %{
11327     regD tmpD;
11328     flagsReg crx;
11329     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11330     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11331     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11332   %}
11333 %}
11334 
11335 instruct convF2IRaw_regF(regF dst, regF src) %{
11336   // no match-rule, false predicate
11337   effect(DEF dst, USE src);
11338   predicate(false);
11339 
11340   format %{ &quot;FCTIWZ $dst, $src \t// convF2I, $src != NaN&quot; %}
11341   size(4);
11342   ins_encode %{
11343     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11344     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11345   %}
11346   ins_pipe(pipe_class_default);
11347 %}
11348 
11349 // Float to Int conversion, NaN is mapped to 0.
11350 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
11351   match(Set dst (ConvF2I src));
11352   predicate(!VM_Version::has_mtfprd());
11353   ins_cost(DEFAULT_COST);
11354 
11355   expand %{
11356     regF tmpF;
11357     stackSlotL tmpS;
11358     flagsReg crx;
11359     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11360     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11361     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11362     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11363   %}
11364 %}
11365 
11366 // Float to Int conversion, NaN is mapped to 0. Special version for Power8.
11367 instruct convF2I_regF_mffprd_ExEx(iRegIdst dst, regF src) %{
11368   match(Set dst (ConvF2I src));
11369   predicate(VM_Version::has_mtfprd());
11370   ins_cost(DEFAULT_COST);
11371 
11372   expand %{
11373     regF tmpF;
11374     flagsReg crx;
11375     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11376     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11377     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11378   %}
11379 %}
11380 
11381 // Convert to Long
11382 
11383 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
11384   match(Set dst (ConvI2L src));
11385   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;long&quot; %}
11386   size(4);
11387   ins_encode %{
11388     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11389     __ extsw($dst$$Register, $src$$Register);
11390   %}
11391   ins_pipe(pipe_class_default);
11392 %}
11393 
11394 // Zero-extend: convert unsigned int to long (convUI2L).
11395 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
11396   match(Set dst (AndL (ConvI2L src) mask));
11397   ins_cost(DEFAULT_COST);
11398 
11399   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11400   size(4);
11401   ins_encode %{
11402     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11403     __ clrldi($dst$$Register, $src$$Register, 32);
11404   %}
11405   ins_pipe(pipe_class_default);
11406 %}
11407 
11408 // Zero-extend: convert unsigned int to long in long register.
11409 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
11410   match(Set dst (AndL src mask));
11411   ins_cost(DEFAULT_COST);
11412 
11413   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11414   size(4);
11415   ins_encode %{
11416     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11417     __ clrldi($dst$$Register, $src$$Register, 32);
11418   %}
11419   ins_pipe(pipe_class_default);
11420 %}
11421 
11422 instruct convF2LRaw_regF(regF dst, regF src) %{
11423   // no match-rule, false predicate
11424   effect(DEF dst, USE src);
11425   predicate(false);
11426 
11427   format %{ &quot;FCTIDZ $dst, $src \t// convF2L, $src != NaN&quot; %}
11428   size(4);
11429   ins_encode %{
11430     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11431     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11432   %}
11433   ins_pipe(pipe_class_default);
11434 %}
11435 
11436 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
11437   // no match-rule, false predicate
11438   effect(DEF dst, USE crx, USE src);
11439   predicate(false);
11440 
11441   ins_variable_size_depending_on_alignment(true);
11442 
11443   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11444   // Worst case is branch + move + stop, no stop without scheduler.
11445   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11446   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11447   ins_pipe(pipe_class_default);
11448 %}
11449 
11450 instruct cmovL_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
11451   // no match-rule, false predicate
11452   effect(DEF dst, USE crx, USE src);
11453   predicate(false);
11454 
11455   ins_variable_size_depending_on_alignment(true);
11456 
11457   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11458   // Worst case is branch + move + stop, no stop without scheduler.
11459   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11460   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11461   ins_pipe(pipe_class_default);
11462 %}
11463 
11464 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
11465   // no match-rule, false predicate
11466   effect(DEF dst, USE crx, USE mem);
11467   predicate(false);
11468 
11469   format %{ &quot;CmovL   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11470   postalloc_expand %{
11471     //
11472     // replaces
11473     //
11474     //   region  dst  crx  mem
11475     //    \       |    |   /
11476     //     dst=cmovL_bso_stackSlotL_conLvalue0
11477     //
11478     // with
11479     //
11480     //   region  dst
11481     //    \       /
11482     //     dst=loadConL16(0)
11483     //      |
11484     //      ^  region  dst  crx  mem
11485     //      |   \       |    |    /
11486     //      dst=cmovL_bso_stackSlotL
11487     //
11488 
11489     // Create new nodes.
11490     MachNode *m1 = new loadConL16Node();
11491     MachNode *m2 = new cmovL_bso_stackSlotLNode();
11492 
11493     // inputs for new nodes
11494     m1-&gt;add_req(n_region);
11495     m2-&gt;add_req(n_region, n_crx, n_mem);
11496     m2-&gt;add_prec(m1);
11497 
11498     // operands for new nodes
11499     m1-&gt;_opnds[0] = op_dst;
11500     m1-&gt;_opnds[1] = new immL16Oper(0);
11501     m2-&gt;_opnds[0] = op_dst;
11502     m2-&gt;_opnds[1] = op_crx;
11503     m2-&gt;_opnds[2] = op_mem;
11504 
11505     // registers for new nodes
11506     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11507     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11508 
11509     // Insert new nodes.
11510     nodes-&gt;push(m1);
11511     nodes-&gt;push(m2);
11512   %}
11513 %}
11514 
11515 instruct cmovL_bso_reg_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, regD src) %{
11516   // no match-rule, false predicate
11517   effect(DEF dst, USE crx, USE src);
11518   predicate(false);
11519 
11520   format %{ &quot;CmovL   $dst, $crx, $src \t// postalloc expanded&quot; %}
11521   postalloc_expand %{
11522     //
11523     // replaces
11524     //
11525     //   region  dst  crx  src
11526     //    \       |    |   /
11527     //     dst=cmovL_bso_reg_conLvalue0
11528     //
11529     // with
11530     //
11531     //   region  dst
11532     //    \       /
11533     //     dst=loadConL16(0)
11534     //      |
11535     //      ^  region  dst  crx  src
11536     //      |   \       |    |    /
11537     //      dst=cmovL_bso_reg
11538     //
11539 
11540     // Create new nodes.
11541     MachNode *m1 = new loadConL16Node();
11542     MachNode *m2 = new cmovL_bso_regNode();
11543 
11544     // inputs for new nodes
11545     m1-&gt;add_req(n_region);
11546     m2-&gt;add_req(n_region, n_crx, n_src);
11547     m2-&gt;add_prec(m1);
11548 
11549     // operands for new nodes
11550     m1-&gt;_opnds[0] = op_dst;
11551     m1-&gt;_opnds[1] = new immL16Oper(0);
11552     m2-&gt;_opnds[0] = op_dst;
11553     m2-&gt;_opnds[1] = op_crx;
11554     m2-&gt;_opnds[2] = op_src;
11555 
11556     // registers for new nodes
11557     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11558     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11559 
11560     // Insert new nodes.
11561     nodes-&gt;push(m1);
11562     nodes-&gt;push(m2);
11563   %}
11564 %}
11565 
11566 // Float to Long conversion, NaN is mapped to 0.
11567 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
11568   match(Set dst (ConvF2L src));
11569   predicate(!VM_Version::has_mtfprd());
11570   ins_cost(DEFAULT_COST);
11571 
11572   expand %{
11573     regF tmpF;
11574     stackSlotL tmpS;
11575     flagsReg crx;
11576     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11577     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11578     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11579     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11580   %}
11581 %}
11582 
11583 // Float to Long conversion, NaN is mapped to 0. Special version for Power8.
11584 instruct convF2L_reg_mffprd_ExEx(iRegLdst dst, regF src) %{
11585   match(Set dst (ConvF2L src));
11586   predicate(VM_Version::has_mtfprd());
11587   ins_cost(DEFAULT_COST);
11588 
11589   expand %{
11590     regF tmpF;
11591     flagsReg crx;
11592     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11593     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11594     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11595   %}
11596 %}
11597 
11598 instruct convD2LRaw_regD(regD dst, regD src) %{
11599   // no match-rule, false predicate
11600   effect(DEF dst, USE src);
11601   predicate(false);
11602 
11603   format %{ &quot;FCTIDZ $dst, $src \t// convD2L $src != NaN&quot; %}
11604   size(4);
11605   ins_encode %{
11606     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11607     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11608   %}
11609   ins_pipe(pipe_class_default);
11610 %}
11611 
11612 // Double to Long conversion, NaN is mapped to 0.
11613 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
11614   match(Set dst (ConvD2L src));
11615   predicate(!VM_Version::has_mtfprd());
11616   ins_cost(DEFAULT_COST);
11617 
11618   expand %{
11619     regD tmpD;
11620     stackSlotL tmpS;
11621     flagsReg crx;
11622     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11623     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11624     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11625     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11626   %}
11627 %}
11628 
11629 // Double to Long conversion, NaN is mapped to 0. Special version for Power8.
11630 instruct convD2L_reg_mffprd_ExEx(iRegLdst dst, regD src) %{
11631   match(Set dst (ConvD2L src));
11632   predicate(VM_Version::has_mtfprd());
11633   ins_cost(DEFAULT_COST);
11634 
11635   expand %{
11636     regD tmpD;
11637     flagsReg crx;
11638     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11639     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11640     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11641   %}
11642 %}
11643 
11644 // Convert to Float
11645 
11646 // Placed here as needed in expand.
11647 instruct convL2DRaw_regD(regD dst, regD src) %{
11648   // no match-rule, false predicate
11649   effect(DEF dst, USE src);
11650   predicate(false);
11651 
11652   format %{ &quot;FCFID $dst, $src \t// convL2D&quot; %}
11653   size(4);
11654   ins_encode %{
11655     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11656     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
11657   %}
11658   ins_pipe(pipe_class_default);
11659 %}
11660 
11661 // Placed here as needed in expand.
11662 instruct convD2F_reg(regF dst, regD src) %{
11663   match(Set dst (ConvD2F src));
11664   format %{ &quot;FRSP    $dst, $src \t// convD2F&quot; %}
11665   size(4);
11666   ins_encode %{
11667     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
11668     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
11669   %}
11670   ins_pipe(pipe_class_default);
11671 %}
11672 
11673 // Integer to Float conversion.
11674 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
11675   match(Set dst (ConvI2F src));
11676   predicate(!VM_Version::has_fcfids());
11677   ins_cost(DEFAULT_COST);
11678 
11679   expand %{
11680     iRegLdst tmpL;
11681     stackSlotL tmpS;
11682     regD tmpD;
11683     regD tmpD2;
11684     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11685     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11686     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11687     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
11688     convD2F_reg(dst, tmpD2);             // Convert double to float.
11689   %}
11690 %}
11691 
11692 instruct convL2FRaw_regF(regF dst, regD src) %{
11693   // no match-rule, false predicate
11694   effect(DEF dst, USE src);
11695   predicate(false);
11696 
11697   format %{ &quot;FCFIDS $dst, $src \t// convL2F&quot; %}
11698   size(4);
11699   ins_encode %{
11700     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11701     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
11702   %}
11703   ins_pipe(pipe_class_default);
11704 %}
11705 
11706 // Integer to Float conversion. Special version for Power7.
11707 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
11708   match(Set dst (ConvI2F src));
11709   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11710   ins_cost(DEFAULT_COST);
11711 
11712   expand %{
11713     iRegLdst tmpL;
11714     stackSlotL tmpS;
11715     regD tmpD;
11716     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11717     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11718     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11719     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11720   %}
11721 %}
11722 
11723 // Integer to Float conversion. Special version for Power8.
11724 instruct convI2F_ireg_mtfprd_Ex(regF dst, iRegIsrc src) %{
11725   match(Set dst (ConvI2F src));
11726   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11727   ins_cost(DEFAULT_COST);
11728 
11729   expand %{
11730     regD tmpD;
11731     moveI2D_reg(tmpD, src);
11732     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11733   %}
11734 %}
11735 
11736 // L2F to avoid runtime call.
11737 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
11738   match(Set dst (ConvL2F src));
11739   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11740   ins_cost(DEFAULT_COST);
11741 
11742   expand %{
11743     stackSlotL tmpS;
11744     regD tmpD;
11745     regL_to_stkL(tmpS, src);             // Store long to stack.
11746     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11747     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11748   %}
11749 %}
11750 
11751 // L2F to avoid runtime call.  Special version for Power8.
11752 instruct convL2F_ireg_mtfprd_Ex(regF dst, iRegLsrc src) %{
11753   match(Set dst (ConvL2F src));
11754   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11755   ins_cost(DEFAULT_COST);
11756 
11757   expand %{
11758     regD tmpD;
11759     moveL2D_reg(tmpD, src);
11760     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11761   %}
11762 %}
11763 
11764 // Moved up as used in expand.
11765 //instruct convD2F_reg(regF dst, regD src) %{%}
11766 
11767 // Convert to Double
11768 
11769 // Integer to Double conversion.
11770 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
11771   match(Set dst (ConvI2D src));
11772   predicate(!VM_Version::has_mtfprd());
11773   ins_cost(DEFAULT_COST);
11774 
11775   expand %{
11776     iRegLdst tmpL;
11777     stackSlotL tmpS;
11778     regD tmpD;
11779     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11780     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11781     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11782     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11783   %}
11784 %}
11785 
11786 // Integer to Double conversion. Special version for Power8.
11787 instruct convI2D_reg_mtfprd_Ex(regD dst, iRegIsrc src) %{
11788   match(Set dst (ConvI2D src));
11789   predicate(VM_Version::has_mtfprd());
11790   ins_cost(DEFAULT_COST);
11791 
11792   expand %{
11793     regD tmpD;
11794     moveI2D_reg(tmpD, src);
11795     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11796   %}
11797 %}
11798 
11799 // Long to Double conversion
11800 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
11801   match(Set dst (ConvL2D src));
11802   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
11803 
11804   expand %{
11805     regD tmpD;
11806     moveL2D_stack_reg(tmpD, src);
11807     convL2DRaw_regD(dst, tmpD);
11808   %}
11809 %}
11810 
11811 // Long to Double conversion. Special version for Power8.
11812 instruct convL2D_reg_mtfprd_Ex(regD dst, iRegLsrc src) %{
11813   match(Set dst (ConvL2D src));
11814   predicate(VM_Version::has_mtfprd());
11815   ins_cost(DEFAULT_COST);
11816 
11817   expand %{
11818     regD tmpD;
11819     moveL2D_reg(tmpD, src);
11820     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11821   %}
11822 %}
11823 
11824 instruct convF2D_reg(regD dst, regF src) %{
11825   match(Set dst (ConvF2D src));
11826   format %{ &quot;FMR     $dst, $src \t// float-&gt;double&quot; %}
11827   // variable size, 0 or 4
11828   ins_encode %{
11829     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
11830     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
11831   %}
11832   ins_pipe(pipe_class_default);
11833 %}
11834 
11835 //----------Control Flow Instructions------------------------------------------
11836 // Compare Instructions
11837 
11838 // Compare Integers
11839 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11840   match(Set crx (CmpI src1 src2));
11841   size(4);
11842   format %{ &quot;CMPW    $crx, $src1, $src2&quot; %}
11843   ins_encode %{
11844     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11845     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11846   %}
11847   ins_pipe(pipe_class_compare);
11848 %}
11849 
11850 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11851   match(Set crx (CmpI src1 src2));
11852   format %{ &quot;CMPWI   $crx, $src1, $src2&quot; %}
11853   size(4);
11854   ins_encode %{
11855     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11856     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11857   %}
11858   ins_pipe(pipe_class_compare);
11859 %}
11860 
11861 // (src1 &amp; src2) == 0?
11862 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11863   match(Set cr0 (CmpI (AndI src1 src2) zero));
11864   // r0 is killed
11865   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST int&quot; %}
11866   size(4);
11867   ins_encode %{
11868     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11869     __ andi_(R0, $src1$$Register, $src2$$constant);
11870   %}
11871   ins_pipe(pipe_class_compare);
11872 %}
11873 
11874 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11875   match(Set crx (CmpL src1 src2));
11876   format %{ &quot;CMPD    $crx, $src1, $src2&quot; %}
11877   size(4);
11878   ins_encode %{
11879     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11880     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11881   %}
11882   ins_pipe(pipe_class_compare);
11883 %}
11884 
11885 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11886   match(Set crx (CmpL src1 src2));
11887   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
11888   size(4);
11889   ins_encode %{
11890     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11891     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11892   %}
11893   ins_pipe(pipe_class_compare);
11894 %}
11895 
11896 // Added CmpUL for LoopPredicate.
11897 instruct cmpUL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11898   match(Set crx (CmpUL src1 src2));
11899   format %{ &quot;CMPLD   $crx, $src1, $src2&quot; %}
11900   size(4);
11901   ins_encode %{
11902     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11903     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11904   %}
11905   ins_pipe(pipe_class_compare);
11906 %}
11907 
11908 instruct cmpUL_reg_imm16(flagsReg crx, iRegLsrc src1, uimmL16 src2) %{
11909   match(Set crx (CmpUL src1 src2));
11910   format %{ &quot;CMPLDI  $crx, $src1, $src2&quot; %}
11911   size(4);
11912   ins_encode %{
11913     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11914     __ cmpldi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11915   %}
11916   ins_pipe(pipe_class_compare);
11917 %}
11918 
11919 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11920   match(Set cr0 (CmpL (AndL src1 src2) zero));
11921   // r0 is killed
11922   format %{ &quot;AND     R0, $src1, $src2 \t// BTST long&quot; %}
11923   size(4);
11924   ins_encode %{
11925     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11926     __ and_(R0, $src1$$Register, $src2$$Register);
11927   %}
11928   ins_pipe(pipe_class_compare);
11929 %}
11930 
11931 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11932   match(Set cr0 (CmpL (AndL src1 src2) zero));
11933   // r0 is killed
11934   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST long&quot; %}
11935   size(4);
11936   ins_encode %{
11937     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11938     __ andi_(R0, $src1$$Register, $src2$$constant);
11939   %}
11940   ins_pipe(pipe_class_compare);
11941 %}
11942 
11943 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11944   // no match-rule, false predicate
11945   effect(DEF dst, USE crx);
11946   predicate(false);
11947 
11948   ins_variable_size_depending_on_alignment(true);
11949 
11950   format %{ &quot;cmovI   $crx, $dst, -1, 0, +1&quot; %}
11951   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11952   size((false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16));
11953   ins_encode %{
11954     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11955     Label done;
11956     // li(Rdst, 0);              // equal -&gt; 0
11957     __ beq($crx$$CondRegister, done);
11958     __ li($dst$$Register, 1);    // greater -&gt; +1
11959     __ bgt($crx$$CondRegister, done);
11960     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11961     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11962     __ bind(done);
11963   %}
11964   ins_pipe(pipe_class_compare);
11965 %}
11966 
11967 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11968   // no match-rule, false predicate
11969   effect(DEF dst, USE crx);
11970   predicate(false);
11971 
11972   format %{ &quot;CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded&quot; %}
11973   postalloc_expand %{
11974     //
11975     // replaces
11976     //
11977     //   region  crx
11978     //    \       |
11979     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11980     //
11981     // with
11982     //
11983     //   region
11984     //    \
11985     //     dst=loadConI16(0)
11986     //      |
11987     //      ^  region  crx
11988     //      |   \       |
11989     //      dst=cmovI_conIvalueMinus1_conIvalue1
11990     //
11991 
11992     // Create new nodes.
11993     MachNode *m1 = new loadConI16Node();
11994     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11995 
11996     // inputs for new nodes
11997     m1-&gt;add_req(n_region);
11998     m2-&gt;add_req(n_region, n_crx);
11999     m2-&gt;add_prec(m1);
12000 
12001     // operands for new nodes
12002     m1-&gt;_opnds[0] = op_dst;
12003     m1-&gt;_opnds[1] = new immI16Oper(0);
12004     m2-&gt;_opnds[0] = op_dst;
12005     m2-&gt;_opnds[1] = op_crx;
12006 
12007     // registers for new nodes
12008     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12009     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12010 
12011     // Insert new nodes.
12012     nodes-&gt;push(m1);
12013     nodes-&gt;push(m2);
12014   %}
12015 %}
12016 
12017 // Manifest a CmpL3 result in an integer register. Very painful.
12018 // This is the test to avoid.
12019 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
12020 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
12021   match(Set dst (CmpL3 src1 src2));
12022   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12023 
12024   expand %{
12025     flagsReg tmp1;
12026     cmpL_reg_reg(tmp1, src1, src2);
12027     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12028   %}
12029 %}
12030 
12031 // Implicit range checks.
12032 // A range check in the ideal world has one of the following shapes:
12033 //  - (If le (CmpU length index)), (IfTrue  throw exception)
12034 //  - (If lt (CmpU index length)), (IfFalse throw exception)
12035 //
12036 // Match range check &#39;If le (CmpU length index)&#39;.
12037 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
12038   match(If cmp (CmpU src_length index));
12039   effect(USE labl);
12040   predicate(TrapBasedRangeChecks &amp;&amp;
12041             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
12042             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
12043             (Matcher::branches_to_uncommon_trap(_leaf)));
12044 
12045   ins_is_TrapBasedCheckNode(true);
12046 
12047   format %{ &quot;TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12048   size(4);
12049   ins_encode %{
12050     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12051     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
12052       __ trap_range_check_le($src_length$$Register, $index$$constant);
12053     } else {
12054       // Both successors are uncommon traps, probability is 0.
12055       // Node got flipped during fixup flow.
12056       assert($cmp$$cmpcode == 0x9, &quot;must be greater&quot;);
12057       __ trap_range_check_g($src_length$$Register, $index$$constant);
12058     }
12059   %}
12060   ins_pipe(pipe_class_trap);
12061 %}
12062 
12063 // Match range check &#39;If lt (CmpU index length)&#39;.
12064 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
12065   match(If cmp (CmpU src_index src_length));
12066   effect(USE labl);
12067   predicate(TrapBasedRangeChecks &amp;&amp;
12068             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12069             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12070             (Matcher::branches_to_uncommon_trap(_leaf)));
12071 
12072   ins_is_TrapBasedCheckNode(true);
12073 
12074   format %{ &quot;TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12075   size(4);
12076   ins_encode %{
12077     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
12078     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12079       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
12080     } else {
12081       // Both successors are uncommon traps, probability is 0.
12082       // Node got flipped during fixup flow.
12083       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12084       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
12085     }
12086   %}
12087   ins_pipe(pipe_class_trap);
12088 %}
12089 
12090 // Match range check &#39;If lt (CmpU index length)&#39;.
12091 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
12092   match(If cmp (CmpU src_index length));
12093   effect(USE labl);
12094   predicate(TrapBasedRangeChecks &amp;&amp;
12095             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12096             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12097             (Matcher::branches_to_uncommon_trap(_leaf)));
12098 
12099   ins_is_TrapBasedCheckNode(true);
12100 
12101   format %{ &quot;TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl&quot; %}
12102   size(4);
12103   ins_encode %{
12104     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12105     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12106       __ trap_range_check_ge($src_index$$Register, $length$$constant);
12107     } else {
12108       // Both successors are uncommon traps, probability is 0.
12109       // Node got flipped during fixup flow.
12110       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12111       __ trap_range_check_l($src_index$$Register, $length$$constant);
12112     }
12113   %}
12114   ins_pipe(pipe_class_trap);
12115 %}
12116 
12117 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
12118   match(Set crx (CmpU src1 src2));
12119   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// unsigned&quot; %}
12120   size(4);
12121   ins_encode %{
12122     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12123     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12124   %}
12125   ins_pipe(pipe_class_compare);
12126 %}
12127 
12128 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
12129   match(Set crx (CmpU src1 src2));
12130   size(4);
12131   format %{ &quot;CMPLWI  $crx, $src1, $src2&quot; %}
12132   ins_encode %{
12133     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12134     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12135   %}
12136   ins_pipe(pipe_class_compare);
12137 %}
12138 
12139 // Implicit zero checks (more implicit null checks).
12140 // No constant pool entries required.
12141 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
12142   match(If cmp (CmpN value zero));
12143   effect(USE labl);
12144   predicate(TrapBasedNullChecks &amp;&amp;
12145             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12146             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12147             Matcher::branches_to_uncommon_trap(_leaf));
12148   ins_cost(1);
12149 
12150   ins_is_TrapBasedCheckNode(true);
12151 
12152   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl&quot; %}
12153   size(4);
12154   ins_encode %{
12155     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12156     if ($cmp$$cmpcode == 0xA) {
12157       __ trap_null_check($value$$Register);
12158     } else {
12159       // Both successors are uncommon traps, probability is 0.
12160       // Node got flipped during fixup flow.
12161       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12162       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12163     }
12164   %}
12165   ins_pipe(pipe_class_trap);
12166 %}
12167 
12168 // Compare narrow oops.
12169 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
12170   match(Set crx (CmpN src1 src2));
12171 
12172   size(4);
12173   ins_cost(2);
12174   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// compressed ptr&quot; %}
12175   ins_encode %{
12176     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12177     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12178   %}
12179   ins_pipe(pipe_class_compare);
12180 %}
12181 
12182 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
12183   match(Set crx (CmpN src1 src2));
12184   // Make this more expensive than zeroCheckN_iReg_imm0.
12185   ins_cost(2);
12186 
12187   format %{ &quot;CMPLWI  $crx, $src1, $src2 \t// compressed ptr&quot; %}
12188   size(4);
12189   ins_encode %{
12190     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12191     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12192   %}
12193   ins_pipe(pipe_class_compare);
12194 %}
12195 
12196 // Implicit zero checks (more implicit null checks).
12197 // No constant pool entries required.
12198 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
12199   match(If cmp (CmpP value zero));
12200   effect(USE labl);
12201   predicate(TrapBasedNullChecks &amp;&amp;
12202             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12203             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12204             Matcher::branches_to_uncommon_trap(_leaf));
12205   ins_cost(1); // Should not be cheaper than zeroCheckN.
12206 
12207   ins_is_TrapBasedCheckNode(true);
12208 
12209   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl&quot; %}
12210   size(4);
12211   ins_encode %{
12212     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12213     if ($cmp$$cmpcode == 0xA) {
12214       __ trap_null_check($value$$Register);
12215     } else {
12216       // Both successors are uncommon traps, probability is 0.
12217       // Node got flipped during fixup flow.
12218       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12219       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12220     }
12221   %}
12222   ins_pipe(pipe_class_trap);
12223 %}
12224 
12225 // Compare Pointers
12226 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
12227   match(Set crx (CmpP src1 src2));
12228   format %{ &quot;CMPLD   $crx, $src1, $src2 \t// ptr&quot; %}
12229   size(4);
12230   ins_encode %{
12231     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12232     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
12233   %}
12234   ins_pipe(pipe_class_compare);
12235 %}
12236 
12237 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
12238   match(Set crx (CmpP src1 src2));
12239   format %{ &quot;CMPLDI   $crx, $src1, $src2 \t// ptr&quot; %}
12240   size(4);
12241   ins_encode %{
12242     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12243     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
12244   %}
12245   ins_pipe(pipe_class_compare);
12246 %}
12247 
12248 // Used in postalloc expand.
12249 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
12250   // This match rule prevents reordering of node before a safepoint.
12251   // This only makes sense if this instructions is used exclusively
12252   // for the expansion of EncodeP!
12253   match(Set crx (CmpP src1 src2));
12254   predicate(false);
12255 
12256   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
12257   size(4);
12258   ins_encode %{
12259     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
12260     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12261   %}
12262   ins_pipe(pipe_class_compare);
12263 %}
12264 
12265 //----------Float Compares----------------------------------------------------
12266 
12267 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
12268   // Needs matchrule, see cmpDUnordered.
12269   match(Set crx (CmpF src1 src2));
12270   // no match-rule, false predicate
12271   predicate(false);
12272 
12273   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12274   size(4);
12275   ins_encode %{
12276     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12277     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12278   %}
12279   ins_pipe(pipe_class_default);
12280 %}
12281 
12282 instruct cmov_bns_less(flagsReg crx) %{
12283   // no match-rule, false predicate
12284   effect(DEF crx);
12285   predicate(false);
12286 
12287   ins_variable_size_depending_on_alignment(true);
12288 
12289   format %{ &quot;cmov    $crx&quot; %}
12290   // Worst case is branch + move + stop, no stop without scheduler.
12291   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12));
12292   ins_encode %{
12293     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
12294     Label done;
12295     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
12296     __ li(R0, 0);
12297     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to &#39;less&#39;
12298     // TODO PPC port __ endgroup_if_needed(_size == 16);
12299     __ bind(done);
12300   %}
12301   ins_pipe(pipe_class_default);
12302 %}
12303 
12304 // Compare floating, generate condition code.
12305 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
12306   // FIXME: should we match &#39;If cmp (CmpF src1 src2))&#39; ??
12307   //
12308   // The following code sequence occurs a lot in mpegaudio:
12309   //
12310   // block BXX:
12311   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
12312   //    cmpFUrd CCR6, F11, F9
12313   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
12314   //    cmov CCR6
12315   // 8: instruct branchConSched:
12316   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
12317   match(Set crx (CmpF src1 src2));
12318   ins_cost(DEFAULT_COST+BRANCH_COST);
12319 
12320   format %{ &quot;CmpF    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12321   postalloc_expand %{
12322     //
12323     // replaces
12324     //
12325     //   region  src1  src2
12326     //    \       |     |
12327     //     crx=cmpF_reg_reg
12328     //
12329     // with
12330     //
12331     //   region  src1  src2
12332     //    \       |     |
12333     //     crx=cmpFUnordered_reg_reg
12334     //      |
12335     //      ^  region
12336     //      |   \
12337     //      crx=cmov_bns_less
12338     //
12339 
12340     // Create new nodes.
12341     MachNode *m1 = new cmpFUnordered_reg_regNode();
12342     MachNode *m2 = new cmov_bns_lessNode();
12343 
12344     // inputs for new nodes
12345     m1-&gt;add_req(n_region, n_src1, n_src2);
12346     m2-&gt;add_req(n_region);
12347     m2-&gt;add_prec(m1);
12348 
12349     // operands for new nodes
12350     m1-&gt;_opnds[0] = op_crx;
12351     m1-&gt;_opnds[1] = op_src1;
12352     m1-&gt;_opnds[2] = op_src2;
12353     m2-&gt;_opnds[0] = op_crx;
12354 
12355     // registers for new nodes
12356     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12357     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12358 
12359     // Insert new nodes.
12360     nodes-&gt;push(m1);
12361     nodes-&gt;push(m2);
12362   %}
12363 %}
12364 
12365 // Compare float, generate -1,0,1
12366 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
12367   match(Set dst (CmpF3 src1 src2));
12368   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12369 
12370   expand %{
12371     flagsReg tmp1;
12372     cmpFUnordered_reg_reg(tmp1, src1, src2);
12373     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12374   %}
12375 %}
12376 
12377 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
12378   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
12379   // node right before the conditional move using it.
12380   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
12381   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
12382   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
12383   // conditional move was supposed to be spilled.
12384   match(Set crx (CmpD src1 src2));
12385   // False predicate, shall not be matched.
12386   predicate(false);
12387 
12388   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12389   size(4);
12390   ins_encode %{
12391     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12392     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12393   %}
12394   ins_pipe(pipe_class_default);
12395 %}
12396 
12397 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
12398   match(Set crx (CmpD src1 src2));
12399   ins_cost(DEFAULT_COST+BRANCH_COST);
12400 
12401   format %{ &quot;CmpD    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12402   postalloc_expand %{
12403     //
12404     // replaces
12405     //
12406     //   region  src1  src2
12407     //    \       |     |
12408     //     crx=cmpD_reg_reg
12409     //
12410     // with
12411     //
12412     //   region  src1  src2
12413     //    \       |     |
12414     //     crx=cmpDUnordered_reg_reg
12415     //      |
12416     //      ^  region
12417     //      |   \
12418     //      crx=cmov_bns_less
12419     //
12420 
12421     // create new nodes
12422     MachNode *m1 = new cmpDUnordered_reg_regNode();
12423     MachNode *m2 = new cmov_bns_lessNode();
12424 
12425     // inputs for new nodes
12426     m1-&gt;add_req(n_region, n_src1, n_src2);
12427     m2-&gt;add_req(n_region);
12428     m2-&gt;add_prec(m1);
12429 
12430     // operands for new nodes
12431     m1-&gt;_opnds[0] = op_crx;
12432     m1-&gt;_opnds[1] = op_src1;
12433     m1-&gt;_opnds[2] = op_src2;
12434     m2-&gt;_opnds[0] = op_crx;
12435 
12436     // registers for new nodes
12437     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12438     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12439 
12440     // Insert new nodes.
12441     nodes-&gt;push(m1);
12442     nodes-&gt;push(m2);
12443   %}
12444 %}
12445 
12446 // Compare double, generate -1,0,1
12447 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
12448   match(Set dst (CmpD3 src1 src2));
12449   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12450 
12451   expand %{
12452     flagsReg tmp1;
12453     cmpDUnordered_reg_reg(tmp1, src1, src2);
12454     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12455   %}
12456 %}
12457 
12458 // Compare char
12459 instruct cmprb_Digit_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12460   match(Set dst (Digit src1));
12461   effect(TEMP src2, TEMP crx);
12462   ins_cost(3 * DEFAULT_COST);
12463 
12464   format %{ &quot;LI      $src2, 0x3930\n\t&quot;
12465             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12466             &quot;SETB    $dst, $crx&quot; %}
12467   size(12);
12468   ins_encode %{
12469     // 0x30: 0, 0x39: 9
12470     __ li($src2$$Register, 0x3930);
12471     // compare src1 with ranges 0x30 to 0x39
12472     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12473     __ setb($dst$$Register, $crx$$CondRegister);
12474   %}
12475   ins_pipe(pipe_class_default);
12476 %}
12477 
12478 instruct cmprb_LowerCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12479   match(Set dst (LowerCase src1));
12480   effect(TEMP src2, TEMP crx);
12481   ins_cost(12 * DEFAULT_COST);
12482 
12483   format %{ &quot;LI      $src2, 0x7A61\n\t&quot;
12484             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12485             &quot;BGT     $crx, done\n\t&quot;
12486             &quot;LIS     $src2, (signed short)0xF6DF\n\t&quot;
12487             &quot;ORI     $src2, $src2, 0xFFF8\n\t&quot;
12488             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12489             &quot;BGT     $crx, done\n\t&quot;
12490             &quot;LIS     $src2, (signed short)0xAAB5\n\t&quot;
12491             &quot;ORI     $src2, $src2, 0xBABA\n\t&quot;
12492             &quot;INSRDI  $src2, $src2, 32, 0\n\t&quot;
12493             &quot;CMPEQB  $crx, 1, $src1, $src2\n&quot;
12494             &quot;done:\n\t&quot;
12495             &quot;SETB    $dst, $crx&quot; %}
12496 
12497   size(48);
12498   ins_encode %{
12499     Label done;
12500     // 0x61: a, 0x7A: z
12501     __ li($src2$$Register, 0x7A61);
12502     // compare src1 with ranges 0x61 to 0x7A
12503     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12504     __ bgt($crx$$CondRegister, done);
12505 
12506     // 0xDF: sharp s, 0xFF: y with diaeresis, 0xF7 is not the lower case
12507     __ lis($src2$$Register, (signed short)0xF6DF);
12508     __ ori($src2$$Register, $src2$$Register, 0xFFF8);
12509     // compare src1 with ranges 0xDF to 0xF6 and 0xF8 to 0xFF
12510     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12511     __ bgt($crx$$CondRegister, done);
12512 
12513     // 0xAA: feminine ordinal indicator
12514     // 0xB5: micro sign
12515     // 0xBA: masculine ordinal indicator
12516     __ lis($src2$$Register, (signed short)0xAAB5);
12517     __ ori($src2$$Register, $src2$$Register, 0xBABA);
12518     __ insrdi($src2$$Register, $src2$$Register, 32, 0);
12519     // compare src1 with 0xAA, 0xB5, and 0xBA
12520     __ cmpeqb($crx$$CondRegister, $src1$$Register, $src2$$Register);
12521 
12522     __ bind(done);
12523     __ setb($dst$$Register, $crx$$CondRegister);
12524   %}
12525   ins_pipe(pipe_class_default);
12526 %}
12527 
12528 instruct cmprb_UpperCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12529   match(Set dst (UpperCase src1));
12530   effect(TEMP src2, TEMP crx);
12531   ins_cost(7 * DEFAULT_COST);
12532 
12533   format %{ &quot;LI      $src2, 0x5A41\n\t&quot;
12534             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12535             &quot;BGT     $crx, done\n\t&quot;
12536             &quot;LIS     $src2, (signed short)0xD6C0\n\t&quot;
12537             &quot;ORI     $src2, $src2, 0xDED8\n\t&quot;
12538             &quot;CMPRB   $crx, 1, $src1, $src2\n&quot;
12539             &quot;done:\n\t&quot;
12540             &quot;SETB    $dst, $crx&quot; %}
12541 
12542   size(28);
12543   ins_encode %{
12544     Label done;
12545     // 0x41: A, 0x5A: Z
12546     __ li($src2$$Register, 0x5A41);
12547     // compare src1 with a range 0x41 to 0x5A
12548     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12549     __ bgt($crx$$CondRegister, done);
12550 
12551     // 0xC0: a with grave, 0xDE: thorn, 0xD7 is not the upper case
12552     __ lis($src2$$Register, (signed short)0xD6C0);
12553     __ ori($src2$$Register, $src2$$Register, 0xDED8);
12554     // compare src1 with ranges 0xC0 to 0xD6 and 0xD8 to 0xDE
12555     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12556 
12557     __ bind(done);
12558     __ setb($dst$$Register, $crx$$CondRegister);
12559   %}
12560   ins_pipe(pipe_class_default);
12561 %}
12562 
12563 instruct cmprb_Whitespace_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12564   match(Set dst (Whitespace src1));
12565   effect(TEMP src2, TEMP crx);
12566   ins_cost(4 * DEFAULT_COST);
12567 
12568   format %{ &quot;LI      $src2, 0x0D09\n\t&quot;
12569             &quot;ADDIS   $src2, 0x201C\n\t&quot;
12570             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12571             &quot;SETB    $dst, $crx&quot; %}
12572   size(16);
12573   ins_encode %{
12574     // 0x09 to 0x0D, 0x1C to 0x20
12575     __ li($src2$$Register, 0x0D09);
12576     __ addis($src2$$Register, $src2$$Register, 0x0201C);
12577     // compare src with ranges 0x09 to 0x0D and 0x1C to 0x20
12578     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12579     __ setb($dst$$Register, $crx$$CondRegister);
12580   %}
12581   ins_pipe(pipe_class_default);
12582 %}
12583 
12584 //----------Branches---------------------------------------------------------
12585 // Jump
12586 
12587 // Direct Branch.
12588 instruct branch(label labl) %{
12589   match(Goto);
12590   effect(USE labl);
12591   ins_cost(BRANCH_COST);
12592 
12593   format %{ &quot;B       $labl&quot; %}
12594   size(4);
12595   ins_encode %{
12596     // TODO: PPC port $archOpcode(ppc64Opcode_b);
12597      Label d;    // dummy
12598      __ bind(d);
12599      Label* p = $labl$$label;
12600      // `p&#39; is `NULL&#39; when this encoding class is used only to
12601      // determine the size of the encoded instruction.
12602      Label&amp; l = (NULL == p)? d : *(p);
12603      __ b(l);
12604   %}
12605   ins_pipe(pipe_class_default);
12606 %}
12607 
12608 // Conditional Near Branch
12609 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12610   // Same match rule as `branchConFar&#39;.
12611   match(If cmp crx);
12612   effect(USE lbl);
12613   ins_cost(BRANCH_COST);
12614 
12615   // If set to 1 this indicates that the current instruction is a
12616   // short variant of a long branch. This avoids using this
12617   // instruction in first-pass matching. It will then only be used in
12618   // the `Shorten_branches&#39; pass.
12619   ins_short_branch(1);
12620 
12621   format %{ &quot;B$cmp     $crx, $lbl&quot; %}
12622   size(4);
12623   ins_encode( enc_bc(crx, cmp, lbl) );
12624   ins_pipe(pipe_class_default);
12625 %}
12626 
12627 // This is for cases when the ppc64 `bc&#39; instruction does not
12628 // reach far enough. So we emit a far branch here, which is more
12629 // expensive.
12630 //
12631 // Conditional Far Branch
12632 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12633   // Same match rule as `branchCon&#39;.
12634   match(If cmp crx);
12635   effect(USE crx, USE lbl);
12636   predicate(!false /* TODO: PPC port HB_Schedule*/);
12637   // Higher cost than `branchCon&#39;.
12638   ins_cost(5*BRANCH_COST);
12639 
12640   // This is not a short variant of a branch, but the long variant.
12641   ins_short_branch(0);
12642 
12643   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12644   size(8);
12645   ins_encode( enc_bc_far(crx, cmp, lbl) );
12646   ins_pipe(pipe_class_default);
12647 %}
12648 
12649 // Conditional Branch used with Power6 scheduler (can be far or short).
12650 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12651   // Same match rule as `branchCon&#39;.
12652   match(If cmp crx);
12653   effect(USE crx, USE lbl);
12654   predicate(false /* TODO: PPC port HB_Schedule*/);
12655   // Higher cost than `branchCon&#39;.
12656   ins_cost(5*BRANCH_COST);
12657 
12658   // Actually size doesn&#39;t depend on alignment but on shortening.
12659   ins_variable_size_depending_on_alignment(true);
12660   // long variant.
12661   ins_short_branch(0);
12662 
12663   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12664   size(8); // worst case
12665   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
12666   ins_pipe(pipe_class_default);
12667 %}
12668 
12669 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
12670   match(CountedLoopEnd cmp crx);
12671   effect(USE labl);
12672   ins_cost(BRANCH_COST);
12673 
12674   // short variant.
12675   ins_short_branch(1);
12676 
12677   format %{ &quot;B$cmp     $crx, $labl \t// counted loop end&quot; %}
12678   size(4);
12679   ins_encode( enc_bc(crx, cmp, labl) );
12680   ins_pipe(pipe_class_default);
12681 %}
12682 
12683 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
12684   match(CountedLoopEnd cmp crx);
12685   effect(USE labl);
12686   predicate(!false /* TODO: PPC port HB_Schedule */);
12687   ins_cost(BRANCH_COST);
12688 
12689   // Long variant.
12690   ins_short_branch(0);
12691 
12692   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12693   size(8);
12694   ins_encode( enc_bc_far(crx, cmp, labl) );
12695   ins_pipe(pipe_class_default);
12696 %}
12697 
12698 // Conditional Branch used with Power6 scheduler (can be far or short).
12699 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
12700   match(CountedLoopEnd cmp crx);
12701   effect(USE labl);
12702   predicate(false /* TODO: PPC port HB_Schedule */);
12703   // Higher cost than `branchCon&#39;.
12704   ins_cost(5*BRANCH_COST);
12705 
12706   // Actually size doesn&#39;t depend on alignment but on shortening.
12707   ins_variable_size_depending_on_alignment(true);
12708   // Long variant.
12709   ins_short_branch(0);
12710 
12711   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12712   size(8); // worst case
12713   ins_encode( enc_bc_short_far(crx, cmp, labl) );
12714   ins_pipe(pipe_class_default);
12715 %}
12716 
12717 // ============================================================================
12718 // Java runtime operations, intrinsics and other complex operations.
12719 
12720 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
12721 // array for an instance of the superklass. Set a hidden internal cache on a
12722 // hit (cache is checked with exposed code in gen_subtype_check()). Return
12723 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
12724 //
12725 // GL TODO: Improve this.
12726 // - result should not be a TEMP
12727 // - Add match rule as on sparc avoiding additional Cmp.
12728 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
12729                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
12730   match(Set result (PartialSubtypeCheck subklass superklass));
12731   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
12732   ins_cost(DEFAULT_COST*10);
12733 
12734   format %{ &quot;PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr&quot; %}
12735   ins_encode %{
12736     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12737     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
12738                                      $tmp_klass$$Register, NULL, $result$$Register);
12739   %}
12740   ins_pipe(pipe_class_default);
12741 %}
12742 
12743 // inlined locking and unlocking
12744 
12745 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
12746   match(Set crx (FastLock oop box));
12747   effect(TEMP tmp1, TEMP tmp2);
12748   predicate(!Compile::current()-&gt;use_rtm());
12749 
12750   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12751   ins_encode %{
12752     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12753     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12754                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
12755                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
12756     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12757     // The compiler generates a branch to the runtime call to
12758     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12759   %}
12760   ins_pipe(pipe_class_compare);
12761 %}
12762 
12763 // Separate version for TM. Use bound register for box to enable USE_KILL.
12764 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12765   match(Set crx (FastLock oop box));
12766   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
12767   predicate(Compile::current()-&gt;use_rtm());
12768 
12769   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)&quot; %}
12770   ins_encode %{
12771     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12772     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12773                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12774                                  /*Biased Locking*/ false,
12775                                  _rtm_counters, _stack_rtm_counters,
12776                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12777                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
12778     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12779     // The compiler generates a branch to the runtime call to
12780     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12781   %}
12782   ins_pipe(pipe_class_compare);
12783 %}
12784 
12785 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12786   match(Set crx (FastUnlock oop box));
12787   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12788   predicate(!Compile::current()-&gt;use_rtm());
12789 
12790   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12791   ins_encode %{
12792     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12793     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12794                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12795                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
12796                                    false);
12797     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12798     // The compiler generates a branch to the runtime call to
12799     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12800   %}
12801   ins_pipe(pipe_class_compare);
12802 %}
12803 
12804 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12805   match(Set crx (FastUnlock oop box));
12806   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12807   predicate(Compile::current()-&gt;use_rtm());
12808 
12809   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)&quot; %}
12810   ins_encode %{
12811     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12812     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12813                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12814                                    /*Biased Locking*/ false, /*TM*/ true);
12815     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12816     // The compiler generates a branch to the runtime call to
12817     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12818   %}
12819   ins_pipe(pipe_class_compare);
12820 %}
12821 
12822 // Align address.
12823 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
12824   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
12825 
12826   format %{ &quot;ANDDI   $dst, $src, $mask \t// next aligned address&quot; %}
12827   size(4);
12828   ins_encode %{
12829     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
12830     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
12831   %}
12832   ins_pipe(pipe_class_default);
12833 %}
12834 
12835 // Array size computation.
12836 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
12837   match(Set dst (SubL (CastP2X end) (CastP2X start)));
12838 
12839   format %{ &quot;SUB     $dst, $end, $start \t// array size in bytes&quot; %}
12840   size(4);
12841   ins_encode %{
12842     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
12843     __ subf($dst$$Register, $start$$Register, $end$$Register);
12844   %}
12845   ins_pipe(pipe_class_default);
12846 %}
12847 
12848 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
12849 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12850   match(Set dummy (ClearArray cnt base));
12851   effect(USE_KILL base, KILL ctr);
12852   ins_cost(2 * MEMORY_REF_COST);
12853 
12854   format %{ &quot;ClearArray $cnt, $base&quot; %}
12855   ins_encode %{
12856     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12857     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
12858   %}
12859   ins_pipe(pipe_class_default);
12860 %}
12861 
12862 // Clear-array with constant large array length.
12863 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
12864   match(Set dummy (ClearArray cnt base));
12865   effect(USE_KILL base, TEMP tmp, KILL ctr);
12866   ins_cost(3 * MEMORY_REF_COST);
12867 
12868   format %{ &quot;ClearArray $cnt, $base \t// KILL $tmp&quot; %}
12869   ins_encode %{
12870     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12871     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
12872   %}
12873   ins_pipe(pipe_class_default);
12874 %}
12875 
12876 // Clear-array with dynamic array length.
12877 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12878   match(Set dummy (ClearArray cnt base));
12879   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
12880   ins_cost(4 * MEMORY_REF_COST);
12881 
12882   format %{ &quot;ClearArray $cnt, $base&quot; %}
12883   ins_encode %{
12884     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12885     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
12886   %}
12887   ins_pipe(pipe_class_default);
12888 %}
12889 
12890 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12891                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12892   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12893   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12894   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12895   ins_cost(300);
12896   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12897   ins_encode %{
12898     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12899     __ string_compare($str1$$Register, $str2$$Register,
12900                       $cnt1$$Register, $cnt2$$Register,
12901                       $tmp$$Register,
12902                       $result$$Register, StrIntrinsicNode::LL);
12903   %}
12904   ins_pipe(pipe_class_default);
12905 %}
12906 
12907 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12908                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12909   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12910   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12911   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12912   ins_cost(300);
12913   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12914   ins_encode %{
12915     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12916     __ string_compare($str1$$Register, $str2$$Register,
12917                       $cnt1$$Register, $cnt2$$Register,
12918                       $tmp$$Register,
12919                       $result$$Register, StrIntrinsicNode::UU);
12920   %}
12921   ins_pipe(pipe_class_default);
12922 %}
12923 
12924 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12925                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12926   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
12927   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12928   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12929   ins_cost(300);
12930   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12931   ins_encode %{
12932     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12933     __ string_compare($str1$$Register, $str2$$Register,
12934                       $cnt1$$Register, $cnt2$$Register,
12935                       $tmp$$Register,
12936                       $result$$Register, StrIntrinsicNode::LU);
12937   %}
12938   ins_pipe(pipe_class_default);
12939 %}
12940 
12941 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12942                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12943   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12944   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12945   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12946   ins_cost(300);
12947   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12948   ins_encode %{
12949     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12950     __ string_compare($str2$$Register, $str1$$Register,
12951                       $cnt2$$Register, $cnt1$$Register,
12952                       $tmp$$Register,
12953                       $result$$Register, StrIntrinsicNode::UL);
12954   %}
12955   ins_pipe(pipe_class_default);
12956 %}
12957 
12958 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12959                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12960   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12961   match(Set result (StrEquals (Binary str1 str2) cnt));
12962   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12963   ins_cost(300);
12964   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12965   ins_encode %{
12966     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12967     __ array_equals(false, $str1$$Register, $str2$$Register,
12968                     $cnt$$Register, $tmp$$Register,
12969                     $result$$Register, true /* byte */);
12970   %}
12971   ins_pipe(pipe_class_default);
12972 %}
12973 
12974 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12975                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12976   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12977   match(Set result (StrEquals (Binary str1 str2) cnt));
12978   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12979   ins_cost(300);
12980   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12981   ins_encode %{
12982     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12983     __ array_equals(false, $str1$$Register, $str2$$Register,
12984                     $cnt$$Register, $tmp$$Register,
12985                     $result$$Register, false /* byte */);
12986   %}
12987   ins_pipe(pipe_class_default);
12988 %}
12989 
12990 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12991                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12992   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12993   match(Set result (AryEq ary1 ary2));
12994   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12995   ins_cost(300);
12996   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
12997   ins_encode %{
12998     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12999     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13000                     $tmp1$$Register, $tmp2$$Register,
13001                     $result$$Register, true /* byte */);
13002   %}
13003   ins_pipe(pipe_class_default);
13004 %}
13005 
13006 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13007                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13008   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13009   match(Set result (AryEq ary1 ary2));
13010   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13011   ins_cost(300);
13012   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13013   ins_encode %{
13014     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13015     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13016                     $tmp1$$Register, $tmp2$$Register,
13017                     $result$$Register, false /* byte */);
13018   %}
13019   ins_pipe(pipe_class_default);
13020 %}
13021 
13022 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13023                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13024                              iRegIdst tmp1, iRegIdst tmp2,
13025                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13026   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13027   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13028   // Required for EA: check if it is still a type_array.
13029   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13030   ins_cost(150);
13031 
13032   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13033             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13034 
13035   ins_encode %{
13036     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13037     immPOper *needleOper = (immPOper *)$needleImm;
13038     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13039     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13040     jchar chr;
13041 #ifdef VM_LITTLE_ENDIAN
13042     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13043            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13044 #else
13045     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13046            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13047 #endif
13048     __ string_indexof_char($result$$Register,
13049                            $haystack$$Register, $haycnt$$Register,
13050                            R0, chr,
13051                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13052   %}
13053   ins_pipe(pipe_class_compare);
13054 %}
13055 
13056 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13057                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13058                              iRegIdst tmp1, iRegIdst tmp2,
13059                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13060   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13061   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13062   // Required for EA: check if it is still a type_array.
13063   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13064   ins_cost(150);
13065 
13066   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13067             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13068 
13069   ins_encode %{
13070     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13071     immPOper *needleOper = (immPOper *)$needleImm;
13072     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13073     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13074     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13075     __ string_indexof_char($result$$Register,
13076                            $haystack$$Register, $haycnt$$Register,
13077                            R0, chr,
13078                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13079   %}
13080   ins_pipe(pipe_class_compare);
13081 %}
13082 
13083 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13084                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
13085                               iRegIdst tmp1, iRegIdst tmp2,
13086                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13087   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13088   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13089   // Required for EA: check if it is still a type_array.
13090   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13091   ins_cost(150);
13092 
13093   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13094             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13095 
13096   ins_encode %{
13097     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13098     immPOper *needleOper = (immPOper *)$needleImm;
13099     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13100     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13101     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13102     __ string_indexof_char($result$$Register,
13103                            $haystack$$Register, $haycnt$$Register,
13104                            R0, chr,
13105                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13106   %}
13107   ins_pipe(pipe_class_compare);
13108 %}
13109 
13110 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13111                         rscratch2RegP needle, immI_1 needlecntImm,
13112                         iRegIdst tmp1, iRegIdst tmp2,
13113                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13114   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13115   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13116   // Required for EA: check if it is still a type_array.
13117   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13118             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13119             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13120   ins_cost(180);
13121 
13122   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13123             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13124   ins_encode %{
13125     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13126     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13127     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13128     guarantee(needle_values, &quot;sanity&quot;);
13129     jchar chr;
13130 #ifdef VM_LITTLE_ENDIAN
13131     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13132            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13133 #else
13134     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13135            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13136 #endif
13137     __ string_indexof_char($result$$Register,
13138                            $haystack$$Register, $haycnt$$Register,
13139                            R0, chr,
13140                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13141   %}
13142   ins_pipe(pipe_class_compare);
13143 %}
13144 
13145 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13146                         rscratch2RegP needle, immI_1 needlecntImm,
13147                         iRegIdst tmp1, iRegIdst tmp2,
13148                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13149   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13150   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13151   // Required for EA: check if it is still a type_array.
13152   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13153             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13154             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13155   ins_cost(180);
13156 
13157   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13158             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13159   ins_encode %{
13160     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13161     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13162     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13163     guarantee(needle_values, &quot;sanity&quot;);
13164     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13165     __ string_indexof_char($result$$Register,
13166                            $haystack$$Register, $haycnt$$Register,
13167                            R0, chr,
13168                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13169   %}
13170   ins_pipe(pipe_class_compare);
13171 %}
13172 
13173 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13174                          rscratch2RegP needle, immI_1 needlecntImm,
13175                          iRegIdst tmp1, iRegIdst tmp2,
13176                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13177   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13178   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13179   // Required for EA: check if it is still a type_array.
13180   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13181             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13182             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13183   ins_cost(180);
13184 
13185   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13186             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13187   ins_encode %{
13188     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13189     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13190     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13191     guarantee(needle_values, &quot;sanity&quot;);
13192     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13193     __ string_indexof_char($result$$Register,
13194                            $haystack$$Register, $haycnt$$Register,
13195                            R0, chr,
13196                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13197   %}
13198   ins_pipe(pipe_class_compare);
13199 %}
13200 
13201 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13202                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
13203                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13204   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
13205   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13206   ins_cost(180);
13207 
13208   format %{ &quot;String IndexOfChar $haystack[0..$haycnt], $ch&quot;
13209             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13210   ins_encode %{
13211     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13212     __ string_indexof_char($result$$Register,
13213                            $haystack$$Register, $haycnt$$Register,
13214                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
13215                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13216   %}
13217   ins_pipe(pipe_class_compare);
13218 %}
13219 
13220 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13221                        iRegPsrc needle, uimmI15 needlecntImm,
13222                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13223                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13224   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13225   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13226          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13227   // Required for EA: check if it is still a type_array.
13228   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13229             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13230             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13231   ins_cost(250);
13232 
13233   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13234             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13235   ins_encode %{
13236     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13237     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13238     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13239 
13240     __ string_indexof($result$$Register,
13241                       $haystack$$Register, $haycnt$$Register,
13242                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13243                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13244   %}
13245   ins_pipe(pipe_class_compare);
13246 %}
13247 
13248 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13249                        iRegPsrc needle, uimmI15 needlecntImm,
13250                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13251                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13252   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13253   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13254          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13255   // Required for EA: check if it is still a type_array.
13256   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13257             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13258             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13259   ins_cost(250);
13260 
13261   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13262             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13263   ins_encode %{
13264     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13265     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13266     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13267 
13268     __ string_indexof($result$$Register,
13269                       $haystack$$Register, $haycnt$$Register,
13270                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13271                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13272   %}
13273   ins_pipe(pipe_class_compare);
13274 %}
13275 
13276 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13277                         iRegPsrc needle, uimmI15 needlecntImm,
13278                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13279                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13280   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13281   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13282          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13283   // Required for EA: check if it is still a type_array.
13284   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13285             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13286             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13287   ins_cost(250);
13288 
13289   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13290             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13291   ins_encode %{
13292     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13293     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13294     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13295 
13296     __ string_indexof($result$$Register,
13297                       $haystack$$Register, $haycnt$$Register,
13298                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13299                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13300   %}
13301   ins_pipe(pipe_class_compare);
13302 %}
13303 
13304 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13305                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13306                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13307   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13308   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13309          TEMP_DEF result,
13310          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13311   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13312   ins_cost(300);
13313 
13314   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13315              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13316   ins_encode %{
13317     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13318     __ string_indexof($result$$Register,
13319                       $haystack$$Register, $haycnt$$Register,
13320                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13321                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13322   %}
13323   ins_pipe(pipe_class_compare);
13324 %}
13325 
13326 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13327                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13328                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13329   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13330   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13331          TEMP_DEF result,
13332          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13333   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13334   ins_cost(300);
13335 
13336   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13337              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13338   ins_encode %{
13339     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13340     __ string_indexof($result$$Register,
13341                       $haystack$$Register, $haycnt$$Register,
13342                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13343                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13344   %}
13345   ins_pipe(pipe_class_compare);
13346 %}
13347 
13348 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13349                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13350                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13351   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13352   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13353          TEMP_DEF result,
13354          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13355   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13356   ins_cost(300);
13357 
13358   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13359              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13360   ins_encode %{
13361     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13362     __ string_indexof($result$$Register,
13363                       $haystack$$Register, $haycnt$$Register,
13364                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13365                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13366   %}
13367   ins_pipe(pipe_class_compare);
13368 %}
13369 
13370 // char[] to byte[] compression
13371 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13372                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13373   match(Set result (StrCompressedCopy src (Binary dst len)));
13374   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13375          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13376   ins_cost(300);
13377   format %{ &quot;String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13378   ins_encode %{
13379     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13380     Label Lskip, Ldone;
13381     __ li($result$$Register, 0);
13382     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13383                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
13384     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13385     __ beq(CCR0, Lskip);
13386     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
13387     __ bind(Lskip);
13388     __ mr($result$$Register, $len$$Register);
13389     __ bind(Ldone);
13390   %}
13391   ins_pipe(pipe_class_default);
13392 %}
13393 
13394 // byte[] to char[] inflation
13395 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
13396                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13397   match(Set dummy (StrInflatedCopy src (Binary dst len)));
13398   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13399   ins_cost(300);
13400   format %{ &quot;String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13401   ins_encode %{
13402     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13403     Label Ldone;
13404     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13405                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
13406     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13407     __ beq(CCR0, Ldone);
13408     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
13409     __ bind(Ldone);
13410   %}
13411   ins_pipe(pipe_class_default);
13412 %}
13413 
13414 // StringCoding.java intrinsics
13415 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
13416                        regCTR ctr, flagsRegCR0 cr0)
13417 %{
13418   match(Set result (HasNegatives ary1 len));
13419   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
13420   ins_cost(300);
13421   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2&quot; %}
13422   ins_encode %{
13423     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13424     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
13425                      $tmp1$$Register, $tmp2$$Register);
13426   %}
13427   ins_pipe(pipe_class_default);
13428 %}
13429 
13430 // encode char[] to byte[] in ISO_8859_1
13431 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13432                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13433   match(Set result (EncodeISOArray src (Binary dst len)));
13434   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13435          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13436   ins_cost(300);
13437   format %{ &quot;Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13438   ins_encode %{
13439     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13440     Label Lslow, Lfailure1, Lfailure2, Ldone;
13441     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13442                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
13443     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13444     __ beq(CCR0, Ldone);
13445     __ bind(Lslow);
13446     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
13447     __ li($result$$Register, 0);
13448     __ b(Ldone);
13449 
13450     __ bind(Lfailure1);
13451     __ mr($result$$Register, $len$$Register);
13452     __ mfctr($tmp1$$Register);
13453     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
13454     __ beq(CCR0, Ldone);
13455     __ b(Lslow);
13456 
13457     __ bind(Lfailure2);
13458     __ mfctr($result$$Register); // Remaining characters.
13459 
13460     __ bind(Ldone);
13461     __ subf($result$$Register, $result$$Register, $len$$Register);
13462   %}
13463   ins_pipe(pipe_class_default);
13464 %}
13465 
13466 
13467 //---------- Min/Max Instructions ---------------------------------------------
13468 
13469 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13470   match(Set dst (MinI src1 src2));
13471   ins_cost(DEFAULT_COST*6);
13472 
13473   expand %{
13474     iRegLdst src1s;
13475     iRegLdst src2s;
13476     iRegLdst diff;
13477     iRegLdst sm;
13478     iRegLdst doz; // difference or zero
13479     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13480     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13481     subL_reg_reg(diff, src2s, src1s);
13482     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13483     signmask64L_regL(sm, diff);
13484     andL_reg_reg(doz, diff, sm); // &lt;=0
13485     addI_regL_regL(dst, doz, src1s);
13486   %}
13487 %}
13488 
13489 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13490   match(Set dst (MinI src1 src2));
13491   effect(KILL cr0);
13492   predicate(VM_Version::has_isel());
13493   ins_cost(DEFAULT_COST*2);
13494 
13495   ins_encode %{
13496     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13497     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13498     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
13499   %}
13500   ins_pipe(pipe_class_default);
13501 %}
13502 
13503 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13504   match(Set dst (MaxI src1 src2));
13505   ins_cost(DEFAULT_COST*6);
13506 
13507   expand %{
13508     iRegLdst src1s;
13509     iRegLdst src2s;
13510     iRegLdst diff;
13511     iRegLdst sm;
13512     iRegLdst doz; // difference or zero
13513     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13514     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13515     subL_reg_reg(diff, src2s, src1s);
13516     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13517     signmask64L_regL(sm, diff);
13518     andcL_reg_reg(doz, diff, sm); // &gt;=0
13519     addI_regL_regL(dst, doz, src1s);
13520   %}
13521 %}
13522 
13523 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13524   match(Set dst (MaxI src1 src2));
13525   effect(KILL cr0);
13526   predicate(VM_Version::has_isel());
13527   ins_cost(DEFAULT_COST*2);
13528 
13529   ins_encode %{
13530     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13531     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13532     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
13533   %}
13534   ins_pipe(pipe_class_default);
13535 %}
13536 
13537 //---------- Population Count Instructions ------------------------------------
13538 
13539 // Popcnt for Power7.
13540 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
13541   match(Set dst (PopCountI src));
13542   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13543   ins_cost(DEFAULT_COST);
13544 
13545   format %{ &quot;POPCNTW $dst, $src&quot; %}
13546   size(4);
13547   ins_encode %{
13548     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13549     __ popcntw($dst$$Register, $src$$Register);
13550   %}
13551   ins_pipe(pipe_class_default);
13552 %}
13553 
13554 // Popcnt for Power7.
13555 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
13556   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13557   match(Set dst (PopCountL src));
13558   ins_cost(DEFAULT_COST);
13559 
13560   format %{ &quot;POPCNTD $dst, $src&quot; %}
13561   size(4);
13562   ins_encode %{
13563     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13564     __ popcntd($dst$$Register, $src$$Register);
13565   %}
13566   ins_pipe(pipe_class_default);
13567 %}
13568 
13569 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
13570   match(Set dst (CountLeadingZerosI src));
13571   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13572   ins_cost(DEFAULT_COST);
13573 
13574   format %{ &quot;CNTLZW  $dst, $src&quot; %}
13575   size(4);
13576   ins_encode %{
13577     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
13578     __ cntlzw($dst$$Register, $src$$Register);
13579   %}
13580   ins_pipe(pipe_class_default);
13581 %}
13582 
13583 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
13584   match(Set dst (CountLeadingZerosL src));
13585   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13586   ins_cost(DEFAULT_COST);
13587 
13588   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13589   size(4);
13590   ins_encode %{
13591     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13592     __ cntlzd($dst$$Register, $src$$Register);
13593   %}
13594   ins_pipe(pipe_class_default);
13595 %}
13596 
13597 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
13598   // no match-rule, false predicate
13599   effect(DEF dst, USE src);
13600   predicate(false);
13601 
13602   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13603   size(4);
13604   ins_encode %{
13605     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13606     __ cntlzd($dst$$Register, $src$$Register);
13607   %}
13608   ins_pipe(pipe_class_default);
13609 %}
13610 
13611 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
13612   match(Set dst (CountTrailingZerosI src));
13613   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13614   ins_cost(DEFAULT_COST);
13615 
13616   expand %{
13617     immI16 imm1 %{ (int)-1 %}
13618     immI16 imm2 %{ (int)32 %}
13619     immI_minus1 m1 %{ -1 %}
13620     iRegIdst tmpI1;
13621     iRegIdst tmpI2;
13622     iRegIdst tmpI3;
13623     addI_reg_imm16(tmpI1, src, imm1);
13624     andcI_reg_reg(tmpI2, src, m1, tmpI1);
13625     countLeadingZerosI(tmpI3, tmpI2);
13626     subI_imm16_reg(dst, imm2, tmpI3);
13627   %}
13628 %}
13629 
13630 instruct countTrailingZerosI_cnttzw(iRegIdst dst, iRegIsrc src) %{
13631   match(Set dst (CountTrailingZerosI src));
13632   predicate(UseCountTrailingZerosInstructionsPPC64);
13633   ins_cost(DEFAULT_COST);
13634 
13635   format %{ &quot;CNTTZW  $dst, $src&quot; %}
13636   size(4);
13637   ins_encode %{
13638     __ cnttzw($dst$$Register, $src$$Register);
13639   %}
13640   ins_pipe(pipe_class_default);
13641 %}
13642 
13643 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
13644   match(Set dst (CountTrailingZerosL src));
13645   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13646   ins_cost(DEFAULT_COST);
13647 
13648   expand %{
13649     immL16 imm1 %{ (long)-1 %}
13650     immI16 imm2 %{ (int)64 %}
13651     iRegLdst tmpL1;
13652     iRegLdst tmpL2;
13653     iRegIdst tmpL3;
13654     addL_reg_imm16(tmpL1, src, imm1);
13655     andcL_reg_reg(tmpL2, tmpL1, src);
13656     countLeadingZerosL(tmpL3, tmpL2);
13657     subI_imm16_reg(dst, imm2, tmpL3);
13658  %}
13659 %}
13660 
13661 instruct countTrailingZerosL_cnttzd(iRegIdst dst, iRegLsrc src) %{
13662   match(Set dst (CountTrailingZerosL src));
13663   predicate(UseCountTrailingZerosInstructionsPPC64);
13664   ins_cost(DEFAULT_COST);
13665 
13666   format %{ &quot;CNTTZD  $dst, $src&quot; %}
13667   size(4);
13668   ins_encode %{
13669     __ cnttzd($dst$$Register, $src$$Register);
13670   %}
13671   ins_pipe(pipe_class_default);
13672 %}
13673 
13674 // Expand nodes for byte_reverse_int.
13675 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13676   effect(DEF dst, USE src, USE pos, USE shift);
13677   predicate(false);
13678 
13679   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13680   size(4);
13681   ins_encode %{
13682     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13683     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13684   %}
13685   ins_pipe(pipe_class_default);
13686 %}
13687 
13688 // As insrwi_a, but with USE_DEF.
13689 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13690   effect(USE_DEF dst, USE src, USE pos, USE shift);
13691   predicate(false);
13692 
13693   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13694   size(4);
13695   ins_encode %{
13696     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13697     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13698   %}
13699   ins_pipe(pipe_class_default);
13700 %}
13701 
13702 // Just slightly faster than java implementation.
13703 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
13704   match(Set dst (ReverseBytesI src));
13705   ins_cost(7*DEFAULT_COST);
13706 
13707   expand %{
13708     immI16 imm24 %{ (int) 24 %}
13709     immI16 imm16 %{ (int) 16 %}
13710     immI16  imm8 %{ (int)  8 %}
13711     immI16  imm4 %{ (int)  4 %}
13712     immI16  imm0 %{ (int)  0 %}
13713     iRegLdst tmpI1;
13714     iRegLdst tmpI2;
13715     iRegLdst tmpI3;
13716 
13717     urShiftI_reg_imm(tmpI1, src, imm24);
13718     insrwi_a(dst, tmpI1, imm24, imm8);
13719     urShiftI_reg_imm(tmpI2, src, imm16);
13720     insrwi(dst, tmpI2, imm8, imm16);
13721     urShiftI_reg_imm(tmpI3, src, imm8);
13722     insrwi(dst, tmpI3, imm8, imm8);
13723     insrwi(dst, src, imm0, imm8);
13724   %}
13725 %}
13726 
13727 instruct bytes_reverse_long_Ex(iRegLdst dst, iRegLsrc src) %{
13728   match(Set dst (ReverseBytesL src));
13729   ins_cost(15*DEFAULT_COST);
13730 
13731   expand %{
13732     immI16 imm56 %{ (int) 56 %}
13733     immI16 imm48 %{ (int) 48 %}
13734     immI16 imm40 %{ (int) 40 %}
13735     immI16 imm32 %{ (int) 32 %}
13736     immI16 imm24 %{ (int) 24 %}
13737     immI16 imm16 %{ (int) 16 %}
13738     immI16  imm8 %{ (int)  8 %}
13739     immI16  imm0 %{ (int)  0 %}
13740     iRegLdst tmpL1;
13741     iRegLdst tmpL2;
13742     iRegLdst tmpL3;
13743     iRegLdst tmpL4;
13744     iRegLdst tmpL5;
13745     iRegLdst tmpL6;
13746 
13747                                         // src   : |a|b|c|d|e|f|g|h|
13748     rldicl(tmpL1, src, imm8, imm24);    // tmpL1 : | | | |e|f|g|h|a|
13749     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |a| | | |e|
13750     rldicl(tmpL3, tmpL2, imm32, imm0);  // tmpL3 : | | | |e| | | |a|
13751     rldicl(tmpL1, src, imm16, imm24);   // tmpL1 : | | | |f|g|h|a|b|
13752     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |b| | | |f|
13753     rldicl(tmpL4, tmpL2, imm40, imm0);  // tmpL4 : | | |f| | | |b| |
13754     orL_reg_reg(tmpL5, tmpL3, tmpL4);   // tmpL5 : | | |f|e| | |b|a|
13755     rldicl(tmpL1, src, imm24, imm24);   // tmpL1 : | | | |g|h|a|b|c|
13756     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |c| | | |g|
13757     rldicl(tmpL3, tmpL2, imm48, imm0);  // tmpL3 : | |g| | | |c| | |
13758     rldicl(tmpL1, src, imm32, imm24);   // tmpL1 : | | | |h|a|b|c|d|
13759     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |d| | | |h|
13760     rldicl(tmpL4, tmpL2, imm56, imm0);  // tmpL4 : |h| | | |d| | | |
13761     orL_reg_reg(tmpL6, tmpL3, tmpL4);   // tmpL6 : |h|g| | |d|c| | |
13762     orL_reg_reg(dst, tmpL5, tmpL6);     // dst   : |h|g|f|e|d|c|b|a|
13763   %}
13764 %}
13765 
13766 instruct bytes_reverse_ushort_Ex(iRegIdst dst, iRegIsrc src) %{
13767   match(Set dst (ReverseBytesUS src));
13768   ins_cost(2*DEFAULT_COST);
13769 
13770   expand %{
13771     immI16  imm16 %{ (int) 16 %}
13772     immI16   imm8 %{ (int)  8 %}
13773 
13774     urShiftI_reg_imm(dst, src, imm8);
13775     insrwi(dst, src, imm16, imm8);
13776   %}
13777 %}
13778 
13779 instruct bytes_reverse_short_Ex(iRegIdst dst, iRegIsrc src) %{
13780   match(Set dst (ReverseBytesS src));
13781   ins_cost(3*DEFAULT_COST);
13782 
13783   expand %{
13784     immI16  imm16 %{ (int) 16 %}
13785     immI16   imm8 %{ (int)  8 %}
13786     iRegLdst tmpI1;
13787 
13788     urShiftI_reg_imm(tmpI1, src, imm8);
13789     insrwi(tmpI1, src, imm16, imm8);
13790     extsh(dst, tmpI1);
13791   %}
13792 %}
13793 
13794 // Load Integer reversed byte order
13795 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
13796   match(Set dst (ReverseBytesI (LoadI mem)));
13797   ins_cost(MEMORY_REF_COST);
13798 
13799   size(4);
13800   ins_encode %{
13801     __ lwbrx($dst$$Register, $mem$$Register);
13802   %}
13803   ins_pipe(pipe_class_default);
13804 %}
13805 
13806 // Load Long - aligned and reversed
13807 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
13808   match(Set dst (ReverseBytesL (LoadL mem)));
13809   predicate(VM_Version::has_ldbrx());
13810   ins_cost(MEMORY_REF_COST);
13811 
13812   size(4);
13813   ins_encode %{
13814     __ ldbrx($dst$$Register, $mem$$Register);
13815   %}
13816   ins_pipe(pipe_class_default);
13817 %}
13818 
13819 // Load unsigned short / char reversed byte order
13820 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
13821   match(Set dst (ReverseBytesUS (LoadUS mem)));
13822   ins_cost(MEMORY_REF_COST);
13823 
13824   size(4);
13825   ins_encode %{
13826     __ lhbrx($dst$$Register, $mem$$Register);
13827   %}
13828   ins_pipe(pipe_class_default);
13829 %}
13830 
13831 // Load short reversed byte order
13832 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
13833   match(Set dst (ReverseBytesS (LoadS mem)));
13834   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
13835 
13836   size(8);
13837   ins_encode %{
13838     __ lhbrx($dst$$Register, $mem$$Register);
13839     __ extsh($dst$$Register, $dst$$Register);
13840   %}
13841   ins_pipe(pipe_class_default);
13842 %}
13843 
13844 // Store Integer reversed byte order
13845 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
13846   match(Set mem (StoreI mem (ReverseBytesI src)));
13847   ins_cost(MEMORY_REF_COST);
13848 
13849   size(4);
13850   ins_encode %{
13851     __ stwbrx($src$$Register, $mem$$Register);
13852   %}
13853   ins_pipe(pipe_class_default);
13854 %}
13855 
13856 // Store Long reversed byte order
13857 instruct storeL_reversed(iRegLsrc src, indirect mem) %{
13858   match(Set mem (StoreL mem (ReverseBytesL src)));
13859   predicate(VM_Version::has_stdbrx());
13860   ins_cost(MEMORY_REF_COST);
13861 
13862   size(4);
13863   ins_encode %{
13864     __ stdbrx($src$$Register, $mem$$Register);
13865   %}
13866   ins_pipe(pipe_class_default);
13867 %}
13868 
13869 // Store unsigned short / char reversed byte order
13870 instruct storeUS_reversed(iRegIsrc src, indirect mem) %{
13871   match(Set mem (StoreC mem (ReverseBytesUS src)));
13872   ins_cost(MEMORY_REF_COST);
13873 
13874   size(4);
13875   ins_encode %{
13876     __ sthbrx($src$$Register, $mem$$Register);
13877   %}
13878   ins_pipe(pipe_class_default);
13879 %}
13880 
13881 // Store short reversed byte order
13882 instruct storeS_reversed(iRegIsrc src, indirect mem) %{
13883   match(Set mem (StoreC mem (ReverseBytesS src)));
13884   ins_cost(MEMORY_REF_COST);
13885 
13886   size(4);
13887   ins_encode %{
13888     __ sthbrx($src$$Register, $mem$$Register);
13889   %}
13890   ins_pipe(pipe_class_default);
13891 %}
13892 
13893 instruct mtvsrwz(vecX temp1, iRegIsrc src) %{
13894   effect(DEF temp1, USE src);
13895 
13896   format %{ &quot;MTVSRWZ $temp1, $src \t// Move to 16-byte register&quot; %}
13897   size(4);
13898   ins_encode %{
13899     __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);
13900   %}
13901   ins_pipe(pipe_class_default);
13902 %}
13903 
13904 instruct xxspltw(vecX dst, vecX src, immI8 imm1) %{
13905   effect(DEF dst, USE src, USE imm1);
13906 
13907   format %{ &quot;XXSPLTW $dst, $src, $imm1 \t// Splat word&quot; %}
13908   size(4);
13909   ins_encode %{
13910     __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);
13911   %}
13912   ins_pipe(pipe_class_default);
13913 %}
13914 
13915 instruct xscvdpspn_regF(vecX dst, regF src) %{
13916   effect(DEF dst, USE src);
13917 
13918   format %{ &quot;XSCVDPSPN $dst, $src \t// Convert scalar single precision to vector single precision&quot; %}
13919   size(4);
13920   ins_encode %{
13921     __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr());
13922   %}
13923   ins_pipe(pipe_class_default);
13924 %}
13925 
13926 //---------- Replicate Vector Instructions ------------------------------------
13927 
13928 // Insrdi does replicate if src == dst.
13929 instruct repl32(iRegLdst dst) %{
13930   predicate(false);
13931   effect(USE_DEF dst);
13932 
13933   format %{ &quot;INSRDI  $dst, #0, $dst, #32 \t// replicate&quot; %}
13934   size(4);
13935   ins_encode %{
13936     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13937     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
13938   %}
13939   ins_pipe(pipe_class_default);
13940 %}
13941 
13942 // Insrdi does replicate if src == dst.
13943 instruct repl48(iRegLdst dst) %{
13944   predicate(false);
13945   effect(USE_DEF dst);
13946 
13947   format %{ &quot;INSRDI  $dst, #0, $dst, #48 \t// replicate&quot; %}
13948   size(4);
13949   ins_encode %{
13950     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13951     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
13952   %}
13953   ins_pipe(pipe_class_default);
13954 %}
13955 
13956 // Insrdi does replicate if src == dst.
13957 instruct repl56(iRegLdst dst) %{
13958   predicate(false);
13959   effect(USE_DEF dst);
13960 
13961   format %{ &quot;INSRDI  $dst, #0, $dst, #56 \t// replicate&quot; %}
13962   size(4);
13963   ins_encode %{
13964     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13965     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
13966   %}
13967   ins_pipe(pipe_class_default);
13968 %}
13969 
13970 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
13971   match(Set dst (ReplicateB src));
13972   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13973   expand %{
13974     moveReg(dst, src);
13975     repl56(dst);
13976     repl48(dst);
13977     repl32(dst);
13978   %}
13979 %}
13980 
13981 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
13982   match(Set dst (ReplicateB zero));
13983   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13984   format %{ &quot;LI      $dst, #0 \t// replicate8B&quot; %}
13985   size(4);
13986   ins_encode %{
13987     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
13988     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
13989   %}
13990   ins_pipe(pipe_class_default);
13991 %}
13992 
13993 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
13994   match(Set dst (ReplicateB src));
13995   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13996   format %{ &quot;LI      $dst, #-1 \t// replicate8B&quot; %}
13997   size(4);
13998   ins_encode %{
13999     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14000     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14001   %}
14002   ins_pipe(pipe_class_default);
14003 %}
14004 
14005 instruct repl16B_reg_Ex(vecX dst, iRegIsrc src) %{
14006   match(Set dst (ReplicateB src));
14007   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14008 
14009   expand %{
14010     iRegLdst tmpL;
14011     vecX tmpV;
14012     immI8  imm1 %{ (int)  1 %}
14013     moveReg(tmpL, src);
14014     repl56(tmpL);
14015     repl48(tmpL);
14016     mtvsrwz(tmpV, tmpL);
14017     xxspltw(dst, tmpV, imm1);
14018   %}
14019 %}
14020 
14021 instruct repl16B_immI0(vecX dst, immI_0 zero) %{
14022   match(Set dst (ReplicateB zero));
14023   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14024 
14025   format %{ &quot;XXLXOR      $dst, $zero \t// replicate16B&quot; %}
14026   size(4);
14027   ins_encode %{
14028     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14029   %}
14030   ins_pipe(pipe_class_default);
14031 %}
14032 
14033 instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{
14034   match(Set dst (ReplicateB src));
14035   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14036 
14037   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}
14038   size(4);
14039   ins_encode %{
14040     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14041   %}
14042   ins_pipe(pipe_class_default);
14043 %}
14044 
14045 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14046   match(Set dst (ReplicateS src));
14047   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14048   expand %{
14049     moveReg(dst, src);
14050     repl48(dst);
14051     repl32(dst);
14052   %}
14053 %}
14054 
14055 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14056   match(Set dst (ReplicateS zero));
14057   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14058   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}
14059   size(4);
14060   ins_encode %{
14061     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14062     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14063   %}
14064   ins_pipe(pipe_class_default);
14065 %}
14066 
14067 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14068   match(Set dst (ReplicateS src));
14069   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14070   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}
14071   size(4);
14072   ins_encode %{
14073     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14074     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14075   %}
14076   ins_pipe(pipe_class_default);
14077 %}
14078 
14079 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14080   match(Set dst (ReplicateS src));
14081   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14082 
14083   expand %{
14084     iRegLdst tmpL;
14085     vecX tmpV;
14086     immI8  zero %{ (int)  0 %}
14087     moveReg(tmpL, src);
14088     repl48(tmpL);
14089     repl32(tmpL);
14090     mtvsrd(tmpV, tmpL);
14091     xxpermdi(dst, tmpV, tmpV, zero);
14092   %}
14093 %}
14094 
14095 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14096   match(Set dst (ReplicateS zero));
14097   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14098 
14099   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14100   size(4);
14101   ins_encode %{
14102     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14103   %}
14104   ins_pipe(pipe_class_default);
14105 %}
14106 
14107 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14108   match(Set dst (ReplicateS src));
14109   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14110 
14111   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}
14112   size(4);
14113   ins_encode %{
14114     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14115   %}
14116   ins_pipe(pipe_class_default);
14117 %}
14118 
14119 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14120   match(Set dst (ReplicateI src));
14121   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14122   ins_cost(2 * DEFAULT_COST);
14123   expand %{
14124     moveReg(dst, src);
14125     repl32(dst);
14126   %}
14127 %}
14128 
14129 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14130   match(Set dst (ReplicateI zero));
14131   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14132   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}
14133   size(4);
14134   ins_encode %{
14135     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14136     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14137   %}
14138   ins_pipe(pipe_class_default);
14139 %}
14140 
14141 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14142   match(Set dst (ReplicateI src));
14143   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14144   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}
14145   size(4);
14146   ins_encode %{
14147     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14148     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14149   %}
14150   ins_pipe(pipe_class_default);
14151 %}
14152 
14153 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14154   match(Set dst (ReplicateI src));
14155   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14156   ins_cost(2 * DEFAULT_COST);
14157 
14158   expand %{
14159     iRegLdst tmpL;
14160     vecX tmpV;
14161     immI8  zero %{ (int)  0 %}
14162     moveReg(tmpL, src);
14163     repl32(tmpL);
14164     mtvsrd(tmpV, tmpL);
14165     xxpermdi(dst, tmpV, tmpV, zero);
14166   %}
14167 %}
14168 
14169 instruct repl4I_immI0(vecX dst, immI_0 zero) %{
14170   match(Set dst (ReplicateI zero));
14171   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14172 
14173   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4I&quot; %}
14174   size(4);
14175   ins_encode %{
14176     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14177   %}
14178   ins_pipe(pipe_class_default);
14179 %}
14180 
14181 instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
14182   match(Set dst (ReplicateI src));
14183   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14184 
14185   format %{ &quot;XXLEQV      $dst, $dst, $dst \t// replicate4I&quot; %}
14186   size(4);
14187   ins_encode %{
14188     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14189   %}
14190   ins_pipe(pipe_class_default);
14191 %}
14192 
14193 // Move float to int register via stack, replicate.
14194 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
14195   match(Set dst (ReplicateF src));
14196   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14197   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
14198   expand %{
14199     stackSlotL tmpS;
14200     iRegIdst tmpI;
14201     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
14202     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
14203     moveReg(dst, tmpI);             // Move int to long reg.
14204     repl32(dst);                    // Replicate bitpattern.
14205   %}
14206 %}
14207 
14208 // Replicate scalar constant to packed float values in Double register
14209 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
14210   match(Set dst (ReplicateF src));
14211   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14212   ins_cost(5 * DEFAULT_COST);
14213 
14214   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded&quot; %}
14215   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
14216 %}
14217 
14218 // Replicate scalar zero constant to packed float values in Double register
14219 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
14220   match(Set dst (ReplicateF zero));
14221   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14222 
14223   format %{ &quot;LI      $dst, #0 \t// replicate2F&quot; %}
14224   ins_encode %{
14225     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14226     __ li($dst$$Register, 0x0);
14227   %}
14228   ins_pipe(pipe_class_default);
14229 %}
14230 
14231 
14232 //----------Vector Arithmetic Instructions--------------------------------------
14233 
14234 // Vector Addition Instructions
14235 
14236 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
14237   match(Set dst (AddVB src1 src2));
14238   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14239   format %{ &quot;VADDUBM  $dst,$src1,$src2\t// add packed16B&quot; %}
14240   size(4);
14241   ins_encode %{
14242     __ vaddubm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14243   %}
14244   ins_pipe(pipe_class_default);
14245 %}
14246 
14247 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
14248   match(Set dst (AddVS src1 src2));
14249   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14250   format %{ &quot;VADDUHM  $dst,$src1,$src2\t// add packed8S&quot; %}
14251   size(4);
14252   ins_encode %{
14253     __ vadduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14254   %}
14255   ins_pipe(pipe_class_default);
14256 %}
14257 
14258 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
14259   match(Set dst (AddVI src1 src2));
14260   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14261   format %{ &quot;VADDUWM  $dst,$src1,$src2\t// add packed4I&quot; %}
14262   size(4);
14263   ins_encode %{
14264     __ vadduwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14265   %}
14266   ins_pipe(pipe_class_default);
14267 %}
14268 
14269 instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{
14270   match(Set dst (AddVF src1 src2));
14271   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14272   format %{ &quot;VADDFP  $dst,$src1,$src2\t// add packed4F&quot; %}
14273   size(4);
14274   ins_encode %{
14275     __ vaddfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14276   %}
14277   ins_pipe(pipe_class_default);
14278 %}
14279 
14280 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
14281   match(Set dst (AddVL src1 src2));
14282   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14283   format %{ &quot;VADDUDM  $dst,$src1,$src2\t// add packed2L&quot; %}
14284   size(4);
14285   ins_encode %{
14286     __ vaddudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14287   %}
14288   ins_pipe(pipe_class_default);
14289 %}
14290 
14291 instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
14292   match(Set dst (AddVD src1 src2));
14293   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14294   format %{ &quot;XVADDDP  $dst,$src1,$src2\t// add packed2D&quot; %}
14295   size(4);
14296   ins_encode %{
14297     __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14298   %}
14299   ins_pipe(pipe_class_default);
14300 %}
14301 
14302 // Vector Subtraction Instructions
14303 
14304 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
14305   match(Set dst (SubVB src1 src2));
14306   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14307   format %{ &quot;VSUBUBM  $dst,$src1,$src2\t// sub packed16B&quot; %}
14308   size(4);
14309   ins_encode %{
14310     __ vsububm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14311   %}
14312   ins_pipe(pipe_class_default);
14313 %}
14314 
14315 instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{
14316   match(Set dst (SubVS src1 src2));
14317   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14318   format %{ &quot;VSUBUHM  $dst,$src1,$src2\t// sub packed8S&quot; %}
14319   size(4);
14320   ins_encode %{
14321     __ vsubuhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14322   %}
14323   ins_pipe(pipe_class_default);
14324 %}
14325 
14326 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
14327   match(Set dst (SubVI src1 src2));
14328   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14329   format %{ &quot;VSUBUWM  $dst,$src1,$src2\t// sub packed4I&quot; %}
14330   size(4);
14331   ins_encode %{
14332     __ vsubuwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14333   %}
14334   ins_pipe(pipe_class_default);
14335 %}
14336 
14337 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
14338   match(Set dst (SubVF src1 src2));
14339   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14340   format %{ &quot;VSUBFP  $dst,$src1,$src2\t// sub packed4F&quot; %}
14341   size(4);
14342   ins_encode %{
14343     __ vsubfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14344   %}
14345   ins_pipe(pipe_class_default);
14346 %}
14347 
14348 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
14349   match(Set dst (SubVL src1 src2));
14350   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14351   format %{ &quot;VSUBUDM  $dst,$src1,$src2\t// sub packed2L&quot; %}
14352   size(4);
14353   ins_encode %{
14354     __ vsubudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14355   %}
14356   ins_pipe(pipe_class_default);
14357 %}
14358 
14359 instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{
14360   match(Set dst (SubVD src1 src2));
14361   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14362   format %{ &quot;XVSUBDP  $dst,$src1,$src2\t// sub packed2D&quot; %}
14363   size(4);
14364   ins_encode %{
14365     __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14366   %}
14367   ins_pipe(pipe_class_default);
14368 %}
14369 
14370 // Vector Multiplication Instructions
14371 
14372 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2, vecX tmp) %{
14373   match(Set dst (MulVS src1 src2));
14374   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14375   effect(TEMP tmp);
14376   format %{ &quot;VSPLTISH  $tmp,0\t// mul packed8S&quot; %}
14377   format %{ &quot;VMLADDUHM  $dst,$src1,$src2\t// mul packed8S&quot; %}
14378   size(8);
14379   ins_encode %{
14380     __ vspltish($tmp$$VectorSRegister-&gt;to_vr(), 0);
14381     __ vmladduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr(), $tmp$$VectorSRegister-&gt;to_vr());
14382   %}
14383   ins_pipe(pipe_class_default);
14384 %}
14385 
14386 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
14387   match(Set dst (MulVI src1 src2));
14388   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14389   format %{ &quot;VMULUWM  $dst,$src1,$src2\t// mul packed4I&quot; %}
14390   size(4);
14391   ins_encode %{
14392     __ vmuluwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14393   %}
14394   ins_pipe(pipe_class_default);
14395 %}
14396 
14397 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
14398   match(Set dst (MulVF src1 src2));
14399   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14400   format %{ &quot;XVMULSP  $dst,$src1,$src2\t// mul packed4F&quot; %}
14401   size(4);
14402   ins_encode %{
14403     __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14404   %}
14405   ins_pipe(pipe_class_default);
14406 %}
14407 
14408 instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{
14409   match(Set dst (MulVD src1 src2));
14410   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14411   format %{ &quot;XVMULDP  $dst,$src1,$src2\t// mul packed2D&quot; %}
14412   size(4);
14413   ins_encode %{
14414     __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14415   %}
14416   ins_pipe(pipe_class_default);
14417 %}
14418 
14419 // Vector Division Instructions
14420 
14421 instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{
14422   match(Set dst (DivVF src1 src2));
14423   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14424   format %{ &quot;XVDIVSP  $dst,$src1,$src2\t// div packed4F&quot; %}
14425   size(4);
14426   ins_encode %{
14427     __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14428   %}
14429   ins_pipe(pipe_class_default);
14430 %}
14431 
14432 instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{
14433   match(Set dst (DivVD src1 src2));
14434   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14435   format %{ &quot;XVDIVDP  $dst,$src1,$src2\t// div packed2D&quot; %}
14436   size(4);
14437   ins_encode %{
14438     __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14439   %}
14440   ins_pipe(pipe_class_default);
14441 %}
14442 
14443 // Vector Absolute Instructions
14444 
14445 instruct vabs4F_reg(vecX dst, vecX src) %{
14446   match(Set dst (AbsVF src));
14447   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14448   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14449   size(4);
14450   ins_encode %{
14451     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14452   %}
14453   ins_pipe(pipe_class_default);
14454 %}
14455 
14456 instruct vabs2D_reg(vecX dst, vecX src) %{
14457   match(Set dst (AbsVD src));
14458   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14459   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14460   size(4);
14461   ins_encode %{
14462     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14463   %}
14464   ins_pipe(pipe_class_default);
14465 %}
14466 
14467 // Round Instructions
14468 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
14469   match(Set dst (RoundDoubleMode src rmode));
14470   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}
14471   size(4);
14472   ins_encode %{
14473     switch ($rmode$$constant) {
14474       case RoundDoubleModeNode::rmode_rint:
14475         __ frin($dst$$FloatRegister, $src$$FloatRegister);
14476         break;
14477       case RoundDoubleModeNode::rmode_floor:
14478         __ frim($dst$$FloatRegister, $src$$FloatRegister);
14479         break;
14480       case RoundDoubleModeNode::rmode_ceil:
14481         __ frip($dst$$FloatRegister, $src$$FloatRegister);
14482         break;
14483       default:
14484         ShouldNotReachHere();
14485     }
14486   %}
14487   ins_pipe(pipe_class_default);
14488 %}
14489 
14490 // Vector Round Instructions
14491 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
14492   match(Set dst (RoundDoubleModeV src rmode));
14493   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14494   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}
14495   size(4);
14496   ins_encode %{
14497     switch ($rmode$$constant) {
14498       case RoundDoubleModeNode::rmode_rint:
14499         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
14500         break;
14501       case RoundDoubleModeNode::rmode_floor:
14502         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
14503         break;
14504       case RoundDoubleModeNode::rmode_ceil:
14505         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
14506         break;
14507       default:
14508         ShouldNotReachHere();
14509     }
14510   %}
14511   ins_pipe(pipe_class_default);
14512 %}
14513 
14514 // Vector Negate Instructions
14515 
14516 instruct vneg4F_reg(vecX dst, vecX src) %{
14517   match(Set dst (NegVF src));
14518   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14519   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14520   size(4);
14521   ins_encode %{
14522     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14523   %}
14524   ins_pipe(pipe_class_default);
14525 %}
14526 
14527 instruct vneg2D_reg(vecX dst, vecX src) %{
14528   match(Set dst (NegVD src));
14529   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14530   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14531   size(4);
14532   ins_encode %{
14533     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
14534   %}
14535   ins_pipe(pipe_class_default);
14536 %}
14537 
14538 // Vector Square Root Instructions
14539 
14540 instruct vsqrt4F_reg(vecX dst, vecX src) %{
14541   match(Set dst (SqrtVF src));
14542   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14543   format %{ &quot;XVSQRTSP $dst,$src\t// sqrt packed4F&quot; %}
14544   size(4);
14545   ins_encode %{
14546     __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);
14547   %}
14548   ins_pipe(pipe_class_default);
14549 %}
14550 
14551 instruct vsqrt2D_reg(vecX dst, vecX src) %{
14552   match(Set dst (SqrtVD src));
14553   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14554   format %{ &quot;XVSQRTDP  $dst,$src\t// sqrt packed2D&quot; %}
14555   size(4);
14556   ins_encode %{
14557     __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);
14558   %}
14559   ins_pipe(pipe_class_default);
14560 %}
14561 
14562 // Vector Population Count Instructions
14563 
14564 instruct vpopcnt4I_reg(vecX dst, vecX src) %{
14565   match(Set dst (PopCountVI src));
14566   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14567   format %{ &quot;VPOPCNTW $dst,$src\t// pop count packed4I&quot; %}
14568   size(4);
14569   ins_encode %{
14570     __ vpopcntw($dst$$VectorSRegister-&gt;to_vr(), $src$$VectorSRegister-&gt;to_vr());
14571   %}
14572   ins_pipe(pipe_class_default);
14573 %}
14574 
14575 // --------------------------------- FMA --------------------------------------
14576 // dst + src1 * src2
14577 instruct vfma4F(vecX dst, vecX src1, vecX src2) %{
14578   match(Set dst (FmaVF dst (Binary src1 src2)));
14579   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14580 
14581   format %{ &quot;XVMADDASP   $dst, $src1, $src2&quot; %}
14582 
14583   size(4);
14584   ins_encode %{
14585     __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14586   %}
14587   ins_pipe(pipe_class_default);
14588 %}
14589 
14590 // dst - src1 * src2
14591 instruct vfma4F_neg1(vecX dst, vecX src1, vecX src2) %{
14592   match(Set dst (FmaVF dst (Binary (NegVF src1) src2)));
14593   match(Set dst (FmaVF dst (Binary src1 (NegVF src2))));
14594   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14595 
14596   format %{ &quot;XVNMSUBASP   $dst, $src1, $src2&quot; %}
14597 
14598   size(4);
14599   ins_encode %{
14600     __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14601   %}
14602   ins_pipe(pipe_class_default);
14603 %}
14604 
14605 // - dst + src1 * src2
14606 instruct vfma4F_neg2(vecX dst, vecX src1, vecX src2) %{
14607   match(Set dst (FmaVF (NegVF dst) (Binary src1 src2)));
14608   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14609 
14610   format %{ &quot;XVMSUBASP   $dst, $src1, $src2&quot; %}
14611 
14612   size(4);
14613   ins_encode %{
14614     __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14615   %}
14616   ins_pipe(pipe_class_default);
14617 %}
14618 
14619 // dst + src1 * src2
14620 instruct vfma2D(vecX dst, vecX src1, vecX src2) %{
14621   match(Set dst (FmaVD  dst (Binary src1 src2)));
14622   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14623 
14624   format %{ &quot;XVMADDADP   $dst, $src1, $src2&quot; %}
14625 
14626   size(4);
14627   ins_encode %{
14628     __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14629   %}
14630   ins_pipe(pipe_class_default);
14631 %}
14632 
14633 // dst - src1 * src2
14634 instruct vfma2D_neg1(vecX dst, vecX src1, vecX src2) %{
14635   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
14636   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
14637   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14638 
14639   format %{ &quot;XVNMSUBADP   $dst, $src1, $src2&quot; %}
14640 
14641   size(4);
14642   ins_encode %{
14643     __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14644   %}
14645   ins_pipe(pipe_class_default);
14646 %}
14647 
14648 // - dst + src1 * src2
14649 instruct vfma2D_neg2(vecX dst, vecX src1, vecX src2) %{
14650   match(Set dst (FmaVD (NegVD dst) (Binary src1 src2)));
14651   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14652 
14653   format %{ &quot;XVMSUBADP   $dst, $src1, $src2&quot; %}
14654 
14655   size(4);
14656   ins_encode %{
14657     __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14658   %}
14659   ins_pipe(pipe_class_default);
14660 %}
14661 
14662 //----------Overflow Math Instructions-----------------------------------------
14663 
14664 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
14665 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
14666 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
14667 
14668 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14669   match(Set cr0 (OverflowAddL op1 op2));
14670 
14671   format %{ &quot;add_    $op1, $op2\t# overflow check long&quot; %}
14672   ins_encode %{
14673     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14674     __ li(R0, 0);
14675     __ mtxer(R0); // clear XER.SO
14676     __ addo_(R0, $op1$$Register, $op2$$Register);
14677   %}
14678   ins_pipe(pipe_class_default);
14679 %}
14680 
14681 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14682   match(Set cr0 (OverflowSubL op1 op2));
14683 
14684   format %{ &quot;subfo_  R0, $op2, $op1\t# overflow check long&quot; %}
14685   ins_encode %{
14686     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14687     __ li(R0, 0);
14688     __ mtxer(R0); // clear XER.SO
14689     __ subfo_(R0, $op2$$Register, $op1$$Register);
14690   %}
14691   ins_pipe(pipe_class_default);
14692 %}
14693 
14694 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
14695   match(Set cr0 (OverflowSubL zero op2));
14696 
14697   format %{ &quot;nego_   R0, $op2\t# overflow check long&quot; %}
14698   ins_encode %{
14699     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14700     __ li(R0, 0);
14701     __ mtxer(R0); // clear XER.SO
14702     __ nego_(R0, $op2$$Register);
14703   %}
14704   ins_pipe(pipe_class_default);
14705 %}
14706 
14707 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14708   match(Set cr0 (OverflowMulL op1 op2));
14709 
14710   format %{ &quot;mulldo_ R0, $op1, $op2\t# overflow check long&quot; %}
14711   ins_encode %{
14712     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14713     __ li(R0, 0);
14714     __ mtxer(R0); // clear XER.SO
14715     __ mulldo_(R0, $op1$$Register, $op2$$Register);
14716   %}
14717   ins_pipe(pipe_class_default);
14718 %}
14719 
14720 instruct repl4F_reg_Ex(vecX dst, regF src) %{
14721   match(Set dst (ReplicateF src));
14722   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14723   ins_cost(DEFAULT_COST);
14724   expand %{
14725     vecX tmpV;
14726     immI8  zero %{ (int)  0 %}
14727 
14728     xscvdpspn_regF(tmpV, src);
14729     xxspltw(dst, tmpV, zero);
14730   %}
14731 %}
14732 
14733 instruct repl4F_immF_Ex(vecX dst, immF src, iRegLdst tmp) %{
14734   match(Set dst (ReplicateF src));
14735   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14736   effect(TEMP tmp);
14737   ins_cost(10 * DEFAULT_COST);
14738 
14739   postalloc_expand( postalloc_expand_load_replF_constant_vsx(dst, src, constanttablebase, tmp) );
14740 %}
14741 
14742 instruct repl4F_immF0(vecX dst, immF_0 zero) %{
14743   match(Set dst (ReplicateF zero));
14744   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14745 
14746   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14747   ins_encode %{
14748     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14749   %}
14750   ins_pipe(pipe_class_default);
14751 %}
14752 
14753 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14754   match(Set dst (ReplicateD src));
14755   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14756 
14757   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14758   size(4);
14759   ins_encode %{
14760     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14761   %}
14762   ins_pipe(pipe_class_default);
14763 %}
14764 
14765 instruct repl2D_immD0(vecX dst, immD_0 zero) %{
14766   match(Set dst (ReplicateD zero));
14767   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14768 
14769   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14770   size(4);
14771   ins_encode %{
14772     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14773   %}
14774   ins_pipe(pipe_class_default);
14775 %}
14776 
14777 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14778   predicate(false);
14779   effect(DEF dst, USE src);
14780 
14781   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14782   size(4);
14783   ins_encode %{
14784     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14785   %}
14786   ins_pipe(pipe_class_default);
14787 %}
14788 
14789 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14790   effect(DEF dst, USE src, USE zero);
14791 
14792   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14793   size(4);
14794   ins_encode %{
14795     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14796   %}
14797   ins_pipe(pipe_class_default);
14798 %}
14799 
14800 instruct xxpermdi(vecX dst, vecX src1, vecX src2, immI8 zero) %{
14801   effect(DEF dst, USE src1, USE src2, USE zero);
14802 
14803   format %{ &quot;XXPERMDI      $dst, $src1, $src2, $zero \t// Splat doubleword&quot; %}
14804   size(4);
14805   ins_encode %{
14806     __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);
14807   %}
14808   ins_pipe(pipe_class_default);
14809 %}
14810 
14811 instruct repl2L_reg_Ex(vecX dst, iRegLsrc src) %{
14812   match(Set dst (ReplicateL src));
14813   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14814   expand %{
14815     vecX tmpV;
14816     immI8  zero %{ (int)  0 %}
14817     mtvsrd(tmpV, src);
14818     xxpermdi(dst, tmpV, tmpV, zero);
14819   %}
14820 %}
14821 
14822 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14823   match(Set dst (ReplicateL zero));
14824   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14825 
14826   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14827   size(4);
14828   ins_encode %{
14829     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14830   %}
14831   ins_pipe(pipe_class_default);
14832 %}
14833 
14834 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14835   match(Set dst (ReplicateL src));
14836   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14837 
14838   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}
14839   size(4);
14840   ins_encode %{
14841     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14842   %}
14843   ins_pipe(pipe_class_default);
14844 %}
14845 
14846 // ============================================================================
14847 // Safepoint Instruction
14848 
14849 instruct safePoint_poll(iRegPdst poll) %{
14850   match(SafePoint poll);
14851 
14852   // It caused problems to add the effect that r0 is killed, but this
14853   // effect no longer needs to be mentioned, since r0 is not contained
14854   // in a reg_class.
14855 
14856   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14857   size(4);
14858   ins_encode( enc_poll(0x0, poll) );
14859   ins_pipe(pipe_class_default);
14860 %}
14861 
14862 // ============================================================================
14863 // Call Instructions
14864 
14865 // Call Java Static Instruction
14866 
14867 // Schedulable version of call static node.
14868 instruct CallStaticJavaDirect(method meth) %{
14869   match(CallStaticJava);
14870   effect(USE meth);
14871   ins_cost(CALL_COST);
14872 
14873   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
14874 
14875   format %{ &quot;CALL,static $meth \t// ==&gt; &quot; %}
14876   size(4);
14877   ins_encode( enc_java_static_call(meth) );
14878   ins_pipe(pipe_class_call);
14879 %}
14880 
14881 // Call Java Dynamic Instruction
14882 
14883 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
14884 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
14885 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
14886 // The call destination must still be placed in the constant pool.
14887 instruct CallDynamicJavaDirectSched(method meth) %{
14888   match(CallDynamicJava); // To get all the data fields we need ...
14889   effect(USE meth);
14890   predicate(false);       // ... but never match.
14891 
14892   ins_field_load_ic_hi_node(loadConL_hiNode*);
14893   ins_field_load_ic_node(loadConLNode*);
14894   ins_num_consts(1 /* 1 patchable constant: call destination */);
14895 
14896   format %{ &quot;BL        \t// dynamic $meth ==&gt; &quot; %}
14897   size(4);
14898   ins_encode( enc_java_dynamic_call_sched(meth) );
14899   ins_pipe(pipe_class_call);
14900 %}
14901 
14902 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
14903 // We use postalloc expanded calls if we use inline caches
14904 // and do not update method data.
14905 //
14906 // This instruction has two constants: inline cache (IC) and call destination.
14907 // Loading the inline cache will be postalloc expanded, thus leaving a call with
14908 // one constant.
14909 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
14910   match(CallDynamicJava);
14911   effect(USE meth);
14912   predicate(UseInlineCaches);
14913   ins_cost(CALL_COST);
14914 
14915   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
14916 
14917   format %{ &quot;CALL,dynamic $meth \t// postalloc expanded&quot; %}
14918   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
14919 %}
14920 
14921 // Compound version of call dynamic java
14922 // We use postalloc expanded calls if we use inline caches
14923 // and do not update method data.
14924 instruct CallDynamicJavaDirect(method meth) %{
14925   match(CallDynamicJava);
14926   effect(USE meth);
14927   predicate(!UseInlineCaches);
14928   ins_cost(CALL_COST);
14929 
14930   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
14931   ins_num_consts(4);
14932 
14933   format %{ &quot;CALL,dynamic $meth \t// ==&gt; &quot; %}
14934   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
14935   ins_pipe(pipe_class_call);
14936 %}
14937 
14938 // Call Runtime Instruction
14939 
14940 instruct CallRuntimeDirect(method meth) %{
14941   match(CallRuntime);
14942   effect(USE meth);
14943   ins_cost(CALL_COST);
14944 
14945   // Enc_java_to_runtime_call needs up to 3 constants: call target,
14946   // env for callee, C-toc.
14947   ins_num_consts(3);
14948 
14949   format %{ &quot;CALL,runtime&quot; %}
14950   ins_encode( enc_java_to_runtime_call(meth) );
14951   ins_pipe(pipe_class_call);
14952 %}
14953 
14954 // Call Leaf
14955 
14956 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
14957 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
14958   effect(DEF dst, USE src);
14959 
14960   ins_num_consts(1);
14961 
14962   format %{ &quot;MTCTR   $src&quot; %}
14963   size(4);
14964   ins_encode( enc_leaf_call_mtctr(src) );
14965   ins_pipe(pipe_class_default);
14966 %}
14967 
14968 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
14969 instruct CallLeafDirect(method meth) %{
14970   match(CallLeaf);   // To get the data all the data fields we need ...
14971   effect(USE meth);
14972   predicate(false);  // but never match.
14973 
14974   format %{ &quot;BCTRL     \t// leaf call $meth ==&gt; &quot; %}
14975   size(4);
14976   ins_encode %{
14977     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
14978     __ bctrl();
14979   %}
14980   ins_pipe(pipe_class_call);
14981 %}
14982 
14983 // postalloc expand of CallLeafDirect.
14984 // Load adress to call from TOC, then bl to it.
14985 instruct CallLeafDirect_Ex(method meth) %{
14986   match(CallLeaf);
14987   effect(USE meth);
14988   ins_cost(CALL_COST);
14989 
14990   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
14991   // env for callee, C-toc.
14992   ins_num_consts(3);
14993 
14994   format %{ &quot;CALL,runtime leaf $meth \t// postalloc expanded&quot; %}
14995   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
14996 %}
14997 
14998 // Call runtime without safepoint - same as CallLeaf.
14999 // postalloc expand of CallLeafNoFPDirect.
15000 // Load adress to call from TOC, then bl to it.
15001 instruct CallLeafNoFPDirect_Ex(method meth) %{
15002   match(CallLeafNoFP);
15003   effect(USE meth);
15004   ins_cost(CALL_COST);
15005 
15006   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15007   // env for callee, C-toc.
15008   ins_num_consts(3);
15009 
15010   format %{ &quot;CALL,runtime leaf nofp $meth \t// postalloc expanded&quot; %}
15011   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15012 %}
15013 
15014 // Tail Call; Jump from runtime stub to Java code.
15015 // Also known as an &#39;interprocedural jump&#39;.
15016 // Target of jump will eventually return to caller.
15017 // TailJump below removes the return address.
15018 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
15019   match(TailCall jump_target method_oop);
15020   ins_cost(CALL_COST);
15021 
15022   format %{ &quot;MTCTR   $jump_target \t// $method_oop holds method oop\n\t&quot;
15023             &quot;BCTR         \t// tail call&quot; %}
15024   size(8);
15025   ins_encode %{
15026     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15027     __ mtctr($jump_target$$Register);
15028     __ bctr();
15029   %}
15030   ins_pipe(pipe_class_call);
15031 %}
15032 
15033 // Return Instruction
15034 instruct Ret() %{
15035   match(Return);
15036   format %{ &quot;BLR      \t// branch to link register&quot; %}
15037   size(4);
15038   ins_encode %{
15039     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
15040     // LR is restored in MachEpilogNode. Just do the RET here.
15041     __ blr();
15042   %}
15043   ins_pipe(pipe_class_default);
15044 %}
15045 
15046 // Tail Jump; remove the return address; jump to target.
15047 // TailCall above leaves the return address around.
15048 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
15049 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
15050 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
15051 // in %i0.
15052 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
15053   match(TailJump jump_target ex_oop);
15054   ins_cost(CALL_COST);
15055 
15056   format %{ &quot;LD      R4_ARG2 = LR\n\t&quot;
15057             &quot;MTCTR   $jump_target\n\t&quot;
15058             &quot;BCTR     \t// TailJump, exception oop: $ex_oop&quot; %}
15059   size(12);
15060   ins_encode %{
15061     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15062     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
15063     __ mtctr($jump_target$$Register);
15064     __ bctr();
15065   %}
15066   ins_pipe(pipe_class_call);
15067 %}
15068 
15069 // Create exception oop: created by stack-crawling runtime code.
15070 // Created exception is now available to this handler, and is setup
15071 // just prior to jumping to this handler. No code emitted.
15072 instruct CreateException(rarg1RegP ex_oop) %{
15073   match(Set ex_oop (CreateEx));
15074   ins_cost(0);
15075 
15076   format %{ &quot; -- \t// exception oop; no code emitted&quot; %}
15077   size(0);
15078   ins_encode( /*empty*/ );
15079   ins_pipe(pipe_class_default);
15080 %}
15081 
15082 // Rethrow exception: The exception oop will come in the first
15083 // argument position. Then JUMP (not call) to the rethrow stub code.
15084 instruct RethrowException() %{
15085   match(Rethrow);
15086   ins_cost(CALL_COST);
15087 
15088   format %{ &quot;Jmp     rethrow_stub&quot; %}
15089   ins_encode %{
15090     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15091     cbuf.set_insts_mark();
15092     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
15093   %}
15094   ins_pipe(pipe_class_call);
15095 %}
15096 
15097 // Die now.
15098 instruct ShouldNotReachHere() %{
15099   match(Halt);
15100   ins_cost(CALL_COST);
15101 
15102   format %{ &quot;ShouldNotReachHere&quot; %}
15103   size(4);
15104   ins_encode %{
15105     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
15106     __ trap_should_not_reach_here();
15107   %}
15108   ins_pipe(pipe_class_default);
15109 %}
15110 
15111 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
15112 // forces a &#39;TypeRawPtr::BOTTOM&#39; output type for this guy.
15113 // Get a DEF on threadRegP, no costs, no encoding, use
15114 // &#39;ins_should_rematerialize(true)&#39; to avoid spilling.
15115 instruct tlsLoadP(threadRegP dst) %{
15116   match(Set dst (ThreadLocal));
15117   ins_cost(0);
15118 
15119   ins_should_rematerialize(true);
15120 
15121   format %{ &quot; -- \t// $dst=Thread::current(), empty&quot; %}
15122   size(0);
15123   ins_encode( /*empty*/ );
15124   ins_pipe(pipe_class_empty);
15125 %}
15126 
15127 //---Some PPC specific nodes---------------------------------------------------
15128 
15129 // Stop a group.
15130 instruct endGroup() %{
15131   ins_cost(0);
15132 
15133   ins_is_nop(true);
15134 
15135   format %{ &quot;End Bundle (ori r1, r1, 0)&quot; %}
15136   size(4);
15137   ins_encode %{
15138     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
15139     __ endgroup();
15140   %}
15141   ins_pipe(pipe_class_default);
15142 %}
15143 
15144 // Nop instructions
15145 
15146 instruct fxNop() %{
15147   ins_cost(0);
15148 
15149   ins_is_nop(true);
15150 
15151   format %{ &quot;fxNop&quot; %}
15152   size(4);
15153   ins_encode %{
15154     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15155     __ nop();
15156   %}
15157   ins_pipe(pipe_class_default);
15158 %}
15159 
15160 instruct fpNop0() %{
15161   ins_cost(0);
15162 
15163   ins_is_nop(true);
15164 
15165   format %{ &quot;fpNop0&quot; %}
15166   size(4);
15167   ins_encode %{
15168     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15169     __ fpnop0();
15170   %}
15171   ins_pipe(pipe_class_default);
15172 %}
15173 
15174 instruct fpNop1() %{
15175   ins_cost(0);
15176 
15177   ins_is_nop(true);
15178 
15179   format %{ &quot;fpNop1&quot; %}
15180   size(4);
15181   ins_encode %{
15182     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15183     __ fpnop1();
15184   %}
15185   ins_pipe(pipe_class_default);
15186 %}
15187 
15188 instruct brNop0() %{
15189   ins_cost(0);
15190   size(4);
15191   format %{ &quot;brNop0&quot; %}
15192   ins_encode %{
15193     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15194     __ brnop0();
15195   %}
15196   ins_is_nop(true);
15197   ins_pipe(pipe_class_default);
15198 %}
15199 
15200 instruct brNop1() %{
15201   ins_cost(0);
15202 
15203   ins_is_nop(true);
15204 
15205   format %{ &quot;brNop1&quot; %}
15206   size(4);
15207   ins_encode %{
15208     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15209     __ brnop1();
15210   %}
15211   ins_pipe(pipe_class_default);
15212 %}
15213 
15214 instruct brNop2() %{
15215   ins_cost(0);
15216 
15217   ins_is_nop(true);
15218 
15219   format %{ &quot;brNop2&quot; %}
15220   size(4);
15221   ins_encode %{
15222     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15223     __ brnop2();
15224   %}
15225   ins_pipe(pipe_class_default);
15226 %}
15227 
15228 instruct cacheWB(indirect addr)
15229 %{
15230   match(CacheWB addr);
15231 
15232   ins_cost(100);
15233   format %{ &quot;cache writeback, address = $addr&quot; %}
15234   ins_encode %{
15235     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
15236     assert($addr$$disp == 0, &quot;should be&quot;);
15237     __ cache_wb(Address($addr$$base$$Register));
15238   %}
15239   ins_pipe(pipe_class_default);
15240 %}
15241 
15242 instruct cacheWBPreSync()
15243 %{
15244   match(CacheWBPreSync);
15245 
15246   ins_cost(0);
15247   format %{ &quot;cache writeback presync&quot; %}
15248   ins_encode %{
15249     __ cache_wbsync(true);
15250   %}
15251   ins_pipe(pipe_class_default);
15252 %}
15253 
15254 instruct cacheWBPostSync()
15255 %{
15256   match(CacheWBPostSync);
15257 
15258   ins_cost(100);
15259   format %{ &quot;cache writeback postsync&quot; %}
15260   ins_encode %{
15261     __ cache_wbsync(false);
15262   %}
15263   ins_pipe(pipe_class_default);
15264 %}
15265 
15266 //----------PEEPHOLE RULES-----------------------------------------------------
15267 // These must follow all instruction definitions as they use the names
15268 // defined in the instructions definitions.
15269 //
15270 // peepmatch ( root_instr_name [preceeding_instruction]* );
15271 //
15272 // peepconstraint %{
15273 // (instruction_number.operand_name relational_op instruction_number.operand_name
15274 //  [, ...] );
15275 // // instruction numbers are zero-based using left to right order in peepmatch
15276 //
15277 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15278 // // provide an instruction_number.operand_name for each operand that appears
15279 // // in the replacement instruction&#39;s match rule
15280 //
15281 // ---------VM FLAGS---------------------------------------------------------
15282 //
15283 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15284 //
15285 // Each peephole rule is given an identifying number starting with zero and
15286 // increasing by one in the order seen by the parser. An individual peephole
15287 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
15288 // on the command-line.
15289 //
15290 // ---------CURRENT LIMITATIONS----------------------------------------------
15291 //
15292 // Only match adjacent instructions in same basic block
15293 // Only equality constraints
15294 // Only constraints between operands, not (0.dest_reg == EAX_enc)
15295 // Only one replacement instruction
15296 //
15297 // ---------EXAMPLE----------------------------------------------------------
15298 //
15299 // // pertinent parts of existing instructions in architecture description
15300 // instruct movI(eRegI dst, eRegI src) %{
15301 //   match(Set dst (CopyI src));
15302 // %}
15303 //
15304 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
15305 //   match(Set dst (AddI dst src));
15306 //   effect(KILL cr);
15307 // %}
15308 //
15309 // // Change (inc mov) to lea
15310 // peephole %{
15311 //   // increment preceeded by register-register move
15312 //   peepmatch ( incI_eReg movI );
15313 //   // require that the destination register of the increment
15314 //   // match the destination register of the move
15315 //   peepconstraint ( 0.dst == 1.dst );
15316 //   // construct a replacement instruction that sets
15317 //   // the destination to ( move&#39;s source register + one )
15318 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15319 // %}
15320 //
15321 // Implementation no longer uses movX instructions since
15322 // machine-independent system no longer uses CopyX nodes.
15323 //
15324 // peephole %{
15325 //   peepmatch ( incI_eReg movI );
15326 //   peepconstraint ( 0.dst == 1.dst );
15327 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15328 // %}
15329 //
15330 // peephole %{
15331 //   peepmatch ( decI_eReg movI );
15332 //   peepconstraint ( 0.dst == 1.dst );
15333 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15334 // %}
15335 //
15336 // peephole %{
15337 //   peepmatch ( addI_eReg_imm movI );
15338 //   peepconstraint ( 0.dst == 1.dst );
15339 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15340 // %}
15341 //
15342 // peephole %{
15343 //   peepmatch ( addP_eReg_imm movP );
15344 //   peepconstraint ( 0.dst == 1.dst );
15345 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
15346 // %}
15347 
15348 // // Change load of spilled value to only a spill
15349 // instruct storeI(memory mem, eRegI src) %{
15350 //   match(Set mem (StoreI mem src));
15351 // %}
15352 //
15353 // instruct loadI(eRegI dst, memory mem) %{
15354 //   match(Set dst (LoadI mem));
15355 // %}
15356 //
15357 peephole %{
15358   peepmatch ( loadI storeI );
15359   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15360   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
15361 %}
15362 
15363 peephole %{
15364   peepmatch ( loadL storeL );
15365   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15366   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
15367 %}
15368 
15369 peephole %{
15370   peepmatch ( loadP storeP );
15371   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
15372   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
15373 %}
15374 
15375 //----------SMARTSPILL RULES---------------------------------------------------
15376 // These must follow all instruction definitions as they use the names
15377 // defined in the instructions definitions.
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
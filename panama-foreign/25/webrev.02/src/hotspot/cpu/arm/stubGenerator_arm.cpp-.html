<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/arm/stubGenerator_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/universe.hpp&quot;
  32 #include &quot;nativeInst_arm.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/method.hpp&quot;
  35 #include &quot;oops/objArrayKlass.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/handles.inline.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  42 #include &quot;runtime/stubRoutines.hpp&quot;
  43 #include &quot;utilities/align.hpp&quot;
  44 #ifdef COMPILER2
  45 #include &quot;opto/runtime.hpp&quot;
  46 #endif
  47 
  48 // Declaration and definition of StubGenerator (no .hpp file).
  49 // For a more detailed description of the stub routine structure
  50 // see the comment in stubRoutines.hpp
  51 
  52 #define __ _masm-&gt;
  53 
  54 #ifdef PRODUCT
  55 #define BLOCK_COMMENT(str) /* nothing */
  56 #else
  57 #define BLOCK_COMMENT(str) __ block_comment(str)
  58 #endif
  59 
  60 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  61 
  62 // -------------------------------------------------------------------------------------------------------------------------
  63 // Stub Code definitions
  64 
  65 // Platform dependent parameters for array copy stubs
  66 
  67 // Note: we have noticed a huge change in behavior on a microbenchmark
  68 // from platform to platform depending on the configuration.
  69 
  70 // Instead of adding a series of command line options (which
  71 // unfortunately have to be done in the shared file and cannot appear
  72 // only in the ARM port), the tested result are hard-coded here in a set
  73 // of options, selected by specifying &#39;ArmCopyPlatform&#39;
  74 
  75 // Currently, this &#39;platform&#39; is hardcoded to a value that is a good
  76 // enough trade-off.  However, one can easily modify this file to test
  77 // the hard-coded configurations or create new ones. If the gain is
  78 // significant, we could decide to either add command line options or
  79 // add code to automatically choose a configuration.
  80 
  81 // see comments below for the various configurations created
  82 #define DEFAULT_ARRAYCOPY_CONFIG 0
  83 #define TEGRA2_ARRAYCOPY_CONFIG 1
  84 #define IMX515_ARRAYCOPY_CONFIG 2
  85 
  86 // Hard coded choices (XXX: could be changed to a command line option)
  87 #define ArmCopyPlatform DEFAULT_ARRAYCOPY_CONFIG
  88 
  89 #define ArmCopyCacheLineSize 32 // not worth optimizing to 64 according to measured gains
  90 
  91 // configuration for each kind of loop
  92 typedef struct {
  93   int pld_distance;       // prefetch distance (0 =&gt; no prefetch, &lt;0: prefetch_before);
  94   bool split_ldm;         // if true, split each STM in STMs with fewer registers
  95   bool split_stm;         // if true, split each LTM in LTMs with fewer registers
  96 } arraycopy_loop_config;
  97 
  98 // configuration for all loops
  99 typedef struct {
 100   // const char *description;
 101   arraycopy_loop_config forward_aligned;
 102   arraycopy_loop_config backward_aligned;
 103   arraycopy_loop_config forward_shifted;
 104   arraycopy_loop_config backward_shifted;
 105 } arraycopy_platform_config;
 106 
 107 // configured platforms
 108 static arraycopy_platform_config arraycopy_configurations[] = {
 109   // configuration parameters for arraycopy loops
 110 
 111   // Configurations were chosen based on manual analysis of benchmark
 112   // results, minimizing overhead with respect to best results on the
 113   // different test cases.
 114 
 115   // Prefetch before is always favored since it avoids dirtying the
 116   // cache uselessly for small copies. Code for prefetch after has
 117   // been kept in case the difference is significant for some
 118   // platforms but we might consider dropping it.
 119 
 120   // distance, ldm, stm
 121   {
 122     // default: tradeoff tegra2/imx515/nv-tegra2,
 123     // Notes on benchmarking:
 124     // - not far from optimal configuration on nv-tegra2
 125     // - within 5% of optimal configuration except for backward aligned on IMX
 126     // - up to 40% from optimal configuration for backward shifted and backward align for tegra2
 127     //   but still on par with the operating system copy
 128     {-256, true,  true  }, // forward aligned
 129     {-256, true,  true  }, // backward aligned
 130     {-256, false, false }, // forward shifted
 131     {-256, true,  true  } // backward shifted
 132   },
 133   {
 134     // configuration tuned on tegra2-4.
 135     // Warning: should not be used on nv-tegra2 !
 136     // Notes:
 137     // - prefetch after gives 40% gain on backward copies on tegra2-4,
 138     //   resulting in better number than the operating system
 139     //   copy. However, this can lead to a 300% loss on nv-tegra and has
 140     //   more impact on the cache (fetches futher than what is
 141     //   copied). Use this configuration with care, in case it improves
 142     //   reference benchmarks.
 143     {-256, true,  true  }, // forward aligned
 144     {96,   false, false }, // backward aligned
 145     {-256, false, false }, // forward shifted
 146     {96,   false, false } // backward shifted
 147   },
 148   {
 149     // configuration tuned on imx515
 150     // Notes:
 151     // - smaller prefetch distance is sufficient to get good result and might be more stable
 152     // - refined backward aligned options within 5% of optimal configuration except for
 153     //   tests were the arrays fit in the cache
 154     {-160, false, false }, // forward aligned
 155     {-160, false, false }, // backward aligned
 156     {-160, false, false }, // forward shifted
 157     {-160, true,  true  } // backward shifted
 158   }
 159 };
 160 
 161 class StubGenerator: public StubCodeGenerator {
 162 
 163 #ifdef PRODUCT
 164 #define inc_counter_np(a,b,c) ((void)0)
 165 #else
 166 #define inc_counter_np(counter, t1, t2) \
 167   BLOCK_COMMENT(&quot;inc_counter &quot; #counter); \
 168   __ inc_counter(&amp;counter, t1, t2);
 169 #endif
 170 
 171  private:
 172 
 173   address generate_call_stub(address&amp; return_address) {
 174     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;call_stub&quot;);
 175     address start = __ pc();
 176 
 177 
 178     assert(frame::entry_frame_call_wrapper_offset == 0, &quot;adjust this code&quot;);
 179 
 180     __ mov(Rtemp, SP);
 181     __ push(RegisterSet(FP) | RegisterSet(LR));
 182     __ fpush_hardfp(FloatRegisterSet(D8, 8));
 183     __ stmdb(SP, RegisterSet(R0, R2) | RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11, writeback);
 184     __ mov(Rmethod, R3);
 185     __ ldmia(Rtemp, RegisterSet(R1, R3) | Rthread); // stacked arguments
 186 
 187     // XXX: TODO
 188     // Would be better with respect to native tools if the following
 189     // setting of FP was changed to conform to the native ABI, with FP
 190     // pointing to the saved FP slot (and the corresponding modifications
 191     // for entry_frame_call_wrapper_offset and frame::real_fp).
 192     __ mov(FP, SP);
 193 
 194     {
 195       Label no_parameters, pass_parameters;
 196       __ cmp(R3, 0);
 197       __ b(no_parameters, eq);
 198 
 199       __ bind(pass_parameters);
 200       __ ldr(Rtemp, Address(R2, wordSize, post_indexed)); // Rtemp OK, unused and scratchable
 201       __ subs(R3, R3, 1);
 202       __ push(Rtemp);
 203       __ b(pass_parameters, ne);
 204       __ bind(no_parameters);
 205     }
 206 
 207     __ mov(Rsender_sp, SP);
 208     __ blx(R1);
 209     return_address = __ pc();
 210 
 211     __ add(SP, FP, wordSize); // Skip link to JavaCallWrapper
 212     __ pop(RegisterSet(R2, R3));
 213 #ifndef __ABI_HARD__
 214     __ cmp(R3, T_LONG);
 215     __ cmp(R3, T_DOUBLE, ne);
 216     __ str(R0, Address(R2));
 217     __ str(R1, Address(R2, wordSize), eq);
 218 #else
 219     Label cont, l_float, l_double;
 220 
 221     __ cmp(R3, T_DOUBLE);
 222     __ b(l_double, eq);
 223 
 224     __ cmp(R3, T_FLOAT);
 225     __ b(l_float, eq);
 226 
 227     __ cmp(R3, T_LONG);
 228     __ str(R0, Address(R2));
 229     __ str(R1, Address(R2, wordSize), eq);
 230     __ b(cont);
 231 
 232 
 233     __ bind(l_double);
 234     __ fstd(D0, Address(R2));
 235     __ b(cont);
 236 
 237     __ bind(l_float);
 238     __ fsts(S0, Address(R2));
 239 
 240     __ bind(cont);
 241 #endif
 242 
 243     __ pop(RegisterSet(R4, R6) | RegisterSet(R8, R10) | altFP_7_11);
 244     __ fpop_hardfp(FloatRegisterSet(D8, 8));
 245     __ pop(RegisterSet(FP) | RegisterSet(PC));
 246 
 247     return start;
 248   }
 249 
 250 
 251   // (in) Rexception_obj: exception oop
 252   address generate_catch_exception() {
 253     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;catch_exception&quot;);
 254     address start = __ pc();
 255 
 256     __ str(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 257     __ b(StubRoutines::_call_stub_return_address);
 258 
 259     return start;
 260   }
 261 
 262 
 263   // (in) Rexception_pc: return address
 264   address generate_forward_exception() {
 265     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;forward exception&quot;);
 266     address start = __ pc();
 267 
 268     __ mov(c_rarg0, Rthread);
 269     __ mov(c_rarg1, Rexception_pc);
 270     __ call_VM_leaf(CAST_FROM_FN_PTR(address,
 271                          SharedRuntime::exception_handler_for_return_address),
 272                          c_rarg0, c_rarg1);
 273     __ ldr(Rexception_obj, Address(Rthread, Thread::pending_exception_offset()));
 274     const Register Rzero = __ zero_register(Rtemp); // Rtemp OK (cleared by above call)
 275     __ str(Rzero, Address(Rthread, Thread::pending_exception_offset()));
 276 
 277 #ifdef ASSERT
 278     // make sure exception is set
 279     { Label L;
 280       __ cbnz(Rexception_obj, L);
 281       __ stop(&quot;StubRoutines::forward exception: no pending exception (2)&quot;);
 282       __ bind(L);
 283     }
 284 #endif
 285 
 286     // Verify that there is really a valid exception in RAX.
 287     __ verify_oop(Rexception_obj);
 288 
 289     __ jump(R0); // handler is returned in R0 by runtime function
 290     return start;
 291   }
 292 
 293 
 294 
 295   // Integer division shared routine
 296   //   Input:
 297   //     R0  - dividend
 298   //     R2  - divisor
 299   //   Output:
 300   //     R0  - remainder
 301   //     R1  - quotient
 302   //   Destroys:
 303   //     R2
 304   //     LR
 305   address generate_idiv_irem() {
 306     Label positive_arguments, negative_or_zero, call_slow_path;
 307     Register dividend  = R0;
 308     Register divisor   = R2;
 309     Register remainder = R0;
 310     Register quotient  = R1;
 311     Register tmp       = LR;
 312     assert(dividend == remainder, &quot;must be&quot;);
 313 
 314     address start = __ pc();
 315 
 316     // Check for special cases: divisor &lt;= 0 or dividend &lt; 0
 317     __ cmp(divisor, 0);
 318     __ orrs(quotient, dividend, divisor, ne);
 319     __ b(negative_or_zero, le);
 320 
 321     __ bind(positive_arguments);
 322     // Save return address on stack to free one extra register
 323     __ push(LR);
 324     // Approximate the mamximum order of the quotient
 325     __ clz(tmp, dividend);
 326     __ clz(quotient, divisor);
 327     __ subs(tmp, quotient, tmp);
 328     __ mov(quotient, 0);
 329     // Jump to the appropriate place in the unrolled loop below
 330     __ ldr(PC, Address(PC, tmp, lsl, 2), pl);
 331     // If divisor is greater than dividend, return immediately
 332     __ pop(PC);
 333 
 334     // Offset table
 335     Label offset_table[32];
 336     int i;
 337     for (i = 0; i &lt;= 31; i++) {
 338       __ emit_address(offset_table[i]);
 339     }
 340 
 341     // Unrolled loop of 32 division steps
 342     for (i = 31; i &gt;= 0; i--) {
 343       __ bind(offset_table[i]);
 344       __ cmp(remainder, AsmOperand(divisor, lsl, i));
 345       __ sub(remainder, remainder, AsmOperand(divisor, lsl, i), hs);
 346       __ add(quotient, quotient, 1 &lt;&lt; i, hs);
 347     }
 348     __ pop(PC);
 349 
 350     __ bind(negative_or_zero);
 351     // Find the combination of argument signs and jump to corresponding handler
 352     __ andr(quotient, dividend, 0x80000000, ne);
 353     __ orr(quotient, quotient, AsmOperand(divisor, lsr, 31), ne);
 354     __ add(PC, PC, AsmOperand(quotient, ror, 26), ne);
 355     __ str(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
 356 
 357     // The leaf runtime function can destroy R0-R3 and R12 registers which are still alive
 358     RegisterSet saved_registers = RegisterSet(R3) | RegisterSet(R12);
 359 #if R9_IS_SCRATCHED
 360     // Safer to save R9 here since callers may have been written
 361     // assuming R9 survives. This is suboptimal but may not be worth
 362     // revisiting for this slow case.
 363 
 364     // save also R10 for alignment
 365     saved_registers = saved_registers | RegisterSet(R9, R10);
 366 #endif
 367     {
 368       // divisor == 0
 369       FixedSizeCodeBlock zero_divisor(_masm, 8, true);
 370       __ push(saved_registers);
 371       __ mov(R0, Rthread);
 372       __ mov(R1, LR);
 373       __ mov(R2, SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
 374       __ b(call_slow_path);
 375     }
 376 
 377     {
 378       // divisor &gt; 0 &amp;&amp; dividend &lt; 0
 379       FixedSizeCodeBlock positive_divisor_negative_dividend(_masm, 8, true);
 380       __ push(LR);
 381       __ rsb(dividend, dividend, 0);
 382       __ bl(positive_arguments);
 383       __ rsb(remainder, remainder, 0);
 384       __ rsb(quotient, quotient, 0);
 385       __ pop(PC);
 386     }
 387 
 388     {
 389       // divisor &lt; 0 &amp;&amp; dividend &gt; 0
 390       FixedSizeCodeBlock negative_divisor_positive_dividend(_masm, 8, true);
 391       __ push(LR);
 392       __ rsb(divisor, divisor, 0);
 393       __ bl(positive_arguments);
 394       __ rsb(quotient, quotient, 0);
 395       __ pop(PC);
 396     }
 397 
 398     {
 399       // divisor &lt; 0 &amp;&amp; dividend &lt; 0
 400       FixedSizeCodeBlock negative_divisor_negative_dividend(_masm, 8, true);
 401       __ push(LR);
 402       __ rsb(dividend, dividend, 0);
 403       __ rsb(divisor, divisor, 0);
 404       __ bl(positive_arguments);
 405       __ rsb(remainder, remainder, 0);
 406       __ pop(PC);
 407     }
 408 
 409     __ bind(call_slow_path);
 410     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::continuation_for_implicit_exception));
 411     __ pop(saved_registers);
 412     __ bx(R0);
 413 
 414     return start;
 415   }
 416 
 417 
 418  // As per atomic.hpp the Atomic read-modify-write operations must be logically implemented as:
 419  //  &lt;fence&gt;; &lt;op&gt;; &lt;membar StoreLoad|StoreStore&gt;
 420  // But for load-linked/store-conditional based systems a fence here simply means
 421  // no load/store can be reordered with respect to the initial load-linked, so we have:
 422  // &lt;membar storeload|loadload&gt; ; load-linked; &lt;op&gt;; store-conditional; &lt;membar storeload|storestore&gt;
 423  // There are no memory actions in &lt;op&gt; so nothing further is needed.
 424  //
 425  // So we define the following for convenience:
 426 #define MEMBAR_ATOMIC_OP_PRE \
 427     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::LoadLoad)
 428 #define MEMBAR_ATOMIC_OP_POST \
 429     MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad|MacroAssembler::StoreStore)
 430 
 431   // Note: JDK 9 only supports ARMv7+ so we always have ldrexd available even though the
 432   // code below allows for it to be otherwise. The else clause indicates an ARMv5 system
 433   // for which we do not support MP and so membars are not necessary. This ARMv5 code will
 434   // be removed in the future.
 435 
 436   // Implementation of atomic_add(jint add_value, volatile jint* dest)
 437   // used by Atomic::add(volatile jint* dest, jint add_value)
 438   //
 439   // Arguments :
 440   //
 441   //      add_value:      R0
 442   //      dest:           R1
 443   //
 444   // Results:
 445   //
 446   //     R0: the new stored in dest
 447   //
 448   // Overwrites:
 449   //
 450   //     R1, R2, R3
 451   //
 452   address generate_atomic_add() {
 453     address start;
 454 
 455     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_add&quot;);
 456     Label retry;
 457     start = __ pc();
 458     Register addval    = R0;
 459     Register dest      = R1;
 460     Register prev      = R2;
 461     Register ok        = R2;
 462     Register newval    = R3;
 463 
 464     if (VM_Version::supports_ldrex()) {
 465       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 466       __ bind(retry);
 467       __ ldrex(newval, Address(dest));
 468       __ add(newval, addval, newval);
 469       __ strex(ok, newval, Address(dest));
 470       __ cmp(ok, 0);
 471       __ b(retry, ne);
 472       __ mov (R0, newval);
 473       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 474     } else {
 475       __ bind(retry);
 476       __ ldr (prev, Address(dest));
 477       __ add(newval, addval, prev);
 478       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 479       __ b(retry, ne);
 480       __ mov (R0, newval);
 481     }
 482     __ bx(LR);
 483 
 484     return start;
 485   }
 486 
 487   // Implementation of jint atomic_xchg(jint exchange_value, volatile jint* dest)
 488   // used by Atomic::add(volatile jint* dest, jint exchange_value)
 489   //
 490   // Arguments :
 491   //
 492   //      exchange_value: R0
 493   //      dest:           R1
 494   //
 495   // Results:
 496   //
 497   //     R0: the value previously stored in dest
 498   //
 499   // Overwrites:
 500   //
 501   //     R1, R2, R3
 502   //
 503   address generate_atomic_xchg() {
 504     address start;
 505 
 506     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_xchg&quot;);
 507     start = __ pc();
 508     Register newval    = R0;
 509     Register dest      = R1;
 510     Register prev      = R2;
 511 
 512     Label retry;
 513 
 514     if (VM_Version::supports_ldrex()) {
 515       Register ok=R3;
 516       __ membar(MEMBAR_ATOMIC_OP_PRE, prev);
 517       __ bind(retry);
 518       __ ldrex(prev, Address(dest));
 519       __ strex(ok, newval, Address(dest));
 520       __ cmp(ok, 0);
 521       __ b(retry, ne);
 522       __ mov (R0, prev);
 523       __ membar(MEMBAR_ATOMIC_OP_POST, prev);
 524     } else {
 525       __ bind(retry);
 526       __ ldr (prev, Address(dest));
 527       __ atomic_cas_bool(prev, newval, dest, 0, noreg/*ignored*/);
 528       __ b(retry, ne);
 529       __ mov (R0, prev);
 530     }
 531     __ bx(LR);
 532 
 533     return start;
 534   }
 535 
 536   // Implementation of jint atomic_cmpxchg(jint exchange_value, volatile jint *dest, jint compare_value)
 537   // used by Atomic::cmpxchg(volatile jint *dest, jint compare_value, jint exchange_value)
 538   //
 539   // Arguments :
 540   //
 541   //      compare_value:  R0
 542   //      exchange_value: R1
 543   //      dest:           R2
 544   //
 545   // Results:
 546   //
 547   //     R0: the value previously stored in dest
 548   //
 549   // Overwrites:
 550   //
 551   //     R0, R1, R2, R3, Rtemp
 552   //
 553   address generate_atomic_cmpxchg() {
 554     address start;
 555 
 556     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg&quot;);
 557     start = __ pc();
 558     Register cmp       = R0;
 559     Register newval    = R1;
 560     Register dest      = R2;
 561     Register temp1     = R3;
 562     Register temp2     = Rtemp; // Rtemp free (native ABI)
 563 
 564     __ membar(MEMBAR_ATOMIC_OP_PRE, temp1);
 565 
 566     // atomic_cas returns previous value in R0
 567     __ atomic_cas(temp1, temp2, cmp, newval, dest, 0);
 568 
 569     __ membar(MEMBAR_ATOMIC_OP_POST, temp1);
 570 
 571     __ bx(LR);
 572 
 573     return start;
 574   }
 575 
 576   // Support for jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong *dest, jlong compare_value)
 577   // reordered before by a wrapper to (jlong compare_value, jlong exchange_value, volatile jlong *dest)
 578   //
 579   // Arguments :
 580   //
 581   //      compare_value:  R1 (High), R0 (Low)
 582   //      exchange_value: R3 (High), R2 (Low)
 583   //      dest:           SP+0
 584   //
 585   // Results:
 586   //
 587   //     R0:R1: the value previously stored in dest
 588   //
 589   // Overwrites:
 590   //
 591   address generate_atomic_cmpxchg_long() {
 592     address start;
 593 
 594     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_cmpxchg_long&quot;);
 595     start = __ pc();
 596     Register cmp_lo      = R0;
 597     Register cmp_hi      = R1;
 598     Register newval_lo   = R2;
 599     Register newval_hi   = R3;
 600     Register addr        = Rtemp;  /* After load from stack */
 601     Register temp_lo     = R4;
 602     Register temp_hi     = R5;
 603     Register temp_result = R8;
 604     assert_different_registers(cmp_lo, newval_lo, temp_lo, addr, temp_result, R7);
 605     assert_different_registers(cmp_hi, newval_hi, temp_hi, addr, temp_result, R7);
 606 
 607     __ membar(MEMBAR_ATOMIC_OP_PRE, Rtemp); // Rtemp free (native ABI)
 608 
 609     // Stack is unaligned, maintain double word alignment by pushing
 610     // odd number of regs.
 611     __ push(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));
 612     __ ldr(addr, Address(SP, 12));
 613 
 614     // atomic_cas64 returns previous value in temp_lo, temp_hi
 615     __ atomic_cas64(temp_lo, temp_hi, temp_result, cmp_lo, cmp_hi,
 616                     newval_lo, newval_hi, addr, 0);
 617     __ mov(R0, temp_lo);
 618     __ mov(R1, temp_hi);
 619 
 620     __ pop(RegisterSet(temp_result) | RegisterSet(temp_lo, temp_hi));
 621 
 622     __ membar(MEMBAR_ATOMIC_OP_POST, Rtemp); // Rtemp free (native ABI)
 623     __ bx(LR);
 624 
 625     return start;
 626   }
 627 
 628   address generate_atomic_load_long() {
 629     address start;
 630 
 631     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_load_long&quot;);
 632     start = __ pc();
 633     Register result_lo = R0;
 634     Register result_hi = R1;
 635     Register src       = R0;
 636 
 637     if (!os::is_MP()) {
 638       __ ldmia(src, RegisterSet(result_lo, result_hi));
 639       __ bx(LR);
 640     } else if (VM_Version::supports_ldrexd()) {
 641       __ ldrexd(result_lo, Address(src));
 642       __ clrex(); // FIXME: safe to remove?
 643       __ bx(LR);
 644     } else {
 645       __ stop(&quot;Atomic load(jlong) unsupported on this platform&quot;);
 646       __ bx(LR);
 647     }
 648 
 649     return start;
 650   }
 651 
 652   address generate_atomic_store_long() {
 653     address start;
 654 
 655     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;atomic_store_long&quot;);
 656     start = __ pc();
 657     Register newval_lo = R0;
 658     Register newval_hi = R1;
 659     Register dest      = R2;
 660     Register scratch_lo    = R2;
 661     Register scratch_hi    = R3;  /* After load from stack */
 662     Register result    = R3;
 663 
 664     if (!os::is_MP()) {
 665       __ stmia(dest, RegisterSet(newval_lo, newval_hi));
 666       __ bx(LR);
 667     } else if (VM_Version::supports_ldrexd()) {
 668       __ mov(Rtemp, dest);  // get dest to Rtemp
 669       Label retry;
 670       __ bind(retry);
 671       __ ldrexd(scratch_lo, Address(Rtemp));
 672       __ strexd(result, R0, Address(Rtemp));
 673       __ rsbs(result, result, 1);
 674       __ b(retry, eq);
 675       __ bx(LR);
 676     } else {
 677       __ stop(&quot;Atomic store(jlong) unsupported on this platform&quot;);
 678       __ bx(LR);
 679     }
 680 
 681     return start;
 682   }
 683 
 684 
 685 
 686 #ifdef COMPILER2
 687   // Support for uint StubRoutine::Arm::partial_subtype_check( Klass sub, Klass super );
 688   // Arguments :
 689   //
 690   //      ret  : R0, returned
 691   //      icc/xcc: set as R0 (depending on wordSize)
 692   //      sub  : R1, argument, not changed
 693   //      super: R2, argument, not changed
 694   //      raddr: LR, blown by call
 695   address generate_partial_subtype_check() {
 696     __ align(CodeEntryAlignment);
 697     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;partial_subtype_check&quot;);
 698     address start = __ pc();
 699 
 700     // based on SPARC check_klass_subtype_[fast|slow]_path (without CompressedOops)
 701 
 702     // R0 used as tmp_reg (in addition to return reg)
 703     Register sub_klass = R1;
 704     Register super_klass = R2;
 705     Register tmp_reg2 = R3;
 706     Register tmp_reg3 = R4;
 707 #define saved_set tmp_reg2, tmp_reg3
 708 
 709     Label L_loop, L_fail;
 710 
 711     int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
 712 
 713     // fast check should be redundant
 714 
 715     // slow check
 716     {
 717       __ raw_push(saved_set);
 718 
 719       // a couple of useful fields in sub_klass:
 720       int ss_offset = in_bytes(Klass::secondary_supers_offset());
 721 
 722       // Do a linear scan of the secondary super-klass chain.
 723       // This code is rarely used, so simplicity is a virtue here.
 724 
 725       inc_counter_np(SharedRuntime::_partial_subtype_ctr, tmp_reg2, tmp_reg3);
 726 
 727       Register scan_temp = tmp_reg2;
 728       Register count_temp = tmp_reg3;
 729 
 730       // We will consult the secondary-super array.
 731       __ ldr(scan_temp, Address(sub_klass, ss_offset));
 732 
 733       Register search_key = super_klass;
 734 
 735       // Load the array length.
 736       __ ldr_s32(count_temp, Address(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes()));
 737       __ add(scan_temp, scan_temp, Array&lt;Klass*&gt;::base_offset_in_bytes());
 738 
 739       __ add(count_temp, count_temp, 1);
 740 
 741       // Top of search loop
 742       __ bind(L_loop);
 743       // Notes:
 744       //  scan_temp starts at the array elements
 745       //  count_temp is 1+size
 746       __ subs(count_temp, count_temp, 1);
 747       __ b(L_fail, eq); // not found in the array
 748 
 749       // Load next super to check
 750       // In the array of super classes elements are pointer sized.
 751       int element_size = wordSize;
 752       __ ldr(R0, Address(scan_temp, element_size, post_indexed));
 753 
 754       // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
 755       __ subs(R0, R0, search_key); // set R0 to 0 on success (and flags to eq)
 756 
 757       // A miss means we are NOT a subtype and need to keep looping
 758       __ b(L_loop, ne);
 759 
 760       // Falling out the bottom means we found a hit; we ARE a subtype
 761 
 762       // Success.  Cache the super we found and proceed in triumph.
 763       __ str(super_klass, Address(sub_klass, sc_offset));
 764 
 765       // Return success
 766       // R0 is already 0 and flags are already set to eq
 767       __ raw_pop(saved_set);
 768       __ ret();
 769 
 770       // Return failure
 771       __ bind(L_fail);
 772       __ movs(R0, 1); // sets the flags
 773       __ raw_pop(saved_set);
 774       __ ret();
 775     }
 776     return start;
 777   }
 778 #undef saved_set
 779 #endif // COMPILER2
 780 
 781 
 782   //----------------------------------------------------------------------------------------------------
 783   // Non-destructive plausibility checks for oops
 784 
 785   address generate_verify_oop() {
 786     StubCodeMark mark(this, &quot;StubRoutines&quot;, &quot;verify_oop&quot;);
 787     address start = __ pc();
 788 
 789     // Incoming arguments:
 790     //
 791     // R0: error message (char* )
 792     // R1: address of register save area
 793     // R2: oop to verify
 794     //
 795     // All registers are saved before calling this stub. However, condition flags should be saved here.
 796 
 797     const Register oop   = R2;
 798     const Register klass = R3;
 799     const Register tmp1  = R6;
 800     const Register tmp2  = R8;
 801 
 802     const Register flags     = Rtmp_save0; // R4/R19
 803     const Register ret_addr  = Rtmp_save1; // R5/R20
 804     assert_different_registers(oop, klass, tmp1, tmp2, flags, ret_addr, R7);
 805 
 806     Label exit, error;
 807     InlinedAddress verify_oop_count((address) StubRoutines::verify_oop_count_addr());
 808 
 809     __ mrs(Assembler::CPSR, flags);
 810 
 811     __ ldr_literal(tmp1, verify_oop_count);
 812     __ ldr_s32(tmp2, Address(tmp1));
 813     __ add(tmp2, tmp2, 1);
 814     __ str_32(tmp2, Address(tmp1));
 815 
 816     // make sure object is &#39;reasonable&#39;
 817     __ cbz(oop, exit);                           // if obj is NULL it is ok
 818 
 819     // Check if the oop is in the right area of memory
 820     // Note: oop_mask and oop_bits must be updated if the code is saved/reused
 821     const address oop_mask = (address) Universe::verify_oop_mask();
 822     const address oop_bits = (address) Universe::verify_oop_bits();
 823     __ mov_address(tmp1, oop_mask);
 824     __ andr(tmp2, oop, tmp1);
 825     __ mov_address(tmp1, oop_bits);
 826     __ cmp(tmp2, tmp1);
 827     __ b(error, ne);
 828 
 829     // make sure klass is &#39;reasonable&#39;
 830     __ load_klass(klass, oop);                   // get klass
 831     __ cbz(klass, error);                        // if klass is NULL it is broken
 832 
 833     // return if everything seems ok
 834     __ bind(exit);
 835 
 836     __ msr(Assembler::CPSR_f, flags);
 837 
 838     __ ret();
 839 
 840     // handle errors
 841     __ bind(error);
 842 
 843     __ mov(ret_addr, LR);                      // save return address
 844 
 845     // R0: error message
 846     // R1: register save area
 847     __ call(CAST_FROM_FN_PTR(address, MacroAssembler::debug));
 848 
 849     __ mov(LR, ret_addr);
 850     __ b(exit);
 851 
 852     __ bind_literal(verify_oop_count);
 853 
 854     return start;
 855   }
 856 
 857   //----------------------------------------------------------------------------------------------------
 858   // Array copy stubs
 859 
 860   //
 861   //  Generate overlap test for array copy stubs
 862   //
 863   //  Input:
 864   //    R0    -  array1
 865   //    R1    -  array2
 866   //    R2    -  element count, 32-bit int
 867   //
 868   //  input registers are preserved
 869   //
 870   void array_overlap_test(address no_overlap_target, int log2_elem_size, Register tmp1, Register tmp2) {
 871     assert(no_overlap_target != NULL, &quot;must be generated&quot;);
 872     array_overlap_test(no_overlap_target, NULL, log2_elem_size, tmp1, tmp2);
 873   }
 874   void array_overlap_test(Label&amp; L_no_overlap, int log2_elem_size, Register tmp1, Register tmp2) {
 875     array_overlap_test(NULL, &amp;L_no_overlap, log2_elem_size, tmp1, tmp2);
 876   }
 877   void array_overlap_test(address no_overlap_target, Label* NOLp, int log2_elem_size, Register tmp1, Register tmp2) {
 878     const Register from       = R0;
 879     const Register to         = R1;
 880     const Register count      = R2;
 881     const Register to_from    = tmp1; // to - from
 882     const Register byte_count = (log2_elem_size == 0) ? count : tmp2; // count &lt;&lt; log2_elem_size
 883     assert_different_registers(from, to, count, tmp1, tmp2);
 884 
 885     // no_overlap version works if &#39;to&#39; lower (unsigned) than &#39;from&#39;
 886     // and or &#39;to&#39; more than (count*size) from &#39;from&#39;
 887 
 888     BLOCK_COMMENT(&quot;Array Overlap Test:&quot;);
 889     __ subs(to_from, to, from);
 890     if (log2_elem_size != 0) {
 891       __ mov(byte_count, AsmOperand(count, lsl, log2_elem_size));
 892     }
 893     if (NOLp == NULL)
 894       __ b(no_overlap_target,lo);
 895     else
 896       __ b((*NOLp), lo);
 897     __ cmp(to_from, byte_count);
 898     if (NOLp == NULL)
 899       __ b(no_overlap_target, ge);
 900     else
 901       __ b((*NOLp), ge);
 902   }
 903 
 904 
 905   //   probably we should choose between &quot;prefetch-store before or after store&quot;, not &quot;before or after load&quot;.
 906   void prefetch(Register from, Register to, int offset, int to_delta = 0) {
 907     __ prefetch_read(Address(from, offset));
 908   }
 909 
 910   // Generate the inner loop for forward aligned array copy
 911   //
 912   // Arguments
 913   //      from:      src address, 64 bits  aligned
 914   //      to:        dst address, wordSize aligned
 915   //      count:     number of elements (32-bit int)
 916   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
 917   //
 918   // Return the minimum initial value for count
 919   //
 920   // Notes:
 921   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
 922   // - &#39;to&#39; aligned on wordSize
 923   // - &#39;count&#39; must be greater or equal than the returned value
 924   //
 925   // Increases &#39;from&#39; and &#39;to&#39; by count*bytes_per_count.
 926   //
 927   // Scratches &#39;count&#39;, R3.
 928   // R4-R10 are preserved (saved/restored).
 929   //
 930   int generate_forward_aligned_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool unsafe_copy = false) {
 931     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
 932 
 933     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
 934     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_aligned;
 935     int pld_offset = config-&gt;pld_distance;
 936     const int count_per_loop = bytes_per_loop / bytes_per_count;
 937 
 938     bool split_read= config-&gt;split_ldm;
 939     bool split_write= config-&gt;split_stm;
 940 
 941     // XXX optim: use VLDM/VSTM when available (Neon) with PLD
 942     //  NEONCopyPLD
 943     //      PLD [r1, #0xC0]
 944     //      VLDM r1!,{d0-d7}
 945     //      VSTM r0!,{d0-d7}
 946     //      SUBS r2,r2,#0x40
 947     //      BGE NEONCopyPLD
 948 
 949     __ push(RegisterSet(R4,R10));
 950 
 951     const bool prefetch_before = pld_offset &lt; 0;
 952     const bool prefetch_after = pld_offset &gt; 0;
 953 
 954     Label L_skip_pld;
 955 
 956     {
 957       // UnsafeCopyMemory page error: continue after ucm
 958       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
 959       // predecrease to exit when there is less than count_per_loop
 960       __ sub_32(count, count, count_per_loop);
 961 
 962       if (pld_offset != 0) {
 963         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
 964 
 965         prefetch(from, to, 0);
 966 
 967         if (prefetch_before) {
 968           // If prefetch is done ahead, final PLDs that overflow the
 969           // copied area can be easily avoided. &#39;count&#39; is predecreased
 970           // by the prefetch distance to optimize the inner loop and the
 971           // outer loop skips the PLD.
 972           __ subs_32(count, count, (bytes_per_loop+pld_offset)/bytes_per_count);
 973 
 974           // skip prefetch for small copies
 975           __ b(L_skip_pld, lt);
 976         }
 977 
 978         int offset = ArmCopyCacheLineSize;
 979         while (offset &lt;= pld_offset) {
 980           prefetch(from, to, offset);
 981           offset += ArmCopyCacheLineSize;
 982         };
 983       }
 984 
 985       {
 986         // 32-bit ARM note: we have tried implementing loop unrolling to skip one
 987         // PLD with 64 bytes cache line but the gain was not significant.
 988 
 989         Label L_copy_loop;
 990         __ align(OptoLoopAlignment);
 991         __ BIND(L_copy_loop);
 992 
 993         if (prefetch_before) {
 994           prefetch(from, to, bytes_per_loop + pld_offset);
 995           __ BIND(L_skip_pld);
 996         }
 997 
 998         if (split_read) {
 999           // Split the register set in two sets so that there is less
1000           // latency between LDM and STM (R3-R6 available while R7-R10
1001           // still loading) and less register locking issue when iterating
1002           // on the first LDM.
1003           __ ldmia(from, RegisterSet(R3, R6), writeback);
1004           __ ldmia(from, RegisterSet(R7, R10), writeback);
1005         } else {
1006           __ ldmia(from, RegisterSet(R3, R10), writeback);
1007         }
1008 
1009         __ subs_32(count, count, count_per_loop);
1010 
1011         if (prefetch_after) {
1012           prefetch(from, to, pld_offset, bytes_per_loop);
1013         }
1014 
1015         if (split_write) {
1016           __ stmia(to, RegisterSet(R3, R6), writeback);
1017           __ stmia(to, RegisterSet(R7, R10), writeback);
1018         } else {
1019           __ stmia(to, RegisterSet(R3, R10), writeback);
1020         }
1021 
1022         __ b(L_copy_loop, ge);
1023 
1024         if (prefetch_before) {
1025           // the inner loop may end earlier, allowing to skip PLD for the last iterations
1026           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1027           __ b(L_skip_pld, ge);
1028         }
1029       }
1030       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);
1031       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes
1032 
1033       // __ add(count, count, ...); // addition useless for the bit tests
1034       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);
1035 
1036       __ tst(count, 16 / bytes_per_count);
1037       __ ldmia(from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes
1038       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1039 
1040       __ tst(count, 8 / bytes_per_count);
1041       __ ldmia(from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes
1042       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1043 
1044       if (bytes_per_count &lt;= 4) {
1045         __ tst(count, 4 / bytes_per_count);
1046         __ ldr(R3, Address(from, 4, post_indexed), ne); // copy 4 bytes
1047         __ str(R3, Address(to, 4, post_indexed), ne);
1048       }
1049 
1050       if (bytes_per_count &lt;= 2) {
1051         __ tst(count, 2 / bytes_per_count);
1052         __ ldrh(R3, Address(from, 2, post_indexed), ne); // copy 2 bytes
1053         __ strh(R3, Address(to, 2, post_indexed), ne);
1054       }
1055 
1056       if (bytes_per_count == 1) {
1057         __ tst(count, 1);
1058         __ ldrb(R3, Address(from, 1, post_indexed), ne);
1059         __ strb(R3, Address(to, 1, post_indexed), ne);
1060       }
1061     }
1062 
1063     __ pop(RegisterSet(R4,R10));
1064 
1065     return count_per_loop;
1066   }
1067 
1068 
1069   // Generate the inner loop for backward aligned array copy
1070   //
1071   // Arguments
1072   //      end_from:      src end address, 64 bits  aligned
1073   //      end_to:        dst end address, wordSize aligned
1074   //      count:         number of elements (32-bit int)
1075   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1076   //
1077   // Return the minimum initial value for count
1078   //
1079   // Notes:
1080   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1081   // - &#39;end_to&#39; aligned on wordSize
1082   // - &#39;count&#39; must be greater or equal than the returned value
1083   //
1084   // Decreases &#39;end_from&#39; and &#39;end_to&#39; by count*bytes_per_count.
1085   //
1086   // Scratches &#39;count&#39;, R3.
1087   // ARM R4-R10 are preserved (saved/restored).
1088   //
1089   int generate_backward_aligned_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count, bool unsafe_copy = false) {
1090     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1091 
1092     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iteration
1093     const int count_per_loop = bytes_per_loop / bytes_per_count;
1094 
1095     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_aligned;
1096     int pld_offset = config-&gt;pld_distance;
1097 
1098     bool split_read= config-&gt;split_ldm;
1099     bool split_write= config-&gt;split_stm;
1100 
1101     // See the forward copy variant for additional comments.
1102 
1103     __ push(RegisterSet(R4,R10));
1104 
1105     {
1106       // UnsafeCopyMemory page error: continue after ucm
1107       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1108       __ sub_32(count, count, count_per_loop);
1109 
1110       const bool prefetch_before = pld_offset &lt; 0;
1111       const bool prefetch_after = pld_offset &gt; 0;
1112 
1113       Label L_skip_pld;
1114 
1115       if (pld_offset != 0) {
1116         pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1117 
1118         prefetch(end_from, end_to, -wordSize);
1119 
1120         if (prefetch_before) {
1121           __ subs_32(count, count, (bytes_per_loop + pld_offset) / bytes_per_count);
1122           __ b(L_skip_pld, lt);
1123         }
1124 
1125         int offset = ArmCopyCacheLineSize;
1126         while (offset &lt;= pld_offset) {
1127           prefetch(end_from, end_to, -(wordSize + offset));
1128           offset += ArmCopyCacheLineSize;
1129         };
1130       }
1131 
1132       {
1133         // 32-bit ARM note: we have tried implementing loop unrolling to skip one
1134         // PLD with 64 bytes cache line but the gain was not significant.
1135 
1136         Label L_copy_loop;
1137         __ align(OptoLoopAlignment);
1138         __ BIND(L_copy_loop);
1139 
1140         if (prefetch_before) {
1141           prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));
1142           __ BIND(L_skip_pld);
1143         }
1144 
1145         if (split_read) {
1146           __ ldmdb(end_from, RegisterSet(R7, R10), writeback);
1147           __ ldmdb(end_from, RegisterSet(R3, R6), writeback);
1148         } else {
1149           __ ldmdb(end_from, RegisterSet(R3, R10), writeback);
1150         }
1151 
1152         __ subs_32(count, count, count_per_loop);
1153 
1154         if (prefetch_after) {
1155           prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);
1156         }
1157 
1158         if (split_write) {
1159           __ stmdb(end_to, RegisterSet(R7, R10), writeback);
1160           __ stmdb(end_to, RegisterSet(R3, R6), writeback);
1161         } else {
1162           __ stmdb(end_to, RegisterSet(R3, R10), writeback);
1163         }
1164 
1165         __ b(L_copy_loop, ge);
1166 
1167         if (prefetch_before) {
1168           __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1169           __ b(L_skip_pld, ge);
1170         }
1171       }
1172       BLOCK_COMMENT(&quot;Remaining bytes:&quot;);
1173       // still 0..bytes_per_loop-1 aligned bytes to copy, count already decreased by (at least) bytes_per_loop bytes
1174 
1175       // __ add(count, count, ...); // addition useless for the bit tests
1176       assert (pld_offset % bytes_per_loop == 0, &quot;decreasing count by pld_offset before loop must not change tested bits&quot;);
1177 
1178       __ tst(count, 16 / bytes_per_count);
1179       __ ldmdb(end_from, RegisterSet(R3, R6), writeback, ne); // copy 16 bytes
1180       __ stmdb(end_to, RegisterSet(R3, R6), writeback, ne);
1181 
1182       __ tst(count, 8 / bytes_per_count);
1183       __ ldmdb(end_from, RegisterSet(R3, R4), writeback, ne); // copy 8 bytes
1184       __ stmdb(end_to, RegisterSet(R3, R4), writeback, ne);
1185 
1186       if (bytes_per_count &lt;= 4) {
1187         __ tst(count, 4 / bytes_per_count);
1188         __ ldr(R3, Address(end_from, -4, pre_indexed), ne); // copy 4 bytes
1189         __ str(R3, Address(end_to, -4, pre_indexed), ne);
1190       }
1191 
1192       if (bytes_per_count &lt;= 2) {
1193         __ tst(count, 2 / bytes_per_count);
1194         __ ldrh(R3, Address(end_from, -2, pre_indexed), ne); // copy 2 bytes
1195         __ strh(R3, Address(end_to, -2, pre_indexed), ne);
1196       }
1197 
1198       if (bytes_per_count == 1) {
1199         __ tst(count, 1);
1200         __ ldrb(R3, Address(end_from, -1, pre_indexed), ne);
1201         __ strb(R3, Address(end_to, -1, pre_indexed), ne);
1202       }
1203     }
1204     __ pop(RegisterSet(R4,R10));
1205 
1206     return count_per_loop;
1207   }
1208 
1209 
1210   // Generate the inner loop for shifted forward array copy (unaligned copy).
1211   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1212   //
1213   // Arguments
1214   //      from:      start src address, 64 bits aligned
1215   //      to:        start dst address, (now) wordSize aligned
1216   //      count:     number of elements (32-bit int)
1217   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1218   //      lsr_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1219   //      lsl_shift: shift applied to &#39;new&#39; value to set the high bytes of the next write
1220   //
1221   // Return the minimum initial value for count
1222   //
1223   // Notes:
1224   // - &#39;from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1225   // - &#39;to&#39; aligned on wordSize
1226   // - &#39;count&#39; must be greater or equal than the returned value
1227   // - &#39;lsr_shift&#39; + &#39;lsl_shift&#39; = BitsPerWord
1228   // - &#39;bytes_per_count&#39; is 1 or 2
1229   //
1230   // Increases &#39;to&#39; by count*bytes_per_count.
1231   //
1232   // Scratches &#39;from&#39; and &#39;count&#39;, R3-R10, R12
1233   //
1234   // On entry:
1235   // - R12 is preloaded with the first &#39;BitsPerWord&#39; bits read just before &#39;from&#39;
1236   // - (R12 &gt;&gt; lsr_shift) is the part not yet written (just before &#39;to&#39;)
1237   // --&gt; (*to) = (R12 &gt;&gt; lsr_shift) | (*from) &lt;&lt; lsl_shift); ...
1238   //
1239   // This implementation may read more bytes than required.
1240   // Actually, it always reads exactly all data from the copied region with upper bound aligned up by wordSize,
1241   // so excessive read do not cross a word bound and is thus harmless.
1242   //
1243   int generate_forward_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, int lsr_shift, int lsl_shift) {
1244     assert (from == R0 &amp;&amp; to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1245 
1246     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iter
1247     const int count_per_loop = bytes_per_loop / bytes_per_count;
1248 
1249     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].forward_shifted;
1250     int pld_offset = config-&gt;pld_distance;
1251 
1252     bool split_read= config-&gt;split_ldm;
1253     bool split_write= config-&gt;split_stm;
1254 
1255     const bool prefetch_before = pld_offset &lt; 0;
1256     const bool prefetch_after = pld_offset &gt; 0;
1257     Label L_skip_pld, L_last_read, L_done;
1258     if (pld_offset != 0) {
1259 
1260       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1261 
1262       prefetch(from, to, 0);
1263 
1264       if (prefetch_before) {
1265         __ cmp_32(count, count_per_loop);
1266         __ b(L_last_read, lt);
1267         // skip prefetch for small copies
1268         // warning: count is predecreased by the prefetch distance to optimize the inner loop
1269         __ subs_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1270         __ b(L_skip_pld, lt);
1271       }
1272 
1273       int offset = ArmCopyCacheLineSize;
1274       while (offset &lt;= pld_offset) {
1275         prefetch(from, to, offset);
1276         offset += ArmCopyCacheLineSize;
1277       };
1278     }
1279 
1280     Label L_shifted_loop;
1281 
1282     __ align(OptoLoopAlignment);
1283     __ BIND(L_shifted_loop);
1284 
1285     if (prefetch_before) {
1286       // do it early if there might be register locking issues
1287       prefetch(from, to, bytes_per_loop + pld_offset);
1288       __ BIND(L_skip_pld);
1289     } else {
1290       __ cmp_32(count, count_per_loop);
1291       __ b(L_last_read, lt);
1292     }
1293 
1294     // read 32 bytes
1295     if (split_read) {
1296       // if write is not split, use less registers in first set to reduce locking
1297       RegisterSet set1 = split_write ? RegisterSet(R4, R7) : RegisterSet(R4, R5);
1298       RegisterSet set2 = (split_write ? RegisterSet(R8, R10) : RegisterSet(R6, R10)) | R12;
1299       __ ldmia(from, set1, writeback);
1300       __ mov(R3, AsmOperand(R12, lsr, lsr_shift)); // part of R12 not yet written
1301       __ ldmia(from, set2, writeback);
1302       __ subs(count, count, count_per_loop); // XXX: should it be before the 2nd LDM ? (latency vs locking)
1303     } else {
1304       __ mov(R3, AsmOperand(R12, lsr, lsr_shift)); // part of R12 not yet written
1305       __ ldmia(from, RegisterSet(R4, R10) | R12, writeback); // Note: small latency on R4
1306       __ subs(count, count, count_per_loop);
1307     }
1308 
1309     if (prefetch_after) {
1310       // do it after the 1st ldm/ldp anyway  (no locking issues with early STM/STP)
1311       prefetch(from, to, pld_offset, bytes_per_loop);
1312     }
1313 
1314     // prepare (shift) the values in R3..R10
1315     __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift)); // merged below low bytes of next val
1316     __ logical_shift_right(R4, R4, lsr_shift); // unused part of next val
1317     __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift)); // ...
1318     __ logical_shift_right(R5, R5, lsr_shift);
1319     __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift));
1320     __ logical_shift_right(R6, R6, lsr_shift);
1321     __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift));
1322     if (split_write) {
1323       // write the first half as soon as possible to reduce stm locking
1324       __ stmia(to, RegisterSet(R3, R6), writeback, prefetch_before ? gt : ge);
1325     }
1326     __ logical_shift_right(R7, R7, lsr_shift);
1327     __ orr(R7, R7, AsmOperand(R8, lsl, lsl_shift));
1328     __ logical_shift_right(R8, R8, lsr_shift);
1329     __ orr(R8, R8, AsmOperand(R9, lsl, lsl_shift));
1330     __ logical_shift_right(R9, R9, lsr_shift);
1331     __ orr(R9, R9, AsmOperand(R10, lsl, lsl_shift));
1332     __ logical_shift_right(R10, R10, lsr_shift);
1333     __ orr(R10, R10, AsmOperand(R12, lsl, lsl_shift));
1334 
1335     if (split_write) {
1336       __ stmia(to, RegisterSet(R7, R10), writeback, prefetch_before ? gt : ge);
1337     } else {
1338       __ stmia(to, RegisterSet(R3, R10), writeback, prefetch_before ? gt : ge);
1339     }
1340     __ b(L_shifted_loop, gt); // no need to loop if 0 (when count need not be precise modulo bytes_per_loop)
1341 
1342     if (prefetch_before) {
1343       // the first loop may end earlier, allowing to skip pld at the end
1344       __ cmn_32(count, (bytes_per_loop + pld_offset)/bytes_per_count);
1345       __ stmia(to, RegisterSet(R3, R10), writeback); // stmia was skipped
1346       __ b(L_skip_pld, ge);
1347       __ adds_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1348     }
1349 
1350     __ BIND(L_last_read);
1351     __ b(L_done, eq);
1352 
1353     switch (bytes_per_count) {
1354     case 2:
1355       __ mov(R3, AsmOperand(R12, lsr, lsr_shift));
1356       __ tst(count, 8);
1357       __ ldmia(from, RegisterSet(R4, R7), writeback, ne);
1358       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1359       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1360       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1361       __ mov(R5, AsmOperand(R5, lsr, lsr_shift), ne);
1362       __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift), ne);
1363       __ mov(R6, AsmOperand(R6, lsr, lsr_shift), ne);
1364       __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift), ne);
1365       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1366       __ mov(R3, AsmOperand(R7, lsr, lsr_shift), ne);
1367 
1368       __ tst(count, 4);
1369       __ ldmia(from, RegisterSet(R4, R5), writeback, ne);
1370       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1371       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1372       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1373       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1374       __ mov(R3, AsmOperand(R5, lsr, lsr_shift), ne);
1375 
1376       __ tst(count, 2);
1377       __ ldr(R4, Address(from, 4, post_indexed), ne);
1378       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne);
1379       __ str(R3, Address(to, 4, post_indexed), ne);
1380       __ mov(R3, AsmOperand(R4, lsr, lsr_shift), ne);
1381 
1382       __ tst(count, 1);
1383       __ strh(R3, Address(to, 2, post_indexed), ne); // one last short
1384       break;
1385 
1386     case 1:
1387       __ mov(R3, AsmOperand(R12, lsr, lsr_shift));
1388       __ tst(count, 16);
1389       __ ldmia(from, RegisterSet(R4, R7), writeback, ne);
1390       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1391       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1392       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1393       __ mov(R5, AsmOperand(R5, lsr, lsr_shift), ne);
1394       __ orr(R5, R5, AsmOperand(R6, lsl, lsl_shift), ne);
1395       __ mov(R6, AsmOperand(R6, lsr, lsr_shift), ne);
1396       __ orr(R6, R6, AsmOperand(R7, lsl, lsl_shift), ne);
1397       __ stmia(to, RegisterSet(R3, R6), writeback, ne);
1398       __ mov(R3, AsmOperand(R7, lsr, lsr_shift), ne);
1399 
1400       __ tst(count, 8);
1401       __ ldmia(from, RegisterSet(R4, R5), writeback, ne);
1402       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne); // merged below low bytes of next val
1403       __ mov(R4, AsmOperand(R4, lsr, lsr_shift), ne); // unused part of next val
1404       __ orr(R4, R4, AsmOperand(R5, lsl, lsl_shift), ne); // ...
1405       __ stmia(to, RegisterSet(R3, R4), writeback, ne);
1406       __ mov(R3, AsmOperand(R5, lsr, lsr_shift), ne);
1407 
1408       __ tst(count, 4);
1409       __ ldr(R4, Address(from, 4, post_indexed), ne);
1410       __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ne);
1411       __ str(R3, Address(to, 4, post_indexed), ne);
1412       __ mov(R3, AsmOperand(R4, lsr, lsr_shift), ne);
1413 
1414       __ andr(count, count, 3);
1415       __ cmp(count, 2);
1416 
1417       // Note: R3 might contain enough bytes ready to write (3 needed at most),
1418       // thus load on lsl_shift==24 is not needed (in fact forces reading
1419       // beyond source buffer end boundary)
1420       if (lsl_shift == 8) {
1421         __ ldr(R4, Address(from, 4, post_indexed), ge);
1422         __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), ge);
1423       } else if (lsl_shift == 16) {
1424         __ ldr(R4, Address(from, 4, post_indexed), gt);
1425         __ orr(R3, R3, AsmOperand(R4, lsl, lsl_shift), gt);
1426       }
1427 
1428       __ strh(R3, Address(to, 2, post_indexed), ge); // two last bytes
1429       __ mov(R3, AsmOperand(R3, lsr, 16), gt);
1430 
1431       __ tst(count, 1);
1432       __ strb(R3, Address(to, 1, post_indexed), ne); // one last byte
1433       break;
1434     }
1435 
1436     __ BIND(L_done);
1437     return 0; // no minimum
1438   }
1439 
1440   // Generate the inner loop for shifted backward array copy (unaligned copy).
1441   // It can be used when bytes_per_count &lt; wordSize, i.e. byte/short copy
1442   //
1443   // Arguments
1444   //      end_from:  end src address, 64 bits aligned
1445   //      end_to:    end dst address, (now) wordSize aligned
1446   //      count:     number of elements (32-bit int)
1447   //      bytes_per_count: number of bytes for each unit of &#39;count&#39;
1448   //      lsl_shift: shift applied to &#39;old&#39; value to skipped already written bytes
1449   //      lsr_shift: shift applied to &#39;new&#39; value to set the low bytes of the next write
1450   //
1451   // Return the minimum initial value for count
1452   //
1453   // Notes:
1454   // - &#39;end_from&#39; aligned on 64-bit (recommended for 32-bit ARM in case this speeds up LDMIA)
1455   // - &#39;end_to&#39; aligned on wordSize
1456   // - &#39;count&#39; must be greater or equal than the returned value
1457   // - &#39;lsr_shift&#39; + &#39;lsl_shift&#39; = &#39;BitsPerWord&#39;
1458   // - &#39;bytes_per_count&#39; is 1 or 2 on 32-bit ARM
1459   //
1460   // Decreases &#39;end_to&#39; by count*bytes_per_count.
1461   //
1462   // Scratches &#39;end_from&#39;, &#39;count&#39;, R3-R10, R12
1463   //
1464   // On entry:
1465   // - R3 is preloaded with the first &#39;BitsPerWord&#39; bits read just after &#39;from&#39;
1466   // - (R3 &lt;&lt; lsl_shift) is the part not yet written
1467   // --&gt; (*--to) = (R3 &lt;&lt; lsl_shift) | (*--from) &gt;&gt; lsr_shift); ...
1468   //
1469   // This implementation may read more bytes than required.
1470   // Actually, it always reads exactly all data from the copied region with beginning aligned down by wordSize,
1471   // so excessive read do not cross a word bound and is thus harmless.
1472   //
1473   int generate_backward_shifted_copy_loop(Register end_from, Register end_to, Register count, int bytes_per_count, int lsr_shift, int lsl_shift) {
1474     assert (end_from == R0 &amp;&amp; end_to == R1 &amp;&amp; count == R2, &quot;adjust the implementation below&quot;);
1475 
1476     const int bytes_per_loop = 8*wordSize; // 8 registers are read and written on every loop iter
1477     const int count_per_loop = bytes_per_loop / bytes_per_count;
1478 
1479     arraycopy_loop_config *config=&amp;arraycopy_configurations[ArmCopyPlatform].backward_shifted;
1480     int pld_offset = config-&gt;pld_distance;
1481 
1482     bool split_read= config-&gt;split_ldm;
1483     bool split_write= config-&gt;split_stm;
1484 
1485 
1486     const bool prefetch_before = pld_offset &lt; 0;
1487     const bool prefetch_after = pld_offset &gt; 0;
1488 
1489     Label L_skip_pld, L_done, L_last_read;
1490     if (pld_offset != 0) {
1491 
1492       pld_offset = (pld_offset &lt; 0) ? -pld_offset : pld_offset;
1493 
1494       prefetch(end_from, end_to, -wordSize);
1495 
1496       if (prefetch_before) {
1497         __ cmp_32(count, count_per_loop);
1498         __ b(L_last_read, lt);
1499 
1500         // skip prefetch for small copies
1501         // warning: count is predecreased by the prefetch distance to optimize the inner loop
1502         __ subs_32(count, count, ((bytes_per_loop + pld_offset)/bytes_per_count) + count_per_loop);
1503         __ b(L_skip_pld, lt);
1504       }
1505 
1506       int offset = ArmCopyCacheLineSize;
1507       while (offset &lt;= pld_offset) {
1508         prefetch(end_from, end_to, -(wordSize + offset));
1509         offset += ArmCopyCacheLineSize;
1510       };
1511     }
1512 
1513     Label L_shifted_loop;
1514     __ align(OptoLoopAlignment);
1515     __ BIND(L_shifted_loop);
1516 
1517     if (prefetch_before) {
1518       // do the 1st ldm/ldp first anyway (no locking issues with early STM/STP)
1519       prefetch(end_from, end_to, -(wordSize + bytes_per_loop + pld_offset));
1520       __ BIND(L_skip_pld);
1521     } else {
1522       __ cmp_32(count, count_per_loop);
1523       __ b(L_last_read, lt);
1524     }
1525 
1526     if (split_read) {
1527       __ ldmdb(end_from, RegisterSet(R7, R10), writeback);
1528       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1529       __ ldmdb(end_from, RegisterSet(R3, R6), writeback);
1530     } else {
1531       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1532       __ ldmdb(end_from, RegisterSet(R3, R10), writeback);
1533     }
1534 
1535     __ subs_32(count, count, count_per_loop);
1536 
1537     if (prefetch_after) { // do prefetch during ldm/ldp latency
1538       prefetch(end_from, end_to, -(wordSize + pld_offset), -bytes_per_loop);
1539     }
1540 
1541     // prepare the values in R4..R10,R12
1542     __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift)); // merged above high  bytes of prev val
1543     __ logical_shift_left(R10, R10, lsl_shift); // unused part of prev val
1544     __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift)); // ...
1545     __ logical_shift_left(R9, R9, lsl_shift);
1546     __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift));
1547     __ logical_shift_left(R8, R8, lsl_shift);
1548     __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift));
1549     __ logical_shift_left(R7, R7, lsl_shift);
1550     __ orr(R7, R7, AsmOperand(R6, lsr, lsr_shift));
1551     __ logical_shift_left(R6, R6, lsl_shift);
1552     __ orr(R6, R6, AsmOperand(R5, lsr, lsr_shift));
1553     if (split_write) {
1554       // store early to reduce locking issues
1555       __ stmdb(end_to, RegisterSet(R6, R10) | R12, writeback, prefetch_before ? gt : ge);
1556     }
1557     __ logical_shift_left(R5, R5, lsl_shift);
1558     __ orr(R5, R5, AsmOperand(R4, lsr, lsr_shift));
1559     __ logical_shift_left(R4, R4, lsl_shift);
1560     __ orr(R4, R4, AsmOperand(R3, lsr, lsr_shift));
1561 
1562     if (split_write) {
1563       __ stmdb(end_to, RegisterSet(R4, R5), writeback, prefetch_before ? gt : ge);
1564     } else {
1565       __ stmdb(end_to, RegisterSet(R4, R10) | R12, writeback, prefetch_before ? gt : ge);
1566     }
1567 
1568     __ b(L_shifted_loop, gt); // no need to loop if 0 (when count need not be precise modulo bytes_per_loop)
1569 
1570     if (prefetch_before) {
1571       // the first loop may end earlier, allowing to skip pld at the end
1572       __ cmn_32(count, ((bytes_per_loop + pld_offset)/bytes_per_count));
1573       __ stmdb(end_to, RegisterSet(R4, R10) | R12, writeback); // stmdb was skipped
1574       __ b(L_skip_pld, ge);
1575       __ adds_32(count, count, ((bytes_per_loop + pld_offset) / bytes_per_count) + count_per_loop);
1576     }
1577 
1578     __ BIND(L_last_read);
1579     __ b(L_done, eq);
1580 
1581       switch(bytes_per_count) {
1582       case 2:
1583       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1584       __ tst(count, 8);
1585       __ ldmdb(end_from, RegisterSet(R7,R10), writeback, ne);
1586       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1587       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1588       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1589       __ mov(R9, AsmOperand(R9, lsl, lsl_shift),ne);
1590       __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift),ne);
1591       __ mov(R8, AsmOperand(R8, lsl, lsl_shift),ne);
1592       __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift),ne);
1593       __ stmdb(end_to, RegisterSet(R8,R10)|R12, writeback, ne);
1594       __ mov(R12, AsmOperand(R7, lsl, lsl_shift), ne);
1595 
1596       __ tst(count, 4);
1597       __ ldmdb(end_from, RegisterSet(R9, R10), writeback, ne);
1598       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1599       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1600       __ orr(R10, R10, AsmOperand(R9, lsr,lsr_shift),ne); // ...
1601       __ stmdb(end_to, RegisterSet(R10)|R12, writeback, ne);
1602       __ mov(R12, AsmOperand(R9, lsl, lsl_shift), ne);
1603 
1604       __ tst(count, 2);
1605       __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1606       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1607       __ str(R12, Address(end_to, -4, pre_indexed), ne);
1608       __ mov(R12, AsmOperand(R10, lsl, lsl_shift), ne);
1609 
1610       __ tst(count, 1);
1611       __ mov(R12, AsmOperand(R12, lsr, lsr_shift),ne);
1612       __ strh(R12, Address(end_to, -2, pre_indexed), ne); // one last short
1613       break;
1614 
1615       case 1:
1616       __ mov(R12, AsmOperand(R3, lsl, lsl_shift)); // part of R3 not yet written
1617       __ tst(count, 16);
1618       __ ldmdb(end_from, RegisterSet(R7,R10), writeback, ne);
1619       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1620       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1621       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1622       __ mov(R9, AsmOperand(R9, lsl, lsl_shift),ne);
1623       __ orr(R9, R9, AsmOperand(R8, lsr, lsr_shift),ne);
1624       __ mov(R8, AsmOperand(R8, lsl, lsl_shift),ne);
1625       __ orr(R8, R8, AsmOperand(R7, lsr, lsr_shift),ne);
1626       __ stmdb(end_to, RegisterSet(R8,R10)|R12, writeback, ne);
1627       __ mov(R12, AsmOperand(R7, lsl, lsl_shift), ne);
1628 
1629       __ tst(count, 8);
1630       __ ldmdb(end_from, RegisterSet(R9,R10), writeback, ne);
1631       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1632       __ mov(R10, AsmOperand(R10, lsl, lsl_shift),ne); // unused part of prev val
1633       __ orr(R10, R10, AsmOperand(R9, lsr, lsr_shift),ne); // ...
1634       __ stmdb(end_to, RegisterSet(R10)|R12, writeback, ne);
1635       __ mov(R12, AsmOperand(R9, lsl, lsl_shift), ne);
1636 
1637       __ tst(count, 4);
1638       __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1639       __ orr(R12, R12, AsmOperand(R10, lsr, lsr_shift), ne);
1640       __ str(R12, Address(end_to, -4, pre_indexed), ne);
1641       __ mov(R12, AsmOperand(R10, lsl, lsl_shift), ne);
1642 
1643       __ tst(count, 2);
1644       if (lsr_shift != 24) {
1645         // avoid useless reading R10 when we already have 3 bytes ready in R12
1646         __ ldr(R10, Address(end_from, -4, pre_indexed), ne);
1647         __ orr(R12, R12, AsmOperand(R10, lsr,lsr_shift), ne);
1648       }
1649 
1650       // Note: R12 contains enough bytes ready to write (3 needed at most)
1651       // write the 2 MSBs
1652       __ mov(R9, AsmOperand(R12, lsr, 16), ne);
1653       __ strh(R9, Address(end_to, -2, pre_indexed), ne);
1654       // promote remaining to MSB
1655       __ mov(R12, AsmOperand(R12, lsl, 16), ne);
1656 
1657       __ tst(count, 1);
1658       // write the MSB of R12
1659       __ mov(R12, AsmOperand(R12, lsr, 24), ne);
1660       __ strb(R12, Address(end_to, -1, pre_indexed), ne);
1661 
1662       break;
1663       }
1664 
1665     __ BIND(L_done);
1666     return 0; // no minimum
1667   }
1668 
1669   // This method is very useful for merging forward/backward implementations
1670   Address get_addr_with_indexing(Register base, int delta, bool forward) {
1671     if (forward) {
1672       return Address(base, delta, post_indexed);
1673     } else {
1674       return Address(base, -delta, pre_indexed);
1675     }
1676   }
1677 
1678   void load_one(Register rd, Register from, int size_in_bytes, bool forward, AsmCondition cond = al, Register rd2 = noreg) {
1679     assert_different_registers(from, rd, rd2);
1680     if (size_in_bytes &lt; 8) {
1681       Address addr = get_addr_with_indexing(from, size_in_bytes, forward);
1682       __ load_sized_value(rd, addr, size_in_bytes, false, cond);
1683     } else {
1684       assert (rd2 != noreg, &quot;second value register must be specified&quot;);
1685       assert (rd-&gt;encoding() &lt; rd2-&gt;encoding(), &quot;wrong value register set&quot;);
1686 
1687       if (forward) {
1688         __ ldmia(from, RegisterSet(rd) | rd2, writeback, cond);
1689       } else {
1690         __ ldmdb(from, RegisterSet(rd) | rd2, writeback, cond);
1691       }
1692     }
1693   }
1694 
1695   void store_one(Register rd, Register to, int size_in_bytes, bool forward, AsmCondition cond = al, Register rd2 = noreg) {
1696     assert_different_registers(to, rd, rd2);
1697     if (size_in_bytes &lt; 8) {
1698       Address addr = get_addr_with_indexing(to, size_in_bytes, forward);
1699       __ store_sized_value(rd, addr, size_in_bytes, cond);
1700     } else {
1701       assert (rd2 != noreg, &quot;second value register must be specified&quot;);
1702       assert (rd-&gt;encoding() &lt; rd2-&gt;encoding(), &quot;wrong value register set&quot;);
1703 
1704       if (forward) {
1705         __ stmia(to, RegisterSet(rd) | rd2, writeback, cond);
1706       } else {
1707         __ stmdb(to, RegisterSet(rd) | rd2, writeback, cond);
1708       }
1709     }
1710   }
1711 
1712   // Copies data from &#39;from&#39; to &#39;to&#39; in specified direction to align &#39;from&#39; by 64 bits.
1713   // (on 32-bit ARM 64-bit alignment is better for LDM).
1714   //
1715   // Arguments:
1716   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1717   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1718   //     count:             32-bit int, maximum number of elements which can be copied
1719   //     bytes_per_count:   size of an element
1720   //     forward:           specifies copy direction
1721   //
1722   // Notes:
1723   //   &#39;from&#39; and &#39;to&#39; must be aligned by &#39;bytes_per_count&#39;
1724   //   &#39;count&#39; must not be less than the returned value
1725   //   shifts &#39;from&#39; and &#39;to&#39; by the number of copied bytes in corresponding direction
1726   //   decreases &#39;count&#39; by the number of elements copied
1727   //
1728   // Returns maximum number of bytes which may be copied.
1729   int align_src(Register from, Register to, Register count, Register tmp, int bytes_per_count, bool forward) {
1730     assert_different_registers(from, to, count, tmp);
1731     if (bytes_per_count &lt; 8) {
1732       Label L_align_src;
1733       __ BIND(L_align_src);
1734       __ tst(from, 7);
1735       // ne =&gt; not aligned: copy one element and (if bytes_per_count &lt; 4) loop
1736       __ sub(count, count, 1, ne);
1737       load_one(tmp, from, bytes_per_count, forward, ne);
1738       store_one(tmp, to, bytes_per_count, forward, ne);
1739       if (bytes_per_count &lt; 4) {
1740         __ b(L_align_src, ne); // if bytes_per_count == 4, then 0 or 1 loop iterations are enough
1741       }
1742     }
1743     return 7/bytes_per_count;
1744   }
1745 
1746   // Copies &#39;count&#39; of &#39;bytes_per_count&#39;-sized elements in the specified direction.
1747   //
1748   // Arguments:
1749   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1750   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1751   //     count:             32-bit int, number of elements to be copied
1752   //     entry:             copy loop entry point
1753   //     bytes_per_count:   size of an element
1754   //     forward:           specifies copy direction
1755   //
1756   // Notes:
1757   //     shifts &#39;from&#39; and &#39;to&#39;
1758   void copy_small_array(Register from, Register to, Register count, Register tmp, Register tmp2, int bytes_per_count, bool forward, Label &amp; entry, bool unsafe_copy = false) {
1759     assert_different_registers(from, to, count, tmp);
1760 
1761     {
1762       // UnsafeCopyMemory page error: continue after ucm
1763       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1764       __ align(OptoLoopAlignment);
1765       Label L_small_loop;
1766       __ BIND(L_small_loop);
1767       store_one(tmp, to, bytes_per_count, forward, al, tmp2);
1768       __ BIND(entry); // entry point
1769       __ subs(count, count, 1);
1770       load_one(tmp, from, bytes_per_count, forward, ge, tmp2);
1771       __ b(L_small_loop, ge);
1772     }
1773   }
1774 
1775   // Aligns &#39;to&#39; by reading one word from &#39;from&#39; and writting its part to &#39;to&#39;.
1776   //
1777   // Arguments:
1778   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1779   //     count:             32-bit int, number of elements allowed to be copied
1780   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1781   //     bytes_per_count:   size of an element
1782   //     forward:           specifies copy direction
1783   //     Rval:              contains an already read but not yet written word;
1784   //                        its&#39; LSBs (if forward) or MSBs (if !forward) are to be written to align &#39;to&#39;.
1785   //
1786   // Notes:
1787   //     &#39;count&#39; must not be less then the returned value
1788   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1789   //     shifts &#39;to&#39; by the number of written bytes (so that it becomes the bound of memory to be written)
1790   //     decreases &#39;count&#39; by the the number of elements written
1791   //     Rval&#39;s MSBs or LSBs remain to be written further by generate_{forward,backward}_shifted_copy_loop
1792   int align_dst(Register to, Register count, Register Rval, Register tmp,
1793                                         int to_remainder, int bytes_per_count, bool forward) {
1794     assert_different_registers(to, count, tmp, Rval);
1795 
1796     assert (0 &lt; to_remainder &amp;&amp; to_remainder &lt; wordSize, &quot;to_remainder is not valid&quot;);
1797     assert (to_remainder % bytes_per_count == 0, &quot;to must be aligned by bytes_per_count&quot;);
1798 
1799     int bytes_to_write = forward ? (wordSize - to_remainder) : to_remainder;
1800 
1801     int offset = 0;
1802 
1803     for (int l = 0; l &lt; LogBytesPerWord; ++l) {
1804       int s = (1 &lt;&lt; l);
1805       if (bytes_to_write &amp; s) {
1806         int new_offset = offset + s*BitsPerByte;
1807         if (forward) {
1808           if (offset == 0) {
1809             store_one(Rval, to, s, forward);
1810           } else {
1811             __ logical_shift_right(tmp, Rval, offset);
1812             store_one(tmp, to, s, forward);
1813           }
1814         } else {
1815           __ logical_shift_right(tmp, Rval, BitsPerWord - new_offset);
1816           store_one(tmp, to, s, forward);
1817         }
1818 
1819         offset = new_offset;
1820       }
1821     }
1822 
1823     assert (offset == bytes_to_write * BitsPerByte, &quot;all bytes must be copied&quot;);
1824 
1825     __ sub_32(count, count, bytes_to_write/bytes_per_count);
1826 
1827     return bytes_to_write / bytes_per_count;
1828   }
1829 
1830   // Copies &#39;count&#39; of elements using shifted copy loop
1831   //
1832   // Arguments:
1833   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1834   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1835   //     count:             32-bit int, number of elements to be copied
1836   //     to_remainder:      remainder of dividing &#39;to&#39; by wordSize
1837   //     bytes_per_count:   size of an element
1838   //     forward:           specifies copy direction
1839   //     Rval:              contains an already read but not yet written word
1840   //
1841   //
1842   // Notes:
1843   //     &#39;count&#39; must not be less then the returned value
1844   //     &#39;from&#39; must be aligned by wordSize
1845   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1846   //     shifts &#39;to&#39; by the number of copied bytes
1847   //
1848   // Scratches R3-R10, R12
1849   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, Register Rval,
1850                                                         int to_remainder, int bytes_per_count, bool forward) {
1851 
1852     assert (0 &lt; to_remainder &amp;&amp; to_remainder &lt; wordSize, &quot;to_remainder is invalid&quot;);
1853 
1854     const Register tmp  = forward ? R3 : R12;
1855     assert_different_registers(from, to, count, Rval, tmp);
1856 
1857     int required_to_align = align_dst(to, count, Rval, tmp, to_remainder, bytes_per_count, forward);
1858 
1859     int lsr_shift = (wordSize - to_remainder) * BitsPerByte;
1860     int lsl_shift = to_remainder * BitsPerByte;
1861 
1862     int min_copy;
1863     if (forward) {
1864       min_copy = generate_forward_shifted_copy_loop(from, to, count, bytes_per_count, lsr_shift, lsl_shift);
1865     } else {
1866       min_copy = generate_backward_shifted_copy_loop(from, to, count, bytes_per_count, lsr_shift, lsl_shift);
1867     }
1868 
1869     return min_copy + required_to_align;
1870   }
1871 
1872   // Copies &#39;count&#39; of elements using shifted copy loop
1873   //
1874   // Arguments:
1875   //     from:              beginning (if forward) or upper bound (if !forward) of the region to be read
1876   //     to:                beginning (if forward) or upper bound (if !forward) of the region to be written
1877   //     count:             32-bit int, number of elements to be copied
1878   //     bytes_per_count:   size of an element
1879   //     forward:           specifies copy direction
1880   //
1881   // Notes:
1882   //     &#39;count&#39; must not be less then the returned value
1883   //     &#39;from&#39; must be aligned by wordSize
1884   //     &#39;to&#39; must be aligned by bytes_per_count but must not be aligned by wordSize
1885   //     shifts &#39;to&#39; by the number of copied bytes
1886   //
1887   // Scratches &#39;from&#39;, &#39;count&#39;, R3 and R12.
1888   // R4-R10 saved for use.
1889   int align_dst_and_generate_shifted_copy_loop(Register from, Register to, Register count, int bytes_per_count, bool forward, bool unsafe_copy = false) {
1890 
1891     const Register Rval = forward ? R12 : R3; // as generate_{forward,backward}_shifted_copy_loop expect
1892 
1893     int min_copy = 0;
1894 
1895     // Note: if {seq} is a sequence of numbers, L{seq} means that if the execution reaches this point,
1896     // then the remainder of &#39;to&#39; divided by wordSize is one of elements of {seq}.
1897 
1898     __ push(RegisterSet(R4,R10));
1899 
1900     {
1901       // UnsafeCopyMemory page error: continue after ucm
1902       UnsafeCopyMemoryMark ucmm(this, unsafe_copy, true);
1903       load_one(Rval, from, wordSize, forward);
1904 
1905       switch (bytes_per_count) {
1906         case 2:
1907           min_copy = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1908           break;
1909         case 1:
1910         {
1911           Label L1, L2, L3;
1912           int min_copy1, min_copy2, min_copy3;
1913 
1914           Label L_loop_finished;
1915 
1916           if (forward) {
1917               __ tbz(to, 0, L2);
1918               __ tbz(to, 1, L1);
1919 
1920               __ BIND(L3);
1921               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);
1922               __ b(L_loop_finished);
1923 
1924               __ BIND(L1);
1925               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);
1926               __ b(L_loop_finished);
1927 
1928               __ BIND(L2);
1929               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1930           } else {
1931               __ tbz(to, 0, L2);
1932               __ tbnz(to, 1, L3);
1933 
1934               __ BIND(L1);
1935               min_copy1 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 1, bytes_per_count, forward);
1936               __ b(L_loop_finished);
1937 
1938                __ BIND(L3);
1939               min_copy3 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 3, bytes_per_count, forward);
1940               __ b(L_loop_finished);
1941 
1942              __ BIND(L2);
1943               min_copy2 = align_dst_and_generate_shifted_copy_loop(from, to, count, Rval, 2, bytes_per_count, forward);
1944           }
1945 
1946           min_copy = MAX2(MAX2(min_copy1, min_copy2), min_copy3);
1947 
1948           __ BIND(L_loop_finished);
1949 
1950           break;
1951         }
1952         default:
1953           ShouldNotReachHere();
1954           break;
1955       }
1956     }
1957     __ pop(RegisterSet(R4,R10));
1958 
1959     return min_copy;
1960   }
1961 
1962 #ifndef PRODUCT
1963   int * get_arraycopy_counter(int bytes_per_count) {
1964     switch (bytes_per_count) {
1965       case 1:
1966         return &amp;SharedRuntime::_jbyte_array_copy_ctr;
1967       case 2:
1968         return &amp;SharedRuntime::_jshort_array_copy_ctr;
1969       case 4:
1970         return &amp;SharedRuntime::_jint_array_copy_ctr;
1971       case 8:
1972         return &amp;SharedRuntime::_jlong_array_copy_ctr;
1973       default:
1974         ShouldNotReachHere();
1975         return NULL;
1976     }
1977   }
1978 #endif // !PRODUCT
1979 
1980   address generate_unsafecopy_common_error_exit() {
1981     address start_pc = __ pc();
1982       __ mov(R0, 0);
1983       __ ret();
1984     return start_pc;
1985   }
1986 
1987   //
1988   //  Generate stub for primitive array copy.  If &quot;aligned&quot; is true, the
1989   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
1990   //
1991   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
1992   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
1993   //
1994   // Arguments for generated stub:
1995   //      from:  R0
1996   //      to:    R1
1997   //      count: R2 treated as signed 32-bit int
1998   //
1999   address generate_primitive_copy(bool aligned, const char * name, bool status, int bytes_per_count, bool disjoint, address nooverlap_target = NULL) {
2000     __ align(CodeEntryAlignment);
2001     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2002     address start = __ pc();
2003 
2004     const Register from  = R0;   // source array address
2005     const Register to    = R1;   // destination array address
2006     const Register count = R2;   // elements count
2007     const Register tmp1  = R3;
2008     const Register tmp2  = R12;
2009 
2010     if (!aligned)  {
2011       BLOCK_COMMENT(&quot;Entry:&quot;);
2012     }
2013 
2014     __ zap_high_non_significant_bits(R2);
2015 
2016     if (!disjoint) {
2017       assert (nooverlap_target != NULL, &quot;must be specified for conjoint case&quot;);
2018       array_overlap_test(nooverlap_target, exact_log2(bytes_per_count), tmp1, tmp2);
2019     }
2020 
2021     inc_counter_np(*get_arraycopy_counter(bytes_per_count), tmp1, tmp2);
2022 
2023     // Conjoint case: since execution reaches this point, the arrays overlap, so performing backward copy
2024     // Disjoint case: perform forward copy
2025     bool forward = disjoint;
2026 
2027 
2028     if (!forward) {
2029       // Set &#39;from&#39; and &#39;to&#39; to upper bounds
2030       int log_bytes_per_count = exact_log2(bytes_per_count);
2031       __ add_ptr_scaled_int32(to,   to,   count, log_bytes_per_count);
2032       __ add_ptr_scaled_int32(from, from, count, log_bytes_per_count);
2033     }
2034 
2035     // There are two main copy loop implementations:
2036     //  *) The huge and complex one applicable only for large enough arrays
2037     //  *) The small and simple one applicable for any array (but not efficient for large arrays).
2038     // Currently &quot;small&quot; implementation is used if and only if the &quot;large&quot; one could not be used.
2039     // XXX optim: tune the limit higher ?
2040     // Large implementation lower applicability bound is actually determined by
2041     // aligned copy loop which require &lt;=7 bytes for src alignment, and 8 words for aligned copy loop.
2042     const int small_copy_limit = (8*wordSize + 7) / bytes_per_count;
2043 
2044     Label L_small_array;
2045     __ cmp_32(count, small_copy_limit);
2046     __ b(L_small_array, le);
2047 
2048     // Otherwise proceed with large implementation.
2049 
2050     bool from_is_aligned = (bytes_per_count &gt;= 8);
2051     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2052         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2053         //  then from is aligned by 8
2054         from_is_aligned = true;
2055     }
2056 
2057     int count_required_to_align = 0;
2058     {
2059       // UnsafeCopyMemoryMark page error: continue at UnsafeCopyMemory common_error_exit
2060       UnsafeCopyMemoryMark ucmm(this, !aligned, false);
2061       count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);
2062       assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);
2063     }
2064 
2065     // now &#39;from&#39; is aligned
2066 
2067     bool to_is_aligned = false;
2068 
2069     if (bytes_per_count &gt;= wordSize) {
2070       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2071       to_is_aligned = true;
2072     } else {
2073       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2074         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2075         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2076         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2077         to_is_aligned = true;
2078       }
2079     }
2080 
2081     Label L_unaligned_dst;
2082 
2083     if (!to_is_aligned) {
2084       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2085       __ tst(to, wordSize - 1);
2086       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2087     }
2088 
2089     // &#39;from&#39; and &#39;to&#39; are properly aligned
2090 
2091     int min_copy;
2092     if (forward) {
2093       min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);
2094     } else {
2095       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count, !aligned /*add UnsafeCopyMemory entry*/);
2096     }
2097     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2098 
2099     if (status) {
2100       __ mov(R0, 0); // OK
2101     }
2102 
2103     __ ret();
2104 
2105     {
2106       copy_small_array(from, to, count, tmp1, tmp2, bytes_per_count, forward, L_small_array /* entry */, !aligned /*add UnsafeCopyMemory entry*/);
2107 
2108       if (status) {
2109         __ mov(R0, 0); // OK
2110       }
2111 
2112       __ ret();
2113     }
2114 
2115     if (! to_is_aligned) {
2116       __ BIND(L_unaligned_dst);
2117       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward, !aligned /*add UnsafeCopyMemory entry*/);
2118       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2119 
2120       if (status) {
2121         __ mov(R0, 0); // OK
2122       }
2123 
2124       __ ret();
2125     }
2126 
2127     return start;
2128   }
2129 
2130 
2131   // Generates pattern of code to be placed after raw data copying in generate_oop_copy
2132   // Includes return from arraycopy stub.
2133   //
2134   // Arguments:
2135   //     to:       destination pointer after copying.
2136   //               if &#39;forward&#39; then &#39;to&#39; == upper bound, else &#39;to&#39; == beginning of the modified region
2137   //     count:    total number of copied elements, 32-bit int
2138   //
2139   // Blows all volatile R0-R3, Rtemp, LR) and &#39;to&#39;, &#39;count&#39;, &#39;tmp&#39; registers.
2140   void oop_arraycopy_stub_epilogue_helper(Register to, Register count, Register tmp, bool status, bool forward, DecoratorSet decorators) {
2141     assert_different_registers(to, count, tmp);
2142 
2143     if (forward) {
2144       // &#39;to&#39; is upper bound of the modified region
2145       // restore initial dst:
2146       __ sub_ptr_scaled_int32(to, to, count, LogBytesPerHeapOop);
2147     }
2148 
2149     // &#39;to&#39; is the beginning of the region
2150 
2151     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2152     bs-&gt;arraycopy_epilogue(_masm, decorators, true, to, count, tmp);
2153 
2154     if (status) {
2155       __ mov(R0, 0); // OK
2156     }
2157 
2158     __ pop(PC);
2159   }
2160 
2161 
2162   //  Generate stub for assign-compatible oop copy.  If &quot;aligned&quot; is true, the
2163   //  &quot;from&quot; and &quot;to&quot; addresses are assumed to be heapword aligned.
2164   //
2165   //  If &quot;disjoint&quot; is true, arrays are assumed to be disjoint, otherwise they may overlap and
2166   //  &quot;nooverlap_target&quot; must be specified as the address to jump if they don&#39;t.
2167   //
2168   // Arguments for generated stub:
2169   //      from:  R0
2170   //      to:    R1
2171   //      count: R2 treated as signed 32-bit int
2172   //
2173   address generate_oop_copy(bool aligned, const char * name, bool status, bool disjoint, address nooverlap_target = NULL) {
2174     __ align(CodeEntryAlignment);
2175     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2176     address start = __ pc();
2177 
2178     Register from  = R0;
2179     Register to    = R1;
2180     Register count = R2;
2181     Register tmp1  = R3;
2182     Register tmp2  = R12;
2183 
2184 
2185     if (!aligned) {
2186       BLOCK_COMMENT(&quot;Entry:&quot;);
2187     }
2188 
2189     __ zap_high_non_significant_bits(R2);
2190 
2191     if (!disjoint) {
2192       assert (nooverlap_target != NULL, &quot;must be specified for conjoint case&quot;);
2193       array_overlap_test(nooverlap_target, LogBytesPerHeapOop, tmp1, tmp2);
2194     }
2195 
2196     inc_counter_np(SharedRuntime::_oop_array_copy_ctr, tmp1, tmp2);
2197 
2198     // Conjoint case: since execution reaches this point, the arrays overlap, so performing backward copy
2199     // Disjoint case: perform forward copy
2200     bool forward = disjoint;
2201 
2202     const int bytes_per_count = BytesPerHeapOop;
2203     const int log_bytes_per_count = LogBytesPerHeapOop;
2204 
2205     const Register saved_count = LR;
2206     const int callee_saved_regs = 3; // R0-R2
2207 
2208     // LR is used later to save barrier args
2209     __ push(LR);
2210 
2211     DecoratorSet decorators = IN_HEAP | IS_ARRAY;
2212     if (disjoint) {
2213       decorators |= ARRAYCOPY_DISJOINT;
2214     }
2215     if (aligned) {
2216       decorators |= ARRAYCOPY_ALIGNED;
2217     }
2218 
2219     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2220     bs-&gt;arraycopy_prologue(_masm, decorators, true, to, count, callee_saved_regs);
2221 
2222     // save arguments for barrier generation (after the pre barrier)
2223     __ mov(saved_count, count);
2224 
2225     if (!forward) {
2226       __ add_ptr_scaled_int32(to,   to,   count, log_bytes_per_count);
2227       __ add_ptr_scaled_int32(from, from, count, log_bytes_per_count);
2228     }
2229 
2230     // for short arrays, just do single element copy
2231     Label L_small_array;
2232     const int small_copy_limit = (8*wordSize + 7)/bytes_per_count; // XXX optim: tune the limit higher ?
2233     __ cmp_32(count, small_copy_limit);
2234     __ b(L_small_array, le);
2235 
2236     bool from_is_aligned = (bytes_per_count &gt;= 8);
2237     if (aligned &amp;&amp; forward &amp;&amp; (HeapWordSize % 8 == 0)) {
2238         // if &#39;from&#39; is heapword aligned and HeapWordSize is divisible by 8,
2239         //  then from is aligned by 8
2240         from_is_aligned = true;
2241     }
2242 
2243     int count_required_to_align = from_is_aligned ? 0 : align_src(from, to, count, tmp1, bytes_per_count, forward);
2244     assert (small_copy_limit &gt;= count_required_to_align, &quot;alignment could exhaust count&quot;);
2245 
2246     // now &#39;from&#39; is aligned
2247 
2248     bool to_is_aligned = false;
2249 
2250     if (bytes_per_count &gt;= wordSize) {
2251       // &#39;to&#39; is aligned by bytes_per_count, so it is aligned by wordSize
2252       to_is_aligned = true;
2253     } else {
2254       if (aligned &amp;&amp; (8 % HeapWordSize == 0) &amp;&amp; (HeapWordSize % wordSize == 0)) {
2255         // Originally &#39;from&#39; and &#39;to&#39; were heapword aligned;
2256         // (from - to) has not been changed, so since now &#39;from&#39; is 8-byte aligned, then it is also heapword aligned,
2257         //  so &#39;to&#39; is also heapword aligned and thus aligned by wordSize.
2258         to_is_aligned = true;
2259       }
2260     }
2261 
2262     Label L_unaligned_dst;
2263 
2264     if (!to_is_aligned) {
2265       BLOCK_COMMENT(&quot;Check dst alignment:&quot;);
2266       __ tst(to, wordSize - 1);
2267       __ b(L_unaligned_dst, ne); // &#39;to&#39; is not aligned
2268     }
2269 
2270     int min_copy;
2271     if (forward) {
2272       min_copy = generate_forward_aligned_copy_loop(from, to, count, bytes_per_count);
2273     } else {
2274       min_copy = generate_backward_aligned_copy_loop(from, to, count, bytes_per_count);
2275     }
2276     assert(small_copy_limit &gt;= count_required_to_align + min_copy, &quot;first loop might exhaust count&quot;);
2277 
2278     oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2279 
2280     {
2281       copy_small_array(from, to, count, tmp1, noreg, bytes_per_count, forward, L_small_array);
2282 
2283       oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2284     }
2285 
2286     if (!to_is_aligned) {
2287       __ BIND(L_unaligned_dst);
2288       ShouldNotReachHere();
2289       int min_copy_shifted = align_dst_and_generate_shifted_copy_loop(from, to, count, bytes_per_count, forward);
2290       assert (small_copy_limit &gt;= count_required_to_align + min_copy_shifted, &quot;first loop might exhaust count&quot;);
2291 
2292       oop_arraycopy_stub_epilogue_helper(to, saved_count, /* tmp */ tmp1, status, forward, decorators);
2293     }
2294 
2295     return start;
2296   }
2297 
2298   //  Generate &#39;unsafe&#39; array copy stub
2299   //  Though just as safe as the other stubs, it takes an unscaled
2300   //  size_t argument instead of an element count.
2301   //
2302   // Arguments for generated stub:
2303   //      from:  R0
2304   //      to:    R1
2305   //      count: R2 byte count, treated as ssize_t, can be zero
2306   //
2307   // Examines the alignment of the operands and dispatches
2308   // to a long, int, short, or byte copy loop.
2309   //
2310   address generate_unsafe_copy(const char* name) {
2311 
2312     const Register R0_from   = R0;      // source array address
2313     const Register R1_to     = R1;      // destination array address
2314     const Register R2_count  = R2;      // elements count
2315 
2316     const Register R3_bits   = R3;      // test copy of low bits
2317 
2318     __ align(CodeEntryAlignment);
2319     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2320     address start = __ pc();
2321     const Register tmp = Rtemp;
2322 
2323     // bump this on entry, not on exit:
2324     inc_counter_np(SharedRuntime::_unsafe_array_copy_ctr, R3, tmp);
2325 
2326     __ orr(R3_bits, R0_from, R1_to);
2327     __ orr(R3_bits, R2_count, R3_bits);
2328 
2329     __ tst(R3_bits, BytesPerLong-1);
2330     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerLong), eq);
2331     __ jump(StubRoutines::_jlong_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2332 
2333     __ tst(R3_bits, BytesPerInt-1);
2334     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerInt), eq);
2335     __ jump(StubRoutines::_jint_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2336 
2337     __ tst(R3_bits, BytesPerShort-1);
2338     __ mov(R2_count,AsmOperand(R2_count,asr,LogBytesPerShort), eq);
2339     __ jump(StubRoutines::_jshort_arraycopy, relocInfo::runtime_call_type, tmp, eq);
2340 
2341     __ jump(StubRoutines::_jbyte_arraycopy, relocInfo::runtime_call_type, tmp);
2342     return start;
2343   }
2344 
2345   // Helper for generating a dynamic type check.
2346   // Smashes only the given temp registers.
2347   void generate_type_check(Register sub_klass,
2348                            Register super_check_offset,
2349                            Register super_klass,
2350                            Register tmp1,
2351                            Register tmp2,
2352                            Register tmp3,
2353                            Label&amp; L_success) {
2354     assert_different_registers(sub_klass, super_check_offset, super_klass, tmp1, tmp2, tmp3);
2355 
2356     BLOCK_COMMENT(&quot;type_check:&quot;);
2357 
2358     // If the pointers are equal, we are done (e.g., String[] elements).
2359 
2360     __ cmp(super_klass, sub_klass);
2361     __ b(L_success, eq); // fast success
2362 
2363 
2364     Label L_loop, L_fail;
2365 
2366     int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2367 
2368     // Check the supertype display:
2369     __ ldr(tmp1, Address(sub_klass, super_check_offset));
2370     __ cmp(tmp1, super_klass);
2371     __ b(L_success, eq);
2372 
2373     __ cmp(super_check_offset, sc_offset);
2374     __ b(L_fail, ne); // failure
2375 
2376     BLOCK_COMMENT(&quot;type_check_slow_path:&quot;);
2377 
2378     // a couple of useful fields in sub_klass:
2379     int ss_offset = in_bytes(Klass::secondary_supers_offset());
2380 
2381     // Do a linear scan of the secondary super-klass chain.
2382 
2383 #ifndef PRODUCT
2384     int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2385     __ inc_counter((address) pst_counter, tmp1, tmp2);
2386 #endif
2387 
2388     Register scan_temp = tmp1;
2389     Register count_temp = tmp2;
2390 
2391     // We will consult the secondary-super array.
2392     __ ldr(scan_temp, Address(sub_klass, ss_offset));
2393 
2394     Register search_key = super_klass;
2395 
2396     // Load the array length.
2397     __ ldr_s32(count_temp, Address(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes()));
2398     __ add(scan_temp, scan_temp, Array&lt;Klass*&gt;::base_offset_in_bytes());
2399 
2400     __ add(count_temp, count_temp, 1);
2401 
2402     // Top of search loop
2403     __ bind(L_loop);
2404     // Notes:
2405     //  scan_temp starts at the array elements
2406     //  count_temp is 1+size
2407 
2408     __ subs(count_temp, count_temp, 1);
2409     __ b(L_fail, eq); // not found
2410 
2411     // Load next super to check
2412     // In the array of super classes elements are pointer sized.
2413     int element_size = wordSize;
2414     __ ldr(tmp3, Address(scan_temp, element_size, post_indexed));
2415 
2416     // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2417     __ cmp(tmp3, search_key);
2418 
2419     // A miss means we are NOT a subtype and need to keep looping
2420     __ b(L_loop, ne);
2421 
2422     // Falling out the bottom means we found a hit; we ARE a subtype
2423 
2424     // Success.  Cache the super we found and proceed in triumph.
2425     __ str(super_klass, Address(sub_klass, sc_offset));
2426 
2427     // Jump to success
2428     __ b(L_success);
2429 
2430     // Fall through on failure!
2431     __ bind(L_fail);
2432   }
2433 
2434   //  Generate stub for checked oop copy.
2435   //
2436   // Arguments for generated stub:
2437   //      from:  R0
2438   //      to:    R1
2439   //      count: R2 treated as signed 32-bit int
2440   //      ckoff: R3 (super_check_offset)
2441   //      ckval: R4 (super_klass)
2442   //      ret:   R0 zero for success; (-1^K) where K is partial transfer count (32-bit)
2443   //
2444   address generate_checkcast_copy(const char * name) {
2445     __ align(CodeEntryAlignment);
2446     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2447     address start = __ pc();
2448 
2449     const Register from  = R0;  // source array address
2450     const Register to    = R1;  // destination array address
2451     const Register count = R2;  // elements count
2452 
2453     const Register R3_ckoff  = R3;      // super_check_offset
2454     const Register R4_ckval  = R4;      // super_klass
2455 
2456     const int callee_saved_regs = 4; // LR saved differently
2457 
2458     Label load_element, store_element, do_epilogue, fail;
2459 
2460     BLOCK_COMMENT(&quot;Entry:&quot;);
2461 
2462     __ zap_high_non_significant_bits(R2);
2463 
2464     int pushed = 0;
2465     __ push(LR);
2466     pushed+=1;
2467 
2468     DecoratorSet decorators = IN_HEAP | IS_ARRAY | ARRAYCOPY_CHECKCAST;
2469 
2470     BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
2471     bs-&gt;arraycopy_prologue(_masm, decorators, true, to, count, callee_saved_regs);
2472 
2473     const RegisterSet caller_saved_regs = RegisterSet(R4,R6) | RegisterSet(R8,R9) | altFP_7_11;
2474     __ push(caller_saved_regs);
2475     assert(caller_saved_regs.size() == 6, &quot;check the count&quot;);
2476     pushed+=6;
2477 
2478     __ ldr(R4_ckval,Address(SP, wordSize*pushed)); // read the argument that was on the stack
2479 
2480     // Save arguments for barrier generation (after the pre barrier):
2481     // - must be a caller saved register and not LR
2482     // - ARM32: avoid R10 in case RThread is needed
2483     const Register saved_count = altFP_7_11;
2484     __ movs(saved_count, count); // and test count
2485     __ b(load_element,ne);
2486 
2487     // nothing to copy
2488     __ mov(R0, 0);
2489 
2490     __ pop(caller_saved_regs);
2491     __ pop(PC);
2492 
2493     // ======== begin loop ========
2494     // (Loop is rotated; its entry is load_element.)
2495     __ align(OptoLoopAlignment);
2496     __ BIND(store_element);
2497     if (UseCompressedOops) {
2498       __ store_heap_oop(Address(to, BytesPerHeapOop, post_indexed), R5);  // store the oop, changes flags
2499       __ subs_32(count,count,1);
2500     } else {
2501       __ subs_32(count,count,1);
2502       __ str(R5, Address(to, BytesPerHeapOop, post_indexed));             // store the oop
2503     }
2504     __ b(do_epilogue, eq); // count exhausted
2505 
2506     // ======== loop entry is here ========
2507     __ BIND(load_element);
2508     __ load_heap_oop(R5, Address(from, BytesPerHeapOop, post_indexed));  // load the oop
2509     __ cbz(R5, store_element); // NULL
2510 
2511     __ load_klass(R6, R5);
2512 
2513     generate_type_check(R6, R3_ckoff, R4_ckval, /*tmps*/ R12, R8, R9,
2514                         // branch to this on success:
2515                         store_element);
2516     // ======== end loop ========
2517 
2518     // It was a real error; we must depend on the caller to finish the job.
2519     // Register count has number of *remaining* oops, saved_count number of *total* oops.
2520     // Emit GC store barriers for the oops we have copied
2521     // and report their number to the caller (0 or (-1^n))
2522     __ BIND(fail);
2523 
2524     // Note: fail marked by the fact that count differs from saved_count
2525 
2526     __ BIND(do_epilogue);
2527 
2528     Register copied = R4; // saved
2529     Label L_not_copied;
2530 
2531     __ subs_32(copied, saved_count, count); // copied count (in saved reg)
2532     __ b(L_not_copied, eq); // nothing was copied, skip post barrier
2533     __ sub(to, to, AsmOperand(copied, lsl, LogBytesPerHeapOop)); // initial to value
2534     __ mov(R12, copied); // count arg scratched by post barrier
2535 
2536     bs-&gt;arraycopy_epilogue(_masm, decorators, true, to, R12, R3);
2537 
2538     assert_different_registers(R3,R12,LR,copied,saved_count);
2539     inc_counter_np(SharedRuntime::_checkcast_array_copy_ctr, R3, R12);
2540 
2541     __ BIND(L_not_copied);
2542     __ cmp_32(copied, saved_count); // values preserved in saved registers
2543 
2544     __ mov(R0, 0, eq); // 0 if all copied
2545     __ mvn(R0, copied, ne); // else NOT(copied)
2546     __ pop(caller_saved_regs);
2547     __ pop(PC);
2548 
2549     return start;
2550   }
2551 
2552   // Perform range checks on the proposed arraycopy.
2553   // Kills the two temps, but nothing else.
2554   void arraycopy_range_checks(Register src,     // source array oop
2555                               Register src_pos, // source position (32-bit int)
2556                               Register dst,     // destination array oop
2557                               Register dst_pos, // destination position (32-bit int)
2558                               Register length,  // length of copy (32-bit int)
2559                               Register temp1, Register temp2,
2560                               Label&amp; L_failed) {
2561 
2562     BLOCK_COMMENT(&quot;arraycopy_range_checks:&quot;);
2563 
2564     //  if (src_pos + length &gt; arrayOop(src)-&gt;length() ) FAIL;
2565 
2566     const Register array_length = temp1;  // scratch
2567     const Register end_pos      = temp2;  // scratch
2568 
2569     __ add_32(end_pos, length, src_pos);  // src_pos + length
2570     __ ldr_s32(array_length, Address(src, arrayOopDesc::length_offset_in_bytes()));
2571     __ cmp_32(end_pos, array_length);
2572     __ b(L_failed, hi);
2573 
2574     //  if (dst_pos + length &gt; arrayOop(dst)-&gt;length() ) FAIL;
2575     __ add_32(end_pos, length, dst_pos); // dst_pos + length
2576     __ ldr_s32(array_length, Address(dst, arrayOopDesc::length_offset_in_bytes()));
2577     __ cmp_32(end_pos, array_length);
2578     __ b(L_failed, hi);
2579 
2580     BLOCK_COMMENT(&quot;arraycopy_range_checks done&quot;);
2581   }
2582 
2583   //
2584   //  Generate generic array copy stubs
2585   //
2586   //  Input:
2587   //    R0    -  src oop
2588   //    R1    -  src_pos (32-bit int)
2589   //    R2    -  dst oop
2590   //    R3    -  dst_pos (32-bit int)
2591   //    SP[0] -  element count (32-bit int)
2592   //
2593   //  Output: (32-bit int)
2594   //    R0 ==  0  -  success
2595   //    R0 &lt;   0  -  need to call System.arraycopy
2596   //
2597   address generate_generic_copy(const char *name) {
2598     Label L_failed, L_objArray;
2599 
2600     // Input registers
2601     const Register src      = R0;  // source array oop
2602     const Register src_pos  = R1;  // source position
2603     const Register dst      = R2;  // destination array oop
2604     const Register dst_pos  = R3;  // destination position
2605 
2606     // registers used as temp
2607     const Register R5_src_klass = R5; // source array klass
2608     const Register R6_dst_klass = R6; // destination array klass
2609     const Register R_lh         = altFP_7_11; // layout handler
2610     const Register R8_temp      = R8;
2611 
2612     __ align(CodeEntryAlignment);
2613     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2614     address start = __ pc();
2615 
2616     __ zap_high_non_significant_bits(R1);
2617     __ zap_high_non_significant_bits(R3);
2618     __ zap_high_non_significant_bits(R4);
2619 
2620     int pushed = 0;
2621     const RegisterSet saved_regs = RegisterSet(R4,R6) | RegisterSet(R8,R9) | altFP_7_11;
2622     __ push(saved_regs);
2623     assert(saved_regs.size() == 6, &quot;check the count&quot;);
2624     pushed+=6;
2625 
2626     // bump this on entry, not on exit:
2627     inc_counter_np(SharedRuntime::_generic_array_copy_ctr, R5, R12);
2628 
2629     const Register length   = R4;  // elements count
2630     __ ldr(length, Address(SP,4*pushed));
2631 
2632 
2633     //-----------------------------------------------------------------------
2634     // Assembler stubs will be used for this call to arraycopy
2635     // if the following conditions are met:
2636     //
2637     // (1) src and dst must not be null.
2638     // (2) src_pos must not be negative.
2639     // (3) dst_pos must not be negative.
2640     // (4) length  must not be negative.
2641     // (5) src klass and dst klass should be the same and not NULL.
2642     // (6) src and dst should be arrays.
2643     // (7) src_pos + length must not exceed length of src.
2644     // (8) dst_pos + length must not exceed length of dst.
2645     BLOCK_COMMENT(&quot;arraycopy initial argument checks&quot;);
2646 
2647     //  if (src == NULL) return -1;
2648     __ cbz(src, L_failed);
2649 
2650     //  if (src_pos &lt; 0) return -1;
2651     __ cmp_32(src_pos, 0);
2652     __ b(L_failed, lt);
2653 
2654     //  if (dst == NULL) return -1;
2655     __ cbz(dst, L_failed);
2656 
2657     //  if (dst_pos &lt; 0) return -1;
2658     __ cmp_32(dst_pos, 0);
2659     __ b(L_failed, lt);
2660 
2661     //  if (length &lt; 0) return -1;
2662     __ cmp_32(length, 0);
2663     __ b(L_failed, lt);
2664 
2665     BLOCK_COMMENT(&quot;arraycopy argument klass checks&quot;);
2666     //  get src-&gt;klass()
2667     __ load_klass(R5_src_klass, src);
2668 
2669     // Load layout helper
2670     //
2671     //  |array_tag|     | header_size | element_type |     |log2_element_size|
2672     // 32        30    24            16              8     2                 0
2673     //
2674     //   array_tag: typeArray = 0x3, objArray = 0x2, non-array = 0x0
2675     //
2676 
2677     int lh_offset = in_bytes(Klass::layout_helper_offset());
2678     __ ldr_u32(R_lh, Address(R5_src_klass, lh_offset));
2679 
2680     __ load_klass(R6_dst_klass, dst);
2681 
2682     // Handle objArrays completely differently...
2683     juint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2684     __ mov_slow(R8_temp, objArray_lh);
2685     __ cmp_32(R_lh, R8_temp);
2686     __ b(L_objArray,eq);
2687 
2688     //  if (src-&gt;klass() != dst-&gt;klass()) return -1;
2689     __ cmp(R5_src_klass, R6_dst_klass);
2690     __ b(L_failed, ne);
2691 
2692     //  if (!src-&gt;is_Array()) return -1;
2693     __ cmp_32(R_lh, Klass::_lh_neutral_value); // &lt; 0
2694     __ b(L_failed, ge);
2695 
2696     arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2697                            R8_temp, R6_dst_klass, L_failed);
2698 
2699     {
2700       // TypeArrayKlass
2701       //
2702       // src_addr = (src + array_header_in_bytes()) + (src_pos &lt;&lt; log2elemsize);
2703       // dst_addr = (dst + array_header_in_bytes()) + (dst_pos &lt;&lt; log2elemsize);
2704       //
2705 
2706       const Register R6_offset = R6_dst_klass;    // array offset
2707       const Register R12_elsize = R12;            // log2 element size
2708 
2709       __ logical_shift_right(R6_offset, R_lh, Klass::_lh_header_size_shift);
2710       __ andr(R6_offset, R6_offset, (unsigned int)Klass::_lh_header_size_mask); // array_offset
2711       __ add(src, src, R6_offset);       // src array offset
2712       __ add(dst, dst, R6_offset);       // dst array offset
2713       __ andr(R12_elsize, R_lh, (unsigned int)Klass::_lh_log2_element_size_mask); // log2 element size
2714 
2715       // next registers should be set before the jump to corresponding stub
2716       const Register from     = R0;  // source array address
2717       const Register to       = R1;  // destination array address
2718       const Register count    = R2;  // elements count
2719 
2720       // &#39;from&#39;, &#39;to&#39;, &#39;count&#39; registers should be set in this order
2721       // since they are the same as &#39;src&#39;, &#39;src_pos&#39;, &#39;dst&#39;.
2722 
2723 
2724       BLOCK_COMMENT(&quot;scale indexes to element size&quot;);
2725       __ add(from, src, AsmOperand(src_pos, lsl, R12_elsize));       // src_addr
2726       __ add(to, dst, AsmOperand(dst_pos, lsl, R12_elsize));         // dst_addr
2727 
2728       __ mov(count, length);  // length
2729 
2730       // XXX optim: avoid later push in arraycopy variants ?
2731 
2732       __ pop(saved_regs);
2733 
2734       BLOCK_COMMENT(&quot;choose copy loop based on element size&quot;);
2735       __ cmp(R12_elsize, 0);
2736       __ b(StubRoutines::_jbyte_arraycopy,eq);
2737 
2738       __ cmp(R12_elsize, LogBytesPerShort);
2739       __ b(StubRoutines::_jshort_arraycopy,eq);
2740 
2741       __ cmp(R12_elsize, LogBytesPerInt);
2742       __ b(StubRoutines::_jint_arraycopy,eq);
2743 
2744       __ b(StubRoutines::_jlong_arraycopy);
2745 
2746     }
2747 
2748     // ObjArrayKlass
2749     __ BIND(L_objArray);
2750     // live at this point:  R5_src_klass, R6_dst_klass, src[_pos], dst[_pos], length
2751 
2752     Label L_plain_copy, L_checkcast_copy;
2753     //  test array classes for subtyping
2754     __ cmp(R5_src_klass, R6_dst_klass);         // usual case is exact equality
2755     __ b(L_checkcast_copy, ne);
2756 
2757     BLOCK_COMMENT(&quot;Identically typed arrays&quot;);
2758     {
2759       // Identically typed arrays can be copied without element-wise checks.
2760       arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2761                              R8_temp, R_lh, L_failed);
2762 
2763       // next registers should be set before the jump to corresponding stub
2764       const Register from     = R0;  // source array address
2765       const Register to       = R1;  // destination array address
2766       const Register count    = R2;  // elements count
2767 
2768       __ add(src, src, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //src offset
2769       __ add(dst, dst, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //dst offset
2770       __ add_ptr_scaled_int32(from, src, src_pos, LogBytesPerHeapOop);         // src_addr
2771       __ add_ptr_scaled_int32(to, dst, dst_pos, LogBytesPerHeapOop);           // dst_addr
2772       __ BIND(L_plain_copy);
2773       __ mov(count, length);
2774 
2775       __ pop(saved_regs); // XXX optim: avoid later push in oop_arraycopy ?
2776       __ b(StubRoutines::_oop_arraycopy);
2777     }
2778 
2779     {
2780       __ BIND(L_checkcast_copy);
2781       // live at this point:  R5_src_klass, R6_dst_klass
2782 
2783       // Before looking at dst.length, make sure dst is also an objArray.
2784       __ ldr_u32(R8_temp, Address(R6_dst_klass, lh_offset));
2785       __ cmp_32(R_lh, R8_temp);
2786       __ b(L_failed, ne);
2787 
2788       // It is safe to examine both src.length and dst.length.
2789 
2790       arraycopy_range_checks(src, src_pos, dst, dst_pos, length,
2791                              R8_temp, R_lh, L_failed);
2792 
2793       // next registers should be set before the jump to corresponding stub
2794       const Register from     = R0;  // source array address
2795       const Register to       = R1;  // destination array address
2796       const Register count    = R2;  // elements count
2797 
2798       // Marshal the base address arguments now, freeing registers.
2799       __ add(src, src, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //src offset
2800       __ add(dst, dst, arrayOopDesc::base_offset_in_bytes(T_OBJECT)); //dst offset
2801       __ add_ptr_scaled_int32(from, src, src_pos, LogBytesPerHeapOop);         // src_addr
2802       __ add_ptr_scaled_int32(to, dst, dst_pos, LogBytesPerHeapOop);           // dst_addr
2803 
2804       __ mov(count, length); // length (reloaded)
2805 
2806       Register sco_temp = R3;                   // this register is free now
2807       assert_different_registers(from, to, count, sco_temp,
2808                                  R6_dst_klass, R5_src_klass);
2809 
2810       // Generate the type check.
2811       int sco_offset = in_bytes(Klass::super_check_offset_offset());
2812       __ ldr_u32(sco_temp, Address(R6_dst_klass, sco_offset));
2813       generate_type_check(R5_src_klass, sco_temp, R6_dst_klass,
2814                           R8_temp, R9,
2815                           R12,
2816                           L_plain_copy);
2817 
2818       // Fetch destination element klass from the ObjArrayKlass header.
2819       int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2820 
2821       // the checkcast_copy loop needs two extra arguments:
2822       const Register Rdst_elem_klass = R3;
2823       __ ldr(Rdst_elem_klass, Address(R6_dst_klass, ek_offset));   // dest elem klass
2824       __ pop(saved_regs); // XXX optim: avoid later push in oop_arraycopy ?
2825       __ str(Rdst_elem_klass, Address(SP,0));    // dest elem klass argument
2826       __ ldr_u32(R3, Address(Rdst_elem_klass, sco_offset));  // sco of elem klass
2827       __ b(StubRoutines::_checkcast_arraycopy);
2828     }
2829 
2830     __ BIND(L_failed);
2831 
2832     __ pop(saved_regs);
2833     __ mvn(R0, 0); // failure, with 0 copied
2834     __ ret();
2835 
2836     return start;
2837   }
2838 
2839   // Safefetch stubs.
2840   void generate_safefetch(const char* name, int size, address* entry, address* fault_pc, address* continuation_pc) {
2841     // safefetch signatures:
2842     //   int      SafeFetch32(int*      adr, int      errValue);
2843     //   intptr_t SafeFetchN (intptr_t* adr, intptr_t errValue);
2844     //
2845     // arguments:
2846     //   R0 = adr
2847     //   R1 = errValue
2848     //
2849     // result:
2850     //   R0  = *adr or errValue
2851 
2852     StubCodeMark mark(this, &quot;StubRoutines&quot;, name);
2853 
2854     // Entry point, pc or function descriptor.
2855     *entry = __ pc();
2856 
2857     // Load *adr into c_rarg2, may fault.
2858     *fault_pc = __ pc();
2859 
2860     switch (size) {
2861       case 4: // int32_t
2862         __ ldr_s32(R1, Address(R0));
2863         break;
2864 
2865       case 8: // int64_t
2866         Unimplemented();
2867         break;
2868 
2869       default:
2870         ShouldNotReachHere();
2871     }
2872 
2873     // return errValue or *adr
2874     *continuation_pc = __ pc();
2875     __ mov(R0, R1);
2876     __ ret();
2877   }
2878 
2879   void generate_arraycopy_stubs() {
2880 
2881     // Note:  the disjoint stubs must be generated first, some of
2882     //        the conjoint stubs use them.
2883 
2884     bool status = false; // non failing C2 stubs need not return a status in R0
2885 
2886 #ifdef TEST_C2_GENERIC_ARRAYCOPY /* Internal development flag */
2887     // With this flag, the C2 stubs are tested by generating calls to
2888     // generic_arraycopy instead of Runtime1::arraycopy
2889 
2890     // Runtime1::arraycopy return a status in R0 (0 if OK, else ~copied)
2891     // and the result is tested to see whether the arraycopy stub should
2892     // be called.
2893 
2894     // When we test arraycopy this way, we must generate extra code in the
2895     // arraycopy methods callable from C2 generic_arraycopy to set the
2896     // status to 0 for those who always succeed (calling the slow path stub might
2897     // lead to errors since the copy has already been performed).
2898 
2899     status = true; // generate a status compatible with C1 calls
2900 #endif
2901 
2902     address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();
2903     UnsafeCopyMemory::set_common_exit_stub_pc(ucm_common_error_exit);
2904 
2905     // these need always status in case they are called from generic_arraycopy
2906     StubRoutines::_jbyte_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jbyte_disjoint_arraycopy&quot;,  true, 1, true);
2907     StubRoutines::_jshort_disjoint_arraycopy = generate_primitive_copy(false, &quot;jshort_disjoint_arraycopy&quot;, true, 2, true);
2908     StubRoutines::_jint_disjoint_arraycopy   = generate_primitive_copy(false, &quot;jint_disjoint_arraycopy&quot;,   true, 4, true);
2909     StubRoutines::_jlong_disjoint_arraycopy  = generate_primitive_copy(false, &quot;jlong_disjoint_arraycopy&quot;,  true, 8, true);
2910     StubRoutines::_oop_disjoint_arraycopy    = generate_oop_copy      (false, &quot;oop_disjoint_arraycopy&quot;,    true,    true);
2911 
2912     StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jbyte_disjoint_arraycopy&quot;, status, 1, true);
2913     StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_primitive_copy(true, &quot;arrayof_jshort_disjoint_arraycopy&quot;,status, 2, true);
2914     StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jint_disjoint_arraycopy&quot;,  status, 4, true);
2915     StubRoutines::_arrayof_jlong_disjoint_arraycopy  = generate_primitive_copy(true, &quot;arrayof_jlong_disjoint_arraycopy&quot;, status, 8, true);
2916     StubRoutines::_arrayof_oop_disjoint_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_disjoint_arraycopy&quot;,   status,    true);
2917 
2918     // these need always status in case they are called from generic_arraycopy
2919     StubRoutines::_jbyte_arraycopy  = generate_primitive_copy(false, &quot;jbyte_arraycopy&quot;,  true, 1, false, StubRoutines::_jbyte_disjoint_arraycopy);
2920     StubRoutines::_jshort_arraycopy = generate_primitive_copy(false, &quot;jshort_arraycopy&quot;, true, 2, false, StubRoutines::_jshort_disjoint_arraycopy);
2921     StubRoutines::_jint_arraycopy   = generate_primitive_copy(false, &quot;jint_arraycopy&quot;,   true, 4, false, StubRoutines::_jint_disjoint_arraycopy);
2922     StubRoutines::_jlong_arraycopy  = generate_primitive_copy(false, &quot;jlong_arraycopy&quot;,  true, 8, false, StubRoutines::_jlong_disjoint_arraycopy);
2923     StubRoutines::_oop_arraycopy    = generate_oop_copy      (false, &quot;oop_arraycopy&quot;,    true,    false, StubRoutines::_oop_disjoint_arraycopy);
2924 
2925     StubRoutines::_arrayof_jbyte_arraycopy    = generate_primitive_copy(true, &quot;arrayof_jbyte_arraycopy&quot;,  status, 1, false, StubRoutines::_arrayof_jbyte_disjoint_arraycopy);
2926     StubRoutines::_arrayof_jshort_arraycopy   = generate_primitive_copy(true, &quot;arrayof_jshort_arraycopy&quot;, status, 2, false, StubRoutines::_arrayof_jshort_disjoint_arraycopy);
2927 #ifdef _LP64
2928     // since sizeof(jint) &lt; sizeof(HeapWord), there&#39;s a different flavor:
2929     StubRoutines::_arrayof_jint_arraycopy     = generate_primitive_copy(true, &quot;arrayof_jint_arraycopy&quot;,   status, 4, false, StubRoutines::_arrayof_jint_disjoint_arraycopy);
2930 #else
2931     StubRoutines::_arrayof_jint_arraycopy     = StubRoutines::_jint_arraycopy;
2932 #endif
2933     if (BytesPerHeapOop &lt; HeapWordSize) {
2934       StubRoutines::_arrayof_oop_arraycopy    = generate_oop_copy      (true, &quot;arrayof_oop_arraycopy&quot;,    status,    false, StubRoutines::_arrayof_oop_disjoint_arraycopy);
2935     } else {
2936       StubRoutines::_arrayof_oop_arraycopy    = StubRoutines::_oop_arraycopy;
2937     }
2938     StubRoutines::_arrayof_jlong_arraycopy    = StubRoutines::_jlong_arraycopy;
2939 
2940     StubRoutines::_checkcast_arraycopy = generate_checkcast_copy(&quot;checkcast_arraycopy&quot;);
2941     StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(&quot;unsafe_arraycopy&quot;);
2942     StubRoutines::_generic_arraycopy   = generate_generic_copy(&quot;generic_arraycopy&quot;);
2943 
2944 
2945   }
2946 
2947 #define COMPILE_CRYPTO
2948 #include &quot;stubRoutinesCrypto_arm.cpp&quot;
2949 
2950  private:
2951 
2952 #undef  __
2953 #define __ masm-&gt;
2954 
2955   //------------------------------------------------------------------------------------------------------------------------
2956   // Continuation point for throwing of implicit exceptions that are not handled in
2957   // the current activation. Fabricates an exception oop and initiates normal
2958   // exception dispatching in this frame.
2959   address generate_throw_exception(const char* name, address runtime_entry) {
2960     int insts_size = 128;
2961     int locs_size  = 32;
2962     CodeBuffer code(name, insts_size, locs_size);
2963     OopMapSet* oop_maps;
2964     int frame_size;
2965     int frame_complete;
2966 
2967     oop_maps = new OopMapSet();
2968     MacroAssembler* masm = new MacroAssembler(&amp;code);
2969 
2970     address start = __ pc();
2971 
2972     frame_size = 2;
2973     __ mov(Rexception_pc, LR);
2974     __ raw_push(FP, LR);
2975 
2976     frame_complete = __ pc() - start;
2977 
2978     // Any extra arguments are already supposed to be R1 and R2
2979     __ mov(R0, Rthread);
2980 
2981     int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);
2982     assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
2983     __ call(runtime_entry);
2984     if (pc_offset == -1) {
2985       pc_offset = __ offset();
2986     }
2987 
2988     // Generate oop map
2989     OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);
2990     oop_maps-&gt;add_gc_map(pc_offset, map);
2991     __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
2992 
2993     __ raw_pop(FP, LR);
2994     __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
2995 
2996     RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &amp;code, frame_complete,
2997                                                       frame_size, oop_maps, false);
2998     return stub-&gt;entry_point();
2999   }
3000 
3001   //---------------------------------------------------------------------------
3002   // Initialization
3003 
3004   void generate_initial() {
3005     // Generates all stubs and initializes the entry points
3006 
3007     //------------------------------------------------------------------------------------------------------------------------
3008     // entry points that exist in all platforms
3009     // Note: This is code that could be shared among different platforms - however the benefit seems to be smaller than
3010     //       the disadvantage of having a much more complicated generator structure. See also comment in stubRoutines.hpp.
3011     StubRoutines::_forward_exception_entry      = generate_forward_exception();
3012 
3013     StubRoutines::_call_stub_entry              =
3014       generate_call_stub(StubRoutines::_call_stub_return_address);
3015     // is referenced by megamorphic call
3016     StubRoutines::_catch_exception_entry        = generate_catch_exception();
3017 
3018     // stub for throwing stack overflow error used both by interpreter and compiler
3019     StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(&quot;StackOverflowError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));
3020 
3021     // integer division used both by interpreter and compiler
3022     StubRoutines::Arm::_idiv_irem_entry = generate_idiv_irem();
3023 
3024     StubRoutines::_atomic_add_entry = generate_atomic_add();
3025     StubRoutines::_atomic_xchg_entry = generate_atomic_xchg();
3026     StubRoutines::_atomic_cmpxchg_entry = generate_atomic_cmpxchg();
3027     StubRoutines::_atomic_cmpxchg_long_entry = generate_atomic_cmpxchg_long();
3028     StubRoutines::_atomic_load_long_entry = generate_atomic_load_long();
3029     StubRoutines::_atomic_store_long_entry = generate_atomic_store_long();
3030   }
3031 
3032   void generate_all() {
3033     // Generates all stubs and initializes the entry points
3034 
3035 #ifdef COMPILER2
3036     // Generate partial_subtype_check first here since its code depends on
3037     // UseZeroBaseCompressedOops which is defined after heap initialization.
3038     StubRoutines::Arm::_partial_subtype_check                = generate_partial_subtype_check();
3039 #endif
3040     // These entry points require SharedInfo::stack0 to be set up in non-core builds
3041     // and need to be relocatable, so they each fabricate a RuntimeStub internally.
3042     StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(&quot;AbstractMethodError throw_exception&quot;,          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));
3043     StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(&quot;IncompatibleClassChangeError throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));
3044     StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(&quot;NullPointerException at call throw_exception&quot;, CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));
3045 
3046     //------------------------------------------------------------------------------------------------------------------------
3047     // entry points that are platform specific
3048 
3049     // support for verify_oop (must happen after universe_init)
3050     StubRoutines::_verify_oop_subroutine_entry     = generate_verify_oop();
3051 
3052     // arraycopy stubs used by compilers
3053     generate_arraycopy_stubs();
3054 
3055     // Safefetch stubs.
3056     generate_safefetch(&quot;SafeFetch32&quot;, sizeof(int), &amp;StubRoutines::_safefetch32_entry,
3057                                                    &amp;StubRoutines::_safefetch32_fault_pc,
3058                                                    &amp;StubRoutines::_safefetch32_continuation_pc);
3059     assert (sizeof(int) == wordSize, &quot;32-bit architecture&quot;);
3060     StubRoutines::_safefetchN_entry           = StubRoutines::_safefetch32_entry;
3061     StubRoutines::_safefetchN_fault_pc        = StubRoutines::_safefetch32_fault_pc;
3062     StubRoutines::_safefetchN_continuation_pc = StubRoutines::_safefetch32_continuation_pc;
3063 
3064 #ifdef COMPILE_CRYPTO
3065     // generate AES intrinsics code
3066     if (UseAESIntrinsics) {
3067       aes_init();
3068       StubRoutines::_aescrypt_encryptBlock = generate_aescrypt_encryptBlock();
3069       StubRoutines::_aescrypt_decryptBlock = generate_aescrypt_decryptBlock();
3070       StubRoutines::_cipherBlockChaining_encryptAESCrypt = generate_cipherBlockChaining_encryptAESCrypt();
3071       StubRoutines::_cipherBlockChaining_decryptAESCrypt = generate_cipherBlockChaining_decryptAESCrypt();
3072     }
3073 #endif // COMPILE_CRYPTO
3074   }
3075 
3076 
3077  public:
3078   StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {
3079     if (all) {
3080       generate_all();
3081     } else {
3082       generate_initial();
3083     }
3084   }
3085 }; // end class declaration
3086 
3087 #define UCM_TABLE_MAX_ENTRIES 32
3088 void StubGenerator_generate(CodeBuffer* code, bool all) {
3089   if (UnsafeCopyMemory::_table == NULL) {
3090     UnsafeCopyMemory::create_table(UCM_TABLE_MAX_ENTRIES);
3091   }
3092   StubGenerator g(code, all);
3093 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/sharedRuntime_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;assembler_arm.inline.hpp&quot;
  28 #include &quot;code/debugInfoRec.hpp&quot;
  29 #include &quot;code/icBuffer.hpp&quot;
  30 #include &quot;code/vtableStubs.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/compiledICHolder.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/safepointMechanism.hpp&quot;
  38 #include &quot;runtime/vframeArray.hpp&quot;
  39 #include &quot;utilities/align.hpp&quot;
<a name="1" id="anc1"></a>
  40 #include &quot;vmreg_arm.inline.hpp&quot;
  41 #ifdef COMPILER1
  42 #include &quot;c1/c1_Runtime1.hpp&quot;
  43 #endif
  44 #ifdef COMPILER2
  45 #include &quot;opto/runtime.hpp&quot;
  46 #endif
  47 
  48 #define __ masm-&gt;
  49 
  50 class RegisterSaver {
  51 public:
  52 
  53   // Special registers:
  54   //              32-bit ARM     64-bit ARM
  55   //  Rthread:       R10            R28
  56   //  LR:            R14            R30
  57 
  58   // Rthread is callee saved in the C ABI and never changed by compiled code:
  59   // no need to save it.
  60 
  61   // 2 slots for LR: the one at LR_offset and an other one at R14/R30_offset.
  62   // The one at LR_offset is a return address that is needed by stack walking.
  63   // A c2 method uses LR as a standard register so it may be live when we
  64   // branch to the runtime. The slot at R14/R30_offset is for the value of LR
  65   // in case it&#39;s live in the method we are coming from.
  66 
  67 
  68   enum RegisterLayout {
  69     fpu_save_size = FloatRegisterImpl::number_of_registers,
  70 #ifndef __SOFTFP__
  71     D0_offset = 0,
  72 #endif
  73     R0_offset = fpu_save_size,
  74     R1_offset,
  75     R2_offset,
  76     R3_offset,
  77     R4_offset,
  78     R5_offset,
  79     R6_offset,
  80 #if (FP_REG_NUM != 7)
  81     // if not saved as FP
  82     R7_offset,
  83 #endif
  84     R8_offset,
  85     R9_offset,
  86 #if (FP_REG_NUM != 11)
  87     // if not saved as FP
  88     R11_offset,
  89 #endif
  90     R12_offset,
  91     R14_offset,
  92     FP_offset,
  93     LR_offset,
  94     reg_save_size,
  95 
  96     Rmethod_offset = R9_offset,
  97     Rtemp_offset = R12_offset,
  98   };
  99 
 100   // all regs but Rthread (R10), FP (R7 or R11), SP and PC
 101   // (altFP_7_11 is the one amoung R7 and R11 which is not FP)
 102 #define SAVED_BASE_REGS (RegisterSet(R0, R6) | RegisterSet(R8, R9) | RegisterSet(R12) | R14 | altFP_7_11)
 103 
 104 
 105   //  When LR may be live in the nmethod from which we are comming
 106   //  then lr_saved is true, the return address is saved before the
 107   //  call to save_live_register by the caller and LR contains the
 108   //  live value.
 109 
 110   static OopMap* save_live_registers(MacroAssembler* masm,
 111                                      int* total_frame_words,
 112                                      bool lr_saved = false);
 113   static void restore_live_registers(MacroAssembler* masm, bool restore_lr = true);
 114 
 115 };
 116 
 117 
 118 
 119 
 120 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm,
 121                                            int* total_frame_words,
 122                                            bool lr_saved) {
 123   *total_frame_words = reg_save_size;
 124 
 125   OopMapSet *oop_maps = new OopMapSet();
 126   OopMap* map = new OopMap(VMRegImpl::slots_per_word * (*total_frame_words), 0);
 127 
 128   if (lr_saved) {
 129     __ push(RegisterSet(FP));
 130   } else {
 131     __ push(RegisterSet(FP) | RegisterSet(LR));
 132   }
 133   __ push(SAVED_BASE_REGS);
 134   if (HaveVFP) {
 135     if (VM_Version::has_vfp3_32()) {
 136       __ fpush(FloatRegisterSet(D16, 16));
 137     } else {
 138       if (FloatRegisterImpl::number_of_registers &gt; 32) {
 139         assert(FloatRegisterImpl::number_of_registers == 64, &quot;nb fp registers should be 64&quot;);
 140         __ sub(SP, SP, 32 * wordSize);
 141       }
 142     }
 143     __ fpush(FloatRegisterSet(D0, 16));
 144   } else {
 145     __ sub(SP, SP, fpu_save_size * wordSize);
 146   }
 147 
 148   int i;
 149   int j=0;
 150   for (i = R0_offset; i &lt;= R9_offset; i++) {
 151     if (j == FP_REG_NUM) {
 152       // skip the FP register, managed below.
 153       j++;
 154     }
 155     map-&gt;set_callee_saved(VMRegImpl::stack2reg(i), as_Register(j)-&gt;as_VMReg());
 156     j++;
 157   }
 158   assert(j == R10-&gt;encoding(), &quot;must be&quot;);
 159 #if (FP_REG_NUM != 11)
 160   // add R11, if not managed as FP
 161   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R11_offset), R11-&gt;as_VMReg());
 162 #endif
 163   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R12_offset), R12-&gt;as_VMReg());
 164   map-&gt;set_callee_saved(VMRegImpl::stack2reg(R14_offset), R14-&gt;as_VMReg());
 165   if (HaveVFP) {
 166     for (i = 0; i &lt; (VM_Version::has_vfp3_32() ? 64 : 32); i+=2) {
 167       map-&gt;set_callee_saved(VMRegImpl::stack2reg(i), as_FloatRegister(i)-&gt;as_VMReg());
 168       map-&gt;set_callee_saved(VMRegImpl::stack2reg(i + 1), as_FloatRegister(i)-&gt;as_VMReg()-&gt;next());
 169     }
 170   }
 171 
 172   return map;
 173 }
 174 
 175 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_lr) {
 176   if (HaveVFP) {
 177     __ fpop(FloatRegisterSet(D0, 16));
 178     if (VM_Version::has_vfp3_32()) {
 179       __ fpop(FloatRegisterSet(D16, 16));
 180     } else {
 181       if (FloatRegisterImpl::number_of_registers &gt; 32) {
 182         assert(FloatRegisterImpl::number_of_registers == 64, &quot;nb fp registers should be 64&quot;);
 183         __ add(SP, SP, 32 * wordSize);
 184       }
 185     }
 186   } else {
 187     __ add(SP, SP, fpu_save_size * wordSize);
 188   }
 189   __ pop(SAVED_BASE_REGS);
 190   if (restore_lr) {
 191     __ pop(RegisterSet(FP) | RegisterSet(LR));
 192   } else {
 193     __ pop(RegisterSet(FP));
 194   }
 195 }
 196 
 197 
 198 static void push_result_registers(MacroAssembler* masm, BasicType ret_type) {
 199 #ifdef __ABI_HARD__
 200   if (ret_type == T_DOUBLE || ret_type == T_FLOAT) {
 201     __ sub(SP, SP, 8);
 202     __ fstd(D0, Address(SP));
 203     return;
 204   }
 205 #endif // __ABI_HARD__
 206   __ raw_push(R0, R1);
 207 }
 208 
 209 static void pop_result_registers(MacroAssembler* masm, BasicType ret_type) {
 210 #ifdef __ABI_HARD__
 211   if (ret_type == T_DOUBLE || ret_type == T_FLOAT) {
 212     __ fldd(D0, Address(SP));
 213     __ add(SP, SP, 8);
 214     return;
 215   }
 216 #endif // __ABI_HARD__
 217   __ raw_pop(R0, R1);
 218 }
 219 
 220 static void push_param_registers(MacroAssembler* masm, int fp_regs_in_arguments) {
 221   // R1-R3 arguments need to be saved, but we push 4 registers for 8-byte alignment
 222   __ push(RegisterSet(R0, R3));
 223 
 224   // preserve arguments
 225   // Likely not needed as the locking code won&#39;t probably modify volatile FP registers,
 226   // but there is no way to guarantee that
 227   if (fp_regs_in_arguments) {
 228     // convert fp_regs_in_arguments to a number of double registers
 229     int double_regs_num = (fp_regs_in_arguments + 1) &gt;&gt; 1;
 230     __ fpush_hardfp(FloatRegisterSet(D0, double_regs_num));
 231   }
 232 }
 233 
 234 static void pop_param_registers(MacroAssembler* masm, int fp_regs_in_arguments) {
 235   if (fp_regs_in_arguments) {
 236     int double_regs_num = (fp_regs_in_arguments + 1) &gt;&gt; 1;
 237     __ fpop_hardfp(FloatRegisterSet(D0, double_regs_num));
 238   }
 239   __ pop(RegisterSet(R0, R3));
 240 }
 241 
 242 
 243 
 244 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 245 // All vector registers are saved by default on ARM.
 246 bool SharedRuntime::is_wide_vector(int size) {
 247   return false;
 248 }
 249 
 250 size_t SharedRuntime::trampoline_size() {
 251   return 16;
 252 }
 253 
 254 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 255   InlinedAddress dest(destination);
 256   __ indirect_jump(dest, Rtemp);
 257   __ bind_literal(dest);
 258 }
 259 
 260 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
 261                                         VMRegPair *regs,
 262                                         VMRegPair *regs2,
 263                                         int total_args_passed) {
 264   assert(regs2 == NULL, &quot;not needed on arm&quot;);
 265 
 266   int slot = 0;
 267   int ireg = 0;
 268 #ifdef __ABI_HARD__
 269   int fp_slot = 0;
 270   int single_fpr_slot = 0;
 271 #endif // __ABI_HARD__
 272   for (int i = 0; i &lt; total_args_passed; i++) {
 273     switch (sig_bt[i]) {
 274     case T_SHORT:
 275     case T_CHAR:
 276     case T_BYTE:
 277     case T_BOOLEAN:
 278     case T_INT:
 279     case T_ARRAY:
 280     case T_OBJECT:
 281     case T_ADDRESS:
 282     case T_METADATA:
 283 #ifndef __ABI_HARD__
 284     case T_FLOAT:
 285 #endif // !__ABI_HARD__
 286       if (ireg &lt; 4) {
 287         Register r = as_Register(ireg);
 288         regs[i].set1(r-&gt;as_VMReg());
 289         ireg++;
 290       } else {
 291         regs[i].set1(VMRegImpl::stack2reg(slot));
 292         slot++;
 293       }
 294       break;
 295     case T_LONG:
 296 #ifndef __ABI_HARD__
 297     case T_DOUBLE:
 298 #endif // !__ABI_HARD__
 299       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i+1] == T_VOID, &quot;missing Half&quot; );
 300       if (ireg &lt;= 2) {
 301 #if (ALIGN_WIDE_ARGUMENTS == 1)
 302         if(ireg &amp; 1) ireg++;  // Aligned location required
 303 #endif
 304         Register r1 = as_Register(ireg);
 305         Register r2 = as_Register(ireg + 1);
 306         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 307         ireg += 2;
 308 #if (ALIGN_WIDE_ARGUMENTS == 0)
 309       } else if (ireg == 3) {
 310         // uses R3 + one stack slot
 311         Register r = as_Register(ireg);
 312         regs[i].set_pair(VMRegImpl::stack2reg(slot), r-&gt;as_VMReg());
 313         ireg += 1;
 314         slot += 1;
 315 #endif
 316       } else {
 317         if (slot &amp; 1) slot++; // Aligned location required
 318         regs[i].set_pair(VMRegImpl::stack2reg(slot+1), VMRegImpl::stack2reg(slot));
 319         slot += 2;
 320         ireg = 4;
 321       }
 322       break;
 323     case T_VOID:
 324       regs[i].set_bad();
 325       break;
 326 #ifdef __ABI_HARD__
 327     case T_FLOAT:
 328       if ((fp_slot &lt; 16)||(single_fpr_slot &amp; 1)) {
 329         if ((single_fpr_slot &amp; 1) == 0) {
 330           single_fpr_slot = fp_slot;
 331           fp_slot += 2;
 332         }
 333         FloatRegister r = as_FloatRegister(single_fpr_slot);
 334         single_fpr_slot++;
 335         regs[i].set1(r-&gt;as_VMReg());
 336       } else {
 337         regs[i].set1(VMRegImpl::stack2reg(slot));
 338         slot++;
 339       }
 340       break;
 341     case T_DOUBLE:
 342       assert(ALIGN_WIDE_ARGUMENTS == 1, &quot;ABI_HARD not supported with unaligned wide arguments&quot;);
 343       if (fp_slot &lt;= 14) {
 344         FloatRegister r1 = as_FloatRegister(fp_slot);
 345         FloatRegister r2 = as_FloatRegister(fp_slot+1);
 346         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 347         fp_slot += 2;
 348       } else {
 349         if(slot &amp; 1) slot++;
 350         regs[i].set_pair(VMRegImpl::stack2reg(slot+1), VMRegImpl::stack2reg(slot));
 351         slot += 2;
 352         single_fpr_slot = 16;
 353       }
 354       break;
 355 #endif // __ABI_HARD__
 356     default:
 357       ShouldNotReachHere();
 358     }
 359   }
 360   return slot;
 361 }
 362 
 363 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 364                                            VMRegPair *regs,
 365                                            int total_args_passed,
 366                                            int is_outgoing) {
 367 #ifdef __SOFTFP__
 368   // soft float is the same as the C calling convention.
 369   return c_calling_convention(sig_bt, regs, NULL, total_args_passed);
 370 #endif // __SOFTFP__
 371   (void) is_outgoing;
 372   int slot = 0;
 373   int ireg = 0;
 374   int freg = 0;
 375   int single_fpr = 0;
 376 
 377   for (int i = 0; i &lt; total_args_passed; i++) {
 378     switch (sig_bt[i]) {
 379     case T_SHORT:
 380     case T_CHAR:
 381     case T_BYTE:
 382     case T_BOOLEAN:
 383     case T_INT:
 384     case T_ARRAY:
 385     case T_OBJECT:
 386     case T_ADDRESS:
 387       if (ireg &lt; 4) {
 388         Register r = as_Register(ireg++);
 389         regs[i].set1(r-&gt;as_VMReg());
 390       } else {
 391         regs[i].set1(VMRegImpl::stack2reg(slot++));
 392       }
 393       break;
 394     case T_FLOAT:
 395       // C2 utilizes S14/S15 for mem-mem moves
 396       if ((freg &lt; 16 COMPILER2_PRESENT(-2)) || (single_fpr &amp; 1)) {
 397         if ((single_fpr &amp; 1) == 0) {
 398           single_fpr = freg;
 399           freg += 2;
 400         }
 401         FloatRegister r = as_FloatRegister(single_fpr++);
 402         regs[i].set1(r-&gt;as_VMReg());
 403       } else {
 404         regs[i].set1(VMRegImpl::stack2reg(slot++));
 405       }
 406       break;
 407     case T_DOUBLE:
 408       // C2 utilizes S14/S15 for mem-mem moves
 409       if (freg &lt;= 14 COMPILER2_PRESENT(-2)) {
 410         FloatRegister r1 = as_FloatRegister(freg);
 411         FloatRegister r2 = as_FloatRegister(freg + 1);
 412         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 413         freg += 2;
 414       } else {
 415         // Keep internally the aligned calling convention,
 416         // ignoring ALIGN_WIDE_ARGUMENTS
 417         if (slot &amp; 1) slot++;
 418         regs[i].set_pair(VMRegImpl::stack2reg(slot + 1), VMRegImpl::stack2reg(slot));
 419         slot += 2;
 420         single_fpr = 16;
 421       }
 422       break;
 423     case T_LONG:
 424       // Keep internally the aligned calling convention,
 425       // ignoring ALIGN_WIDE_ARGUMENTS
 426       if (ireg &lt;= 2) {
 427         if (ireg &amp; 1) ireg++;
 428         Register r1 = as_Register(ireg);
 429         Register r2 = as_Register(ireg + 1);
 430         regs[i].set_pair(r2-&gt;as_VMReg(), r1-&gt;as_VMReg());
 431         ireg += 2;
 432       } else {
 433         if (slot &amp; 1) slot++;
 434         regs[i].set_pair(VMRegImpl::stack2reg(slot + 1), VMRegImpl::stack2reg(slot));
 435         slot += 2;
 436         ireg = 4;
 437       }
 438       break;
 439     case T_VOID:
 440       regs[i].set_bad();
 441       break;
 442     default:
 443       ShouldNotReachHere();
 444     }
 445   }
 446 
 447   if (slot &amp; 1) slot++;
 448   return slot;
 449 }
 450 
 451 static void patch_callers_callsite(MacroAssembler *masm) {
 452   Label skip;
 453 
 454   __ ldr(Rtemp, Address(Rmethod, Method::code_offset()));
 455   __ cbz(Rtemp, skip);
 456 
 457   // Pushing an even number of registers for stack alignment.
 458   // Selecting R9, which had to be saved anyway for some platforms.
 459   __ push(RegisterSet(R0, R3) | R9 | LR);
 460   __ fpush_hardfp(FloatRegisterSet(D0, 8));
 461 
 462   __ mov(R0, Rmethod);
 463   __ mov(R1, LR);
 464   __ call(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite));
 465 
 466   __ fpop_hardfp(FloatRegisterSet(D0, 8));
 467   __ pop(RegisterSet(R0, R3) | R9 | LR);
 468 
 469   __ bind(skip);
 470 }
 471 
 472 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm,
 473                                     int total_args_passed, int comp_args_on_stack,
 474                                     const BasicType *sig_bt, const VMRegPair *regs) {
 475   // TODO: ARM - May be can use ldm to load arguments
 476   const Register tmp = Rtemp; // avoid erasing R5_mh
 477 
 478   // Next assert may not be needed but safer. Extra analysis required
 479   // if this there is not enough free registers and we need to use R5 here.
 480   assert_different_registers(tmp, R5_mh);
 481 
 482   // 6243940 We might end up in handle_wrong_method if
 483   // the callee is deoptimized as we race thru here. If that
 484   // happens we don&#39;t want to take a safepoint because the
 485   // caller frame will look interpreted and arguments are now
 486   // &quot;compiled&quot; so it is much better to make this transition
 487   // invisible to the stack walking code. Unfortunately if
 488   // we try and find the callee by normal means a safepoint
 489   // is possible. So we stash the desired callee in the thread
 490   // and the vm will find there should this case occur.
 491   Address callee_target_addr(Rthread, JavaThread::callee_target_offset());
 492   __ str(Rmethod, callee_target_addr);
 493 
 494 
 495   assert_different_registers(tmp, R0, R1, R2, R3, Rsender_sp, Rmethod);
 496 
 497   const Register initial_sp = Rmethod; // temporarily scratched
 498 
 499   // Old code was modifying R4 but this looks unsafe (particularly with JSR292)
 500   assert_different_registers(tmp, R0, R1, R2, R3, Rsender_sp, initial_sp);
 501 
 502   __ mov(initial_sp, SP);
 503 
 504   if (comp_args_on_stack) {
 505     __ sub_slow(SP, SP, comp_args_on_stack * VMRegImpl::stack_slot_size);
 506   }
 507   __ bic(SP, SP, StackAlignmentInBytes - 1);
 508 
 509   for (int i = 0; i &lt; total_args_passed; i++) {
 510     if (sig_bt[i] == T_VOID) {
 511       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 512       continue;
 513     }
 514     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;must be ordered&quot;);
 515     int arg_offset = Interpreter::expr_offset_in_bytes(total_args_passed - 1 - i);
 516 
 517     VMReg r_1 = regs[i].first();
 518     VMReg r_2 = regs[i].second();
 519     if (r_1-&gt;is_stack()) {
 520       int stack_offset = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size;
 521       if (!r_2-&gt;is_valid()) {
 522         __ ldr(tmp, Address(initial_sp, arg_offset));
 523         __ str(tmp, Address(SP, stack_offset));
 524       } else {
 525         __ ldr(tmp, Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 526         __ str(tmp, Address(SP, stack_offset));
 527         __ ldr(tmp, Address(initial_sp, arg_offset));
 528         __ str(tmp, Address(SP, stack_offset + wordSize));
 529       }
 530     } else if (r_1-&gt;is_Register()) {
 531       if (!r_2-&gt;is_valid()) {
 532         __ ldr(r_1-&gt;as_Register(), Address(initial_sp, arg_offset));
 533       } else {
 534         __ ldr(r_1-&gt;as_Register(), Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 535         __ ldr(r_2-&gt;as_Register(), Address(initial_sp, arg_offset));
 536       }
 537     } else if (r_1-&gt;is_FloatRegister()) {
 538 #ifdef __SOFTFP__
 539       ShouldNotReachHere();
 540 #endif // __SOFTFP__
 541       if (!r_2-&gt;is_valid()) {
 542         __ flds(r_1-&gt;as_FloatRegister(), Address(initial_sp, arg_offset));
 543       } else {
 544         __ fldd(r_1-&gt;as_FloatRegister(), Address(initial_sp, arg_offset - Interpreter::stackElementSize));
 545       }
 546     } else {
 547       assert(!r_1-&gt;is_valid() &amp;&amp; !r_2-&gt;is_valid(), &quot;must be&quot;);
 548     }
 549   }
 550 
 551   // restore Rmethod (scratched for initial_sp)
 552   __ ldr(Rmethod, callee_target_addr);
 553   __ ldr(PC, Address(Rmethod, Method::from_compiled_offset()));
 554 
 555 }
 556 
 557 static void gen_c2i_adapter(MacroAssembler *masm,
 558                             int total_args_passed,  int comp_args_on_stack,
 559                             const BasicType *sig_bt, const VMRegPair *regs,
 560                             Label&amp; skip_fixup) {
 561   // TODO: ARM - May be can use stm to deoptimize arguments
 562   const Register tmp = Rtemp;
 563 
 564   patch_callers_callsite(masm);
 565   __ bind(skip_fixup);
 566 
 567   __ mov(Rsender_sp, SP); // not yet saved
 568 
 569 
 570   int extraspace = total_args_passed * Interpreter::stackElementSize;
 571   if (extraspace) {
 572     __ sub_slow(SP, SP, extraspace);
 573   }
 574 
 575   for (int i = 0; i &lt; total_args_passed; i++) {
 576     if (sig_bt[i] == T_VOID) {
 577       assert(i &gt; 0 &amp;&amp; (sig_bt[i-1] == T_LONG || sig_bt[i-1] == T_DOUBLE), &quot;missing half&quot;);
 578       continue;
 579     }
 580     int stack_offset = (total_args_passed - 1 - i) * Interpreter::stackElementSize;
 581 
 582     VMReg r_1 = regs[i].first();
 583     VMReg r_2 = regs[i].second();
 584     if (r_1-&gt;is_stack()) {
 585       int arg_offset = r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace;
 586       if (!r_2-&gt;is_valid()) {
 587         __ ldr(tmp, Address(SP, arg_offset));
 588         __ str(tmp, Address(SP, stack_offset));
 589       } else {
 590         __ ldr(tmp, Address(SP, arg_offset));
 591         __ str(tmp, Address(SP, stack_offset - Interpreter::stackElementSize));
 592         __ ldr(tmp, Address(SP, arg_offset + wordSize));
 593         __ str(tmp, Address(SP, stack_offset));
 594       }
 595     } else if (r_1-&gt;is_Register()) {
 596       if (!r_2-&gt;is_valid()) {
 597         __ str(r_1-&gt;as_Register(), Address(SP, stack_offset));
 598       } else {
 599         __ str(r_1-&gt;as_Register(), Address(SP, stack_offset - Interpreter::stackElementSize));
 600         __ str(r_2-&gt;as_Register(), Address(SP, stack_offset));
 601       }
 602     } else if (r_1-&gt;is_FloatRegister()) {
 603 #ifdef __SOFTFP__
 604       ShouldNotReachHere();
 605 #endif // __SOFTFP__
 606       if (!r_2-&gt;is_valid()) {
 607         __ fsts(r_1-&gt;as_FloatRegister(), Address(SP, stack_offset));
 608       } else {
 609         __ fstd(r_1-&gt;as_FloatRegister(), Address(SP, stack_offset - Interpreter::stackElementSize));
 610       }
 611     } else {
 612       assert(!r_1-&gt;is_valid() &amp;&amp; !r_2-&gt;is_valid(), &quot;must be&quot;);
 613     }
 614   }
 615 
 616   __ ldr(PC, Address(Rmethod, Method::interpreter_entry_offset()));
 617 
 618 }
 619 
 620 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 621                                                             int total_args_passed,
 622                                                             int comp_args_on_stack,
 623                                                             const BasicType *sig_bt,
 624                                                             const VMRegPair *regs,
 625                                                             AdapterFingerPrint* fingerprint) {
 626   address i2c_entry = __ pc();
 627   gen_i2c_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs);
 628 
 629   address c2i_unverified_entry = __ pc();
 630   Label skip_fixup;
 631   const Register receiver       = R0;
 632   const Register holder_klass   = Rtemp; // XXX should be OK for C2 but not 100% sure
 633   const Register receiver_klass = R4;
 634 
 635   __ load_klass(receiver_klass, receiver);
 636   __ ldr(holder_klass, Address(Ricklass, CompiledICHolder::holder_klass_offset()));
 637   __ ldr(Rmethod, Address(Ricklass, CompiledICHolder::holder_metadata_offset()));
 638   __ cmp(receiver_klass, holder_klass);
 639 
 640   __ ldr(Rtemp, Address(Rmethod, Method::code_offset()), eq);
 641   __ cmp(Rtemp, 0, eq);
 642   __ b(skip_fixup, eq);
 643   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
 644 
 645   address c2i_entry = __ pc();
 646   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 647 
 648   __ flush();
 649   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);
 650 }
 651 
 652 
 653 static int reg2offset_in(VMReg r) {
 654   // Account for saved FP and LR
 655   return r-&gt;reg2stack() * VMRegImpl::stack_slot_size + 2*wordSize;
 656 }
 657 
 658 static int reg2offset_out(VMReg r) {
 659   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 660 }
 661 
 662 
 663 static void verify_oop_args(MacroAssembler* masm,
 664                             const methodHandle&amp; method,
 665                             const BasicType* sig_bt,
 666                             const VMRegPair* regs) {
 667   Register temp_reg = Rmethod;  // not part of any compiled calling seq
 668   if (VerifyOops) {
 669     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
 670       if (sig_bt[i] == T_OBJECT || sig_bt[i] == T_ARRAY) {
 671         VMReg r = regs[i].first();
 672         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
 673         if (r-&gt;is_stack()) {
 674           __ ldr(temp_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 675           __ verify_oop(temp_reg);
 676         } else {
 677           __ verify_oop(r-&gt;as_Register());
 678         }
 679       }
 680     }
 681   }
 682 }
 683 
 684 static void gen_special_dispatch(MacroAssembler* masm,
 685                                  const methodHandle&amp; method,
 686                                  const BasicType* sig_bt,
 687                                  const VMRegPair* regs) {
 688   verify_oop_args(masm, method, sig_bt, regs);
 689   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
 690 
 691   // Now write the args into the outgoing interpreter space
 692   bool     has_receiver   = false;
 693   Register receiver_reg   = noreg;
 694   int      member_arg_pos = -1;
 695   Register member_reg     = noreg;
 696   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
 697   if (ref_kind != 0) {
 698     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
 699     member_reg = Rmethod;  // known to be free at this point
 700     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
 701   } else if (iid == vmIntrinsics::_invokeBasic) {
 702     has_receiver = true;
 703   } else {
 704     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
 705   }
 706 
 707   if (member_reg != noreg) {
 708     // Load the member_arg into register, if necessary.
 709     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
 710     VMReg r = regs[member_arg_pos].first();
 711     if (r-&gt;is_stack()) {
 712       __ ldr(member_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 713     } else {
 714       // no data motion is needed
 715       member_reg = r-&gt;as_Register();
 716     }
 717   }
 718 
 719   if (has_receiver) {
 720     // Make sure the receiver is loaded into a register.
 721     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
 722     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
 723     VMReg r = regs[0].first();
 724     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
 725     if (r-&gt;is_stack()) {
 726       // Porting note:  This assumes that compiled calling conventions always
 727       // pass the receiver oop in a register.  If this is not true on some
 728       // platform, pick a temp and load the receiver from stack.
 729       assert(false, &quot;receiver always in a register&quot;);
 730       receiver_reg = j_rarg0;  // known to be free at this point
 731       __ ldr(receiver_reg, Address(SP, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
 732     } else {
 733       // no data motion is needed
 734       receiver_reg = r-&gt;as_Register();
 735     }
 736   }
 737 
 738   // Figure out which address we are really jumping to:
 739   MethodHandles::generate_method_handle_dispatch(masm, iid,
 740                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
 741 }
 742 
 743 // ---------------------------------------------------------------------------
 744 // Generate a native wrapper for a given method.  The method takes arguments
 745 // in the Java compiled code convention, marshals them to the native
 746 // convention (handlizes oops, etc), transitions to native, makes the call,
 747 // returns to java state (possibly blocking), unhandlizes any result and
 748 // returns.
 749 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
 750                                                 const methodHandle&amp; method,
 751                                                 int compile_id,
 752                                                 BasicType* in_sig_bt,
 753                                                 VMRegPair* in_regs,
 754                                                 BasicType ret_type,
 755                                                 address critical_entry) {
 756   if (method-&gt;is_method_handle_intrinsic()) {
 757     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
 758     intptr_t start = (intptr_t)__ pc();
 759     int vep_offset = ((intptr_t)__ pc()) - start;
 760     gen_special_dispatch(masm,
 761                          method,
 762                          in_sig_bt,
 763                          in_regs);
 764     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
 765     __ flush();
 766     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
 767     return nmethod::new_native_nmethod(method,
 768                                        compile_id,
 769                                        masm-&gt;code(),
 770                                        vep_offset,
 771                                        frame_complete,
 772                                        stack_slots / VMRegImpl::slots_per_word,
 773                                        in_ByteSize(-1),
 774                                        in_ByteSize(-1),
 775                                        (OopMapSet*)NULL);
 776   }
 777   // Arguments for JNI method include JNIEnv and Class if static
 778 
 779   // Usage of Rtemp should be OK since scratched by native call
 780 
 781   bool is_static = method-&gt;is_static();
 782 
 783   const int total_in_args = method-&gt;size_of_parameters();
 784   int total_c_args = total_in_args + 1;
 785   if (is_static) {
 786     total_c_args++;
 787   }
 788 
 789   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
 790   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
 791 
 792   int argc = 0;
 793   out_sig_bt[argc++] = T_ADDRESS;
 794   if (is_static) {
 795     out_sig_bt[argc++] = T_OBJECT;
 796   }
 797 
 798   int i;
 799   for (i = 0; i &lt; total_in_args; i++) {
 800     out_sig_bt[argc++] = in_sig_bt[i];
 801   }
 802 
 803   int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
 804   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
 805   // Since object arguments need to be wrapped, we must preserve space
 806   // for those object arguments which come in registers (GPR_PARAMS maximum)
 807   // plus one more slot for Klass handle (for static methods)
 808   int oop_handle_offset = stack_slots;
 809   stack_slots += (GPR_PARAMS + 1) * VMRegImpl::slots_per_word;
 810 
 811   // Plus a lock if needed
 812   int lock_slot_offset = 0;
 813   if (method-&gt;is_synchronized()) {
 814     lock_slot_offset = stack_slots;
 815     assert(sizeof(BasicLock) == wordSize, &quot;adjust this code&quot;);
 816     stack_slots += VMRegImpl::slots_per_word;
 817   }
 818 
 819   // Space to save return address and FP
 820   stack_slots += 2 * VMRegImpl::slots_per_word;
 821 
 822   // Calculate the final stack size taking account of alignment
 823   stack_slots = align_up(stack_slots, StackAlignmentInBytes / VMRegImpl::stack_slot_size);
 824   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
 825   int lock_slot_fp_offset = stack_size - 2 * wordSize -
 826     lock_slot_offset * VMRegImpl::stack_slot_size;
 827 
 828   // Unverified entry point
 829   address start = __ pc();
 830 
 831   // Inline cache check, same as in C1_MacroAssembler::inline_cache_check()
 832   const Register receiver = R0; // see receiverOpr()
 833   __ load_klass(Rtemp, receiver);
 834   __ cmp(Rtemp, Ricklass);
 835   Label verified;
 836 
 837   __ b(verified, eq); // jump over alignment no-ops too
 838   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, Rtemp);
 839   __ align(CodeEntryAlignment);
 840 
 841   // Verified entry point
 842   __ bind(verified);
 843   int vep_offset = __ pc() - start;
 844 
 845 
 846   if ((InlineObjectHash &amp;&amp; method-&gt;intrinsic_id() == vmIntrinsics::_hashCode) || (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode)) {
 847     // Object.hashCode, System.identityHashCode can pull the hashCode from the header word
 848     // instead of doing a full VM transition once it&#39;s been computed.
 849     Label slow_case;
 850     const Register obj_reg = R0;
 851 
 852     // Unlike for Object.hashCode, System.identityHashCode is static method and
 853     // gets object as argument instead of the receiver.
 854     if (method-&gt;intrinsic_id() == vmIntrinsics::_identityHashCode) {
 855       assert(method-&gt;is_static(), &quot;method should be static&quot;);
 856       // return 0 for null reference input, return val = R0 = obj_reg = 0
 857       __ cmp(obj_reg, 0);
 858       __ bx(LR, eq);
 859     }
 860 
 861     __ ldr(Rtemp, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 862 
 863     assert(markWord::unlocked_value == 1, &quot;adjust this code&quot;);
 864     __ tbz(Rtemp, exact_log2(markWord::unlocked_value), slow_case);
 865 
 866     if (UseBiasedLocking) {
 867       assert(is_power_of_2(markWord::biased_lock_bit_in_place), &quot;adjust this code&quot;);
 868       __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);
 869     }
 870 
 871     __ bics(Rtemp, Rtemp, ~markWord::hash_mask_in_place);
 872     __ mov(R0, AsmOperand(Rtemp, lsr, markWord::hash_shift), ne);
 873     __ bx(LR, ne);
 874 
 875     __ bind(slow_case);
 876   }
 877 
 878   // Bang stack pages
 879   __ arm_stack_overflow_check(stack_size, Rtemp);
 880 
 881   // Setup frame linkage
 882   __ raw_push(FP, LR);
 883   __ mov(FP, SP);
 884   __ sub_slow(SP, SP, stack_size - 2*wordSize);
 885 
 886   int frame_complete = __ pc() - start;
 887 
 888   OopMapSet* oop_maps = new OopMapSet();
 889   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
 890   const int extra_args = is_static ? 2 : 1;
 891   int receiver_offset = -1;
 892   int fp_regs_in_arguments = 0;
 893 
 894   for (i = total_in_args; --i &gt;= 0; ) {
 895     switch (in_sig_bt[i]) {
 896     case T_ARRAY:
 897     case T_OBJECT: {
 898       VMReg src = in_regs[i].first();
 899       VMReg dst = out_regs[i + extra_args].first();
 900       if (src-&gt;is_stack()) {
 901         assert(dst-&gt;is_stack(), &quot;must be&quot;);
 902         assert(i != 0, &quot;Incoming receiver is always in a register&quot;);
 903         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
 904         __ cmp(Rtemp, 0);
 905         __ add(Rtemp, FP, reg2offset_in(src), ne);
 906         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
 907         int offset_in_older_frame = src-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
 908         map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + stack_slots));
 909       } else {
 910         int offset = oop_handle_offset * VMRegImpl::stack_slot_size;
 911         __ str(src-&gt;as_Register(), Address(SP, offset));
 912         map-&gt;set_oop(VMRegImpl::stack2reg(oop_handle_offset));
 913         if ((i == 0) &amp;&amp; (!is_static)) {
 914           receiver_offset = offset;
 915         }
 916         oop_handle_offset += VMRegImpl::slots_per_word;
 917 
 918         if (dst-&gt;is_stack()) {
 919           __ movs(Rtemp, src-&gt;as_Register());
 920           __ add(Rtemp, SP, offset, ne);
 921           __ str(Rtemp, Address(SP, reg2offset_out(dst)));
 922         } else {
 923           __ movs(dst-&gt;as_Register(), src-&gt;as_Register());
 924           __ add(dst-&gt;as_Register(), SP, offset, ne);
 925         }
 926       }
 927     }
 928 
 929     case T_VOID:
 930       break;
 931 
 932 
 933 #ifdef __SOFTFP__
 934     case T_DOUBLE:
 935 #endif
 936     case T_LONG: {
 937       VMReg src_1 = in_regs[i].first();
 938       VMReg src_2 = in_regs[i].second();
 939       VMReg dst_1 = out_regs[i + extra_args].first();
 940       VMReg dst_2 = out_regs[i + extra_args].second();
 941 #if (ALIGN_WIDE_ARGUMENTS == 0)
 942       // C convention can mix a register and a stack slot for a
 943       // 64-bits native argument.
 944 
 945       // Note: following code should work independently of whether
 946       // the Java calling convention follows C convention or whether
 947       // it aligns 64-bit values.
 948       if (dst_2-&gt;is_Register()) {
 949         if (src_1-&gt;as_Register() != dst_1-&gt;as_Register()) {
 950           assert(src_1-&gt;as_Register() != dst_2-&gt;as_Register() &amp;&amp;
 951                  src_2-&gt;as_Register() != dst_2-&gt;as_Register(), &quot;must be&quot;);
 952           __ mov(dst_2-&gt;as_Register(), src_2-&gt;as_Register());
 953           __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
 954         } else {
 955           assert(src_2-&gt;as_Register() == dst_2-&gt;as_Register(), &quot;must be&quot;);
 956         }
 957       } else if (src_2-&gt;is_Register()) {
 958         if (dst_1-&gt;is_Register()) {
 959           // dst mixes a register and a stack slot
 960           assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 961           assert(src_1-&gt;as_Register() != dst_1-&gt;as_Register(), &quot;must be&quot;);
 962           __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
 963           __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
 964         } else {
 965           // registers to stack slots
 966           assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 967           __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
 968           __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
 969         }
 970       } else if (src_1-&gt;is_Register()) {
 971         if (dst_1-&gt;is_Register()) {
 972           // src and dst must be R3 + stack slot
 973           assert(dst_1-&gt;as_Register() == src_1-&gt;as_Register(), &quot;must be&quot;);
 974           __ ldr(Rtemp,    Address(FP, reg2offset_in(src_2)));
 975           __ str(Rtemp,    Address(SP, reg2offset_out(dst_2)));
 976         } else {
 977           // &lt;R3,stack&gt; -&gt; &lt;stack,stack&gt;
 978           assert(dst_2-&gt;is_stack() &amp;&amp; src_2-&gt;is_stack(), &quot;must be&quot;);
 979           __ ldr(LR, Address(FP, reg2offset_in(src_2)));
 980           __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
 981           __ str(LR, Address(SP, reg2offset_out(dst_2)));
 982         }
 983       } else {
 984         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
 985         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
 986         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
 987         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
 988         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
 989       }
 990 #else // ALIGN_WIDE_ARGUMENTS
 991       if (src_1-&gt;is_stack()) {
 992         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
 993         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
 994         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
 995         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
 996         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
 997       } else if (dst_1-&gt;is_stack()) {
 998         assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_Register() &amp;&amp; src_2-&gt;is_Register(), &quot;must be&quot;);
 999         __ str(src_1-&gt;as_Register(), Address(SP, reg2offset_out(dst_1)));
1000         __ str(src_2-&gt;as_Register(), Address(SP, reg2offset_out(dst_2)));
1001       } else if (src_1-&gt;as_Register() == dst_1-&gt;as_Register()) {
1002         assert(src_2-&gt;as_Register() == dst_2-&gt;as_Register(), &quot;must be&quot;);
1003       } else {
1004         assert(src_1-&gt;as_Register() != dst_2-&gt;as_Register() &amp;&amp;
1005                src_2-&gt;as_Register() != dst_2-&gt;as_Register(), &quot;must be&quot;);
1006         __ mov(dst_2-&gt;as_Register(), src_2-&gt;as_Register());
1007         __ mov(dst_1-&gt;as_Register(), src_1-&gt;as_Register());
1008       }
1009 #endif // ALIGN_WIDE_ARGUMENTS
1010       break;
1011     }
1012 
1013 #if (!defined __SOFTFP__ &amp;&amp; !defined __ABI_HARD__)
1014     case T_FLOAT: {
1015       VMReg src = in_regs[i].first();
1016       VMReg dst = out_regs[i + extra_args].first();
1017       if (src-&gt;is_stack()) {
1018         assert(dst-&gt;is_stack(), &quot;must be&quot;);
1019         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1020         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1021       } else if (dst-&gt;is_stack()) {
1022         __ fsts(src-&gt;as_FloatRegister(), Address(SP, reg2offset_out(dst)));
1023       } else {
1024         assert(src-&gt;is_FloatRegister() &amp;&amp; dst-&gt;is_Register(), &quot;must be&quot;);
1025         __ fmrs(dst-&gt;as_Register(), src-&gt;as_FloatRegister());
1026       }
1027       break;
1028     }
1029 
1030     case T_DOUBLE: {
1031       VMReg src_1 = in_regs[i].first();
1032       VMReg src_2 = in_regs[i].second();
1033       VMReg dst_1 = out_regs[i + extra_args].first();
1034       VMReg dst_2 = out_regs[i + extra_args].second();
1035       if (src_1-&gt;is_stack()) {
1036         assert(src_2-&gt;is_stack() &amp;&amp; dst_1-&gt;is_stack() &amp;&amp; dst_2-&gt;is_stack(), &quot;must be&quot;);
1037         __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
1038         __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
1039         __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
1040         __ str(LR,    Address(SP, reg2offset_out(dst_2)));
1041       } else if (dst_1-&gt;is_stack()) {
1042         assert(dst_2-&gt;is_stack() &amp;&amp; src_1-&gt;is_FloatRegister(), &quot;must be&quot;);
1043         __ fstd(src_1-&gt;as_FloatRegister(), Address(SP, reg2offset_out(dst_1)));
1044 #if (ALIGN_WIDE_ARGUMENTS == 0)
1045       } else if (dst_2-&gt;is_stack()) {
1046         assert(! src_2-&gt;is_stack(), &quot;must be&quot;); // assuming internal java convention is aligned
1047         // double register must go into R3 + one stack slot
1048         __ fmrrd(dst_1-&gt;as_Register(), Rtemp, src_1-&gt;as_FloatRegister());
1049         __ str(Rtemp, Address(SP, reg2offset_out(dst_2)));
1050 #endif
1051       } else {
1052         assert(src_1-&gt;is_FloatRegister() &amp;&amp; dst_1-&gt;is_Register() &amp;&amp; dst_2-&gt;is_Register(), &quot;must be&quot;);
1053         __ fmrrd(dst_1-&gt;as_Register(), dst_2-&gt;as_Register(), src_1-&gt;as_FloatRegister());
1054       }
1055       break;
1056     }
1057 #endif // __SOFTFP__
1058 
1059 #ifdef __ABI_HARD__
1060     case T_FLOAT: {
1061       VMReg src = in_regs[i].first();
1062       VMReg dst = out_regs[i + extra_args].first();
1063       if (src-&gt;is_stack()) {
1064         if (dst-&gt;is_stack()) {
1065           __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1066           __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1067         } else {
1068           // C2 Java calling convention does not populate S14 and S15, therefore
1069           // those need to be loaded from stack here
1070           __ flds(dst-&gt;as_FloatRegister(), Address(FP, reg2offset_in(src)));
1071           fp_regs_in_arguments++;
1072         }
1073       } else {
1074         assert(src-&gt;is_FloatRegister(), &quot;must be&quot;);
1075         fp_regs_in_arguments++;
1076       }
1077       break;
1078     }
1079     case T_DOUBLE: {
1080       VMReg src_1 = in_regs[i].first();
1081       VMReg src_2 = in_regs[i].second();
1082       VMReg dst_1 = out_regs[i + extra_args].first();
1083       VMReg dst_2 = out_regs[i + extra_args].second();
1084       if (src_1-&gt;is_stack()) {
1085         if (dst_1-&gt;is_stack()) {
1086           assert(dst_2-&gt;is_stack(), &quot;must be&quot;);
1087           __ ldr(Rtemp, Address(FP, reg2offset_in(src_1)));
1088           __ ldr(LR,    Address(FP, reg2offset_in(src_2)));
1089           __ str(Rtemp, Address(SP, reg2offset_out(dst_1)));
1090           __ str(LR,    Address(SP, reg2offset_out(dst_2)));
1091         } else {
1092           // C2 Java calling convention does not populate S14 and S15, therefore
1093           // those need to be loaded from stack here
1094           __ fldd(dst_1-&gt;as_FloatRegister(), Address(FP, reg2offset_in(src_1)));
1095           fp_regs_in_arguments += 2;
1096         }
1097       } else {
1098         assert(src_1-&gt;is_FloatRegister() &amp;&amp; src_2-&gt;is_FloatRegister(), &quot;must be&quot;);
1099         fp_regs_in_arguments += 2;
1100       }
1101       break;
1102     }
1103 #endif // __ABI_HARD__
1104 
1105     default: {
1106       assert(in_sig_bt[i] != T_ADDRESS, &quot;found T_ADDRESS in java args&quot;);
1107       VMReg src = in_regs[i].first();
1108       VMReg dst = out_regs[i + extra_args].first();
1109       if (src-&gt;is_stack()) {
1110         assert(dst-&gt;is_stack(), &quot;must be&quot;);
1111         __ ldr(Rtemp, Address(FP, reg2offset_in(src)));
1112         __ str(Rtemp, Address(SP, reg2offset_out(dst)));
1113       } else if (dst-&gt;is_stack()) {
1114         __ str(src-&gt;as_Register(), Address(SP, reg2offset_out(dst)));
1115       } else {
1116         assert(src-&gt;is_Register() &amp;&amp; dst-&gt;is_Register(), &quot;must be&quot;);
1117         __ mov(dst-&gt;as_Register(), src-&gt;as_Register());
1118       }
1119     }
1120     }
1121   }
1122 
1123   // Get Klass mirror
1124   int klass_offset = -1;
1125   if (is_static) {
1126     klass_offset = oop_handle_offset * VMRegImpl::stack_slot_size;
1127     __ mov_oop(Rtemp, JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()));
1128     __ add(c_rarg1, SP, klass_offset);
1129     __ str(Rtemp, Address(SP, klass_offset));
1130     map-&gt;set_oop(VMRegImpl::stack2reg(oop_handle_offset));
1131   }
1132 
1133   // the PC offset given to add_gc_map must match the PC saved in set_last_Java_frame
1134   int pc_offset = __ set_last_Java_frame(SP, FP, true, Rtemp);
1135   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1136   oop_maps-&gt;add_gc_map(pc_offset, map);
1137 
1138   // Order last_Java_pc store with the thread state transition (to _thread_in_native)
1139   __ membar(MacroAssembler::StoreStore, Rtemp);
1140 
1141   // RedefineClasses() tracing support for obsolete method entry
1142   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1143     __ save_caller_save_registers();
1144     __ mov(R0, Rthread);
1145     __ mov_metadata(R1, method());
1146     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry), R0, R1);
1147     __ restore_caller_save_registers();
1148   }
1149 
1150   const Register sync_handle = R5;
1151   const Register sync_obj    = R6;
1152   const Register disp_hdr    = altFP_7_11;
1153   const Register tmp         = R8;
1154 
1155   Label slow_lock, slow_lock_biased, lock_done, fast_lock;
1156   if (method-&gt;is_synchronized()) {
1157     // The first argument is a handle to sync object (a class or an instance)
1158     __ ldr(sync_obj, Address(R1));
1159     // Remember the handle for the unlocking code
1160     __ mov(sync_handle, R1);
1161 
1162     __ resolve(IS_NOT_NULL, sync_obj);
1163 
1164     if(UseBiasedLocking) {
1165       __ biased_locking_enter(sync_obj, tmp, disp_hdr/*scratched*/, false, Rtemp, lock_done, slow_lock_biased);
1166     }
1167 
1168     const Register mark = tmp;
1169     // On MP platforms the next load could return a &#39;stale&#39; value if the memory location has been modified by another thread.
1170     // That would be acceptable as either CAS or slow case path is taken in that case
1171 
1172     __ ldr(mark, Address(sync_obj, oopDesc::mark_offset_in_bytes()));
1173     __ sub(disp_hdr, FP, lock_slot_fp_offset);
1174     __ tst(mark, markWord::unlocked_value);
1175     __ b(fast_lock, ne);
1176 
1177     // Check for recursive lock
1178     // See comments in InterpreterMacroAssembler::lock_object for
1179     // explanations on the fast recursive locking check.
1180     // Check independently the low bits and the distance to SP
1181     // -1- test low 2 bits
1182     __ movs(Rtemp, AsmOperand(mark, lsl, 30));
1183     // -2- test (hdr - SP) if the low two bits are 0
1184     __ sub(Rtemp, mark, SP, eq);
1185     __ movs(Rtemp, AsmOperand(Rtemp, lsr, exact_log2(os::vm_page_size())), eq);
1186     // If still &#39;eq&#39; then recursive locking OK: set displaced header to 0
1187     __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()), eq);
1188     __ b(lock_done, eq);
1189     __ b(slow_lock);
1190 
1191     __ bind(fast_lock);
1192     __ str(mark, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));
1193 
1194     __ cas_for_lock_acquire(mark, disp_hdr, sync_obj, Rtemp, slow_lock);
1195 
1196     __ bind(lock_done);
1197   }
1198 
1199   // Get JNIEnv*
1200   __ add(c_rarg0, Rthread, in_bytes(JavaThread::jni_environment_offset()));
1201 
1202   // Perform thread state transition
1203   __ mov(Rtemp, _thread_in_native);
1204   __ str(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1205 
1206   // Finally, call the native method
1207   __ call(method-&gt;native_function());
1208 
1209   // Set FPSCR/FPCR to a known state
1210   if (AlwaysRestoreFPU) {
1211     __ restore_default_fp_mode();
1212   }
1213 
1214   // Ensure a Boolean result is mapped to 0..1
1215   if (ret_type == T_BOOLEAN) {
1216     __ c2bool(R0);
1217   }
1218 
1219   // Do a safepoint check while thread is in transition state
1220   Label call_safepoint_runtime, return_to_java;
1221   __ mov(Rtemp, _thread_in_native_trans);
1222   __ str_32(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1223 
1224   // make sure the store is observed before reading the SafepointSynchronize state and further mem refs
1225   __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreLoad | MacroAssembler::StoreStore), Rtemp);
1226 
1227   __ safepoint_poll(R2, call_safepoint_runtime);
1228   __ ldr_u32(R3, Address(Rthread, JavaThread::suspend_flags_offset()));
1229   __ cmp(R3, 0);
1230   __ b(call_safepoint_runtime, ne);
1231 
1232   __ bind(return_to_java);
1233 
1234   // Perform thread state transition and reguard stack yellow pages if needed
1235   Label reguard, reguard_done;
1236   __ mov(Rtemp, _thread_in_Java);
1237   __ ldr_s32(R2, Address(Rthread, JavaThread::stack_guard_state_offset()));
1238   __ str_32(Rtemp, Address(Rthread, JavaThread::thread_state_offset()));
1239 
1240   __ cmp(R2, JavaThread::stack_guard_yellow_reserved_disabled);
1241   __ b(reguard, eq);
1242   __ bind(reguard_done);
1243 
1244   Label slow_unlock, unlock_done;
1245   if (method-&gt;is_synchronized()) {
1246     __ ldr(sync_obj, Address(sync_handle));
1247 
1248     __ resolve(IS_NOT_NULL, sync_obj);
1249 
1250     if(UseBiasedLocking) {
1251       __ biased_locking_exit(sync_obj, Rtemp, unlock_done);
1252       // disp_hdr may not have been saved on entry with biased locking
1253       __ sub(disp_hdr, FP, lock_slot_fp_offset);
1254     }
1255 
1256     // See C1_MacroAssembler::unlock_object() for more comments
1257     __ ldr(R2, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));
1258     __ cbz(R2, unlock_done);
1259 
1260     __ cas_for_lock_release(disp_hdr, R2, sync_obj, Rtemp, slow_unlock);
1261 
1262     __ bind(unlock_done);
1263   }
1264 
1265   // Set last java frame and handle block to zero
1266   __ ldr(LR, Address(Rthread, JavaThread::active_handles_offset()));
1267   __ reset_last_Java_frame(Rtemp); // sets Rtemp to 0 on 32-bit ARM
1268 
1269   __ str_32(Rtemp, Address(LR, JNIHandleBlock::top_offset_in_bytes()));
1270   if (CheckJNICalls) {
1271     __ str(__ zero_register(Rtemp), Address(Rthread, JavaThread::pending_jni_exception_check_fn_offset()));
1272   }
1273 
1274   // Unbox oop result, e.g. JNIHandles::resolve value in R0.
1275   if (ret_type == T_OBJECT || ret_type == T_ARRAY) {
1276     __ resolve_jobject(R0,      // value
1277                        Rtemp,   // tmp1
1278                        R1_tmp); // tmp2
1279   }
1280 
1281   // Any exception pending?
1282   __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1283   __ mov(SP, FP);
1284 
1285   __ cmp(Rtemp, 0);
1286   // Pop the frame and return if no exception pending
1287   __ pop(RegisterSet(FP) | RegisterSet(PC), eq);
1288   // Pop the frame and forward the exception. Rexception_pc contains return address.
1289   __ ldr(FP, Address(SP, wordSize, post_indexed), ne);
1290   __ ldr(Rexception_pc, Address(SP, wordSize, post_indexed), ne);
1291   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1292 
1293   // Safepoint operation and/or pending suspend request is in progress.
1294   // Save the return values and call the runtime function by hand.
1295   __ bind(call_safepoint_runtime);
1296   push_result_registers(masm, ret_type);
1297   __ mov(R0, Rthread);
1298   __ call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));
1299   pop_result_registers(masm, ret_type);
1300   __ b(return_to_java);
1301 
1302   // Reguard stack pages. Save native results around a call to C runtime.
1303   __ bind(reguard);
1304   push_result_registers(masm, ret_type);
1305   __ call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));
1306   pop_result_registers(masm, ret_type);
1307   __ b(reguard_done);
1308 
1309   if (method-&gt;is_synchronized()) {
1310     // Locking slow case
1311     if(UseBiasedLocking) {
1312       __ bind(slow_lock_biased);
1313       __ sub(disp_hdr, FP, lock_slot_fp_offset);
1314     }
1315 
1316     __ bind(slow_lock);
1317 
1318     push_param_registers(masm, fp_regs_in_arguments);
1319 
1320     // last_Java_frame is already set, so do call_VM manually; no exception can occur
1321     __ mov(R0, sync_obj);
1322     __ mov(R1, disp_hdr);
1323     __ mov(R2, Rthread);
1324     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C));
1325 
1326     pop_param_registers(masm, fp_regs_in_arguments);
1327 
1328     __ b(lock_done);
1329 
1330     // Unlocking slow case
1331     __ bind(slow_unlock);
1332 
1333     push_result_registers(masm, ret_type);
1334 
1335     // Clear pending exception before reentering VM.
1336     // Can store the oop in register since it is a leaf call.
1337     assert_different_registers(Rtmp_save1, sync_obj, disp_hdr);
1338     __ ldr(Rtmp_save1, Address(Rthread, Thread::pending_exception_offset()));
1339     Register zero = __ zero_register(Rtemp);
1340     __ str(zero, Address(Rthread, Thread::pending_exception_offset()));
1341     __ mov(R0, sync_obj);
1342     __ mov(R1, disp_hdr);
1343     __ mov(R2, Rthread);
1344     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));
1345     __ str(Rtmp_save1, Address(Rthread, Thread::pending_exception_offset()));
1346 
1347     pop_result_registers(masm, ret_type);
1348 
1349     __ b(unlock_done);
1350   }
1351 
1352   __ flush();
1353   return nmethod::new_native_nmethod(method,
1354                                      compile_id,
1355                                      masm-&gt;code(),
1356                                      vep_offset,
1357                                      frame_complete,
1358                                      stack_slots / VMRegImpl::slots_per_word,
1359                                      in_ByteSize(is_static ? klass_offset : receiver_offset),
1360                                      in_ByteSize(lock_slot_offset * VMRegImpl::stack_slot_size),
1361                                      oop_maps);
1362 }
1363 
1364 // this function returns the adjust size (in number of words) to a c2i adapter
1365 // activation for use during deoptimization
1366 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
1367   int extra_locals_size = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
1368   return extra_locals_size;
1369 }
1370 
1371 
1372 uint SharedRuntime::out_preserve_stack_slots() {
1373   return 0;
1374 }
1375 
1376 
1377 //------------------------------generate_deopt_blob----------------------------
1378 void SharedRuntime::generate_deopt_blob() {
1379   ResourceMark rm;
1380   CodeBuffer buffer(&quot;deopt_blob&quot;, 1024, 1024);
1381   int frame_size_in_words;
1382   OopMapSet* oop_maps;
1383   int reexecute_offset;
1384   int exception_in_tls_offset;
1385   int exception_offset;
1386 
1387   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1388   Label cont;
1389   const Register Rkind   = R9; // caller-saved
1390   const Register Rublock = R6;
1391   const Register Rsender = altFP_7_11;
1392   assert_different_registers(Rkind, Rublock, Rsender, Rexception_obj, Rexception_pc, R0, R1, R2, R3, R8, Rtemp);
1393 
1394   address start = __ pc();
1395 
1396   oop_maps = new OopMapSet();
1397   // LR saved by caller (can be live in c2 method)
1398 
1399   // A deopt is a case where LR may be live in the c2 nmethod. So it&#39;s
1400   // not possible to call the deopt blob from the nmethod and pass the
1401   // address of the deopt handler of the nmethod in LR. What happens
1402   // now is that the caller of the deopt blob pushes the current
1403   // address so the deopt blob doesn&#39;t have to do it. This way LR can
1404   // be preserved, contains the live value from the nmethod and is
1405   // saved at R14/R30_offset here.
1406   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words, true);
1407   __ mov(Rkind, Deoptimization::Unpack_deopt);
1408   __ b(cont);
1409 
1410   exception_offset = __ pc() - start;
1411 
1412   // Transfer Rexception_obj &amp; Rexception_pc in TLS and fall thru to the
1413   // exception_in_tls_offset entry point.
1414   __ str(Rexception_obj, Address(Rthread, JavaThread::exception_oop_offset()));
1415   __ str(Rexception_pc, Address(Rthread, JavaThread::exception_pc_offset()));
1416   // Force return value to NULL to avoid confusing the escape analysis
1417   // logic. Everything is dead here anyway.
1418   __ mov(R0, 0);
1419 
1420   exception_in_tls_offset = __ pc() - start;
1421 
1422   // Exception data is in JavaThread structure
1423   // Patch the return address of the current frame
1424   __ ldr(LR, Address(Rthread, JavaThread::exception_pc_offset()));
1425   (void) RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words);
1426   {
1427     const Register Rzero = __ zero_register(Rtemp); // XXX should be OK for C2 but not 100% sure
1428     __ str(Rzero, Address(Rthread, JavaThread::exception_pc_offset()));
1429   }
1430   __ mov(Rkind, Deoptimization::Unpack_exception);
1431   __ b(cont);
1432 
1433   reexecute_offset = __ pc() - start;
1434 
1435   (void) RegisterSaver::save_live_registers(masm, &amp;frame_size_in_words);
1436   __ mov(Rkind, Deoptimization::Unpack_reexecute);
1437 
1438   // Calculate UnrollBlock and save the result in Rublock
1439   __ bind(cont);
1440   __ mov(R0, Rthread);
1441   __ mov(R1, Rkind);
1442 
1443   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1444   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1445   __ call(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info));
1446   if (pc_offset == -1) {
1447     pc_offset = __ offset();
1448   }
1449   oop_maps-&gt;add_gc_map(pc_offset, map);
1450   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1451 
1452   __ mov(Rublock, R0);
1453 
1454   // Reload Rkind from the UnrollBlock (might have changed)
1455   __ ldr_s32(Rkind, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1456   Label noException;
1457   __ cmp_32(Rkind, Deoptimization::Unpack_exception);   // Was exception pending?
1458   __ b(noException, ne);
1459   // handle exception case
1460 #ifdef ASSERT
1461   // assert that exception_pc is zero in tls
1462   { Label L;
1463     __ ldr(Rexception_pc, Address(Rthread, JavaThread::exception_pc_offset()));
1464     __ cbz(Rexception_pc, L);
1465     __ stop(&quot;exception pc should be null&quot;);
1466     __ bind(L);
1467   }
1468 #endif
1469   __ ldr(Rexception_obj, Address(Rthread, JavaThread::exception_oop_offset()));
1470   __ verify_oop(Rexception_obj);
1471   {
1472     const Register Rzero = __ zero_register(Rtemp);
1473     __ str(Rzero, Address(Rthread, JavaThread::exception_oop_offset()));
1474   }
1475 
1476   __ bind(noException);
1477 
1478   // This frame is going away.  Fetch return value, so we can move it to
1479   // a new frame.
1480   __ ldr(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1481   __ ldr(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1482 #ifndef __SOFTFP__
1483   __ ldr_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1484 #endif
1485   // pop frame
1486   __ add(SP, SP, RegisterSaver::reg_save_size * wordSize);
1487 
1488   // Set initial stack state before pushing interpreter frames
1489   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
1490   __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
1491   __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
1492 
1493   __ add(SP, SP, Rtemp);
1494 
1495 #ifdef ASSERT
1496   // Compilers generate code that bang the stack by as much as the
1497   // interpreter would need. So this stack banging should never
1498   // trigger a fault. Verify that it does not on non product builds.
1499   // See if it is enough stack to push deoptimized frames
1500   if (UseStackBanging) {
1501     // The compiled method that we are deoptimizing was popped from the stack.
1502     // If the stack bang results in a stack overflow, we don&#39;t return to the
1503     // method that is being deoptimized. The stack overflow exception is
1504     // propagated to the caller of the deoptimized method. Need to get the pc
1505     // from the caller in LR and restore FP.
1506     __ ldr(LR, Address(R2, 0));
1507     __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1508     __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
1509     __ arm_stack_overflow_check(R8, Rtemp);
1510   }
1511 #endif
1512   __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
1513 
1514   // Pick up the initial fp we should save
1515   // XXX Note: was ldr(FP, Address(FP));
1516 
1517   // The compiler no longer uses FP as a frame pointer for the
1518   // compiled code. It can be used by the allocator in C2 or to
1519   // memorize the original SP for JSR292 call sites.
1520 
1521   // Hence, ldr(FP, Address(FP)) is probably not correct. For x86,
1522   // Deoptimization::fetch_unroll_info computes the right FP value and
1523   // stores it in Rublock.initial_info. This has been activated for ARM.
1524   __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1525 
1526   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
1527   __ mov(Rsender, SP);
1528   __ sub(SP, SP, Rtemp);
1529 
1530   // Push interpreter frames in a loop
1531   Label loop;
1532   __ bind(loop);
1533   __ ldr(LR, Address(R2, wordSize, post_indexed));         // load frame pc
1534   __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      // load frame size
1535 
1536   __ raw_push(FP, LR);                                     // create new frame
1537   __ mov(FP, SP);
1538   __ sub(Rtemp, Rtemp, 2*wordSize);
1539 
1540   __ sub(SP, SP, Rtemp);
1541 
1542   __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));
1543   __ mov(LR, 0);
1544   __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
1545 
1546   __ subs(R8, R8, 1);                               // decrement counter
1547   __ mov(Rsender, SP);
1548   __ b(loop, ne);
1549 
1550   // Re-push self-frame
1551   __ ldr(LR, Address(R2));
1552   __ raw_push(FP, LR);
1553   __ mov(FP, SP);
1554   __ sub(SP, SP, (frame_size_in_words - 2) * wordSize);
1555 
1556   // Restore frame locals after moving the frame
1557   __ str(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1558   __ str(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1559 
1560 #ifndef __SOFTFP__
1561   __ str_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1562 #endif // !__SOFTFP__
1563 
1564 #ifdef ASSERT
1565   // Reload Rkind from the UnrollBlock and check that it was not overwritten (Rkind is not callee-saved)
1566   { Label L;
1567     __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1568     __ cmp_32(Rkind, Rtemp);
1569     __ b(L, eq);
1570     __ stop(&quot;Rkind was overwritten&quot;);
1571     __ bind(L);
1572   }
1573 #endif
1574 
1575   // Call unpack_frames with proper arguments
1576   __ mov(R0, Rthread);
1577   __ mov(R1, Rkind);
1578 
1579   pc_offset = __ set_last_Java_frame(SP, FP, true, Rtemp);
1580   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1581   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));
1582   if (pc_offset == -1) {
1583     pc_offset = __ offset();
1584   }
1585   oop_maps-&gt;add_gc_map(pc_offset, new OopMap(frame_size_in_words * VMRegImpl::slots_per_word, 0));
1586   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1587 
1588   // Collect return values, pop self-frame and jump to interpreter
1589   __ ldr(R0, Address(SP, RegisterSaver::R0_offset * wordSize));
1590   __ ldr(R1, Address(SP, RegisterSaver::R1_offset * wordSize));
1591   // Interpreter floats controlled by __SOFTFP__, but compiler
1592   // float return value registers controlled by __ABI_HARD__
1593   // This matters for vfp-sflt builds.
1594 #ifndef __SOFTFP__
1595   // Interpreter hard float
1596 #ifdef __ABI_HARD__
1597   // Compiler float return value in FP registers
1598   __ ldr_double(D0, Address(SP, RegisterSaver::D0_offset * wordSize));
1599 #else
1600   // Compiler float return value in integer registers,
1601   // copy to D0 for interpreter (S0 &lt;-- R0)
1602   __ fmdrr(D0_tos, R0, R1);
1603 #endif
1604 #endif // !__SOFTFP__
1605   __ mov(SP, FP);
1606 
1607   __ pop(RegisterSet(FP) | RegisterSet(PC));
1608 
1609   __ flush();
1610 
1611   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset,
1612                                            reexecute_offset, frame_size_in_words);
1613   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
1614 }
1615 
1616 #ifdef COMPILER2
1617 
1618 //------------------------------generate_uncommon_trap_blob--------------------
1619 // Ought to generate an ideal graph &amp; compile, but here&#39;s some SPARC ASM
1620 // instead.
1621 void SharedRuntime::generate_uncommon_trap_blob() {
1622   // allocate space for the code
1623   ResourceMark rm;
1624 
1625   // setup code generation tools
1626   int pad = VerifyThread ? 512 : 0;
1627 #ifdef _LP64
1628   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2700+pad, 512);
1629 #else
1630   // Measured 8/7/03 at 660 in 32bit debug build (no VerifyThread)
1631   // Measured 8/7/03 at 1028 in 32bit debug build (VerifyThread)
1632   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2000+pad, 512);
1633 #endif
1634   // bypassed when code generation useless
1635   MacroAssembler* masm               = new MacroAssembler(&amp;buffer);
1636   const Register Rublock = R6;
1637   const Register Rsender = altFP_7_11;
1638   assert_different_registers(Rublock, Rsender, Rexception_obj, R0, R1, R2, R3, R8, Rtemp);
1639 
1640   //
1641   // This is the entry point for all traps the compiler takes when it thinks
1642   // it cannot handle further execution of compilation code. The frame is
1643   // deoptimized in these cases and converted into interpreter frames for
1644   // execution
1645   // The steps taken by this frame are as follows:
1646   //   - push a fake &quot;unpack_frame&quot;
1647   //   - call the C routine Deoptimization::uncommon_trap (this function
1648   //     packs the current compiled frame into vframe arrays and returns
1649   //     information about the number and size of interpreter frames which
1650   //     are equivalent to the frame which is being deoptimized)
1651   //   - deallocate the &quot;unpack_frame&quot;
1652   //   - deallocate the deoptimization frame
1653   //   - in a loop using the information returned in the previous step
1654   //     push interpreter frames;
1655   //   - create a dummy &quot;unpack_frame&quot;
1656   //   - call the C routine: Deoptimization::unpack_frames (this function
1657   //     lays out values on the interpreter frame which was just created)
1658   //   - deallocate the dummy unpack_frame
1659   //   - return to the interpreter entry point
1660   //
1661   //  Refer to the following methods for more information:
1662   //   - Deoptimization::uncommon_trap
1663   //   - Deoptimization::unpack_frame
1664 
1665   // the unloaded class index is in R0 (first parameter to this blob)
1666 
1667   __ raw_push(FP, LR);
1668   __ set_last_Java_frame(SP, FP, false, Rtemp);
1669   __ mov(R2, Deoptimization::Unpack_uncommon_trap);
1670   __ mov(R1, R0);
1671   __ mov(R0, Rthread);
1672   __ call(CAST_FROM_FN_PTR(address, Deoptimization::uncommon_trap));
1673   __ mov(Rublock, R0);
1674   __ reset_last_Java_frame(Rtemp);
1675   __ raw_pop(FP, LR);
1676 
1677 #ifdef ASSERT
1678   { Label L;
1679     __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
1680     __ cmp_32(Rtemp, Deoptimization::Unpack_uncommon_trap);
1681     __ b(L, eq);
1682     __ stop(&quot;SharedRuntime::generate_uncommon_trap_blob: expected Unpack_uncommon_trap&quot;);
1683     __ bind(L);
1684   }
1685 #endif
1686 
1687 
1688   // Set initial stack state before pushing interpreter frames
1689   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
1690   __ ldr(R2, Address(Rublock, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
1691   __ ldr(R3, Address(Rublock, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
1692 
1693   __ add(SP, SP, Rtemp);
1694 
1695   // See if it is enough stack to push deoptimized frames
1696 #ifdef ASSERT
1697   // Compilers generate code that bang the stack by as much as the
1698   // interpreter would need. So this stack banging should never
1699   // trigger a fault. Verify that it does not on non product builds.
1700   if (UseStackBanging) {
1701     // The compiled method that we are deoptimizing was popped from the stack.
1702     // If the stack bang results in a stack overflow, we don&#39;t return to the
1703     // method that is being deoptimized. The stack overflow exception is
1704     // propagated to the caller of the deoptimized method. Need to get the pc
1705     // from the caller in LR and restore FP.
1706     __ ldr(LR, Address(R2, 0));
1707     __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1708     __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
1709     __ arm_stack_overflow_check(R8, Rtemp);
1710   }
1711 #endif
1712   __ ldr_s32(R8, Address(Rublock, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
1713   __ ldr_s32(Rtemp, Address(Rublock, Deoptimization::UnrollBlock::caller_adjustment_offset_in_bytes()));
1714   __ mov(Rsender, SP);
1715   __ sub(SP, SP, Rtemp);
1716   //  __ ldr(FP, Address(FP));
1717   __ ldr(FP, Address(Rublock, Deoptimization::UnrollBlock::initial_info_offset_in_bytes()));
1718 
1719   // Push interpreter frames in a loop
1720   Label loop;
1721   __ bind(loop);
1722   __ ldr(LR, Address(R2, wordSize, post_indexed));         // load frame pc
1723   __ ldr(Rtemp, Address(R3, wordSize, post_indexed));      // load frame size
1724 
1725   __ raw_push(FP, LR);                                     // create new frame
1726   __ mov(FP, SP);
1727   __ sub(Rtemp, Rtemp, 2*wordSize);
1728 
1729   __ sub(SP, SP, Rtemp);
1730 
1731   __ str(Rsender, Address(FP, frame::interpreter_frame_sender_sp_offset * wordSize));
1732   __ mov(LR, 0);
1733   __ str(LR, Address(FP, frame::interpreter_frame_last_sp_offset * wordSize));
1734   __ subs(R8, R8, 1);                               // decrement counter
1735   __ mov(Rsender, SP);
1736   __ b(loop, ne);
1737 
1738   // Re-push self-frame
1739   __ ldr(LR, Address(R2));
1740   __ raw_push(FP, LR);
1741   __ mov(FP, SP);
1742 
1743   // Call unpack_frames with proper arguments
1744   __ mov(R0, Rthread);
1745   __ mov(R1, Deoptimization::Unpack_uncommon_trap);
1746   __ set_last_Java_frame(SP, FP, true, Rtemp);
1747   __ call_VM_leaf(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames));
1748   //  oop_maps-&gt;add_gc_map(__ pc() - start, new OopMap(frame_size_in_words, 0));
1749   __ reset_last_Java_frame(Rtemp);
1750 
1751   __ mov(SP, FP);
1752   __ pop(RegisterSet(FP) | RegisterSet(PC));
1753 
1754   masm-&gt;flush();
1755   _uncommon_trap_blob = UncommonTrapBlob::create(&amp;buffer, NULL, 2 /* LR+FP */);
1756 }
1757 
1758 #endif // COMPILER2
1759 
1760 //------------------------------generate_handler_blob------
1761 //
1762 // Generate a special Compile2Runtime blob that saves all registers,
1763 // setup oopmap, and calls safepoint code to stop the compiled code for
1764 // a safepoint.
1765 //
1766 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
1767   assert(StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
1768 
1769   ResourceMark rm;
1770   CodeBuffer buffer(&quot;handler_blob&quot;, 256, 256);
1771   int frame_size_words;
1772   OopMapSet* oop_maps;
1773 
1774   bool cause_return = (poll_type == POLL_AT_RETURN);
1775 
1776   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1777   address start = __ pc();
1778   oop_maps = new OopMapSet();
1779 
1780   if (!cause_return) {
1781     __ sub(SP, SP, 4); // make room for LR which may still be live
1782                        // here if we are coming from a c2 method
1783   }
1784 
1785   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words, !cause_return);
1786   if (!cause_return) {
1787     // update saved PC with correct value
1788     // need 2 steps because LR can be live in c2 method
1789     __ ldr(LR, Address(Rthread, JavaThread::saved_exception_pc_offset()));
1790     __ str(LR, Address(SP, RegisterSaver::LR_offset * wordSize));
1791   }
1792 
1793   __ mov(R0, Rthread);
1794   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp); // note: FP may not need to be saved (not on x86)
1795   assert(((__ pc()) - start) == __ offset(), &quot;warning: start differs from code_begin&quot;);
1796   __ call(call_ptr);
1797   if (pc_offset == -1) {
1798     pc_offset = __ offset();
1799   }
1800   oop_maps-&gt;add_gc_map(pc_offset, map);
1801   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1802 
1803   if (!cause_return) {
1804     if (SafepointMechanism::uses_thread_local_poll()) {
1805       // If our stashed return pc was modified by the runtime we avoid touching it
1806       __ ldr(R3_tmp, Address(Rthread, JavaThread::saved_exception_pc_offset()));
1807       __ ldr(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize));
1808       __ cmp(R2_tmp, R3_tmp);
1809       // Adjust return pc forward to step over the safepoint poll instruction
1810       __ add(R2_tmp, R2_tmp, 4, eq);
1811       __ str(R2_tmp, Address(SP, RegisterSaver::LR_offset * wordSize), eq);
1812     }
1813 
1814     // Check for pending exception
1815     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1816     __ cmp(Rtemp, 0);
1817 
1818     RegisterSaver::restore_live_registers(masm, false);
1819     __ pop(PC, eq);
1820     __ pop(Rexception_pc);
1821   } else {
1822     // Check for pending exception
1823     __ ldr(Rtemp, Address(Rthread, Thread::pending_exception_offset()));
1824     __ cmp(Rtemp, 0);
1825 
1826     RegisterSaver::restore_live_registers(masm);
1827     __ bx(LR, eq);
1828     __ mov(Rexception_pc, LR);
1829   }
1830 
1831   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1832 
1833   __ flush();
1834 
1835   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_words);
1836 }
1837 
1838 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
1839   assert(StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
1840 
1841   ResourceMark rm;
1842   CodeBuffer buffer(name, 1000, 512);
1843   int frame_size_words;
1844   OopMapSet *oop_maps;
1845   int frame_complete;
1846 
1847   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
1848   Label pending_exception;
1849 
1850   int start = __ offset();
1851 
1852   oop_maps = new OopMapSet();
1853   OopMap* map = RegisterSaver::save_live_registers(masm, &amp;frame_size_words);
1854 
1855   frame_complete = __ offset();
1856 
1857   __ mov(R0, Rthread);
1858 
1859   int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);
1860   assert(start == 0, &quot;warning: start differs from code_begin&quot;);
1861   __ call(destination);
1862   if (pc_offset == -1) {
1863     pc_offset = __ offset();
1864   }
1865   oop_maps-&gt;add_gc_map(pc_offset, map);
1866   __ reset_last_Java_frame(Rtemp); // Rtemp free since scratched by far call
1867 
1868   __ ldr(R1, Address(Rthread, Thread::pending_exception_offset()));
1869   __ cbnz(R1, pending_exception);
1870 
1871   // Overwrite saved register values
1872 
1873   // Place metadata result of VM call into Rmethod
1874   __ get_vm_result_2(R1, Rtemp);
1875   __ str(R1, Address(SP, RegisterSaver::Rmethod_offset * wordSize));
1876 
1877   // Place target address (VM call result) into Rtemp
1878   __ str(R0, Address(SP, RegisterSaver::Rtemp_offset * wordSize));
1879 
1880   RegisterSaver::restore_live_registers(masm);
1881   __ jump(Rtemp);
1882 
1883   __ bind(pending_exception);
1884 
1885   RegisterSaver::restore_live_registers(masm);
1886   const Register Rzero = __ zero_register(Rtemp);
1887   __ str(Rzero, Address(Rthread, JavaThread::vm_result_2_offset()));
1888   __ mov(Rexception_pc, LR);
1889   __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);
1890 
1891   __ flush();
1892 
1893   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_words, oop_maps, true);
1894 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/vm_version_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;logging/log.hpp&quot;
  30 #include &quot;logging/logStream.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;runtime/java.hpp&quot;
  33 #include &quot;runtime/os.hpp&quot;
  34 #include &quot;runtime/stubCodeGenerator.hpp&quot;
  35 #include &quot;runtime/vm_version.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  36 #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  37 #include &quot;utilities/virtualizationSupport.hpp&quot;
  38 
  39 #include OS_HEADER_INLINE(os)
  40 
  41 int VM_Version::_cpu;
  42 int VM_Version::_model;
  43 int VM_Version::_stepping;
  44 VM_Version::CpuidInfo VM_Version::_cpuid_info = { 0, };
  45 
  46 // Address of instruction which causes SEGV
  47 address VM_Version::_cpuinfo_segv_addr = 0;
  48 // Address of instruction after the one which causes SEGV
  49 address VM_Version::_cpuinfo_cont_addr = 0;
  50 
  51 static BufferBlob* stub_blob;
  52 static const int stub_size = 1100;
  53 
  54 extern &quot;C&quot; {
  55   typedef void (*get_cpu_info_stub_t)(void*);
  56 }
  57 static get_cpu_info_stub_t get_cpu_info_stub = NULL;
  58 
  59 
  60 class VM_Version_StubGenerator: public StubCodeGenerator {
  61  public:
  62 
  63   VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}
  64 
  65   address generate_get_cpu_info() {
  66     // Flags to test CPU type.
  67     const uint32_t HS_EFL_AC = 0x40000;
  68     const uint32_t HS_EFL_ID = 0x200000;
  69     // Values for when we don&#39;t have a CPUID instruction.
  70     const int      CPU_FAMILY_SHIFT = 8;
  71     const uint32_t CPU_FAMILY_386 = (3 &lt;&lt; CPU_FAMILY_SHIFT);
  72     const uint32_t CPU_FAMILY_486 = (4 &lt;&lt; CPU_FAMILY_SHIFT);
  73     bool use_evex = FLAG_IS_DEFAULT(UseAVX) || (UseAVX &gt; 2);
  74 
  75     Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;
  76     Label sef_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7, ext_cpuid8, done, wrapup;
  77     Label legacy_setup, save_restore_except, legacy_save_restore, start_simd_check;
  78 
  79     StubCodeMark mark(this, &quot;VM_Version&quot;, &quot;get_cpu_info_stub&quot;);
  80 #   define __ _masm-&gt;
  81 
  82     address start = __ pc();
  83 
  84     //
  85     // void get_cpu_info(VM_Version::CpuidInfo* cpuid_info);
  86     //
  87     // LP64: rcx and rdx are first and second argument registers on windows
  88 
  89     __ push(rbp);
  90 #ifdef _LP64
  91     __ mov(rbp, c_rarg0); // cpuid_info address
  92 #else
  93     __ movptr(rbp, Address(rsp, 8)); // cpuid_info address
  94 #endif
  95     __ push(rbx);
  96     __ push(rsi);
  97     __ pushf();          // preserve rbx, and flags
  98     __ pop(rax);
  99     __ push(rax);
 100     __ mov(rcx, rax);
 101     //
 102     // if we are unable to change the AC flag, we have a 386
 103     //
 104     __ xorl(rax, HS_EFL_AC);
 105     __ push(rax);
 106     __ popf();
 107     __ pushf();
 108     __ pop(rax);
 109     __ cmpptr(rax, rcx);
 110     __ jccb(Assembler::notEqual, detect_486);
 111 
 112     __ movl(rax, CPU_FAMILY_386);
 113     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 114     __ jmp(done);
 115 
 116     //
 117     // If we are unable to change the ID flag, we have a 486 which does
 118     // not support the &quot;cpuid&quot; instruction.
 119     //
 120     __ bind(detect_486);
 121     __ mov(rax, rcx);
 122     __ xorl(rax, HS_EFL_ID);
 123     __ push(rax);
 124     __ popf();
 125     __ pushf();
 126     __ pop(rax);
 127     __ cmpptr(rcx, rax);
 128     __ jccb(Assembler::notEqual, detect_586);
 129 
 130     __ bind(cpu486);
 131     __ movl(rax, CPU_FAMILY_486);
 132     __ movl(Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())), rax);
 133     __ jmp(done);
 134 
 135     //
 136     // At this point, we have a chip which supports the &quot;cpuid&quot; instruction
 137     //
 138     __ bind(detect_586);
 139     __ xorl(rax, rax);
 140     __ cpuid();
 141     __ orl(rax, rax);
 142     __ jcc(Assembler::equal, cpu486);   // if cpuid doesn&#39;t support an input
 143                                         // value of at least 1, we give up and
 144                                         // assume a 486
 145     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 146     __ movl(Address(rsi, 0), rax);
 147     __ movl(Address(rsi, 4), rbx);
 148     __ movl(Address(rsi, 8), rcx);
 149     __ movl(Address(rsi,12), rdx);
 150 
 151     __ cmpl(rax, 0xa);                  // Is cpuid(0xB) supported?
 152     __ jccb(Assembler::belowEqual, std_cpuid4);
 153 
 154     //
 155     // cpuid(0xB) Processor Topology
 156     //
 157     __ movl(rax, 0xb);
 158     __ xorl(rcx, rcx);   // Threads level
 159     __ cpuid();
 160 
 161     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB0_offset())));
 162     __ movl(Address(rsi, 0), rax);
 163     __ movl(Address(rsi, 4), rbx);
 164     __ movl(Address(rsi, 8), rcx);
 165     __ movl(Address(rsi,12), rdx);
 166 
 167     __ movl(rax, 0xb);
 168     __ movl(rcx, 1);     // Cores level
 169     __ cpuid();
 170     __ push(rax);
 171     __ andl(rax, 0x1f);  // Determine if valid topology level
 172     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 173     __ andl(rax, 0xffff);
 174     __ pop(rax);
 175     __ jccb(Assembler::equal, std_cpuid4);
 176 
 177     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB1_offset())));
 178     __ movl(Address(rsi, 0), rax);
 179     __ movl(Address(rsi, 4), rbx);
 180     __ movl(Address(rsi, 8), rcx);
 181     __ movl(Address(rsi,12), rdx);
 182 
 183     __ movl(rax, 0xb);
 184     __ movl(rcx, 2);     // Packages level
 185     __ cpuid();
 186     __ push(rax);
 187     __ andl(rax, 0x1f);  // Determine if valid topology level
 188     __ orl(rax, rbx);    // eax[4:0] | ebx[0:15] == 0 indicates invalid level
 189     __ andl(rax, 0xffff);
 190     __ pop(rax);
 191     __ jccb(Assembler::equal, std_cpuid4);
 192 
 193     __ lea(rsi, Address(rbp, in_bytes(VM_Version::tpl_cpuidB2_offset())));
 194     __ movl(Address(rsi, 0), rax);
 195     __ movl(Address(rsi, 4), rbx);
 196     __ movl(Address(rsi, 8), rcx);
 197     __ movl(Address(rsi,12), rdx);
 198 
 199     //
 200     // cpuid(0x4) Deterministic cache params
 201     //
 202     __ bind(std_cpuid4);
 203     __ movl(rax, 4);
 204     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x4) supported?
 205     __ jccb(Assembler::greater, std_cpuid1);
 206 
 207     __ xorl(rcx, rcx);   // L1 cache
 208     __ cpuid();
 209     __ push(rax);
 210     __ andl(rax, 0x1f);  // Determine if valid cache parameters used
 211     __ orl(rax, rax);    // eax[4:0] == 0 indicates invalid cache
 212     __ pop(rax);
 213     __ jccb(Assembler::equal, std_cpuid1);
 214 
 215     __ lea(rsi, Address(rbp, in_bytes(VM_Version::dcp_cpuid4_offset())));
 216     __ movl(Address(rsi, 0), rax);
 217     __ movl(Address(rsi, 4), rbx);
 218     __ movl(Address(rsi, 8), rcx);
 219     __ movl(Address(rsi,12), rdx);
 220 
 221     //
 222     // Standard cpuid(0x1)
 223     //
 224     __ bind(std_cpuid1);
 225     __ movl(rax, 1);
 226     __ cpuid();
 227     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 228     __ movl(Address(rsi, 0), rax);
 229     __ movl(Address(rsi, 4), rbx);
 230     __ movl(Address(rsi, 8), rcx);
 231     __ movl(Address(rsi,12), rdx);
 232 
 233     //
 234     // Check if OS has enabled XGETBV instruction to access XCR0
 235     // (OSXSAVE feature flag) and CPU supports AVX
 236     //
 237     __ andl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 238     __ cmpl(rcx, 0x18000000);
 239     __ jccb(Assembler::notEqual, sef_cpuid); // jump if AVX is not supported
 240 
 241     //
 242     // XCR0, XFEATURE_ENABLED_MASK register
 243     //
 244     __ xorl(rcx, rcx);   // zero for XCR0 register
 245     __ xgetbv();
 246     __ lea(rsi, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset())));
 247     __ movl(Address(rsi, 0), rax);
 248     __ movl(Address(rsi, 4), rdx);
 249 
 250     //
 251     // cpuid(0x7) Structured Extended Features
 252     //
 253     __ bind(sef_cpuid);
 254     __ movl(rax, 7);
 255     __ cmpl(rax, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset()))); // Is cpuid(0x7) supported?
 256     __ jccb(Assembler::greater, ext_cpuid);
 257 
 258     __ xorl(rcx, rcx);
 259     __ cpuid();
 260     __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 261     __ movl(Address(rsi, 0), rax);
 262     __ movl(Address(rsi, 4), rbx);
 263     __ movl(Address(rsi, 8), rcx);
 264     __ movl(Address(rsi, 12), rdx);
 265 
 266     //
 267     // Extended cpuid(0x80000000)
 268     //
 269     __ bind(ext_cpuid);
 270     __ movl(rax, 0x80000000);
 271     __ cpuid();
 272     __ cmpl(rax, 0x80000000);     // Is cpuid(0x80000001) supported?
 273     __ jcc(Assembler::belowEqual, done);
 274     __ cmpl(rax, 0x80000004);     // Is cpuid(0x80000005) supported?
 275     __ jcc(Assembler::belowEqual, ext_cpuid1);
 276     __ cmpl(rax, 0x80000006);     // Is cpuid(0x80000007) supported?
 277     __ jccb(Assembler::belowEqual, ext_cpuid5);
 278     __ cmpl(rax, 0x80000007);     // Is cpuid(0x80000008) supported?
 279     __ jccb(Assembler::belowEqual, ext_cpuid7);
 280     __ cmpl(rax, 0x80000008);     // Is cpuid(0x80000009 and above) supported?
 281     __ jccb(Assembler::belowEqual, ext_cpuid8);
 282     __ cmpl(rax, 0x8000001E);     // Is cpuid(0x8000001E) supported?
 283     __ jccb(Assembler::below, ext_cpuid8);
 284     //
 285     // Extended cpuid(0x8000001E)
 286     //
 287     __ movl(rax, 0x8000001E);
 288     __ cpuid();
 289     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1E_offset())));
 290     __ movl(Address(rsi, 0), rax);
 291     __ movl(Address(rsi, 4), rbx);
 292     __ movl(Address(rsi, 8), rcx);
 293     __ movl(Address(rsi,12), rdx);
 294 
 295     //
 296     // Extended cpuid(0x80000008)
 297     //
 298     __ bind(ext_cpuid8);
 299     __ movl(rax, 0x80000008);
 300     __ cpuid();
 301     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid8_offset())));
 302     __ movl(Address(rsi, 0), rax);
 303     __ movl(Address(rsi, 4), rbx);
 304     __ movl(Address(rsi, 8), rcx);
 305     __ movl(Address(rsi,12), rdx);
 306 
 307     //
 308     // Extended cpuid(0x80000007)
 309     //
 310     __ bind(ext_cpuid7);
 311     __ movl(rax, 0x80000007);
 312     __ cpuid();
 313     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid7_offset())));
 314     __ movl(Address(rsi, 0), rax);
 315     __ movl(Address(rsi, 4), rbx);
 316     __ movl(Address(rsi, 8), rcx);
 317     __ movl(Address(rsi,12), rdx);
 318 
 319     //
 320     // Extended cpuid(0x80000005)
 321     //
 322     __ bind(ext_cpuid5);
 323     __ movl(rax, 0x80000005);
 324     __ cpuid();
 325     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid5_offset())));
 326     __ movl(Address(rsi, 0), rax);
 327     __ movl(Address(rsi, 4), rbx);
 328     __ movl(Address(rsi, 8), rcx);
 329     __ movl(Address(rsi,12), rdx);
 330 
 331     //
 332     // Extended cpuid(0x80000001)
 333     //
 334     __ bind(ext_cpuid1);
 335     __ movl(rax, 0x80000001);
 336     __ cpuid();
 337     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ext_cpuid1_offset())));
 338     __ movl(Address(rsi, 0), rax);
 339     __ movl(Address(rsi, 4), rbx);
 340     __ movl(Address(rsi, 8), rcx);
 341     __ movl(Address(rsi,12), rdx);
 342 
 343     //
 344     // Check if OS has enabled XGETBV instruction to access XCR0
 345     // (OSXSAVE feature flag) and CPU supports AVX
 346     //
 347     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 348     __ movl(rcx, 0x18000000); // cpuid1 bits osxsave | avx
 349     __ andl(rcx, Address(rsi, 8)); // cpuid1 bits osxsave | avx
 350     __ cmpl(rcx, 0x18000000);
 351     __ jccb(Assembler::notEqual, done); // jump if AVX is not supported
 352 
 353     __ movl(rax, 0x6);
 354     __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 355     __ cmpl(rax, 0x6);
 356     __ jccb(Assembler::equal, start_simd_check); // return if AVX is not supported
 357 
 358     // we need to bridge farther than imm8, so we use this island as a thunk
 359     __ bind(done);
 360     __ jmp(wrapup);
 361 
 362     __ bind(start_simd_check);
 363     //
 364     // Some OSs have a bug when upper 128/256bits of YMM/ZMM
 365     // registers are not restored after a signal processing.
 366     // Generate SEGV here (reference through NULL)
 367     // and check upper YMM/ZMM bits after it.
 368     //
 369     intx saved_useavx = UseAVX;
 370     intx saved_usesse = UseSSE;
 371 
 372     // If UseAVX is unitialized or is set by the user to include EVEX
 373     if (use_evex) {
 374       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 375       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 376       __ movl(rax, 0x10000);
 377       __ andl(rax, Address(rsi, 4)); // xcr0 bits sse | ymm
 378       __ cmpl(rax, 0x10000);
 379       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 380       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 381       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 382       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 383       __ movl(rax, 0xE0);
 384       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 385       __ cmpl(rax, 0xE0);
 386       __ jccb(Assembler::notEqual, legacy_setup); // jump if EVEX is not supported
 387 
 388       if (FLAG_IS_DEFAULT(UseAVX)) {
 389         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 390         __ movl(rax, Address(rsi, 0));
 391         __ cmpl(rax, 0x50654);              // If it is Skylake
 392         __ jcc(Assembler::equal, legacy_setup);
 393       }
 394       // EVEX setup: run in lowest evex mode
 395       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 396       UseAVX = 3;
 397       UseSSE = 2;
 398 #ifdef _WINDOWS
 399       // xmm5-xmm15 are not preserved by caller on windows
 400       // https://msdn.microsoft.com/en-us/library/9z1stfyw.aspx
 401       __ subptr(rsp, 64);
 402       __ evmovdqul(Address(rsp, 0), xmm7, Assembler::AVX_512bit);
 403 #ifdef _LP64
 404       __ subptr(rsp, 64);
 405       __ evmovdqul(Address(rsp, 0), xmm8, Assembler::AVX_512bit);
 406       __ subptr(rsp, 64);
 407       __ evmovdqul(Address(rsp, 0), xmm31, Assembler::AVX_512bit);
 408 #endif // _LP64
 409 #endif // _WINDOWS
 410 
 411       // load value into all 64 bytes of zmm7 register
 412       __ movl(rcx, VM_Version::ymm_test_value());
 413       __ movdl(xmm0, rcx);
 414       __ vpbroadcastd(xmm0, xmm0, Assembler::AVX_512bit);
 415       __ evmovdqul(xmm7, xmm0, Assembler::AVX_512bit);
 416 #ifdef _LP64
 417       __ evmovdqul(xmm8, xmm0, Assembler::AVX_512bit);
 418       __ evmovdqul(xmm31, xmm0, Assembler::AVX_512bit);
 419 #endif
 420       VM_Version::clean_cpuFeatures();
 421       __ jmp(save_restore_except);
 422     }
 423 
 424     __ bind(legacy_setup);
 425     // AVX setup
 426     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 427     UseAVX = 1;
 428     UseSSE = 2;
 429 #ifdef _WINDOWS
 430     __ subptr(rsp, 32);
 431     __ vmovdqu(Address(rsp, 0), xmm7);
 432 #ifdef _LP64
 433     __ subptr(rsp, 32);
 434     __ vmovdqu(Address(rsp, 0), xmm8);
 435     __ subptr(rsp, 32);
 436     __ vmovdqu(Address(rsp, 0), xmm15);
 437 #endif // _LP64
 438 #endif // _WINDOWS
 439 
 440     // load value into all 32 bytes of ymm7 register
 441     __ movl(rcx, VM_Version::ymm_test_value());
 442 
 443     __ movdl(xmm0, rcx);
 444     __ pshufd(xmm0, xmm0, 0x00);
 445     __ vinsertf128_high(xmm0, xmm0);
 446     __ vmovdqu(xmm7, xmm0);
 447 #ifdef _LP64
 448     __ vmovdqu(xmm8, xmm0);
 449     __ vmovdqu(xmm15, xmm0);
 450 #endif
 451     VM_Version::clean_cpuFeatures();
 452 
 453     __ bind(save_restore_except);
 454     __ xorl(rsi, rsi);
 455     VM_Version::set_cpuinfo_segv_addr(__ pc());
 456     // Generate SEGV
 457     __ movl(rax, Address(rsi, 0));
 458 
 459     VM_Version::set_cpuinfo_cont_addr(__ pc());
 460     // Returns here after signal. Save xmm0 to check it later.
 461 
 462     // If UseAVX is unitialized or is set by the user to include EVEX
 463     if (use_evex) {
 464       // check _cpuid_info.sef_cpuid7_ebx.bits.avx512f
 465       __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_offset())));
 466       __ movl(rax, 0x10000);
 467       __ andl(rax, Address(rsi, 4));
 468       __ cmpl(rax, 0x10000);
 469       __ jcc(Assembler::notEqual, legacy_save_restore);
 470       // check _cpuid_info.xem_xcr0_eax.bits.opmask
 471       // check _cpuid_info.xem_xcr0_eax.bits.zmm512
 472       // check _cpuid_info.xem_xcr0_eax.bits.zmm32
 473       __ movl(rax, 0xE0);
 474       __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); // xcr0 bits sse | ymm
 475       __ cmpl(rax, 0xE0);
 476       __ jcc(Assembler::notEqual, legacy_save_restore);
 477 
 478       if (FLAG_IS_DEFAULT(UseAVX)) {
 479         __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 480         __ movl(rax, Address(rsi, 0));
 481         __ cmpl(rax, 0x50654);              // If it is Skylake
 482         __ jcc(Assembler::equal, legacy_save_restore);
 483       }
 484       // EVEX check: run in lowest evex mode
 485       VM_Version::set_evex_cpuFeatures(); // Enable temporary to pass asserts
 486       UseAVX = 3;
 487       UseSSE = 2;
 488       __ lea(rsi, Address(rbp, in_bytes(VM_Version::zmm_save_offset())));
 489       __ evmovdqul(Address(rsi, 0), xmm0, Assembler::AVX_512bit);
 490       __ evmovdqul(Address(rsi, 64), xmm7, Assembler::AVX_512bit);
 491 #ifdef _LP64
 492       __ evmovdqul(Address(rsi, 128), xmm8, Assembler::AVX_512bit);
 493       __ evmovdqul(Address(rsi, 192), xmm31, Assembler::AVX_512bit);
 494 #endif
 495 
 496 #ifdef _WINDOWS
 497 #ifdef _LP64
 498       __ evmovdqul(xmm31, Address(rsp, 0), Assembler::AVX_512bit);
 499       __ addptr(rsp, 64);
 500       __ evmovdqul(xmm8, Address(rsp, 0), Assembler::AVX_512bit);
 501       __ addptr(rsp, 64);
 502 #endif // _LP64
 503       __ evmovdqul(xmm7, Address(rsp, 0), Assembler::AVX_512bit);
 504       __ addptr(rsp, 64);
 505 #endif // _WINDOWS
 506       generate_vzeroupper(wrapup);
 507       VM_Version::clean_cpuFeatures();
 508       UseAVX = saved_useavx;
 509       UseSSE = saved_usesse;
 510       __ jmp(wrapup);
 511    }
 512 
 513     __ bind(legacy_save_restore);
 514     // AVX check
 515     VM_Version::set_avx_cpuFeatures(); // Enable temporary to pass asserts
 516     UseAVX = 1;
 517     UseSSE = 2;
 518     __ lea(rsi, Address(rbp, in_bytes(VM_Version::ymm_save_offset())));
 519     __ vmovdqu(Address(rsi, 0), xmm0);
 520     __ vmovdqu(Address(rsi, 32), xmm7);
 521 #ifdef _LP64
 522     __ vmovdqu(Address(rsi, 64), xmm8);
 523     __ vmovdqu(Address(rsi, 96), xmm15);
 524 #endif
 525 
 526 #ifdef _WINDOWS
 527 #ifdef _LP64
 528     __ vmovdqu(xmm15, Address(rsp, 0));
 529     __ addptr(rsp, 32);
 530     __ vmovdqu(xmm8, Address(rsp, 0));
 531     __ addptr(rsp, 32);
 532 #endif // _LP64
 533     __ vmovdqu(xmm7, Address(rsp, 0));
 534     __ addptr(rsp, 32);
 535 #endif // _WINDOWS
 536     generate_vzeroupper(wrapup);
 537     VM_Version::clean_cpuFeatures();
 538     UseAVX = saved_useavx;
 539     UseSSE = saved_usesse;
 540 
 541     __ bind(wrapup);
 542     __ popf();
 543     __ pop(rsi);
 544     __ pop(rbx);
 545     __ pop(rbp);
 546     __ ret(0);
 547 
 548 #   undef __
 549 
 550     return start;
 551   };
 552   void generate_vzeroupper(Label&amp; L_wrapup) {
 553 #   define __ _masm-&gt;
 554     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid0_offset())));
 555     __ cmpl(Address(rsi, 4), 0x756e6547);  // &#39;uneG&#39;
 556     __ jcc(Assembler::notEqual, L_wrapup);
 557     __ movl(rcx, 0x0FFF0FF0);
 558     __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid1_offset())));
 559     __ andl(rcx, Address(rsi, 0));
 560     __ cmpl(rcx, 0x00050670);              // If it is Xeon Phi 3200/5200/7200
 561     __ jcc(Assembler::equal, L_wrapup);
 562     __ cmpl(rcx, 0x00080650);              // If it is Future Xeon Phi
 563     __ jcc(Assembler::equal, L_wrapup);
 564     __ vzeroupper();
 565 #   undef __
 566   }
 567 };
 568 
 569 void VM_Version::get_processor_features() {
 570 
 571   _cpu = 4; // 486 by default
 572   _model = 0;
 573   _stepping = 0;
 574   _features = 0;
 575   _logical_processors_per_package = 1;
 576   // i486 internal cache is both I&amp;D and has a 16-byte line size
 577   _L1_data_cache_line_size = 16;
 578 
 579   // Get raw processor info
 580 
 581   get_cpu_info_stub(&amp;_cpuid_info);
 582 
 583   assert_is_initialized();
 584   _cpu = extended_cpu_family();
 585   _model = extended_cpu_model();
 586   _stepping = cpu_stepping();
 587 
 588   if (cpu_family() &gt; 4) { // it supports CPUID
 589     _features = feature_flags();
 590     // Logical processors are only available on P4s and above,
 591     // and only if hyperthreading is available.
 592     _logical_processors_per_package = logical_processor_count();
 593     _L1_data_cache_line_size = L1_line_size();
 594   }
 595 
 596   _supports_cx8 = supports_cmpxchg8();
 597   // xchg and xadd instructions
 598   _supports_atomic_getset4 = true;
 599   _supports_atomic_getadd4 = true;
 600   LP64_ONLY(_supports_atomic_getset8 = true);
 601   LP64_ONLY(_supports_atomic_getadd8 = true);
 602 
 603 #ifdef _LP64
 604   // OS should support SSE for x64 and hardware should support at least SSE2.
 605   if (!VM_Version::supports_sse2()) {
 606     vm_exit_during_initialization(&quot;Unknown x64 processor: SSE2 not supported&quot;);
 607   }
 608   // in 64 bit the use of SSE2 is the minimum
 609   if (UseSSE &lt; 2) UseSSE = 2;
 610 #endif
 611 
 612 #ifdef AMD64
 613   // flush_icache_stub have to be generated first.
 614   // That is why Icache line size is hard coded in ICache class,
 615   // see icache_x86.hpp. It is also the reason why we can&#39;t use
 616   // clflush instruction in 32-bit VM since it could be running
 617   // on CPU which does not support it.
 618   //
 619   // The only thing we can do is to verify that flushed
 620   // ICache::line_size has correct value.
 621   guarantee(_cpuid_info.std_cpuid1_edx.bits.clflush != 0, &quot;clflush is not supported&quot;);
 622   // clflush_size is size in quadwords (8 bytes).
 623   guarantee(_cpuid_info.std_cpuid1_ebx.bits.clflush_size == 8, &quot;such clflush size is not supported&quot;);
 624 #endif
 625 
 626 #ifdef _LP64
 627   // assigning this field effectively enables Unsafe.writebackMemory()
 628   // by initing UnsafeConstant.DATA_CACHE_LINE_FLUSH_SIZE to non-zero
 629   // that is only implemented on x86_64 and only if the OS plays ball
 630   if (os::supports_map_sync()) {
 631     // publish data cache line flush size to generic field, otherwise
 632     // let if default to zero thereby disabling writeback
 633     _data_cache_line_flush_size = _cpuid_info.std_cpuid1_ebx.bits.clflush_size * 8;
 634   }
 635 #endif
 636   // If the OS doesn&#39;t support SSE, we can&#39;t use this feature even if the HW does
 637   if (!os::supports_sse())
 638     _features &amp;= ~(CPU_SSE|CPU_SSE2|CPU_SSE3|CPU_SSSE3|CPU_SSE4A|CPU_SSE4_1|CPU_SSE4_2);
 639 
 640   if (UseSSE &lt; 4) {
 641     _features &amp;= ~CPU_SSE4_1;
 642     _features &amp;= ~CPU_SSE4_2;
 643   }
 644 
 645   if (UseSSE &lt; 3) {
 646     _features &amp;= ~CPU_SSE3;
 647     _features &amp;= ~CPU_SSSE3;
 648     _features &amp;= ~CPU_SSE4A;
 649   }
 650 
 651   if (UseSSE &lt; 2)
 652     _features &amp;= ~CPU_SSE2;
 653 
 654   if (UseSSE &lt; 1)
 655     _features &amp;= ~CPU_SSE;
 656 
 657   //since AVX instructions is slower than SSE in some ZX cpus, force USEAVX=0.
 658   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7))) {
 659     UseAVX = 0;
 660   }
 661 
 662   // first try initial setting and detect what we can support
 663   int use_avx_limit = 0;
 664   if (UseAVX &gt; 0) {
 665     if (UseAVX &gt; 2 &amp;&amp; supports_evex()) {
 666       use_avx_limit = 3;
 667     } else if (UseAVX &gt; 1 &amp;&amp; supports_avx2()) {
 668       use_avx_limit = 2;
 669     } else if (UseAVX &gt; 0 &amp;&amp; supports_avx()) {
 670       use_avx_limit = 1;
 671     } else {
 672       use_avx_limit = 0;
 673     }
 674   }
 675   if (FLAG_IS_DEFAULT(UseAVX)) {
 676     // Don&#39;t use AVX-512 on older Skylakes unless explicitly requested.
 677     if (use_avx_limit &gt; 2 &amp;&amp; is_intel_skylake() &amp;&amp; _stepping &lt; 5) {
 678       FLAG_SET_DEFAULT(UseAVX, 2);
 679     } else {
 680       FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 681     }
 682   }
 683   if (UseAVX &gt; use_avx_limit) {
 684     warning(&quot;UseAVX=%d is not supported on this CPU, setting it to UseAVX=%d&quot;, (int) UseAVX, use_avx_limit);
 685     FLAG_SET_DEFAULT(UseAVX, use_avx_limit);
 686   } else if (UseAVX &lt; 0) {
 687     warning(&quot;UseAVX=%d is not valid, setting it to UseAVX=0&quot;, (int) UseAVX);
 688     FLAG_SET_DEFAULT(UseAVX, 0);
 689   }
 690 
 691   if (UseAVX &lt; 3) {
 692     _features &amp;= ~CPU_AVX512F;
 693     _features &amp;= ~CPU_AVX512DQ;
 694     _features &amp;= ~CPU_AVX512CD;
 695     _features &amp;= ~CPU_AVX512BW;
 696     _features &amp;= ~CPU_AVX512VL;
 697     _features &amp;= ~CPU_AVX512_VPOPCNTDQ;
 698     _features &amp;= ~CPU_AVX512_VPCLMULQDQ;
 699     _features &amp;= ~CPU_VAES;
 700     _features &amp;= ~CPU_VNNI;
 701     _features &amp;= ~CPU_VBMI2;
 702   }
 703 
 704   if (UseAVX &lt; 2)
 705     _features &amp;= ~CPU_AVX2;
 706 
 707   if (UseAVX &lt; 1) {
 708     _features &amp;= ~CPU_AVX;
 709     _features &amp;= ~CPU_VZEROUPPER;
 710   }
 711 
 712   if (logical_processors_per_package() == 1) {
 713     // HT processor could be installed on a system which doesn&#39;t support HT.
 714     _features &amp;= ~CPU_HT;
 715   }
 716 
 717   if (is_intel()) { // Intel cpus specific settings
 718     if (is_knights_family()) {
 719       _features &amp;= ~CPU_VZEROUPPER;
 720     }
 721   }
 722 
 723   char buf[256];
 724   jio_snprintf(buf, sizeof(buf), &quot;(%u cores per cpu, %u threads per core) family %d model %d stepping %d%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;,
 725                cores_per_cpu(), threads_per_core(),
 726                cpu_family(), _model, _stepping,
 727                (supports_cmov() ? &quot;, cmov&quot; : &quot;&quot;),
 728                (supports_cmpxchg8() ? &quot;, cx8&quot; : &quot;&quot;),
 729                (supports_fxsr() ? &quot;, fxsr&quot; : &quot;&quot;),
 730                (supports_mmx()  ? &quot;, mmx&quot;  : &quot;&quot;),
 731                (supports_sse()  ? &quot;, sse&quot;  : &quot;&quot;),
 732                (supports_sse2() ? &quot;, sse2&quot; : &quot;&quot;),
 733                (supports_sse3() ? &quot;, sse3&quot; : &quot;&quot;),
 734                (supports_ssse3()? &quot;, ssse3&quot;: &quot;&quot;),
 735                (supports_sse4_1() ? &quot;, sse4.1&quot; : &quot;&quot;),
 736                (supports_sse4_2() ? &quot;, sse4.2&quot; : &quot;&quot;),
 737                (supports_popcnt() ? &quot;, popcnt&quot; : &quot;&quot;),
 738                (supports_avx()    ? &quot;, avx&quot; : &quot;&quot;),
 739                (supports_avx2()   ? &quot;, avx2&quot; : &quot;&quot;),
 740                (supports_aes()    ? &quot;, aes&quot; : &quot;&quot;),
 741                (supports_clmul()  ? &quot;, clmul&quot; : &quot;&quot;),
 742                (supports_erms()   ? &quot;, erms&quot; : &quot;&quot;),
 743                (supports_rtm()    ? &quot;, rtm&quot; : &quot;&quot;),
 744                (supports_mmx_ext() ? &quot;, mmxext&quot; : &quot;&quot;),
 745                (supports_3dnow_prefetch() ? &quot;, 3dnowpref&quot; : &quot;&quot;),
 746                (supports_lzcnt()   ? &quot;, lzcnt&quot;: &quot;&quot;),
 747                (supports_sse4a()   ? &quot;, sse4a&quot;: &quot;&quot;),
 748                (supports_ht() ? &quot;, ht&quot;: &quot;&quot;),
 749                (supports_tsc() ? &quot;, tsc&quot;: &quot;&quot;),
 750                (supports_tscinv_bit() ? &quot;, tscinvbit&quot;: &quot;&quot;),
 751                (supports_tscinv() ? &quot;, tscinv&quot;: &quot;&quot;),
 752                (supports_bmi1() ? &quot;, bmi1&quot; : &quot;&quot;),
 753                (supports_bmi2() ? &quot;, bmi2&quot; : &quot;&quot;),
 754                (supports_adx() ? &quot;, adx&quot; : &quot;&quot;),
 755                (supports_evex() ? &quot;, evex&quot; : &quot;&quot;),
 756                (supports_sha() ? &quot;, sha&quot; : &quot;&quot;),
 757                (supports_fma() ? &quot;, fma&quot; : &quot;&quot;),
 758                (supports_vbmi2() ? &quot;, vbmi2&quot; : &quot;&quot;),
 759                (supports_vaes() ? &quot;, vaes&quot; : &quot;&quot;),
 760                (supports_vnni() ? &quot;, vnni&quot; : &quot;&quot;));
 761   _features_string = os::strdup(buf);
 762 
 763   // UseSSE is set to the smaller of what hardware supports and what
 764   // the command line requires.  I.e., you cannot set UseSSE to 2 on
 765   // older Pentiums which do not support it.
 766   int use_sse_limit = 0;
 767   if (UseSSE &gt; 0) {
 768     if (UseSSE &gt; 3 &amp;&amp; supports_sse4_1()) {
 769       use_sse_limit = 4;
 770     } else if (UseSSE &gt; 2 &amp;&amp; supports_sse3()) {
 771       use_sse_limit = 3;
 772     } else if (UseSSE &gt; 1 &amp;&amp; supports_sse2()) {
 773       use_sse_limit = 2;
 774     } else if (UseSSE &gt; 0 &amp;&amp; supports_sse()) {
 775       use_sse_limit = 1;
 776     } else {
 777       use_sse_limit = 0;
 778     }
 779   }
 780   if (FLAG_IS_DEFAULT(UseSSE)) {
 781     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 782   } else if (UseSSE &gt; use_sse_limit) {
 783     warning(&quot;UseSSE=%d is not supported on this CPU, setting it to UseSSE=%d&quot;, (int) UseSSE, use_sse_limit);
 784     FLAG_SET_DEFAULT(UseSSE, use_sse_limit);
 785   } else if (UseSSE &lt; 0) {
 786     warning(&quot;UseSSE=%d is not valid, setting it to UseSSE=0&quot;, (int) UseSSE);
 787     FLAG_SET_DEFAULT(UseSSE, 0);
 788   }
 789 
 790   // Use AES instructions if available.
 791   if (supports_aes()) {
 792     if (FLAG_IS_DEFAULT(UseAES)) {
 793       FLAG_SET_DEFAULT(UseAES, true);
 794     }
 795     if (!UseAES) {
 796       if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 797         warning(&quot;AES intrinsics require UseAES flag to be enabled. Intrinsics will be disabled.&quot;);
 798       }
 799       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 800     } else {
 801       if (UseSSE &gt; 2) {
 802         if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 803           FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 804         }
 805       } else {
 806         // The AES intrinsic stubs require AES instruction support (of course)
 807         // but also require sse3 mode or higher for instructions it use.
 808         if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 809           warning(&quot;X86 AES intrinsics require SSE3 instructions or higher. Intrinsics will be disabled.&quot;);
 810         }
 811         FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 812       }
 813 
 814       // --AES-CTR begins--
 815       if (!UseAESIntrinsics) {
 816         if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 817           warning(&quot;AES-CTR intrinsics require UseAESIntrinsics flag to be enabled. Intrinsics will be disabled.&quot;);
 818           FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 819         }
 820       } else {
 821         if (supports_sse4_1()) {
 822           if (FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 823             FLAG_SET_DEFAULT(UseAESCTRIntrinsics, true);
 824           }
 825         } else {
 826            // The AES-CTR intrinsic stubs require AES instruction support (of course)
 827            // but also require sse4.1 mode or higher for instructions it use.
 828           if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 829              warning(&quot;X86 AES-CTR intrinsics require SSE4.1 instructions or higher. Intrinsics will be disabled.&quot;);
 830            }
 831            FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 832         }
 833       }
 834       // --AES-CTR ends--
 835     }
 836   } else if (UseAES || UseAESIntrinsics || UseAESCTRIntrinsics) {
 837     if (UseAES &amp;&amp; !FLAG_IS_DEFAULT(UseAES)) {
 838       warning(&quot;AES instructions are not available on this CPU&quot;);
 839       FLAG_SET_DEFAULT(UseAES, false);
 840     }
 841     if (UseAESIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 842       warning(&quot;AES intrinsics are not available on this CPU&quot;);
 843       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 844     }
 845     if (UseAESCTRIntrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESCTRIntrinsics)) {
 846       warning(&quot;AES-CTR intrinsics are not available on this CPU&quot;);
 847       FLAG_SET_DEFAULT(UseAESCTRIntrinsics, false);
 848     }
 849   }
 850 
 851   // Use CLMUL instructions if available.
 852   if (supports_clmul()) {
 853     if (FLAG_IS_DEFAULT(UseCLMUL)) {
 854       UseCLMUL = true;
 855     }
 856   } else if (UseCLMUL) {
 857     if (!FLAG_IS_DEFAULT(UseCLMUL))
 858       warning(&quot;CLMUL instructions not available on this CPU (AVX may also be required)&quot;);
 859     FLAG_SET_DEFAULT(UseCLMUL, false);
 860   }
 861 
 862   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 863     if (FLAG_IS_DEFAULT(UseCRC32Intrinsics)) {
 864       UseCRC32Intrinsics = true;
 865     }
 866   } else if (UseCRC32Intrinsics) {
 867     if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics))
 868       warning(&quot;CRC32 Intrinsics requires CLMUL instructions (not available on this CPU)&quot;);
 869     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
 870   }
 871 
 872   if (supports_sse4_2() &amp;&amp; supports_clmul()) {
 873     if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 874       UseCRC32CIntrinsics = true;
 875     }
 876   } else if (UseCRC32CIntrinsics) {
 877     if (!FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 878       warning(&quot;CRC32C intrinsics are not available on this CPU&quot;);
 879     }
 880     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 881   }
 882 
 883   // GHASH/GCM intrinsics
 884   if (UseCLMUL &amp;&amp; (UseSSE &gt; 2)) {
 885     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
 886       UseGHASHIntrinsics = true;
 887     }
 888   } else if (UseGHASHIntrinsics) {
 889     if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics))
 890       warning(&quot;GHASH intrinsic requires CLMUL and SSE2 instructions on this CPU&quot;);
 891     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 892   }
 893 
 894   // Base64 Intrinsics (Check the condition for which the intrinsic will be active)
 895   if ((UseAVX &gt; 2) &amp;&amp; supports_avx512vl() &amp;&amp; supports_avx512bw()) {
 896     if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {
 897       UseBASE64Intrinsics = true;
 898     }
 899   } else if (UseBASE64Intrinsics) {
 900      if (!FLAG_IS_DEFAULT(UseBASE64Intrinsics))
 901       warning(&quot;Base64 intrinsic requires EVEX instructions on this CPU&quot;);
 902     FLAG_SET_DEFAULT(UseBASE64Intrinsics, false);
 903   }
 904 
 905   if (supports_fma() &amp;&amp; UseSSE &gt;= 2) { // Check UseSSE since FMA code uses SSE instructions
 906     if (FLAG_IS_DEFAULT(UseFMA)) {
 907       UseFMA = true;
 908     }
 909   } else if (UseFMA) {
 910     warning(&quot;FMA instructions are not available on this CPU&quot;);
 911     FLAG_SET_DEFAULT(UseFMA, false);
 912   }
 913 
 914   if (supports_sha() LP64_ONLY(|| supports_avx2() &amp;&amp; supports_bmi2())) {
 915     if (FLAG_IS_DEFAULT(UseSHA)) {
 916       UseSHA = true;
 917     }
 918   } else if (UseSHA) {
 919     warning(&quot;SHA instructions are not available on this CPU&quot;);
 920     FLAG_SET_DEFAULT(UseSHA, false);
 921   }
 922 
 923   if (supports_sha() &amp;&amp; supports_sse4_1() &amp;&amp; UseSHA) {
 924     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 925       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 926     }
 927   } else if (UseSHA1Intrinsics) {
 928     warning(&quot;Intrinsics for SHA-1 crypto hash functions not available on this CPU.&quot;);
 929     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 930   }
 931 
 932   if (supports_sse4_1() &amp;&amp; UseSHA) {
 933     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 934       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 935     }
 936   } else if (UseSHA256Intrinsics) {
 937     warning(&quot;Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.&quot;);
 938     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 939   }
 940 
 941 #ifdef _LP64
 942   // These are only supported on 64-bit
 943   if (UseSHA &amp;&amp; supports_avx2() &amp;&amp; supports_bmi2()) {
 944     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 945       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 946     }
 947   } else
 948 #endif
 949   if (UseSHA512Intrinsics) {
 950     warning(&quot;Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.&quot;);
 951     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 952   }
 953 
 954   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 955     FLAG_SET_DEFAULT(UseSHA, false);
 956   }
 957 
 958   if (UseAdler32Intrinsics) {
 959     warning(&quot;Adler32Intrinsics not available on this CPU.&quot;);
 960     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 961   }
 962 
 963   if (!supports_rtm() &amp;&amp; UseRTMLocking) {
 964     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 965     // setting during arguments processing. See use_biased_locking().
 966     // VM_Version_init() is executed after UseBiasedLocking is used
 967     // in Thread::allocate().
 968     vm_exit_during_initialization(&quot;RTM instructions are not available on this CPU&quot;);
 969   }
 970 
 971 #if INCLUDE_RTM_OPT
 972   if (UseRTMLocking) {
 973     if (is_client_compilation_mode_vm()) {
 974       // Only C2 does RTM locking optimization.
 975       // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
 976       // setting during arguments processing. See use_biased_locking().
 977       vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
 978     }
 979     if (is_intel_family_core()) {
 980       if ((_model == CPU_MODEL_HASWELL_E3) ||
 981           (_model == CPU_MODEL_HASWELL_E7 &amp;&amp; _stepping &lt; 3) ||
 982           (_model == CPU_MODEL_BROADWELL  &amp;&amp; _stepping &lt; 4)) {
 983         // currently a collision between SKL and HSW_E3
 984         if (!UnlockExperimentalVMOptions &amp;&amp; UseAVX &lt; 3) {
 985           vm_exit_during_initialization(&quot;UseRTMLocking is only available as experimental option on this &quot;
 986                                         &quot;platform. It must be enabled via -XX:+UnlockExperimentalVMOptions flag.&quot;);
 987         } else {
 988           warning(&quot;UseRTMLocking is only available as experimental option on this platform.&quot;);
 989         }
 990       }
 991     }
 992     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 993       // RTM locking should be used only for applications with
 994       // high lock contention. For now we do not use it by default.
 995       vm_exit_during_initialization(&quot;UseRTMLocking flag should be only set on command line&quot;);
 996     }
 997   } else { // !UseRTMLocking
 998     if (UseRTMForStackLocks) {
 999       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
1000         warning(&quot;UseRTMForStackLocks flag should be off when UseRTMLocking flag is off&quot;);
1001       }
1002       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
1003     }
1004     if (UseRTMDeopt) {
1005       FLAG_SET_DEFAULT(UseRTMDeopt, false);
1006     }
1007     if (PrintPreciseRTMLockingStatistics) {
1008       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
1009     }
1010   }
1011 #else
1012   if (UseRTMLocking) {
1013     // Only C2 does RTM locking optimization.
1014     // Can&#39;t continue because UseRTMLocking affects UseBiasedLocking flag
1015     // setting during arguments processing. See use_biased_locking().
1016     vm_exit_during_initialization(&quot;RTM locking optimization is not supported in this VM&quot;);
1017   }
1018 #endif
1019 
1020 #ifdef COMPILER2
1021   if (UseFPUForSpilling) {
1022     if (UseSSE &lt; 2) {
1023       // Only supported with SSE2+
1024       FLAG_SET_DEFAULT(UseFPUForSpilling, false);
1025     }
1026   }
1027 #endif
1028 
1029 #if COMPILER2_OR_JVMCI
1030   int max_vector_size = 0;
1031   if (UseSSE &lt; 2) {
1032     // Vectors (in XMM) are only supported with SSE2+
1033     // SSE is always 2 on x64.
1034     max_vector_size = 0;
1035   } else if (UseAVX == 0 || !os_supports_avx_vectors()) {
1036     // 16 byte vectors (in XMM) are supported with SSE2+
1037     max_vector_size = 16;
1038   } else if (UseAVX == 1 || UseAVX == 2) {
1039     // 32 bytes vectors (in YMM) are only supported with AVX+
1040     max_vector_size = 32;
1041   } else if (UseAVX &gt; 2) {
1042     // 64 bytes vectors (in ZMM) are only supported with AVX 3
1043     max_vector_size = 64;
1044   }
1045 
1046 #ifdef _LP64
1047   int min_vector_size = 4; // We require MaxVectorSize to be at least 4 on 64bit
1048 #else
1049   int min_vector_size = 0;
1050 #endif
1051 
1052   if (!FLAG_IS_DEFAULT(MaxVectorSize)) {
1053     if (MaxVectorSize &lt; min_vector_size) {
1054       warning(&quot;MaxVectorSize must be at least %i on this platform&quot;, min_vector_size);
1055       FLAG_SET_DEFAULT(MaxVectorSize, min_vector_size);
1056     }
1057     if (MaxVectorSize &gt; max_vector_size) {
1058       warning(&quot;MaxVectorSize must be at most %i on this platform&quot;, max_vector_size);
1059       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1060     }
1061     if (!is_power_of_2(MaxVectorSize)) {
1062       warning(&quot;MaxVectorSize must be a power of 2, setting to default: %i&quot;, max_vector_size);
1063       FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1064     }
1065   } else {
1066     // If default, use highest supported configuration
1067     FLAG_SET_DEFAULT(MaxVectorSize, max_vector_size);
1068   }
1069 
1070 #if defined(COMPILER2) &amp;&amp; defined(ASSERT)
1071   if (MaxVectorSize &gt; 0) {
1072     if (supports_avx() &amp;&amp; PrintMiscellaneous &amp;&amp; Verbose &amp;&amp; TraceNewVectors) {
1073       tty-&gt;print_cr(&quot;State of YMM registers after signal handle:&quot;);
1074       int nreg = 2 LP64_ONLY(+2);
1075       const char* ymm_name[4] = {&quot;0&quot;, &quot;7&quot;, &quot;8&quot;, &quot;15&quot;};
1076       for (int i = 0; i &lt; nreg; i++) {
1077         tty-&gt;print(&quot;YMM%s:&quot;, ymm_name[i]);
1078         for (int j = 7; j &gt;=0; j--) {
1079           tty-&gt;print(&quot; %x&quot;, _cpuid_info.ymm_save[i*8 + j]);
1080         }
1081         tty-&gt;cr();
1082       }
1083     }
1084   }
1085 #endif // COMPILER2 &amp;&amp; ASSERT
1086 
1087   if (!FLAG_IS_DEFAULT(AVX3Threshold)) {
1088     if (!is_power_of_2(AVX3Threshold)) {
1089       warning(&quot;AVX3Threshold must be a power of 2&quot;);
1090       FLAG_SET_DEFAULT(AVX3Threshold, 4096);
1091     }
1092   }
1093 
1094 #ifdef _LP64
1095   if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1096     UseMultiplyToLenIntrinsic = true;
1097   }
1098   if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1099     UseSquareToLenIntrinsic = true;
1100   }
1101   if (FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1102     UseMulAddIntrinsic = true;
1103   }
1104   if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1105     UseMontgomeryMultiplyIntrinsic = true;
1106   }
1107   if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1108     UseMontgomerySquareIntrinsic = true;
1109   }
1110 #else
1111   if (UseMultiplyToLenIntrinsic) {
1112     if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {
1113       warning(&quot;multiplyToLen intrinsic is not available in 32-bit VM&quot;);
1114     }
1115     FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);
1116   }
1117   if (UseMontgomeryMultiplyIntrinsic) {
1118     if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {
1119       warning(&quot;montgomeryMultiply intrinsic is not available in 32-bit VM&quot;);
1120     }
1121     FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);
1122   }
1123   if (UseMontgomerySquareIntrinsic) {
1124     if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {
1125       warning(&quot;montgomerySquare intrinsic is not available in 32-bit VM&quot;);
1126     }
1127     FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);
1128   }
1129   if (UseSquareToLenIntrinsic) {
1130     if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {
1131       warning(&quot;squareToLen intrinsic is not available in 32-bit VM&quot;);
1132     }
1133     FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);
1134   }
1135   if (UseMulAddIntrinsic) {
1136     if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {
1137       warning(&quot;mulAdd intrinsic is not available in 32-bit VM&quot;);
1138     }
1139     FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);
1140   }
1141 #endif // _LP64
1142 #endif // COMPILER2_OR_JVMCI
1143 
1144   // On new cpus instructions which update whole XMM register should be used
1145   // to prevent partial register stall due to dependencies on high half.
1146   //
1147   // UseXmmLoadAndClearUpper == true  --&gt; movsd(xmm, mem)
1148   // UseXmmLoadAndClearUpper == false --&gt; movlpd(xmm, mem)
1149   // UseXmmRegToRegMoveAll == true  --&gt; movaps(xmm, xmm), movapd(xmm, xmm).
1150   // UseXmmRegToRegMoveAll == false --&gt; movss(xmm, xmm),  movsd(xmm, xmm).
1151 
1152 
1153   if (is_zx()) { // ZX cpus specific settings
1154     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1155       UseStoreImmI16 = false; // don&#39;t use it on ZX cpus
1156     }
1157     if ((cpu_family() == 6) || (cpu_family() == 7)) {
1158       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1159         // Use it on all ZX cpus
1160         UseAddressNop = true;
1161       }
1162     }
1163     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1164       UseXmmLoadAndClearUpper = true; // use movsd on all ZX cpus
1165     }
1166     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1167       if (supports_sse3()) {
1168         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new ZX cpus
1169       } else {
1170         UseXmmRegToRegMoveAll = false;
1171       }
1172     }
1173     if (((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse3()) { // new ZX cpus
1174 #ifdef COMPILER2
1175       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1176         // For new ZX cpus do the next optimization:
1177         // don&#39;t align the beginning of a loop if there are enough instructions
1178         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1179         // in current fetch line (OptoLoopAlignment) or the padding
1180         // is big (&gt; MaxLoopPad).
1181         // Set MaxLoopPad to 11 for new ZX cpus to reduce number of
1182         // generated NOP instructions. 11 is the largest size of one
1183         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1184         MaxLoopPad = 11;
1185       }
1186 #endif // COMPILER2
1187       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1188         UseXMMForArrayCopy = true; // use SSE2 movq on new ZX cpus
1189       }
1190       if (supports_sse4_2()) { // new ZX cpus
1191         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1192           UseUnalignedLoadStores = true; // use movdqu on newest ZX cpus
1193         }
1194       }
1195       if (supports_sse4_2()) {
1196         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1197           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1198         }
1199       } else {
1200         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1201           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1202         }
1203         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1204       }
1205     }
1206 
1207     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1208       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1209     }
1210   }
1211 
1212   if (is_amd_family()) { // AMD cpus specific settings
1213     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseAddressNop)) {
1214       // Use it on new AMD cpus starting from Opteron.
1215       UseAddressNop = true;
1216     }
1217     if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseNewLongLShift)) {
1218       // Use it on new AMD cpus starting from Opteron.
1219       UseNewLongLShift = true;
1220     }
1221     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1222       if (supports_sse4a()) {
1223         UseXmmLoadAndClearUpper = true; // use movsd only on &#39;10h&#39; Opteron
1224       } else {
1225         UseXmmLoadAndClearUpper = false;
1226       }
1227     }
1228     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1229       if (supports_sse4a()) {
1230         UseXmmRegToRegMoveAll = true; // use movaps, movapd only on &#39;10h&#39;
1231       } else {
1232         UseXmmRegToRegMoveAll = false;
1233       }
1234     }
1235     if (FLAG_IS_DEFAULT(UseXmmI2F)) {
1236       if (supports_sse4a()) {
1237         UseXmmI2F = true;
1238       } else {
1239         UseXmmI2F = false;
1240       }
1241     }
1242     if (FLAG_IS_DEFAULT(UseXmmI2D)) {
1243       if (supports_sse4a()) {
1244         UseXmmI2D = true;
1245       } else {
1246         UseXmmI2D = false;
1247       }
1248     }
1249     if (supports_sse4_2()) {
1250       if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1251         FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1252       }
1253     } else {
1254       if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1255         warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1256       }
1257       FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1258     }
1259 
1260     // some defaults for AMD family 15h
1261     if (cpu_family() == 0x15) {
1262       // On family 15h processors default is no sw prefetch
1263       if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1264         FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1265       }
1266       // Also, if some other prefetch style is specified, default instruction type is PREFETCHW
1267       if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1268         FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1269       }
1270       // On family 15h processors use XMM and UnalignedLoadStores for Array Copy
1271       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1272         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1273       }
1274       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1275         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1276       }
1277     }
1278 
1279 #ifdef COMPILER2
1280     if (cpu_family() &lt; 0x17 &amp;&amp; MaxVectorSize &gt; 16) {
1281       // Limit vectors size to 16 bytes on AMD cpus &lt; 17h.
1282       FLAG_SET_DEFAULT(MaxVectorSize, 16);
1283     }
1284 #endif // COMPILER2
1285 
1286     // Some defaults for AMD family 17h || Hygon family 18h
1287     if (cpu_family() == 0x17 || cpu_family() == 0x18) {
1288       // On family 17h processors use XMM and UnalignedLoadStores for Array Copy
1289       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1290         FLAG_SET_DEFAULT(UseXMMForArrayCopy, true);
1291       }
1292       if (supports_sse2() &amp;&amp; FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1293         FLAG_SET_DEFAULT(UseUnalignedLoadStores, true);
1294       }
1295 #ifdef COMPILER2
1296       if (supports_sse4_2() &amp;&amp; FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1297         FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1298       }
1299 #endif
1300     }
1301   }
1302 
1303   if (is_intel()) { // Intel cpus specific settings
1304     if (FLAG_IS_DEFAULT(UseStoreImmI16)) {
1305       UseStoreImmI16 = false; // don&#39;t use it on Intel cpus
1306     }
1307     if (cpu_family() == 6 || cpu_family() == 15) {
1308       if (FLAG_IS_DEFAULT(UseAddressNop)) {
1309         // Use it on all Intel cpus starting from PentiumPro
1310         UseAddressNop = true;
1311       }
1312     }
1313     if (FLAG_IS_DEFAULT(UseXmmLoadAndClearUpper)) {
1314       UseXmmLoadAndClearUpper = true; // use movsd on all Intel cpus
1315     }
1316     if (FLAG_IS_DEFAULT(UseXmmRegToRegMoveAll)) {
1317       if (supports_sse3()) {
1318         UseXmmRegToRegMoveAll = true; // use movaps, movapd on new Intel cpus
1319       } else {
1320         UseXmmRegToRegMoveAll = false;
1321       }
1322     }
1323     if (cpu_family() == 6 &amp;&amp; supports_sse3()) { // New Intel cpus
1324 #ifdef COMPILER2
1325       if (FLAG_IS_DEFAULT(MaxLoopPad)) {
1326         // For new Intel cpus do the next optimization:
1327         // don&#39;t align the beginning of a loop if there are enough instructions
1328         // left (NumberOfLoopInstrToAlign defined in c2_globals.hpp)
1329         // in current fetch line (OptoLoopAlignment) or the padding
1330         // is big (&gt; MaxLoopPad).
1331         // Set MaxLoopPad to 11 for new Intel cpus to reduce number of
1332         // generated NOP instructions. 11 is the largest size of one
1333         // address NOP instruction &#39;0F 1F&#39; (see Assembler::nop(i)).
1334         MaxLoopPad = 11;
1335       }
1336 #endif // COMPILER2
1337       if (FLAG_IS_DEFAULT(UseXMMForArrayCopy)) {
1338         UseXMMForArrayCopy = true; // use SSE2 movq on new Intel cpus
1339       }
1340       if ((supports_sse4_2() &amp;&amp; supports_ht()) || supports_avx()) { // Newest Intel cpus
1341         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1342           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1343         }
1344       }
1345       if (supports_sse4_2()) {
1346         if (FLAG_IS_DEFAULT(UseSSE42Intrinsics)) {
1347           FLAG_SET_DEFAULT(UseSSE42Intrinsics, true);
1348         }
1349       } else {
1350         if (UseSSE42Intrinsics &amp;&amp; !FLAG_IS_DEFAULT(UseAESIntrinsics)) {
1351           warning(&quot;SSE4.2 intrinsics require SSE4.2 instructions or higher. Intrinsics will be disabled.&quot;);
1352         }
1353         FLAG_SET_DEFAULT(UseSSE42Intrinsics, false);
1354       }
1355     }
1356     if (is_atom_family() || is_knights_family()) {
1357 #ifdef COMPILER2
1358       if (FLAG_IS_DEFAULT(OptoScheduling)) {
1359         OptoScheduling = true;
1360       }
1361 #endif
1362       if (supports_sse4_2()) { // Silvermont
1363         if (FLAG_IS_DEFAULT(UseUnalignedLoadStores)) {
1364           UseUnalignedLoadStores = true; // use movdqu on newest Intel cpus
1365         }
1366       }
1367       if (FLAG_IS_DEFAULT(UseIncDec)) {
1368         FLAG_SET_DEFAULT(UseIncDec, false);
1369       }
1370     }
1371     if (FLAG_IS_DEFAULT(AllocatePrefetchInstr) &amp;&amp; supports_3dnow_prefetch()) {
1372       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1373     }
1374   }
1375 
1376 #ifdef _LP64
1377   if (UseSSE42Intrinsics) {
1378     if (FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1379       UseVectorizedMismatchIntrinsic = true;
1380     }
1381   } else if (UseVectorizedMismatchIntrinsic) {
1382     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic))
1383       warning(&quot;vectorizedMismatch intrinsics are not available on this CPU&quot;);
1384     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1385   }
1386 #else
1387   if (UseVectorizedMismatchIntrinsic) {
1388     if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {
1389       warning(&quot;vectorizedMismatch intrinsic is not available in 32-bit VM&quot;);
1390     }
1391     FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);
1392   }
1393 #endif // _LP64
1394 
1395   // Use count leading zeros count instruction if available.
1396   if (supports_lzcnt()) {
1397     if (FLAG_IS_DEFAULT(UseCountLeadingZerosInstruction)) {
1398       UseCountLeadingZerosInstruction = true;
1399     }
1400    } else if (UseCountLeadingZerosInstruction) {
1401     warning(&quot;lzcnt instruction is not available on this CPU&quot;);
1402     FLAG_SET_DEFAULT(UseCountLeadingZerosInstruction, false);
1403   }
1404 
1405   // Use count trailing zeros instruction if available
1406   if (supports_bmi1()) {
1407     // tzcnt does not require VEX prefix
1408     if (FLAG_IS_DEFAULT(UseCountTrailingZerosInstruction)) {
1409       if (!UseBMI1Instructions &amp;&amp; !FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1410         // Don&#39;t use tzcnt if BMI1 is switched off on command line.
1411         UseCountTrailingZerosInstruction = false;
1412       } else {
1413         UseCountTrailingZerosInstruction = true;
1414       }
1415     }
1416   } else if (UseCountTrailingZerosInstruction) {
1417     warning(&quot;tzcnt instruction is not available on this CPU&quot;);
1418     FLAG_SET_DEFAULT(UseCountTrailingZerosInstruction, false);
1419   }
1420 
1421   // BMI instructions (except tzcnt) use an encoding with VEX prefix.
1422   // VEX prefix is generated only when AVX &gt; 0.
1423   if (supports_bmi1() &amp;&amp; supports_avx()) {
1424     if (FLAG_IS_DEFAULT(UseBMI1Instructions)) {
1425       UseBMI1Instructions = true;
1426     }
1427   } else if (UseBMI1Instructions) {
1428     warning(&quot;BMI1 instructions are not available on this CPU (AVX is also required)&quot;);
1429     FLAG_SET_DEFAULT(UseBMI1Instructions, false);
1430   }
1431 
1432   if (supports_bmi2() &amp;&amp; supports_avx()) {
1433     if (FLAG_IS_DEFAULT(UseBMI2Instructions)) {
1434       UseBMI2Instructions = true;
1435     }
1436   } else if (UseBMI2Instructions) {
1437     warning(&quot;BMI2 instructions are not available on this CPU (AVX is also required)&quot;);
1438     FLAG_SET_DEFAULT(UseBMI2Instructions, false);
1439   }
1440 
1441   // Use population count instruction if available.
1442   if (supports_popcnt()) {
1443     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
1444       UsePopCountInstruction = true;
1445     }
1446   } else if (UsePopCountInstruction) {
1447     warning(&quot;POPCNT instruction is not available on this CPU&quot;);
1448     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
1449   }
1450 
1451   // Use fast-string operations if available.
1452   if (supports_erms()) {
1453     if (FLAG_IS_DEFAULT(UseFastStosb)) {
1454       UseFastStosb = true;
1455     }
1456   } else if (UseFastStosb) {
1457     warning(&quot;fast-string operations are not available on this CPU&quot;);
1458     FLAG_SET_DEFAULT(UseFastStosb, false);
1459   }
1460 
1461   // Use XMM/YMM MOVDQU instruction for Object Initialization
1462   if (!UseFastStosb &amp;&amp; UseSSE &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
1463     if (FLAG_IS_DEFAULT(UseXMMForObjInit)) {
1464       UseXMMForObjInit = true;
1465     }
1466   } else if (UseXMMForObjInit) {
1467     warning(&quot;UseXMMForObjInit requires SSE2 and unaligned load/stores. Feature is switched off.&quot;);
1468     FLAG_SET_DEFAULT(UseXMMForObjInit, false);
1469   }
1470 
1471 #ifdef COMPILER2
1472   if (FLAG_IS_DEFAULT(AlignVector)) {
1473     // Modern processors allow misaligned memory operations for vectors.
1474     AlignVector = !UseUnalignedLoadStores;
1475   }
1476 #endif // COMPILER2
1477 
1478   if (FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
1479     if (AllocatePrefetchInstr == 3 &amp;&amp; !supports_3dnow_prefetch()) {
1480       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 0);
1481     } else if (!supports_sse() &amp;&amp; supports_3dnow_prefetch()) {
1482       FLAG_SET_DEFAULT(AllocatePrefetchInstr, 3);
1483     }
1484   }
1485 
1486   // Allocation prefetch settings
1487   intx cache_line_size = prefetch_data_size();
1488   if (FLAG_IS_DEFAULT(AllocatePrefetchStepSize) &amp;&amp;
1489       (cache_line_size &gt; AllocatePrefetchStepSize)) {
1490     FLAG_SET_DEFAULT(AllocatePrefetchStepSize, cache_line_size);
1491   }
1492 
1493   if ((AllocatePrefetchDistance == 0) &amp;&amp; (AllocatePrefetchStyle != 0)) {
1494     assert(!FLAG_IS_DEFAULT(AllocatePrefetchDistance), &quot;default value should not be 0&quot;);
1495     if (!FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
1496       warning(&quot;AllocatePrefetchDistance is set to 0 which disable prefetching. Ignoring AllocatePrefetchStyle flag.&quot;);
1497     }
1498     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 0);
1499   }
1500 
1501   if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
1502     bool use_watermark_prefetch = (AllocatePrefetchStyle == 2);
1503     FLAG_SET_DEFAULT(AllocatePrefetchDistance, allocate_prefetch_distance(use_watermark_prefetch));
1504   }
1505 
1506   if (is_intel() &amp;&amp; cpu_family() == 6 &amp;&amp; supports_sse3()) {
1507     if (FLAG_IS_DEFAULT(AllocatePrefetchLines) &amp;&amp;
1508         supports_sse4_2() &amp;&amp; supports_ht()) { // Nehalem based cpus
1509       FLAG_SET_DEFAULT(AllocatePrefetchLines, 4);
1510     }
1511 #ifdef COMPILER2
1512     if (FLAG_IS_DEFAULT(UseFPUForSpilling) &amp;&amp; supports_sse4_2()) {
1513       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1514     }
1515 #endif
1516   }
1517 
1518   if (is_zx() &amp;&amp; ((cpu_family() == 6) || (cpu_family() == 7)) &amp;&amp; supports_sse4_2()) {
1519 #ifdef COMPILER2
1520     if (FLAG_IS_DEFAULT(UseFPUForSpilling)) {
1521       FLAG_SET_DEFAULT(UseFPUForSpilling, true);
1522     }
1523 #endif
1524   }
1525 
1526 #ifdef _LP64
1527   // Prefetch settings
1528 
1529   // Prefetch interval for gc copy/scan == 9 dcache lines.  Derived from
1530   // 50-warehouse specjbb runs on a 2-way 1.8ghz opteron using a 4gb heap.
1531   // Tested intervals from 128 to 2048 in increments of 64 == one cache line.
1532   // 256 bytes (4 dcache lines) was the nearest runner-up to 576.
1533 
1534   // gc copy/scan is disabled if prefetchw isn&#39;t supported, because
1535   // Prefetch::write emits an inlined prefetchw on Linux.
1536   // Do not use the 3dnow prefetchw instruction.  It isn&#39;t supported on em64t.
1537   // The used prefetcht0 instruction works for both amd64 and em64t.
1538 
1539   if (FLAG_IS_DEFAULT(PrefetchCopyIntervalInBytes)) {
1540     FLAG_SET_DEFAULT(PrefetchCopyIntervalInBytes, 576);
1541   }
1542   if (FLAG_IS_DEFAULT(PrefetchScanIntervalInBytes)) {
1543     FLAG_SET_DEFAULT(PrefetchScanIntervalInBytes, 576);
1544   }
1545   if (FLAG_IS_DEFAULT(PrefetchFieldsAhead)) {
1546     FLAG_SET_DEFAULT(PrefetchFieldsAhead, 1);
1547   }
1548 #endif
1549 
1550   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
1551      (cache_line_size &gt; ContendedPaddingWidth))
1552      ContendedPaddingWidth = cache_line_size;
1553 
1554   // This machine allows unaligned memory accesses
1555   if (FLAG_IS_DEFAULT(UseUnalignedAccesses)) {
1556     FLAG_SET_DEFAULT(UseUnalignedAccesses, true);
1557   }
1558 
1559 #ifndef PRODUCT
1560   if (log_is_enabled(Info, os, cpu)) {
1561     LogStream ls(Log(os, cpu)::info());
1562     outputStream* log = &amp;ls;
1563     log-&gt;print_cr(&quot;Logical CPUs per core: %u&quot;,
1564                   logical_processors_per_package());
1565     log-&gt;print_cr(&quot;L1 data cache line size: %u&quot;, L1_data_cache_line_size());
1566     log-&gt;print(&quot;UseSSE=%d&quot;, (int) UseSSE);
1567     if (UseAVX &gt; 0) {
1568       log-&gt;print(&quot;  UseAVX=%d&quot;, (int) UseAVX);
1569     }
1570     if (UseAES) {
1571       log-&gt;print(&quot;  UseAES=1&quot;);
1572     }
1573 #ifdef COMPILER2
1574     if (MaxVectorSize &gt; 0) {
1575       log-&gt;print(&quot;  MaxVectorSize=%d&quot;, (int) MaxVectorSize);
1576     }
1577 #endif
1578     log-&gt;cr();
1579     log-&gt;print(&quot;Allocation&quot;);
1580     if (AllocatePrefetchStyle &lt;= 0 || (UseSSE == 0 &amp;&amp; !supports_3dnow_prefetch())) {
1581       log-&gt;print_cr(&quot;: no prefetching&quot;);
1582     } else {
1583       log-&gt;print(&quot; prefetching: &quot;);
1584       if (UseSSE == 0 &amp;&amp; supports_3dnow_prefetch()) {
1585         log-&gt;print(&quot;PREFETCHW&quot;);
1586       } else if (UseSSE &gt;= 1) {
1587         if (AllocatePrefetchInstr == 0) {
1588           log-&gt;print(&quot;PREFETCHNTA&quot;);
1589         } else if (AllocatePrefetchInstr == 1) {
1590           log-&gt;print(&quot;PREFETCHT0&quot;);
1591         } else if (AllocatePrefetchInstr == 2) {
1592           log-&gt;print(&quot;PREFETCHT2&quot;);
1593         } else if (AllocatePrefetchInstr == 3) {
1594           log-&gt;print(&quot;PREFETCHW&quot;);
1595         }
1596       }
1597       if (AllocatePrefetchLines &gt; 1) {
1598         log-&gt;print_cr(&quot; at distance %d, %d lines of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);
1599       } else {
1600         log-&gt;print_cr(&quot; at distance %d, one line of %d bytes&quot;, (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);
1601       }
1602     }
1603 
1604     if (PrefetchCopyIntervalInBytes &gt; 0) {
1605       log-&gt;print_cr(&quot;PrefetchCopyIntervalInBytes %d&quot;, (int) PrefetchCopyIntervalInBytes);
1606     }
1607     if (PrefetchScanIntervalInBytes &gt; 0) {
1608       log-&gt;print_cr(&quot;PrefetchScanIntervalInBytes %d&quot;, (int) PrefetchScanIntervalInBytes);
1609     }
1610     if (PrefetchFieldsAhead &gt; 0) {
1611       log-&gt;print_cr(&quot;PrefetchFieldsAhead %d&quot;, (int) PrefetchFieldsAhead);
1612     }
1613     if (ContendedPaddingWidth &gt; 0) {
1614       log-&gt;print_cr(&quot;ContendedPaddingWidth %d&quot;, (int) ContendedPaddingWidth);
1615     }
1616   }
1617 #endif // !PRODUCT
1618 }
1619 
1620 void VM_Version::print_platform_virtualization_info(outputStream* st) {
1621   VirtualizationType vrt = VM_Version::get_detected_virtualization();
1622   if (vrt == XenHVM) {
1623     st-&gt;print_cr(&quot;Xen hardware-assisted virtualization detected&quot;);
1624   } else if (vrt == KVM) {
1625     st-&gt;print_cr(&quot;KVM virtualization detected&quot;);
1626   } else if (vrt == VMWare) {
1627     st-&gt;print_cr(&quot;VMWare virtualization detected&quot;);
1628     VirtualizationSupport::print_virtualization_info(st);
1629   } else if (vrt == HyperV) {
1630     st-&gt;print_cr(&quot;HyperV virtualization detected&quot;);
1631   }
1632 }
1633 
1634 void VM_Version::check_virt_cpuid(uint32_t idx, uint32_t *regs) {
1635 // TODO support 32 bit
1636 #if defined(_LP64)
1637 #if defined(_MSC_VER)
1638   // Allocate space for the code
1639   const int code_size = 100;
1640   ResourceMark rm;
1641   CodeBuffer cb(&quot;detect_virt&quot;, code_size, 0);
1642   MacroAssembler* a = new MacroAssembler(&amp;cb);
1643   address code = a-&gt;pc();
1644   void (*test)(uint32_t idx, uint32_t *regs) = (void(*)(uint32_t idx, uint32_t *regs))code;
1645 
1646   a-&gt;movq(r9, rbx); // save nonvolatile register
1647 
1648   // next line would not work on 32-bit
1649   a-&gt;movq(rax, c_rarg0 /* rcx */);
1650   a-&gt;movq(r8, c_rarg1 /* rdx */);
1651   a-&gt;cpuid();
1652   a-&gt;movl(Address(r8,  0), rax);
1653   a-&gt;movl(Address(r8,  4), rbx);
1654   a-&gt;movl(Address(r8,  8), rcx);
1655   a-&gt;movl(Address(r8, 12), rdx);
1656 
1657   a-&gt;movq(rbx, r9); // restore nonvolatile register
1658   a-&gt;ret(0);
1659 
1660   uint32_t *code_end = (uint32_t *)a-&gt;pc();
1661   a-&gt;flush();
1662 
1663   // execute code
1664   (*test)(idx, regs);
1665 #elif defined(__GNUC__)
1666   __asm__ volatile (
1667      &quot;        cpuid;&quot;
1668      &quot;        mov %%eax,(%1);&quot;
1669      &quot;        mov %%ebx,4(%1);&quot;
1670      &quot;        mov %%ecx,8(%1);&quot;
1671      &quot;        mov %%edx,12(%1);&quot;
1672      : &quot;+a&quot; (idx)
1673      : &quot;S&quot; (regs)
1674      : &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;memory&quot; );
1675 #endif
1676 #endif
1677 }
1678 
1679 
1680 bool VM_Version::use_biased_locking() {
1681 #if INCLUDE_RTM_OPT
1682   // RTM locking is most useful when there is high lock contention and
1683   // low data contention.  With high lock contention the lock is usually
1684   // inflated and biased locking is not suitable for that case.
1685   // RTM locking code requires that biased locking is off.
1686   // Note: we can&#39;t switch off UseBiasedLocking in get_processor_features()
1687   // because it is used by Thread::allocate() which is called before
1688   // VM_Version::initialize().
1689   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
1690     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
1691       FLAG_SET_DEFAULT(UseBiasedLocking, false);
1692     } else {
1693       warning(&quot;Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag.&quot; );
1694       UseBiasedLocking = false;
1695     }
1696   }
1697 #endif
1698   return UseBiasedLocking;
1699 }
1700 
1701 // On Xen, the cpuid instruction returns
1702 //  eax / registers[0]: Version of Xen
1703 //  ebx / registers[1]: chars &#39;XenV&#39;
1704 //  ecx / registers[2]: chars &#39;MMXe&#39;
1705 //  edx / registers[3]: chars &#39;nVMM&#39;
1706 //
1707 // On KVM / VMWare / MS Hyper-V, the cpuid instruction returns
1708 //  ebx / registers[1]: chars &#39;KVMK&#39; / &#39;VMwa&#39; / &#39;Micr&#39;
1709 //  ecx / registers[2]: chars &#39;VMKV&#39; / &#39;reVM&#39; / &#39;osof&#39;
1710 //  edx / registers[3]: chars &#39;M&#39;    / &#39;ware&#39; / &#39;t Hv&#39;
1711 //
1712 // more information :
1713 // https://kb.vmware.com/s/article/1009458
1714 //
1715 void VM_Version::check_virtualizations() {
1716 #if defined(_LP64)
1717   uint32_t registers[4];
1718   char signature[13];
1719   uint32_t base;
1720   signature[12] = &#39;\0&#39;;
1721   memset((void*)registers, 0, 4*sizeof(uint32_t));
1722 
1723   for (base = 0x40000000; base &lt; 0x40010000; base += 0x100) {
1724     check_virt_cpuid(base, registers);
1725 
1726     *(uint32_t *)(signature + 0) = registers[1];
1727     *(uint32_t *)(signature + 4) = registers[2];
1728     *(uint32_t *)(signature + 8) = registers[3];
1729 
1730     if (strncmp(&quot;VMwareVMware&quot;, signature, 12) == 0) {
1731       Abstract_VM_Version::_detected_virtualization = VMWare;
1732       // check for extended metrics from guestlib
1733       VirtualizationSupport::initialize();
1734     }
1735 
1736     if (strncmp(&quot;Microsoft Hv&quot;, signature, 12) == 0) {
1737       Abstract_VM_Version::_detected_virtualization = HyperV;
1738     }
1739 
1740     if (strncmp(&quot;KVMKVMKVM&quot;, signature, 9) == 0) {
1741       Abstract_VM_Version::_detected_virtualization = KVM;
1742     }
1743 
1744     if (strncmp(&quot;XenVMMXenVMM&quot;, signature, 12) == 0) {
1745       Abstract_VM_Version::_detected_virtualization = XenHVM;
1746     }
1747   }
1748 #endif
1749 }
1750 
1751 void VM_Version::initialize() {
1752   ResourceMark rm;
1753   // Making this stub must be FIRST use of assembler
1754 
1755   stub_blob = BufferBlob::create(&quot;get_cpu_info_stub&quot;, stub_size);
1756   if (stub_blob == NULL) {
1757     vm_exit_during_initialization(&quot;Unable to allocate get_cpu_info_stub&quot;);
1758   }
1759   CodeBuffer c(stub_blob);
1760   VM_Version_StubGenerator g(&amp;c);
1761   get_cpu_info_stub = CAST_TO_FN_PTR(get_cpu_info_stub_t,
1762                                      g.generate_get_cpu_info());
1763 
1764   get_processor_features();
1765   if (cpu_family() &gt; 4) { // it supports CPUID
1766     check_virtualizations();
1767   }
1768 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
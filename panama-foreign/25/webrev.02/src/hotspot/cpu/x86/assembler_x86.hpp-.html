<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_ASSEMBLER_X86_HPP
  26 #define CPU_X86_ASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/register.hpp&quot;
  29 #include &quot;runtime/vm_version.hpp&quot;
  30 
  31 class BiasedLockingCounters;
  32 
  33 // Contains all the definitions needed for x86 assembly code generation.
  34 
  35 // Calling convention
  36 class Argument {
  37  public:
  38   enum {
  39 #ifdef _LP64
  40 #ifdef _WIN64
  41     n_int_register_parameters_c   = 4, // rcx, rdx, r8, r9 (c_rarg0, c_rarg1, ...)
  42     n_float_register_parameters_c = 4,  // xmm0 - xmm3 (c_farg0, c_farg1, ... )
  43     n_int_register_returns_c = 1, // rax
  44     n_float_register_returns_c = 1, // xmm0
  45 #else
  46     n_int_register_parameters_c   = 6, // rdi, rsi, rdx, rcx, r8, r9 (c_rarg0, c_rarg1, ...)
  47     n_float_register_parameters_c = 8,  // xmm0 - xmm7 (c_farg0, c_farg1, ... )
  48     n_int_register_returns_c = 2, // rax, rdx
  49     n_float_register_returns_c = 2, // xmm0, xmm1
  50 #endif // _WIN64
  51     n_int_register_parameters_j   = 6, // j_rarg0, j_rarg1, ...
  52     n_float_register_parameters_j = 8  // j_farg0, j_farg1, ...
  53 #else
  54     n_register_parameters = 0   // 0 registers used to pass arguments
  55 #endif // _LP64
  56   };
  57 };
  58 
  59 
  60 #ifdef _LP64
  61 // Symbolically name the register arguments used by the c calling convention.
  62 // Windows is different from linux/solaris. So much for standards...
  63 
  64 #ifdef _WIN64
  65 
  66 REGISTER_DECLARATION(Register, c_rarg0, rcx);
  67 REGISTER_DECLARATION(Register, c_rarg1, rdx);
  68 REGISTER_DECLARATION(Register, c_rarg2, r8);
  69 REGISTER_DECLARATION(Register, c_rarg3, r9);
  70 
  71 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  72 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  73 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  74 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  75 
  76 #else
  77 
  78 REGISTER_DECLARATION(Register, c_rarg0, rdi);
  79 REGISTER_DECLARATION(Register, c_rarg1, rsi);
  80 REGISTER_DECLARATION(Register, c_rarg2, rdx);
  81 REGISTER_DECLARATION(Register, c_rarg3, rcx);
  82 REGISTER_DECLARATION(Register, c_rarg4, r8);
  83 REGISTER_DECLARATION(Register, c_rarg5, r9);
  84 
  85 REGISTER_DECLARATION(XMMRegister, c_farg0, xmm0);
  86 REGISTER_DECLARATION(XMMRegister, c_farg1, xmm1);
  87 REGISTER_DECLARATION(XMMRegister, c_farg2, xmm2);
  88 REGISTER_DECLARATION(XMMRegister, c_farg3, xmm3);
  89 REGISTER_DECLARATION(XMMRegister, c_farg4, xmm4);
  90 REGISTER_DECLARATION(XMMRegister, c_farg5, xmm5);
  91 REGISTER_DECLARATION(XMMRegister, c_farg6, xmm6);
  92 REGISTER_DECLARATION(XMMRegister, c_farg7, xmm7);
  93 
  94 #endif // _WIN64
  95 
  96 // Symbolically name the register arguments used by the Java calling convention.
  97 // We have control over the convention for java so we can do what we please.
  98 // What pleases us is to offset the java calling convention so that when
  99 // we call a suitable jni method the arguments are lined up and we don&#39;t
 100 // have to do little shuffling. A suitable jni method is non-static and a
 101 // small number of arguments (two fewer args on windows)
 102 //
 103 //        |-------------------------------------------------------|
 104 //        | c_rarg0   c_rarg1  c_rarg2 c_rarg3 c_rarg4 c_rarg5    |
 105 //        |-------------------------------------------------------|
 106 //        | rcx       rdx      r8      r9      rdi*    rsi*       | windows (* not a c_rarg)
 107 //        | rdi       rsi      rdx     rcx     r8      r9         | solaris/linux
 108 //        |-------------------------------------------------------|
 109 //        | j_rarg5   j_rarg0  j_rarg1 j_rarg2 j_rarg3 j_rarg4    |
 110 //        |-------------------------------------------------------|
 111 
 112 REGISTER_DECLARATION(Register, j_rarg0, c_rarg1);
 113 REGISTER_DECLARATION(Register, j_rarg1, c_rarg2);
 114 REGISTER_DECLARATION(Register, j_rarg2, c_rarg3);
 115 // Windows runs out of register args here
 116 #ifdef _WIN64
 117 REGISTER_DECLARATION(Register, j_rarg3, rdi);
 118 REGISTER_DECLARATION(Register, j_rarg4, rsi);
 119 #else
 120 REGISTER_DECLARATION(Register, j_rarg3, c_rarg4);
 121 REGISTER_DECLARATION(Register, j_rarg4, c_rarg5);
 122 #endif /* _WIN64 */
 123 REGISTER_DECLARATION(Register, j_rarg5, c_rarg0);
 124 
 125 REGISTER_DECLARATION(XMMRegister, j_farg0, xmm0);
 126 REGISTER_DECLARATION(XMMRegister, j_farg1, xmm1);
 127 REGISTER_DECLARATION(XMMRegister, j_farg2, xmm2);
 128 REGISTER_DECLARATION(XMMRegister, j_farg3, xmm3);
 129 REGISTER_DECLARATION(XMMRegister, j_farg4, xmm4);
 130 REGISTER_DECLARATION(XMMRegister, j_farg5, xmm5);
 131 REGISTER_DECLARATION(XMMRegister, j_farg6, xmm6);
 132 REGISTER_DECLARATION(XMMRegister, j_farg7, xmm7);
 133 
 134 REGISTER_DECLARATION(Register, rscratch1, r10);  // volatile
 135 REGISTER_DECLARATION(Register, rscratch2, r11);  // volatile
 136 
 137 REGISTER_DECLARATION(Register, r12_heapbase, r12); // callee-saved
 138 REGISTER_DECLARATION(Register, r15_thread, r15); // callee-saved
 139 
 140 #else
 141 // rscratch1 will apear in 32bit code that is dead but of course must compile
 142 // Using noreg ensures if the dead code is incorrectly live and executed it
 143 // will cause an assertion failure
 144 #define rscratch1 noreg
 145 #define rscratch2 noreg
 146 
 147 #endif // _LP64
 148 
 149 // JSR 292
 150 // On x86, the SP does not have to be saved when invoking method handle intrinsics
 151 // or compiled lambda forms. We indicate that by setting rbp_mh_SP_save to noreg.
 152 REGISTER_DECLARATION(Register, rbp_mh_SP_save, noreg);
 153 
 154 // Address is an abstraction used to represent a memory location
 155 // using any of the amd64 addressing modes with one object.
 156 //
 157 // Note: A register location is represented via a Register, not
 158 //       via an address for efficiency &amp; simplicity reasons.
 159 
 160 class ArrayAddress;
 161 
 162 class Address {
 163  public:
 164   enum ScaleFactor {
 165     no_scale = -1,
 166     times_1  =  0,
 167     times_2  =  1,
 168     times_4  =  2,
 169     times_8  =  3,
 170     times_ptr = LP64_ONLY(times_8) NOT_LP64(times_4)
 171   };
 172   static ScaleFactor times(int size) {
 173     assert(size &gt;= 1 &amp;&amp; size &lt;= 8 &amp;&amp; is_power_of_2(size), &quot;bad scale size&quot;);
 174     if (size == 8)  return times_8;
 175     if (size == 4)  return times_4;
 176     if (size == 2)  return times_2;
 177     return times_1;
 178   }
 179   static int scale_size(ScaleFactor scale) {
 180     assert(scale != no_scale, &quot;&quot;);
 181     assert(((1 &lt;&lt; (int)times_1) == 1 &amp;&amp;
 182             (1 &lt;&lt; (int)times_2) == 2 &amp;&amp;
 183             (1 &lt;&lt; (int)times_4) == 4 &amp;&amp;
 184             (1 &lt;&lt; (int)times_8) == 8), &quot;&quot;);
 185     return (1 &lt;&lt; (int)scale);
 186   }
 187 
 188  private:
 189   Register         _base;
 190   Register         _index;
 191   XMMRegister      _xmmindex;
 192   ScaleFactor      _scale;
 193   int              _disp;
 194   bool             _isxmmindex;
 195   RelocationHolder _rspec;
 196 
 197   // Easily misused constructors make them private
 198   // %%% can we make these go away?
 199   NOT_LP64(Address(address loc, RelocationHolder spec);)
 200   Address(int disp, address loc, relocInfo::relocType rtype);
 201   Address(int disp, address loc, RelocationHolder spec);
 202 
 203  public:
 204 
 205  int disp() { return _disp; }
 206   // creation
 207   Address()
 208     : _base(noreg),
 209       _index(noreg),
 210       _xmmindex(xnoreg),
 211       _scale(no_scale),
 212       _disp(0),
 213       _isxmmindex(false){
 214   }
 215 
 216   // No default displacement otherwise Register can be implicitly
 217   // converted to 0(Register) which is quite a different animal.
 218 
 219   Address(Register base, int disp)
 220     : _base(base),
 221       _index(noreg),
 222       _xmmindex(xnoreg),
 223       _scale(no_scale),
 224       _disp(disp),
 225       _isxmmindex(false){
 226   }
 227 
 228   Address(Register base, Register index, ScaleFactor scale, int disp = 0)
 229     : _base (base),
 230       _index(index),
 231       _xmmindex(xnoreg),
 232       _scale(scale),
 233       _disp (disp),
 234       _isxmmindex(false) {
 235     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 236            &quot;inconsistent address&quot;);
 237   }
 238 
 239   Address(Register base, RegisterOrConstant index, ScaleFactor scale = times_1, int disp = 0)
 240     : _base (base),
 241       _index(index.register_or_noreg()),
 242       _xmmindex(xnoreg),
 243       _scale(scale),
 244       _disp (disp + (index.constant_or_zero() * scale_size(scale))),
 245       _isxmmindex(false){
 246     if (!index.is_register())  scale = Address::no_scale;
 247     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 248            &quot;inconsistent address&quot;);
 249   }
 250 
 251   Address(Register base, XMMRegister index, ScaleFactor scale, int disp = 0)
 252     : _base (base),
 253       _index(noreg),
 254       _xmmindex(index),
 255       _scale(scale),
 256       _disp(disp),
 257       _isxmmindex(true) {
 258       assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 259              &quot;inconsistent address&quot;);
 260   }
 261 
 262   Address plus_disp(int disp) const {
 263     Address a = (*this);
 264     a._disp += disp;
 265     return a;
 266   }
 267   Address plus_disp(RegisterOrConstant disp, ScaleFactor scale = times_1) const {
 268     Address a = (*this);
 269     a._disp += disp.constant_or_zero() * scale_size(scale);
 270     if (disp.is_register()) {
 271       assert(!a.index()-&gt;is_valid(), &quot;competing indexes&quot;);
 272       a._index = disp.as_register();
 273       a._scale = scale;
 274     }
 275     return a;
 276   }
 277   bool is_same_address(Address a) const {
 278     // disregard _rspec
 279     return _base == a._base &amp;&amp; _disp == a._disp &amp;&amp; _index == a._index &amp;&amp; _scale == a._scale;
 280   }
 281 
 282   // The following two overloads are used in connection with the
 283   // ByteSize type (see sizes.hpp).  They simplify the use of
 284   // ByteSize&#39;d arguments in assembly code. Note that their equivalent
 285   // for the optimized build are the member functions with int disp
 286   // argument since ByteSize is mapped to an int type in that case.
 287   //
 288   // Note: DO NOT introduce similar overloaded functions for WordSize
 289   // arguments as in the optimized mode, both ByteSize and WordSize
 290   // are mapped to the same type and thus the compiler cannot make a
 291   // distinction anymore (=&gt; compiler errors).
 292 
 293 #ifdef ASSERT
 294   Address(Register base, ByteSize disp)
 295     : _base(base),
 296       _index(noreg),
 297       _xmmindex(xnoreg),
 298       _scale(no_scale),
 299       _disp(in_bytes(disp)),
 300       _isxmmindex(false){
 301   }
 302 
 303   Address(Register base, Register index, ScaleFactor scale, ByteSize disp)
 304     : _base(base),
 305       _index(index),
 306       _xmmindex(xnoreg),
 307       _scale(scale),
 308       _disp(in_bytes(disp)),
 309       _isxmmindex(false){
 310     assert(!index-&gt;is_valid() == (scale == Address::no_scale),
 311            &quot;inconsistent address&quot;);
 312   }
 313   Address(Register base, RegisterOrConstant index, ScaleFactor scale, ByteSize disp)
 314     : _base (base),
 315       _index(index.register_or_noreg()),
 316       _xmmindex(xnoreg),
 317       _scale(scale),
 318       _disp (in_bytes(disp) + (index.constant_or_zero() * scale_size(scale))),
 319       _isxmmindex(false) {
 320     if (!index.is_register())  scale = Address::no_scale;
 321     assert(!_index-&gt;is_valid() == (scale == Address::no_scale),
 322            &quot;inconsistent address&quot;);
 323   }
 324 
 325 #endif // ASSERT
 326 
 327   // accessors
 328   bool        uses(Register reg) const { return _base == reg || _index == reg; }
 329   Register    base()             const { return _base;  }
 330   Register    index()            const { return _index; }
 331   XMMRegister xmmindex()         const { return _xmmindex; }
 332   ScaleFactor scale()            const { return _scale; }
 333   int         disp()             const { return _disp;  }
 334   bool        isxmmindex()       const { return _isxmmindex; }
 335 
 336   // Convert the raw encoding form into the form expected by the constructor for
 337   // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 338   // that to noreg for the Address constructor.
 339   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 340 
 341   static Address make_array(ArrayAddress);
 342 
 343  private:
 344   bool base_needs_rex() const {
 345     return _base != noreg &amp;&amp; _base-&gt;encoding() &gt;= 8;
 346   }
 347 
 348   bool index_needs_rex() const {
 349     return _index != noreg &amp;&amp;_index-&gt;encoding() &gt;= 8;
 350   }
 351 
 352   bool xmmindex_needs_rex() const {
 353     return _xmmindex != xnoreg &amp;&amp; _xmmindex-&gt;encoding() &gt;= 8;
 354   }
 355 
 356   relocInfo::relocType reloc() const { return _rspec.type(); }
 357 
 358   friend class Assembler;
 359   friend class MacroAssembler;
 360   friend class LIR_Assembler; // base/index/scale/disp
 361 };
 362 
 363 //
 364 // AddressLiteral has been split out from Address because operands of this type
 365 // need to be treated specially on 32bit vs. 64bit platforms. By splitting it out
 366 // the few instructions that need to deal with address literals are unique and the
 367 // MacroAssembler does not have to implement every instruction in the Assembler
 368 // in order to search for address literals that may need special handling depending
 369 // on the instruction and the platform. As small step on the way to merging i486/amd64
 370 // directories.
 371 //
 372 class AddressLiteral {
 373   friend class ArrayAddress;
 374   RelocationHolder _rspec;
 375   // Typically we use AddressLiterals we want to use their rval
 376   // However in some situations we want the lval (effect address) of the item.
 377   // We provide a special factory for making those lvals.
 378   bool _is_lval;
 379 
 380   // If the target is far we&#39;ll need to load the ea of this to
 381   // a register to reach it. Otherwise if near we can do rip
 382   // relative addressing.
 383 
 384   address          _target;
 385 
 386  protected:
 387   // creation
 388   AddressLiteral()
 389     : _is_lval(false),
 390       _target(NULL)
 391   {}
 392 
 393   public:
 394 
 395 
 396   AddressLiteral(address target, relocInfo::relocType rtype);
 397 
 398   AddressLiteral(address target, RelocationHolder const&amp; rspec)
 399     : _rspec(rspec),
 400       _is_lval(false),
 401       _target(target)
 402   {}
 403 
 404   AddressLiteral addr() {
 405     AddressLiteral ret = *this;
 406     ret._is_lval = true;
 407     return ret;
 408   }
 409 
 410 
 411  private:
 412 
 413   address target() { return _target; }
 414   bool is_lval() { return _is_lval; }
 415 
 416   relocInfo::relocType reloc() const { return _rspec.type(); }
 417   const RelocationHolder&amp; rspec() const { return _rspec; }
 418 
 419   friend class Assembler;
 420   friend class MacroAssembler;
 421   friend class Address;
 422   friend class LIR_Assembler;
 423 };
 424 
 425 // Convience classes
 426 class RuntimeAddress: public AddressLiteral {
 427 
 428   public:
 429 
 430   RuntimeAddress(address target) : AddressLiteral(target, relocInfo::runtime_call_type) {}
 431 
 432 };
 433 
 434 class ExternalAddress: public AddressLiteral {
 435  private:
 436   static relocInfo::relocType reloc_for_target(address target) {
 437     // Sometimes ExternalAddress is used for values which aren&#39;t
 438     // exactly addresses, like the card table base.
 439     // external_word_type can&#39;t be used for values in the first page
 440     // so just skip the reloc in that case.
 441     return external_word_Relocation::can_be_relocated(target) ? relocInfo::external_word_type : relocInfo::none;
 442   }
 443 
 444  public:
 445 
 446   ExternalAddress(address target) : AddressLiteral(target, reloc_for_target(target)) {}
 447 
 448 };
 449 
 450 class InternalAddress: public AddressLiteral {
 451 
 452   public:
 453 
 454   InternalAddress(address target) : AddressLiteral(target, relocInfo::internal_word_type) {}
 455 
 456 };
 457 
 458 // x86 can do array addressing as a single operation since disp can be an absolute
 459 // address amd64 can&#39;t. We create a class that expresses the concept but does extra
 460 // magic on amd64 to get the final result
 461 
 462 class ArrayAddress {
 463   private:
 464 
 465   AddressLiteral _base;
 466   Address        _index;
 467 
 468   public:
 469 
 470   ArrayAddress() {};
 471   ArrayAddress(AddressLiteral base, Address index): _base(base), _index(index) {};
 472   AddressLiteral base() { return _base; }
 473   Address index() { return _index; }
 474 
 475 };
 476 
 477 class InstructionAttr;
 478 
 479 // 64-bit refect the fxsave size which is 512 bytes and the new xsave area on EVEX which is another 2176 bytes
 480 // See fxsave and xsave(EVEX enabled) documentation for layout
 481 const int FPUStateSizeInWords = NOT_LP64(27) LP64_ONLY(2688 / wordSize);
 482 
 483 // The Intel x86/Amd64 Assembler: Pure assembler doing NO optimizations on the instruction
 484 // level (e.g. mov rax, 0 is not translated into xor rax, rax!); i.e., what you write
 485 // is what you get. The Assembler is generating code into a CodeBuffer.
 486 
 487 class Assembler : public AbstractAssembler  {
 488   friend class AbstractAssembler; // for the non-virtual hack
 489   friend class LIR_Assembler; // as_Address()
 490   friend class StubGenerator;
 491 
 492  public:
 493   enum Condition {                     // The x86 condition codes used for conditional jumps/moves.
 494     zero          = 0x4,
 495     notZero       = 0x5,
 496     equal         = 0x4,
 497     notEqual      = 0x5,
 498     less          = 0xc,
 499     lessEqual     = 0xe,
 500     greater       = 0xf,
 501     greaterEqual  = 0xd,
 502     below         = 0x2,
 503     belowEqual    = 0x6,
 504     above         = 0x7,
 505     aboveEqual    = 0x3,
 506     overflow      = 0x0,
 507     noOverflow    = 0x1,
 508     carrySet      = 0x2,
 509     carryClear    = 0x3,
 510     negative      = 0x8,
 511     positive      = 0x9,
 512     parity        = 0xa,
 513     noParity      = 0xb
 514   };
 515 
 516   enum Prefix {
 517     // segment overrides
 518     CS_segment = 0x2e,
 519     SS_segment = 0x36,
 520     DS_segment = 0x3e,
 521     ES_segment = 0x26,
 522     FS_segment = 0x64,
 523     GS_segment = 0x65,
 524 
 525     REX        = 0x40,
 526 
 527     REX_B      = 0x41,
 528     REX_X      = 0x42,
 529     REX_XB     = 0x43,
 530     REX_R      = 0x44,
 531     REX_RB     = 0x45,
 532     REX_RX     = 0x46,
 533     REX_RXB    = 0x47,
 534 
 535     REX_W      = 0x48,
 536 
 537     REX_WB     = 0x49,
 538     REX_WX     = 0x4A,
 539     REX_WXB    = 0x4B,
 540     REX_WR     = 0x4C,
 541     REX_WRB    = 0x4D,
 542     REX_WRX    = 0x4E,
 543     REX_WRXB   = 0x4F,
 544 
 545     VEX_3bytes = 0xC4,
 546     VEX_2bytes = 0xC5,
 547     EVEX_4bytes = 0x62,
 548     Prefix_EMPTY = 0x0
 549   };
 550 
 551   enum VexPrefix {
 552     VEX_B = 0x20,
 553     VEX_X = 0x40,
 554     VEX_R = 0x80,
 555     VEX_W = 0x80
 556   };
 557 
 558   enum ExexPrefix {
 559     EVEX_F  = 0x04,
 560     EVEX_V  = 0x08,
 561     EVEX_Rb = 0x10,
 562     EVEX_X  = 0x40,
 563     EVEX_Z  = 0x80
 564   };
 565 
 566   enum VexSimdPrefix {
 567     VEX_SIMD_NONE = 0x0,
 568     VEX_SIMD_66   = 0x1,
 569     VEX_SIMD_F3   = 0x2,
 570     VEX_SIMD_F2   = 0x3
 571   };
 572 
 573   enum VexOpcode {
 574     VEX_OPCODE_NONE  = 0x0,
 575     VEX_OPCODE_0F    = 0x1,
 576     VEX_OPCODE_0F_38 = 0x2,
 577     VEX_OPCODE_0F_3A = 0x3,
 578     VEX_OPCODE_MASK  = 0x1F
 579   };
 580 
 581   enum AvxVectorLen {
 582     AVX_128bit = 0x0,
 583     AVX_256bit = 0x1,
 584     AVX_512bit = 0x2,
 585     AVX_NoVec  = 0x4
 586   };
 587 
 588   enum EvexTupleType {
 589     EVEX_FV   = 0,
 590     EVEX_HV   = 4,
 591     EVEX_FVM  = 6,
 592     EVEX_T1S  = 7,
 593     EVEX_T1F  = 11,
 594     EVEX_T2   = 13,
 595     EVEX_T4   = 15,
 596     EVEX_T8   = 17,
 597     EVEX_HVM  = 18,
 598     EVEX_QVM  = 19,
 599     EVEX_OVM  = 20,
 600     EVEX_M128 = 21,
 601     EVEX_DUP  = 22,
 602     EVEX_ETUP = 23
 603   };
 604 
 605   enum EvexInputSizeInBits {
 606     EVEX_8bit  = 0,
 607     EVEX_16bit = 1,
 608     EVEX_32bit = 2,
 609     EVEX_64bit = 3,
 610     EVEX_NObit = 4
 611   };
 612 
 613   enum WhichOperand {
 614     // input to locate_operand, and format code for relocations
 615     imm_operand  = 0,            // embedded 32-bit|64-bit immediate operand
 616     disp32_operand = 1,          // embedded 32-bit displacement or address
 617     call32_operand = 2,          // embedded 32-bit self-relative displacement
 618 #ifndef _LP64
 619     _WhichOperand_limit = 3
 620 #else
 621      narrow_oop_operand = 3,     // embedded 32-bit immediate narrow oop
 622     _WhichOperand_limit = 4
 623 #endif
 624   };
 625 
 626   enum ComparisonPredicate {
 627     eq = 0,
 628     lt = 1,
 629     le = 2,
 630     _false = 3,
 631     neq = 4,
 632     nlt = 5,
 633     nle = 6,
 634     _true = 7
 635   };
 636 
 637   //---&lt;  calculate length of instruction  &gt;---
 638   // As instruction size can&#39;t be found out easily on x86/x64,
 639   // we just use &#39;4&#39; for len and maxlen.
 640   // instruction must start at passed address
 641   static unsigned int instr_len(unsigned char *instr) { return 4; }
 642 
 643   //---&lt;  longest instructions  &gt;---
 644   // Max instruction length is not specified in architecture documentation.
 645   // We could use a &quot;safe enough&quot; estimate (15), but just default to
 646   // instruction length guess from above.
 647   static unsigned int instr_maxlen() { return 4; }
 648 
 649   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 650   // of instructions are freely declared without the need for wrapping them an ifdef.
 651   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 652   // In the .cpp file the implementations are wrapped so that they are dropped out
 653   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 654   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 655   //
 656   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 657   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 658 
 659 private:
 660 
 661   bool _legacy_mode_bw;
 662   bool _legacy_mode_dq;
 663   bool _legacy_mode_vl;
 664   bool _legacy_mode_vlbw;
 665   bool _is_managed;
 666   bool _vector_masking;    // For stub code use only
 667 
 668   class InstructionAttr *_attributes;
 669 
 670   // 64bit prefixes
 671   int prefix_and_encode(int reg_enc, bool byteinst = false);
 672   int prefixq_and_encode(int reg_enc);
 673 
 674   int prefix_and_encode(int dst_enc, int src_enc) {
 675     return prefix_and_encode(dst_enc, false, src_enc, false);
 676   }
 677   int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);
 678   int prefixq_and_encode(int dst_enc, int src_enc);
 679 
 680   void prefix(Register reg);
 681   void prefix(Register dst, Register src, Prefix p);
 682   void prefix(Register dst, Address adr, Prefix p);
 683   void prefix(Address adr);
 684   void prefixq(Address adr);
 685 
 686   void prefix(Address adr, Register reg,  bool byteinst = false);
 687   void prefix(Address adr, XMMRegister reg);
 688   void prefixq(Address adr, Register reg);
 689   void prefixq(Address adr, XMMRegister reg);
 690 
 691   void prefetch_prefix(Address src);
 692 
 693   void rex_prefix(Address adr, XMMRegister xreg,
 694                   VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 695   int  rex_prefix_and_encode(int dst_enc, int src_enc,
 696                              VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 697 
 698   void vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 699 
 700   void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,
 701                    int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 702 
 703   void vex_prefix(Address adr, int nds_enc, int xreg_enc,
 704                   VexSimdPrefix pre, VexOpcode opc,
 705                   InstructionAttr *attributes);
 706 
 707   int  vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc,
 708                              VexSimdPrefix pre, VexOpcode opc,
 709                              InstructionAttr *attributes);
 710 
 711   void simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
 712                    VexOpcode opc, InstructionAttr *attributes);
 713 
 714   int simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
 715                              VexOpcode opc, InstructionAttr *attributes);
 716 
 717   // Helper functions for groups of instructions
 718   void emit_arith_b(int op1, int op2, Register dst, int imm8);
 719 
 720   void emit_arith(int op1, int op2, Register dst, int32_t imm32);
 721   // Force generation of a 4 byte immediate value even if it fits into 8bit
 722   void emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32);
 723   void emit_arith(int op1, int op2, Register dst, Register src);
 724 
 725   bool emit_compressed_disp_byte(int &amp;disp);
 726 
 727   void emit_operand(Register reg,
 728                     Register base, Register index, Address::ScaleFactor scale,
 729                     int disp,
 730                     RelocationHolder const&amp; rspec,
 731                     int rip_relative_correction = 0);
 732 
 733   void emit_operand(XMMRegister reg, Register base, XMMRegister index,
 734                     Address::ScaleFactor scale,
 735                     int disp, RelocationHolder const&amp; rspec);
 736 
 737   void emit_operand(Register reg, Address adr, int rip_relative_correction = 0);
 738 
 739   // operands that only take the original 32bit registers
 740   void emit_operand32(Register reg, Address adr);
 741 
 742   void emit_operand(XMMRegister reg,
 743                     Register base, Register index, Address::ScaleFactor scale,
 744                     int disp,
 745                     RelocationHolder const&amp; rspec);
 746 
 747   void emit_operand(XMMRegister reg, Address adr);
 748 
 749   void emit_operand(MMXRegister reg, Address adr);
 750 
 751   // workaround gcc (3.2.1-7) bug
 752   void emit_operand(Address adr, MMXRegister reg);
 753 
 754 
 755   // Immediate-to-memory forms
 756   void emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32);
 757 
 758   void emit_farith(int b1, int b2, int i);
 759 
 760 
 761  protected:
 762   #ifdef ASSERT
 763   void check_relocation(RelocationHolder const&amp; rspec, int format);
 764   #endif
 765 
 766   void emit_data(jint data, relocInfo::relocType    rtype, int format);
 767   void emit_data(jint data, RelocationHolder const&amp; rspec, int format);
 768   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
 769   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
 770 
 771   bool reachable(AddressLiteral adr) NOT_LP64({ return true;});
 772 
 773   // These are all easily abused and hence protected
 774 
 775   // 32BIT ONLY SECTION
 776 #ifndef _LP64
 777   // Make these disappear in 64bit mode since they would never be correct
 778   void cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);   // 32BIT ONLY
 779   void cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 780 
 781   void mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 782   void mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);     // 32BIT ONLY
 783 
 784   void push_literal32(int32_t imm32, RelocationHolder const&amp; rspec);                 // 32BIT ONLY
 785 #else
 786   // 64BIT ONLY SECTION
 787   void mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec);   // 64BIT ONLY
 788 
 789   void cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);
 790   void cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);
 791 
 792   void mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec);
 793   void mov_narrow_oop(Address dst, int32_t imm32, RelocationHolder const&amp; rspec);
 794 #endif // _LP64
 795 
 796   // These are unique in that we are ensured by the caller that the 32bit
 797   // relative in these instructions will always be able to reach the potentially
 798   // 64bit address described by entry. Since they can take a 64bit address they
 799   // don&#39;t have the 32 suffix like the other instructions in this class.
 800 
 801   void call_literal(address entry, RelocationHolder const&amp; rspec);
 802   void jmp_literal(address entry, RelocationHolder const&amp; rspec);
 803 
 804   // Avoid using directly section
 805   // Instructions in this section are actually usable by anyone without danger
 806   // of failure but have performance issues that are addressed my enhanced
 807   // instructions which will do the proper thing base on the particular cpu.
 808   // We protect them because we don&#39;t trust you...
 809 
 810   // Don&#39;t use next inc() and dec() methods directly. INC &amp; DEC instructions
 811   // could cause a partial flag stall since they don&#39;t set CF flag.
 812   // Use MacroAssembler::decrement() &amp; MacroAssembler::increment() methods
 813   // which call inc() &amp; dec() or add() &amp; sub() in accordance with
 814   // the product flag UseIncDec value.
 815 
 816   void decl(Register dst);
 817   void decl(Address dst);
 818   void decq(Register dst);
 819   void decq(Address dst);
 820 
 821   void incl(Register dst);
 822   void incl(Address dst);
 823   void incq(Register dst);
 824   void incq(Address dst);
 825 
 826   // New cpus require use of movsd and movss to avoid partial register stall
 827   // when loading from memory. But for old Opteron use movlpd instead of movsd.
 828   // The selection is done in MacroAssembler::movdbl() and movflt().
 829 
 830   // Move Scalar Single-Precision Floating-Point Values
 831   void movss(XMMRegister dst, Address src);
 832   void movss(XMMRegister dst, XMMRegister src);
 833   void movss(Address dst, XMMRegister src);
 834 
 835   // Move Scalar Double-Precision Floating-Point Values
 836   void movsd(XMMRegister dst, Address src);
 837   void movsd(XMMRegister dst, XMMRegister src);
 838   void movsd(Address dst, XMMRegister src);
 839   void movlpd(XMMRegister dst, Address src);
 840 
 841   // New cpus require use of movaps and movapd to avoid partial register stall
 842   // when moving between registers.
 843   void movaps(XMMRegister dst, XMMRegister src);
 844   void movapd(XMMRegister dst, XMMRegister src);
 845 
 846   // End avoid using directly
 847 
 848 
 849   // Instruction prefixes
 850   void prefix(Prefix p);
 851 
 852   public:
 853 
 854   // Creation
 855   Assembler(CodeBuffer* code) : AbstractAssembler(code) {
 856     init_attributes();
 857   }
 858 
 859   // Decoding
 860   static address locate_operand(address inst, WhichOperand which);
 861   static address locate_next_instruction(address inst);
 862 
 863   // Utilities
 864   static bool is_polling_page_far() NOT_LP64({ return false;});
 865   static bool query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 866                                          int cur_tuple_type, int in_size_in_bits, int cur_encoding);
 867 
 868   // Generic instructions
 869   // Does 32bit or 64bit as needed for the platform. In some sense these
 870   // belong in macro assembler but there is no need for both varieties to exist
 871 
 872   void init_attributes(void) {
 873     _legacy_mode_bw = (VM_Version::supports_avx512bw() == false);
 874     _legacy_mode_dq = (VM_Version::supports_avx512dq() == false);
 875     _legacy_mode_vl = (VM_Version::supports_avx512vl() == false);
 876     _legacy_mode_vlbw = (VM_Version::supports_avx512vlbw() == false);
 877     _is_managed = false;
 878     _vector_masking = false;
 879     _attributes = NULL;
 880   }
 881 
 882   void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }
 883   void clear_attributes(void) { _attributes = NULL; }
 884 
 885   void set_managed(void) { _is_managed = true; }
 886   void clear_managed(void) { _is_managed = false; }
 887   bool is_managed(void) { return _is_managed; }
 888 
 889   void lea(Register dst, Address src);
 890 
 891   void mov(Register dst, Register src);
 892 
 893   void pusha();
 894   void popa();
 895 
 896   void pushf();
 897   void popf();
 898 
 899   void push(int32_t imm32);
 900 
 901   void push(Register src);
 902 
 903   void pop(Register dst);
 904 
 905   // These are dummies to prevent surprise implicit conversions to Register
 906   void push(void* v);
 907   void pop(void* v);
 908 
 909   // These do register sized moves/scans
 910   void rep_mov();
 911   void rep_stos();
 912   void rep_stosb();
 913   void repne_scan();
 914 #ifdef _LP64
 915   void repne_scanl();
 916 #endif
 917 
 918   // Vanilla instructions in lexical order
 919 
 920   void adcl(Address dst, int32_t imm32);
 921   void adcl(Address dst, Register src);
 922   void adcl(Register dst, int32_t imm32);
 923   void adcl(Register dst, Address src);
 924   void adcl(Register dst, Register src);
 925 
 926   void adcq(Register dst, int32_t imm32);
 927   void adcq(Register dst, Address src);
 928   void adcq(Register dst, Register src);
 929 
 930   void addb(Address dst, int imm8);
 931   void addw(Address dst, int imm16);
 932 
 933   void addl(Address dst, int32_t imm32);
 934   void addl(Address dst, Register src);
 935   void addl(Register dst, int32_t imm32);
 936   void addl(Register dst, Address src);
 937   void addl(Register dst, Register src);
 938 
 939   void addq(Address dst, int32_t imm32);
 940   void addq(Address dst, Register src);
 941   void addq(Register dst, int32_t imm32);
 942   void addq(Register dst, Address src);
 943   void addq(Register dst, Register src);
 944 
 945 #ifdef _LP64
 946  //Add Unsigned Integers with Carry Flag
 947   void adcxq(Register dst, Register src);
 948 
 949  //Add Unsigned Integers with Overflow Flag
 950   void adoxq(Register dst, Register src);
 951 #endif
 952 
 953   void addr_nop_4();
 954   void addr_nop_5();
 955   void addr_nop_7();
 956   void addr_nop_8();
 957 
 958   // Add Scalar Double-Precision Floating-Point Values
 959   void addsd(XMMRegister dst, Address src);
 960   void addsd(XMMRegister dst, XMMRegister src);
 961 
 962   // Add Scalar Single-Precision Floating-Point Values
 963   void addss(XMMRegister dst, Address src);
 964   void addss(XMMRegister dst, XMMRegister src);
 965 
 966   // AES instructions
 967   void aesdec(XMMRegister dst, Address src);
 968   void aesdec(XMMRegister dst, XMMRegister src);
 969   void aesdeclast(XMMRegister dst, Address src);
 970   void aesdeclast(XMMRegister dst, XMMRegister src);
 971   void aesenc(XMMRegister dst, Address src);
 972   void aesenc(XMMRegister dst, XMMRegister src);
 973   void aesenclast(XMMRegister dst, Address src);
 974   void aesenclast(XMMRegister dst, XMMRegister src);
 975   // Vector AES instructions
 976   void vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 977   void vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 978   void vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 979   void vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
 980 
 981   void andl(Address  dst, int32_t imm32);
 982   void andl(Register dst, int32_t imm32);
 983   void andl(Register dst, Address src);
 984   void andl(Register dst, Register src);
 985 
 986   void andq(Address  dst, int32_t imm32);
 987   void andq(Register dst, int32_t imm32);
 988   void andq(Register dst, Address src);
 989   void andq(Register dst, Register src);
 990 
 991   // BMI instructions
 992   void andnl(Register dst, Register src1, Register src2);
 993   void andnl(Register dst, Register src1, Address src2);
 994   void andnq(Register dst, Register src1, Register src2);
 995   void andnq(Register dst, Register src1, Address src2);
 996 
 997   void blsil(Register dst, Register src);
 998   void blsil(Register dst, Address src);
 999   void blsiq(Register dst, Register src);
1000   void blsiq(Register dst, Address src);
1001 
1002   void blsmskl(Register dst, Register src);
1003   void blsmskl(Register dst, Address src);
1004   void blsmskq(Register dst, Register src);
1005   void blsmskq(Register dst, Address src);
1006 
1007   void blsrl(Register dst, Register src);
1008   void blsrl(Register dst, Address src);
1009   void blsrq(Register dst, Register src);
1010   void blsrq(Register dst, Address src);
1011 
1012   void bsfl(Register dst, Register src);
1013   void bsrl(Register dst, Register src);
1014 
1015 #ifdef _LP64
1016   void bsfq(Register dst, Register src);
1017   void bsrq(Register dst, Register src);
1018 #endif
1019 
1020   void bswapl(Register reg);
1021 
1022   void bswapq(Register reg);
1023 
1024   void call(Label&amp; L, relocInfo::relocType rtype);
1025   void call(Register reg);  // push pc; pc &lt;- reg
1026   void call(Address adr);   // push pc; pc &lt;- adr
1027 
1028   void cdql();
1029 
1030   void cdqq();
1031 
1032   void cld();
1033 
1034   void clflush(Address adr);
1035   void clflushopt(Address adr);
1036   void clwb(Address adr);
1037 
1038   void cmovl(Condition cc, Register dst, Register src);
1039   void cmovl(Condition cc, Register dst, Address src);
1040 
1041   void cmovq(Condition cc, Register dst, Register src);
1042   void cmovq(Condition cc, Register dst, Address src);
1043 
1044 
1045   void cmpb(Address dst, int imm8);
1046 
1047   void cmpl(Address dst, int32_t imm32);
1048 
1049   void cmpl(Register dst, int32_t imm32);
1050   void cmpl(Register dst, Register src);
1051   void cmpl(Register dst, Address src);
1052 
1053   void cmpq(Address dst, int32_t imm32);
1054   void cmpq(Address dst, Register src);
1055 
1056   void cmpq(Register dst, int32_t imm32);
1057   void cmpq(Register dst, Register src);
1058   void cmpq(Register dst, Address src);
1059 
1060   // these are dummies used to catch attempting to convert NULL to Register
1061   void cmpl(Register dst, void* junk); // dummy
1062   void cmpq(Register dst, void* junk); // dummy
1063 
1064   void cmpw(Address dst, int imm16);
1065 
1066   void cmpxchg8 (Address adr);
1067 
1068   void cmpxchgb(Register reg, Address adr);
1069   void cmpxchgl(Register reg, Address adr);
1070 
1071   void cmpxchgq(Register reg, Address adr);
1072 
1073   // Ordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1074   void comisd(XMMRegister dst, Address src);
1075   void comisd(XMMRegister dst, XMMRegister src);
1076 
1077   // Ordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1078   void comiss(XMMRegister dst, Address src);
1079   void comiss(XMMRegister dst, XMMRegister src);
1080 
1081   // Identify processor type and features
1082   void cpuid();
1083 
1084   // CRC32C
1085   void crc32(Register crc, Register v, int8_t sizeInBytes);
1086   void crc32(Register crc, Address adr, int8_t sizeInBytes);
1087 
1088   // Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value
1089   void cvtsd2ss(XMMRegister dst, XMMRegister src);
1090   void cvtsd2ss(XMMRegister dst, Address src);
1091 
1092   // Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value
1093   void cvtsi2sdl(XMMRegister dst, Register src);
1094   void cvtsi2sdl(XMMRegister dst, Address src);
1095   void cvtsi2sdq(XMMRegister dst, Register src);
1096   void cvtsi2sdq(XMMRegister dst, Address src);
1097 
1098   // Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value
1099   void cvtsi2ssl(XMMRegister dst, Register src);
1100   void cvtsi2ssl(XMMRegister dst, Address src);
1101   void cvtsi2ssq(XMMRegister dst, Register src);
1102   void cvtsi2ssq(XMMRegister dst, Address src);
1103 
1104   // Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Value
1105   void cvtdq2pd(XMMRegister dst, XMMRegister src);
1106 
1107   // Convert Packed Signed Doubleword Integers to Packed Single-Precision Floating-Point Value
1108   void cvtdq2ps(XMMRegister dst, XMMRegister src);
1109 
1110   // Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value
1111   void cvtss2sd(XMMRegister dst, XMMRegister src);
1112   void cvtss2sd(XMMRegister dst, Address src);
1113 
1114   // Convert with Truncation Scalar Double-Precision Floating-Point Value to Doubleword Integer
1115   void cvttsd2sil(Register dst, Address src);
1116   void cvttsd2sil(Register dst, XMMRegister src);
1117   void cvttsd2siq(Register dst, Address src);
1118   void cvttsd2siq(Register dst, XMMRegister src);
1119 
1120   // Convert with Truncation Scalar Single-Precision Floating-Point Value to Doubleword Integer
1121   void cvttss2sil(Register dst, XMMRegister src);
1122   void cvttss2siq(Register dst, XMMRegister src);
1123 
1124   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1125 
1126   //Abs of packed Integer values
1127   void pabsb(XMMRegister dst, XMMRegister src);
1128   void pabsw(XMMRegister dst, XMMRegister src);
1129   void pabsd(XMMRegister dst, XMMRegister src);
1130   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1131   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1132   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1133   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1134 
1135   // Divide Scalar Double-Precision Floating-Point Values
1136   void divsd(XMMRegister dst, Address src);
1137   void divsd(XMMRegister dst, XMMRegister src);
1138 
1139   // Divide Scalar Single-Precision Floating-Point Values
1140   void divss(XMMRegister dst, Address src);
1141   void divss(XMMRegister dst, XMMRegister src);
1142 
1143   void emms();
1144 
1145 #ifndef _LP64
1146   void fabs();
1147 
1148   void fadd(int i);
1149 
1150   void fadd_d(Address src);
1151   void fadd_s(Address src);
1152 
1153   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1154   // stack instead of on TOS
1155 
1156   void fadda(int i); // &quot;alternate&quot; fadd
1157   void faddp(int i = 1);
1158 
1159   void fchs();
1160 
1161   void fcom(int i);
1162 
1163   void fcomp(int i = 1);
1164   void fcomp_d(Address src);
1165   void fcomp_s(Address src);
1166 
1167   void fcompp();
1168 
1169   void fcos();
1170 
1171   void fdecstp();
1172 
1173   void fdiv(int i);
1174   void fdiv_d(Address src);
1175   void fdivr_s(Address src);
1176   void fdiva(int i);  // &quot;alternate&quot; fdiv
1177   void fdivp(int i = 1);
1178 
1179   void fdivr(int i);
1180   void fdivr_d(Address src);
1181   void fdiv_s(Address src);
1182 
1183   void fdivra(int i); // &quot;alternate&quot; reversed fdiv
1184 
1185   void fdivrp(int i = 1);
1186 
1187   void ffree(int i = 0);
1188 
1189   void fild_d(Address adr);
1190   void fild_s(Address adr);
1191 
1192   void fincstp();
1193 
1194   void finit();
1195 
1196   void fist_s (Address adr);
1197   void fistp_d(Address adr);
1198   void fistp_s(Address adr);
1199 
1200   void fld1();
1201 
1202   void fld_d(Address adr);
1203   void fld_s(Address adr);
1204   void fld_s(int index);
1205 
1206   void fldcw(Address src);
1207 
1208   void fldenv(Address src);
1209 
1210   void fldlg2();
1211 
1212   void fldln2();
1213 
1214   void fldz();
1215 
1216   void flog();
1217   void flog10();
1218 
1219   void fmul(int i);
1220 
1221   void fmul_d(Address src);
1222   void fmul_s(Address src);
1223 
1224   void fmula(int i);  // &quot;alternate&quot; fmul
1225 
1226   void fmulp(int i = 1);
1227 
1228   void fnsave(Address dst);
1229 
1230   void fnstcw(Address src);
1231 
1232   void fnstsw_ax();
1233 
1234   void fprem();
1235   void fprem1();
1236 
1237   void frstor(Address src);
1238 
1239   void fsin();
1240 
1241   void fsqrt();
1242 
1243   void fst_d(Address adr);
1244   void fst_s(Address adr);
1245 
1246   void fstp_d(Address adr);
1247   void fstp_d(int index);
1248   void fstp_s(Address adr);
1249 
1250   void fsub(int i);
1251   void fsub_d(Address src);
1252   void fsub_s(Address src);
1253 
1254   void fsuba(int i);  // &quot;alternate&quot; fsub
1255 
1256   void fsubp(int i = 1);
1257 
1258   void fsubr(int i);
1259   void fsubr_d(Address src);
1260   void fsubr_s(Address src);
1261 
1262   void fsubra(int i); // &quot;alternate&quot; reversed fsub
1263 
1264   void fsubrp(int i = 1);
1265 
1266   void ftan();
1267 
1268   void ftst();
1269 
1270   void fucomi(int i = 1);
1271   void fucomip(int i = 1);
1272 
1273   void fwait();
1274 
1275   void fxch(int i = 1);
1276 
1277   void fyl2x();
1278   void frndint();
1279   void f2xm1();
1280   void fldl2e();
1281 #endif // !_LP64
1282 
1283   void fld_x(Address adr);  // extended-precision (80-bit) format
1284   void fstp_x(Address adr); // extended-precision (80-bit) format
1285   void fxrstor(Address src);
1286   void xrstor(Address src);
1287 
1288   void fxsave(Address dst);
1289   void xsave(Address dst);
1290 
1291   void hlt();
1292 
1293   void idivl(Register src);
1294   void divl(Register src); // Unsigned division
1295 
1296 #ifdef _LP64
1297   void idivq(Register src);
1298 #endif
1299 
1300   void imull(Register src);
1301   void imull(Register dst, Register src);
1302   void imull(Register dst, Register src, int value);
1303   void imull(Register dst, Address src);
1304 
1305 #ifdef _LP64
1306   void imulq(Register dst, Register src);
1307   void imulq(Register dst, Register src, int value);
1308   void imulq(Register dst, Address src);
1309 #endif
1310 
1311   // jcc is the generic conditional branch generator to run-
1312   // time routines, jcc is used for branches to labels. jcc
1313   // takes a branch opcode (cc) and a label (L) and generates
1314   // either a backward branch or a forward branch and links it
1315   // to the label fixup chain. Usage:
1316   //
1317   // Label L;      // unbound label
1318   // jcc(cc, L);   // forward branch to unbound label
1319   // bind(L);      // bind label to the current pc
1320   // jcc(cc, L);   // backward branch to bound label
1321   // bind(L);      // illegal: a label may be bound only once
1322   //
1323   // Note: The same Label can be used for forward and backward branches
1324   // but it may be bound only once.
1325 
1326   void jcc(Condition cc, Label&amp; L, bool maybe_short = true);
1327 
1328   // Conditional jump to a 8-bit offset to L.
1329   // WARNING: be very careful using this for forward jumps.  If the label is
1330   // not bound within an 8-bit offset of this instruction, a run-time error
1331   // will occur.
1332 
1333   // Use macro to record file and line number.
1334   #define jccb(cc, L) jccb_0(cc, L, __FILE__, __LINE__)
1335 
1336   void jccb_0(Condition cc, Label&amp; L, const char* file, int line);
1337 
1338   void jmp(Address entry);    // pc &lt;- entry
1339 
1340   // Label operations &amp; relative jumps (PPUM Appendix D)
1341   void jmp(Label&amp; L, bool maybe_short = true);   // unconditional jump to L
1342 
1343   void jmp(Register entry); // pc &lt;- entry
1344 
1345   // Unconditional 8-bit offset jump to L.
1346   // WARNING: be very careful using this for forward jumps.  If the label is
1347   // not bound within an 8-bit offset of this instruction, a run-time error
1348   // will occur.
1349 
1350   // Use macro to record file and line number.
1351   #define jmpb(L) jmpb_0(L, __FILE__, __LINE__)
1352 
1353   void jmpb_0(Label&amp; L, const char* file, int line);
1354 
1355   void ldmxcsr( Address src );
1356 
1357   void leal(Register dst, Address src);
1358 
1359   void leaq(Register dst, Address src);
1360 
1361   void lfence();
1362 
1363   void lock();
1364 
1365   void lzcntl(Register dst, Register src);
1366 
1367 #ifdef _LP64
1368   void lzcntq(Register dst, Register src);
1369 #endif
1370 
1371   enum Membar_mask_bits {
1372     StoreStore = 1 &lt;&lt; 3,
1373     LoadStore  = 1 &lt;&lt; 2,
1374     StoreLoad  = 1 &lt;&lt; 1,
1375     LoadLoad   = 1 &lt;&lt; 0
1376   };
1377 
1378   // Serializes memory and blows flags
1379   void membar(Membar_mask_bits order_constraint) {
1380     // We only have to handle StoreLoad
1381     if (order_constraint &amp; StoreLoad) {
1382       // All usable chips support &quot;locked&quot; instructions which suffice
1383       // as barriers, and are much faster than the alternative of
1384       // using cpuid instruction. We use here a locked add [esp-C],0.
1385       // This is conveniently otherwise a no-op except for blowing
1386       // flags, and introducing a false dependency on target memory
1387       // location. We can&#39;t do anything with flags, but we can avoid
1388       // memory dependencies in the current method by locked-adding
1389       // somewhere else on the stack. Doing [esp+C] will collide with
1390       // something on stack in current method, hence we go for [esp-C].
1391       // It is convenient since it is almost always in data cache, for
1392       // any small C.  We need to step back from SP to avoid data
1393       // dependencies with other things on below SP (callee-saves, for
1394       // example). Without a clear way to figure out the minimal safe
1395       // distance from SP, it makes sense to step back the complete
1396       // cache line, as this will also avoid possible second-order effects
1397       // with locked ops against the cache line. Our choice of offset
1398       // is bounded by x86 operand encoding, which should stay within
1399       // [-128; +127] to have the 8-byte displacement encoding.
1400       //
1401       // Any change to this code may need to revisit other places in
1402       // the code where this idiom is used, in particular the
1403       // orderAccess code.
1404 
1405       int offset = -VM_Version::L1_line_size();
1406       if (offset &lt; -128) {
1407         offset = -128;
1408       }
1409 
1410       lock();
1411       addl(Address(rsp, offset), 0);// Assert the lock# signal here
1412     }
1413   }
1414 
1415   void mfence();
1416   void sfence();
1417 
1418   // Moves
1419 
1420   void mov64(Register dst, int64_t imm64);
1421 
1422   void movb(Address dst, Register src);
1423   void movb(Address dst, int imm8);
1424   void movb(Register dst, Address src);
1425 
1426   void movddup(XMMRegister dst, XMMRegister src);
1427 
1428   void kmovbl(KRegister dst, Register src);
1429   void kmovbl(Register dst, KRegister src);
1430   void kmovwl(KRegister dst, Register src);
1431   void kmovwl(KRegister dst, Address src);
1432   void kmovwl(Register dst, KRegister src);
1433   void kmovdl(KRegister dst, Register src);
1434   void kmovdl(Register dst, KRegister src);
1435   void kmovql(KRegister dst, KRegister src);
1436   void kmovql(Address dst, KRegister src);
1437   void kmovql(KRegister dst, Address src);
1438   void kmovql(KRegister dst, Register src);
1439   void kmovql(Register dst, KRegister src);
1440 
1441   void knotwl(KRegister dst, KRegister src);
1442 
1443   void kortestbl(KRegister dst, KRegister src);
1444   void kortestwl(KRegister dst, KRegister src);
1445   void kortestdl(KRegister dst, KRegister src);
1446   void kortestql(KRegister dst, KRegister src);
1447 
1448   void ktestq(KRegister src1, KRegister src2);
1449   void ktestd(KRegister src1, KRegister src2);
1450 
1451   void ktestql(KRegister dst, KRegister src);
1452 
1453   void movdl(XMMRegister dst, Register src);
1454   void movdl(Register dst, XMMRegister src);
1455   void movdl(XMMRegister dst, Address src);
1456   void movdl(Address dst, XMMRegister src);
1457 
1458   // Move Double Quadword
1459   void movdq(XMMRegister dst, Register src);
1460   void movdq(Register dst, XMMRegister src);
1461 
1462   // Move Aligned Double Quadword
1463   void movdqa(XMMRegister dst, XMMRegister src);
1464   void movdqa(XMMRegister dst, Address src);
1465 
1466   // Move Unaligned Double Quadword
1467   void movdqu(Address     dst, XMMRegister src);
1468   void movdqu(XMMRegister dst, Address src);
1469   void movdqu(XMMRegister dst, XMMRegister src);
1470 
1471   // Move Unaligned 256bit Vector
1472   void vmovdqu(Address dst, XMMRegister src);
1473   void vmovdqu(XMMRegister dst, Address src);
1474   void vmovdqu(XMMRegister dst, XMMRegister src);
1475 
1476    // Move Unaligned 512bit Vector
1477   void evmovdqub(Address dst, XMMRegister src, int vector_len);
1478   void evmovdqub(XMMRegister dst, Address src, int vector_len);
1479   void evmovdqub(XMMRegister dst, XMMRegister src, int vector_len);
1480   void evmovdqub(XMMRegister dst, KRegister mask, Address src, int vector_len);
1481   void evmovdquw(Address dst, XMMRegister src, int vector_len);
1482   void evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len);
1483   void evmovdquw(XMMRegister dst, Address src, int vector_len);
1484   void evmovdquw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1485   void evmovdqul(Address dst, XMMRegister src, int vector_len);
1486   void evmovdqul(XMMRegister dst, Address src, int vector_len);
1487   void evmovdqul(XMMRegister dst, XMMRegister src, int vector_len);
1488   void evmovdquq(Address dst, XMMRegister src, int vector_len);
1489   void evmovdquq(XMMRegister dst, Address src, int vector_len);
1490   void evmovdquq(XMMRegister dst, XMMRegister src, int vector_len);
1491 
1492   // Move lower 64bit to high 64bit in 128bit register
1493   void movlhps(XMMRegister dst, XMMRegister src);
1494 
1495   void movl(Register dst, int32_t imm32);
1496   void movl(Address dst, int32_t imm32);
1497   void movl(Register dst, Register src);
1498   void movl(Register dst, Address src);
1499   void movl(Address dst, Register src);
1500 
1501   // These dummies prevent using movl from converting a zero (like NULL) into Register
1502   // by giving the compiler two choices it can&#39;t resolve
1503 
1504   void movl(Address  dst, void* junk);
1505   void movl(Register dst, void* junk);
1506 
1507 #ifdef _LP64
1508   void movq(Register dst, Register src);
1509   void movq(Register dst, Address src);
1510   void movq(Address  dst, Register src);
1511 #endif
1512 
1513   void movq(Address     dst, MMXRegister src );
1514   void movq(MMXRegister dst, Address src );
1515 
1516 #ifdef _LP64
1517   // These dummies prevent using movq from converting a zero (like NULL) into Register
1518   // by giving the compiler two choices it can&#39;t resolve
1519 
1520   void movq(Address  dst, void* dummy);
1521   void movq(Register dst, void* dummy);
1522 #endif
1523 
1524   // Move Quadword
1525   void movq(Address     dst, XMMRegister src);
1526   void movq(XMMRegister dst, Address src);
1527 
1528   void movsbl(Register dst, Address src);
1529   void movsbl(Register dst, Register src);
1530 
1531 #ifdef _LP64
1532   void movsbq(Register dst, Address src);
1533   void movsbq(Register dst, Register src);
1534 
1535   // Move signed 32bit immediate to 64bit extending sign
1536   void movslq(Address  dst, int32_t imm64);
1537   void movslq(Register dst, int32_t imm64);
1538 
1539   void movslq(Register dst, Address src);
1540   void movslq(Register dst, Register src);
1541   void movslq(Register dst, void* src); // Dummy declaration to cause NULL to be ambiguous
1542 #endif
1543 
1544   void movswl(Register dst, Address src);
1545   void movswl(Register dst, Register src);
1546 
1547 #ifdef _LP64
1548   void movswq(Register dst, Address src);
1549   void movswq(Register dst, Register src);
1550 #endif
1551 
1552   void movw(Address dst, int imm16);
1553   void movw(Register dst, Address src);
1554   void movw(Address dst, Register src);
1555 
1556   void movzbl(Register dst, Address src);
1557   void movzbl(Register dst, Register src);
1558 
1559 #ifdef _LP64
1560   void movzbq(Register dst, Address src);
1561   void movzbq(Register dst, Register src);
1562 #endif
1563 
1564   void movzwl(Register dst, Address src);
1565   void movzwl(Register dst, Register src);
1566 
1567 #ifdef _LP64
1568   void movzwq(Register dst, Address src);
1569   void movzwq(Register dst, Register src);
1570 #endif
1571 
1572   // Unsigned multiply with RAX destination register
1573   void mull(Address src);
1574   void mull(Register src);
1575 
1576 #ifdef _LP64
1577   void mulq(Address src);
1578   void mulq(Register src);
1579   void mulxq(Register dst1, Register dst2, Register src);
1580 #endif
1581 
1582   // Multiply Scalar Double-Precision Floating-Point Values
1583   void mulsd(XMMRegister dst, Address src);
1584   void mulsd(XMMRegister dst, XMMRegister src);
1585 
1586   // Multiply Scalar Single-Precision Floating-Point Values
1587   void mulss(XMMRegister dst, Address src);
1588   void mulss(XMMRegister dst, XMMRegister src);
1589 
1590   void negl(Register dst);
1591 
1592 #ifdef _LP64
1593   void negq(Register dst);
1594 #endif
1595 
1596   void nop(int i = 1);
1597 
1598   void notl(Register dst);
1599 
1600 #ifdef _LP64
1601   void notq(Register dst);
1602 
1603   void btsq(Address dst, int imm8);
1604   void btrq(Address dst, int imm8);
1605 #endif
1606 
1607   void orl(Address dst, int32_t imm32);
1608   void orl(Register dst, int32_t imm32);
1609   void orl(Register dst, Address src);
1610   void orl(Register dst, Register src);
1611   void orl(Address dst, Register src);
1612 
1613   void orb(Address dst, int imm8);
1614 
1615   void orq(Address dst, int32_t imm32);
1616   void orq(Register dst, int32_t imm32);
1617   void orq(Register dst, Address src);
1618   void orq(Register dst, Register src);
1619 
1620   // Pack with unsigned saturation
1621   void packuswb(XMMRegister dst, XMMRegister src);
1622   void packuswb(XMMRegister dst, Address src);
1623   void vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1624 
1625   // Pemutation of 64bit words
1626   void vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len);
1627   void vpermq(XMMRegister dst, XMMRegister src, int imm8);
1628   void vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1629   void vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8);
1630   void vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8);
1631   void evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1632 
1633   void pause();
1634 
1635   // Undefined Instruction
1636   void ud2();
1637 
1638   // SSE4.2 string instructions
1639   void pcmpestri(XMMRegister xmm1, XMMRegister xmm2, int imm8);
1640   void pcmpestri(XMMRegister xmm1, Address src, int imm8);
1641 
1642   void pcmpeqb(XMMRegister dst, XMMRegister src);
1643   void vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1644   void evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1645   void evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1646   void evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1647 
1648   void evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1649   void evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len);
1650 
1651   void evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len);
1652   void evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate of, int vector_len);
1653   void evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len);
1654 
1655   void pcmpeqw(XMMRegister dst, XMMRegister src);
1656   void vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1657   void evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1658   void evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1659 
1660   void pcmpeqd(XMMRegister dst, XMMRegister src);
1661   void vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1662   void evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1663   void evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1664 
1665   void pcmpeqq(XMMRegister dst, XMMRegister src);
1666   void vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1667   void evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len);
1668   void evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len);
1669 
1670   void pmovmskb(Register dst, XMMRegister src);
1671   void vpmovmskb(Register dst, XMMRegister src);
1672 
1673   // SSE 4.1 extract
1674   void pextrd(Register dst, XMMRegister src, int imm8);
1675   void pextrq(Register dst, XMMRegister src, int imm8);
1676   void pextrd(Address dst, XMMRegister src, int imm8);
1677   void pextrq(Address dst, XMMRegister src, int imm8);
1678   void pextrb(Address dst, XMMRegister src, int imm8);
1679   // SSE 2 extract
1680   void pextrw(Register dst, XMMRegister src, int imm8);
1681   void pextrw(Address dst, XMMRegister src, int imm8);
1682 
1683   // SSE 4.1 insert
1684   void pinsrd(XMMRegister dst, Register src, int imm8);
1685   void pinsrq(XMMRegister dst, Register src, int imm8);
1686   void pinsrd(XMMRegister dst, Address src, int imm8);
1687   void pinsrq(XMMRegister dst, Address src, int imm8);
1688   void pinsrb(XMMRegister dst, Address src, int imm8);
1689   // SSE 2 insert
1690   void pinsrw(XMMRegister dst, Register src, int imm8);
1691   void pinsrw(XMMRegister dst, Address src, int imm8);
1692 
1693   // SSE4.1 packed move
1694   void pmovzxbw(XMMRegister dst, XMMRegister src);
1695   void pmovzxbw(XMMRegister dst, Address src);
1696 
1697   void vpmovzxbw( XMMRegister dst, Address src, int vector_len);
1698   void vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len);
1699   void evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len);
1700 
1701   void evpmovwb(Address dst, XMMRegister src, int vector_len);
1702   void evpmovwb(Address dst, KRegister mask, XMMRegister src, int vector_len);
1703 
1704   void vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len);
1705 
1706   void evpmovdb(Address dst, XMMRegister src, int vector_len);
1707 
1708   // Sign extend moves
1709   void pmovsxbw(XMMRegister dst, XMMRegister src);
1710   void vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len);
1711 
1712   // Multiply add
1713   void pmaddwd(XMMRegister dst, XMMRegister src);
1714   void vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1715   // Multiply add accumulate
1716   void evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1717 
1718 #ifndef _LP64 // no 32bit push/pop on amd64
1719   void popl(Address dst);
1720 #endif
1721 
1722 #ifdef _LP64
1723   void popq(Address dst);
1724 #endif
1725 
1726   void popcntl(Register dst, Address src);
1727   void popcntl(Register dst, Register src);
1728 
1729   void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);
1730 
1731 #ifdef _LP64
1732   void popcntq(Register dst, Address src);
1733   void popcntq(Register dst, Register src);
1734 #endif
1735 
1736   // Prefetches (SSE, SSE2, 3DNOW only)
1737 
1738   void prefetchnta(Address src);
1739   void prefetchr(Address src);
1740   void prefetcht0(Address src);
1741   void prefetcht1(Address src);
1742   void prefetcht2(Address src);
1743   void prefetchw(Address src);
1744 
1745   // Shuffle Bytes
1746   void pshufb(XMMRegister dst, XMMRegister src);
1747   void pshufb(XMMRegister dst, Address src);
1748   void vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1749 
1750   // Shuffle Packed Doublewords
1751   void pshufd(XMMRegister dst, XMMRegister src, int mode);
1752   void pshufd(XMMRegister dst, Address src,     int mode);
1753   void vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len);
1754 
1755   // Shuffle Packed Low Words
1756   void pshuflw(XMMRegister dst, XMMRegister src, int mode);
1757   void pshuflw(XMMRegister dst, Address src,     int mode);
1758 
1759   // Shuffle packed values at 128 bit granularity
1760   void evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
1761 
1762   // Shift Right by bytes Logical DoubleQuadword Immediate
1763   void psrldq(XMMRegister dst, int shift);
1764   // Shift Left by bytes Logical DoubleQuadword Immediate
1765   void pslldq(XMMRegister dst, int shift);
1766 
1767   // Logical Compare 128bit
1768   void ptest(XMMRegister dst, XMMRegister src);
1769   void ptest(XMMRegister dst, Address src);
1770   // Logical Compare 256bit
1771   void vptest(XMMRegister dst, XMMRegister src);
1772   void vptest(XMMRegister dst, Address src);
1773 
1774   // Interleave Low Bytes
1775   void punpcklbw(XMMRegister dst, XMMRegister src);
1776   void punpcklbw(XMMRegister dst, Address src);
1777 
1778   // Interleave Low Doublewords
1779   void punpckldq(XMMRegister dst, XMMRegister src);
1780   void punpckldq(XMMRegister dst, Address src);
1781 
1782   // Interleave Low Quadwords
1783   void punpcklqdq(XMMRegister dst, XMMRegister src);
1784 
1785 #ifndef _LP64 // no 32bit push/pop on amd64
1786   void pushl(Address src);
1787 #endif
1788 
1789   void pushq(Address src);
1790 
1791   void rcll(Register dst, int imm8);
1792 
1793   void rclq(Register dst, int imm8);
1794 
1795   void rcrq(Register dst, int imm8);
1796 
1797   void rcpps(XMMRegister dst, XMMRegister src);
1798 
1799   void rcpss(XMMRegister dst, XMMRegister src);
1800 
1801   void rdtsc();
1802 
1803   void ret(int imm16);
1804 
1805 #ifdef _LP64
1806   void rorq(Register dst, int imm8);
1807   void rorxq(Register dst, Register src, int imm8);
1808   void rorxd(Register dst, Register src, int imm8);
1809 #endif
1810 
1811   void sahf();
1812 
1813   void sarl(Register dst, int imm8);
1814   void sarl(Register dst);
1815 
1816   void sarq(Register dst, int imm8);
1817   void sarq(Register dst);
1818 
1819   void sbbl(Address dst, int32_t imm32);
1820   void sbbl(Register dst, int32_t imm32);
1821   void sbbl(Register dst, Address src);
1822   void sbbl(Register dst, Register src);
1823 
1824   void sbbq(Address dst, int32_t imm32);
1825   void sbbq(Register dst, int32_t imm32);
1826   void sbbq(Register dst, Address src);
1827   void sbbq(Register dst, Register src);
1828 
1829   void setb(Condition cc, Register dst);
1830 
1831   void palignr(XMMRegister dst, XMMRegister src, int imm8);
1832   void vpalignr(XMMRegister dst, XMMRegister src1, XMMRegister src2, int imm8, int vector_len);
1833   void evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
1834 
1835   void pblendw(XMMRegister dst, XMMRegister src, int imm8);
1836 
1837   void sha1rnds4(XMMRegister dst, XMMRegister src, int imm8);
1838   void sha1nexte(XMMRegister dst, XMMRegister src);
1839   void sha1msg1(XMMRegister dst, XMMRegister src);
1840   void sha1msg2(XMMRegister dst, XMMRegister src);
1841   // xmm0 is implicit additional source to the following instruction.
1842   void sha256rnds2(XMMRegister dst, XMMRegister src);
1843   void sha256msg1(XMMRegister dst, XMMRegister src);
1844   void sha256msg2(XMMRegister dst, XMMRegister src);
1845 
1846   void shldl(Register dst, Register src);
1847   void shldl(Register dst, Register src, int8_t imm8);
1848   void shrdl(Register dst, Register src);
1849   void shrdl(Register dst, Register src, int8_t imm8);
1850 
1851   void shll(Register dst, int imm8);
1852   void shll(Register dst);
1853 
1854   void shlq(Register dst, int imm8);
1855   void shlq(Register dst);
1856 
1857   void shrl(Register dst, int imm8);
1858   void shrl(Register dst);
1859 
1860   void shrq(Register dst, int imm8);
1861   void shrq(Register dst);
1862 
1863   void smovl(); // QQQ generic?
1864 
1865   // Compute Square Root of Scalar Double-Precision Floating-Point Value
1866   void sqrtsd(XMMRegister dst, Address src);
1867   void sqrtsd(XMMRegister dst, XMMRegister src);
1868 
1869   void roundsd(XMMRegister dst, Address src, int32_t rmode);
1870   void roundsd(XMMRegister dst, XMMRegister src, int32_t rmode);
1871 
1872   // Compute Square Root of Scalar Single-Precision Floating-Point Value
1873   void sqrtss(XMMRegister dst, Address src);
1874   void sqrtss(XMMRegister dst, XMMRegister src);
1875 
1876   void std();
1877 
1878   void stmxcsr( Address dst );
1879 
1880   void subl(Address dst, int32_t imm32);
1881   void subl(Address dst, Register src);
1882   void subl(Register dst, int32_t imm32);
1883   void subl(Register dst, Address src);
1884   void subl(Register dst, Register src);
1885 
1886   void subq(Address dst, int32_t imm32);
1887   void subq(Address dst, Register src);
1888   void subq(Register dst, int32_t imm32);
1889   void subq(Register dst, Address src);
1890   void subq(Register dst, Register src);
1891 
1892   // Force generation of a 4 byte immediate value even if it fits into 8bit
1893   void subl_imm32(Register dst, int32_t imm32);
1894   void subq_imm32(Register dst, int32_t imm32);
1895 
1896   // Subtract Scalar Double-Precision Floating-Point Values
1897   void subsd(XMMRegister dst, Address src);
1898   void subsd(XMMRegister dst, XMMRegister src);
1899 
1900   // Subtract Scalar Single-Precision Floating-Point Values
1901   void subss(XMMRegister dst, Address src);
1902   void subss(XMMRegister dst, XMMRegister src);
1903 
1904   void testb(Register dst, int imm8);
1905   void testb(Address dst, int imm8);
1906 
1907   void testl(Register dst, int32_t imm32);
1908   void testl(Register dst, Register src);
1909   void testl(Register dst, Address src);
1910 
1911   void testq(Register dst, int32_t imm32);
1912   void testq(Register dst, Register src);
1913   void testq(Register dst, Address src);
1914 
1915   // BMI - count trailing zeros
1916   void tzcntl(Register dst, Register src);
1917   void tzcntq(Register dst, Register src);
1918 
1919   // Unordered Compare Scalar Double-Precision Floating-Point Values and set EFLAGS
1920   void ucomisd(XMMRegister dst, Address src);
1921   void ucomisd(XMMRegister dst, XMMRegister src);
1922 
1923   // Unordered Compare Scalar Single-Precision Floating-Point Values and set EFLAGS
1924   void ucomiss(XMMRegister dst, Address src);
1925   void ucomiss(XMMRegister dst, XMMRegister src);
1926 
1927   void xabort(int8_t imm8);
1928 
1929   void xaddb(Address dst, Register src);
1930   void xaddw(Address dst, Register src);
1931   void xaddl(Address dst, Register src);
1932   void xaddq(Address dst, Register src);
1933 
1934   void xbegin(Label&amp; abort, relocInfo::relocType rtype = relocInfo::none);
1935 
1936   void xchgb(Register reg, Address adr);
1937   void xchgw(Register reg, Address adr);
1938   void xchgl(Register reg, Address adr);
1939   void xchgl(Register dst, Register src);
1940 
1941   void xchgq(Register reg, Address adr);
1942   void xchgq(Register dst, Register src);
1943 
1944   void xend();
1945 
1946   // Get Value of Extended Control Register
1947   void xgetbv();
1948 
1949   void xorl(Register dst, int32_t imm32);
1950   void xorl(Register dst, Address src);
1951   void xorl(Register dst, Register src);
1952 
1953   void xorb(Register dst, Address src);
1954 
1955   void xorq(Register dst, Address src);
1956   void xorq(Register dst, Register src);
1957 
1958   void set_byte_if_not_zero(Register dst); // sets reg to 1 if not zero, otherwise 0
1959 
1960   // AVX 3-operands scalar instructions (encoded with VEX prefix)
1961 
1962   void vaddsd(XMMRegister dst, XMMRegister nds, Address src);
1963   void vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1964   void vaddss(XMMRegister dst, XMMRegister nds, Address src);
1965   void vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1966   void vdivsd(XMMRegister dst, XMMRegister nds, Address src);
1967   void vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1968   void vdivss(XMMRegister dst, XMMRegister nds, Address src);
1969   void vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1970   void vfmadd231sd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1971   void vfmadd231ss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1972   void vmulsd(XMMRegister dst, XMMRegister nds, Address src);
1973   void vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1974   void vmulss(XMMRegister dst, XMMRegister nds, Address src);
1975   void vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1976   void vsubsd(XMMRegister dst, XMMRegister nds, Address src);
1977   void vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1978   void vsubss(XMMRegister dst, XMMRegister nds, Address src);
1979   void vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1980 
1981   void vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1982   void vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1983   void vminss(XMMRegister dst, XMMRegister nds, XMMRegister src);
1984   void vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src);
1985 
1986   void shlxl(Register dst, Register src1, Register src2);
1987   void shlxq(Register dst, Register src1, Register src2);
1988 
1989   //====================VECTOR ARITHMETIC=====================================
1990 
1991   // Add Packed Floating-Point Values
1992   void addpd(XMMRegister dst, XMMRegister src);
1993   void addpd(XMMRegister dst, Address src);
1994   void addps(XMMRegister dst, XMMRegister src);
1995   void vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1996   void vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
1997   void vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1998   void vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
1999 
2000   // Subtract Packed Floating-Point Values
2001   void subpd(XMMRegister dst, XMMRegister src);
2002   void subps(XMMRegister dst, XMMRegister src);
2003   void vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2004   void vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2005   void vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2006   void vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2007 
2008   // Multiply Packed Floating-Point Values
2009   void mulpd(XMMRegister dst, XMMRegister src);
2010   void mulpd(XMMRegister dst, Address src);
2011   void mulps(XMMRegister dst, XMMRegister src);
2012   void vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2013   void vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2014   void vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2015   void vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2016 
2017   void vfmadd231pd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2018   void vfmadd231ps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2019   void vfmadd231pd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2020   void vfmadd231ps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2021 
2022   // Divide Packed Floating-Point Values
2023   void divpd(XMMRegister dst, XMMRegister src);
2024   void divps(XMMRegister dst, XMMRegister src);
2025   void vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2026   void vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2027   void vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2028   void vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2029 
2030   // Sqrt Packed Floating-Point Values
2031   void vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len);
2032   void vsqrtpd(XMMRegister dst, Address src, int vector_len);
2033   void vsqrtps(XMMRegister dst, XMMRegister src, int vector_len);
2034   void vsqrtps(XMMRegister dst, Address src, int vector_len);
2035 
2036   // Round Packed Double precision value.
2037   void vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len);
2038   void vroundpd(XMMRegister dst, Address src, int32_t rmode, int vector_len);
2039   void vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len);
2040   void vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len);
2041 
2042   // Bitwise Logical AND of Packed Floating-Point Values
2043   void andpd(XMMRegister dst, XMMRegister src);
2044   void andps(XMMRegister dst, XMMRegister src);
2045   void vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2046   void vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2047   void vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2048   void vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2049 
2050   void unpckhpd(XMMRegister dst, XMMRegister src);
2051   void unpcklpd(XMMRegister dst, XMMRegister src);
2052 
2053   // Bitwise Logical XOR of Packed Floating-Point Values
2054   void xorpd(XMMRegister dst, XMMRegister src);
2055   void xorps(XMMRegister dst, XMMRegister src);
2056   void vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2057   void vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2058   void vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2059   void vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2060 
2061   // Add horizontal packed integers
2062   void vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2063   void vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2064   void phaddw(XMMRegister dst, XMMRegister src);
2065   void phaddd(XMMRegister dst, XMMRegister src);
2066 
2067   // Add packed integers
2068   void paddb(XMMRegister dst, XMMRegister src);
2069   void paddw(XMMRegister dst, XMMRegister src);
2070   void paddd(XMMRegister dst, XMMRegister src);
2071   void paddd(XMMRegister dst, Address src);
2072   void paddq(XMMRegister dst, XMMRegister src);
2073   void vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2074   void vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2075   void vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2076   void vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2077   void vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2078   void vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2079   void vpaddd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2080   void vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2081 
2082   // Sub packed integers
2083   void psubb(XMMRegister dst, XMMRegister src);
2084   void psubw(XMMRegister dst, XMMRegister src);
2085   void psubd(XMMRegister dst, XMMRegister src);
2086   void psubq(XMMRegister dst, XMMRegister src);
2087   void vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2088   void vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2089   void vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2090   void vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2091   void vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2092   void vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2093   void vpsubd(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2094   void vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2095 
2096   // Multiply packed integers (only shorts and ints)
2097   void pmullw(XMMRegister dst, XMMRegister src);
2098   void pmulld(XMMRegister dst, XMMRegister src);
2099   void vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2100   void vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2101   void vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2102   void vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2103   void vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2104   void vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2105 
2106   // Shift left packed integers
2107   void psllw(XMMRegister dst, int shift);
2108   void pslld(XMMRegister dst, int shift);
2109   void psllq(XMMRegister dst, int shift);
2110   void psllw(XMMRegister dst, XMMRegister shift);
2111   void pslld(XMMRegister dst, XMMRegister shift);
2112   void psllq(XMMRegister dst, XMMRegister shift);
2113   void vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2114   void vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2115   void vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2116   void vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2117   void vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2118   void vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2119   void vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2120 
2121   // Logical shift right packed integers
2122   void psrlw(XMMRegister dst, int shift);
2123   void psrld(XMMRegister dst, int shift);
2124   void psrlq(XMMRegister dst, int shift);
2125   void psrlw(XMMRegister dst, XMMRegister shift);
2126   void psrld(XMMRegister dst, XMMRegister shift);
2127   void psrlq(XMMRegister dst, XMMRegister shift);
2128   void vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2129   void vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2130   void vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2131   void vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2132   void vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2133   void vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2134   void vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2135   void evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2136   void evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2137 
2138   // Arithmetic shift right packed integers (only shorts and ints, no instructions for longs)
2139   void psraw(XMMRegister dst, int shift);
2140   void psrad(XMMRegister dst, int shift);
2141   void psraw(XMMRegister dst, XMMRegister shift);
2142   void psrad(XMMRegister dst, XMMRegister shift);
2143   void vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2144   void vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2145   void vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2146   void vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2147   void evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len);
2148   void evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2149 
2150   void vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2151   void vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len);
2152 
2153   // And packed integers
2154   void pand(XMMRegister dst, XMMRegister src);
2155   void vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2156   void vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2157   void vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2158 
2159   // Andn packed integers
2160   void pandn(XMMRegister dst, XMMRegister src);
2161   void vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2162 
2163   // Or packed integers
2164   void por(XMMRegister dst, XMMRegister src);
2165   void vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2166   void vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2167   void vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2168 
2169   // Xor packed integers
2170   void pxor(XMMRegister dst, XMMRegister src);
2171   void vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2172   void vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2173   void evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);
2174   void evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len);
2175 
2176 
2177   // vinserti forms
2178   void vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2179   void vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2180   void vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2181   void vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2182   void vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2183 
2184   // vinsertf forms
2185   void vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2186   void vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2187   void vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2188   void vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2189   void vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8);
2190   void vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8);
2191 
2192   // vextracti forms
2193   void vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2194   void vextracti128(Address dst, XMMRegister src, uint8_t imm8);
2195   void vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2196   void vextracti32x4(Address dst, XMMRegister src, uint8_t imm8);
2197   void vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2198   void vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2199   void vextracti64x4(Address dst, XMMRegister src, uint8_t imm8);
2200 
2201   // vextractf forms
2202   void vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8);
2203   void vextractf128(Address dst, XMMRegister src, uint8_t imm8);
2204   void vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2205   void vextractf32x4(Address dst, XMMRegister src, uint8_t imm8);
2206   void vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8);
2207   void vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8);
2208   void vextractf64x4(Address dst, XMMRegister src, uint8_t imm8);
2209 
2210   // xmm/mem sourced byte/word/dword/qword replicate
2211   void vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len);
2212   void vpbroadcastb(XMMRegister dst, Address src, int vector_len);
2213   void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);
2214   void vpbroadcastw(XMMRegister dst, Address src, int vector_len);
2215   void vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len);
2216   void vpbroadcastd(XMMRegister dst, Address src, int vector_len);
2217   void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len);
2218   void vpbroadcastq(XMMRegister dst, Address src, int vector_len);
2219 
2220   void evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len);
2221   void evbroadcasti64x2(XMMRegister dst, Address src, int vector_len);
2222 
2223   // scalar single/double precision replicate
2224   void vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len);
2225   void vbroadcastss(XMMRegister dst, Address src, int vector_len);
2226   void vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len);
2227   void vbroadcastsd(XMMRegister dst, Address src, int vector_len);
2228 
2229   // gpr sourced byte/word/dword/qword replicate
2230   void evpbroadcastb(XMMRegister dst, Register src, int vector_len);
2231   void evpbroadcastw(XMMRegister dst, Register src, int vector_len);
2232   void evpbroadcastd(XMMRegister dst, Register src, int vector_len);
2233   void evpbroadcastq(XMMRegister dst, Register src, int vector_len);
2234 
2235   void evpgatherdd(XMMRegister dst, KRegister k1, Address src, int vector_len);
2236 
2237   // Carry-Less Multiplication Quadword
2238   void pclmulqdq(XMMRegister dst, XMMRegister src, int mask);
2239   void vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask);
2240   void evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len);
2241   // AVX instruction which is used to clear upper 128 bits of YMM registers and
2242   // to avoid transaction penalty between AVX and SSE states. There is no
2243   // penalty if legacy SSE instructions are encoded using VEX prefix because
2244   // they always clear upper 128 bits. It should be used before calling
2245   // runtime code and native libraries.
2246   void vzeroupper();
2247 
2248   // AVX support for vectorized conditional move (float/double). The following two instructions used only coupled.
2249   void cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2250   void blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2251   void cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len);
2252   void blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len);
2253   void vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len);
2254 
2255  protected:
2256   // Next instructions require address alignment 16 bytes SSE mode.
2257   // They should be called only from corresponding MacroAssembler instructions.
2258   void andpd(XMMRegister dst, Address src);
2259   void andps(XMMRegister dst, Address src);
2260   void xorpd(XMMRegister dst, Address src);
2261   void xorps(XMMRegister dst, Address src);
2262 
2263 };
2264 
2265 // The Intel x86/Amd64 Assembler attributes: All fields enclosed here are to guide encoding level decisions.
2266 // Specific set functions are for specialized use, else defaults or whatever was supplied to object construction
2267 // are applied.
2268 class InstructionAttr {
2269 public:
2270   InstructionAttr(
2271     int vector_len,     // The length of vector to be applied in encoding - for both AVX and EVEX
2272     bool rex_vex_w,     // Width of data: if 32-bits or less, false, else if 64-bit or specially defined, true
2273     bool legacy_mode,   // Details if either this instruction is conditionally encoded to AVX or earlier if true else possibly EVEX
2274     bool no_reg_mask,   // when true, k0 is used when EVEX encoding is chosen, else embedded_opmask_register_specifier is used
2275     bool uses_vl)       // This instruction may have legacy constraints based on vector length for EVEX
2276     :
2277       _avx_vector_len(vector_len),
2278       _rex_vex_w(rex_vex_w),
2279       _rex_vex_w_reverted(false),
2280       _legacy_mode(legacy_mode),
2281       _no_reg_mask(no_reg_mask),
2282       _uses_vl(uses_vl),
2283       _tuple_type(Assembler::EVEX_ETUP),
2284       _input_size_in_bits(Assembler::EVEX_NObit),
2285       _is_evex_instruction(false),
2286       _evex_encoding(0),
2287       _is_clear_context(true),
2288       _is_extended_context(false),
2289       _embedded_opmask_register_specifier(0), // hard code k0
2290       _current_assembler(NULL) {
2291     if (UseAVX &lt; 3) _legacy_mode = true;
2292   }
2293 
2294   ~InstructionAttr() {
2295     if (_current_assembler != NULL) {
2296       _current_assembler-&gt;clear_attributes();
2297     }
2298     _current_assembler = NULL;
2299   }
2300 
2301 private:
2302   int  _avx_vector_len;
2303   bool _rex_vex_w;
2304   bool _rex_vex_w_reverted;
2305   bool _legacy_mode;
2306   bool _no_reg_mask;
2307   bool _uses_vl;
2308   int  _tuple_type;
2309   int  _input_size_in_bits;
2310   bool _is_evex_instruction;
2311   int  _evex_encoding;
2312   bool _is_clear_context;
2313   bool _is_extended_context;
2314   int _embedded_opmask_register_specifier;
2315 
2316   Assembler *_current_assembler;
2317 
2318 public:
2319   // query functions for field accessors
2320   int  get_vector_len(void) const { return _avx_vector_len; }
2321   bool is_rex_vex_w(void) const { return _rex_vex_w; }
2322   bool is_rex_vex_w_reverted(void) { return _rex_vex_w_reverted; }
2323   bool is_legacy_mode(void) const { return _legacy_mode; }
2324   bool is_no_reg_mask(void) const { return _no_reg_mask; }
2325   bool uses_vl(void) const { return _uses_vl; }
2326   int  get_tuple_type(void) const { return _tuple_type; }
2327   int  get_input_size(void) const { return _input_size_in_bits; }
2328   int  is_evex_instruction(void) const { return _is_evex_instruction; }
2329   int  get_evex_encoding(void) const { return _evex_encoding; }
2330   bool is_clear_context(void) const { return _is_clear_context; }
2331   bool is_extended_context(void) const { return _is_extended_context; }
2332   int get_embedded_opmask_register_specifier(void) const { return _embedded_opmask_register_specifier; }
2333 
2334   // Set the vector len manually
2335   void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }
2336 
2337   // Set revert rex_vex_w for avx encoding
2338   void set_rex_vex_w_reverted(void) { _rex_vex_w_reverted = true; }
2339 
2340   // Set rex_vex_w based on state
2341   void set_rex_vex_w(bool state) { _rex_vex_w = state; }
2342 
2343   // Set the instruction to be encoded in AVX mode
2344   void set_is_legacy_mode(void) { _legacy_mode = true; }
2345 
2346   // Set the current instuction to be encoded as an EVEX instuction
2347   void set_is_evex_instruction(void) { _is_evex_instruction = true; }
2348 
2349   // Internal encoding data used in compressed immediate offset programming
2350   void set_evex_encoding(int value) { _evex_encoding = value; }
2351 
2352   // Set the Evex.Z field to be used to clear all non directed XMM/YMM/ZMM components
2353   void reset_is_clear_context(void) { _is_clear_context = false; }
2354 
2355   // Map back to current asembler so that we can manage object level assocation
2356   void set_current_assembler(Assembler *current_assembler) { _current_assembler = current_assembler; }
2357 
2358   // Address modifiers used for compressed displacement calculation
2359   void set_address_attributes(int tuple_type, int input_size_in_bits) {
2360     if (VM_Version::supports_evex()) {
2361       _tuple_type = tuple_type;
2362       _input_size_in_bits = input_size_in_bits;
2363     }
2364   }
2365 
2366   // Set embedded opmask register specifier.
2367   void set_embedded_opmask_register_specifier(KRegister mask) {
2368     _embedded_opmask_register_specifier = (*mask).encoding() &amp; 0x7;
2369   }
2370 
2371 };
2372 
2373 #endif // CPU_X86_ASSEMBLER_X86_HPP
    </pre>
  </body>
</html>
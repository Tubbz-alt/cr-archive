<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;nativeInst_x86.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/safepointMechanism.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;utilities/powerOfTwo.hpp&quot;
  42 #include &quot;vmreg_x86.inline.hpp&quot;
  43 
  44 
  45 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  46 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  47 // fast versions of NegF/NegD and AbsF/AbsD.
  48 
  49 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  50 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  51   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  52   // of 128-bits operands for SSE instructions.
  53   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  54   // Store the value to a 128-bits operand.
  55   operand[0] = lo;
  56   operand[1] = hi;
  57   return operand;
  58 }
  59 
  60 // Buffer for 128-bits masks used by SSE instructions.
  61 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  62 
  63 // Static initialization during VM startup.
  64 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  65 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  66 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  67 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  68 
  69 
  70 NEEDS_CLEANUP // remove this definitions ?
  71 const Register IC_Klass    = rax;   // where the IC klass is cached
  72 const Register SYNC_header = rax;   // synchronization header
  73 const Register SHIFT_count = rcx;   // where count for shift operations must be
  74 
  75 #define __ _masm-&gt;
  76 
  77 
  78 static void select_different_registers(Register preserve,
  79                                        Register extra,
  80                                        Register &amp;tmp1,
  81                                        Register &amp;tmp2) {
  82   if (tmp1 == preserve) {
  83     assert_different_registers(tmp1, tmp2, extra);
  84     tmp1 = extra;
  85   } else if (tmp2 == preserve) {
  86     assert_different_registers(tmp1, tmp2, extra);
  87     tmp2 = extra;
  88   }
  89   assert_different_registers(preserve, tmp1, tmp2);
  90 }
  91 
  92 
  93 
  94 static void select_different_registers(Register preserve,
  95                                        Register extra,
  96                                        Register &amp;tmp1,
  97                                        Register &amp;tmp2,
  98                                        Register &amp;tmp3) {
  99   if (tmp1 == preserve) {
 100     assert_different_registers(tmp1, tmp2, tmp3, extra);
 101     tmp1 = extra;
 102   } else if (tmp2 == preserve) {
 103     assert_different_registers(tmp1, tmp2, tmp3, extra);
 104     tmp2 = extra;
 105   } else if (tmp3 == preserve) {
 106     assert_different_registers(tmp1, tmp2, tmp3, extra);
 107     tmp3 = extra;
 108   }
 109   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 110 }
 111 
 112 
 113 
 114 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 115   if (opr-&gt;is_constant()) {
 116     LIR_Const* constant = opr-&gt;as_constant_ptr();
 117     switch (constant-&gt;type()) {
 118       case T_INT: {
 119         return true;
 120       }
 121 
 122       default:
 123         return false;
 124     }
 125   }
 126   return false;
 127 }
 128 
 129 
 130 LIR_Opr LIR_Assembler::receiverOpr() {
 131   return FrameMap::receiver_opr;
 132 }
 133 
 134 LIR_Opr LIR_Assembler::osrBufferPointer() {
 135   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 136 }
 137 
 138 //--------------fpu register translations-----------------------
 139 
 140 
 141 address LIR_Assembler::float_constant(float f) {
 142   address const_addr = __ float_constant(f);
 143   if (const_addr == NULL) {
 144     bailout(&quot;const section overflow&quot;);
 145     return __ code()-&gt;consts()-&gt;start();
 146   } else {
 147     return const_addr;
 148   }
 149 }
 150 
 151 
 152 address LIR_Assembler::double_constant(double d) {
 153   address const_addr = __ double_constant(d);
 154   if (const_addr == NULL) {
 155     bailout(&quot;const section overflow&quot;);
 156     return __ code()-&gt;consts()-&gt;start();
 157   } else {
 158     return const_addr;
 159   }
 160 }
 161 
 162 #ifndef _LP64
 163 void LIR_Assembler::fpop() {
 164   __ fpop();
 165 }
 166 
 167 void LIR_Assembler::fxch(int i) {
 168   __ fxch(i);
 169 }
 170 
 171 void LIR_Assembler::fld(int i) {
 172   __ fld_s(i);
 173 }
 174 
 175 void LIR_Assembler::ffree(int i) {
 176   __ ffree(i);
 177 }
 178 #endif // !_LP64
 179 
 180 void LIR_Assembler::breakpoint() {
 181   __ int3();
 182 }
 183 
 184 void LIR_Assembler::push(LIR_Opr opr) {
 185   if (opr-&gt;is_single_cpu()) {
 186     __ push_reg(opr-&gt;as_register());
 187   } else if (opr-&gt;is_double_cpu()) {
 188     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 189     __ push_reg(opr-&gt;as_register_lo());
 190   } else if (opr-&gt;is_stack()) {
 191     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 192   } else if (opr-&gt;is_constant()) {
 193     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 194     if (const_opr-&gt;type() == T_OBJECT) {
 195       __ push_oop(const_opr-&gt;as_jobject());
 196     } else if (const_opr-&gt;type() == T_INT) {
 197       __ push_jint(const_opr-&gt;as_jint());
 198     } else {
 199       ShouldNotReachHere();
 200     }
 201 
 202   } else {
 203     ShouldNotReachHere();
 204   }
 205 }
 206 
 207 void LIR_Assembler::pop(LIR_Opr opr) {
 208   if (opr-&gt;is_single_cpu()) {
 209     __ pop_reg(opr-&gt;as_register());
 210   } else {
 211     ShouldNotReachHere();
 212   }
 213 }
 214 
 215 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 216   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 217 }
 218 
 219 //-------------------------------------------
 220 
 221 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 222   return as_Address(addr, rscratch1);
 223 }
 224 
 225 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 226   if (addr-&gt;base()-&gt;is_illegal()) {
 227     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 228     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 229     if (! __ reachable(laddr)) {
 230       __ movptr(tmp, laddr.addr());
 231       Address res(tmp, 0);
 232       return res;
 233     } else {
 234       return __ as_Address(laddr);
 235     }
 236   }
 237 
 238   Register base = addr-&gt;base()-&gt;as_pointer_register();
 239 
 240   if (addr-&gt;index()-&gt;is_illegal()) {
 241     return Address( base, addr-&gt;disp());
 242   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 243     Register index = addr-&gt;index()-&gt;as_pointer_register();
 244     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 245   } else if (addr-&gt;index()-&gt;is_constant()) {
 246     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 247     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 248 
 249     return Address(base, addr_offset);
 250   } else {
 251     Unimplemented();
 252     return Address();
 253   }
 254 }
 255 
 256 
 257 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 258   Address base = as_Address(addr);
 259   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 260 }
 261 
 262 
 263 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 264   return as_Address(addr);
 265 }
 266 
 267 
 268 void LIR_Assembler::osr_entry() {
 269   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 270   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 271   ValueStack* entry_state = osr_entry-&gt;state();
 272   int number_of_locks = entry_state-&gt;locks_size();
 273 
 274   // we jump here if osr happens with the interpreter
 275   // state set up to continue at the beginning of the
 276   // loop that triggered osr - in particular, we have
 277   // the following registers setup:
 278   //
 279   // rcx: osr buffer
 280   //
 281 
 282   // build frame
 283   ciMethod* m = compilation()-&gt;method();
 284   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 285 
 286   // OSR buffer is
 287   //
 288   // locals[nlocals-1..0]
 289   // monitors[0..number_of_locks]
 290   //
 291   // locals is a direct copy of the interpreter frame so in the osr buffer
 292   // so first slot in the local array is the last local from the interpreter
 293   // and last slot is local[0] (receiver) from the interpreter
 294   //
 295   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 296   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 297   // in the interpreter frame (the method lock if a sync method)
 298 
 299   // Initialize monitors in the compiled activation.
 300   //   rcx: pointer to osr buffer
 301   //
 302   // All other registers are dead at this point and the locals will be
 303   // copied into place by code emitted in the IR.
 304 
 305   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 306   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 307     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 308       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 309     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 310     // the OSR buffer using 2 word entries: first the lock and then
 311     // the oop.
 312     for (int i = 0; i &lt; number_of_locks; i++) {
 313       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 314 #ifdef ASSERT
 315       // verify the interpreter&#39;s monitor has a non-null object
 316       {
 317         Label L;
 318         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 319         __ jcc(Assembler::notZero, L);
 320         __ stop(&quot;locked object is NULL&quot;);
 321         __ bind(L);
 322       }
 323 #endif
 324       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 325       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 327       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 328     }
 329   }
 330 }
 331 
 332 
 333 // inline cache check; done before the frame is built.
 334 int LIR_Assembler::check_icache() {
 335   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 336   Register ic_klass = IC_Klass;
 337   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 338   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 339   if (!do_post_padding) {
 340     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 341     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 342   }
 343   int offset = __ offset();
 344   __ inline_cache_check(receiver, IC_Klass);
 345   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 346   if (do_post_padding) {
 347     // force alignment after the cache check.
 348     // It&#39;s been verified to be aligned if !VerifyOops
 349     __ align(CodeEntryAlignment);
 350   }
 351   return offset;
 352 }
 353 
 354 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 355   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 356   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 357 
 358   Label L_skip_barrier;
 359   Register klass = rscratch1;
 360   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 361   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 362 
 363   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 364   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 365 
 366   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 367 
 368   __ bind(L_skip_barrier);
 369 }
 370 
 371 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 372   jobject o = NULL;
 373   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 374   __ movoop(reg, o);
 375   patching_epilog(patch, lir_patch_normal, reg, info);
 376 }
 377 
 378 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 379   Metadata* o = NULL;
 380   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 381   __ mov_metadata(reg, o);
 382   patching_epilog(patch, lir_patch_normal, reg, info);
 383 }
 384 
 385 // This specifies the rsp decrement needed to build the frame
 386 int LIR_Assembler::initial_frame_size_in_bytes() const {
 387   // if rounding, must let FrameMap know!
 388 
 389   // The frame_map records size in slots (32bit word)
 390 
 391   // subtract two words to account for return address and link
 392   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 393 }
 394 
 395 
 396 int LIR_Assembler::emit_exception_handler() {
 397   // if the last instruction is a call (typically to do a throw which
 398   // is coming at the end after block reordering) the return address
 399   // must still point into the code area in order to avoid assertion
 400   // failures when searching for the corresponding bci =&gt; add a nop
 401   // (was bug 5/14/1999 - gri)
 402   __ nop();
 403 
 404   // generate code for exception handler
 405   address handler_base = __ start_a_stub(exception_handler_size());
 406   if (handler_base == NULL) {
 407     // not enough space left for the handler
 408     bailout(&quot;exception handler overflow&quot;);
 409     return -1;
 410   }
 411 
 412   int offset = code_offset();
 413 
 414   // the exception oop and pc are in rax, and rdx
 415   // no other registers need to be preserved, so invalidate them
 416   __ invalidate_registers(false, true, true, false, true, true);
 417 
 418   // check that there is really an exception
 419   __ verify_not_null_oop(rax);
 420 
 421   // search an exception handler (rax: exception oop, rdx: throwing pc)
 422   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 423   __ should_not_reach_here();
 424   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 425   __ end_a_stub();
 426 
 427   return offset;
 428 }
 429 
 430 
 431 // Emit the code to remove the frame from the stack in the exception
 432 // unwind path.
 433 int LIR_Assembler::emit_unwind_handler() {
 434 #ifndef PRODUCT
 435   if (CommentedAssembly) {
 436     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 437   }
 438 #endif
 439 
 440   int offset = code_offset();
 441 
 442   // Fetch the exception from TLS and clear out exception related thread state
 443   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 444   NOT_LP64(__ get_thread(rsi));
 445   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 446   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 447   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 448 
 449   __ bind(_unwind_handler_entry);
 450   __ verify_not_null_oop(rax);
 451   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 452     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 453   }
 454 
 455   // Preform needed unlocking
 456   MonitorExitStub* stub = NULL;
 457   if (method()-&gt;is_synchronized()) {
 458     monitor_address(0, FrameMap::rax_opr);
 459     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 460     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 461     __ bind(*stub-&gt;continuation());
 462   }
 463 
 464   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 465 #ifdef _LP64
 466     __ mov(rdi, r15_thread);
 467     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 468 #else
 469     __ get_thread(rax);
 470     __ movptr(Address(rsp, 0), rax);
 471     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 472 #endif
 473     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 474   }
 475 
 476   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 477     __ mov(rax, rbx);  // Restore the exception
 478   }
 479 
 480   // remove the activation and dispatch to the unwind handler
 481   __ remove_frame(initial_frame_size_in_bytes());
 482   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 483 
 484   // Emit the slow path assembly
 485   if (stub != NULL) {
 486     stub-&gt;emit_code(this);
 487   }
 488 
 489   return offset;
 490 }
 491 
 492 
 493 int LIR_Assembler::emit_deopt_handler() {
 494   // if the last instruction is a call (typically to do a throw which
 495   // is coming at the end after block reordering) the return address
 496   // must still point into the code area in order to avoid assertion
 497   // failures when searching for the corresponding bci =&gt; add a nop
 498   // (was bug 5/14/1999 - gri)
 499   __ nop();
 500 
 501   // generate code for exception handler
 502   address handler_base = __ start_a_stub(deopt_handler_size());
 503   if (handler_base == NULL) {
 504     // not enough space left for the handler
 505     bailout(&quot;deopt handler overflow&quot;);
 506     return -1;
 507   }
 508 
 509   int offset = code_offset();
 510   InternalAddress here(__ pc());
 511 
 512   __ pushptr(here.addr());
 513   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 514   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 515   __ end_a_stub();
 516 
 517   return offset;
 518 }
 519 
 520 
 521 void LIR_Assembler::return_op(LIR_Opr result) {
 522   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 523   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 524     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 525   }
 526 
 527   // Pop the stack before the safepoint code
 528   __ remove_frame(initial_frame_size_in_bytes());
 529 
 530   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 531     __ reserved_stack_check();
 532   }
 533 
 534   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 535 
 536   // Note: we do not need to round double result; float result has the right precision
 537   // the poll sets the condition code, but no data registers
 538 
 539   if (SafepointMechanism::uses_thread_local_poll()) {
 540 #ifdef _LP64
 541     const Register poll_addr = rscratch1;
 542     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 543 #else
 544     const Register poll_addr = rbx;
 545     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 546     __ get_thread(poll_addr);
 547     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 548 #endif
 549     __ relocate(relocInfo::poll_return_type);
 550     __ testl(rax, Address(poll_addr, 0));
 551   } else {
 552     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 553 
 554     if (Assembler::is_polling_page_far()) {
 555       __ lea(rscratch1, polling_page);
 556       __ relocate(relocInfo::poll_return_type);
 557       __ testl(rax, Address(rscratch1, 0));
 558     } else {
 559       __ testl(rax, polling_page);
 560     }
 561   }
 562   __ ret(0);
 563 }
 564 
 565 
 566 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 567   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 568   int offset = __ offset();
 569   if (SafepointMechanism::uses_thread_local_poll()) {
 570 #ifdef _LP64
 571     const Register poll_addr = rscratch1;
 572     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 573 #else
 574     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 575     const Register poll_addr = tmp-&gt;as_register();
 576     __ get_thread(poll_addr);
 577     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 578 #endif
 579     add_debug_info_for_branch(info);
 580     __ relocate(relocInfo::poll_type);
 581     address pre_pc = __ pc();
 582     __ testl(rax, Address(poll_addr, 0));
 583     address post_pc = __ pc();
 584     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 585   } else {
 586     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 587     if (Assembler::is_polling_page_far()) {
 588       __ lea(rscratch1, polling_page);
 589       offset = __ offset();
 590       add_debug_info_for_branch(info);
 591       __ relocate(relocInfo::poll_type);
 592       __ testl(rax, Address(rscratch1, 0));
 593     } else {
 594       add_debug_info_for_branch(info);
 595       __ testl(rax, polling_page);
 596     }
 597   }
 598   return offset;
 599 }
 600 
 601 
 602 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 603   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 604 }
 605 
 606 void LIR_Assembler::swap_reg(Register a, Register b) {
 607   __ xchgptr(a, b);
 608 }
 609 
 610 
 611 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 612   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 613   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 614   LIR_Const* c = src-&gt;as_constant_ptr();
 615 
 616   switch (c-&gt;type()) {
 617     case T_INT: {
 618       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 619       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 620       break;
 621     }
 622 
 623     case T_ADDRESS: {
 624       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 625       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 626       break;
 627     }
 628 
 629     case T_LONG: {
 630       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 631 #ifdef _LP64
 632       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 633 #else
 634       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 635       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 636 #endif // _LP64
 637       break;
 638     }
 639 
 640     case T_OBJECT: {
 641       if (patch_code != lir_patch_none) {
 642         jobject2reg_with_patching(dest-&gt;as_register(), info);
 643       } else {
 644         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 645       }
 646       break;
 647     }
 648 
 649     case T_METADATA: {
 650       if (patch_code != lir_patch_none) {
 651         klass2reg_with_patching(dest-&gt;as_register(), info);
 652       } else {
 653         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 654       }
 655       break;
 656     }
 657 
 658     case T_FLOAT: {
 659       if (dest-&gt;is_single_xmm()) {
 660         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 661           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 662         } else {
 663           __ movflt(dest-&gt;as_xmm_float_reg(),
 664                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 665         }
 666       } else {
 667 #ifndef _LP64
 668         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 669         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 670         if (c-&gt;is_zero_float()) {
 671           __ fldz();
 672         } else if (c-&gt;is_one_float()) {
 673           __ fld1();
 674         } else {
 675           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 676         }
 677 #else
 678         ShouldNotReachHere();
 679 #endif // !_LP64
 680       }
 681       break;
 682     }
 683 
 684     case T_DOUBLE: {
 685       if (dest-&gt;is_double_xmm()) {
 686         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 687           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 688         } else {
 689           __ movdbl(dest-&gt;as_xmm_double_reg(),
 690                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 691         }
 692       } else {
 693 #ifndef _LP64
 694         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 695         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 696         if (c-&gt;is_zero_double()) {
 697           __ fldz();
 698         } else if (c-&gt;is_one_double()) {
 699           __ fld1();
 700         } else {
 701           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 702         }
 703 #else
 704         ShouldNotReachHere();
 705 #endif // !_LP64
 706       }
 707       break;
 708     }
 709 
 710     default:
 711       ShouldNotReachHere();
 712   }
 713 }
 714 
 715 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 716   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 717   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 718   LIR_Const* c = src-&gt;as_constant_ptr();
 719 
 720   switch (c-&gt;type()) {
 721     case T_INT:  // fall through
 722     case T_FLOAT:
 723       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 724       break;
 725 
 726     case T_ADDRESS:
 727       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 728       break;
 729 
 730     case T_OBJECT:
 731       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 732       break;
 733 
 734     case T_LONG:  // fall through
 735     case T_DOUBLE:
 736 #ifdef _LP64
 737       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 738                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 739 #else
 740       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 741                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 742       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 743                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 744 #endif // _LP64
 745       break;
 746 
 747     default:
 748       ShouldNotReachHere();
 749   }
 750 }
 751 
 752 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 753   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 754   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 755   LIR_Const* c = src-&gt;as_constant_ptr();
 756   LIR_Address* addr = dest-&gt;as_address_ptr();
 757 
 758   int null_check_here = code_offset();
 759   switch (type) {
 760     case T_INT:    // fall through
 761     case T_FLOAT:
 762       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 763       break;
 764 
 765     case T_ADDRESS:
 766       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 767       break;
 768 
 769     case T_OBJECT:  // fall through
 770     case T_ARRAY:
 771       if (c-&gt;as_jobject() == NULL) {
 772         if (UseCompressedOops &amp;&amp; !wide) {
 773           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 774         } else {
 775 #ifdef _LP64
 776           __ xorptr(rscratch1, rscratch1);
 777           null_check_here = code_offset();
 778           __ movptr(as_Address(addr), rscratch1);
 779 #else
 780           __ movptr(as_Address(addr), NULL_WORD);
 781 #endif
 782         }
 783       } else {
 784         if (is_literal_address(addr)) {
 785           ShouldNotReachHere();
 786           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 787         } else {
 788 #ifdef _LP64
 789           __ movoop(rscratch1, c-&gt;as_jobject());
 790           if (UseCompressedOops &amp;&amp; !wide) {
 791             __ encode_heap_oop(rscratch1);
 792             null_check_here = code_offset();
 793             __ movl(as_Address_lo(addr), rscratch1);
 794           } else {
 795             null_check_here = code_offset();
 796             __ movptr(as_Address_lo(addr), rscratch1);
 797           }
 798 #else
 799           __ movoop(as_Address(addr), c-&gt;as_jobject());
 800 #endif
 801         }
 802       }
 803       break;
 804 
 805     case T_LONG:    // fall through
 806     case T_DOUBLE:
 807 #ifdef _LP64
 808       if (is_literal_address(addr)) {
 809         ShouldNotReachHere();
 810         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 811       } else {
 812         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 813         null_check_here = code_offset();
 814         __ movptr(as_Address_lo(addr), r10);
 815       }
 816 #else
 817       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 818       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 819       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 820 #endif // _LP64
 821       break;
 822 
 823     case T_BOOLEAN: // fall through
 824     case T_BYTE:
 825       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 826       break;
 827 
 828     case T_CHAR:    // fall through
 829     case T_SHORT:
 830       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 831       break;
 832 
 833     default:
 834       ShouldNotReachHere();
 835   };
 836 
 837   if (info != NULL) {
 838     add_debug_info_for_null_check(null_check_here, info);
 839   }
 840 }
 841 
 842 
 843 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 844   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 845   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 846 
 847   // move between cpu-registers
 848   if (dest-&gt;is_single_cpu()) {
 849 #ifdef _LP64
 850     if (src-&gt;type() == T_LONG) {
 851       // Can do LONG -&gt; OBJECT
 852       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 853       return;
 854     }
 855 #endif
 856     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 857     if (src-&gt;type() == T_OBJECT) {
 858       __ verify_oop(src-&gt;as_register());
 859     }
 860     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 861 
 862   } else if (dest-&gt;is_double_cpu()) {
 863 #ifdef _LP64
 864     if (is_reference_type(src-&gt;type())) {
 865       // Surprising to me but we can see move of a long to t_object
 866       __ verify_oop(src-&gt;as_register());
 867       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 868       return;
 869     }
 870 #endif
 871     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 872     Register f_lo = src-&gt;as_register_lo();
 873     Register f_hi = src-&gt;as_register_hi();
 874     Register t_lo = dest-&gt;as_register_lo();
 875     Register t_hi = dest-&gt;as_register_hi();
 876 #ifdef _LP64
 877     assert(f_hi == f_lo, &quot;must be same&quot;);
 878     assert(t_hi == t_lo, &quot;must be same&quot;);
 879     move_regs(f_lo, t_lo);
 880 #else
 881     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 882 
 883 
 884     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 885       swap_reg(f_lo, f_hi);
 886     } else if (f_hi == t_lo) {
 887       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 888       move_regs(f_hi, t_hi);
 889       move_regs(f_lo, t_lo);
 890     } else {
 891       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 892       move_regs(f_lo, t_lo);
 893       move_regs(f_hi, t_hi);
 894     }
 895 #endif // LP64
 896 
 897 #ifndef _LP64
 898     // special moves from fpu-register to xmm-register
 899     // necessary for method results
 900   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 901     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 902     __ fld_s(Address(rsp, 0));
 903   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 904     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 905     __ fld_d(Address(rsp, 0));
 906   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 907     __ fstp_s(Address(rsp, 0));
 908     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 909   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 910     __ fstp_d(Address(rsp, 0));
 911     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 912 #endif // !_LP64
 913 
 914     // move between xmm-registers
 915   } else if (dest-&gt;is_single_xmm()) {
 916     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 917     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 918   } else if (dest-&gt;is_double_xmm()) {
 919     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 920     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 921 
 922 #ifndef _LP64
 923     // move between fpu-registers (no instruction necessary because of fpu-stack)
 924   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 925     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 926     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 927 #endif // !_LP64
 928 
 929   } else {
 930     ShouldNotReachHere();
 931   }
 932 }
 933 
 934 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 935   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 936   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 937 
 938   if (src-&gt;is_single_cpu()) {
 939     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 940     if (is_reference_type(type)) {
 941       __ verify_oop(src-&gt;as_register());
 942       __ movptr (dst, src-&gt;as_register());
 943     } else if (type == T_METADATA || type == T_ADDRESS) {
 944       __ movptr (dst, src-&gt;as_register());
 945     } else {
 946       __ movl (dst, src-&gt;as_register());
 947     }
 948 
 949   } else if (src-&gt;is_double_cpu()) {
 950     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 951     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 952     __ movptr (dstLO, src-&gt;as_register_lo());
 953     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 954 
 955   } else if (src-&gt;is_single_xmm()) {
 956     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 957     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 958 
 959   } else if (src-&gt;is_double_xmm()) {
 960     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 961     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 962 
 963 #ifndef _LP64
 964   } else if (src-&gt;is_single_fpu()) {
 965     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 966     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 967     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 968     else                   __ fst_s  (dst_addr);
 969 
 970   } else if (src-&gt;is_double_fpu()) {
 971     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
 972     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 973     if (pop_fpu_stack)     __ fstp_d (dst_addr);
 974     else                   __ fst_d  (dst_addr);
 975 #endif // !_LP64
 976 
 977   } else {
 978     ShouldNotReachHere();
 979   }
 980 }
 981 
 982 
 983 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
 984   LIR_Address* to_addr = dest-&gt;as_address_ptr();
 985   PatchingStub* patch = NULL;
 986   Register compressed_src = rscratch1;
 987 
 988   if (is_reference_type(type)) {
 989     __ verify_oop(src-&gt;as_register());
 990 #ifdef _LP64
 991     if (UseCompressedOops &amp;&amp; !wide) {
 992       __ movptr(compressed_src, src-&gt;as_register());
 993       __ encode_heap_oop(compressed_src);
 994       if (patch_code != lir_patch_none) {
 995         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
 996       }
 997     }
 998 #endif
 999   }
1000 
1001   if (patch_code != lir_patch_none) {
1002     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1003     Address toa = as_Address(to_addr);
1004     assert(toa.disp() != 0, &quot;must have&quot;);
1005   }
1006 
1007   int null_check_here = code_offset();
1008   switch (type) {
1009     case T_FLOAT: {
1010 #ifdef _LP64
1011       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1012       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1013 #else
1014       if (src-&gt;is_single_xmm()) {
1015         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1016       } else {
1017         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1018         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1019         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1020         else                    __ fst_s (as_Address(to_addr));
1021       }
1022 #endif // _LP64
1023       break;
1024     }
1025 
1026     case T_DOUBLE: {
1027 #ifdef _LP64
1028       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1029       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1030 #else
1031       if (src-&gt;is_double_xmm()) {
1032         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1033       } else {
1034         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1035         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1036         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1037         else                    __ fst_d (as_Address(to_addr));
1038       }
1039 #endif // _LP64
1040       break;
1041     }
1042 
1043     case T_ARRAY:   // fall through
1044     case T_OBJECT:  // fall through
1045       if (UseCompressedOops &amp;&amp; !wide) {
1046         __ movl(as_Address(to_addr), compressed_src);
1047       } else {
1048         __ movptr(as_Address(to_addr), src-&gt;as_register());
1049       }
1050       break;
1051     case T_METADATA:
1052       // We get here to store a method pointer to the stack to pass to
1053       // a dtrace runtime call. This can&#39;t work on 64 bit with
1054       // compressed klass ptrs: T_METADATA can be a compressed klass
1055       // ptr or a 64 bit method pointer.
1056       LP64_ONLY(ShouldNotReachHere());
1057       __ movptr(as_Address(to_addr), src-&gt;as_register());
1058       break;
1059     case T_ADDRESS:
1060       __ movptr(as_Address(to_addr), src-&gt;as_register());
1061       break;
1062     case T_INT:
1063       __ movl(as_Address(to_addr), src-&gt;as_register());
1064       break;
1065 
1066     case T_LONG: {
1067       Register from_lo = src-&gt;as_register_lo();
1068       Register from_hi = src-&gt;as_register_hi();
1069 #ifdef _LP64
1070       __ movptr(as_Address_lo(to_addr), from_lo);
1071 #else
1072       Register base = to_addr-&gt;base()-&gt;as_register();
1073       Register index = noreg;
1074       if (to_addr-&gt;index()-&gt;is_register()) {
1075         index = to_addr-&gt;index()-&gt;as_register();
1076       }
1077       if (base == from_lo || index == from_lo) {
1078         assert(base != from_hi, &quot;can&#39;t be&quot;);
1079         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1080         __ movl(as_Address_hi(to_addr), from_hi);
1081         if (patch != NULL) {
1082           patching_epilog(patch, lir_patch_high, base, info);
1083           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1084           patch_code = lir_patch_low;
1085         }
1086         __ movl(as_Address_lo(to_addr), from_lo);
1087       } else {
1088         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1089         __ movl(as_Address_lo(to_addr), from_lo);
1090         if (patch != NULL) {
1091           patching_epilog(patch, lir_patch_low, base, info);
1092           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1093           patch_code = lir_patch_high;
1094         }
1095         __ movl(as_Address_hi(to_addr), from_hi);
1096       }
1097 #endif // _LP64
1098       break;
1099     }
1100 
1101     case T_BYTE:    // fall through
1102     case T_BOOLEAN: {
1103       Register src_reg = src-&gt;as_register();
1104       Address dst_addr = as_Address(to_addr);
1105       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1106       __ movb(dst_addr, src_reg);
1107       break;
1108     }
1109 
1110     case T_CHAR:    // fall through
1111     case T_SHORT:
1112       __ movw(as_Address(to_addr), src-&gt;as_register());
1113       break;
1114 
1115     default:
1116       ShouldNotReachHere();
1117   }
1118   if (info != NULL) {
1119     add_debug_info_for_null_check(null_check_here, info);
1120   }
1121 
1122   if (patch_code != lir_patch_none) {
1123     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1124   }
1125 }
1126 
1127 
1128 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1129   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1130   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1131 
1132   if (dest-&gt;is_single_cpu()) {
1133     if (is_reference_type(type)) {
1134       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1135       __ verify_oop(dest-&gt;as_register());
1136     } else if (type == T_METADATA || type == T_ADDRESS) {
1137       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1138     } else {
1139       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1140     }
1141 
1142   } else if (dest-&gt;is_double_cpu()) {
1143     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1144     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1145     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1146     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1147 
1148   } else if (dest-&gt;is_single_xmm()) {
1149     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1150     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1151 
1152   } else if (dest-&gt;is_double_xmm()) {
1153     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1154     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1155 
1156 #ifndef _LP64
1157   } else if (dest-&gt;is_single_fpu()) {
1158     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1159     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1160     __ fld_s(src_addr);
1161 
1162   } else if (dest-&gt;is_double_fpu()) {
1163     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1164     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1165     __ fld_d(src_addr);
1166 #endif // _LP64
1167 
1168   } else {
1169     ShouldNotReachHere();
1170   }
1171 }
1172 
1173 
1174 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1175   if (src-&gt;is_single_stack()) {
1176     if (is_reference_type(type)) {
1177       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1178       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1179     } else {
1180 #ifndef _LP64
1181       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1182       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1183 #else
1184       //no pushl on 64bits
1185       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1186       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1187 #endif
1188     }
1189 
1190   } else if (src-&gt;is_double_stack()) {
1191 #ifdef _LP64
1192     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1193     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1194 #else
1195     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1196     // push and pop the part at src + wordSize, adding wordSize for the previous push
1197     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1198     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1199     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1200 #endif // _LP64
1201 
1202   } else {
1203     ShouldNotReachHere();
1204   }
1205 }
1206 
1207 
1208 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1209   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1210   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1211 
1212   LIR_Address* addr = src-&gt;as_address_ptr();
1213   Address from_addr = as_Address(addr);
1214 
1215   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1216     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1217   }
1218 
1219   switch (type) {
1220     case T_BOOLEAN: // fall through
1221     case T_BYTE:    // fall through
1222     case T_CHAR:    // fall through
1223     case T_SHORT:
1224       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1225         // on pre P6 processors we may get partial register stalls
1226         // so blow away the value of to_rinfo before loading a
1227         // partial word into it.  Do it here so that it precedes
1228         // the potential patch point below.
1229         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1230       }
1231       break;
1232    default:
1233      break;
1234   }
1235 
1236   PatchingStub* patch = NULL;
1237   if (patch_code != lir_patch_none) {
1238     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1239     assert(from_addr.disp() != 0, &quot;must have&quot;);
1240   }
1241   if (info != NULL) {
1242     add_debug_info_for_null_check_here(info);
1243   }
1244 
1245   switch (type) {
1246     case T_FLOAT: {
1247       if (dest-&gt;is_single_xmm()) {
1248         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1249       } else {
1250 #ifndef _LP64
1251         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1252         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1253         __ fld_s(from_addr);
1254 #else
1255         ShouldNotReachHere();
1256 #endif // !LP64
1257       }
1258       break;
1259     }
1260 
1261     case T_DOUBLE: {
1262       if (dest-&gt;is_double_xmm()) {
1263         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1264       } else {
1265 #ifndef _LP64
1266         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1267         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1268         __ fld_d(from_addr);
1269 #else
1270         ShouldNotReachHere();
1271 #endif // !LP64
1272       }
1273       break;
1274     }
1275 
1276     case T_OBJECT:  // fall through
1277     case T_ARRAY:   // fall through
1278       if (UseCompressedOops &amp;&amp; !wide) {
1279         __ movl(dest-&gt;as_register(), from_addr);
1280       } else {
1281         __ movptr(dest-&gt;as_register(), from_addr);
1282       }
1283       break;
1284 
1285     case T_ADDRESS:
1286       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1287         __ movl(dest-&gt;as_register(), from_addr);
1288       } else {
1289         __ movptr(dest-&gt;as_register(), from_addr);
1290       }
1291       break;
1292     case T_INT:
1293       __ movl(dest-&gt;as_register(), from_addr);
1294       break;
1295 
1296     case T_LONG: {
1297       Register to_lo = dest-&gt;as_register_lo();
1298       Register to_hi = dest-&gt;as_register_hi();
1299 #ifdef _LP64
1300       __ movptr(to_lo, as_Address_lo(addr));
1301 #else
1302       Register base = addr-&gt;base()-&gt;as_register();
1303       Register index = noreg;
1304       if (addr-&gt;index()-&gt;is_register()) {
1305         index = addr-&gt;index()-&gt;as_register();
1306       }
1307       if ((base == to_lo &amp;&amp; index == to_hi) ||
1308           (base == to_hi &amp;&amp; index == to_lo)) {
1309         // addresses with 2 registers are only formed as a result of
1310         // array access so this code will never have to deal with
1311         // patches or null checks.
1312         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1313         __ lea(to_hi, as_Address(addr));
1314         __ movl(to_lo, Address(to_hi, 0));
1315         __ movl(to_hi, Address(to_hi, BytesPerWord));
1316       } else if (base == to_lo || index == to_lo) {
1317         assert(base != to_hi, &quot;can&#39;t be&quot;);
1318         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1319         __ movl(to_hi, as_Address_hi(addr));
1320         if (patch != NULL) {
1321           patching_epilog(patch, lir_patch_high, base, info);
1322           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1323           patch_code = lir_patch_low;
1324         }
1325         __ movl(to_lo, as_Address_lo(addr));
1326       } else {
1327         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1328         __ movl(to_lo, as_Address_lo(addr));
1329         if (patch != NULL) {
1330           patching_epilog(patch, lir_patch_low, base, info);
1331           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1332           patch_code = lir_patch_high;
1333         }
1334         __ movl(to_hi, as_Address_hi(addr));
1335       }
1336 #endif // _LP64
1337       break;
1338     }
1339 
1340     case T_BOOLEAN: // fall through
1341     case T_BYTE: {
1342       Register dest_reg = dest-&gt;as_register();
1343       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1344       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1345         __ movsbl(dest_reg, from_addr);
1346       } else {
1347         __ movb(dest_reg, from_addr);
1348         __ shll(dest_reg, 24);
1349         __ sarl(dest_reg, 24);
1350       }
1351       break;
1352     }
1353 
1354     case T_CHAR: {
1355       Register dest_reg = dest-&gt;as_register();
1356       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1357       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1358         __ movzwl(dest_reg, from_addr);
1359       } else {
1360         __ movw(dest_reg, from_addr);
1361       }
1362       break;
1363     }
1364 
1365     case T_SHORT: {
1366       Register dest_reg = dest-&gt;as_register();
1367       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1368         __ movswl(dest_reg, from_addr);
1369       } else {
1370         __ movw(dest_reg, from_addr);
1371         __ shll(dest_reg, 16);
1372         __ sarl(dest_reg, 16);
1373       }
1374       break;
1375     }
1376 
1377     default:
1378       ShouldNotReachHere();
1379   }
1380 
1381   if (patch != NULL) {
1382     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1383   }
1384 
1385   if (is_reference_type(type)) {
1386 #ifdef _LP64
1387     if (UseCompressedOops &amp;&amp; !wide) {
1388       __ decode_heap_oop(dest-&gt;as_register());
1389     }
1390 #endif
1391 
1392     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1393     if (!UseZGC) {
1394       __ verify_oop(dest-&gt;as_register());
1395     }
1396   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1397 #ifdef _LP64
1398     if (UseCompressedClassPointers) {
1399       __ decode_klass_not_null(dest-&gt;as_register());
1400     }
1401 #endif
1402   }
1403 }
1404 
1405 
1406 NEEDS_CLEANUP; // This could be static?
1407 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1408   int elem_size = type2aelembytes(type);
1409   switch (elem_size) {
1410     case 1: return Address::times_1;
1411     case 2: return Address::times_2;
1412     case 4: return Address::times_4;
1413     case 8: return Address::times_8;
1414   }
1415   ShouldNotReachHere();
1416   return Address::no_scale;
1417 }
1418 
1419 
1420 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1421   switch (op-&gt;code()) {
1422     case lir_idiv:
1423     case lir_irem:
1424       arithmetic_idiv(op-&gt;code(),
1425                       op-&gt;in_opr1(),
1426                       op-&gt;in_opr2(),
1427                       op-&gt;in_opr3(),
1428                       op-&gt;result_opr(),
1429                       op-&gt;info());
1430       break;
1431     case lir_fmad:
1432       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1433               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1434               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1435               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1436       break;
1437     case lir_fmaf:
1438       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1439               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1440               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1441               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1442       break;
1443     default:      ShouldNotReachHere(); break;
1444   }
1445 }
1446 
1447 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1448 #ifdef ASSERT
1449   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1450   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1451   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1452 #endif
1453 
1454   if (op-&gt;cond() == lir_cond_always) {
1455     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1456     __ jmp (*(op-&gt;label()));
1457   } else {
1458     Assembler::Condition acond = Assembler::zero;
1459     if (op-&gt;code() == lir_cond_float_branch) {
1460       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1461       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1462       switch(op-&gt;cond()) {
1463         case lir_cond_equal:        acond = Assembler::equal;      break;
1464         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1465         case lir_cond_less:         acond = Assembler::below;      break;
1466         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1467         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1468         case lir_cond_greater:      acond = Assembler::above;      break;
1469         default:                         ShouldNotReachHere();
1470       }
1471     } else {
1472       switch (op-&gt;cond()) {
1473         case lir_cond_equal:        acond = Assembler::equal;       break;
1474         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1475         case lir_cond_less:         acond = Assembler::less;        break;
1476         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1477         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1478         case lir_cond_greater:      acond = Assembler::greater;     break;
1479         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1480         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1481         default:                         ShouldNotReachHere();
1482       }
1483     }
1484     __ jcc(acond,*(op-&gt;label()));
1485   }
1486 }
1487 
1488 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1489   LIR_Opr src  = op-&gt;in_opr();
1490   LIR_Opr dest = op-&gt;result_opr();
1491 
1492   switch (op-&gt;bytecode()) {
1493     case Bytecodes::_i2l:
1494 #ifdef _LP64
1495       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1496 #else
1497       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1498       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1499       __ sarl(dest-&gt;as_register_hi(), 31);
1500 #endif // LP64
1501       break;
1502 
1503     case Bytecodes::_l2i:
1504 #ifdef _LP64
1505       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1506 #else
1507       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1508 #endif
1509       break;
1510 
1511     case Bytecodes::_i2b:
1512       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1513       __ sign_extend_byte(dest-&gt;as_register());
1514       break;
1515 
1516     case Bytecodes::_i2c:
1517       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1518       __ andl(dest-&gt;as_register(), 0xFFFF);
1519       break;
1520 
1521     case Bytecodes::_i2s:
1522       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1523       __ sign_extend_short(dest-&gt;as_register());
1524       break;
1525 
1526 
1527 #ifdef _LP64
1528     case Bytecodes::_f2d:
1529       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1530       break;
1531 
1532     case Bytecodes::_d2f:
1533       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1534       break;
1535 
1536     case Bytecodes::_i2f:
1537       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1538       break;
1539 
1540     case Bytecodes::_i2d:
1541       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1542       break;
1543 
1544     case Bytecodes::_l2f:
1545       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1546       break;
1547 
1548     case Bytecodes::_l2d:
1549       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1550       break;
1551 
1552     case Bytecodes::_f2i:
1553       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1554       break;
1555 
1556     case Bytecodes::_d2i:
1557       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1558       break;
1559 
1560     case Bytecodes::_f2l:
1561       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1562       break;
1563 
1564     case Bytecodes::_d2l:
1565       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1566       break;
1567 #else
1568     case Bytecodes::_f2d:
1569     case Bytecodes::_d2f:
1570       if (dest-&gt;is_single_xmm()) {
1571         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1572       } else if (dest-&gt;is_double_xmm()) {
1573         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1574       } else {
1575         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1576         // do nothing (float result is rounded later through spilling)
1577       }
1578       break;
1579 
1580     case Bytecodes::_i2f:
1581     case Bytecodes::_i2d:
1582       if (dest-&gt;is_single_xmm()) {
1583         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1584       } else if (dest-&gt;is_double_xmm()) {
1585         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1586       } else {
1587         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1588         __ movl(Address(rsp, 0), src-&gt;as_register());
1589         __ fild_s(Address(rsp, 0));
1590       }
1591       break;
1592 
1593     case Bytecodes::_l2f:
1594     case Bytecodes::_l2d:
1595       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1596       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1597       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1598       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1599       __ fild_d(Address(rsp, 0));
1600       // float result is rounded later through spilling
1601       break;
1602 
1603     case Bytecodes::_f2i:
1604     case Bytecodes::_d2i:
1605       if (src-&gt;is_single_xmm()) {
1606         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1607       } else if (src-&gt;is_double_xmm()) {
1608         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1609       } else {
1610         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1611         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1612         __ fist_s(Address(rsp, 0));
1613         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1614         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1615       }
1616       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1617       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1618       __ cmpl(dest-&gt;as_register(), 0x80000000);
1619       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1620       __ bind(*op-&gt;stub()-&gt;continuation());
1621       break;
1622 
1623     case Bytecodes::_f2l:
1624     case Bytecodes::_d2l:
1625       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1626       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1627       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1628 
1629       // instruction sequence too long to inline it here
1630       {
1631         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1632       }
1633       break;
1634 #endif // _LP64
1635 
1636     default: ShouldNotReachHere();
1637   }
1638 }
1639 
1640 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1641   if (op-&gt;init_check()) {
1642     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1643     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1644                     InstanceKlass::init_state_offset()),
1645                     InstanceKlass::fully_initialized);
1646     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1647   }
1648   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1649                      op-&gt;tmp1()-&gt;as_register(),
1650                      op-&gt;tmp2()-&gt;as_register(),
1651                      op-&gt;header_size(),
1652                      op-&gt;object_size(),
1653                      op-&gt;klass()-&gt;as_register(),
1654                      *op-&gt;stub()-&gt;entry());
1655   __ bind(*op-&gt;stub()-&gt;continuation());
1656 }
1657 
1658 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1659   Register len =  op-&gt;len()-&gt;as_register();
1660   LP64_ONLY( __ movslq(len, len); )
1661 
1662   if (UseSlowPath ||
1663       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1664       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1665     __ jmp(*op-&gt;stub()-&gt;entry());
1666   } else {
1667     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1668     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1669     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1670     if (len == tmp1) {
1671       tmp1 = tmp3;
1672     } else if (len == tmp2) {
1673       tmp2 = tmp3;
1674     } else if (len == tmp3) {
1675       // everything is ok
1676     } else {
1677       __ mov(tmp3, len);
1678     }
1679     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1680                       len,
1681                       tmp1,
1682                       tmp2,
1683                       arrayOopDesc::header_size(op-&gt;type()),
1684                       array_element_size(op-&gt;type()),
1685                       op-&gt;klass()-&gt;as_register(),
1686                       *op-&gt;stub()-&gt;entry());
1687   }
1688   __ bind(*op-&gt;stub()-&gt;continuation());
1689 }
1690 
1691 void LIR_Assembler::type_profile_helper(Register mdo,
1692                                         ciMethodData *md, ciProfileData *data,
1693                                         Register recv, Label* update_done) {
1694   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1695     Label next_test;
1696     // See if the receiver is receiver[n].
1697     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1698     __ jccb(Assembler::notEqual, next_test);
1699     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1700     __ addptr(data_addr, DataLayout::counter_increment);
1701     __ jmp(*update_done);
1702     __ bind(next_test);
1703   }
1704 
1705   // Didn&#39;t find receiver; find next empty slot and fill it in
1706   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1707     Label next_test;
1708     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1709     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1710     __ jccb(Assembler::notEqual, next_test);
1711     __ movptr(recv_addr, recv);
1712     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1713     __ jmp(*update_done);
1714     __ bind(next_test);
1715   }
1716 }
1717 
1718 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1719   // we always need a stub for the failure case.
1720   CodeStub* stub = op-&gt;stub();
1721   Register obj = op-&gt;object()-&gt;as_register();
1722   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1723   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1724   Register dst = op-&gt;result_opr()-&gt;as_register();
1725   ciKlass* k = op-&gt;klass();
1726   Register Rtmp1 = noreg;
1727 
1728   // check if it needs to be profiled
1729   ciMethodData* md = NULL;
1730   ciProfileData* data = NULL;
1731 
1732   if (op-&gt;should_profile()) {
1733     ciMethod* method = op-&gt;profiled_method();
1734     assert(method != NULL, &quot;Should have method&quot;);
1735     int bci = op-&gt;profiled_bci();
1736     md = method-&gt;method_data_or_null();
1737     assert(md != NULL, &quot;Sanity&quot;);
1738     data = md-&gt;bci_to_data(bci);
1739     assert(data != NULL,                &quot;need data for type check&quot;);
1740     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1741   }
1742   Label profile_cast_success, profile_cast_failure;
1743   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1744   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1745 
1746   if (obj == k_RInfo) {
1747     k_RInfo = dst;
1748   } else if (obj == klass_RInfo) {
1749     klass_RInfo = dst;
1750   }
1751   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1752     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1753   } else {
1754     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1755     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1756   }
1757 
1758   assert_different_registers(obj, k_RInfo, klass_RInfo);
1759 
1760   __ cmpptr(obj, (int32_t)NULL_WORD);
1761   if (op-&gt;should_profile()) {
1762     Label not_null;
1763     __ jccb(Assembler::notEqual, not_null);
1764     // Object is null; update MDO and exit
1765     Register mdo  = klass_RInfo;
1766     __ mov_metadata(mdo, md-&gt;constant_encoding());
1767     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1768     int header_bits = BitData::null_seen_byte_constant();
1769     __ orb(data_addr, header_bits);
1770     __ jmp(*obj_is_null);
1771     __ bind(not_null);
1772   } else {
1773     __ jcc(Assembler::equal, *obj_is_null);
1774   }
1775 
1776   if (!k-&gt;is_loaded()) {
1777     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1778   } else {
1779 #ifdef _LP64
1780     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1781 #endif // _LP64
1782   }
1783   __ verify_oop(obj);
1784 
1785   if (op-&gt;fast_check()) {
1786     // get object class
1787     // not a safepoint as obj null check happens earlier
1788 #ifdef _LP64
1789     if (UseCompressedClassPointers) {
1790       __ load_klass(Rtmp1, obj);
1791       __ cmpptr(k_RInfo, Rtmp1);
1792     } else {
1793       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1794     }
1795 #else
1796     if (k-&gt;is_loaded()) {
1797       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1798     } else {
1799       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1800     }
1801 #endif
1802     __ jcc(Assembler::notEqual, *failure_target);
1803     // successful cast, fall through to profile or jump
1804   } else {
1805     // get object class
1806     // not a safepoint as obj null check happens earlier
1807     __ load_klass(klass_RInfo, obj);
1808     if (k-&gt;is_loaded()) {
1809       // See if we get an immediate positive hit
1810 #ifdef _LP64
1811       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1812 #else
1813       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1814 #endif // _LP64
1815       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1816         __ jcc(Assembler::notEqual, *failure_target);
1817         // successful cast, fall through to profile or jump
1818       } else {
1819         // See if we get an immediate positive hit
1820         __ jcc(Assembler::equal, *success_target);
1821         // check for self
1822 #ifdef _LP64
1823         __ cmpptr(klass_RInfo, k_RInfo);
1824 #else
1825         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1826 #endif // _LP64
1827         __ jcc(Assembler::equal, *success_target);
1828 
1829         __ push(klass_RInfo);
1830 #ifdef _LP64
1831         __ push(k_RInfo);
1832 #else
1833         __ pushklass(k-&gt;constant_encoding());
1834 #endif // _LP64
1835         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1836         __ pop(klass_RInfo);
1837         __ pop(klass_RInfo);
1838         // result is a boolean
1839         __ cmpl(klass_RInfo, 0);
1840         __ jcc(Assembler::equal, *failure_target);
1841         // successful cast, fall through to profile or jump
1842       }
1843     } else {
1844       // perform the fast part of the checking logic
1845       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1846       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1847       __ push(klass_RInfo);
1848       __ push(k_RInfo);
1849       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1850       __ pop(klass_RInfo);
1851       __ pop(k_RInfo);
1852       // result is a boolean
1853       __ cmpl(k_RInfo, 0);
1854       __ jcc(Assembler::equal, *failure_target);
1855       // successful cast, fall through to profile or jump
1856     }
1857   }
1858   if (op-&gt;should_profile()) {
1859     Register mdo  = klass_RInfo, recv = k_RInfo;
1860     __ bind(profile_cast_success);
1861     __ mov_metadata(mdo, md-&gt;constant_encoding());
1862     __ load_klass(recv, obj);
1863     type_profile_helper(mdo, md, data, recv, success);
1864     __ jmp(*success);
1865 
1866     __ bind(profile_cast_failure);
1867     __ mov_metadata(mdo, md-&gt;constant_encoding());
1868     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1869     __ subptr(counter_addr, DataLayout::counter_increment);
1870     __ jmp(*failure);
1871   }
1872   __ jmp(*success);
1873 }
1874 
1875 
1876 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1877   LIR_Code code = op-&gt;code();
1878   if (code == lir_store_check) {
1879     Register value = op-&gt;object()-&gt;as_register();
1880     Register array = op-&gt;array()-&gt;as_register();
1881     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1882     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1883     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1884 
1885     CodeStub* stub = op-&gt;stub();
1886 
1887     // check if it needs to be profiled
1888     ciMethodData* md = NULL;
1889     ciProfileData* data = NULL;
1890 
1891     if (op-&gt;should_profile()) {
1892       ciMethod* method = op-&gt;profiled_method();
1893       assert(method != NULL, &quot;Should have method&quot;);
1894       int bci = op-&gt;profiled_bci();
1895       md = method-&gt;method_data_or_null();
1896       assert(md != NULL, &quot;Sanity&quot;);
1897       data = md-&gt;bci_to_data(bci);
1898       assert(data != NULL,                &quot;need data for type check&quot;);
1899       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1900     }
1901     Label profile_cast_success, profile_cast_failure, done;
1902     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1903     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1904 
1905     __ cmpptr(value, (int32_t)NULL_WORD);
1906     if (op-&gt;should_profile()) {
1907       Label not_null;
1908       __ jccb(Assembler::notEqual, not_null);
1909       // Object is null; update MDO and exit
1910       Register mdo  = klass_RInfo;
1911       __ mov_metadata(mdo, md-&gt;constant_encoding());
1912       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1913       int header_bits = BitData::null_seen_byte_constant();
1914       __ orb(data_addr, header_bits);
1915       __ jmp(done);
1916       __ bind(not_null);
1917     } else {
1918       __ jcc(Assembler::equal, done);
1919     }
1920 
1921     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1922     __ load_klass(k_RInfo, array);
1923     __ load_klass(klass_RInfo, value);
1924 
1925     // get instance klass (it&#39;s already uncompressed)
1926     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1927     // perform the fast part of the checking logic
1928     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1929     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1930     __ push(klass_RInfo);
1931     __ push(k_RInfo);
1932     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1933     __ pop(klass_RInfo);
1934     __ pop(k_RInfo);
1935     // result is a boolean
1936     __ cmpl(k_RInfo, 0);
1937     __ jcc(Assembler::equal, *failure_target);
1938     // fall through to the success case
1939 
1940     if (op-&gt;should_profile()) {
1941       Register mdo  = klass_RInfo, recv = k_RInfo;
1942       __ bind(profile_cast_success);
1943       __ mov_metadata(mdo, md-&gt;constant_encoding());
1944       __ load_klass(recv, value);
1945       type_profile_helper(mdo, md, data, recv, &amp;done);
1946       __ jmpb(done);
1947 
1948       __ bind(profile_cast_failure);
1949       __ mov_metadata(mdo, md-&gt;constant_encoding());
1950       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1951       __ subptr(counter_addr, DataLayout::counter_increment);
1952       __ jmp(*stub-&gt;entry());
1953     }
1954 
1955     __ bind(done);
1956   } else
1957     if (code == lir_checkcast) {
1958       Register obj = op-&gt;object()-&gt;as_register();
1959       Register dst = op-&gt;result_opr()-&gt;as_register();
1960       Label success;
1961       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
1962       __ bind(success);
1963       if (dst != obj) {
1964         __ mov(dst, obj);
1965       }
1966     } else
1967       if (code == lir_instanceof) {
1968         Register obj = op-&gt;object()-&gt;as_register();
1969         Register dst = op-&gt;result_opr()-&gt;as_register();
1970         Label success, failure, done;
1971         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
1972         __ bind(failure);
1973         __ xorptr(dst, dst);
1974         __ jmpb(done);
1975         __ bind(success);
1976         __ movptr(dst, 1);
1977         __ bind(done);
1978       } else {
1979         ShouldNotReachHere();
1980       }
1981 
1982 }
1983 
1984 
1985 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
1986   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
1987     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
1988     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
1989     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
1990     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
1991     Register addr = op-&gt;addr()-&gt;as_register();
1992     __ lock();
1993     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
1994 
1995   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
1996     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
1997     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
1998     Register newval = op-&gt;new_value()-&gt;as_register();
1999     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
2000     assert(cmpval == rax, &quot;wrong register&quot;);
2001     assert(newval != NULL, &quot;new val must be register&quot;);
2002     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2003     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2004     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2005 
2006     if ( op-&gt;code() == lir_cas_obj) {
2007 #ifdef _LP64
2008       if (UseCompressedOops) {
2009         __ encode_heap_oop(cmpval);
2010         __ mov(rscratch1, newval);
2011         __ encode_heap_oop(rscratch1);
2012         __ lock();
2013         // cmpval (rax) is implicitly used by this instruction
2014         __ cmpxchgl(rscratch1, Address(addr, 0));
2015       } else
2016 #endif
2017       {
2018         __ lock();
2019         __ cmpxchgptr(newval, Address(addr, 0));
2020       }
2021     } else {
2022       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2023       __ lock();
2024       __ cmpxchgl(newval, Address(addr, 0));
2025     }
2026 #ifdef _LP64
2027   } else if (op-&gt;code() == lir_cas_long) {
2028     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2029     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2030     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2031     assert(cmpval == rax, &quot;wrong register&quot;);
2032     assert(newval != NULL, &quot;new val must be register&quot;);
2033     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2034     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2035     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2036     __ lock();
2037     __ cmpxchgq(newval, Address(addr, 0));
2038 #endif // _LP64
2039   } else {
2040     Unimplemented();
2041   }
2042 }
2043 
2044 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2045   Assembler::Condition acond, ncond;
2046   switch (condition) {
2047     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2048     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2049     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2050     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2051     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2052     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2053     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2054     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2055     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2056                                 ShouldNotReachHere();
2057   }
2058 
2059   if (opr1-&gt;is_cpu_register()) {
2060     reg2reg(opr1, result);
2061   } else if (opr1-&gt;is_stack()) {
2062     stack2reg(opr1, result, result-&gt;type());
2063   } else if (opr1-&gt;is_constant()) {
2064     const2reg(opr1, result, lir_patch_none, NULL);
2065   } else {
2066     ShouldNotReachHere();
2067   }
2068 
2069   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2070     // optimized version that does not require a branch
2071     if (opr2-&gt;is_single_cpu()) {
2072       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2073       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2074     } else if (opr2-&gt;is_double_cpu()) {
2075       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2076       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2077       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2078       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2079     } else if (opr2-&gt;is_single_stack()) {
2080       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2081     } else if (opr2-&gt;is_double_stack()) {
2082       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2083       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2084     } else {
2085       ShouldNotReachHere();
2086     }
2087 
2088   } else {
2089     Label skip;
2090     __ jcc (acond, skip);
2091     if (opr2-&gt;is_cpu_register()) {
2092       reg2reg(opr2, result);
2093     } else if (opr2-&gt;is_stack()) {
2094       stack2reg(opr2, result, result-&gt;type());
2095     } else if (opr2-&gt;is_constant()) {
2096       const2reg(opr2, result, lir_patch_none, NULL);
2097     } else {
2098       ShouldNotReachHere();
2099     }
2100     __ bind(skip);
2101   }
2102 }
2103 
2104 
2105 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2106   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2107 
2108   if (left-&gt;is_single_cpu()) {
2109     assert(left == dest, &quot;left and dest must be equal&quot;);
2110     Register lreg = left-&gt;as_register();
2111 
2112     if (right-&gt;is_single_cpu()) {
2113       // cpu register - cpu register
2114       Register rreg = right-&gt;as_register();
2115       switch (code) {
2116         case lir_add: __ addl (lreg, rreg); break;
2117         case lir_sub: __ subl (lreg, rreg); break;
2118         case lir_mul: __ imull(lreg, rreg); break;
2119         default:      ShouldNotReachHere();
2120       }
2121 
2122     } else if (right-&gt;is_stack()) {
2123       // cpu register - stack
2124       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2125       switch (code) {
2126         case lir_add: __ addl(lreg, raddr); break;
2127         case lir_sub: __ subl(lreg, raddr); break;
2128         default:      ShouldNotReachHere();
2129       }
2130 
2131     } else if (right-&gt;is_constant()) {
2132       // cpu register - constant
2133       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2134       switch (code) {
2135         case lir_add: {
2136           __ incrementl(lreg, c);
2137           break;
2138         }
2139         case lir_sub: {
2140           __ decrementl(lreg, c);
2141           break;
2142         }
2143         default: ShouldNotReachHere();
2144       }
2145 
2146     } else {
2147       ShouldNotReachHere();
2148     }
2149 
2150   } else if (left-&gt;is_double_cpu()) {
2151     assert(left == dest, &quot;left and dest must be equal&quot;);
2152     Register lreg_lo = left-&gt;as_register_lo();
2153     Register lreg_hi = left-&gt;as_register_hi();
2154 
2155     if (right-&gt;is_double_cpu()) {
2156       // cpu register - cpu register
2157       Register rreg_lo = right-&gt;as_register_lo();
2158       Register rreg_hi = right-&gt;as_register_hi();
2159       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2160       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2161       switch (code) {
2162         case lir_add:
2163           __ addptr(lreg_lo, rreg_lo);
2164           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2165           break;
2166         case lir_sub:
2167           __ subptr(lreg_lo, rreg_lo);
2168           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2169           break;
2170         case lir_mul:
2171 #ifdef _LP64
2172           __ imulq(lreg_lo, rreg_lo);
2173 #else
2174           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2175           __ imull(lreg_hi, rreg_lo);
2176           __ imull(rreg_hi, lreg_lo);
2177           __ addl (rreg_hi, lreg_hi);
2178           __ mull (rreg_lo);
2179           __ addl (lreg_hi, rreg_hi);
2180 #endif // _LP64
2181           break;
2182         default:
2183           ShouldNotReachHere();
2184       }
2185 
2186     } else if (right-&gt;is_constant()) {
2187       // cpu register - constant
2188 #ifdef _LP64
2189       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2190       __ movptr(r10, (intptr_t) c);
2191       switch (code) {
2192         case lir_add:
2193           __ addptr(lreg_lo, r10);
2194           break;
2195         case lir_sub:
2196           __ subptr(lreg_lo, r10);
2197           break;
2198         default:
2199           ShouldNotReachHere();
2200       }
2201 #else
2202       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2203       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2204       switch (code) {
2205         case lir_add:
2206           __ addptr(lreg_lo, c_lo);
2207           __ adcl(lreg_hi, c_hi);
2208           break;
2209         case lir_sub:
2210           __ subptr(lreg_lo, c_lo);
2211           __ sbbl(lreg_hi, c_hi);
2212           break;
2213         default:
2214           ShouldNotReachHere();
2215       }
2216 #endif // _LP64
2217 
2218     } else {
2219       ShouldNotReachHere();
2220     }
2221 
2222   } else if (left-&gt;is_single_xmm()) {
2223     assert(left == dest, &quot;left and dest must be equal&quot;);
2224     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2225 
2226     if (right-&gt;is_single_xmm()) {
2227       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2228       switch (code) {
2229         case lir_add: __ addss(lreg, rreg);  break;
2230         case lir_sub: __ subss(lreg, rreg);  break;
2231         case lir_mul_strictfp: // fall through
2232         case lir_mul: __ mulss(lreg, rreg);  break;
2233         case lir_div_strictfp: // fall through
2234         case lir_div: __ divss(lreg, rreg);  break;
2235         default: ShouldNotReachHere();
2236       }
2237     } else {
2238       Address raddr;
2239       if (right-&gt;is_single_stack()) {
2240         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2241       } else if (right-&gt;is_constant()) {
2242         // hack for now
2243         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2244       } else {
2245         ShouldNotReachHere();
2246       }
2247       switch (code) {
2248         case lir_add: __ addss(lreg, raddr);  break;
2249         case lir_sub: __ subss(lreg, raddr);  break;
2250         case lir_mul_strictfp: // fall through
2251         case lir_mul: __ mulss(lreg, raddr);  break;
2252         case lir_div_strictfp: // fall through
2253         case lir_div: __ divss(lreg, raddr);  break;
2254         default: ShouldNotReachHere();
2255       }
2256     }
2257 
2258   } else if (left-&gt;is_double_xmm()) {
2259     assert(left == dest, &quot;left and dest must be equal&quot;);
2260 
2261     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2262     if (right-&gt;is_double_xmm()) {
2263       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2264       switch (code) {
2265         case lir_add: __ addsd(lreg, rreg);  break;
2266         case lir_sub: __ subsd(lreg, rreg);  break;
2267         case lir_mul_strictfp: // fall through
2268         case lir_mul: __ mulsd(lreg, rreg);  break;
2269         case lir_div_strictfp: // fall through
2270         case lir_div: __ divsd(lreg, rreg);  break;
2271         default: ShouldNotReachHere();
2272       }
2273     } else {
2274       Address raddr;
2275       if (right-&gt;is_double_stack()) {
2276         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2277       } else if (right-&gt;is_constant()) {
2278         // hack for now
2279         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2280       } else {
2281         ShouldNotReachHere();
2282       }
2283       switch (code) {
2284         case lir_add: __ addsd(lreg, raddr);  break;
2285         case lir_sub: __ subsd(lreg, raddr);  break;
2286         case lir_mul_strictfp: // fall through
2287         case lir_mul: __ mulsd(lreg, raddr);  break;
2288         case lir_div_strictfp: // fall through
2289         case lir_div: __ divsd(lreg, raddr);  break;
2290         default: ShouldNotReachHere();
2291       }
2292     }
2293 
2294 #ifndef _LP64
2295   } else if (left-&gt;is_single_fpu()) {
2296     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2297 
2298     if (right-&gt;is_single_fpu()) {
2299       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2300 
2301     } else {
2302       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2303       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2304 
2305       Address raddr;
2306       if (right-&gt;is_single_stack()) {
2307         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2308       } else if (right-&gt;is_constant()) {
2309         address const_addr = float_constant(right-&gt;as_jfloat());
2310         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2311         // hack for now
2312         raddr = __ as_Address(InternalAddress(const_addr));
2313       } else {
2314         ShouldNotReachHere();
2315       }
2316 
2317       switch (code) {
2318         case lir_add: __ fadd_s(raddr); break;
2319         case lir_sub: __ fsub_s(raddr); break;
2320         case lir_mul_strictfp: // fall through
2321         case lir_mul: __ fmul_s(raddr); break;
2322         case lir_div_strictfp: // fall through
2323         case lir_div: __ fdiv_s(raddr); break;
2324         default:      ShouldNotReachHere();
2325       }
2326     }
2327 
2328   } else if (left-&gt;is_double_fpu()) {
2329     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2330 
2331     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2332       // Double values require special handling for strictfp mul/div on x86
2333       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2334       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2335     }
2336 
2337     if (right-&gt;is_double_fpu()) {
2338       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2339 
2340     } else {
2341       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2342       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2343 
2344       Address raddr;
2345       if (right-&gt;is_double_stack()) {
2346         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2347       } else if (right-&gt;is_constant()) {
2348         // hack for now
2349         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2350       } else {
2351         ShouldNotReachHere();
2352       }
2353 
2354       switch (code) {
2355         case lir_add: __ fadd_d(raddr); break;
2356         case lir_sub: __ fsub_d(raddr); break;
2357         case lir_mul_strictfp: // fall through
2358         case lir_mul: __ fmul_d(raddr); break;
2359         case lir_div_strictfp: // fall through
2360         case lir_div: __ fdiv_d(raddr); break;
2361         default: ShouldNotReachHere();
2362       }
2363     }
2364 
2365     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2366       // Double values require special handling for strictfp mul/div on x86
2367       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2368       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2369     }
2370 #endif // !_LP64
2371 
2372   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2373     assert(left == dest, &quot;left and dest must be equal&quot;);
2374 
2375     Address laddr;
2376     if (left-&gt;is_single_stack()) {
2377       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2378     } else if (left-&gt;is_address()) {
2379       laddr = as_Address(left-&gt;as_address_ptr());
2380     } else {
2381       ShouldNotReachHere();
2382     }
2383 
2384     if (right-&gt;is_single_cpu()) {
2385       Register rreg = right-&gt;as_register();
2386       switch (code) {
2387         case lir_add: __ addl(laddr, rreg); break;
2388         case lir_sub: __ subl(laddr, rreg); break;
2389         default:      ShouldNotReachHere();
2390       }
2391     } else if (right-&gt;is_constant()) {
2392       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2393       switch (code) {
2394         case lir_add: {
2395           __ incrementl(laddr, c);
2396           break;
2397         }
2398         case lir_sub: {
2399           __ decrementl(laddr, c);
2400           break;
2401         }
2402         default: ShouldNotReachHere();
2403       }
2404     } else {
2405       ShouldNotReachHere();
2406     }
2407 
2408   } else {
2409     ShouldNotReachHere();
2410   }
2411 }
2412 
2413 #ifndef _LP64
2414 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2415   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2416   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2417   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2418 
2419   bool left_is_tos = (left_index == 0);
2420   bool dest_is_tos = (dest_index == 0);
2421   int non_tos_index = (left_is_tos ? right_index : left_index);
2422 
2423   switch (code) {
2424     case lir_add:
2425       if (pop_fpu_stack)       __ faddp(non_tos_index);
2426       else if (dest_is_tos)    __ fadd (non_tos_index);
2427       else                     __ fadda(non_tos_index);
2428       break;
2429 
2430     case lir_sub:
2431       if (left_is_tos) {
2432         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2433         else if (dest_is_tos)  __ fsub  (non_tos_index);
2434         else                   __ fsubra(non_tos_index);
2435       } else {
2436         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2437         else if (dest_is_tos)  __ fsubr (non_tos_index);
2438         else                   __ fsuba (non_tos_index);
2439       }
2440       break;
2441 
2442     case lir_mul_strictfp: // fall through
2443     case lir_mul:
2444       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2445       else if (dest_is_tos)    __ fmul (non_tos_index);
2446       else                     __ fmula(non_tos_index);
2447       break;
2448 
2449     case lir_div_strictfp: // fall through
2450     case lir_div:
2451       if (left_is_tos) {
2452         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2453         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2454         else                   __ fdivra(non_tos_index);
2455       } else {
2456         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2457         else if (dest_is_tos)  __ fdivr (non_tos_index);
2458         else                   __ fdiva (non_tos_index);
2459       }
2460       break;
2461 
2462     case lir_rem:
2463       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2464       __ fremr(noreg);
2465       break;
2466 
2467     default:
2468       ShouldNotReachHere();
2469   }
2470 }
2471 #endif // _LP64
2472 
2473 
2474 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2475   if (value-&gt;is_double_xmm()) {
2476     switch(code) {
2477       case lir_abs :
2478         {
2479 #ifdef _LP64
2480           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2481             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2482             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2483           } else
2484 #endif
2485           {
2486             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2487               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2488             }
2489             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2490             __ andpd(dest-&gt;as_xmm_double_reg(),
2491                      ExternalAddress((address)double_signmask_pool));
2492           }
2493         }
2494         break;
2495 
2496       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2497       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2498       default      : ShouldNotReachHere();
2499     }
2500 
2501 #ifndef _LP64
2502   } else if (value-&gt;is_double_fpu()) {
2503     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2504     switch(code) {
2505       case lir_abs   : __ fabs() ; break;
2506       case lir_sqrt  : __ fsqrt(); break;
2507       default      : ShouldNotReachHere();
2508     }
2509 #endif // !_LP64
2510   } else {
2511     Unimplemented();
2512   }
2513 }
2514 
2515 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2516   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2517   if (left-&gt;is_single_cpu()) {
2518     Register reg = left-&gt;as_register();
2519     if (right-&gt;is_constant()) {
2520       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2521       switch (code) {
2522         case lir_logic_and: __ andl (reg, val); break;
2523         case lir_logic_or:  __ orl  (reg, val); break;
2524         case lir_logic_xor: __ xorl (reg, val); break;
2525         default: ShouldNotReachHere();
2526       }
2527     } else if (right-&gt;is_stack()) {
2528       // added support for stack operands
2529       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2530       switch (code) {
2531         case lir_logic_and: __ andl (reg, raddr); break;
2532         case lir_logic_or:  __ orl  (reg, raddr); break;
2533         case lir_logic_xor: __ xorl (reg, raddr); break;
2534         default: ShouldNotReachHere();
2535       }
2536     } else {
2537       Register rright = right-&gt;as_register();
2538       switch (code) {
2539         case lir_logic_and: __ andptr (reg, rright); break;
2540         case lir_logic_or : __ orptr  (reg, rright); break;
2541         case lir_logic_xor: __ xorptr (reg, rright); break;
2542         default: ShouldNotReachHere();
2543       }
2544     }
2545     move_regs(reg, dst-&gt;as_register());
2546   } else {
2547     Register l_lo = left-&gt;as_register_lo();
2548     Register l_hi = left-&gt;as_register_hi();
2549     if (right-&gt;is_constant()) {
2550 #ifdef _LP64
2551       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2552       switch (code) {
2553         case lir_logic_and:
2554           __ andq(l_lo, rscratch1);
2555           break;
2556         case lir_logic_or:
2557           __ orq(l_lo, rscratch1);
2558           break;
2559         case lir_logic_xor:
2560           __ xorq(l_lo, rscratch1);
2561           break;
2562         default: ShouldNotReachHere();
2563       }
2564 #else
2565       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2566       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2567       switch (code) {
2568         case lir_logic_and:
2569           __ andl(l_lo, r_lo);
2570           __ andl(l_hi, r_hi);
2571           break;
2572         case lir_logic_or:
2573           __ orl(l_lo, r_lo);
2574           __ orl(l_hi, r_hi);
2575           break;
2576         case lir_logic_xor:
2577           __ xorl(l_lo, r_lo);
2578           __ xorl(l_hi, r_hi);
2579           break;
2580         default: ShouldNotReachHere();
2581       }
2582 #endif // _LP64
2583     } else {
2584 #ifdef _LP64
2585       Register r_lo;
2586       if (is_reference_type(right-&gt;type())) {
2587         r_lo = right-&gt;as_register();
2588       } else {
2589         r_lo = right-&gt;as_register_lo();
2590       }
2591 #else
2592       Register r_lo = right-&gt;as_register_lo();
2593       Register r_hi = right-&gt;as_register_hi();
2594       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2595 #endif
2596       switch (code) {
2597         case lir_logic_and:
2598           __ andptr(l_lo, r_lo);
2599           NOT_LP64(__ andptr(l_hi, r_hi);)
2600           break;
2601         case lir_logic_or:
2602           __ orptr(l_lo, r_lo);
2603           NOT_LP64(__ orptr(l_hi, r_hi);)
2604           break;
2605         case lir_logic_xor:
2606           __ xorptr(l_lo, r_lo);
2607           NOT_LP64(__ xorptr(l_hi, r_hi);)
2608           break;
2609         default: ShouldNotReachHere();
2610       }
2611     }
2612 
2613     Register dst_lo = dst-&gt;as_register_lo();
2614     Register dst_hi = dst-&gt;as_register_hi();
2615 
2616 #ifdef _LP64
2617     move_regs(l_lo, dst_lo);
2618 #else
2619     if (dst_lo == l_hi) {
2620       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2621       move_regs(l_hi, dst_hi);
2622       move_regs(l_lo, dst_lo);
2623     } else {
2624       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2625       move_regs(l_lo, dst_lo);
2626       move_regs(l_hi, dst_hi);
2627     }
2628 #endif // _LP64
2629   }
2630 }
2631 
2632 
2633 // we assume that rax, and rdx can be overwritten
2634 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2635 
2636   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2637   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2638   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2639 
2640   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2641   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2642 
2643   Register lreg = left-&gt;as_register();
2644   Register dreg = result-&gt;as_register();
2645 
2646   if (right-&gt;is_constant()) {
2647     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2648     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2649     if (code == lir_idiv) {
2650       assert(lreg == rax, &quot;must be rax,&quot;);
2651       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2652       __ cdql(); // sign extend into rdx:rax
2653       if (divisor == 2) {
2654         __ subl(lreg, rdx);
2655       } else {
2656         __ andl(rdx, divisor - 1);
2657         __ addl(lreg, rdx);
2658       }
2659       __ sarl(lreg, log2_jint(divisor));
2660       move_regs(lreg, dreg);
2661     } else if (code == lir_irem) {
2662       Label done;
2663       __ mov(dreg, lreg);
2664       __ andl(dreg, 0x80000000 | (divisor - 1));
2665       __ jcc(Assembler::positive, done);
2666       __ decrement(dreg);
2667       __ orl(dreg, ~(divisor - 1));
2668       __ increment(dreg);
2669       __ bind(done);
2670     } else {
2671       ShouldNotReachHere();
2672     }
2673   } else {
2674     Register rreg = right-&gt;as_register();
2675     assert(lreg == rax, &quot;left register must be rax,&quot;);
2676     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2677     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2678 
2679     move_regs(lreg, rax);
2680 
2681     int idivl_offset = __ corrected_idivl(rreg);
2682     if (ImplicitDiv0Checks) {
2683       add_debug_info_for_div0(idivl_offset, info);
2684     }
2685     if (code == lir_irem) {
2686       move_regs(rdx, dreg); // result is in rdx
2687     } else {
2688       move_regs(rax, dreg);
2689     }
2690   }
2691 }
2692 
2693 
2694 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2695   if (opr1-&gt;is_single_cpu()) {
2696     Register reg1 = opr1-&gt;as_register();
2697     if (opr2-&gt;is_single_cpu()) {
2698       // cpu register - cpu register
2699       if (is_reference_type(opr1-&gt;type())) {
2700         __ cmpoop(reg1, opr2-&gt;as_register());
2701       } else {
2702         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2703         __ cmpl(reg1, opr2-&gt;as_register());
2704       }
2705     } else if (opr2-&gt;is_stack()) {
2706       // cpu register - stack
2707       if (is_reference_type(opr1-&gt;type())) {
2708         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2709       } else {
2710         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2711       }
2712     } else if (opr2-&gt;is_constant()) {
2713       // cpu register - constant
2714       LIR_Const* c = opr2-&gt;as_constant_ptr();
2715       if (c-&gt;type() == T_INT) {
2716         __ cmpl(reg1, c-&gt;as_jint());
2717       } else if (c-&gt;type() == T_METADATA) {
2718         // All we need for now is a comparison with NULL for equality.
2719         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2720         Metadata* m = c-&gt;as_metadata();
2721         if (m == NULL) {
2722           __ cmpptr(reg1, (int32_t)0);
2723         } else {
2724           ShouldNotReachHere();
2725         }
2726       } else if (is_reference_type(c-&gt;type())) {
2727         // In 64bit oops are single register
2728         jobject o = c-&gt;as_jobject();
2729         if (o == NULL) {
2730           __ cmpptr(reg1, (int32_t)NULL_WORD);
2731         } else {
2732           __ cmpoop(reg1, o);
2733         }
2734       } else {
2735         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2736       }
2737       // cpu register - address
2738     } else if (opr2-&gt;is_address()) {
2739       if (op-&gt;info() != NULL) {
2740         add_debug_info_for_null_check_here(op-&gt;info());
2741       }
2742       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2743     } else {
2744       ShouldNotReachHere();
2745     }
2746 
2747   } else if(opr1-&gt;is_double_cpu()) {
2748     Register xlo = opr1-&gt;as_register_lo();
2749     Register xhi = opr1-&gt;as_register_hi();
2750     if (opr2-&gt;is_double_cpu()) {
2751 #ifdef _LP64
2752       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2753 #else
2754       // cpu register - cpu register
2755       Register ylo = opr2-&gt;as_register_lo();
2756       Register yhi = opr2-&gt;as_register_hi();
2757       __ subl(xlo, ylo);
2758       __ sbbl(xhi, yhi);
2759       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2760         __ orl(xhi, xlo);
2761       }
2762 #endif // _LP64
2763     } else if (opr2-&gt;is_constant()) {
2764       // cpu register - constant 0
2765       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2766 #ifdef _LP64
2767       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2768 #else
2769       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2770       __ orl(xhi, xlo);
2771 #endif // _LP64
2772     } else {
2773       ShouldNotReachHere();
2774     }
2775 
2776   } else if (opr1-&gt;is_single_xmm()) {
2777     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2778     if (opr2-&gt;is_single_xmm()) {
2779       // xmm register - xmm register
2780       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2781     } else if (opr2-&gt;is_stack()) {
2782       // xmm register - stack
2783       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2784     } else if (opr2-&gt;is_constant()) {
2785       // xmm register - constant
2786       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2787     } else if (opr2-&gt;is_address()) {
2788       // xmm register - address
2789       if (op-&gt;info() != NULL) {
2790         add_debug_info_for_null_check_here(op-&gt;info());
2791       }
2792       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2793     } else {
2794       ShouldNotReachHere();
2795     }
2796 
2797   } else if (opr1-&gt;is_double_xmm()) {
2798     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2799     if (opr2-&gt;is_double_xmm()) {
2800       // xmm register - xmm register
2801       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2802     } else if (opr2-&gt;is_stack()) {
2803       // xmm register - stack
2804       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2805     } else if (opr2-&gt;is_constant()) {
2806       // xmm register - constant
2807       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2808     } else if (opr2-&gt;is_address()) {
2809       // xmm register - address
2810       if (op-&gt;info() != NULL) {
2811         add_debug_info_for_null_check_here(op-&gt;info());
2812       }
2813       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2814     } else {
2815       ShouldNotReachHere();
2816     }
2817 
2818 #ifndef _LP64
2819   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2820     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2821     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2822     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2823 #endif // LP64
2824 
2825   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2826     LIR_Const* c = opr2-&gt;as_constant_ptr();
2827 #ifdef _LP64
2828     if (is_reference_type(c-&gt;type())) {
2829       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2830       __ movoop(rscratch1, c-&gt;as_jobject());
2831     }
2832 #endif // LP64
2833     if (op-&gt;info() != NULL) {
2834       add_debug_info_for_null_check_here(op-&gt;info());
2835     }
2836     // special case: address - constant
2837     LIR_Address* addr = opr1-&gt;as_address_ptr();
2838     if (c-&gt;type() == T_INT) {
2839       __ cmpl(as_Address(addr), c-&gt;as_jint());
2840     } else if (is_reference_type(c-&gt;type())) {
2841 #ifdef _LP64
2842       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
2843       // better strategy by giving noreg as the temp for as_Address
2844       __ cmpoop(rscratch1, as_Address(addr, noreg));
2845 #else
2846       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
2847 #endif // _LP64
2848     } else {
2849       ShouldNotReachHere();
2850     }
2851 
2852   } else {
2853     ShouldNotReachHere();
2854   }
2855 }
2856 
2857 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
2858   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
2859     if (left-&gt;is_single_xmm()) {
2860       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
2861       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2862     } else if (left-&gt;is_double_xmm()) {
2863       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
2864       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
2865 
2866     } else {
2867 #ifdef _LP64
2868       ShouldNotReachHere();
2869 #else
2870       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
2871       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
2872 
2873       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
2874       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
2875                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2876 #endif // LP64
2877     }
2878   } else {
2879     assert(code == lir_cmp_l2i, &quot;check&quot;);
2880 #ifdef _LP64
2881     Label done;
2882     Register dest = dst-&gt;as_register();
2883     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
2884     __ movl(dest, -1);
2885     __ jccb(Assembler::less, done);
2886     __ set_byte_if_not_zero(dest);
2887     __ movzbl(dest, dest);
2888     __ bind(done);
2889 #else
2890     __ lcmp2int(left-&gt;as_register_hi(),
2891                 left-&gt;as_register_lo(),
2892                 right-&gt;as_register_hi(),
2893                 right-&gt;as_register_lo());
2894     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
2895 #endif // _LP64
2896   }
2897 }
2898 
2899 
2900 void LIR_Assembler::align_call(LIR_Code code) {
2901   // make sure that the displacement word of the call ends up word aligned
2902   int offset = __ offset();
2903   switch (code) {
2904   case lir_static_call:
2905   case lir_optvirtual_call:
2906   case lir_dynamic_call:
2907     offset += NativeCall::displacement_offset;
2908     break;
2909   case lir_icvirtual_call:
2910     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
2911     break;
2912   case lir_virtual_call:  // currently, sparc-specific for niagara
2913   default: ShouldNotReachHere();
2914   }
2915   __ align(BytesPerWord, offset);
2916 }
2917 
2918 
2919 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
2920   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
2921          &quot;must be aligned&quot;);
2922   __ call(AddressLiteral(op-&gt;addr(), rtype));
2923   add_call_info(code_offset(), op-&gt;info());
2924 }
2925 
2926 
2927 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
2928   __ ic_call(op-&gt;addr());
2929   add_call_info(code_offset(), op-&gt;info());
2930   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
2931          &quot;must be aligned&quot;);
2932 }
2933 
2934 
2935 /* Currently, vtable-dispatch is only enabled for sparc platforms */
2936 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
2937   ShouldNotReachHere();
2938 }
2939 
2940 
2941 void LIR_Assembler::emit_static_call_stub() {
2942   address call_pc = __ pc();
2943   address stub = __ start_a_stub(call_stub_size());
2944   if (stub == NULL) {
2945     bailout(&quot;static call stub overflow&quot;);
2946     return;
2947   }
2948 
2949   int start = __ offset();
2950 
2951   // make sure that the displacement word of the call ends up word aligned
2952   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
2953   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
2954   __ mov_metadata(rbx, (Metadata*)NULL);
2955   // must be set to -1 at code generation time
2956   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
2957   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
2958   __ jump(RuntimeAddress(__ pc()));
2959 
2960   if (UseAOT) {
2961     // Trampoline to aot code
2962     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
2963 #ifdef _LP64
2964     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
2965 #else
2966     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
2967 #endif
2968     __ jmp(rax);
2969   }
2970   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
2971   __ end_a_stub();
2972 }
2973 
2974 
2975 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
2976   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
2977   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
2978 
2979   // exception object is not added to oop map by LinearScan
2980   // (LinearScan assumes that no oops are in fixed registers)
2981   info-&gt;add_register_oop(exceptionOop);
2982   Runtime1::StubID unwind_id;
2983 
2984   // get current pc information
2985   // pc is only needed if the method has an exception handler, the unwind code does not need it.
2986   int pc_for_athrow_offset = __ offset();
2987   InternalAddress pc_for_athrow(__ pc());
2988   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
2989   add_call_info(pc_for_athrow_offset, info); // for exception handler
2990 
2991   __ verify_not_null_oop(rax);
2992   // search an exception handler (rax: exception oop, rdx: throwing pc)
2993   if (compilation()-&gt;has_fpu_code()) {
2994     unwind_id = Runtime1::handle_exception_id;
2995   } else {
2996     unwind_id = Runtime1::handle_exception_nofpu_id;
2997   }
2998   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
2999 
3000   // enough room for two byte trap
3001   __ nop();
3002 }
3003 
3004 
3005 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3006   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3007 
3008   __ jmp(_unwind_handler_entry);
3009 }
3010 
3011 
3012 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3013 
3014   // optimized version for linear scan:
3015   // * count must be already in ECX (guaranteed by LinearScan)
3016   // * left and dest must be equal
3017   // * tmp must be unused
3018   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3019   assert(left == dest, &quot;left and dest must be equal&quot;);
3020   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3021 
3022   if (left-&gt;is_single_cpu()) {
3023     Register value = left-&gt;as_register();
3024     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3025 
3026     switch (code) {
3027       case lir_shl:  __ shll(value); break;
3028       case lir_shr:  __ sarl(value); break;
3029       case lir_ushr: __ shrl(value); break;
3030       default: ShouldNotReachHere();
3031     }
3032   } else if (left-&gt;is_double_cpu()) {
3033     Register lo = left-&gt;as_register_lo();
3034     Register hi = left-&gt;as_register_hi();
3035     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3036 #ifdef _LP64
3037     switch (code) {
3038       case lir_shl:  __ shlptr(lo);        break;
3039       case lir_shr:  __ sarptr(lo);        break;
3040       case lir_ushr: __ shrptr(lo);        break;
3041       default: ShouldNotReachHere();
3042     }
3043 #else
3044 
3045     switch (code) {
3046       case lir_shl:  __ lshl(hi, lo);        break;
3047       case lir_shr:  __ lshr(hi, lo, true);  break;
3048       case lir_ushr: __ lshr(hi, lo, false); break;
3049       default: ShouldNotReachHere();
3050     }
3051 #endif // LP64
3052   } else {
3053     ShouldNotReachHere();
3054   }
3055 }
3056 
3057 
3058 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3059   if (dest-&gt;is_single_cpu()) {
3060     // first move left into dest so that left is not destroyed by the shift
3061     Register value = dest-&gt;as_register();
3062     count = count &amp; 0x1F; // Java spec
3063 
3064     move_regs(left-&gt;as_register(), value);
3065     switch (code) {
3066       case lir_shl:  __ shll(value, count); break;
3067       case lir_shr:  __ sarl(value, count); break;
3068       case lir_ushr: __ shrl(value, count); break;
3069       default: ShouldNotReachHere();
3070     }
3071   } else if (dest-&gt;is_double_cpu()) {
3072 #ifndef _LP64
3073     Unimplemented();
3074 #else
3075     // first move left into dest so that left is not destroyed by the shift
3076     Register value = dest-&gt;as_register_lo();
3077     count = count &amp; 0x1F; // Java spec
3078 
3079     move_regs(left-&gt;as_register_lo(), value);
3080     switch (code) {
3081       case lir_shl:  __ shlptr(value, count); break;
3082       case lir_shr:  __ sarptr(value, count); break;
3083       case lir_ushr: __ shrptr(value, count); break;
3084       default: ShouldNotReachHere();
3085     }
3086 #endif // _LP64
3087   } else {
3088     ShouldNotReachHere();
3089   }
3090 }
3091 
3092 
3093 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3094   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3095   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3096   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3097   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3098 }
3099 
3100 
3101 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3102   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3103   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3104   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3105   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3106 }
3107 
3108 
3109 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3110   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3111   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3112   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3113   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3114 }
3115 
3116 
3117 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3118   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3119   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3120   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3121   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3122 }
3123 
3124 
3125 // This code replaces a call to arraycopy; no exception may
3126 // be thrown in this code, they must be thrown in the System.arraycopy
3127 // activation frame; we could save some checks if this would not be the case
3128 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3129   ciArrayKlass* default_type = op-&gt;expected_type();
3130   Register src = op-&gt;src()-&gt;as_register();
3131   Register dst = op-&gt;dst()-&gt;as_register();
3132   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3133   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3134   Register length  = op-&gt;length()-&gt;as_register();
3135   Register tmp = op-&gt;tmp()-&gt;as_register();
3136 
3137   __ resolve(ACCESS_READ, src);
3138   __ resolve(ACCESS_WRITE, dst);
3139 
3140   CodeStub* stub = op-&gt;stub();
3141   int flags = op-&gt;flags();
3142   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3143   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3144 
3145   // if we don&#39;t know anything, just go through the generic arraycopy
3146   if (default_type == NULL) {
3147     // save outgoing arguments on stack in case call to System.arraycopy is needed
3148     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3149     // for interpreter calling conventions. Now we have to do it in new style conventions.
3150     // For the moment until C1 gets the new register allocator I just force all the
3151     // args to the right place (except the register args) and then on the back side
3152     // reload the register args properly if we go slow path. Yuck
3153 
3154     // These are proper for the calling convention
3155     store_parameter(length, 2);
3156     store_parameter(dst_pos, 1);
3157     store_parameter(dst, 0);
3158 
3159     // these are just temporary placements until we need to reload
3160     store_parameter(src_pos, 3);
3161     store_parameter(src, 4);
3162     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3163 
3164     address copyfunc_addr = StubRoutines::generic_arraycopy();
3165     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3166 
3167     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3168 #ifdef _LP64
3169     // The arguments are in java calling convention so we can trivially shift them to C
3170     // convention
3171     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3172     __ mov(c_rarg0, j_rarg0);
3173     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3174     __ mov(c_rarg1, j_rarg1);
3175     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3176     __ mov(c_rarg2, j_rarg2);
3177     assert_different_registers(c_rarg3, j_rarg4);
3178     __ mov(c_rarg3, j_rarg3);
3179 #ifdef _WIN64
3180     // Allocate abi space for args but be sure to keep stack aligned
3181     __ subptr(rsp, 6*wordSize);
3182     store_parameter(j_rarg4, 4);
3183 #ifndef PRODUCT
3184     if (PrintC1Statistics) {
3185       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3186     }
3187 #endif
3188     __ call(RuntimeAddress(copyfunc_addr));
3189     __ addptr(rsp, 6*wordSize);
3190 #else
3191     __ mov(c_rarg4, j_rarg4);
3192 #ifndef PRODUCT
3193     if (PrintC1Statistics) {
3194       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3195     }
3196 #endif
3197     __ call(RuntimeAddress(copyfunc_addr));
3198 #endif // _WIN64
3199 #else
3200     __ push(length);
3201     __ push(dst_pos);
3202     __ push(dst);
3203     __ push(src_pos);
3204     __ push(src);
3205 
3206 #ifndef PRODUCT
3207     if (PrintC1Statistics) {
3208       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3209     }
3210 #endif
3211     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3212 
3213 #endif // _LP64
3214 
3215     __ cmpl(rax, 0);
3216     __ jcc(Assembler::equal, *stub-&gt;continuation());
3217 
3218     __ mov(tmp, rax);
3219     __ xorl(tmp, -1);
3220 
3221     // Reload values from the stack so they are where the stub
3222     // expects them.
3223     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3224     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3225     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3226     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3227     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3228 
3229     __ subl(length, tmp);
3230     __ addl(src_pos, tmp);
3231     __ addl(dst_pos, tmp);
3232     __ jmp(*stub-&gt;entry());
3233 
3234     __ bind(*stub-&gt;continuation());
3235     return;
3236   }
3237 
3238   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3239 
3240   int elem_size = type2aelembytes(basic_type);
3241   Address::ScaleFactor scale;
3242 
3243   switch (elem_size) {
3244     case 1 :
3245       scale = Address::times_1;
3246       break;
3247     case 2 :
3248       scale = Address::times_2;
3249       break;
3250     case 4 :
3251       scale = Address::times_4;
3252       break;
3253     case 8 :
3254       scale = Address::times_8;
3255       break;
3256     default:
3257       scale = Address::no_scale;
3258       ShouldNotReachHere();
3259   }
3260 
3261   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3262   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3263   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3264   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3265 
3266   // length and pos&#39;s are all sign extended at this point on 64bit
3267 
3268   // test for NULL
3269   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3270     __ testptr(src, src);
3271     __ jcc(Assembler::zero, *stub-&gt;entry());
3272   }
3273   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3274     __ testptr(dst, dst);
3275     __ jcc(Assembler::zero, *stub-&gt;entry());
3276   }
3277 
3278   // If the compiler was not able to prove that exact type of the source or the destination
3279   // of the arraycopy is an array type, check at runtime if the source or the destination is
3280   // an instance type.
3281   if (flags &amp; LIR_OpArrayCopy::type_check) {
3282     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3283       __ load_klass(tmp, dst);
3284       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3285       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3286     }
3287 
3288     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3289       __ load_klass(tmp, src);
3290       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3291       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3292     }
3293   }
3294 
3295   // check if negative
3296   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3297     __ testl(src_pos, src_pos);
3298     __ jcc(Assembler::less, *stub-&gt;entry());
3299   }
3300   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3301     __ testl(dst_pos, dst_pos);
3302     __ jcc(Assembler::less, *stub-&gt;entry());
3303   }
3304 
3305   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3306     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3307     __ cmpl(tmp, src_length_addr);
3308     __ jcc(Assembler::above, *stub-&gt;entry());
3309   }
3310   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3311     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3312     __ cmpl(tmp, dst_length_addr);
3313     __ jcc(Assembler::above, *stub-&gt;entry());
3314   }
3315 
3316   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3317     __ testl(length, length);
3318     __ jcc(Assembler::less, *stub-&gt;entry());
3319   }
3320 
3321 #ifdef _LP64
3322   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3323   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3324 #endif
3325 
3326   if (flags &amp; LIR_OpArrayCopy::type_check) {
3327     // We don&#39;t know the array types are compatible
3328     if (basic_type != T_OBJECT) {
3329       // Simple test for basic type arrays
3330       if (UseCompressedClassPointers) {
3331         __ movl(tmp, src_klass_addr);
3332         __ cmpl(tmp, dst_klass_addr);
3333       } else {
3334         __ movptr(tmp, src_klass_addr);
3335         __ cmpptr(tmp, dst_klass_addr);
3336       }
3337       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3338     } else {
3339       // For object arrays, if src is a sub class of dst then we can
3340       // safely do the copy.
3341       Label cont, slow;
3342 
3343       __ push(src);
3344       __ push(dst);
3345 
3346       __ load_klass(src, src);
3347       __ load_klass(dst, dst);
3348 
3349       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3350 
3351       __ push(src);
3352       __ push(dst);
3353       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3354       __ pop(dst);
3355       __ pop(src);
3356 
3357       __ cmpl(src, 0);
3358       __ jcc(Assembler::notEqual, cont);
3359 
3360       __ bind(slow);
3361       __ pop(dst);
3362       __ pop(src);
3363 
3364       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3365       if (copyfunc_addr != NULL) { // use stub if available
3366         // src is not a sub class of dst so we have to do a
3367         // per-element check.
3368 
3369         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3370         if ((flags &amp; mask) != mask) {
3371           // Check that at least both of them object arrays.
3372           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3373 
3374           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3375             __ load_klass(tmp, src);
3376           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3377             __ load_klass(tmp, dst);
3378           }
3379           int lh_offset = in_bytes(Klass::layout_helper_offset());
3380           Address klass_lh_addr(tmp, lh_offset);
3381           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3382           __ cmpl(klass_lh_addr, objArray_lh);
3383           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3384         }
3385 
3386        // Spill because stubs can use any register they like and it&#39;s
3387        // easier to restore just those that we care about.
3388        store_parameter(dst, 0);
3389        store_parameter(dst_pos, 1);
3390        store_parameter(length, 2);
3391        store_parameter(src_pos, 3);
3392        store_parameter(src, 4);
3393 
3394 #ifndef _LP64
3395         __ movptr(tmp, dst_klass_addr);
3396         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3397         __ push(tmp);
3398         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3399         __ push(tmp);
3400         __ push(length);
3401         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3402         __ push(tmp);
3403         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3404         __ push(tmp);
3405 
3406         __ call_VM_leaf(copyfunc_addr, 5);
3407 #else
3408         __ movl2ptr(length, length); //higher 32bits must be null
3409 
3410         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3411         assert_different_registers(c_rarg0, dst, dst_pos, length);
3412         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3413         assert_different_registers(c_rarg1, dst, length);
3414 
3415         __ mov(c_rarg2, length);
3416         assert_different_registers(c_rarg2, dst);
3417 
3418 #ifdef _WIN64
3419         // Allocate abi space for args but be sure to keep stack aligned
3420         __ subptr(rsp, 6*wordSize);
3421         __ load_klass(c_rarg3, dst);
3422         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3423         store_parameter(c_rarg3, 4);
3424         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3425         __ call(RuntimeAddress(copyfunc_addr));
3426         __ addptr(rsp, 6*wordSize);
3427 #else
3428         __ load_klass(c_rarg4, dst);
3429         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3430         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3431         __ call(RuntimeAddress(copyfunc_addr));
3432 #endif
3433 
3434 #endif
3435 
3436 #ifndef PRODUCT
3437         if (PrintC1Statistics) {
3438           Label failed;
3439           __ testl(rax, rax);
3440           __ jcc(Assembler::notZero, failed);
3441           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3442           __ bind(failed);
3443         }
3444 #endif
3445 
3446         __ testl(rax, rax);
3447         __ jcc(Assembler::zero, *stub-&gt;continuation());
3448 
3449 #ifndef PRODUCT
3450         if (PrintC1Statistics) {
3451           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3452         }
3453 #endif
3454 
3455         __ mov(tmp, rax);
3456 
3457         __ xorl(tmp, -1);
3458 
3459         // Restore previously spilled arguments
3460         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3461         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3462         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3463         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3464         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3465 
3466 
3467         __ subl(length, tmp);
3468         __ addl(src_pos, tmp);
3469         __ addl(dst_pos, tmp);
3470       }
3471 
3472       __ jmp(*stub-&gt;entry());
3473 
3474       __ bind(cont);
3475       __ pop(dst);
3476       __ pop(src);
3477     }
3478   }
3479 
3480 #ifdef ASSERT
3481   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3482     // Sanity check the known type with the incoming class.  For the
3483     // primitive case the types must match exactly with src.klass and
3484     // dst.klass each exactly matching the default type.  For the
3485     // object array case, if no type check is needed then either the
3486     // dst type is exactly the expected type and the src type is a
3487     // subtype which we can&#39;t check or src is the same array as dst
3488     // but not necessarily exactly of type default_type.
3489     Label known_ok, halt;
3490     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3491 #ifdef _LP64
3492     if (UseCompressedClassPointers) {
3493       __ encode_klass_not_null(tmp);
3494     }
3495 #endif
3496 
3497     if (basic_type != T_OBJECT) {
3498 
3499       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3500       else                   __ cmpptr(tmp, dst_klass_addr);
3501       __ jcc(Assembler::notEqual, halt);
3502       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3503       else                   __ cmpptr(tmp, src_klass_addr);
3504       __ jcc(Assembler::equal, known_ok);
3505     } else {
3506       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3507       else                   __ cmpptr(tmp, dst_klass_addr);
3508       __ jcc(Assembler::equal, known_ok);
3509       __ cmpptr(src, dst);
3510       __ jcc(Assembler::equal, known_ok);
3511     }
3512     __ bind(halt);
3513     __ stop(&quot;incorrect type information in arraycopy&quot;);
3514     __ bind(known_ok);
3515   }
3516 #endif
3517 
3518 #ifndef PRODUCT
3519   if (PrintC1Statistics) {
3520     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3521   }
3522 #endif
3523 
3524 #ifdef _LP64
3525   assert_different_registers(c_rarg0, dst, dst_pos, length);
3526   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3527   assert_different_registers(c_rarg1, length);
3528   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3529   __ mov(c_rarg2, length);
3530 
3531 #else
3532   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3533   store_parameter(tmp, 0);
3534   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3535   store_parameter(tmp, 1);
3536   store_parameter(length, 2);
3537 #endif // _LP64
3538 
3539   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3540   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3541   const char *name;
3542   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3543   __ call_VM_leaf(entry, 0);
3544 
3545   __ bind(*stub-&gt;continuation());
3546 }
3547 
3548 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3549   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3550   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3551   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3552   Register crc = op-&gt;crc()-&gt;as_register();
3553   Register val = op-&gt;val()-&gt;as_register();
3554   Register res = op-&gt;result_opr()-&gt;as_register();
3555 
3556   assert_different_registers(val, crc, res);
3557 
3558   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3559   __ notl(crc); // ~crc
3560   __ update_byte_crc32(crc, val, res);
3561   __ notl(crc); // ~crc
3562   __ mov(res, crc);
3563 }
3564 
3565 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3566   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3567   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3568   Register lock = op-&gt;lock_opr()-&gt;as_register();
3569   if (!UseFastLocking) {
3570     __ jmp(*op-&gt;stub()-&gt;entry());
3571   } else if (op-&gt;code() == lir_lock) {
3572     Register scratch = noreg;
3573     if (UseBiasedLocking) {
3574       scratch = op-&gt;scratch_opr()-&gt;as_register();
3575     }
3576     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3577     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3578     // add debug info for NullPointerException only if one is possible
3579     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3580     if (op-&gt;info() != NULL) {
3581       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3582     }
3583     // done
3584   } else if (op-&gt;code() == lir_unlock) {
3585     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3586     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3587   } else {
3588     Unimplemented();
3589   }
3590   __ bind(*op-&gt;stub()-&gt;continuation());
3591 }
3592 
3593 
3594 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3595   ciMethod* method = op-&gt;profiled_method();
3596   int bci          = op-&gt;profiled_bci();
3597   ciMethod* callee = op-&gt;profiled_callee();
3598 
3599   // Update counter for all call types
3600   ciMethodData* md = method-&gt;method_data_or_null();
3601   assert(md != NULL, &quot;Sanity&quot;);
3602   ciProfileData* data = md-&gt;bci_to_data(bci);
3603   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3604   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3605   Register mdo  = op-&gt;mdo()-&gt;as_register();
3606   __ mov_metadata(mdo, md-&gt;constant_encoding());
3607   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3608   // Perform additional virtual call profiling for invokevirtual and
3609   // invokeinterface bytecodes
3610   if (op-&gt;should_profile_receiver_type()) {
3611     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3612     Register recv = op-&gt;recv()-&gt;as_register();
3613     assert_different_registers(mdo, recv);
3614     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3615     ciKlass* known_klass = op-&gt;known_holder();
3616     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3617       // We know the type that will be seen at this call site; we can
3618       // statically update the MethodData* rather than needing to do
3619       // dynamic tests on the receiver type
3620 
3621       // NOTE: we should probably put a lock around this search to
3622       // avoid collisions by concurrent compilations
3623       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3624       uint i;
3625       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3626         ciKlass* receiver = vc_data-&gt;receiver(i);
3627         if (known_klass-&gt;equals(receiver)) {
3628           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3629           __ addptr(data_addr, DataLayout::counter_increment);
3630           return;
3631         }
3632       }
3633 
3634       // Receiver type not found in profile data; select an empty slot
3635 
3636       // Note that this is less efficient than it should be because it
3637       // always does a write to the receiver part of the
3638       // VirtualCallData rather than just the first time
3639       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3640         ciKlass* receiver = vc_data-&gt;receiver(i);
3641         if (receiver == NULL) {
3642           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3643           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3644           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3645           __ addptr(data_addr, DataLayout::counter_increment);
3646           return;
3647         }
3648       }
3649     } else {
3650       __ load_klass(recv, recv);
3651       Label update_done;
3652       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3653       // Receiver did not match any saved receiver and there is no empty row for it.
3654       // Increment total counter to indicate polymorphic case.
3655       __ addptr(counter_addr, DataLayout::counter_increment);
3656 
3657       __ bind(update_done);
3658     }
3659   } else {
3660     // Static call
3661     __ addptr(counter_addr, DataLayout::counter_increment);
3662   }
3663 }
3664 
3665 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3666   Register obj = op-&gt;obj()-&gt;as_register();
3667   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3668   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3669   ciKlass* exact_klass = op-&gt;exact_klass();
3670   intptr_t current_klass = op-&gt;current_klass();
3671   bool not_null = op-&gt;not_null();
3672   bool no_conflict = op-&gt;no_conflict();
3673 
3674   Label update, next, none;
3675 
3676   bool do_null = !not_null;
3677   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3678   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3679 
3680   assert(do_null || do_update, &quot;why are we here?&quot;);
3681   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3682 
3683   __ verify_oop(obj);
3684 
3685   if (tmp != obj) {
3686     __ mov(tmp, obj);
3687   }
3688   if (do_null) {
3689     __ testptr(tmp, tmp);
3690     __ jccb(Assembler::notZero, update);
3691     if (!TypeEntries::was_null_seen(current_klass)) {
3692       __ orptr(mdo_addr, TypeEntries::null_seen);
3693     }
3694     if (do_update) {
3695 #ifndef ASSERT
3696       __ jmpb(next);
3697     }
3698 #else
3699       __ jmp(next);
3700     }
3701   } else {
3702     __ testptr(tmp, tmp);
3703     __ jcc(Assembler::notZero, update);
3704     __ stop(&quot;unexpect null obj&quot;);
3705 #endif
3706   }
3707 
3708   __ bind(update);
3709 
3710   if (do_update) {
3711 #ifdef ASSERT
3712     if (exact_klass != NULL) {
3713       Label ok;
3714       __ load_klass(tmp, tmp);
3715       __ push(tmp);
3716       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3717       __ cmpptr(tmp, Address(rsp, 0));
3718       __ jcc(Assembler::equal, ok);
3719       __ stop(&quot;exact klass and actual klass differ&quot;);
3720       __ bind(ok);
3721       __ pop(tmp);
3722     }
3723 #endif
3724     if (!no_conflict) {
3725       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3726         if (exact_klass != NULL) {
3727           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3728         } else {
3729           __ load_klass(tmp, tmp);
3730         }
3731 
3732         __ xorptr(tmp, mdo_addr);
3733         __ testptr(tmp, TypeEntries::type_klass_mask);
3734         // klass seen before, nothing to do. The unknown bit may have been
3735         // set already but no need to check.
3736         __ jccb(Assembler::zero, next);
3737 
3738         __ testptr(tmp, TypeEntries::type_unknown);
3739         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3740 
3741         if (TypeEntries::is_type_none(current_klass)) {
3742           __ cmpptr(mdo_addr, 0);
3743           __ jccb(Assembler::equal, none);
3744           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3745           __ jccb(Assembler::equal, none);
3746           // There is a chance that the checks above (re-reading profiling
3747           // data from memory) fail if another thread has just set the
3748           // profiling to this obj&#39;s klass
3749           __ xorptr(tmp, mdo_addr);
3750           __ testptr(tmp, TypeEntries::type_klass_mask);
3751           __ jccb(Assembler::zero, next);
3752         }
3753       } else {
3754         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3755                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3756 
3757         __ movptr(tmp, mdo_addr);
3758         __ testptr(tmp, TypeEntries::type_unknown);
3759         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3760       }
3761 
3762       // different than before. Cannot keep accurate profile.
3763       __ orptr(mdo_addr, TypeEntries::type_unknown);
3764 
3765       if (TypeEntries::is_type_none(current_klass)) {
3766         __ jmpb(next);
3767 
3768         __ bind(none);
3769         // first time here. Set profile type.
3770         __ movptr(mdo_addr, tmp);
3771       }
3772     } else {
3773       // There&#39;s a single possible klass at this profile point
3774       assert(exact_klass != NULL, &quot;should be&quot;);
3775       if (TypeEntries::is_type_none(current_klass)) {
3776         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3777         __ xorptr(tmp, mdo_addr);
3778         __ testptr(tmp, TypeEntries::type_klass_mask);
3779 #ifdef ASSERT
3780         __ jcc(Assembler::zero, next);
3781 
3782         {
3783           Label ok;
3784           __ push(tmp);
3785           __ cmpptr(mdo_addr, 0);
3786           __ jcc(Assembler::equal, ok);
3787           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3788           __ jcc(Assembler::equal, ok);
3789           // may have been set by another thread
3790           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3791           __ xorptr(tmp, mdo_addr);
3792           __ testptr(tmp, TypeEntries::type_mask);
3793           __ jcc(Assembler::zero, ok);
3794 
3795           __ stop(&quot;unexpected profiling mismatch&quot;);
3796           __ bind(ok);
3797           __ pop(tmp);
3798         }
3799 #else
3800         __ jccb(Assembler::zero, next);
3801 #endif
3802         // first time here. Set profile type.
3803         __ movptr(mdo_addr, tmp);
3804       } else {
3805         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3806                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3807 
3808         __ movptr(tmp, mdo_addr);
3809         __ testptr(tmp, TypeEntries::type_unknown);
3810         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3811 
3812         __ orptr(mdo_addr, TypeEntries::type_unknown);
3813       }
3814     }
3815 
3816     __ bind(next);
3817   }
3818 }
3819 
3820 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
3821   Unimplemented();
3822 }
3823 
3824 
3825 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
3826   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
3827 }
3828 
3829 
3830 void LIR_Assembler::align_backward_branch_target() {
3831   __ align(BytesPerWord);
3832 }
3833 
3834 
3835 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3836   if (left-&gt;is_single_cpu()) {
3837     __ negl(left-&gt;as_register());
3838     move_regs(left-&gt;as_register(), dest-&gt;as_register());
3839 
3840   } else if (left-&gt;is_double_cpu()) {
3841     Register lo = left-&gt;as_register_lo();
3842 #ifdef _LP64
3843     Register dst = dest-&gt;as_register_lo();
3844     __ movptr(dst, lo);
3845     __ negptr(dst);
3846 #else
3847     Register hi = left-&gt;as_register_hi();
3848     __ lneg(hi, lo);
3849     if (dest-&gt;as_register_lo() == hi) {
3850       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
3851       move_regs(hi, dest-&gt;as_register_hi());
3852       move_regs(lo, dest-&gt;as_register_lo());
3853     } else {
3854       move_regs(lo, dest-&gt;as_register_lo());
3855       move_regs(hi, dest-&gt;as_register_hi());
3856     }
3857 #endif // _LP64
3858 
3859   } else if (dest-&gt;is_single_xmm()) {
3860 #ifdef _LP64
3861     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3862       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3863       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
3864       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
3865     }
3866     else
3867 #endif
3868     {
3869       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3870       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
3871         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
3872       }
3873       __ xorps(dest-&gt;as_xmm_float_reg(),
3874                ExternalAddress((address)float_signflip_pool));
3875     }
3876   } else if (dest-&gt;is_double_xmm()) {
3877 #ifdef _LP64
3878     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
3879       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
3880       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
3881       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
3882     }
3883     else
3884 #endif
3885     {
3886       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
3887       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
3888         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
3889       }
3890       __ xorpd(dest-&gt;as_xmm_double_reg(),
3891                ExternalAddress((address)double_signflip_pool));
3892     }
3893 #ifndef _LP64
3894   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
3895     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
3896     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
3897     __ fchs();
3898 #endif // !_LP64
3899 
3900   } else {
3901     ShouldNotReachHere();
3902   }
3903 }
3904 
3905 
3906 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3907   assert(src-&gt;is_address(), &quot;must be an address&quot;);
3908   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
3909 
3910   PatchingStub* patch = NULL;
3911   if (patch_code != lir_patch_none) {
3912     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3913   }
3914 
3915   Register reg = dest-&gt;as_pointer_register();
3916   LIR_Address* addr = src-&gt;as_address_ptr();
3917   __ lea(reg, as_Address(addr));
3918 
3919   if (patch != NULL) {
3920     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
3921   }
3922 }
3923 
3924 
3925 
3926 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3927   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
3928   __ call(RuntimeAddress(dest));
3929   if (info != NULL) {
3930     add_call_info_here(info);
3931   }
3932 }
3933 
3934 
3935 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3936   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
3937 
3938   if (info != NULL) {
3939     add_debug_info_for_null_check_here(info);
3940   }
3941 
3942   if (src-&gt;is_double_xmm()) {
3943     if (dest-&gt;is_double_cpu()) {
3944 #ifdef _LP64
3945       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3946 #else
3947       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
3948       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
3949       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
3950 #endif // _LP64
3951     } else if (dest-&gt;is_double_stack()) {
3952       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
3953     } else if (dest-&gt;is_address()) {
3954       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
3955     } else {
3956       ShouldNotReachHere();
3957     }
3958 
3959   } else if (dest-&gt;is_double_xmm()) {
3960     if (src-&gt;is_double_stack()) {
3961       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3962     } else if (src-&gt;is_address()) {
3963       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
3964     } else {
3965       ShouldNotReachHere();
3966     }
3967 
3968 #ifndef _LP64
3969   } else if (src-&gt;is_double_fpu()) {
3970     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3971     if (dest-&gt;is_double_stack()) {
3972       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
3973     } else if (dest-&gt;is_address()) {
3974       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
3975     } else {
3976       ShouldNotReachHere();
3977     }
3978 
3979   } else if (dest-&gt;is_double_fpu()) {
3980     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
3981     if (src-&gt;is_double_stack()) {
3982       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
3983     } else if (src-&gt;is_address()) {
3984       __ fild_d(as_Address(src-&gt;as_address_ptr()));
3985     } else {
3986       ShouldNotReachHere();
3987     }
3988 #endif // !_LP64
3989 
3990   } else {
3991     ShouldNotReachHere();
3992   }
3993 }
3994 
3995 #ifdef ASSERT
3996 // emit run-time assertion
3997 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3998   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3999 
4000   if (op-&gt;in_opr1()-&gt;is_valid()) {
4001     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4002     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4003   } else {
4004     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4005     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4006   }
4007 
4008   Label ok;
4009   if (op-&gt;condition() != lir_cond_always) {
4010     Assembler::Condition acond = Assembler::zero;
4011     switch (op-&gt;condition()) {
4012       case lir_cond_equal:        acond = Assembler::equal;       break;
4013       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4014       case lir_cond_less:         acond = Assembler::less;        break;
4015       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4016       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4017       case lir_cond_greater:      acond = Assembler::greater;     break;
4018       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4019       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4020       default:                    ShouldNotReachHere();
4021     }
4022     __ jcc(acond, ok);
4023   }
4024   if (op-&gt;halt()) {
4025     const char* str = __ code_string(op-&gt;msg());
4026     __ stop(str);
4027   } else {
4028     breakpoint();
4029   }
4030   __ bind(ok);
4031 }
4032 #endif
4033 
4034 void LIR_Assembler::membar() {
4035   // QQQ sparc TSO uses this,
4036   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4037 }
4038 
4039 void LIR_Assembler::membar_acquire() {
4040   // No x86 machines currently require load fences
4041 }
4042 
4043 void LIR_Assembler::membar_release() {
4044   // No x86 machines currently require store fences
4045 }
4046 
4047 void LIR_Assembler::membar_loadload() {
4048   // no-op
4049   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4050 }
4051 
4052 void LIR_Assembler::membar_storestore() {
4053   // no-op
4054   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4055 }
4056 
4057 void LIR_Assembler::membar_loadstore() {
4058   // no-op
4059   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4060 }
4061 
4062 void LIR_Assembler::membar_storeload() {
4063   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4064 }
4065 
4066 void LIR_Assembler::on_spin_wait() {
4067   __ pause ();
4068 }
4069 
4070 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4071   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4072 #ifdef _LP64
4073   // __ get_thread(result_reg-&gt;as_register_lo());
4074   __ mov(result_reg-&gt;as_register(), r15_thread);
4075 #else
4076   __ get_thread(result_reg-&gt;as_register());
4077 #endif // _LP64
4078 }
4079 
4080 
4081 void LIR_Assembler::peephole(LIR_List*) {
4082   // do nothing for now
4083 }
4084 
4085 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4086   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4087 
4088   if (data-&gt;type() == T_INT) {
4089     if (code == lir_xadd) {
4090       __ lock();
4091       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4092     } else {
4093       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4094     }
4095   } else if (data-&gt;is_oop()) {
4096     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4097     Register obj = data-&gt;as_register();
4098 #ifdef _LP64
4099     if (UseCompressedOops) {
4100       __ encode_heap_oop(obj);
4101       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4102       __ decode_heap_oop(obj);
4103     } else {
4104       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4105     }
4106 #else
4107     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4108 #endif
4109   } else if (data-&gt;type() == T_LONG) {
4110 #ifdef _LP64
4111     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4112     if (code == lir_xadd) {
4113       __ lock();
4114       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4115     } else {
4116       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4117     }
4118 #else
4119     ShouldNotReachHere();
4120 #endif
4121   } else {
4122     ShouldNotReachHere();
4123   }
4124 }
4125 
4126 #undef __
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.Comparator;
  41 import java.util.Deque;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.LinkedHashMap;
  47 import java.util.LinkedHashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.SortedSet;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.Predicate;
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
  61 import javax.lang.model.element.AnnotationMirror;
  62 import javax.lang.model.element.AnnotationValue;
  63 import javax.lang.model.element.Element;
  64 import javax.lang.model.element.ElementKind;
  65 import javax.lang.model.element.ExecutableElement;
  66 import javax.lang.model.element.Modifier;
  67 import javax.lang.model.element.ModuleElement;
  68 import javax.lang.model.element.ModuleElement.RequiresDirective;
  69 import javax.lang.model.element.PackageElement;
  70 import javax.lang.model.element.RecordComponentElement;
  71 import javax.lang.model.element.TypeElement;
  72 import javax.lang.model.element.TypeParameterElement;
  73 import javax.lang.model.element.VariableElement;
  74 import javax.lang.model.type.ArrayType;
  75 import javax.lang.model.type.DeclaredType;
  76 import javax.lang.model.type.ErrorType;
  77 import javax.lang.model.type.ExecutableType;
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;
  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.SerialFieldTree;
 100 import com.sun.source.doctree.UnknownBlockTagTree;
 101 import com.sun.source.tree.CompilationUnitTree;
 102 import com.sun.source.tree.LineMap;
 103 import com.sun.source.util.DocSourcePositions;
 104 import com.sun.source.util.DocTrees;
 105 import com.sun.source.util.TreePath;
 106 import com.sun.tools.javac.model.JavacTypes;
 107 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
 111 import jdk.javadoc.internal.doclets.toolkit.Messages;
 112 import jdk.javadoc.internal.doclets.toolkit.Resources;
 113 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 115 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 116 import jdk.javadoc.internal.tool.DocEnvImpl;
 117 
 118 import static javax.lang.model.element.ElementKind.*;
 119 import static javax.lang.model.element.Modifier.*;
 120 import static javax.lang.model.type.TypeKind.*;
 121 
 122 import static com.sun.source.doctree.DocTree.Kind.*;
 123 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 124 
 125 /**
 126  * Utilities Class for Doclets.
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Utils {
 134     public final BaseConfiguration configuration;
 135     private final BaseOptions options;
 136     private final Messages messages;
 137     private final Resources resources;
 138     public final DocTrees docTrees;
 139     public final Elements elementUtils;
 140     public final Types typeUtils;
 141     private final JavaScriptScanner javaScriptScanner;
 142 
 143     public Utils(BaseConfiguration c) {
 144         configuration = c;
 145         options = configuration.getOptions();
 146         messages = configuration.getMessages();
 147         resources = configuration.getDocResources();
 148         elementUtils = c.docEnv.getElementUtils();
 149         typeUtils = c.docEnv.getTypeUtils();
 150         docTrees = c.docEnv.getDocTrees();
 151         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 152     }
 153 
 154     // our own little symbol table
 155     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 156 
 157     public TypeMirror getSymbol(String signature) {
 158         TypeMirror type = symtab.get(signature);
 159         if (type == null) {
 160             TypeElement typeElement = elementUtils.getTypeElement(signature);
 161             if (typeElement == null)
 162                 return null;
 163             type = typeElement.asType();
 164             if (type == null)
 165                 return null;
 166             symtab.put(signature, type);
 167         }
 168         return type;
 169     }
 170 
 171     public TypeMirror getObjectType() {
 172         return getSymbol(&quot;java.lang.Object&quot;);
 173     }
 174 
 175     public TypeMirror getExceptionType() {
 176         return getSymbol(&quot;java.lang.Exception&quot;);
 177     }
 178 
 179     public TypeMirror getErrorType() {
 180         return getSymbol(&quot;java.lang.Error&quot;);
 181     }
 182 
 183     public TypeMirror getSerializableType() {
 184         return getSymbol(&quot;java.io.Serializable&quot;);
 185     }
 186 
 187     public TypeMirror getExternalizableType() {
 188         return getSymbol(&quot;java.io.Externalizable&quot;);
 189     }
 190 
 191     public TypeMirror getIllegalArgumentExceptionType() {
 192         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 193     }
 194 
 195     public TypeMirror getNullPointerExceptionType() {
 196         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<a name="1" id="anc1"></a><span class="line-modified"> 217         List&lt;Element&gt; excludeList = members.stream()</span>
<span class="line-modified"> 218                 .filter((member) -&gt; (!isDeprecated(member)))</span>
<span class="line-modified"> 219                 .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));</span>
<span class="line-removed"> 221         return excludeList;</span>
 222     }
 223 
 224     /**
 225      * Search for the given method in the given class.
 226      *
 227      * @param  te        Class to search into.
 228      * @param  method    Method to be searched.
 229      * @return ExecutableElement Method found, null otherwise.
 230      */
 231     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 232         for (Element m : getMethods(te)) {
<a name="2" id="anc2"></a><span class="line-modified"> 233             if (executableMembersEqual(method, (ExecutableElement)m)) {</span>
<span class="line-modified"> 234                 return (ExecutableElement)m;</span>
 235             }
 236         }
 237         return null;
 238     }
 239 
 240     /**
 241      * Test whether a class is a subclass of another class.
 242      *
 243      * @param t1 the candidate superclass.
 244      * @param t2 the target
 245      * @return true if t1 is a superclass of t2.
 246      */
 247     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 248         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 249     }
 250 
 251     /**
 252      * @param e1 the first method to compare.
 253      * @param e2 the second method to compare.
 254      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 255      */
<a name="3" id="anc3"></a><span class="line-removed"> 256 </span>
 257     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 258         // TODO: investigate if Elements.hides(..) will work here.
 259         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 260             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 261             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 262             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 263                     parameters1.size() == parameters2.size()) {
 264                 int j;
 265                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 266                     VariableElement v1 = parameters1.get(j);
 267                     VariableElement v2 = parameters2.get(j);
 268                     String t1 = getTypeName(v1.asType(), true);
 269                     String t2 = getTypeName(v2.asType(), true);
 270                     if (!(t1.equals(t2) ||
 271                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 272                         break;
 273                     }
 274                 }
 275                 if (j == parameters1.size()) {
<a name="4" id="anc4"></a><span class="line-modified"> 276                 return true;</span>
 277                 }
 278             }
 279             return false;
 280         } else {
 281             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 282                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 283                     e1.equals(e2);
 284         }
 285     }
 286 
 287     /**
 288      * According to
 289      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 290      * all the outer classes and static inner classes are core classes.
 291      */
 292     public boolean isCoreClass(TypeElement e) {
 293         return getEnclosingTypeElement(e) == null || isStatic(e);
 294     }
 295 
 296     public Location getLocationForPackage(PackageElement pd) {
 297         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 298 
 299         if (mdle == null)
 300             return defaultLocation();
 301 
 302         return getLocationForModule(mdle);
 303     }
 304 
 305     public Location getLocationForModule(ModuleElement mdle) {
 306         Location loc = configuration.workArounds.getLocationForModule(mdle);
 307         if (loc != null)
 308             return loc;
 309 
 310         return defaultLocation();
 311     }
 312 
 313     private Location defaultLocation() {
 314         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 315         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 316                 ? StandardLocation.SOURCE_PATH
 317                 : StandardLocation.CLASS_PATH;
 318     }
 319 
 320     public boolean isAnnotated(TypeMirror e) {
 321         return !e.getAnnotationMirrors().isEmpty();
 322     }
 323 
 324     public boolean isAnnotated(Element e) {
 325         return !e.getAnnotationMirrors().isEmpty();
 326     }
 327 
 328     @SuppressWarnings(&quot;preview&quot;)
 329     public boolean isAnnotationType(Element e) {
 330         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 331             @Override
 332             public Boolean visitExecutable(ExecutableElement e, Void p) {
 333                 return visit(e.getEnclosingElement());
 334             }
 335 
 336             @Override
 337             public Boolean visitUnknown(Element e, Void p) {
 338                 return false;
 339             }
 340 
 341             @Override
 342             protected Boolean defaultAction(Element e, Void p) {
 343                 return e.getKind() == ANNOTATION_TYPE;
 344             }
 345         }.visit(e);
 346     }
 347 
 348     /**
 349      * An Enum implementation is almost identical, thus this method returns if
 350      * this element represents a CLASS or an ENUM
 351      * @param e element
 352      * @return true if class or enum
 353      */
 354     public boolean isClass(Element e) {
 355         return e.getKind().isClass();
 356     }
 357 
 358     public boolean isConstructor(Element e) {
 359          return e.getKind() == CONSTRUCTOR;
 360     }
 361 
 362     public boolean isEnum(Element e) {
 363         return e.getKind() == ENUM;
 364     }
 365 
 366     boolean isEnumConstant(Element e) {
 367         return e.getKind() == ENUM_CONSTANT;
 368     }
 369 
 370     public boolean isField(Element e) {
 371         return e.getKind() == FIELD;
 372     }
 373 
 374     public boolean isInterface(Element e) {
 375         return e.getKind() == INTERFACE;
 376     }
 377 
 378     public boolean isMethod(Element e) {
 379         return e.getKind() == METHOD;
 380     }
 381 
 382     public boolean isModule(Element e) {
 383         return e.getKind() == ElementKind.MODULE;
 384     }
 385 
 386     public boolean isPackage(Element e) {
 387         return e.getKind() == ElementKind.PACKAGE;
 388     }
 389 
 390     public boolean isAbstract(Element e) {
 391         return e.getModifiers().contains(Modifier.ABSTRACT);
 392     }
 393 
 394     public boolean isDefault(Element e) {
 395         return e.getModifiers().contains(Modifier.DEFAULT);
 396     }
 397 
 398     public boolean isPackagePrivate(Element e) {
 399         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 400     }
 401 
 402     public boolean isPrivate(Element e) {
 403         return e.getModifiers().contains(Modifier.PRIVATE);
 404     }
 405 
 406     public boolean isProtected(Element e) {
 407         return e.getModifiers().contains(Modifier.PROTECTED);
 408     }
 409 
 410     public boolean isPublic(Element e) {
 411         return e.getModifiers().contains(Modifier.PUBLIC);
 412     }
 413 
 414     public boolean isProperty(String name) {
 415         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 416     }
 417 
 418     public String getPropertyName(String name) {
 419         return isProperty(name)
 420                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 421                 : name;
 422     }
 423 
 424     public String getPropertyLabel(String name) {
 425         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 426     }
 427 
 428     public boolean isOverviewElement(Element e) {
 429         return e.getKind() == ElementKind.OTHER;
 430     }
 431 
 432     public boolean isStatic(Element e) {
 433         return e.getModifiers().contains(Modifier.STATIC);
 434     }
 435 
 436     public boolean isSerializable(TypeElement e) {
 437         return typeUtils.isSubtype(e.asType(), getSerializableType());
 438     }
 439 
 440     public boolean isExternalizable(TypeElement e) {
 441         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 442     }
 443 
 444     @SuppressWarnings(&quot;preview&quot;)
 445     public boolean isRecord(TypeElement e) {
 446         return e.getKind() == ElementKind.RECORD;
 447     }
 448 
 449     @SuppressWarnings(&quot;preview&quot;)
 450     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 451         TypeElement te = (TypeElement) ee.getEnclosingElement();
 452         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 453         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 454         if (stateComps.size() != params.size()) {
 455             return false;
 456         }
 457 
 458         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 459         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 460         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 461             VariableElement param = paramIter.next();
 462             RecordComponentElement comp = stateIter.next();
 463             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 464                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 465                 return false;
 466             }
 467         }
 468 
 469         return true;
 470     }
 471 
 472     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 473         return configuration.workArounds.getSerializableFields(aclass);
 474     }
 475 
 476     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 477         return configuration.workArounds.getSerializationMethods(aclass);
 478     }
 479 
 480     public boolean definesSerializableFields(TypeElement aclass) {
 481         return configuration.workArounds.definesSerializableFields( aclass);
 482     }
 483 
 484     @SuppressWarnings(&quot;preview&quot;)
 485     public String modifiersToString(Element e, boolean trailingSpace) {
 486         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 487         modifiers.remove(NATIVE);
 488         modifiers.remove(STRICTFP);
 489         modifiers.remove(SYNCHRONIZED);
 490 
 491         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 492             final StringBuilder sb = new StringBuilder();
 493 
 494             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 495                 if (modifiers.contains(PUBLIC)) {
 496                     append(&quot;public&quot;);
 497                 } else if (modifiers.contains(PROTECTED)) {
 498                     append(&quot;protected&quot;);
 499                 } else if (modifiers.contains(PRIVATE)) {
 500                     append(&quot;private&quot;);
 501                 }
 502             }
 503 
 504             void addStatic(Set&lt;Modifier&gt; modifiers) {
 505                 if (modifiers.contains(STATIC)) {
 506                     append(&quot;static&quot;);
 507                 }
 508             }
 509 
 510             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<a name="5" id="anc5"></a><span class="line-modified"> 511                 modifiers.stream().map(Modifier::toString).forEach(this::append);</span>
 512             }
 513 
 514             void append(String s) {
 515                 if (sb.length() &gt; 0) {
 516                     sb.append(&quot; &quot;);
 517                 }
 518                 sb.append(s);
 519             }
 520 
 521             String finalString(String s) {
 522                 append(s);
 523                 if (trailingSpace) {
 524                     sb.append(&quot; &quot;);
<a name="6" id="anc6"></a><span class="line-modified"> 525                     }</span>
 526                 return sb.toString();
 527             }
 528 
 529             @Override
 530             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 531                 addVisibilityModifier(mods);
 532                 addStatic(mods);
 533                 return finalString(&quot;interface&quot;);
 534             }
 535 
 536             @Override
 537             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 538                 addVisibilityModifier(mods);
 539                 addStatic(mods);
 540                 return finalString(&quot;enum&quot;);
 541             }
 542 
 543             @Override
 544             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 545                 addVisibilityModifier(mods);
 546                 addStatic(mods);
 547                 return finalString(&quot;@interface&quot;);
 548             }
 549 
 550             @Override
 551             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 552                 mods.remove(FINAL); // suppress the implicit `final`
 553                 return visitTypeAsClass(e, mods);
 554             }
 555 
 556             @Override
 557             @SuppressWarnings(&quot;preview&quot;)
 558             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 559                 addModifiers(mods);
 560                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 561                 return finalString(keyword);
 562             }
 563 
 564             @Override
 565             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 566                 addModifiers(mods);
 567                 return sb.toString().trim();
 568             }
 569 
 570         }.visit(e, modifiers);
 571     }
 572 
 573     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 574         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 575                 configuration.docEnv.getSourceVersion()
 576                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 577     }
 578 
 579     public boolean isNoType(TypeMirror t) {
 580         return t.getKind() == NONE;
 581     }
 582 
 583     public boolean isOrdinaryClass(TypeElement te) {
 584         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 585             return false;
 586         }
 587         if (isError(te) || isException(te)) {
 588             return false;
 589         }
 590         return true;
 591     }
 592 
 593     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 594         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 595                 &amp;&amp; !isLinkable(enclosingTypeElement);
 596     }
 597 
 598     public boolean isError(TypeElement te) {
 599         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 600             return false;
 601         }
 602         return typeUtils.isSubtype(te.asType(), getErrorType());
 603     }
 604 
 605     public boolean isException(TypeElement te) {
 606         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 607             return false;
 608         }
 609         return typeUtils.isSubtype(te.asType(), getExceptionType());
 610     }
 611 
 612     public boolean isPrimitive(TypeMirror t) {
 613         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 614 
 615             @Override
 616             public Boolean visitNoType(NoType t, Void p) {
 617                 return t.getKind() == VOID;
 618             }
 619             @Override
 620             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 621                 return true;
 622             }
 623             @Override
 624             public Boolean visitArray(ArrayType t, Void p) {
 625                 return visit(t.getComponentType());
 626             }
 627             @Override
 628             protected Boolean defaultAction(TypeMirror e, Void p) {
 629                 return false;
 630             }
 631         }.visit(t);
 632     }
 633 
 634     public boolean isExecutableElement(Element e) {
 635         ElementKind kind = e.getKind();
 636         switch (kind) {
 637             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 638                 return true;
 639             default:
 640                 return false;
 641         }
 642     }
 643 
 644     public boolean isVariableElement(Element e) {
 645         ElementKind kind = e.getKind();
 646         switch(kind) {
 647               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 648               case LOCAL_VARIABLE: case PARAMETER:
 649               case RESOURCE_VARIABLE:
 650                   return true;
 651               default:
 652                   return false;
 653         }
 654     }
 655 
 656     public boolean isTypeElement(Element e) {
 657         switch (e.getKind()) {
 658             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 659                 return true;
 660             default:
 661                 return false;
 662         }
 663     }
 664 
 665     /**
 666      * Get the signature. It is the parameter list, type is qualified.
 667      * For instance, for a method {@code mymethod(String x, int y)},
<a name="7" id="anc7"></a><span class="line-modified"> 668      * it will return {@code(java.lang.String,int)}.</span>
 669      *
 670      * @param e
 671      * @return String
 672      */
 673     public String signature(ExecutableElement e) {
 674         return makeSignature(e, true);
 675     }
 676 
 677     /**
 678      * Get flat signature.  All types are not qualified.
 679      * Return a String, which is the flat signature of this member.
 680      * It is the parameter list, type is not qualified.
 681      * For instance, for a method {@code mymethod(String x, int y)},
 682      * it will return {@code (String, int)}.
 683      */
 684     public String flatSignature(ExecutableElement e) {
 685         return makeSignature(e, false);
 686     }
 687 
 688     public String makeSignature(ExecutableElement e, boolean full) {
 689         return makeSignature(e, full, false);
 690     }
 691 
 692     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {
 693         StringBuilder result = new StringBuilder();
 694         result.append(&quot;(&quot;);
 695         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();
 696         while (iterator.hasNext()) {
 697             VariableElement next = iterator.next();
 698             TypeMirror type = next.asType();
 699             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 700             if (iterator.hasNext()) {
 701                 result.append(&quot;, &quot;);
 702             }
 703         }
 704         if (e.isVarArgs()) {
 705             int len = result.length();
 706             result.replace(len - 2, len, &quot;...&quot;);
 707         }
 708         result.append(&quot;)&quot;);
 709         return result.toString();
 710     }
 711 
 712     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 713         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 714             final StringBuilder sb = new StringBuilder();
 715 
 716             @Override
 717             public StringBuilder visitArray(ArrayType t, Void p) {
 718                 TypeMirror componentType = t.getComponentType();
 719                 visit(componentType);
 720                 sb.append(&quot;[]&quot;);
 721                 return sb;
 722             }
 723 
 724             @Override
 725             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 726                 Element e = t.asElement();
 727                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 728                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 729                 if (typeArguments.isEmpty() || noTypeParameters) {
 730                     return sb;
 731                 }
 732                 sb.append(&quot;&lt;&quot;);
 733                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 734                 while (iterator.hasNext()) {
 735                     TypeMirror ta = iterator.next();
 736                     visit(ta);
 737                     if (iterator.hasNext()) {
 738                         sb.append(&quot;, &quot;);
 739                     }
 740                 }
 741                 sb.append(&quot;&gt;&quot;);
 742                 return sb;
 743             }
 744 
 745             @Override
 746             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 747                 Element e = t.asElement();
 748                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 749                 return sb;
 750             }
 751 
 752             @Override
 753             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 754                 sb.append(&quot;?&quot;);
 755                 TypeMirror upperBound = t.getExtendsBound();
 756                 if (upperBound != null) {
 757                     sb.append(&quot; extends &quot;);
 758                     visit(upperBound);
 759                 }
 760                 TypeMirror superBound = t.getSuperBound();
 761                 if (superBound != null) {
 762                     sb.append(&quot; super &quot;);
 763                     visit(superBound);
 764                 }
 765                 return sb;
 766             }
 767 
 768             @Override
 769             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 770                 return sb.append(e);
 771             }
 772         }.visit(t).toString();
 773     }
 774 
 775     public boolean isArrayType(TypeMirror t) {
 776         return t.getKind() == ARRAY;
 777     }
 778 
 779     public boolean isDeclaredType(TypeMirror t) {
 780         return t.getKind() == DECLARED;
 781     }
 782 
 783     public boolean isErrorType(TypeMirror t) {
 784         return t.getKind() == ERROR;
 785     }
 786 
 787     public boolean isIntersectionType(TypeMirror t) {
 788         return t.getKind() == INTERSECTION;
 789     }
 790 
 791     public boolean isTypeParameterElement(Element e) {
 792         return e.getKind() == TYPE_PARAMETER;
 793     }
 794 
 795     public boolean isTypeVariable(TypeMirror t) {
 796         return t.getKind() == TYPEVAR;
 797     }
 798 
 799     public boolean isVoid(TypeMirror t) {
 800         return t.getKind() == VOID;
 801     }
 802 
 803     public boolean isWildCard(TypeMirror t) {
 804         return t.getKind() == WILDCARD;
 805     }
 806 
 807     public boolean ignoreBounds(TypeMirror bound) {
 808         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 809     }
 810 
 811     /*
 812      * a direct port of TypeVariable.getBounds
 813      */
 814     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 815         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 816         if (!bounds.isEmpty()) {
 817             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 818             if (ignoreBounds(upperBound)) {
 819                 return Collections.emptyList();
 820             }
 821         }
 822         return bounds;
 823     }
 824 
 825     /**
 826      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 827      * if it is a constructor.
 828      * @param site the contextual type
 829      * @param ee the ExecutableElement
 830      * @return the return type
 831      */
 832     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 833         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 834     }
 835 
 836     /**
 837      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 838      * member of a given declared type. This might cause type-variable substitution to kick in.
 839      * @param site the contextual type.
 840      * @param ee the method declaration.
 841      * @return the instantiated method type.
 842      */
 843     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 844         return shouldInstantiate(site, ee) ?
 845                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 846                 (ExecutableType)ee.asType();
 847     }
 848 
 849     /**
 850      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 851      * member of a given declared type. This might cause type-variable substitution to kick in.
 852      * @param site the contextual type.
 853      * @param ve the field declaration.
 854      * @return the instantiated field type.
 855      */
 856     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 857         return shouldInstantiate(site, ve) ?
 858                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 859                 ve.asType();
 860     }
 861 
 862     /*
 863      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 864      * to which the member belongs to is the same as the one under consideration, (iii) if the
 865      * delcaration to which the member belongs to is not generic.
 866      */
 867     private boolean shouldInstantiate(TypeElement site, Element e) {
 868         return site != null &amp;&amp;
 869                 site != e.getEnclosingElement() &amp;&amp;
 870                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 871     }
 872 
 873     /**
 874      * Return the type containing the method that this method overrides.
 875      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 876      */
 877     public TypeMirror overriddenType(ExecutableElement method) {
 878         return configuration.workArounds.overriddenType(method);
 879     }
 880 
 881     private  TypeMirror getType(TypeMirror t) {
 882         return (isNoType(t)) ? getObjectType() : t;
 883     }
 884 
 885     public TypeMirror getSuperType(TypeElement te) {
 886         TypeMirror t = te.getSuperclass();
 887         return getType(t);
 888     }
 889 
 890     /**
 891      * Return the class that originally defined the method that
 892      * is overridden by the current definition, or null if no
 893      * such class exists.
 894      *
 895      * @return a TypeElement representing the superclass that
 896      * originally defined this method, null if this method does
 897      * not override a definition in a superclass.
 898      */
 899     public TypeElement overriddenClass(ExecutableElement ee) {
 900         TypeMirror type = overriddenType(ee);
 901         return (type != null) ? asTypeElement(type) : null;
 902     }
 903 
 904     public ExecutableElement overriddenMethod(ExecutableElement method) {
 905         if (isStatic(method)) {
 906             return null;
 907         }
 908         final TypeElement origin = getEnclosingTypeElement(method);
 909         for (TypeMirror t = getSuperType(origin);
 910                 t.getKind() == DECLARED;
 911                 t = getSuperType(asTypeElement(t))) {
 912             TypeElement te = asTypeElement(t);
 913             if (te == null) {
 914                 return null;
 915             }
 916             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 917             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 918                 ExecutableElement ee = (ExecutableElement)e;
 919                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 920                         !isSimpleOverride(ee)) {
 921                     return ee;
 922                 }
 923             }
 924             if (t.equals(getObjectType()))
 925                 return null;
 926         }
 927         return null;
 928     }
 929 
 930     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 931         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<a name="8" id="anc8"></a><span class="line-modified"> 932         for (TypeElement te : typeElements) {</span>
<span class="line-removed"> 933             set.add(te);</span>
<span class="line-removed"> 934         }</span>
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
 954      * @param enclosing a TypeElement whose type arguments  we desire
 955      * @param target the TypeMirror of the type as described by the enclosing
 956      * @return
 957      */
 958     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 959                                       TypeElement enclosing, TypeMirror target) {
 960         TypeElement targetElement = asTypeElement(target);
 961         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 962         if (targetTypeArgs.isEmpty()) {
 963             return target;
 964         }
 965 
 966         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 967         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 968 
 969         if (enclosingTypeArgs.isEmpty()) {
 970             for (TypeMirror te : values) {
 971                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 972                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 973                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 974                         targetTypeArgTypes.add(typeArguments.get(i));
 975                     }
 976                     break;
 977                 }
 978             }
 979             // we found no matches in the hierarchy
 980             if (targetTypeArgTypes.isEmpty()) {
 981                 return target;
 982             }
 983         } else {
 984             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 985                 return target;
 986             }
 987             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 988                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
 989                 targetTypeArgTypes.add(tpe.asType());
 990             }
 991         }
 992         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
 993                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
 994         return dt;
 995     }
 996 
 997     /**
 998      * Returns all the implemented super-interfaces of a given type,
 999      * in the case of classes, include all the super-interfaces of
1000      * the supertype. The super-interfaces are collected before the
1001      * super-interfaces of the supertype.
1002      *
1003      * @param  te the type element to get the super-interfaces for.
1004      * @return the list of super-interfaces.
1005      */
1006     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
1007         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
1008         getAllInterfaces(te.asType(), results);
1009         return results;
1010     }
1011 
1012     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
1013         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
1014         TypeMirror superType = null;
1015         for (TypeMirror intfac : intfacs) {
1016             if (intfac == getObjectType())
1017                 continue;
1018             TypeElement e = asTypeElement(intfac);
1019             if (isInterface(e)) {
1020                 if (isPublic(e) || isLinkable(e))
1021                     results.add(intfac);
1022 
1023                 getAllInterfaces(intfac, results);
1024             } else {
1025                 // Save the supertype for later.
1026                 superType = intfac;
1027             }
1028         }
1029         // Collect the super-interfaces of the supertype.
1030         if (superType != null)
1031             getAllInterfaces(superType, results);
1032     }
1033 
1034     /**
1035      * Lookup for a class within this package.
1036      *
1037      * @return TypeElement of found class, or null if not found.
1038      */
1039     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1040         for (TypeElement c : getAllClasses(pkg)) {
1041             if (getSimpleName(c).equals(className)) {
1042                 return c;
1043             }
1044         }
1045         return null;
1046     }
1047 
1048     /**
1049      * TODO: FIXME: port to javax.lang.model
1050      * Find a class within the context of this class. Search order: qualified name, in this class
1051      * (inner), in this package, in the class imports, in the package imports. Return the
1052      * TypeElement if found, null if not found.
1053      */
1054     //### The specified search order is not the normal rule the
1055     //### compiler would use.  Leave as specified or change it?
1056     public TypeElement findClass(Element element, String className) {
1057         TypeElement encl = getEnclosingTypeElement(element);
1058         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1059         if (searchResult == null) {
1060             encl = getEnclosingTypeElement(encl);
1061             //Expand search space to include enclosing class.
1062             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1063                 encl = getEnclosingTypeElement(encl);
1064             }
1065             searchResult = encl == null
1066                     ? null
1067                     : configuration.workArounds.searchClass(encl, className);
1068         }
1069         return searchResult;
1070     }
1071 
1072     /**
1073      * Enclose in quotes, used for paths and filenames that contains spaces
1074      */
1075     public String quote(String filepath) {
1076         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1077     }
1078 
1079     /**
1080      * Parse the package name.  We only want to display package name up to
1081      * 2 levels.
1082      */
1083     public String parsePackageName(PackageElement p) {
1084         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1085         int index = -1;
1086         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1087             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1088         }
1089         if (index != -1) {
1090             pkgname = pkgname.substring(0, index);
1091         }
1092         return pkgname;
1093     }
1094 
1095     /**
1096      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1097      * @param originalStr the string to modify.
1098      * @param oldStr the string to replace.
1099      * @param newStr the string to insert in place of the old string.
1100      */
1101     public String replaceText(String originalStr, String oldStr,
1102             String newStr) {
1103         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1104             return originalStr;
1105         }
1106         return originalStr.replace(oldStr, newStr);
1107     }
1108 
1109     /**
1110      * Given an annotation, return true if it should be documented and false
1111      * otherwise.
1112      *
1113      * @param annotation the annotation to check.
1114      *
1115      * @return true return true if it should be documented and false otherwise.
1116      */
1117     public boolean isDocumentedAnnotation(TypeElement annotation) {
1118         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1119             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1120                     Documented.class.getName())) {
1121                 return true;
1122             }
1123         }
1124         return false;
1125     }
1126 
1127     /**
1128      * Returns true if this class is linkable and false if we can&#39;t link to it.
1129      *
1130      * &lt;p&gt;
1131      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1132      * protected.
1133      *
1134      * @return true if this class is linkable and false if we can&#39;t link to the
1135      * desired class.
1136      */
1137     public boolean isLinkable(TypeElement typeElem) {
1138         return
1139             (typeElem != null &amp;&amp;
1140                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1141             (configuration.extern.isExternal(typeElem) &amp;&amp;
1142                 (isPublic(typeElem) || isProtected(typeElem)));
1143     }
1144 
1145     /**
1146      * Returns true if an element is linkable in the context of a given type element.
1147      *
1148      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1149      * Otherwise, the element is linkable if any of the following are true:
1150      * &lt;ul&gt;
1151      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1152      * &lt;li&gt;it is inherited from an undocumented supertype
1153      * &lt;li&gt;it is a public or protected member of an external API
1154      * &lt;/ul&gt;
1155      *
1156      * @param typeElem the type element
1157      * @param elem the element
1158      * @return whether or not the element is linkable
1159      */
1160     public boolean isLinkable(TypeElement typeElem, Element elem) {
1161         if (isTypeElement(elem)) {
1162             return isLinkable((TypeElement) elem); // defer to existing behavior
1163         }
1164 
1165         if (isIncluded(elem)) {
1166             return true;
1167         }
1168 
1169         // Allow for the behavior that members of undocumented supertypes
1170         // may be included in documented types
1171         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1172             return true;
1173         }
1174 
1175         // Allow for external members
1176         return isLinkable(typeElem)
1177                     &amp;&amp; configuration.extern.isExternal(typeElem)
1178                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1179     }
1180 
1181     /**
1182      * Return this type as a {@code TypeElement} if it represents a class
1183      * interface or annotation.  Array dimensions are ignored.
1184      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1185      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1186      * annotation, return this as a {@code TypeElement}.
1187      * If this is a primitive type, return null.
1188      *
1189      * @return the {@code TypeElement} of this type,
1190      *         or null if it is a primitive type.
1191      */
1192     public TypeElement asTypeElement(TypeMirror t) {
1193         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1194 
1195             @Override
1196             public TypeElement visitDeclared(DeclaredType t, Void p) {
1197                 return (TypeElement) t.asElement();
1198             }
1199 
1200             @Override
1201             public TypeElement visitArray(ArrayType t, Void p) {
1202                 return visit(t.getComponentType());
1203             }
1204 
1205             @Override
1206             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1207                /* TODO, this may not be an optimal fix.
1208                 * if we have an annotated type @DA T, then erasure returns a
1209                 * none, in this case we use asElement instead.
1210                 */
1211                 if (isAnnotated(t)) {
1212                     return visit(typeUtils.asElement(t).asType());
1213                 }
1214                 return visit(typeUtils.erasure(t));
1215             }
1216 
1217             @Override
1218             public TypeElement visitWildcard(WildcardType t, Void p) {
1219                 return visit(typeUtils.erasure(t));
1220             }
1221 
1222             @Override
1223             public TypeElement visitError(ErrorType t, Void p) {
1224                 return (TypeElement)t.asElement();
1225             }
1226 
1227             @Override
1228             protected TypeElement defaultAction(TypeMirror e, Void p) {
1229                 return super.defaultAction(e, p);
1230             }
1231         }.visit(t);
1232     }
1233 
1234     public TypeMirror getComponentType(TypeMirror t) {
1235         while (isArrayType(t)) {
1236             t = ((ArrayType) t).getComponentType();
1237         }
1238         return t;
1239     }
1240 
1241     /**
1242      * Return the type&#39;s dimension information, as a string.
1243      * &lt;p&gt;
1244      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1245      *
1246      * @return the type&#39;s dimension information as a string.
1247      */
1248     public String getDimension(TypeMirror t) {
1249         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<a name="9" id="anc9"></a><span class="line-modified">1250             StringBuilder dimension = new StringBuilder(&quot;&quot;);</span>
1251             @Override
1252             public String visitArray(ArrayType t, Void p) {
1253                 dimension.append(&quot;[]&quot;);
1254                 return visit(t.getComponentType());
1255             }
1256 
1257             @Override
1258             protected String defaultAction(TypeMirror e, Void p) {
1259                 return dimension.toString();
1260             }
1261 
1262         }.visit(t);
1263     }
1264 
1265     public TypeElement getSuperClass(TypeElement te) {
1266         if (isInterface(te) || isAnnotationType(te) ||
1267                 te.asType().equals(getObjectType())) {
1268             return null;
1269         }
1270         TypeMirror superclass = te.getSuperclass();
1271         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1272             superclass = getObjectType();
1273         }
1274         return asTypeElement(superclass);
1275     }
1276 
1277     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1278         if (isAnnotationType(te) || isInterface(te) ||
1279                 te.asType().equals(getObjectType())) {
1280             return null;
1281         }
1282         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1283         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1284     }
1285 
1286     /**
1287      * Given a class, return the closest visible super class.
1288      * @param type the TypeMirror to be interrogated
1289      * @return  the closest visible super class.  Return null if it cannot
1290      *          be found.
1291      */
1292 
1293     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1294         return getFirstVisibleSuperClass(asTypeElement(type));
1295     }
1296 
1297 
1298     /**
1299      * Given a class, return the closest visible super class.
1300      *
1301      * @param te the TypeElement to be interrogated
1302      * @return the closest visible super class.  Return null if it cannot
1303      *         be found..
1304      */
1305     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1306         TypeMirror superType = te.getSuperclass();
1307         if (isNoType(superType)) {
1308             superType = getObjectType();
1309         }
1310         TypeElement superClass = asTypeElement(superType);
1311         // skip &quot;hidden&quot; classes
1312         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1313                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1314             TypeMirror supersuperType = superClass.getSuperclass();
1315             TypeElement supersuperClass = asTypeElement(supersuperType);
1316             if (supersuperClass == null
1317                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1318                 break;
1319             }
1320             superType = supersuperType;
1321             superClass = supersuperClass;
1322         }
1323         if (te.asType().equals(superType)) {
1324             return null;
1325         }
1326         return superType;
1327     }
1328 
1329     /**
1330      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1331      *
1332      * @param te the TypeElement to check.
1333      * @param lowerCaseOnly true if you want the name returned in lower case.
1334      *                      If false, the first letter of the name is capitalized.
1335      * @return
1336      */
<a name="10" id="anc10"></a><span class="line-removed">1337 </span>
1338     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1339         String typeName = &quot;&quot;;
1340         if (isInterface(te)) {
1341             typeName = &quot;doclet.Interface&quot;;
1342         } else if (isException(te)) {
1343             typeName = &quot;doclet.Exception&quot;;
1344         } else if (isError(te)) {
1345             typeName = &quot;doclet.Error&quot;;
1346         } else if (isAnnotationType(te)) {
1347             typeName = &quot;doclet.AnnotationType&quot;;
1348         } else if (isEnum(te)) {
1349             typeName = &quot;doclet.Enum&quot;;
1350         } else if (isOrdinaryClass(te)) {
1351             typeName = &quot;doclet.Class&quot;;
1352         }
1353         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1354         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1355     }
1356 
1357     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1358 
1359     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1360         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1361 
1362             @Override
1363             public String visitArray(ArrayType t, Void p) {
1364                 return visit(t.getComponentType());
1365             }
1366 
1367             @Override
1368             public String visitDeclared(DeclaredType t, Void p) {
1369                 TypeElement te = asTypeElement(t);
1370                 return fullyQualified
1371                         ? te.getQualifiedName().toString()
1372                         : getSimpleName(te);
1373             }
1374 
1375             @Override
1376             public String visitExecutable(ExecutableType t, Void p) {
1377                 return t.toString();
1378             }
1379 
1380             @Override
1381             public String visitPrimitive(PrimitiveType t, Void p) {
1382                 return t.toString();
1383             }
1384 
1385             @Override
1386             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1387                 return getSimpleName(t.asElement());
1388             }
1389 
1390             @Override
1391             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1392                 return t.toString();
1393             }
1394 
1395             @Override
1396             protected String defaultAction(TypeMirror e, Void p) {
1397                 return e.toString();
1398             }
1399         }.visit(t);
1400     }
1401 
1402     /**
1403      * Replace all tabs in a string with the appropriate number of spaces.
1404      * The string may be a multi-line string.
1405      * @param text the text for which the tabs should be expanded
1406      * @return the text with all tabs expanded
1407      */
1408     public String replaceTabs(String text) {
1409         if (!text.contains(&quot;\t&quot;))
1410             return text;
1411 
1412         final int tabLength = options.sourceTabSize();
1413         final String whitespace = &quot; &quot;.repeat(tabLength);
1414         final int textLength = text.length();
1415         StringBuilder result = new StringBuilder(textLength);
1416         int pos = 0;
1417         int lineLength = 0;
1418         for (int i = 0; i &lt; textLength; i++) {
1419             char ch = text.charAt(i);
1420             switch (ch) {
1421                 case &#39;\n&#39;: case &#39;\r&#39;:
1422                     lineLength = 0;
1423                     break;
1424                 case &#39;\t&#39;:
1425                     result.append(text, pos, i);
1426                     int spaceCount = tabLength - lineLength % tabLength;
1427                     result.append(whitespace, 0, spaceCount);
1428                     lineLength += spaceCount;
1429                     pos = i + 1;
1430                     break;
1431                 default:
1432                     lineLength++;
1433             }
1434         }
1435         result.append(text, pos, textLength);
1436         return result.toString();
1437     }
1438 
1439     public CharSequence normalizeNewlines(CharSequence text) {
1440         StringBuilder sb = new StringBuilder();
1441         final int textLength = text.length();
1442         final String NL = DocletConstants.NL;
1443         int pos = 0;
1444         for (int i = 0; i &lt; textLength; i++) {
1445             char ch = text.charAt(i);
1446             switch (ch) {
1447                 case &#39;\n&#39;:
1448                     sb.append(text, pos, i);
1449                     sb.append(NL);
1450                     pos = i + 1;
1451                     break;
1452                 case &#39;\r&#39;:
1453                     sb.append(text, pos, i);
1454                     sb.append(NL);
1455                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1456                         i++;
1457                     pos = i + 1;
1458                     break;
1459             }
1460         }
1461         sb.append(text, pos, textLength);
1462         return sb;
1463     }
1464 
1465     /**
1466      * Returns a locale independent lower cased String. That is, it
1467      * always uses US locale, this is a clone of the one in StringUtils.
1468      * @param s to convert
1469      * @return converted String
1470      */
1471     public static String toLowerCase(String s) {
1472         return s.toLowerCase(Locale.US);
1473     }
1474 
1475     /**
1476      * Return true if the given Element is deprecated.
1477      *
1478      * @param e the Element to check.
1479      * @return true if the given Element is deprecated.
1480      */
1481     public boolean isDeprecated(Element e) {
1482         if (isPackage(e)) {
1483             return configuration.workArounds.isDeprecated0(e);
1484         }
1485         return elementUtils.isDeprecated(e);
1486     }
1487 
1488     /**
1489      * Return true if the given Element is deprecated for removal.
1490      *
1491      * @param e the Element to check.
1492      * @return true if the given Element is deprecated for removal.
1493      */
1494     public boolean isDeprecatedForRemoval(Element e) {
1495         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1496         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1497         for (AnnotationMirror anno : annotationList) {
1498             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1499                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1500                 if (!pairs.isEmpty()) {
1501                     for (ExecutableElement element : pairs.keySet()) {
1502                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1503                             return Boolean.parseBoolean((pairs.get(element)).toString());
1504                         }
1505                     }
1506                 }
1507             }
1508         }
1509         return false;
1510     }
1511 
1512     /**
1513      * A convenience method to get property name from the name of the
1514      * getter or setter method.
1515      * @param e the input method.
1516      * @return the name of the property of the given setter of getter.
1517      */
1518     public String propertyName(ExecutableElement e) {
1519         String name = getSimpleName(e);
1520         String propertyName = null;
1521         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1522             propertyName = name.substring(3);
1523         } else if (name.startsWith(&quot;is&quot;)) {
1524             propertyName = name.substring(2);
1525         }
1526         if ((propertyName == null) || propertyName.isEmpty()){
1527             return &quot;&quot;;
1528         }
1529         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1530                 + propertyName.substring(1);
1531     }
1532 
1533     /**
1534      * Returns true if the element is included, contains &amp;#64;hidden tag,
1535      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1536      * tag.
1537      * @param e the queried element
1538      * @return true if it exists, false otherwise
1539      */
1540     public boolean hasHiddenTag(Element e) {
1541         // prevent needless tests on elements which are not included
1542         if (!isIncluded(e)) {
1543             return false;
1544         }
1545         if (options.javafx() &amp;&amp;
1546                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1547             return true;
1548         }
1549         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1550     }
1551 
1552     /**
1553      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1554      * @param m a method
1555      * @return true if there are no comments, false otherwise
1556      */
1557     public boolean isSimpleOverride(ExecutableElement m) {
1558         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1559             return false;
1560         }
1561 
1562         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1563             return false;
1564 
1565         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1566         return fullBody.isEmpty() ||
1567                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1568     }
1569 
1570     /**
1571      * In case of JavaFX mode on, filters out classes that are private,
1572      * package private, these are not documented in JavaFX mode, also
1573      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1574      *
1575      * @param classlist a collection of TypeElements
1576      * @param javafx set to true if in JavaFX mode.
1577      * @return list of filtered classes.
1578      */
1579     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1580             boolean javafx) {
1581         SortedSet&lt;TypeElement&gt; filteredOutClasses =
1582                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
1583         if (!javafx) {
1584             for (Element te : classlist) {
1585                 if (!hasHiddenTag(te)) {
1586                     filteredOutClasses.add((TypeElement)te);
1587                 }
1588             }
1589             return filteredOutClasses;
1590         }
1591         for (Element e : classlist) {
1592             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1593                 continue;
1594             }
1595             filteredOutClasses.add((TypeElement)e);
1596         }
1597         return filteredOutClasses;
1598     }
1599 
1600     /**
1601      * Compares two elements.
1602      * @param e1 first Element
1603      * @param e2 second Element
1604      * @return a true if they are the same, false otherwise.
1605      */
1606     public boolean elementsEqual(Element e1, Element e2) {
1607         if (e1.getKind() != e2.getKind()) {
1608             return false;
1609         }
1610         String s1 = getSimpleName(e1);
1611         String s2 = getSimpleName(e2);
1612         if (compareStrings(s1, s2) == 0) {
1613             String f1 = getFullyQualifiedName(e1, true);
1614             String f2 = getFullyQualifiedName(e2, true);
1615             return compareStrings(f1, f2) == 0;
1616         }
1617         return false;
1618     }
1619 
1620     /**
1621      * A general purpose case insensitive String comparator, which compares
1622      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1623      *
1624      * @param s1 first String to compare.
1625      * @param s2 second String to compare.
1626      * @return a negative integer, zero, or a positive integer as the first
1627      *         argument is less than, equal to, or greater than the second.
1628      */
1629     public int compareStrings(String s1, String s2) {
1630         return compareStrings(true, s1, s2);
1631     }
1632 
1633     /**
1634      * A general purpose case sensitive String comparator, which
1635      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1636      *
1637      * @param s1 first String to compare.
1638      * @param s2 second String to compare.
1639      * @return a negative integer, zero, or a positive integer as the first
1640      *         argument is less than, equal to, or greater than the second.
1641      */
1642     public int compareCaseCompare(String s1, String s2) {
1643         return compareStrings(false, s1, s2);
1644     }
1645 
1646     private DocCollator tertiaryCollator = null;
1647     private DocCollator secondaryCollator = null;
1648 
1649     private int compareStrings(boolean caseSensitive, String s1, String s2) {
1650         if (caseSensitive) {
1651             if (tertiaryCollator == null) {
1652                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1653             }
1654             return tertiaryCollator.compare(s1, s2);
1655         }
1656         if (secondaryCollator == null) {
1657             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1658         }
1659         return secondaryCollator.compare(s1, s2);
1660     }
1661 
1662     private static class DocCollator {
1663         private final Map&lt;String, CollationKey&gt; keys;
1664         private final Collator instance;
1665         private final int MAX_SIZE = 1000;
1666         private DocCollator(Locale locale, int strength) {
1667             instance = createCollator(locale);
1668             instance.setStrength(strength);
1669 
1670             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1671                 private static final long serialVersionUID = 1L;
1672                 @Override
1673                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1674                     return size() &gt; MAX_SIZE;
1675                 }
1676             };
1677         }
1678 
1679         CollationKey getKey(String s) {
1680             return keys.computeIfAbsent(s, instance :: getCollationKey);
1681         }
1682 
1683         public int compare(String s1, String s2) {
1684             return getKey(s1).compareTo(getKey(s2));
1685         }
1686 
1687         private Collator createCollator(Locale locale) {
1688             Collator baseCollator = Collator.getInstance(locale);
1689             if (baseCollator instanceof RuleBasedCollator) {
1690                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1691                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1692                 try {
1693                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1694                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1695                 } catch (ParseException e) {
1696                     throw new RuntimeException(e);
1697                 }
1698             }
1699             return baseCollator;
1700         }
1701     }
1702 
1703     private Comparator&lt;Element&gt; moduleComparator = null;
1704     /**
1705      * Comparator for ModuleElements, simply compares the fully qualified names
1706      * @return a Comparator
1707      */
1708     public Comparator&lt;Element&gt; makeModuleComparator() {
1709         if (moduleComparator == null) {
1710             moduleComparator = new Utils.ElementComparator() {
1711                 @Override
1712                 public int compare(Element mod1, Element mod2) {
1713                     return compareFullyQualifiedNames(mod1, mod2);
1714                 }
1715             };
1716         }
1717         return moduleComparator;
1718     }
1719 
1720     private Comparator&lt;Element&gt; allClassesComparator = null;
1721     /**
1722      * Returns a Comparator for all classes, compares the simple names of
1723      * TypeElement, if equal then the fully qualified names.
1724      *
1725      * @return Comparator
1726      */
1727     public Comparator&lt;Element&gt; makeAllClassesComparator() {
1728         if (allClassesComparator == null) {
1729             allClassesComparator = new Utils.ElementComparator() {
1730                 @Override
1731                 public int compare(Element e1, Element e2) {
1732                     int result = compareNames(e1, e2);
1733                     if (result == 0)
1734                         result = compareFullyQualifiedNames(e1, e2);
1735 
1736                     return result;
1737                 }
1738             };
1739         }
1740         return allClassesComparator;
1741     }
1742 
1743     private Comparator&lt;Element&gt; packageComparator = null;
1744     /**
1745      * Returns a Comparator for packages, by comparing the fully qualified names.
1746      *
1747      * @return a Comparator
1748      */
1749     public Comparator&lt;Element&gt; makePackageComparator() {
1750         if (packageComparator == null) {
1751             packageComparator = new Utils.ElementComparator() {
1752                 @Override
1753                 public int compare(Element pkg1, Element pkg2) {
1754                     return compareFullyQualifiedNames(pkg1, pkg2);
1755                 }
1756             };
1757         }
1758         return packageComparator;
1759     }
1760 
1761     private Comparator&lt;Element&gt; deprecatedComparator = null;
1762     /**
1763      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the
1764      * fully qualified names.
1765      *
1766      * @return a Comparator
1767      */
1768     public Comparator&lt;Element&gt; makeDeprecatedComparator() {
1769         if (deprecatedComparator == null) {
1770             deprecatedComparator = new Utils.ElementComparator() {
1771                 @Override
1772                 public int compare(Element e1, Element e2) {
1773                     return compareFullyQualifiedNames(e1, e2);
1774                 }
1775             };
1776         }
1777         return deprecatedComparator;
1778     }
1779 
1780     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;
1781     /**
1782      * Returns a Comparator for SerialFieldTree.
1783      * @return a Comparator
1784      */
1785     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1786         if (serialFieldTreeComparator == null) {
1787             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1788                 String s1 = o1.getName().toString();
1789                 String s2 = o2.getName().toString();
1790                 return s1.compareTo(s2);
1791             };
1792         }
1793         return serialFieldTreeComparator;
1794     }
1795 
1796     /**
1797      * Returns a general purpose comparator.
1798      * @return a Comparator
1799      */
1800     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1801         return makeClassUseComparator();
1802     }
1803 
1804     private Comparator&lt;Element&gt; overrideUseComparator = null;
<a name="11" id="anc11"></a>
1805     /**
1806      * Returns a Comparator for overrides and implements,
1807      * used primarily on methods, compares the name first,
1808      * then compares the simple names of the enclosing
1809      * TypeElement and the fully qualified name of the enclosing TypeElement.
1810      * @return a Comparator
1811      */
1812     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1813         if (overrideUseComparator == null) {
1814             overrideUseComparator = new Utils.ElementComparator() {
1815                 @Override
1816                 public int compare(Element o1, Element o2) {
1817                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1818                     if (result != 0) {
1819                         return result;
1820                     }
1821                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1822                         TypeElement t1 = getEnclosingTypeElement(o1);
1823                         TypeElement t2 = getEnclosingTypeElement(o2);
1824                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
1825                         if (result != 0)
1826                             return result;
1827                     }
1828                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));
1829                     if (result != 0)
1830                         return result;
1831                     return compareElementKinds(o1, o2);
1832                 }
1833             };
1834         }
1835         return overrideUseComparator;
1836     }
1837 
1838     private Comparator&lt;Element&gt; indexUseComparator = null;
1839     /**
1840      *  Returns a Comparator for index file presentations, and are sorted as follows.
1841      *  If comparing modules and/or packages then simply compare the qualified names,
1842      *  if comparing a module or a package with a type/member then compare the
1843      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,
1844      *  otherwise:
1845      *  1. compare the ElementKind ex: Module, Package, Interface etc.
1846      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),
1847      *      a case insensitive comparison of parameter the type signatures
1848      *  2b. if equal, case sensitive comparison of the type signatures
1849      *  3. finally, if equal, compare the FQNs of the entities
1850      * @return a comparator for index file use
1851      */
1852     public Comparator&lt;Element&gt; makeIndexUseComparator() {
1853         if (indexUseComparator == null) {
1854             indexUseComparator = new Utils.ElementComparator() {
1855                 /**
1856                  * Compares two elements.
1857                  *
1858                  * @param e1 - an element.
1859                  * @param e2 - an element.
1860                  * @return a negative integer, zero, or a positive integer as the first
1861                  * argument is less than, equal to, or greater than the second.
1862                  */
1863                 @Override
1864                 public int compare(Element e1, Element e2) {
1865                     int result;
1866                     // first, compare names as appropriate
1867                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {
1868                         result = compareFullyQualifiedNames(e1, e2);
1869                     } else if (isModule(e1) || isPackage(e1)) {
1870                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));
1871                     } else if (isModule(e2) || isPackage(e2)) {
1872                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));
1873                     } else {
1874                         result = compareNames(e1, e2);
1875                     }
1876                     if (result != 0) {
1877                         return result;
1878                     }
1879                     // if names are the same, compare element kinds
1880                     result = compareElementKinds(e1, e2);
1881                     if (result != 0) {
1882                         return result;
1883                     }
1884                     // if element kinds are the same, and are methods,
1885                     // compare the method parameters
1886                     if (hasParameters(e1)) {
1887                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
1888                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
1889                         result = compareParameters(false, parameters1, parameters2);
1890                         if (result != 0) {
1891                             return result;
1892                         }
1893                         result = compareParameters(true, parameters1, parameters2);
1894                         if (result != 0) {
1895                             return result;
1896                         }
1897                     }
1898                     // else fall back on fully qualified names
1899                     return compareFullyQualifiedNames(e1, e2);
1900                 }
1901             };
1902         }
1903         return indexUseComparator;
1904     }
1905 
1906     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;
1907     /**
1908      * Compares the FullyQualifiedNames of two TypeMirrors
1909      * @return
1910      */
1911     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {
1912         if (typeMirrorClassUseComparator == null) {
1913             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {
1914                 String s1 = getQualifiedTypeName(type1);
1915                 String s2 = getQualifiedTypeName(type2);
1916                 return compareStrings(s1, s2);
1917             };
1918         }
1919         return typeMirrorClassUseComparator;
1920     }
1921 
1922     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;
1923     /**
1924      * Compares the SimpleNames of TypeMirrors if equal then the
1925      * FullyQualifiedNames of TypeMirrors.
1926      *
1927      * @return
1928      */
1929     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {
1930         if (typeMirrorIndexUseComparator == null) {
1931             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {
1932                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));
1933                 if (result != 0)
1934                     return result;
1935                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));
1936             };
1937         }
1938         return typeMirrorIndexUseComparator;
1939     }
1940 
1941     /**
1942      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1943      * getQualified name, returns  the qualified name of the Reference type
1944      * otherwise the primitive name.
1945      * @param t the type whose name is to be obtained.
1946      * @return the fully qualified name of Reference type or the primitive name
1947      */
1948     public String getQualifiedTypeName(TypeMirror t) {
1949         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1950             @Override
1951             public String visitDeclared(DeclaredType t, Void p) {
1952                 return getFullyQualifiedName(t.asElement());
1953             }
1954 
1955             @Override
1956             public String visitArray(ArrayType t, Void p) {
1957                return visit(t.getComponentType());
1958             }
1959 
1960             @Override
1961             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1962                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1963                 // it to be compatible with the old world, now if we decide to do so
1964                 // care must be taken to avoid collisions.
1965                 // return getFullyQualifiedName(t.asElement());
1966                 return t.toString();
1967             }
1968 
1969             @Override
1970             protected String defaultAction(TypeMirror t, Void p) {
1971                 return t.toString();
1972             }
1973 
1974         }.visit(t);
1975     }
1976 
1977     /**
1978      * A generic utility which returns the fully qualified names of an entity,
1979      * if the entity is not qualifiable then its enclosing entity, it is upto
1980      * the caller to add the elements name as required.
1981      * @param e the element to get FQN for.
1982      * @return the name
1983      */
1984     public String getFullyQualifiedName(Element e) {
1985         return getFullyQualifiedName(e, true);
1986     }
1987 
1988     @SuppressWarnings(&quot;preview&quot;)
1989     public String getFullyQualifiedName(Element e, final boolean outer) {
1990         return new SimpleElementVisitor14&lt;String, Void&gt;() {
1991             @Override
1992             public String visitModule(ModuleElement e, Void p) {
1993                 return e.getQualifiedName().toString();
1994             }
1995 
1996             @Override
1997             public String visitPackage(PackageElement e, Void p) {
1998                 return e.getQualifiedName().toString();
1999             }
2000 
2001             @Override
2002             public String visitType(TypeElement e, Void p) {
2003                 return e.getQualifiedName().toString();
2004             }
2005 
2006             @Override
2007             protected String defaultAction(Element e, Void p) {
2008                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2009             }
2010         }.visit(e);
2011     }
2012 
2013     private Comparator&lt;Element&gt; classUseComparator = null;
<a name="12" id="anc12"></a>
2014     /**
2015      * Comparator for ClassUse presentations, and sorts as follows:
2016      * 1. member names
2017      * 2. then fully qualified member names
2018      * 3. then parameter types if applicable
2019      * 4. finally the element kinds ie. package, class, interface etc.
2020      * @return a comparator to sort classes and members for class use
2021      */
2022     public Comparator&lt;Element&gt; makeClassUseComparator() {
2023         if (classUseComparator == null) {
2024             classUseComparator = new Utils.ElementComparator() {
2025                 /**
2026                  * Compares two Elements.
2027                  *
2028                  * @param e1 - an element.
2029                  * @param e2 - an element.
2030                  * @return a negative integer, zero, or a positive integer as the first
2031                  * argument is less than, equal to, or greater than the second.
2032                  */
2033                 @Override
2034                 public int compare(Element e1, Element e2) {
2035                     int result = compareNames(e1, e2);
2036                     if (result != 0) {
2037                         return result;
2038                     }
2039                     result = compareFullyQualifiedNames(e1, e2);
2040                     if (result != 0) {
2041                         return result;
2042                     }
2043                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {
2044                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();
2045                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();
2046                         result = compareParameters(false, parameters1, parameters2);
2047                         if (result != 0) {
2048                             return result;
2049                         }
2050                         result = compareParameters(true, parameters1, parameters2);
2051                     }
2052                     if (result != 0) {
2053                         return result;
2054                     }
2055                     return compareElementKinds(e1, e2);
2056                 }
2057             };
2058         }
2059         return classUseComparator;
2060     }
2061 
2062     /**
2063      * A general purpose comparator to sort Element entities, basically provides the building blocks
2064      * for creating specific comparators for an use-case.
2065      */
2066     private abstract class ElementComparator implements Comparator&lt;Element&gt; {
2067         public ElementComparator() { }
2068 
2069         /**
2070          * compares two parameter arrays by first comparing the length of the arrays, and
2071          * then each Type of the parameter in the array.
2072          * @param params1 the first parameter array.
2073          * @param params2 the first parameter array.
2074          * @return a negative integer, zero, or a positive integer as the first
2075          *         argument is less than, equal to, or greater than the second.
2076          */
2077         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,
2078                                                                List&lt;? extends VariableElement&gt; params2) {
2079 
2080             return compareStrings(caseSensitive, getParametersAsString(params1),
2081                                                  getParametersAsString(params2));
2082         }
2083 
2084         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {
2085             StringBuilder sb = new StringBuilder();
2086             for (VariableElement param : params) {
2087                 TypeMirror t = param.asType();
2088                 // prefix P for primitive and R for reference types, thus items will
2089                 // be ordered lexically and correctly.
2090                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);
2091             }
2092             return sb.toString();
2093         }
2094 
2095         private String getTypeCode(TypeMirror t) {
2096             return new SimpleTypeVisitor9&lt;String, Void&gt;() {
2097 
2098                 @Override
2099                 public String visitPrimitive(PrimitiveType t, Void p) {
2100                     return &quot;P&quot;;
2101                 }
2102                 @Override
2103                 public String visitArray(ArrayType t, Void p) {
2104                     return visit(t.getComponentType());
2105                 }
2106                 @Override
2107                 protected String defaultAction(TypeMirror e, Void p) {
2108                     return &quot;R&quot;;
2109                 }
2110 
2111             }.visit(t);
2112         }
2113 
2114         /**
2115          * Compares two Elements, typically the name of a method,
2116          * field or constructor.
2117          * @param e1 the first Element.
2118          * @param e2 the second Element.
2119          * @return a negative integer, zero, or a positive integer as the first
2120          *         argument is less than, equal to, or greater than the second.
2121          */
2122         protected int compareNames(Element e1, Element e2) {
2123             return compareStrings(getSimpleName(e1), getSimpleName(e2));
2124         }
2125 
2126         /**
2127          * Compares the fully qualified names of the entities
2128          * @param e1 the first Element.
2129          * @param e2 the first Element.
2130          * @return a negative integer, zero, or a positive integer as the first
2131          *         argument is less than, equal to, or greater than the second.
2132          */
2133         protected int compareFullyQualifiedNames(Element e1, Element e2) {
2134             // add simplename to be compatible
2135             String thisElement = getFullyQualifiedName(e1);
2136             String thatElement = getFullyQualifiedName(e2);
2137             return compareStrings(thisElement, thatElement);
2138         }
2139 
2140         protected int compareElementKinds(Element e1, Element e2) {
2141             return Integer.compare(getKindIndex(e1), getKindIndex(e2));
2142         }
2143 
2144         private int getKindIndex(Element e) {
2145             switch (e.getKind()) {
2146                 case MODULE:            return 0;
2147                 case PACKAGE:           return 1;
2148                 case CLASS:             return 2;
2149                 case ENUM:              return 3;
2150                 case ENUM_CONSTANT:     return 4;
2151                 case RECORD:            return 5;
2152                 case INTERFACE:         return 6;
2153                 case ANNOTATION_TYPE:   return 7;
2154                 case FIELD:             return 8;
2155                 case CONSTRUCTOR:       return 9;
2156                 case METHOD:            return 10;
2157                 default: throw new IllegalArgumentException(e.getKind().toString());
2158             }
2159         }
2160 
2161         @SuppressWarnings(&quot;preview&quot;)
2162         boolean hasParameters(Element e) {
2163             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2164                 @Override
2165                 public Boolean visitExecutable(ExecutableElement e, Void p) {
2166                     return true;
2167                 }
2168 
2169                 @Override
2170                 protected Boolean defaultAction(Element e, Void p) {
2171                     return false;
2172                 }
2173 
2174             }.visit(e);
2175         }
2176 
2177         /**
2178          * The fully qualified names of the entities, used solely by the comparator.
2179          *
2180          * @return a negative integer, zero, or a positive integer as the first argument is less
2181          * than, equal to, or greater than the second.
2182          */
2183         @SuppressWarnings(&quot;preview&quot;)
2184         private String getFullyQualifiedName(Element e) {
2185             return new SimpleElementVisitor14&lt;String, Void&gt;() {
2186                 @Override
2187                 public String visitModule(ModuleElement e, Void p) {
2188                     return e.getQualifiedName().toString();
2189                 }
2190 
2191                 @Override
2192                 public String visitPackage(PackageElement e, Void p) {
2193                     return e.getQualifiedName().toString();
2194                 }
2195 
2196                 @Override
2197                 public String visitExecutable(ExecutableElement e, Void p) {
2198                     // For backward compatibility
2199                     return getFullyQualifiedName(e.getEnclosingElement())
2200                             + &quot;.&quot; + e.getSimpleName().toString();
2201                 }
2202 
2203                 @Override
2204                 public String visitType(TypeElement e, Void p) {
2205                     return e.getQualifiedName().toString();
2206                 }
2207 
2208                 @Override
2209                 protected String defaultAction(Element e, Void p) {
2210                     return getEnclosingTypeElement(e).getQualifiedName().toString()
2211                             + &quot;.&quot; + e.getSimpleName().toString();
2212                 }
2213             }.visit(e);
2214         }
2215     }
2216 
2217     /**
2218      * Returns a Comparator for SearchIndexItems representing types. Items are
2219      * compared by short name, or full string representation if names are equal.
2220      *
2221      * @return a Comparator
2222      */
2223     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {
2224         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2225             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());
2226             if (result == 0) {
2227                 // TreeSet needs this to be consistent with equal so we do
2228                 // a plain comparison of string representations as fallback.
2229                 result = sii1.toString().compareTo(sii2.toString());
2230             }
2231             return result;
2232         };
2233     }
2234 
2235     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;
2236     /**
2237      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.
2238      * Items are compared by label (member name plus signature for members, package name for
2239      * packages, and module name for modules). If labels are equal then full string
2240      * representation is compared.
2241      *
2242      * @return a Comparator
2243      */
2244     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {
2245         if (genericSearchIndexComparator == null) {
2246             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {
2247                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());
2248                 if (result == 0) {
2249                     // TreeSet needs this to be consistent with equal so we do
2250                     // a plain comparison of string representations as fallback.
2251                     result = sii1.toString().compareTo(sii2.toString());
2252                 }
2253                 return result;
2254             };
2255         }
2256         return genericSearchIndexComparator;
2257     }
2258 
2259     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2260         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2261         out.addAll(getClasses(pkg));
2262         out.addAll(getEnums(pkg));
2263         out.addAll(getAnnotationTypes(pkg));
2264         out.addAll(getRecords(pkg));
2265         return out;
2266     }
2267 
2268     // Element related methods
2269     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2270         List&lt;Element&gt; members = getAnnotationFields(aClass);
2271         members.addAll(getAnnotationMethods(aClass));
2272         return members;
2273     }
2274 
2275     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2276         return getItems0(aClass, true, FIELD);
2277     }
2278 
2279     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
2280         return getItems0(aClass, true, FIELD);
2281     }
2282 
2283     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
2284         return getItems0(aClass, true, METHOD);
2285     }
2286 
2287     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
2288         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
2289     }
2290 
2291     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
2292         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
2293     }
2294 
2295     @SuppressWarnings(&quot;preview&quot;)
2296     public List&lt;TypeElement&gt; getRecords(Element e) {
2297         return convertToTypeElement(getItems(e, true, RECORD));
2298     }
2299 
2300     @SuppressWarnings(&quot;preview&quot;)
2301     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
2302         return convertToTypeElement(getItems(e, false, RECORD));
2303     }
2304 
2305     public List&lt;VariableElement&gt; getFields(Element e) {
2306         return convertToVariableElement(getItems(e, true, FIELD));
2307     }
2308 
2309     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
2310         return convertToVariableElement(getItems(e, false, FIELD));
2311     }
2312 
2313     public List&lt;TypeElement&gt; getClasses(Element e) {
2314        return convertToTypeElement(getItems(e, true, CLASS));
2315     }
2316 
2317     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
2318        return convertToTypeElement(getItems(e, false, CLASS));
2319     }
2320 
2321     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
2322         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
2323     }
2324 
2325     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2326         return convertToExecutableElement(getItems(e, true, METHOD));
2327     }
2328 
2329     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2330         return convertToExecutableElement(getItems(e, false, METHOD));
2331     }
2332 
2333     public int getOrdinalValue(VariableElement member) {
2334         if (member == null || member.getKind() != ENUM_CONSTANT) {
2335             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2336         }
2337         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2338     }
2339 
2340     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2341     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2342         if (modulePackageMap == null) {
2343             modulePackageMap = new HashMap&lt;&gt;();
2344             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<a name="13" id="anc13"></a><span class="line-modified">2345             pkgs.forEach((pkg) -&gt; {</span>
2346                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2347                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2348             });
2349         }
2350         return modulePackageMap;
2351     }
2352 
2353     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2354         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2355         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2356         // get all the requires for the element in question
2357         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2358             ModuleElement dep = rd.getDependency();
2359             // add the dependency to work queue
2360             if (!result.containsKey(dep)) {
2361                 if (rd.isTransitive()) {
2362                     queue.addLast(dep);
2363                 }
2364             }
2365             // add all exports for the primary module
2366             result.put(rd.getDependency(), getModifiers(rd));
2367         }
2368 
2369         // add only requires public for subsequent module dependencies
2370         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2371             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2372                 ModuleElement dep = rd.getDependency();
2373                 if (!result.containsKey(dep)) {
2374                     if (rd.isTransitive()) {
2375                         result.put(dep, getModifiers(rd));
2376                         queue.addLast(dep);
2377                     }
2378                 }
2379             }
2380         }
2381         return result;
2382     }
2383 
2384     public String getModifiers(RequiresDirective rd) {
2385         StringBuilder modifiers = new StringBuilder();
<a name="14" id="anc14"></a><span class="line-modified">2386         String sep=&quot;&quot;;</span>
2387         if (rd.isTransitive()) {
2388             modifiers.append(&quot;transitive&quot;);
2389             sep = &quot; &quot;;
2390         }
2391         if (rd.isStatic()) {
2392             modifiers.append(sep);
2393             modifiers.append(&quot;static&quot;);
2394         }
2395         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2396     }
2397 
2398     public long getLineNumber(Element e) {
2399         TreePath path = getTreePath(e);
2400         if (path == null) { // maybe null if synthesized
2401             TypeElement encl = getEnclosingTypeElement(e);
2402             path = getTreePath(encl);
2403         }
2404         CompilationUnitTree cu = path.getCompilationUnit();
2405         LineMap lineMap = cu.getLineMap();
2406         DocSourcePositions spos = docTrees.getSourcePositions();
2407         long pos = spos.getStartPosition(cu, path.getLeaf());
2408         return lineMap.getLineNumber(pos);
2409     }
2410 
2411     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
2412         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2413         for (Element e : list) {
2414             out.add((ExecutableElement)e);
2415         }
2416         return out;
2417     }
2418 
2419     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
2420         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
2421         for (Element e : list) {
2422             out.add((TypeElement)e);
2423         }
2424         return out;
2425     }
2426 
2427     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
2428         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
2429         for (Element e : list) {
2430             out.add((VariableElement) e);
2431         }
2432         return out;
2433     }
2434 
2435     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
2436         return convertToTypeElement(getItems(e, true, INTERFACE));
2437     }
2438 
2439     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2440         return convertToTypeElement(getItems(e, false, INTERFACE));
2441     }
2442 
2443     public List&lt;Element&gt; getEnumConstants(Element e) {
2444         return getItems(e, true, ENUM_CONSTANT);
2445     }
2446 
2447     public List&lt;TypeElement&gt; getEnums(Element e) {
2448         return convertToTypeElement(getItems(e, true, ENUM));
2449     }
2450 
2451     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2452         return convertToTypeElement(getItems(e, false, ENUM));
2453     }
2454 
2455     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2456         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2457         clist.addAll(getInterfacesUnfiltered(e));
2458         clist.addAll(getAnnotationTypesUnfiltered(e));
2459         clist.addAll(getRecordsUnfiltered(e));
2460         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2461         oset.addAll(clist);
2462         return oset;
2463     }
2464 
2465     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2466     /**
2467      * Returns a list containing classes and interfaces,
2468      * including annotation types.
2469      * @param e Element
2470      * @return List
2471      */
2472     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2473         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2474         if (oset != null)
2475             return oset;
2476         List&lt;TypeElement&gt; clist = getClasses(e);
2477         clist.addAll(getInterfaces(e));
2478         clist.addAll(getAnnotationTypes(e));
2479         clist.addAll(getEnums(e));
2480         clist.addAll(getRecords(e));
2481         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
2482         oset.addAll(clist);
2483         cachedClasses.put(e, oset);
2484         return oset;
2485     }
2486 
2487     /*
2488      * Get all the elements unfiltered and filter them finally based
2489      * on its visibility, this works differently from the other getters.
2490      */
2491     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2492         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2493         for (TypeElement te : getClassesUnfiltered(e)) {
2494             if (!filter || configuration.docEnv.isSelected(te)) {
2495                 olist.add(te);
2496             }
2497         }
2498         for (TypeElement te : getInterfacesUnfiltered(e)) {
2499             if (!filter || configuration.docEnv.isSelected(te)) {
2500                 olist.add(te);
2501             }
2502         }
2503         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2504             if (!filter || configuration.docEnv.isSelected(te)) {
2505                 olist.add(te);
2506             }
2507         }
2508         for (TypeElement te : getEnumsUnfiltered(e)) {
2509             if (!filter || configuration.docEnv.isSelected(te)) {
2510                 olist.add(te);
2511             }
2512         }
2513         return olist;
2514     }
2515 
2516     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2517         return getInnerClasses(e, true);
2518     }
2519 
2520     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2521         return getInnerClasses(e, false);
2522     }
2523 
2524     /**
2525      * Returns a list of classes that are not errors or exceptions
2526      * @param e Element
2527      * @return List
2528      */
2529     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2530         return getClasses(e).stream()
2531                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2532                 .collect(Collectors.toList());
2533     }
2534 
2535     public List&lt;TypeElement&gt; getErrors(Element e) {
2536         return getClasses(e)
2537                 .stream()
2538                 .filter(this::isError)
2539                 .collect(Collectors.toList());
2540     }
2541 
2542     public List&lt;TypeElement&gt; getExceptions(Element e) {
2543         return getClasses(e)
2544                 .stream()
2545                 .filter(this::isException)
2546                 .collect(Collectors.toList());
2547     }
2548 
2549     @SuppressWarnings(&quot;preview&quot;)
2550     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2551         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2552         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2553 
2554             @Override
2555             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2556                 recursiveGetItems(elements, e, filter, select);
2557                 return elements;
2558             }
2559 
2560             @Override
2561             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2562                 return getItems0(e0, filter, select);
2563             }
2564 
2565         }.visit(e);
2566     }
2567 
2568     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2569     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2570         list.addAll(getItems0(e, filter, select));
2571         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2572         for (Element c : classes) {
2573             list.addAll(getItems0(c, filter, select));
2574             if (isTypeElement(c)) {
2575                 recursiveGetItems(list, c, filter, select);
2576             }
2577         }
2578     }
2579 
2580     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2581         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2582         return getItems0(te, filter, kinds);
2583     }
2584 
2585     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2586         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2587         for (Element e : te.getEnclosedElements()) {
2588             if (kinds.contains(e.getKind())) {
2589                 if (!filter || shouldDocument(e)) {
2590                     elements.add(e);
2591                 }
2592             }
2593         }
2594         return elements;
2595     }
2596 
2597     @SuppressWarnings(&quot;preview&quot;)
2598     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2599 
2600     @SuppressWarnings(&quot;preview&quot;)
2601     public boolean shouldDocument(Element e) {
2602         if (shouldDocumentVisitor == null) {
2603             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2604                 private boolean hasSource(TypeElement e) {
2605                     return configuration.docEnv.getFileKind(e) ==
2606                             javax.tools.JavaFileObject.Kind.SOURCE;
2607                 }
2608 
2609                 // handle types
2610                 @Override
2611                 public Boolean visitType(TypeElement e, Void p) {
2612                     // treat inner classes etc as members
2613                     if (e.getNestingKind().isNested()) {
2614                         return defaultAction(e, p);
2615                     }
2616                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2617                 }
2618 
2619                 // handle everything else
2620                 @Override
2621                 protected Boolean defaultAction(Element e, Void p) {
2622                     return configuration.docEnv.isSelected(e);
2623                 }
2624 
2625                 @Override
2626                 public Boolean visitUnknown(Element e, Void p) {
2627                     throw new AssertionError(&quot;unknown element: &quot; + e);
2628                 }
2629             };
2630         }
2631         return shouldDocumentVisitor.visit(e);
2632     }
2633 
2634     /*
2635      * nameCache is maintained for improving the comparator
2636      * performance, noting that the Collator used by the comparators
2637      * use Strings, as of this writing.
2638      * TODO: when those APIs handle charSequences, the use of
2639      * this nameCache must be re-investigated and removed.
2640      */
2641     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2642 
2643     /**
2644      * Returns the name of the element after the last dot of the package name.
2645      * This emulates the behavior of the old doclet.
2646      * @param e an element whose name is required
2647      * @return the name
2648      */
2649     public String getSimpleName(Element e) {
2650         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2651     }
2652 
2653     @SuppressWarnings(&quot;preview&quot;)
2654     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2655 
2656     @SuppressWarnings(&quot;preview&quot;)
2657     private String getSimpleName0(Element e) {
2658         if (snvisitor == null) {
2659             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2660                 @Override
2661                 public String visitModule(ModuleElement e, Void p) {
2662                     return e.getQualifiedName().toString();  // temp fix for 8182736
2663                 }
2664 
2665                 @Override
2666                 public String visitType(TypeElement e, Void p) {
2667                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2668                     Element enclosed = e.getEnclosingElement();
2669                     while (enclosed != null
2670                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2671                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2672                         enclosed = enclosed.getEnclosingElement();
2673                     }
2674                     return sb.toString();
2675                 }
2676 
2677                 @Override
2678                 public String visitExecutable(ExecutableElement e, Void p) {
2679                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2680                         return e.getEnclosingElement().getSimpleName().toString();
2681                     }
2682                     return e.getSimpleName().toString();
2683                 }
2684 
2685                 @Override
2686                 protected String defaultAction(Element e, Void p) {
2687                     return e.getSimpleName().toString();
2688                 }
2689             };
2690         }
2691         return snvisitor.visit(e);
2692     }
2693 
2694     public TypeElement getEnclosingTypeElement(Element e) {
2695         if (e.getKind() == ElementKind.PACKAGE)
2696             return null;
2697         Element encl = e.getEnclosingElement();
2698         ElementKind kind = encl.getKind();
2699         if (kind == ElementKind.PACKAGE)
2700             return null;
2701         while (!(kind.isClass() || kind.isInterface())) {
2702             encl = encl.getEnclosingElement();
2703             kind = encl.getKind();
2704         }
2705         return (TypeElement)encl;
2706     }
2707 
2708     private ConstantValueExpression cve = null;
2709 
2710     public String constantValueExpresion(VariableElement ve) {
2711         if (cve == null)
2712             cve = new ConstantValueExpression();
2713         return cve.constantValueExpression(configuration.workArounds, ve);
2714     }
2715 
2716     private static class ConstantValueExpression {
2717         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2718             return new TypeKindVisitor9&lt;String, Object&gt;() {
2719                 /* TODO: we need to fix this correctly.
2720                  * we have a discrepancy here, note the use of getConstValue
2721                  * vs. getConstantValue, at some point we need to use
2722                  * getConstantValue.
2723                  * In the legacy world byte and char primitives appear as Integer values,
2724                  * thus a byte value of 127 will appear as 127, but in the new world,
2725                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2726                  * chars will be  translated to \n, \r etc. however, in the new world,
2727                  * they will be printed as decimal values. The new world is correct,
2728                  * and we should fix this by using getConstantValue and the visitor to
2729                  * address this in the future.
2730                  */
2731                 @Override
2732                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2733                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2734                 }
2735 
2736                 @Override
2737                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2738                     return sourceForm(((Double)val), &#39;d&#39;);
2739                 }
2740 
2741                 @Override
2742                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2743                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2744                 }
2745 
2746                 @Override
2747                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2748                     return val + &quot;L&quot;;
2749                 }
2750 
2751                 @Override
2752                 protected String defaultAction(TypeMirror e, Object val) {
2753                     if (val == null)
2754                         return null;
2755                     else if (val instanceof Character)
2756                         return sourceForm(((Character)val));
2757                     else if (val instanceof Byte)
2758                         return sourceForm(((Byte)val));
2759                     else if (val instanceof String)
2760                         return sourceForm((String)val);
2761                     return val.toString(); // covers int, short
2762                 }
2763             }.visit(ve.asType(), workArounds.getConstValue(ve));
2764         }
2765 
2766         // where
2767         private String sourceForm(double v, char suffix) {
2768             if (Double.isNaN(v))
2769                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2770             if (v == Double.POSITIVE_INFINITY)
2771                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2772             if (v == Double.NEGATIVE_INFINITY)
2773                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2774             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2775         }
2776 
2777         private  String sourceForm(char c) {
2778             StringBuilder buf = new StringBuilder(8);
2779             buf.append(&#39;\&#39;&#39;);
2780             sourceChar(c, buf);
2781             buf.append(&#39;\&#39;&#39;);
2782             return buf.toString();
2783         }
2784 
2785         private String sourceForm(byte c) {
2786             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2787         }
2788 
2789         private String sourceForm(String s) {
2790             StringBuilder buf = new StringBuilder(s.length() + 5);
2791             buf.append(&#39;\&quot;&#39;);
2792             for (int i=0; i&lt;s.length(); i++) {
2793                 char c = s.charAt(i);
2794                 sourceChar(c, buf);
2795             }
2796             buf.append(&#39;\&quot;&#39;);
2797             return buf.toString();
2798         }
2799 
2800         private void sourceChar(char c, StringBuilder buf) {
2801             switch (c) {
2802             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2803             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2804             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2805             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2806             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2807             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2808             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2809             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2810             default:
2811                 if (isPrintableAscii(c)) {
2812                     buf.append(c); return;
2813                 }
2814                 unicodeEscape(c, buf);
2815                 return;
2816             }
2817         }
2818 
2819         private void unicodeEscape(char c, StringBuilder buf) {
2820             final String chars = &quot;0123456789abcdef&quot;;
2821             buf.append(&quot;\\u&quot;);
2822             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2823             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2824             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2825             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2826         }
2827         private boolean isPrintableAscii(char c) {
2828             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2829         }
2830     }
2831 
2832     public boolean isEnclosingPackageIncluded(TypeElement te) {
2833         return isIncluded(containingPackage(te));
2834     }
2835 
2836     public boolean isIncluded(Element e) {
2837         return configuration.docEnv.isIncluded(e);
2838     }
2839 
2840     @SuppressWarnings(&quot;preview&quot;)
2841     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2842     @SuppressWarnings(&quot;preview&quot;)
2843     public boolean isSpecified(Element e) {
2844         if (specifiedVisitor == null) {
2845             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2846                 @Override
2847                 public Boolean visitModule(ModuleElement e, Void p) {
2848                     return configuration.getSpecifiedModuleElements().contains(e);
2849                 }
2850 
2851                 @Override
2852                 public Boolean visitPackage(PackageElement e, Void p) {
2853                     return configuration.getSpecifiedPackageElements().contains(e);
2854                 }
2855 
2856                 @Override
2857                 public Boolean visitType(TypeElement e, Void p) {
2858                     return configuration.getSpecifiedTypeElements().contains(e);
2859                 }
2860 
2861                 @Override
2862                 protected Boolean defaultAction(Element e, Void p) {
2863                     return false;
2864                 }
2865             };
2866         }
2867         return specifiedVisitor.visit(e);
2868     }
2869 
2870     /**
2871      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2872      *
2873      * @param pkg
2874      * @return
2875      */
2876     public String getPackageName(PackageElement pkg) {
2877         if (pkg == null || pkg.isUnnamed()) {
2878             return DocletConstants.DEFAULT_PACKAGE_NAME;
2879         }
2880         return pkg.getQualifiedName().toString();
2881     }
2882 
2883     /**
2884      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2885      *
2886      * @param mdle a ModuleElement
2887      * @return
2888      */
2889     public String getModuleName(ModuleElement mdle) {
2890         if (mdle == null || mdle.isUnnamed()) {
2891             return DocletConstants.DEFAULT_ELEMENT_NAME;
2892         }
2893         return mdle.getQualifiedName().toString();
2894     }
2895 
2896     public boolean isAttribute(DocTree doctree) {
2897         return isKind(doctree, ATTRIBUTE);
2898     }
2899 
2900     public boolean isAuthor(DocTree doctree) {
2901         return isKind(doctree, AUTHOR);
2902     }
2903 
2904     public boolean isComment(DocTree doctree) {
2905         return isKind(doctree, COMMENT);
2906     }
2907 
2908     public boolean isDeprecated(DocTree doctree) {
2909         return isKind(doctree, DEPRECATED);
2910     }
2911 
2912     public boolean isDocComment(DocTree doctree) {
2913         return isKind(doctree, DOC_COMMENT);
2914     }
2915 
2916     public boolean isDocRoot(DocTree doctree) {
2917         return isKind(doctree, DOC_ROOT);
2918     }
2919 
2920     public boolean isEndElement(DocTree doctree) {
2921         return isKind(doctree, END_ELEMENT);
2922     }
2923 
2924     public boolean isEntity(DocTree doctree) {
2925         return isKind(doctree, ENTITY);
2926     }
2927 
2928     public boolean isErroneous(DocTree doctree) {
2929         return isKind(doctree, ERRONEOUS);
2930     }
2931 
2932     public boolean isException(DocTree doctree) {
2933         return isKind(doctree, EXCEPTION);
2934     }
2935 
2936     public boolean isIdentifier(DocTree doctree) {
2937         return isKind(doctree, IDENTIFIER);
2938     }
2939 
2940     public boolean isInheritDoc(DocTree doctree) {
2941         return isKind(doctree, INHERIT_DOC);
2942     }
2943 
2944     public boolean isLink(DocTree doctree) {
2945         return isKind(doctree, LINK);
2946     }
2947 
2948     public boolean isLinkPlain(DocTree doctree) {
2949         return isKind(doctree, LINK_PLAIN);
2950     }
2951 
2952     public boolean isLiteral(DocTree doctree) {
2953         return isKind(doctree, LITERAL);
2954     }
2955 
2956     public boolean isOther(DocTree doctree) {
2957         return doctree.getKind() == DocTree.Kind.OTHER;
2958     }
2959 
2960     public boolean isParam(DocTree doctree) {
2961         return isKind(doctree, PARAM);
2962     }
2963 
2964     public boolean isReference(DocTree doctree) {
2965         return isKind(doctree, REFERENCE);
2966     }
2967 
2968     public boolean isReturn(DocTree doctree) {
2969         return isKind(doctree, RETURN);
2970     }
2971 
2972     public boolean isSee(DocTree doctree) {
2973         return isKind(doctree, SEE);
2974     }
2975 
2976     public boolean isSerial(DocTree doctree) {
2977         return isKind(doctree, SERIAL);
2978     }
2979 
2980     public boolean isSerialData(DocTree doctree) {
2981         return isKind(doctree, SERIAL_DATA);
2982     }
2983 
2984     public boolean isSerialField(DocTree doctree) {
2985         return isKind(doctree, SERIAL_FIELD);
2986     }
2987 
2988     public boolean isSince(DocTree doctree) {
2989         return isKind(doctree, SINCE);
2990     }
2991 
2992     public boolean isStartElement(DocTree doctree) {
2993         return isKind(doctree, START_ELEMENT);
2994     }
2995 
2996     public boolean isText(DocTree doctree) {
2997         return isKind(doctree, TEXT);
2998     }
2999 
3000     public boolean isThrows(DocTree doctree) {
3001         return isKind(doctree, THROWS);
3002     }
3003 
3004     public boolean isUnknownBlockTag(DocTree doctree) {
3005         return isKind(doctree, UNKNOWN_BLOCK_TAG);
3006     }
3007 
3008     public boolean isUnknownInlineTag(DocTree doctree) {
3009         return isKind(doctree, UNKNOWN_INLINE_TAG);
3010     }
3011 
3012     public boolean isValue(DocTree doctree) {
3013         return isKind(doctree, VALUE);
3014     }
3015 
3016     public boolean isVersion(DocTree doctree) {
3017         return isKind(doctree, VERSION);
3018     }
3019 
3020     private boolean isKind(DocTree doctree, DocTree.Kind match) {
3021         return  doctree.getKind() == match;
3022     }
3023 
3024     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
3025 
3026     public CommentHelper getCommentHelper(Element element) {
3027         return commentHelperCache.computeIfAbsent(element);
3028     }
3029 
3030     public void removeCommentHelper(Element element) {
3031         commentHelperCache.remove(element);
3032     }
3033 
3034     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
3035         DocCommentTree dcTree = getDocCommentTree(element);
3036         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
3037     }
3038 
3039     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
3040         return getBlockTags(element).stream()
3041                 .filter(t -&gt; t.getKind() != ERRONEOUS)
3042                 .filter(filter)
3043                 .collect(Collectors.toList());
3044     }
3045 
3046     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
3047         return getBlockTags(element, t -&gt; t.getKind() == kind);
3048     }
3049 
3050     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
3051         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
3052     }
3053 
3054     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
3055         return getBlockTags(element, t -&gt; {
3056             if (taglet instanceof BaseTaglet) {
3057                 return ((BaseTaglet) taglet).accepts(t);
3058             } else if (t instanceof UnknownBlockTagTree) {
3059                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
3060             } else {
3061                 return false;
3062             }
3063         });
3064     }
3065 
3066     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
3067         return hasBlockTag(element, kind, null);
3068     }
3069 
3070     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
3071         CommentHelper ch = getCommentHelper(element);
3072         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
3073                 ? tagName.substring(1)
3074                 : tagName;
3075         for (DocTree dt : getBlockTags(element, kind)) {
3076             if (dt.getKind() == kind) {
3077                 if (tname == null || ch.getTagName(dt).equals(tname)) {
3078                     return true;
3079                 }
3080             }
3081         }
3082         return false;
3083     }
3084 
3085     /**
3086      * Gets a TreePath for an Element. Note this method is called very
3087      * frequently, care must be taken to ensure this method is lithe
3088      * and efficient.
3089      * @param e an Element
3090      * @return TreePath
3091      */
3092     public TreePath getTreePath(Element e) {
3093         DocCommentDuo duo = dcTreeCache.get(e);
3094         if (duo != null &amp;&amp; duo.treePath != null) {
3095             return duo.treePath;
3096         }
3097         duo = configuration.cmtUtils.getSyntheticCommentDuo(e);
3098         if (duo != null &amp;&amp; duo.treePath != null) {
3099             return duo.treePath;
3100         }
3101         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
3102         TreePath path = elementToTreePath.get(e);
3103         if (path != null || elementToTreePath.containsKey(e)) {
3104             // expedite the path and one that is a null
3105             return path;
3106         }
3107         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
3108     }
3109 
3110     private final Map&lt;Element, DocCommentDuo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
3111 
3112     /**
3113      * Retrieves the doc comments for a given element.
3114      * @param element
3115      * @return DocCommentTree for the Element
3116      */
3117     public DocCommentTree getDocCommentTree0(Element element) {
3118 
3119         DocCommentDuo duo = null;
3120 
3121         ElementKind kind = element.getKind();
3122         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
3123             duo = dcTreeCache.get(element); // local cache
3124             if (duo == null &amp;&amp; kind == ElementKind.PACKAGE) {
3125                 // package-info.java
3126                 duo = getDocCommentTuple(element);
3127             }
3128             if (duo == null) {
3129                 // package.html or overview.html
3130                 duo = configuration.cmtUtils.getHtmlCommentDuo(element); // html source
3131             }
3132         } else {
3133             duo = configuration.cmtUtils.getSyntheticCommentDuo(element);
3134             if (duo == null) {
3135                 duo = dcTreeCache.get(element); // local cache
3136             }
3137             if (duo == null) {
3138                 duo = getDocCommentTuple(element); // get the real mccoy
3139             }
3140         }
3141 
3142         DocCommentTree docCommentTree = isValidDuo(duo) ? duo.dcTree : null;
3143         TreePath path = isValidDuo(duo) ? duo.treePath : null;
3144         if (!dcTreeCache.containsKey(element)) {
3145             if (docCommentTree != null &amp;&amp; path != null) {
3146                 if (!configuration.isAllowScriptInComments()) {
3147                     try {
3148                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
3149                             throw new JavaScriptScanner.Fault();
3150                         });
3151                     } catch (JavaScriptScanner.Fault jsf) {
3152                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
3153                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3154                     }
3155                 }
3156                 configuration.workArounds.runDocLint(path);
3157             }
3158             dcTreeCache.put(element, duo);
3159         }
3160         return docCommentTree;
3161     }
3162 
3163     private DocCommentDuo getDocCommentTuple(Element element) {
3164         // prevent nasty things downstream with overview element
3165         if (element.getKind() != ElementKind.OTHER) {
3166             TreePath path = getTreePath(element);
3167             if (path != null) {
3168                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
3169                 return new DocCommentDuo(path, docCommentTree);
3170             }
3171         }
3172         return null;
3173     }
3174 
3175     public void checkJavaScriptInOption(String name, String value) {
3176         if (!configuration.isAllowScriptInComments()) {
3177             DocCommentTree dct = configuration.cmtUtils.parse(
3178                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
3179 
3180             if (dct == null)
3181                 return;
3182 
3183             try {
3184                 javaScriptScanner.scan(dct, null, p -&gt; {
3185                     throw new JavaScriptScanner.Fault();
3186                 });
3187             } catch (JavaScriptScanner.Fault jsf) {
3188                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
3189                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
3190             }
3191         }
3192     }
3193 
3194     boolean isValidDuo(DocCommentDuo duo) {
3195         return duo != null &amp;&amp; duo.dcTree != null;
3196     }
3197 
3198     public DocCommentTree getDocCommentTree(Element element) {
3199         CommentHelper ch = commentHelperCache.get(element);
3200         if (ch != null) {
3201             return ch.dcTree;
3202         }
3203         DocCommentTree dcTree = getDocCommentTree0(element);
3204         if (dcTree != null) {
3205             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
3206         }
3207         return dcTree;
3208     }
3209 
3210     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
3211         DocCommentTree docCommentTree = getDocCommentTree(element);
3212         return docCommentTree == null
3213                 ? Collections.emptyList()
3214                 : docCommentTree.getPreamble();
3215     }
3216 
3217     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
3218         DocCommentTree docCommentTree = getDocCommentTree(element);
3219             return (docCommentTree == null)
3220                     ? Collections.emptyList()
3221                     : docCommentTree.getFullBody();
3222     }
3223 
3224     public List&lt;? extends DocTree&gt; getBody(Element element) {
3225         DocCommentTree docCommentTree = getDocCommentTree(element);
3226         return (docCommentTree == null)
3227                 ? Collections.emptyList()
3228                 : docCommentTree.getFullBody();
3229     }
3230 
3231     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
3232         return getBlockTags(element, DEPRECATED);
3233     }
3234 
3235     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
3236         return getBlockTags(element, PROVIDES);
3237     }
3238 
3239     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
3240         return getBlockTags(element, SEE);
3241     }
3242 
3243     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
3244         return getBlockTags(element, SERIAL);
3245     }
3246 
3247     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
3248         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
3249     }
3250 
3251     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
3252         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
3253     }
3254 
3255     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3256         return getParamTrees(element, true);
3257     }
3258 
3259     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3260         return getParamTrees(element, false);
3261     }
3262 
3263     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3264         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3265         for (DocTree dt : getBlockTags(element, PARAM)) {
3266             ParamTree pt = (ParamTree) dt;
3267             if (pt.isTypeParameter() == isTypeParameters) {
3268                 out.add(pt);
3269             }
3270         }
3271         return out;
3272     }
3273 
3274     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<a name="15" id="anc15"></a><span class="line-modified">3275         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3276         for (DocTree dt : getBlockTags(element, RETURN)) {</span>
<span class="line-removed">3277             out.add(dt);</span>
<span class="line-removed">3278         }</span>
<span class="line-removed">3279         return out;</span>
3280     }
3281 
3282     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3283         return getBlockTags(element, USES);
3284     }
3285 
3286     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3287         DocCommentTree dcTree = getDocCommentTree(element);
3288         if (dcTree == null) {
3289             return Collections.emptyList();
3290         }
<a name="16" id="anc16"></a><span class="line-modified">3291         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3292         for (DocTree dt : dcTree.getFirstSentence()) {</span>
<span class="line-removed">3293             out.add(dt);</span>
<span class="line-removed">3294         }</span>
<span class="line-removed">3295         return out;</span>
3296     }
3297 
3298     public ModuleElement containingModule(Element e) {
3299         return elementUtils.getModuleOf(e);
3300     }
3301 
3302     public PackageElement containingPackage(Element e) {
3303         return elementUtils.getPackageOf(e);
3304     }
3305 
3306     public TypeElement getTopMostContainingTypeElement(Element e) {
3307         if (isPackage(e)) {
3308             return null;
3309         }
3310         TypeElement outer = getEnclosingTypeElement(e);
3311         if (outer == null)
3312             return (TypeElement)e;
3313         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3314             outer = getEnclosingTypeElement(outer);
3315         }
3316         return outer;
3317     }
3318 
3319     /**
3320      * A memory-sensitive cache for {@link CommentHelper} objects,
3321      * which are expensive to compute.
3322      */
3323     private static class CommentHelperCache {
3324 
3325         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;
3326         private final Utils utils;
3327 
3328         public CommentHelperCache(Utils utils) {
3329             map = new HashMap&lt;&gt;();
3330             this.utils = utils;
3331         }
3332 
3333         public CommentHelper remove(Element key) {
3334             SoftReference&lt;CommentHelper&gt; value = map.remove(key);
3335             return value == null ? null : value.get();
3336         }
3337 
3338         public CommentHelper put(Element key, CommentHelper value) {
3339             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));
3340             return prev == null ? null : prev.get();
3341         }
3342 
3343         public CommentHelper get(Object key) {
3344             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3345             return value == null ? null : value.get();
3346         }
3347 
3348         public CommentHelper computeIfAbsent(Element key) {
3349             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3350             if (refValue != null) {
3351                 CommentHelper value = refValue.get();
3352                 if (value != null) {
3353                     return value;
3354                 }
3355             }
3356             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3357                     utils.getDocCommentTree(key));
3358             map.put(key, new SoftReference&lt;&gt;(newValue));
3359             return newValue;
3360         }
3361     }
3362 
3363     /**
<a name="17" id="anc17"></a><span class="line-modified">3364      * A simple pair container.</span>
<span class="line-modified">3365      * @param &lt;K&gt; first a value</span>
<span class="line-modified">3366      * @param &lt;L&gt; second another value</span>

3367      */
3368     public static class Pair&lt;K, L&gt; {
3369         public final K first;
3370         public final L second;
3371 
3372         public Pair(K first, L second) {
3373             this.first = first;
3374             this.second = second;
3375         }
3376 
3377         @Override
3378         public String toString() {
<a name="18" id="anc18"></a><span class="line-modified">3379             StringBuffer out = new StringBuffer();</span>
<span class="line-removed">3380             out.append(first + &quot;:&quot; + second);</span>
<span class="line-removed">3381             return out.toString();</span>
3382         }
3383     }
3384 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
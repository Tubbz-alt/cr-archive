<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
 108 import static com.sun.source.doctree.DocTree.Kind.CODE;
 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK;
 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 112 import static com.sun.source.doctree.DocTree.Kind.SEE;
 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
 118  * Class for the Html Format Code Generation specific to JavaDoc.
 119  * This Class contains methods related to the Html Code Generation which
 120  * are used extensively while generating the entire documentation.
 121  *
 122  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 123  *  If you write code that depends on this, you do so at your own risk.
 124  *  This code and its internal interfaces are subject to change or
 125  *  deletion without notice.&lt;/b&gt;
 126  */
 127 public class HtmlDocletWriter {
 128 
 129     /**
 130      * Relative path from the file getting generated to the destination
 131      * directory. For example, if the file getting generated is
 132      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 133      * This string can be empty if the file getting generated is in
 134      * the destination directory.
 135      */
 136     public final DocPath pathToRoot;
 137 
 138     /**
 139      * Platform-independent path from the current or the
 140      * destination directory to the file getting generated.
 141      * Used when creating the file.
 142      */
 143     public final DocPath path;
 144 
 145     /**
 146      * Name of the file getting generated. If the file getting generated is
 147      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 148      */
 149     public final DocPath filename;
 150 
 151     /**
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
 156     protected final HtmlOptions options;
 157 
 158     protected final Utils utils;
 159 
 160     protected final Contents contents;
 161 
 162     protected final Messages messages;
 163 
 164     protected final Resources resources;
 165 
 166     protected final Links links;
 167 
 168     protected final DocPaths docPaths;
 169 
 170     /**
 171      * To check whether annotation heading is printed or not.
 172      */
 173     protected boolean printedAnnotationHeading = false;
 174 
 175     /**
 176      * To check whether annotation field heading is printed or not.
 177      */
 178     protected boolean printedAnnotationFieldHeading = false;
 179 
 180     /**
 181      * To check whether the repeated annotations is documented or not.
 182      */
 183     private boolean isAnnotationDocumented = false;
 184 
 185     /**
 186      * To check whether the container annotations is documented or not.
 187      */
 188     private boolean isContainerDocumented = false;
 189 
 190     /**
 191      * The window title of this file.
 192      */
 193     protected String winTitle;
 194 
 195     protected Script mainBodyScript;
 196 
 197     /**
 198      * A table of the anchors used for at-index and related tags,
 199      * so that they can be made unique by appending a suitable suffix.
 200      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 201      * to avoid generating duplicates.)
 202      */
 203     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 204 
 205     /**
<a name="1" id="anc1"></a><span class="line-modified"> 206      * Constructor to construct the HtmlStandardWriter object.</span>
 207      *
 208      * @param configuration the configuration for this doclet
 209      * @param path the file to be generated.
 210      */
 211     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 212         this.configuration = configuration;
 213         this.options = configuration.getOptions();
 214         this.contents = configuration.contents;
 215         this.messages = configuration.messages;
 216         this.resources = configuration.docResources;
 217         this.links = new Links(path);
 218         this.utils = configuration.utils;
 219         this.path = path;
 220         this.pathToRoot = path.parent().invert();
 221         this.filename = path.basename();
 222         this.docPaths = configuration.docPaths;
 223         this.mainBodyScript = new Script();
 224 
 225         messages.notice(&quot;doclet.Generating_0&quot;,
 226             DocFile.createFileForOutput(configuration, path).getPath());
 227     }
 228 
 229     /**
 230      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 231      * as -header, -footer, -top and -bottom, and when converting a relative
 232      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 233      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 234      * comments.)
 235      * &lt;p&gt;
 236      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 237      * destination directory from the directory where the file is being
 238      * written, looping to handle all such tags in htmlstr.
 239      * &lt;p&gt;
 240      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 241      * the HTML page for source file p/C1.java is being generated, the
 242      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 243      * the relative path from docs/p/ to docs/ (the document root).
 244      * &lt;p&gt;
 245      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 246      * to prevent the inline tag from being interpreted.
 247      */
 248     public String replaceDocRootDir(String htmlstr) {
 249         // Return if no inline tags exist
 250         int index = htmlstr.indexOf(&quot;{@&quot;);
 251         if (index &lt; 0) {
 252             return htmlstr;
 253         }
 254         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 255         if (!docrootMatcher.find()) {
 256             return htmlstr;
 257         }
 258         StringBuilder buf = new StringBuilder();
 259         int prevEnd = 0;
 260         do {
 261             int match = docrootMatcher.start();
 262             // append htmlstr up to start of next {@docroot}
 263             buf.append(htmlstr.substring(prevEnd, match));
 264             prevEnd = docrootMatcher.end();
 265             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 266                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 267                 buf.append(options.docrootParent());
 268                 prevEnd += 3;
 269             } else {
 270                 // Insert relative path where {@docRoot} was located
 271                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 272             }
 273             // Append slash if next character is not a slash
 274             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 275                 buf.append(&#39;/&#39;);
 276             }
 277         } while (docrootMatcher.find());
 278         buf.append(htmlstr.substring(prevEnd));
 279         return buf.toString();
 280     }
 281     //where:
 282         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 283         private static final Pattern docrootPattern =
 284                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 285 
 286     /**
 287      * Get the script to show or hide the All classes link.
 288      *
 289      * @param id id of the element to show or hide
 290      * @return a content tree for the script
 291      */
 292     public Content getAllClassesLinkScript(String id) {
 293         Script script = new Script(&quot;&lt;!--\n&quot; +
 294                 &quot;  allClassesLink = document.getElementById(&quot;)
 295                 .appendStringLiteral(id)
 296                 .append(&quot;);\n&quot; +
 297                 &quot;  if(window==top) {\n&quot; +
 298                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +
 299                 &quot;  }\n&quot; +
 300                 &quot;  else {\n&quot; +
 301                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +
 302                 &quot;  }\n&quot; +
 303                 &quot;  //--&gt;\n&quot;);
 304         Content div = HtmlTree.DIV(script.asContent());
 305         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);
 306         Content noScript = HtmlTree.NOSCRIPT(div_noscript);
 307         div.add(noScript);
 308         return div;
 309     }
 310 
 311     /**
 312      * Add method information.
 313      *
 314      * @param method the method to be documented
 315      * @param dl the content tree to which the method information will be added
 316      */
 317     private void addMethodInfo(ExecutableElement method, Content dl) {
 318         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 319         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 320         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 321         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 322         // Check whether there is any implementation or overridden info to be
 323         // printed. If no overridden or implementation info needs to be
 324         // printed, do not print this section.
 325         if ((!intfacs.isEmpty()
 326                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 327                 || overriddenMethod != null) {
 328             MethodWriterImpl.addImplementsInfo(this, method, dl);
 329             if (overriddenMethod != null) {
 330                 MethodWriterImpl.addOverridden(this,
 331                         utils.overriddenType(method),
 332                         overriddenMethod,
 333                         dl);
 334             }
 335         }
 336     }
 337 
 338     /**
 339      * Adds the tags information.
 340      *
 341      * @param e the Element for which the tags will be generated
 342      * @param htmltree the documentation tree to which the tags will be added
 343      */
 344     protected void addTagsInfo(Element e, Content htmltree) {
 345         if (options.noComment()) {
 346             return;
 347         }
 348         Content dl = new HtmlTree(HtmlTag.DL);
 349         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 350             addMethodInfo((ExecutableElement)e, dl);
 351         }
 352         Content output = new ContentBuilder();
 353         TagletWriter.genTagOutput(configuration.tagletManager, e,
 354             configuration.tagletManager.getBlockTaglets(e),
 355                 getTagletWriterInstance(false), output);
 356         dl.add(output);
 357         htmltree.add(dl);
 358     }
 359 
 360     /**
 361      * Check whether there are any tags for Serialization Overview
 362      * section to be printed.
 363      *
 364      * @param field the VariableElement object to check for tags.
 365      * @return true if there are tags to be printed else return false.
 366      */
 367     protected boolean hasSerializationOverviewTags(VariableElement field) {
 368         Content output = new ContentBuilder();
 369         TagletWriter.genTagOutput(configuration.tagletManager, field,
 370                 configuration.tagletManager.getBlockTaglets(field),
 371                 getTagletWriterInstance(false), output);
 372         return !output.isEmpty();
 373     }
 374 
 375     /**
 376      * Returns a TagletWriter that knows how to write HTML.
 377      *
 378      * @param isFirstSentence  true if we want to write the first sentence
 379      * @return a TagletWriter that knows how to write HTML.
 380      */
 381     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 382         return new TagletWriterImpl(this, isFirstSentence);
 383     }
 384 
 385     /**
 386      * Returns a TagletWriter that knows how to write HTML.
 387      *
 388      * @param isFirstSentence  true if we want to write the first sentence
 389      * @param inSummary  true if tags are to be added in a summary section
 390      * @return a TagletWriter
 391      */
 392     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 393         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 394     }
 395 
 396     /**
 397      * Generates the HTML document tree and prints it out.
 398      *
 399      * @param metakeywords Array of String keywords for META tag. Each element
 400      *                     of the array is assigned to a separate META tag.
 401      *                     Pass in null for no array
 402      * @param description the content for the description META tag.
 403      * @param body the body htmltree to be included in the document
 404      * @throws DocFileIOException if there is a problem writing the file
 405      */
 406     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 407                                   String description,
 408                                   Content body)
 409             throws DocFileIOException {
 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
 420      * @param localStylesheets local stylesheets to be included in the HEAD element
 421      * @param body the body htmltree to be included in the document
 422      * @throws DocFileIOException if there is a problem writing the file
 423      */
 424     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 425                                   String description,
 426                                   List&lt;DocPath&gt; localStylesheets,
 427                                   Content body)
 428             throws DocFileIOException {
 429         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 430     }
 431 
 432     /**
 433      * Generates the HTML document tree and prints it out.
 434      *
 435      * @param metakeywords Array of String keywords for META tag. Each element
 436      *                     of the array is assigned to a separate META tag.
 437      *                     Pass in null for no array
 438      * @param description the content for the description META tag.
 439      * @param extraHeadContent any additional content to be included in the HEAD element
 440      * @param localStylesheets local stylesheets to be included in the HEAD element
 441      * @param body the body htmltree to be included in the document
 442      * @throws DocFileIOException if there is a problem writing the file
 443      */
 444     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 445                                   String description,
 446                                   Content extraHeadContent,
 447                                   List&lt;DocPath&gt; localStylesheets,
 448                                   Content body)
 449             throws DocFileIOException {
 450         Content htmlComment = contents.newPage;
 451         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 452         additionalStylesheets.addAll(localStylesheets);
 453         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 454                 .setTimestamp(!options.noTimestamp())
 455                 .setDescription(description)
 456                 .setGenerator(getGenerator(getClass()))
 457                 .setTitle(winTitle)
 458                 .setCharset(options.charset())
 459                 .addKeywords(metakeywords)
 460                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 461                 .setIndex(options.createIndex(), mainBodyScript)
 462                 .addContent(extraHeadContent);
 463 
 464         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);
 465         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 466         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 467     }
 468 
 469     /**
 470      * Get the window title.
 471      *
 472      * @param title the title string to construct the complete window title
 473      * @return the window title string
 474      */
 475     public String getWindowTitle(String title) {
 476         if (options.windowTitle().length() &gt; 0) {
 477             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 478         }
 479         return title;
 480     }
 481 
 482     /**
 483      * Get user specified header and the footer.
 484      *
 485      * @param header if true print the user provided header else print the
 486      * user provided footer.
 487      */
 488     public Content getUserHeaderFooter(boolean header) {
 489         String content;
 490         if (header) {
 491             content = replaceDocRootDir(options.header());
 492         } else {
 493             if (options.footer().length() != 0) {
 494                 content = replaceDocRootDir(options.footer());
 495             } else {
 496                 content = replaceDocRootDir(options.header());
 497             }
 498         }
 499         Content rawContent = new RawHtml(content);
 500         return rawContent;
 501     }
 502 
 503     /**
 504      * Adds the user specified top.
 505      *
 506      * @param htmlTree the content tree to which user specified top will be added
 507      */
 508     public void addTop(Content htmlTree) {
 509         Content top = new RawHtml(replaceDocRootDir(options.top()));
 510         htmlTree.add(top);
 511     }
 512 
 513     /**
 514      * Adds the user specified bottom.
 515      *
 516      * @param htmlTree the content tree to which user specified bottom will be added
 517      */
 518     public void addBottom(Content htmlTree) {
 519         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 520         Content small = HtmlTree.SMALL(bottom);
 521         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 522         htmlTree.add(p);
 523     }
 524 
 525     /**
 526      * Get the overview tree link for the main tree.
 527      *
 528      * @param label the label for the link
 529      * @return a content tree for the link
 530      */
 531     protected Content getNavLinkMainTree(String label) {
 532         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 533                 new StringContent(label));
 534         Content li = HtmlTree.LI(mainTreeContent);
 535         return li;
 536     }
 537 
 538     /**
 539      * Get table caption.
 540      *
 541      * @param title the content for the caption
 542      * @return a content tree for the caption
 543      */
 544     public Content getTableCaption(Content title) {
 545         Content captionSpan = HtmlTree.SPAN(title);
 546         Content space = Entity.NO_BREAK_SPACE;
 547         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 548         Content caption = HtmlTree.CAPTION(captionSpan);
 549         caption.add(tabSpan);
 550         return caption;
 551     }
 552 
 553     /**
 554      * Returns a packagename content.
 555      *
 556      * @param packageElement the package to check
 557      * @return package name content
 558      */
 559     public Content getPackageName(PackageElement packageElement) {
 560         return packageElement == null || packageElement.isUnnamed()
 561                 ? contents.defaultPackageLabel
 562                 : getPackageLabel(packageElement.getQualifiedName());
 563     }
 564 
 565     /**
 566      * Returns a package name label.
 567      *
 568      * @param packageName the package name
 569      * @return the package name content
 570      */
 571     public Content getPackageLabel(CharSequence packageName) {
 572         return new StringContent(packageName);
 573     }
 574 
 575     /**
 576      * Return the path to the class page for a typeElement.
 577      *
 578      * @param te   TypeElement for which the path is requested.
 579      * @param name Name of the file(doesn&#39;t include path).
 580      */
 581     protected DocPath pathString(TypeElement te, DocPath name) {
 582         return pathString(utils.containingPackage(te), name);
 583     }
 584 
 585     /**
 586      * Return path to the given file name in the given package. So if the name
 587      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 588      * if the relative path is &quot;../..&quot; then returned string will be
 589      * &quot;../../java/lang/Object.html&quot;
 590      *
 591      * @param packageElement Package in which the file name is assumed to be.
 592      * @param name File name, to which path string is.
 593      */
 594     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 595         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 596     }
 597 
 598     /**
 599      * Given a package, return the name to be used in HTML anchor tag.
 600      * @param packageElement the package.
 601      * @return the name to be used in HTML anchor tag.
 602      */
 603     public String getPackageAnchorName(PackageElement packageElement) {
 604         return packageElement == null || packageElement.isUnnamed()
 605                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 606                 : utils.getPackageName(packageElement);
 607     }
 608 
 609     /**
 610      * Return the link to the given package.
 611      *
 612      * @param packageElement the package to link to.
 613      * @param label the label for the link.
 614      * @return a content tree for the package link.
 615      */
 616     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 617         return getPackageLink(packageElement, new StringContent(label));
 618     }
 619 
 620     public Content getPackageLink(PackageElement packageElement) {
 621         StringContent content =  packageElement.isUnnamed()
 622                 ? new StringContent()
 623                 : new StringContent(utils.getPackageName(packageElement));
 624         return getPackageLink(packageElement, content);
 625     }
 626 
 627     /**
 628      * Return the link to the given package.
 629      *
 630      * @param packageElement the package to link to.
 631      * @param label the label for the link.
 632      * @return a content tree for the package link.
 633      */
 634     public Content getPackageLink(PackageElement packageElement, Content label) {
 635         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 636         if (!included) {
 637             for (PackageElement p : configuration.packages) {
 638                 if (p.equals(packageElement)) {
 639                     included = true;
 640                     break;
 641                 }
 642             }
 643         }
 644         if (included || packageElement == null) {
 645             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 646                     label);
 647         } else {
 648             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 649             if (crossPkgLink != null) {
 650                 return links.createLink(crossPkgLink, label);
 651             } else {
 652                 return label;
 653             }
 654         }
 655     }
 656 
 657     /**
 658      * Get Module link.
 659      *
 660      * @param mdle the module being documented
 661      * @param label tag for the link
 662      * @return a content for the module link
 663      */
 664     public Content getModuleLink(ModuleElement mdle, Content label) {
 665         boolean included = utils.isIncluded(mdle);
 666         return (included)
 667                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 668                 : label;
 669     }
 670 
 671     public Content interfaceName(TypeElement typeElement, boolean qual) {
 672         Content name = new StringContent((qual)
 673                 ? typeElement.getQualifiedName()
 674                 : utils.getSimpleName(typeElement));
 675         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 676     }
 677 
 678     /**
 679      * Add the link to the content tree.
 680      *
 681      * @param element program element for which the link will be added
 682      * @param label label for the link
 683      * @param htmltree the content tree to which the link will be added
 684      */
 685     public void addSrcLink(Element element, Content label, Content htmltree) {
 686         if (element == null) {
 687             return;
 688         }
 689         TypeElement te = utils.getEnclosingTypeElement(element);
 690         if (te == null) {
 691             // must be a typeElement since in has no containing class.
 692             te = (TypeElement) element;
 693         }
 694         if (utils.isIncluded(te)) {
 695             DocPath href = pathToRoot
 696                     .resolve(DocPaths.SOURCE_OUTPUT)
 697                     .resolve(docPaths.forClass(te));
 698             Content content = links.createLink(href
 699                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 700             htmltree.add(content);
 701         } else {
 702             htmltree.add(label);
 703         }
 704     }
 705 
 706     /**
 707      * Return the link to the given class.
 708      *
 709      * @param linkInfo the information about the link.
 710      *
 711      * @return the link for the given class.
 712      */
 713     public Content getLink(LinkInfoImpl linkInfo) {
 714         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 715         return factory.getLink(linkInfo);
 716     }
 717 
 718     /**
 719      * Return the type parameters for the given class.
 720      *
 721      * @param linkInfo the information about the link.
 722      * @return the type for the given class.
 723      */
 724     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 725         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 726         return factory.getTypeParameterLinks(linkInfo, false);
 727     }
 728 
 729     /*************************************************************
 730      * Return a class cross link to external class documentation.
 731      * The -link option does not allow users to
 732      * link to external classes in the &quot;default&quot; package.
 733      *
 734      * @param classElement the class element
 735      * @param refMemName the name of the member being referenced.  This should
 736      * be null or empty string if no member is being referenced.
 737      * @param label the label for the external link.
 738      * @param strong true if the link should be strong.
 739      * @param code true if the label should be code font.
 740      * @return the link
 741      */
 742     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 743                                     Content label, boolean strong, boolean code) {
 744         if (classElement != null) {
 745             String className = utils.getSimpleName(classElement);
 746             PackageElement packageElement = utils.containingPackage(classElement);
 747             Content defaultLabel = new StringContent(className);
 748             if (code)
 749                 defaultLabel = HtmlTree.CODE(defaultLabel);
 750             if (getCrossPackageLink(packageElement) != null) {
 751                 /*
 752                 The package exists in external documentation, so link to the external
 753                 class (assuming that it exists).  This is definitely a limitation of
 754                 the -link option.  There are ways to determine if an external package
 755                 exists, but no way to determine if the external class exists.  We just
 756                 have to assume that it does.
 757                 */
 758                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 759                                 className + &quot;.html&quot;, refMemName);
 760                 return links.createLink(link,
 761                     (label == null) || label.isEmpty() ? defaultLabel : label,
 762                     strong,
 763                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 764                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 765             }
 766         }
 767         return null;
 768     }
 769 
 770     public boolean isClassLinkable(TypeElement typeElement) {
 771         if (utils.isIncluded(typeElement)) {
 772             return configuration.isGeneratedDoc(typeElement);
 773         }
 774         return configuration.extern.isExternal(typeElement);
 775     }
 776 
 777     public DocLink getCrossPackageLink(PackageElement element) {
 778         return configuration.extern.getExternalLink(element, pathToRoot,
 779             DocPaths.PACKAGE_SUMMARY.getPath());
 780     }
 781 
 782     public DocLink getCrossModuleLink(ModuleElement element) {
 783         return configuration.extern.getExternalLink(element, pathToRoot,
 784             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 785     }
 786 
 787     /**
 788      * Get the class link.
 789      *
 790      * @param context the id of the context where the link will be added
 791      * @param element to link to
 792      * @return a content tree for the link
 793      */
 794     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 795         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 796         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 797     }
 798 
 799     /**
 800      * Add the class link.
 801      *
 802      * @param context the id of the context where the link will be added
 803      * @param typeElement to link to
 804      * @param contentTree the content tree to which the link will be added
 805      */
 806     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 807         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 808     }
 809 
 810     /**
 811      * Retrieve the class link with the package portion of the label in
 812      * plain text.  If the qualifier is excluded, it will not be included in the
 813      * link label.
 814      *
 815      * @param typeElement the class to link to.
 816      * @param isStrong true if the link should be strong.
 817      * @return the link with the package portion of the label in plain text.
 818      */
 819     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 820             TypeElement typeElement, boolean isStrong) {
 821         ContentBuilder classlink = new ContentBuilder();
 822         PackageElement pkg = utils.containingPackage(typeElement);
 823         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 824             classlink.add(getEnclosingPackageName(typeElement));
 825         }
 826         classlink.add(getLink(new LinkInfoImpl(configuration,
 827                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 828         return classlink;
 829     }
 830 
 831     /**
 832      * Add the class link with the package portion of the label in
 833      * plain text. If the qualifier is excluded, it will not be included in the
 834      * link label.
 835      *
 836      * @param context the id of the context where the link will be added
 837      * @param typeElement the class to link to
 838      * @param isStrong true if the link should be strong
 839      * @param contentTree the content tree to which the link with be added
 840      */
 841     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 842             TypeElement typeElement, boolean isStrong, Content contentTree) {
 843         PackageElement pkg = utils.containingPackage(typeElement);
 844         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 845             contentTree.add(getEnclosingPackageName(typeElement));
 846         }
 847         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 848                 .label(utils.getSimpleName(typeElement))
 849                 .strong(isStrong);
 850         Content link = getLink(linkinfo);
 851         contentTree.add(link);
 852     }
 853 
 854     /**
 855      * Get the enclosed name of the package
 856      *
 857      * @param te  TypeElement
 858      * @return the name
 859      */
 860     public String getEnclosingPackageName(TypeElement te) {
 861 
 862         PackageElement encl = configuration.utils.containingPackage(te);
 863         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 864     }
 865 
 866     /**
 867      * Return the main type element of the current page or null for pages that don&#39;t have one.
 868      *
 869      * @return the type element of the current page.
 870      */
 871     protected TypeElement getCurrentPageElement() {
 872         return null;
 873     }
 874 
 875     /**
 876      * Add the class link, with only class name as the strong link and prefixing
 877      * plain package name.
 878      *
 879      * @param context the id of the context where the link will be added
 880      * @param typeElement the class to link to
 881      * @param contentTree the content tree to which the link with be added
 882      */
 883     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 884         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 885     }
 886 
 887     /**
 888      * Get the link for the given member.
 889      *
 890      * @param context the id of the context where the link will be added
 891      * @param element the member being linked to
 892      * @param label the label for the link
 893      * @return a content tree for the element link
 894      */
 895     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 896         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 897                 new StringContent(label));
 898     }
 899 
 900     /**
 901      * Return the link for the given member.
 902      *
 903      * @param context the id of the context where the link will be printed.
 904      * @param element the member being linked to.
 905      * @param label the label for the link.
 906      * @param strong true if the link should be strong.
 907      * @return the link for the given member.
 908      */
 909     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 910             boolean strong) {
 911         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 912     }
 913 
 914     /**
 915      * Return the link for the given member.
 916      *
 917      * @param context the id of the context where the link will be printed.
 918      * @param typeElement the typeElement that we should link to.  This is not
 919                  necessarily equal to element.containingClass().  We may be
 920                  inheriting comments.
 921      * @param element the member being linked to.
 922      * @param label the label for the link.
 923      * @param strong true if the link should be strong.
 924      * @return the link for the given member.
 925      */
 926     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 927             CharSequence label, boolean strong) {
 928         return getDocLink(context, typeElement, element, label, strong, false);
 929     }
 930 
 931     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 932             Content label, boolean strong) {
 933         return getDocLink(context, typeElement, element, label, strong, false);
 934     }
 935 
 936     /**
 937      * Return the link for the given member.
 938      *
 939      * @param context the id of the context where the link will be printed.
 940      * @param typeElement the typeElement that we should link to.  This is not
 941                  necessarily equal to element.containingClass().  We may be
 942                  inheriting comments.
 943      * @param element the member being linked to.
 944      * @param label the label for the link.
 945      * @param strong true if the link should be strong.
 946      * @param isProperty true if the element parameter is a JavaFX property.
 947      * @return the link for the given member.
 948      */
 949     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 950             CharSequence label, boolean strong, boolean isProperty) {
 951         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 952     }
 953 
 954     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 955             Content label, boolean strong, boolean isProperty) {
 956         if (!utils.isLinkable(typeElement, element)) {
 957             return label;
 958         }
 959 
 960         if (utils.isExecutableElement(element)) {
 961             ExecutableElement ee = (ExecutableElement)element;
 962             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 963                 .label(label)
 964                 .where(links.getName(getAnchor(ee, isProperty)))
 965                 .strong(strong));
 966         }
 967 
 968         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 969             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 970                 .label(label)
 971                 .where(links.getName(element.getSimpleName().toString()))
 972                 .strong(strong));
 973         }
 974 
 975         return label;
 976     }
 977 
 978     /**
 979      * Return the link for the given member.
 980      *
 981      * @param context the id of the context where the link will be added
 982      * @param typeElement the typeElement that we should link to.  This is not
 983                  necessarily equal to element.containingClass().  We may be
 984                  inheriting comments
 985      * @param element the member being linked to
 986      * @param label the label for the link
 987      * @return the link for the given member
 988      */
 989     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 990             Content label) {
 991         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 992             return label;
 993         } else if (utils.isExecutableElement(element)) {
 994             ExecutableElement emd = (ExecutableElement) element;
 995             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 996                 .label(label)
 997                 .where(links.getName(getAnchor(emd))));
 998         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 999             return getLink(new LinkInfoImpl(configuration, context, typeElement)
1000                 .label(label).where(links.getName(element.getSimpleName().toString())));
1001         } else {
1002             return label;
1003         }
1004     }
1005 
1006     public String getAnchor(ExecutableElement executableElement) {
1007         return getAnchor(executableElement, false);
1008     }
1009 
1010     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
1011         if (isProperty) {
1012             return executableElement.getSimpleName().toString();
1013         }
1014         String member = anchorName(executableElement);
1015         String erasedSignature = utils.makeSignature(executableElement, true, true);
1016         return member + erasedSignature;
1017     }
1018 
1019     public String anchorName(Element member) {
1020         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1021             return &quot;&lt;init&gt;&quot;;
1022         } else {
1023             return utils.getSimpleName(member);
1024         }
1025     }
1026 
1027     public Content seeTagToContent(Element element, DocTree see) {
1028         Kind kind = see.getKind();
1029         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1030             return new ContentBuilder();
1031         }
1032 
1033         CommentHelper ch = utils.getCommentHelper(element);
1034         String tagName = ch.getTagName(see);
1035         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1036         // Check if @see is an href or &quot;string&quot;
1037         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1038             return new RawHtml(seetext);
1039         }
1040         boolean isLinkPlain = kind == LINK_PLAIN;
1041         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1042 
1043         //The text from the @see tag.  We will output this text when a label is not specified.
1044         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1045 
1046         TypeElement refClass = ch.getReferencedClass(see);
1047         String refClassName =  ch.getReferencedClassName(see);
1048         Element refMem =       ch.getReferencedMember(see);
1049         String refMemName =    ch.getReferencedMemberName(see);
1050 
1051         if (refMemName == null &amp;&amp; refMem != null) {
1052             refMemName = refMem.toString();
1053         }
1054         if (refClass == null) {
1055             //@see is not referencing an included class
1056             PackageElement refPackage = ch.getReferencedPackage(see);
1057             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1058                 //@see is referencing an included package
1059                 if (label.isEmpty())
1060                     label = plainOrCode(isLinkPlain,
1061                             new StringContent(refPackage.getQualifiedName()));
1062                 return getPackageLink(refPackage, label);
1063             } else {
1064                 // @see is not referencing an included class, module or package. Check for cross links.
1065                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1066                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1067                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1068                 if (elementCrossLink != null) {
1069                     // Element cross link found
1070                     return links.createLink(elementCrossLink,
1071                             (label.isEmpty() ? text : label), true);
1072                 } else {
1073                     // No cross link found so print warning
1074                     messages.warning(ch.getDocTreePath(see),
1075                             &quot;doclet.see.class_or_package_not_found&quot;,
1076                             &quot;@&quot; + tagName,
1077                             seetext);
1078                     return (label.isEmpty() ? text: label);
1079                 }
1080             }
1081         } else if (refMemName == null) {
1082             // Must be a class reference since refClass is not null and refMemName is null.
1083             if (label.isEmpty()) {
1084                 /*
1085                  * it seems to me this is the right thing to do, but it causes comparator failures.
1086                  */
1087                 if (!configuration.backwardCompatibility) {
1088                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1089                             ? new StringContent(utils.getSimpleName(refClass))
1090                             : new StringContent(utils.getFullyQualifiedName(refClass));
1091                     label = plainOrCode(isLinkPlain, content);
1092                 } else {
1093                     label = plainOrCode(isLinkPlain,
1094                             new StringContent(utils.getSimpleName(refClass)));
1095                 }
1096 
1097             }
1098             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1099                     .label(label));
1100         } else if (refMem == null) {
1101             // Must be a member reference since refClass is not null and refMemName is not null.
1102             // However, refMem is null, so this referenced member does not exist.
1103             return (label.isEmpty() ? text: label);
1104         } else {
1105             // Must be a member reference since refClass is not null and refMemName is not null.
1106             // refMem is not null, so this @see tag must be referencing a valid member.
1107             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1108 
1109             // Find the enclosing type where the method is actually visible
1110             // in the inheritance hierarchy.
1111             ExecutableElement overriddenMethod = null;
1112             if (refMem.getKind() == ElementKind.METHOD) {
1113                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1114                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1115 
1116                 if (overriddenMethod != null)
1117                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1118             }
1119             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1120                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1121                 // Since the link is relative and the holder is not even being
1122                 // documented, this must be an inherited link.  Redirect it.
1123                 // The current class either overrides the referenced member or
1124                 // inherits it automatically.
1125                 if (this instanceof ClassWriterImpl) {
1126                     containing = ((ClassWriterImpl) this).getTypeElement();
1127                 } else if (!utils.isPublic(containing)) {
1128                     messages.warning(
1129                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1130                         tagName, utils.getFullyQualifiedName(containing));
1131                 } else {
1132                     messages.warning(
1133                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1134                         tagName, seetext);
1135                 }
1136             }
1137             if (configuration.currentTypeElement != containing) {
1138                 refMemName = (utils.isConstructor(refMem))
1139                         ? refMemName
1140                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1141             }
1142             if (utils.isExecutableElement(refMem)) {
1143                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1144                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);
1145                 }
1146                 if (overriddenMethod != null) {
1147                     // The method to actually link.
1148                     refMem = overriddenMethod;
1149                 }
1150             }
1151 
1152             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1153 
1154             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1155                     refMem, (label.isEmpty() ? text: label), false);
1156         }
1157     }
1158 
1159     private Content plainOrCode(boolean plain, Content body) {
1160         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1161     }
1162 
1163     /**
1164      * Add the inline comment.
1165      *
1166      * @param element the Element for which the inline comment will be added
1167      * @param tag the inline tag to be added
1168      * @param htmltree the content tree to which the comment will be added
1169      */
1170     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1171         CommentHelper ch = utils.getCommentHelper(element);
1172         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1173         addCommentTags(element, tag, description, false, false, false, htmltree);
1174     }
1175 
1176     /**
1177      * Get the deprecated phrase as content.
1178      *
1179      * @param e the Element for which the inline deprecated comment will be added
1180      * @return a content tree for the deprecated phrase.
1181      */
1182     public Content getDeprecatedPhrase(Element e) {
1183         return (utils.isDeprecatedForRemoval(e))
1184                 ? contents.deprecatedForRemovalPhrase
1185                 : contents.deprecatedPhrase;
1186     }
1187 
1188     /**
1189      * Add the inline deprecated comment.
1190      *
1191      * @param e the Element for which the inline deprecated comment will be added
1192      * @param tag the inline tag to be added
1193      * @param htmltree the content tree to which the comment will be added
1194      */
1195     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1196         CommentHelper ch = utils.getCommentHelper(e);
1197         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1198     }
1199 
1200     /**
1201      * Adds the summary content.
1202      *
1203      * @param element the Element for which the summary will be generated
1204      * @param htmltree the documentation tree to which the summary will be added
1205      */
1206     public void addSummaryComment(Element element, Content htmltree) {
1207         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1208     }
1209 
1210     /**
1211      * Adds the summary content.
1212      *
1213      * @param element the Element for which the summary will be generated
1214      * @param firstSentenceTags the first sentence tags for the doc
1215      * @param htmltree the documentation tree to which the summary will be added
1216      */
1217     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1218         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1219     }
1220 
1221     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1222         CommentHelper ch = utils.getCommentHelper(element);
1223         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1224         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1225     }
1226 
1227     /**
1228      * Adds the inline comment.
1229      *
1230      * @param element the Element for which the inline comments will be generated
1231      * @param htmltree the documentation tree to which the inline comments will be added
1232      */
1233     public void addInlineComment(Element element, Content htmltree) {
1234         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1235     }
1236 
1237     /**
1238      * Adds the comment tags.
1239      *
1240      * @param element the Element for which the comment tags will be generated
1241      * @param tags the first sentence tags for the doc
1242      * @param depr true if it is deprecated
1243      * @param first true if the first sentence tags should be added
1244      * @param inSummary true if the comment tags are added into the summary section
1245      * @param htmltree the documentation tree to which the comment tags will be added
1246      */
1247     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1248             boolean first, boolean inSummary, Content htmltree) {
1249         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1250     }
1251 
1252     /**
1253      * Adds the comment tags.
1254      *
1255      * @param element for which the comment tags will be generated
1256      * @param holderTag the block tag context for the inline tags
1257      * @param tags the first sentence tags for the doc
1258      * @param depr true if it is deprecated
1259      * @param first true if the first sentence tags should be added
1260      * @param inSummary true if the comment tags are added into the summary section
1261      * @param htmltree the documentation tree to which the comment tags will be added
1262      */
1263     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1264             boolean first, boolean inSummary, Content htmltree) {
1265         if (options.noComment()){
1266             return;
1267         }
1268         Content div;
1269         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1270         if (depr) {
1271             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1272             htmltree.add(div);
1273         }
1274         else {
1275             div = HtmlTree.DIV(HtmlStyle.block, result);
1276             htmltree.add(div);
1277         }
1278         if (tags.isEmpty()) {
1279             htmltree.add(Entity.NO_BREAK_SPACE);
1280         }
1281     }
1282 
1283     boolean ignoreNonInlineTag(DocTree dtree) {
1284         Name name = null;
1285         if (dtree.getKind() == Kind.START_ELEMENT) {
1286             StartElementTree setree = (StartElementTree)dtree;
1287             name = setree.getName();
1288         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1289             EndElementTree eetree = (EndElementTree)dtree;
1290             name = eetree.getName();
1291         }
1292 
1293         if (name != null) {
1294             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1295             if (htmlTag != null &amp;&amp;
1296                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1297                 return true;
1298             }
1299         }
1300         return false;
1301     }
1302 
1303     boolean isAllWhiteSpace(String body) {
1304         for (int i = 0 ; i &lt; body.length(); i++) {
1305             if (!Character.isWhitespace(body.charAt(i)))
1306                 return false;
1307         }
1308         return true;
1309     }
1310 
1311     // Notify the next DocTree handler to take necessary action
1312     private boolean commentRemoved = false;
1313 
1314     /**
1315      * Converts inline tags and text to Content, expanding the
1316      * inline tags along the way.  Called wherever text can contain
1317      * an inline tag, such as in comments or in free-form text arguments
1318      * to block tags.
1319      *
1320      * @param holderTag    specific tag where comment resides
1321      * @param element    specific element where comment resides
1322      * @param tags   array of text tags and inline tags (often alternating)
1323                present in the text of interest for this element
1324      * @param isFirstSentence  true if text is first sentence
1325      * @return a Content object
1326      */
<a name="2" id="anc2"></a><span class="line-modified">1327     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">1328             List&lt;? extends DocTree&gt; tags, boolean isFirstSentence) {</span>



1329         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1330     }
1331 
1332     /**
1333      * Converts inline tags and text to text strings, expanding the
1334      * inline tags along the way.  Called wherever text can contain
1335      * an inline tag, such as in comments or in free-form text arguments
1336      * to block tags.
1337      *
1338      * @param holderTag       specific tag where comment resides
1339      * @param element         specific element where comment resides
1340      * @param trees           array of text tags and inline tags (often alternating)
1341      *                        present in the text of interest for this element
1342      * @param isFirstSentence true if text is first sentence
1343      * @param inSummary       if the comment tags are added into the summary section
1344      * @return a Content object
1345      */
<a name="3" id="anc3"></a><span class="line-modified">1346     public Content commentTagsToContent(DocTree holderTag, Element element,</span>
<span class="line-modified">1347             List&lt;? extends DocTree&gt; trees, boolean isFirstSentence, boolean inSummary) {</span>
<span class="line-modified">1348 </span>



1349         final Content result = new ContentBuilder() {
1350             @Override
1351             public void add(CharSequence text) {
1352                 super.add(utils.normalizeNewlines(text));
1353             }
1354         };
1355         CommentHelper ch = utils.getCommentHelper(element);
1356         // Array of all possible inline tags for this javadoc run
1357         configuration.tagletManager.checkTags(element, trees, true);
1358         commentRemoved = false;
1359 
1360         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1361             boolean isFirstNode = !iterator.hasPrevious();
1362             DocTree tag = iterator.next();
1363             boolean isLastNode  = !iterator.hasNext();
1364 
1365             if (isFirstSentence) {
1366                 // Ignore block tags
1367                 if (ignoreNonInlineTag(tag))
1368                     continue;
1369 
1370                 // Ignore any trailing whitespace OR whitespace after removed html comment
1371                 if ((isLastNode || commentRemoved)
1372                         &amp;&amp; tag.getKind() == TEXT
1373                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1374                     continue;
1375 
1376                 // Ignore any leading html comments
1377                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1378                     commentRemoved = true;
1379                     continue;
1380                 }
1381             }
1382 
1383             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1384 
1385                 private boolean inAnAtag() {
1386                     if (utils.isStartElement(tag)) {
1387                         StartElementTree st = (StartElementTree)tag;
1388                         Name name = st.getName();
1389                         if (name != null) {
1390                             com.sun.tools.doclint.HtmlTag htag =
1391                                     com.sun.tools.doclint.HtmlTag.get(name);
1392                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1393                         }
1394                     }
1395                     return false;
1396                 }
1397 
1398                 @Override
1399                 public Boolean visitAttribute(AttributeTree node, Content c) {
1400                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1401                     if (node.getValueKind() == ValueKind.EMPTY) {
1402                         result.add(sb);
1403                         return false;
1404                     }
1405                     sb.append(&quot;=&quot;);
1406                     String quote;
1407                     switch (node.getValueKind()) {
1408                         case DOUBLE:
1409                             quote = &quot;\&quot;&quot;;
1410                             break;
1411                         case SINGLE:
<a name="4" id="anc4"></a><span class="line-modified">1412                             quote = &quot;\&#39;&quot;;</span>
1413                             break;
1414                         default:
1415                             quote = &quot;&quot;;
1416                             break;
1417                     }
1418                     sb.append(quote);
1419                     result.add(sb);
1420                     Content docRootContent = new ContentBuilder();
1421 
1422                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1423                     for (DocTree dt : node.getValue()) {
1424                         if (utils.isText(dt) &amp;&amp; isHRef) {
1425                             String text = ((TextTree) dt).getBody();
1426                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1427                                 result.add(options.docrootParent());
1428                                 docRootContent = new ContentBuilder();
1429                                 result.add(textCleanup(text.substring(3), isLastNode));
1430                             } else {
1431                                 if (!docRootContent.isEmpty()) {
1432                                     docRootContent = copyDocRootContent(docRootContent);
1433                                 } else {
1434                                     text = redirectRelativeLinks(element, (TextTree) dt);
1435                                 }
1436                                 result.add(textCleanup(text, isLastNode));
1437                             }
1438                         } else {
1439                             docRootContent = copyDocRootContent(docRootContent);
1440                             dt.accept(this, docRootContent);
1441                         }
1442                     }
1443                     copyDocRootContent(docRootContent);
1444                     result.add(quote);
1445                     return false;
1446                 }
1447 
1448                 @Override
1449                 public Boolean visitComment(CommentTree node, Content c) {
1450                     result.add(new RawHtml(node.getBody()));
1451                     return false;
1452                 }
1453 
1454                 private Content copyDocRootContent(Content content) {
1455                     if (!content.isEmpty()) {
1456                         result.add(content);
1457                         return new ContentBuilder();
1458                     }
1459                     return content;
1460                 }
1461 
1462                 @Override
1463                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1464                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1465                             configuration.tagletManager,
1466                             holderTag,
1467                             node,
1468                             getTagletWriterInstance(isFirstSentence));
1469                     if (c != null) {
1470                         c.add(docRootContent);
1471                     } else {
1472                         result.add(docRootContent);
1473                     }
1474                     return false;
1475                 }
1476 
1477                 @Override
1478                 public Boolean visitEndElement(EndElementTree node, Content c) {
1479                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1480                     result.add(rawHtml);
1481                     return false;
1482                 }
1483 
1484                 @Override
1485                 public Boolean visitEntity(EntityTree node, Content c) {
1486                     result.add(new RawHtml(node.toString()));
1487                     return false;
1488                 }
1489 
1490                 @Override
1491                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1492                     messages.warning(ch.getDocTreePath(node),
1493                             &quot;doclet.tag.invalid_usage&quot;, node);
1494                     result.add(new RawHtml(node.toString()));
1495                     return false;
1496                 }
1497 
1498                 @Override
1499                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1500                     Content output = TagletWriter.getInlineTagOutput(element,
1501                             configuration.tagletManager, holderTag,
1502                             tag, getTagletWriterInstance(isFirstSentence));
1503                     result.add(output);
1504                     // if we obtained the first sentence successfully, nothing more to do
1505                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1506                 }
1507 
1508                 @Override
1509                 public Boolean visitIndex(IndexTree node, Content p) {
1510                     Content output = TagletWriter.getInlineTagOutput(element,
1511                             configuration.tagletManager, holderTag, tag,
1512                             getTagletWriterInstance(isFirstSentence, inSummary));
1513                     if (output != null) {
1514                         result.add(output);
1515                     }
1516                     return false;
1517                 }
1518 
1519                 @Override
1520                 public Boolean visitLink(LinkTree node, Content c) {
1521                     // we need to pass the DocTreeImpl here, so ignore node
1522                     Content content = seeTagToContent(element, tag);
1523                     result.add(content);
1524                     return false;
1525                 }
1526 
1527                 @Override
1528                 public Boolean visitLiteral(LiteralTree node, Content c) {
1529                     String s = node.getBody().getBody();
1530                     Content content = new StringContent(utils.normalizeNewlines(s));
1531                     if (node.getKind() == CODE)
1532                         content = HtmlTree.CODE(content);
1533                     result.add(content);
1534                     return false;
1535                 }
1536 
1537                 @Override
1538                 public Boolean visitSee(SeeTree node, Content c) {
1539                     // we need to pass the DocTreeImpl here, so ignore node
1540                     result.add(seeTagToContent(element, tag));
1541                     return false;
1542                 }
1543 
1544                 @Override
1545                 public Boolean visitStartElement(StartElementTree node, Content c) {
1546                     String text = &quot;&lt;&quot; + node.getName();
1547                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1548                     result.add(rawHtml);
1549 
1550                     for (DocTree dt : node.getAttributes()) {
1551                         dt.accept(this, null);
1552                     }
1553                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1554                     return false;
1555                 }
1556 
1557                 @Override
1558                 public Boolean visitSummary(SummaryTree node, Content c) {
1559                     Content output = TagletWriter.getInlineTagOutput(element,
1560                             configuration.tagletManager, holderTag, tag,
1561                             getTagletWriterInstance(isFirstSentence));
1562                     result.add(output);
1563                     return false;
1564                 }
1565 
1566                 @Override
1567                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1568                     Content output = TagletWriter.getInlineTagOutput(element,
1569                             configuration.tagletManager, holderTag, tag,
1570                             getTagletWriterInstance(isFirstSentence, inSummary));
1571                     if (output != null) {
1572                         result.add(output);
1573                     }
1574                     return false;
1575                 }
1576 
1577                 private CharSequence textCleanup(String text, boolean isLast) {
1578                     return textCleanup(text, isLast, false);
1579                 }
1580 
1581                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1582                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1583                     if (stripLeading &amp;&amp; stripTrailing) {
1584                         text = text.strip();
1585                     } else if (stripLeading) {
1586                         text = text.stripLeading();
1587                     } else if (stripTrailing) {
1588                         text = text.stripTrailing();
1589                     }
1590                     text = utils.replaceTabs(text);
1591                     return utils.normalizeNewlines(text);
1592                 }
1593 
1594                 @Override
1595                 public Boolean visitText(TextTree node, Content c) {
1596                     String text = node.getBody();
1597                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1598                     return false;
1599                 }
1600 
1601                 @Override
1602                 protected Boolean defaultAction(DocTree node, Content c) {
1603                     Content output = TagletWriter.getInlineTagOutput(element,
1604                             configuration.tagletManager, holderTag, tag,
1605                             getTagletWriterInstance(isFirstSentence));
1606                     if (output != null) {
1607                         result.add(output);
1608                     }
1609                     return false;
1610                 }
1611 
1612             }.visit(tag, null);
1613             commentRemoved = false;
1614             if (allDone)
1615                 break;
1616         }
1617         return result;
1618     }
1619 
1620     /**
1621      * Return true if relative links should not be redirected.
1622      *
1623      * @return Return true if a relative link should not be redirected.
1624      */
1625     private boolean shouldNotRedirectRelativeLinks() {
1626         return  this instanceof AnnotationTypeWriter ||
1627                 this instanceof ClassWriter ||
1628                 this instanceof PackageSummaryWriter;
1629     }
1630 
1631     /**
1632      * Suppose a piece of documentation has a relative link.  When you copy
1633      * that documentation to another place such as the index or class-use page,
1634      * that relative link will no longer work.  We should redirect those links
1635      * so that they will work again.
1636      * &lt;p&gt;
1637      * Here is the algorithm used to fix the link:
1638      * &lt;p&gt;
1639      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1640      * &lt;p&gt;
1641      * For example, suppose DocletEnvironment has this link:
1642      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1643      * &lt;p&gt;
1644      * If this link appeared in the index, we would redirect
1645      * the link like this:
1646      *
1647      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1648      *
1649      * @param element the Element object whose documentation is being written.
1650      * @param tt the text being written.
1651      *
1652      * @return the text, with all the relative links redirected to work.
1653      */
1654     @SuppressWarnings(&quot;preview&quot;)
1655     private String redirectRelativeLinks(Element element, TextTree tt) {
1656         String text = tt.getBody();
1657         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1658             return text;
1659         }
1660 
1661         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1662             @Override
1663             public DocPath visitType(TypeElement e, Void p) {
1664                 return docPaths.forPackage(utils.containingPackage(e));
1665             }
1666 
1667             @Override
1668             public DocPath visitPackage(PackageElement e, Void p) {
1669                 return docPaths.forPackage(e);
1670             }
1671 
1672             @Override
1673             public DocPath visitVariable(VariableElement e, Void p) {
1674                 return docPaths.forPackage(utils.containingPackage(e));
1675             }
1676 
1677             @Override
1678             public DocPath visitExecutable(ExecutableElement e, Void p) {
1679                 return docPaths.forPackage(utils.containingPackage(e));
1680             }
1681 
1682             @Override
1683             protected DocPath defaultAction(Element e, Void p) {
1684                 return null;
1685             }
1686         }.visit(element);
1687         if (redirectPathFromRoot == null) {
1688             return text;
1689         }
1690         String lower = Utils.toLowerCase(text);
1691         if (!(lower.startsWith(&quot;mailto:&quot;)
1692                 || lower.startsWith(&quot;http:&quot;)
1693                 || lower.startsWith(&quot;https:&quot;)
1694                 || lower.startsWith(&quot;file:&quot;))) {
1695             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1696                     + redirectPathFromRoot.resolve(text).getPath();
1697             text = replaceDocRootDir(text);
1698         }
1699         return text;
1700     }
1701 
1702     /**
1703      * According to
1704      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1705      * all the outer classes and static nested classes are core classes.
1706      */
1707     public boolean isCoreClass(TypeElement typeElement) {
1708         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1709     }
1710 
1711     /**
1712      * Adds the annotation types for the given packageElement.
1713      *
1714      * @param packageElement the package to write annotations for.
1715      * @param htmltree the documentation tree to which the annotation info will be
1716      *        added
1717      */
1718     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1719         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1720     }
1721 
1722     /*
1723      * this is a hack to delay dealing with Annotations in the writers, the assumption
1724      * is that all necessary checks have been made to get here.
1725      */
1726     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1727             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1728         TypeMirror rcvrType = method.getReceiverType();
1729         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1730         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1731     }
1732 
1733     /**
1734      * Adds the annotation types for the given element.
1735      *
1736      * @param element the package to write annotations for
1737      * @param htmltree the content tree to which the annotation types will be added
1738      */
1739     public void addAnnotationInfo(Element element, Content htmltree) {
1740         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1741     }
1742 
1743     /**
1744      * Add the annotation types for the given element and parameter.
1745      *
1746      * @param param the parameter to write annotations for.
1747      * @param tree the content tree to which the annotation types will be added
1748      */
1749     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1750         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1751         if (annotationInfo.isEmpty()) {
1752             return false;
1753         }
1754         tree.add(annotationInfo);
1755         return true;
1756     }
1757 
1758     /**
1759      * Adds the annotation types for the given Element.
1760      *
1761      * @param descList a list of annotation mirrors.
1762      * @param htmltree the documentation tree to which the annotation info will be
1763      *        added
1764      */
1765     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1766         htmltree.add(getAnnotationInfo(descList, true));
1767     }
1768 
1769     /**
1770      * Return a content tree containing the annotation types for the given element.
1771      *
1772      * @param descList a list of annotation mirrors.
1773      * @return the documentation tree containing the annotation info.
1774      */
1775     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1776         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1777         String sep = &quot;&quot;;
1778         ContentBuilder builder = new ContentBuilder();
1779         for (Content annotation: annotations) {
1780             builder.add(sep);
1781             builder.add(annotation);
1782             if (!lineBreak) {
1783                 sep = &quot; &quot;;
1784             }
1785         }
1786         return builder;
1787     }
1788 
1789     /**
1790      * Return the string representations of the annotation types for
1791      * the given doc.
1792      *
1793      * @param descList a list of annotation mirrors.
1794      * @param linkBreak if true, add new line between each member value.
1795      * @return a list of strings representing the annotations being
1796      *         documented.
1797      */
1798     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1799         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1800         ContentBuilder annotation;
1801         for (AnnotationMirror aDesc : descList) {
1802             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1803             // If an annotation is not documented, do not add it to the list. If
1804             // the annotation is of a repeatable type, and if it is not documented
1805             // and also if its container annotation is not documented, do not add it
1806             // to the list. If an annotation of a repeatable type is not documented
1807             // but its container is documented, it will be added to the list.
1808             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1809                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1810                 continue;
1811             }
1812             annotation = new ContentBuilder();
1813             isAnnotationDocumented = false;
1814             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1815                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1816             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1817             // If the annotation is synthesized, do not print the container.
1818             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1819                 for (ExecutableElement ee : pairs.keySet()) {
1820                     AnnotationValue annotationValue = pairs.get(ee);
1821                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1822 
1823                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1824                         @Override
1825                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1826                             p.addAll(vals);
1827                             return null;
1828                         }
1829 
1830                         @Override
1831                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1832                             p.add(annotationValue);
1833                             return null;
1834                         }
1835                     }.visit(annotationValue, annotationTypeValues);
1836 
1837                     String sep = &quot;&quot;;
1838                     for (AnnotationValue av : annotationTypeValues) {
1839                         annotation.add(sep);
1840                         annotation.add(annotationValueToContent(av));
1841                         sep = &quot; &quot;;
1842                     }
1843                 }
1844             } else if (isAnnotationArray(pairs)) {
1845                 // If the container has 1 or more value defined and if the
1846                 // repeatable type annotation is not documented, do not print
1847                 // the container.
1848                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1849                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1850                     for (AnnotationValue a :  pairs.values()) {
1851                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1852                             @Override
1853                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1854                                annotationTypeValues.addAll(vals);
1855                                return null;
1856                             }
1857                         }.visit(a, annotationTypeValues);
1858                     }
1859                     String sep = &quot;&quot;;
1860                     for (AnnotationValue av : annotationTypeValues) {
1861                         annotation.add(sep);
1862                         annotation.add(annotationValueToContent(av));
1863                         sep = &quot; &quot;;
1864                     }
1865                 }
1866                 // If the container has 1 or more value defined and if the
1867                 // repeatable type annotation is not documented, print the container.
1868                 else {
1869                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1870                 }
1871             }
1872             else {
1873                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1874             }
1875             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1876             results.add(annotation);
1877         }
1878         return results;
1879     }
1880 
1881     /**
1882      * Add annotation to the annotation string.
1883      *
1884      * @param annotationDoc the annotation being documented
1885      * @param linkInfo the information about the link
1886      * @param annotation the annotation string to which the annotation will be added
1887      * @param map annotation type element to annotation value pairs
1888      * @param linkBreak if true, add new line between each member value
1889      */
1890     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1891                                 ContentBuilder annotation,
1892                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1893                                 boolean linkBreak) {
1894         linkInfo.label = new StringContent(&quot;@&quot;);
1895         linkInfo.label.add(annotationDoc.getSimpleName());
1896         annotation.add(getLink(linkInfo));
1897         if (!map.isEmpty()) {
1898             annotation.add(&quot;(&quot;);
1899             boolean isFirst = true;
1900             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1901             boolean multipleValues = keys.size() &gt; 1;
1902             for (ExecutableElement element : keys) {
1903                 if (isFirst) {
1904                     isFirst = false;
1905                 } else {
1906                     annotation.add(&quot;,&quot;);
1907                     if (linkBreak) {
1908                         annotation.add(DocletConstants.NL);
1909                         int spaces = annotationDoc.getSimpleName().length() + 2;
1910                         for (int k = 0; k &lt; (spaces); k++) {
1911                             annotation.add(&quot; &quot;);
1912                         }
1913                     }
1914                 }
1915                 String simpleName = element.getSimpleName().toString();
1916                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1917                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1918                                                      element, simpleName, false));
1919                     annotation.add(&quot;=&quot;);
1920                 }
1921                 AnnotationValue annotationValue = map.get(element);
1922                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1923                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1924                     @Override
1925                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1926                         annotationTypeValues.addAll(vals);
1927                         return null;
1928                     }
1929                     @Override
1930                     protected Void defaultAction(Object o, AnnotationValue p) {
1931                         annotationTypeValues.add(p);
1932                         return null;
1933                     }
1934                 }.visit(annotationValue, annotationValue);
1935                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1936                 String sep = &quot;&quot;;
1937                 for (AnnotationValue av : annotationTypeValues) {
1938                     annotation.add(sep);
1939                     annotation.add(annotationValueToContent(av));
1940                     sep = &quot;,&quot;;
1941                 }
1942                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1943                 isContainerDocumented = false;
1944             }
1945             annotation.add(&quot;)&quot;);
1946         }
1947     }
1948 
1949     /**
1950      * Check if the annotation contains an array of annotation as a value. This
1951      * check is to verify if a repeatable type annotation is present or not.
1952      *
1953      * @param pairs annotation type element and value pairs
1954      *
1955      * @return true if the annotation contains an array of annotation as a value.
1956      */
1957     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1958         AnnotationValue annotationValue;
1959         for (ExecutableElement ee : pairs.keySet()) {
1960             annotationValue = pairs.get(ee);
1961             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1962                 @Override
1963                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1964                     if (vals.size() &gt; 1) {
1965                         if (vals.get(0) instanceof AnnotationMirror) {
1966                             isContainerDocumented = true;
1967                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1968                                 @Override
1969                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1970                                     isContainerDocumented = true;
1971                                     Element asElement = a.getAnnotationType().asElement();
1972                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1973                                         isAnnotationDocumented = true;
1974                                     }
1975                                     return true;
1976                                 }
1977                                 @Override
1978                                 protected Boolean defaultAction(Object o, Void p) {
1979                                     return false;
1980                                 }
1981                             }.visit(vals.get(0));
1982                         }
1983                     }
1984                     return false;
1985                 }
1986 
1987                 @Override
1988                 protected Boolean defaultAction(Object o, Void p) {
1989                     return false;
1990                 }
1991             }.visit(annotationValue);
1992             if (rvalue) {
1993                 return true;
1994             }
1995         }
1996         return false;
1997     }
1998 
1999     private Content annotationValueToContent(AnnotationValue annotationValue) {
2000         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
2001 
2002             @Override
2003             public Content visitType(TypeMirror t, Void p) {
2004                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2005                     @Override
2006                     public Content visitDeclared(DeclaredType t, Void p) {
2007                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2008                                 LinkInfoImpl.Kind.ANNOTATION, t);
2009                         String name = utils.isIncluded(t.asElement())
2010                                 ? t.asElement().getSimpleName().toString()
2011                                 : utils.getFullyQualifiedName(t.asElement());
2012                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2013                         return getLink(linkInfo);
2014                     }
2015                     @Override
2016                     protected Content defaultAction(TypeMirror e, Void p) {
2017                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2018                     }
2019                 }.visit(t);
2020             }
2021             @Override
2022             public Content visitAnnotation(AnnotationMirror a, Void p) {
2023                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
2024                 ContentBuilder buf = new ContentBuilder();
2025                 for (Content c : list) {
2026                     buf.add(c);
2027                 }
2028                 return buf;
2029             }
2030             @Override
2031             public Content visitEnumConstant(VariableElement c, Void p) {
2032                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2033                         c, c.getSimpleName(), false);
2034             }
2035             @Override
2036             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2037                 ContentBuilder buf = new ContentBuilder();
2038                 String sep = &quot;&quot;;
2039                 for (AnnotationValue av : vals) {
2040                     buf.add(sep);
2041                     buf.add(visit(av));
2042                     sep = &quot; &quot;;
2043                 }
2044                 return buf;
2045             }
2046             @Override
2047             protected Content defaultAction(Object o, Void p) {
2048                 return new StringContent(annotationValue.toString());
2049             }
2050         }.visit(annotationValue);
2051     }
2052 
2053     protected TableHeader getPackageTableHeader() {
2054         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2055     }
2056 
2057     /**
2058      * Generates a string for use in a description meta element,
2059      * based on an element and its enclosing elements
2060      * @param prefix a prefix for the string
2061      * @param elem the element
2062      * @return the description
2063      */
2064     static String getDescription(String prefix, Element elem) {
2065         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2066         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2067             // ignore unnamed enclosing elements
2068             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2069                 break;
2070             }
2071             chain.addFirst(e);
2072         }
2073         StringBuilder sb = new StringBuilder();
2074         for (Element e: chain) {
2075             CharSequence name;
2076             switch (e.getKind()) {
2077                 case MODULE:
2078                 case PACKAGE:
2079                     name = ((QualifiedNameable) e).getQualifiedName();
2080                     if (name.length() == 0) {
2081                         name = &quot;&lt;unnamed&gt;&quot;;
2082                     }
2083                     break;
2084 
2085                 default:
2086                     name = e.getSimpleName();
2087                     break;
2088             }
2089 
2090             if (sb.length() == 0) {
2091                 sb.append(prefix).append(&quot;: &quot;);
2092             } else {
2093                 sb.append(&quot;, &quot;);
2094             }
2095             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2096                     .append(&quot;: &quot;)
2097                     .append(name);
2098         }
2099         return sb.toString();
2100     }
2101 
2102     static String getGenerator(Class&lt;?&gt; clazz) {
2103         return &quot;javadoc/&quot; + clazz.getSimpleName();
2104     }
2105 
2106     /**
2107      * Returns an HtmlTree for the BODY tag.
2108      *
2109      * @param title title for the window
2110      * @return an HtmlTree for the BODY tag
2111      */
2112     public HtmlTree getBody(String title) {
2113         HtmlTree body = new HtmlTree(HtmlTag.BODY);
2114         body.put(HtmlAttr.CLASS, getBodyClass());
2115 
2116         this.winTitle = title;
2117         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2118         // and package-frame
2119         body.add(mainBodyScript.asContent());
2120         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2121         body.add(noScript);
2122         return body;
2123     }
2124 
2125     public String getBodyClass() {
2126         return getClass().getSimpleName()
2127                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2128                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2129                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)
2130                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)
2131                 .toLowerCase(Locale.US);
2132     }
2133 
2134     Script getMainBodyScript() {
2135         return mainBodyScript;
2136     }
2137 
2138     /**
2139      * Returns the path of module/package specific stylesheets for the element.
2140      * @param element module/Package element
2141      * @return list of path of module/package specific stylesheets
2142      * @throws DocFileIOException
2143      */
2144     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2145         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2146         DocPath basePath = null;
2147         if (element instanceof PackageElement) {
2148             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2149             basePath = docPaths.forPackage((PackageElement)element);
2150         } else if (element instanceof ModuleElement) {
2151             basePath = DocPaths.forModule((ModuleElement)element);
2152         }
2153         for (DocPath stylesheet : getStylesheets(element)) {
2154             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2155         }
2156         return stylesheets;
2157     }
2158 
2159     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2160             DocFileIOException {
2161         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2162         ModuleElement moduleElement = utils.containingModule(pkgElement);
2163         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2164             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2165             DocPath basePath = DocPaths.forModule(moduleElement);
2166             for (DocPath stylesheet : localStylesheets) {
2167                 moduleStylesheets.add(basePath.resolve(stylesheet));
2168             }
2169         }
2170         return moduleStylesheets;
2171     }
2172 
2173     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2174         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2175         if (localStylesheets == null) {
2176             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2177                     .getWriterFactory().getDocFilesHandler(element);
2178             localStylesheets = docFilesHandler.getStylesheets();
2179             configuration.localStylesheetMap.put(element, localStylesheets);
2180         }
2181         return localStylesheets;
2182     }
2183 
2184     Content getVerticalSeparator() {
2185         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2186     }
2187 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
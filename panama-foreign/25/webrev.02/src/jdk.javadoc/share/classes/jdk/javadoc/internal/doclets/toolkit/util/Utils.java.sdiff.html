<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IndexBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 217         List&lt;Element&gt; excludeList = members.stream()</span>
<span class="line-modified"> 218                 .filter((member) -&gt; (!isDeprecated(member)))</span>
<span class="line-modified"> 219                 .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                 .collect(Collectors.&lt;Element, List&lt;Element&gt;&gt;toCollection(ArrayList::new));</span>
<span class="line-removed"> 221         return excludeList;</span>
 222     }
 223 
 224     /**
 225      * Search for the given method in the given class.
 226      *
 227      * @param  te        Class to search into.
 228      * @param  method    Method to be searched.
 229      * @return ExecutableElement Method found, null otherwise.
 230      */
 231     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 232         for (Element m : getMethods(te)) {
<span class="line-modified"> 233             if (executableMembersEqual(method, (ExecutableElement)m)) {</span>
<span class="line-modified"> 234                 return (ExecutableElement)m;</span>
 235             }
 236         }
 237         return null;
 238     }
 239 
 240     /**
 241      * Test whether a class is a subclass of another class.
 242      *
 243      * @param t1 the candidate superclass.
 244      * @param t2 the target
 245      * @return true if t1 is a superclass of t2.
 246      */
 247     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 248         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 249     }
 250 
 251     /**
 252      * @param e1 the first method to compare.
 253      * @param e2 the second method to compare.
 254      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 255      */
<span class="line-removed"> 256 </span>
 257     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 258         // TODO: investigate if Elements.hides(..) will work here.
 259         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 260             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 261             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 262             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 263                     parameters1.size() == parameters2.size()) {
 264                 int j;
 265                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 266                     VariableElement v1 = parameters1.get(j);
 267                     VariableElement v2 = parameters2.get(j);
 268                     String t1 = getTypeName(v1.asType(), true);
 269                     String t2 = getTypeName(v2.asType(), true);
 270                     if (!(t1.equals(t2) ||
 271                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 272                         break;
 273                     }
 274                 }
 275                 if (j == parameters1.size()) {
<span class="line-modified"> 276                 return true;</span>
 277                 }
 278             }
 279             return false;
 280         } else {
 281             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 282                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 283                     e1.equals(e2);
 284         }
 285     }
 286 
 287     /**
 288      * According to
 289      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 290      * all the outer classes and static inner classes are core classes.
 291      */
 292     public boolean isCoreClass(TypeElement e) {
 293         return getEnclosingTypeElement(e) == null || isStatic(e);
 294     }
 295 
 296     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 491         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 492             final StringBuilder sb = new StringBuilder();
 493 
 494             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 495                 if (modifiers.contains(PUBLIC)) {
 496                     append(&quot;public&quot;);
 497                 } else if (modifiers.contains(PROTECTED)) {
 498                     append(&quot;protected&quot;);
 499                 } else if (modifiers.contains(PRIVATE)) {
 500                     append(&quot;private&quot;);
 501                 }
 502             }
 503 
 504             void addStatic(Set&lt;Modifier&gt; modifiers) {
 505                 if (modifiers.contains(STATIC)) {
 506                     append(&quot;static&quot;);
 507                 }
 508             }
 509 
 510             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<span class="line-modified"> 511                 modifiers.stream().map(Modifier::toString).forEach(this::append);</span>
 512             }
 513 
 514             void append(String s) {
 515                 if (sb.length() &gt; 0) {
 516                     sb.append(&quot; &quot;);
 517                 }
 518                 sb.append(s);
 519             }
 520 
 521             String finalString(String s) {
 522                 append(s);
 523                 if (trailingSpace) {
 524                     sb.append(&quot; &quot;);
<span class="line-modified"> 525                     }</span>
 526                 return sb.toString();
 527             }
 528 
 529             @Override
 530             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 531                 addVisibilityModifier(mods);
 532                 addStatic(mods);
 533                 return finalString(&quot;interface&quot;);
 534             }
 535 
 536             @Override
 537             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 538                 addVisibilityModifier(mods);
 539                 addStatic(mods);
 540                 return finalString(&quot;enum&quot;);
 541             }
 542 
 543             @Override
 544             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 545                 addVisibilityModifier(mods);
</pre>
<hr />
<pre>
 648               case LOCAL_VARIABLE: case PARAMETER:
 649               case RESOURCE_VARIABLE:
 650                   return true;
 651               default:
 652                   return false;
 653         }
 654     }
 655 
 656     public boolean isTypeElement(Element e) {
 657         switch (e.getKind()) {
 658             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 659                 return true;
 660             default:
 661                 return false;
 662         }
 663     }
 664 
 665     /**
 666      * Get the signature. It is the parameter list, type is qualified.
 667      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 668      * it will return {@code(java.lang.String,int)}.</span>
 669      *
 670      * @param e
 671      * @return String
 672      */
 673     public String signature(ExecutableElement e) {
 674         return makeSignature(e, true);
 675     }
 676 
 677     /**
 678      * Get flat signature.  All types are not qualified.
 679      * Return a String, which is the flat signature of this member.
 680      * It is the parameter list, type is not qualified.
 681      * For instance, for a method {@code mymethod(String x, int y)},
 682      * it will return {@code (String, int)}.
 683      */
 684     public String flatSignature(ExecutableElement e) {
 685         return makeSignature(e, false);
 686     }
 687 
 688     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 912             TypeElement te = asTypeElement(t);
 913             if (te == null) {
 914                 return null;
 915             }
 916             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 917             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 918                 ExecutableElement ee = (ExecutableElement)e;
 919                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 920                         !isSimpleOverride(ee)) {
 921                     return ee;
 922                 }
 923             }
 924             if (t.equals(getObjectType()))
 925                 return null;
 926         }
 927         return null;
 928     }
 929 
 930     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 931         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 932         for (TypeElement te : typeElements) {</span>
<span class="line-removed"> 933             set.add(te);</span>
<span class="line-removed"> 934         }</span>
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
 954      * @param enclosing a TypeElement whose type arguments  we desire
</pre>
<hr />
<pre>
1230             }
1231         }.visit(t);
1232     }
1233 
1234     public TypeMirror getComponentType(TypeMirror t) {
1235         while (isArrayType(t)) {
1236             t = ((ArrayType) t).getComponentType();
1237         }
1238         return t;
1239     }
1240 
1241     /**
1242      * Return the type&#39;s dimension information, as a string.
1243      * &lt;p&gt;
1244      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1245      *
1246      * @return the type&#39;s dimension information as a string.
1247      */
1248     public String getDimension(TypeMirror t) {
1249         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1250             StringBuilder dimension = new StringBuilder(&quot;&quot;);</span>
1251             @Override
1252             public String visitArray(ArrayType t, Void p) {
1253                 dimension.append(&quot;[]&quot;);
1254                 return visit(t.getComponentType());
1255             }
1256 
1257             @Override
1258             protected String defaultAction(TypeMirror e, Void p) {
1259                 return dimension.toString();
1260             }
1261 
1262         }.visit(t);
1263     }
1264 
1265     public TypeElement getSuperClass(TypeElement te) {
1266         if (isInterface(te) || isAnnotationType(te) ||
1267                 te.asType().equals(getObjectType())) {
1268             return null;
1269         }
1270         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1317                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1318                 break;
1319             }
1320             superType = supersuperType;
1321             superClass = supersuperClass;
1322         }
1323         if (te.asType().equals(superType)) {
1324             return null;
1325         }
1326         return superType;
1327     }
1328 
1329     /**
1330      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1331      *
1332      * @param te the TypeElement to check.
1333      * @param lowerCaseOnly true if you want the name returned in lower case.
1334      *                      If false, the first letter of the name is capitalized.
1335      * @return
1336      */
<span class="line-removed">1337 </span>
1338     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1339         String typeName = &quot;&quot;;
1340         if (isInterface(te)) {
1341             typeName = &quot;doclet.Interface&quot;;
1342         } else if (isException(te)) {
1343             typeName = &quot;doclet.Exception&quot;;
1344         } else if (isError(te)) {
1345             typeName = &quot;doclet.Error&quot;;
1346         } else if (isAnnotationType(te)) {
1347             typeName = &quot;doclet.AnnotationType&quot;;
1348         } else if (isEnum(te)) {
1349             typeName = &quot;doclet.Enum&quot;;
1350         } else if (isOrdinaryClass(te)) {
1351             typeName = &quot;doclet.Class&quot;;
1352         }
1353         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1354         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1355     }
1356 
1357     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1785     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1786         if (serialFieldTreeComparator == null) {
1787             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1788                 String s1 = o1.getName().toString();
1789                 String s2 = o2.getName().toString();
1790                 return s1.compareTo(s2);
1791             };
1792         }
1793         return serialFieldTreeComparator;
1794     }
1795 
1796     /**
1797      * Returns a general purpose comparator.
1798      * @return a Comparator
1799      */
1800     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1801         return makeClassUseComparator();
1802     }
1803 
1804     private Comparator&lt;Element&gt; overrideUseComparator = null;

1805     /**
1806      * Returns a Comparator for overrides and implements,
1807      * used primarily on methods, compares the name first,
1808      * then compares the simple names of the enclosing
1809      * TypeElement and the fully qualified name of the enclosing TypeElement.
1810      * @return a Comparator
1811      */
1812     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1813         if (overrideUseComparator == null) {
1814             overrideUseComparator = new Utils.ElementComparator() {
1815                 @Override
1816                 public int compare(Element o1, Element o2) {
1817                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1818                     if (result != 0) {
1819                         return result;
1820                     }
1821                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1822                         TypeElement t1 = getEnclosingTypeElement(o1);
1823                         TypeElement t2 = getEnclosingTypeElement(o2);
1824                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
</pre>
<hr />
<pre>
1994             }
1995 
1996             @Override
1997             public String visitPackage(PackageElement e, Void p) {
1998                 return e.getQualifiedName().toString();
1999             }
2000 
2001             @Override
2002             public String visitType(TypeElement e, Void p) {
2003                 return e.getQualifiedName().toString();
2004             }
2005 
2006             @Override
2007             protected String defaultAction(Element e, Void p) {
2008                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2009             }
2010         }.visit(e);
2011     }
2012 
2013     private Comparator&lt;Element&gt; classUseComparator = null;

2014     /**
2015      * Comparator for ClassUse presentations, and sorts as follows:
2016      * 1. member names
2017      * 2. then fully qualified member names
2018      * 3. then parameter types if applicable
2019      * 4. finally the element kinds ie. package, class, interface etc.
2020      * @return a comparator to sort classes and members for class use
2021      */
2022     public Comparator&lt;Element&gt; makeClassUseComparator() {
2023         if (classUseComparator == null) {
2024             classUseComparator = new Utils.ElementComparator() {
2025                 /**
2026                  * Compares two Elements.
2027                  *
2028                  * @param e1 - an element.
2029                  * @param e2 - an element.
2030                  * @return a negative integer, zero, or a positive integer as the first
2031                  * argument is less than, equal to, or greater than the second.
2032                  */
2033                 @Override
</pre>
<hr />
<pre>
2325     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2326         return convertToExecutableElement(getItems(e, true, METHOD));
2327     }
2328 
2329     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2330         return convertToExecutableElement(getItems(e, false, METHOD));
2331     }
2332 
2333     public int getOrdinalValue(VariableElement member) {
2334         if (member == null || member.getKind() != ENUM_CONSTANT) {
2335             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2336         }
2337         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2338     }
2339 
2340     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2341     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2342         if (modulePackageMap == null) {
2343             modulePackageMap = new HashMap&lt;&gt;();
2344             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2345             pkgs.forEach((pkg) -&gt; {</span>
2346                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2347                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2348             });
2349         }
2350         return modulePackageMap;
2351     }
2352 
2353     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2354         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2355         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2356         // get all the requires for the element in question
2357         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2358             ModuleElement dep = rd.getDependency();
2359             // add the dependency to work queue
2360             if (!result.containsKey(dep)) {
2361                 if (rd.isTransitive()) {
2362                     queue.addLast(dep);
2363                 }
2364             }
2365             // add all exports for the primary module
2366             result.put(rd.getDependency(), getModifiers(rd));
2367         }
2368 
2369         // add only requires public for subsequent module dependencies
2370         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2371             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2372                 ModuleElement dep = rd.getDependency();
2373                 if (!result.containsKey(dep)) {
2374                     if (rd.isTransitive()) {
2375                         result.put(dep, getModifiers(rd));
2376                         queue.addLast(dep);
2377                     }
2378                 }
2379             }
2380         }
2381         return result;
2382     }
2383 
2384     public String getModifiers(RequiresDirective rd) {
2385         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2386         String sep=&quot;&quot;;</span>
2387         if (rd.isTransitive()) {
2388             modifiers.append(&quot;transitive&quot;);
2389             sep = &quot; &quot;;
2390         }
2391         if (rd.isStatic()) {
2392             modifiers.append(sep);
2393             modifiers.append(&quot;static&quot;);
2394         }
2395         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2396     }
2397 
2398     public long getLineNumber(Element e) {
2399         TreePath path = getTreePath(e);
2400         if (path == null) { // maybe null if synthesized
2401             TypeElement encl = getEnclosingTypeElement(e);
2402             path = getTreePath(encl);
2403         }
2404         CompilationUnitTree cu = path.getCompilationUnit();
2405         LineMap lineMap = cu.getLineMap();
2406         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
3255     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3256         return getParamTrees(element, true);
3257     }
3258 
3259     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3260         return getParamTrees(element, false);
3261     }
3262 
3263     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3264         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3265         for (DocTree dt : getBlockTags(element, PARAM)) {
3266             ParamTree pt = (ParamTree) dt;
3267             if (pt.isTypeParameter() == isTypeParameters) {
3268                 out.add(pt);
3269             }
3270         }
3271         return out;
3272     }
3273 
3274     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3275         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3276         for (DocTree dt : getBlockTags(element, RETURN)) {</span>
<span class="line-removed">3277             out.add(dt);</span>
<span class="line-removed">3278         }</span>
<span class="line-removed">3279         return out;</span>
3280     }
3281 
3282     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3283         return getBlockTags(element, USES);
3284     }
3285 
3286     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3287         DocCommentTree dcTree = getDocCommentTree(element);
3288         if (dcTree == null) {
3289             return Collections.emptyList();
3290         }
<span class="line-modified">3291         List&lt;DocTree&gt; out = new ArrayList&lt;&gt;();</span>
<span class="line-removed">3292         for (DocTree dt : dcTree.getFirstSentence()) {</span>
<span class="line-removed">3293             out.add(dt);</span>
<span class="line-removed">3294         }</span>
<span class="line-removed">3295         return out;</span>
3296     }
3297 
3298     public ModuleElement containingModule(Element e) {
3299         return elementUtils.getModuleOf(e);
3300     }
3301 
3302     public PackageElement containingPackage(Element e) {
3303         return elementUtils.getPackageOf(e);
3304     }
3305 
3306     public TypeElement getTopMostContainingTypeElement(Element e) {
3307         if (isPackage(e)) {
3308             return null;
3309         }
3310         TypeElement outer = getEnclosingTypeElement(e);
3311         if (outer == null)
3312             return (TypeElement)e;
3313         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3314             outer = getEnclosingTypeElement(outer);
3315         }
</pre>
<hr />
<pre>
3344             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3345             return value == null ? null : value.get();
3346         }
3347 
3348         public CommentHelper computeIfAbsent(Element key) {
3349             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3350             if (refValue != null) {
3351                 CommentHelper value = refValue.get();
3352                 if (value != null) {
3353                     return value;
3354                 }
3355             }
3356             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3357                     utils.getDocCommentTree(key));
3358             map.put(key, new SoftReference&lt;&gt;(newValue));
3359             return newValue;
3360         }
3361     }
3362 
3363     /**
<span class="line-modified">3364      * A simple pair container.</span>
<span class="line-modified">3365      * @param &lt;K&gt; first a value</span>
<span class="line-modified">3366      * @param &lt;L&gt; second another value</span>

3367      */
3368     public static class Pair&lt;K, L&gt; {
3369         public final K first;
3370         public final L second;
3371 
3372         public Pair(K first, L second) {
3373             this.first = first;
3374             this.second = second;
3375         }
3376 
3377         @Override
3378         public String toString() {
<span class="line-modified">3379             StringBuffer out = new StringBuffer();</span>
<span class="line-removed">3380             out.append(first + &quot;:&quot; + second);</span>
<span class="line-removed">3381             return out.toString();</span>
3382         }
3383     }
3384 }
</pre>
</td>
<td>
<hr />
<pre>
 197     }
 198 
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
<span class="line-modified"> 217         return members.stream()</span>
<span class="line-modified"> 218                       .filter(member -&gt; !isDeprecated(member))</span>
<span class="line-modified"> 219                       .sorted(makeGeneralPurposeComparator())</span>
<span class="line-modified"> 220                       .collect(Collectors.toCollection(ArrayList::new));</span>

 221     }
 222 
 223     /**
 224      * Search for the given method in the given class.
 225      *
 226      * @param  te        Class to search into.
 227      * @param  method    Method to be searched.
 228      * @return ExecutableElement Method found, null otherwise.
 229      */
 230     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 231         for (Element m : getMethods(te)) {
<span class="line-modified"> 232             if (executableMembersEqual(method, (ExecutableElement) m)) {</span>
<span class="line-modified"> 233                 return (ExecutableElement) m;</span>
 234             }
 235         }
 236         return null;
 237     }
 238 
 239     /**
 240      * Test whether a class is a subclass of another class.
 241      *
 242      * @param t1 the candidate superclass.
 243      * @param t2 the target
 244      * @return true if t1 is a superclass of t2.
 245      */
 246     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 247         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 248     }
 249 
 250     /**
 251      * @param e1 the first method to compare.
 252      * @param e2 the second method to compare.
 253      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 254      */

 255     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 256         // TODO: investigate if Elements.hides(..) will work here.
 257         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 258             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 259             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 260             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 261                     parameters1.size() == parameters2.size()) {
 262                 int j;
 263                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 264                     VariableElement v1 = parameters1.get(j);
 265                     VariableElement v2 = parameters2.get(j);
 266                     String t1 = getTypeName(v1.asType(), true);
 267                     String t2 = getTypeName(v2.asType(), true);
 268                     if (!(t1.equals(t2) ||
 269                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 270                         break;
 271                     }
 272                 }
 273                 if (j == parameters1.size()) {
<span class="line-modified"> 274                     return true;</span>
 275                 }
 276             }
 277             return false;
 278         } else {
 279             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 280                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 281                     e1.equals(e2);
 282         }
 283     }
 284 
 285     /**
 286      * According to
 287      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 288      * all the outer classes and static inner classes are core classes.
 289      */
 290     public boolean isCoreClass(TypeElement e) {
 291         return getEnclosingTypeElement(e) == null || isStatic(e);
 292     }
 293 
 294     public Location getLocationForPackage(PackageElement pd) {
</pre>
<hr />
<pre>
 489         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 490             final StringBuilder sb = new StringBuilder();
 491 
 492             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 493                 if (modifiers.contains(PUBLIC)) {
 494                     append(&quot;public&quot;);
 495                 } else if (modifiers.contains(PROTECTED)) {
 496                     append(&quot;protected&quot;);
 497                 } else if (modifiers.contains(PRIVATE)) {
 498                     append(&quot;private&quot;);
 499                 }
 500             }
 501 
 502             void addStatic(Set&lt;Modifier&gt; modifiers) {
 503                 if (modifiers.contains(STATIC)) {
 504                     append(&quot;static&quot;);
 505                 }
 506             }
 507 
 508             void addModifiers(Set&lt;Modifier&gt; modifiers) {
<span class="line-modified"> 509                 modifiers.stream().map(Modifier::toString).forEachOrdered(this::append);</span>
 510             }
 511 
 512             void append(String s) {
 513                 if (sb.length() &gt; 0) {
 514                     sb.append(&quot; &quot;);
 515                 }
 516                 sb.append(s);
 517             }
 518 
 519             String finalString(String s) {
 520                 append(s);
 521                 if (trailingSpace) {
 522                     sb.append(&quot; &quot;);
<span class="line-modified"> 523                 }</span>
 524                 return sb.toString();
 525             }
 526 
 527             @Override
 528             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 529                 addVisibilityModifier(mods);
 530                 addStatic(mods);
 531                 return finalString(&quot;interface&quot;);
 532             }
 533 
 534             @Override
 535             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 536                 addVisibilityModifier(mods);
 537                 addStatic(mods);
 538                 return finalString(&quot;enum&quot;);
 539             }
 540 
 541             @Override
 542             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 543                 addVisibilityModifier(mods);
</pre>
<hr />
<pre>
 646               case LOCAL_VARIABLE: case PARAMETER:
 647               case RESOURCE_VARIABLE:
 648                   return true;
 649               default:
 650                   return false;
 651         }
 652     }
 653 
 654     public boolean isTypeElement(Element e) {
 655         switch (e.getKind()) {
 656             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 657                 return true;
 658             default:
 659                 return false;
 660         }
 661     }
 662 
 663     /**
 664      * Get the signature. It is the parameter list, type is qualified.
 665      * For instance, for a method {@code mymethod(String x, int y)},
<span class="line-modified"> 666      * it will return {@code (java.lang.String,int)}.</span>
 667      *
 668      * @param e
 669      * @return String
 670      */
 671     public String signature(ExecutableElement e) {
 672         return makeSignature(e, true);
 673     }
 674 
 675     /**
 676      * Get flat signature.  All types are not qualified.
 677      * Return a String, which is the flat signature of this member.
 678      * It is the parameter list, type is not qualified.
 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
 681      */
 682     public String flatSignature(ExecutableElement e) {
 683         return makeSignature(e, false);
 684     }
 685 
 686     public String makeSignature(ExecutableElement e, boolean full) {
</pre>
<hr />
<pre>
 910             TypeElement te = asTypeElement(t);
 911             if (te == null) {
 912                 return null;
 913             }
 914             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 915             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 916                 ExecutableElement ee = (ExecutableElement)e;
 917                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 918                         !isSimpleOverride(ee)) {
 919                     return ee;
 920                 }
 921             }
 922             if (t.equals(getObjectType()))
 923                 return null;
 924         }
 925         return null;
 926     }
 927 
 928     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 929         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());
<span class="line-modified"> 930         typeElements.forEach(set::add);</span>


 931         return set;
 932     }
 933 
 934     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 935         return getBlockTags(member, SERIAL_DATA);
 936     }
 937 
 938     public FileObject getFileObject(TypeElement te) {
 939         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 940     }
 941 
 942     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 943         return getDeclaredType(Collections.emptyList(), enclosing, target);
 944     }
 945 
 946     /**
 947      * Finds the declaration of the enclosing&#39;s type parameter.
 948      *
 949      * @param values
 950      * @param enclosing a TypeElement whose type arguments  we desire
</pre>
<hr />
<pre>
1226             }
1227         }.visit(t);
1228     }
1229 
1230     public TypeMirror getComponentType(TypeMirror t) {
1231         while (isArrayType(t)) {
1232             t = ((ArrayType) t).getComponentType();
1233         }
1234         return t;
1235     }
1236 
1237     /**
1238      * Return the type&#39;s dimension information, as a string.
1239      * &lt;p&gt;
1240      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1241      *
1242      * @return the type&#39;s dimension information as a string.
1243      */
1244     public String getDimension(TypeMirror t) {
1245         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
<span class="line-modified">1246             StringBuilder dimension = new StringBuilder();</span>
1247             @Override
1248             public String visitArray(ArrayType t, Void p) {
1249                 dimension.append(&quot;[]&quot;);
1250                 return visit(t.getComponentType());
1251             }
1252 
1253             @Override
1254             protected String defaultAction(TypeMirror e, Void p) {
1255                 return dimension.toString();
1256             }
1257 
1258         }.visit(t);
1259     }
1260 
1261     public TypeElement getSuperClass(TypeElement te) {
1262         if (isInterface(te) || isAnnotationType(te) ||
1263                 te.asType().equals(getObjectType())) {
1264             return null;
1265         }
1266         TypeMirror superclass = te.getSuperclass();
</pre>
<hr />
<pre>
1313                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1314                 break;
1315             }
1316             superType = supersuperType;
1317             superClass = supersuperClass;
1318         }
1319         if (te.asType().equals(superType)) {
1320             return null;
1321         }
1322         return superType;
1323     }
1324 
1325     /**
1326      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1327      *
1328      * @param te the TypeElement to check.
1329      * @param lowerCaseOnly true if you want the name returned in lower case.
1330      *                      If false, the first letter of the name is capitalized.
1331      * @return
1332      */

1333     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1334         String typeName = &quot;&quot;;
1335         if (isInterface(te)) {
1336             typeName = &quot;doclet.Interface&quot;;
1337         } else if (isException(te)) {
1338             typeName = &quot;doclet.Exception&quot;;
1339         } else if (isError(te)) {
1340             typeName = &quot;doclet.Error&quot;;
1341         } else if (isAnnotationType(te)) {
1342             typeName = &quot;doclet.AnnotationType&quot;;
1343         } else if (isEnum(te)) {
1344             typeName = &quot;doclet.Enum&quot;;
1345         } else if (isOrdinaryClass(te)) {
1346             typeName = &quot;doclet.Class&quot;;
1347         }
1348         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1349         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1350     }
1351 
1352     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
1780     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {
1781         if (serialFieldTreeComparator == null) {
1782             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {
1783                 String s1 = o1.getName().toString();
1784                 String s2 = o2.getName().toString();
1785                 return s1.compareTo(s2);
1786             };
1787         }
1788         return serialFieldTreeComparator;
1789     }
1790 
1791     /**
1792      * Returns a general purpose comparator.
1793      * @return a Comparator
1794      */
1795     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {
1796         return makeClassUseComparator();
1797     }
1798 
1799     private Comparator&lt;Element&gt; overrideUseComparator = null;
<span class="line-added">1800 </span>
1801     /**
1802      * Returns a Comparator for overrides and implements,
1803      * used primarily on methods, compares the name first,
1804      * then compares the simple names of the enclosing
1805      * TypeElement and the fully qualified name of the enclosing TypeElement.
1806      * @return a Comparator
1807      */
1808     public Comparator&lt;Element&gt; makeOverrideUseComparator() {
1809         if (overrideUseComparator == null) {
1810             overrideUseComparator = new Utils.ElementComparator() {
1811                 @Override
1812                 public int compare(Element o1, Element o2) {
1813                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));
1814                     if (result != 0) {
1815                         return result;
1816                     }
1817                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {
1818                         TypeElement t1 = getEnclosingTypeElement(o1);
1819                         TypeElement t2 = getEnclosingTypeElement(o2);
1820                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));
</pre>
<hr />
<pre>
1990             }
1991 
1992             @Override
1993             public String visitPackage(PackageElement e, Void p) {
1994                 return e.getQualifiedName().toString();
1995             }
1996 
1997             @Override
1998             public String visitType(TypeElement e, Void p) {
1999                 return e.getQualifiedName().toString();
2000             }
2001 
2002             @Override
2003             protected String defaultAction(Element e, Void p) {
2004                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2005             }
2006         }.visit(e);
2007     }
2008 
2009     private Comparator&lt;Element&gt; classUseComparator = null;
<span class="line-added">2010 </span>
2011     /**
2012      * Comparator for ClassUse presentations, and sorts as follows:
2013      * 1. member names
2014      * 2. then fully qualified member names
2015      * 3. then parameter types if applicable
2016      * 4. finally the element kinds ie. package, class, interface etc.
2017      * @return a comparator to sort classes and members for class use
2018      */
2019     public Comparator&lt;Element&gt; makeClassUseComparator() {
2020         if (classUseComparator == null) {
2021             classUseComparator = new Utils.ElementComparator() {
2022                 /**
2023                  * Compares two Elements.
2024                  *
2025                  * @param e1 - an element.
2026                  * @param e2 - an element.
2027                  * @return a negative integer, zero, or a positive integer as the first
2028                  * argument is less than, equal to, or greater than the second.
2029                  */
2030                 @Override
</pre>
<hr />
<pre>
2322     public List&lt;ExecutableElement&gt; getMethods(Element e) {
2323         return convertToExecutableElement(getItems(e, true, METHOD));
2324     }
2325 
2326     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
2327         return convertToExecutableElement(getItems(e, false, METHOD));
2328     }
2329 
2330     public int getOrdinalValue(VariableElement member) {
2331         if (member == null || member.getKind() != ENUM_CONSTANT) {
2332             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2333         }
2334         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2335     }
2336 
2337     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2338     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2339         if (modulePackageMap == null) {
2340             modulePackageMap = new HashMap&lt;&gt;();
2341             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
<span class="line-modified">2342             pkgs.forEach(pkg -&gt; {</span>
2343                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2344                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2345             });
2346         }
2347         return modulePackageMap;
2348     }
2349 
2350     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
2351         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());
2352         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2353         // get all the requires for the element in question
2354         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2355             ModuleElement dep = rd.getDependency();
2356             // add the dependency to work queue
2357             if (!result.containsKey(dep)) {
2358                 if (rd.isTransitive()) {
2359                     queue.addLast(dep);
2360                 }
2361             }
2362             // add all exports for the primary module
2363             result.put(rd.getDependency(), getModifiers(rd));
2364         }
2365 
2366         // add only requires public for subsequent module dependencies
2367         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2368             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2369                 ModuleElement dep = rd.getDependency();
2370                 if (!result.containsKey(dep)) {
2371                     if (rd.isTransitive()) {
2372                         result.put(dep, getModifiers(rd));
2373                         queue.addLast(dep);
2374                     }
2375                 }
2376             }
2377         }
2378         return result;
2379     }
2380 
2381     public String getModifiers(RequiresDirective rd) {
2382         StringBuilder modifiers = new StringBuilder();
<span class="line-modified">2383         String sep = &quot;&quot;;</span>
2384         if (rd.isTransitive()) {
2385             modifiers.append(&quot;transitive&quot;);
2386             sep = &quot; &quot;;
2387         }
2388         if (rd.isStatic()) {
2389             modifiers.append(sep);
2390             modifiers.append(&quot;static&quot;);
2391         }
2392         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
2393     }
2394 
2395     public long getLineNumber(Element e) {
2396         TreePath path = getTreePath(e);
2397         if (path == null) { // maybe null if synthesized
2398             TypeElement encl = getEnclosingTypeElement(e);
2399             path = getTreePath(encl);
2400         }
2401         CompilationUnitTree cu = path.getCompilationUnit();
2402         LineMap lineMap = cu.getLineMap();
2403         DocSourcePositions spos = docTrees.getSourcePositions();
</pre>
<hr />
<pre>
3252     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
3253         return getParamTrees(element, true);
3254     }
3255 
3256     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
3257         return getParamTrees(element, false);
3258     }
3259 
3260     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
3261         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
3262         for (DocTree dt : getBlockTags(element, PARAM)) {
3263             ParamTree pt = (ParamTree) dt;
3264             if (pt.isTypeParameter() == isTypeParameters) {
3265                 out.add(pt);
3266             }
3267         }
3268         return out;
3269     }
3270 
3271     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
<span class="line-modified">3272         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));</span>




3273     }
3274 
3275     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
3276         return getBlockTags(element, USES);
3277     }
3278 
3279     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
3280         DocCommentTree dcTree = getDocCommentTree(element);
3281         if (dcTree == null) {
3282             return Collections.emptyList();
3283         }
<span class="line-modified">3284         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());</span>




3285     }
3286 
3287     public ModuleElement containingModule(Element e) {
3288         return elementUtils.getModuleOf(e);
3289     }
3290 
3291     public PackageElement containingPackage(Element e) {
3292         return elementUtils.getPackageOf(e);
3293     }
3294 
3295     public TypeElement getTopMostContainingTypeElement(Element e) {
3296         if (isPackage(e)) {
3297             return null;
3298         }
3299         TypeElement outer = getEnclosingTypeElement(e);
3300         if (outer == null)
3301             return (TypeElement)e;
3302         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
3303             outer = getEnclosingTypeElement(outer);
3304         }
</pre>
<hr />
<pre>
3333             SoftReference&lt;CommentHelper&gt; value = map.get(key);
3334             return value == null ? null : value.get();
3335         }
3336 
3337         public CommentHelper computeIfAbsent(Element key) {
3338             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
3339             if (refValue != null) {
3340                 CommentHelper value = refValue.get();
3341                 if (value != null) {
3342                     return value;
3343                 }
3344             }
3345             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
3346                     utils.getDocCommentTree(key));
3347             map.put(key, new SoftReference&lt;&gt;(newValue));
3348             return newValue;
3349         }
3350     }
3351 
3352     /**
<span class="line-modified">3353      * A container holding a pair of values (tuple).</span>
<span class="line-modified">3354      *</span>
<span class="line-modified">3355      * @param &lt;K&gt; the type of the first value</span>
<span class="line-added">3356      * @param &lt;L&gt; the type of the second value</span>
3357      */
3358     public static class Pair&lt;K, L&gt; {
3359         public final K first;
3360         public final L second;
3361 
3362         public Pair(K first, L second) {
3363             this.first = first;
3364             this.second = second;
3365         }
3366 
3367         @Override
3368         public String toString() {
<span class="line-modified">3369             return first + &quot;:&quot; + second;</span>


3370         }
3371     }
3372 }
</pre>
</td>
</tr>
</table>
<center><a href="IndexBuilder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LinkFactoryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedFormWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
241     @Override
242     public Content getSummaryTree(Content summaryContentTree) {
243         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
244     }
245 
246     /**
247      * Compute the modules data that will be displayed in various tables on the module summary page.
248      */
249     public void computeModulesData() {
250         CommentHelper ch = utils.getCommentHelper(mdle);
251         // Get module dependencies using the module&#39;s transitive closure.
252         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
253         // Add all dependent modules to indirect modules set. We will remove the modules,
254         // listed using the requires directive, from this set to come up with the table of indirect
255         // required modules.
256         dependentModules.forEach((module, mod) -&gt; {
257             if (shouldDocument(module)) {
258                 indirectModules.put(module, new StringContent(mod));
259             }
260         });
<span class="line-modified">261         (ElementFilter.requiresIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
262             ModuleElement m = directive.getDependency();
263             if (shouldDocument(m)) {
264                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
265                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">266             } else {</span>
267                     // For api mode, just keep the public requires in dependentModules for display of
268                     // indirect packages in the &quot;Packages&quot; section.
269                     dependentModules.remove(m);
270                 }
271                 indirectModules.remove(m);
<span class="line-modified">272         }</span>
273         });
274 
275         // Get all packages if module is open or if displaying concealed modules
276         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
277             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
278                 PackageEntry e = new PackageEntry();
279                 if (mdle.isOpen()) {
280                     e.openedTo = Collections.emptySet();
281                 }
282                 packages.put(pkg, e);
283             }
284         }
285 
286         // Get all exported packages for the module, using the exports directive for the module.
287         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
288             PackageElement p = directive.getPackage();
289             if (shouldDocument(p)) {
290                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
291                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
292                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
</pre>
<hr />
<pre>
304         // If it is an open module, there will be no separate opens directives.
305         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
306             PackageElement p = directive.getPackage();
307             if (shouldDocument(p)) {
308                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
309                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
310                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
311                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
312                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
313                     if (targetMdles != null) {
314                         mdleList.addAll(targetMdles);
315                     }
316                     packageEntry.openedTo = mdleList;
317                 }
318             }
319         }
320 
321         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
322         // the indirect packages tables.
323         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">324             SortedSet&lt;PackageElement&gt; exportPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">325             (ElementFilter.exportsIn(module.getDirectives())).forEach((directive) -&gt; {</span>
326                 PackageElement pkg = directive.getPackage();
327                 if (shouldDocument(pkg)) {
328                     // Qualified exports are not displayed in API mode
329                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">330                         exportPkgList.add(pkg);</span>
331                     }
332                 }
333             });
334             // If none of the indirect modules have exported packages to be displayed, we should not be
335             // displaying the table and so it should not be added to the map.
<span class="line-modified">336             if (!exportPkgList.isEmpty()) {</span>
<span class="line-modified">337                 indirectPackages.put(module, exportPkgList);</span>
338             }
<span class="line-modified">339             SortedSet&lt;PackageElement&gt; openPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
340             if (module.isOpen()) {
<span class="line-modified">341                 openPkgList.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
342             } else {
<span class="line-modified">343                 (ElementFilter.opensIn(module.getDirectives())).forEach((directive) -&gt; {</span>
344                     PackageElement pkg = directive.getPackage();
345                     if (shouldDocument(pkg)) {
346                         // Qualified opens are not displayed in API mode
347                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">348                             openPkgList.add(pkg);</span>
349                         }
350                     }
351                 });
352             }
353             // If none of the indirect modules have opened packages to be displayed, we should not be
354             // displaying the table and so it should not be added to the map.
<span class="line-modified">355             if (!openPkgList.isEmpty()) {</span>
<span class="line-modified">356                 indirectOpenPackages.put(module, openPkgList);</span>
357             }
358         });
359         // Get all the services listed as uses directive.
<span class="line-modified">360         (ElementFilter.usesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
361             TypeElement u = directive.getService();
362             if (shouldDocument(u)) {
363                 uses.add(u);
364             }
365         });
366         // Get all the services and implementations listed as provides directive.
<span class="line-modified">367         (ElementFilter.providesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
368             TypeElement u = directive.getService();
369             if (shouldDocument(u)) {
370                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
371                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
372                 implSet.addAll(implList);
373                 provides.put(u, implSet);
374             }
375         });
376         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">377         (utils.getBlockTags(mdle, DocTree.Kind.PROVIDES)).forEach((tree) -&gt; {</span>
378             TypeElement t = ch.getServiceType(tree);
379             if (t != null) {
380                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
381             }
382         });
383         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">384         (utils.getBlockTags(mdle, DocTree.Kind.USES)).forEach((tree) -&gt; {</span>
385             TypeElement t = ch.getServiceType(tree);
386             if (t != null) {
387                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
388             }
389         });
390     }
391 
392     /**
393      * Returns true if the element should be documented on the module summary page.
394      *
395      * @param element the element to be checked
396      * @return true if the element should be documented
397      */
398     public boolean shouldDocument(Element element) {
399         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
400     }
401 
402     /**
403      * Returns true if there are elements to be displayed.
404      *
</pre>
<hr />
<pre>
409         return section != null &amp;&amp; !section.isEmpty();
410     }
411 
412     /**
413      * Returns true if there are elements to be displayed.
414      *
415      * @param section map of elements.
416      * @return true if there are elements to be displayed
417      */
418     public boolean display(Map&lt;? extends Element, ?&gt; section) {
419         return section != null &amp;&amp; !section.isEmpty();
420     }
421 
422     /*
423      * Returns true, in API mode, if at least one type element in
424      * the typeElements set is referenced by a javadoc tag in tagsMap.
425      */
426     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
427                                     Map&lt;TypeElement, Content&gt; tagsMap) {
428         return typeElements != null &amp;&amp;
<span class="line-modified">429                 typeElements.stream().anyMatch((v) -&gt; displayServiceDirective(v, tagsMap));</span>
430     }
431 
432     /*
433      * Returns true, in API mode, if the type element is referenced
434      * from a javadoc tag in tagsMap.
435      */
436     private boolean displayServiceDirective(TypeElement typeElement,
437                                             Map&lt;TypeElement, Content&gt; tagsMap) {
438         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
439     }
440 
441     /**
442      * Add the summary header.
443      *
444      * @param startMarker the marker comment
445      * @param heading the heading for the section
446      * @param htmltree the content tree to which the information is added
447      */
448     public void addSummaryHeader(Content startMarker, Content heading,
449             Content htmltree) {
</pre>
</td>
<td>
<hr />
<pre>
241     @Override
242     public Content getSummaryTree(Content summaryContentTree) {
243         return HtmlTree.SECTION(HtmlStyle.summary, summaryContentTree);
244     }
245 
246     /**
247      * Compute the modules data that will be displayed in various tables on the module summary page.
248      */
249     public void computeModulesData() {
250         CommentHelper ch = utils.getCommentHelper(mdle);
251         // Get module dependencies using the module&#39;s transitive closure.
252         Map&lt;ModuleElement, String&gt; dependentModules = utils.getDependentModules(mdle);
253         // Add all dependent modules to indirect modules set. We will remove the modules,
254         // listed using the requires directive, from this set to come up with the table of indirect
255         // required modules.
256         dependentModules.forEach((module, mod) -&gt; {
257             if (shouldDocument(module)) {
258                 indirectModules.put(module, new StringContent(mod));
259             }
260         });
<span class="line-modified">261         ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
262             ModuleElement m = directive.getDependency();
263             if (shouldDocument(m)) {
264                 if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
265                     requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">266                 } else {</span>
267                     // For api mode, just keep the public requires in dependentModules for display of
268                     // indirect packages in the &quot;Packages&quot; section.
269                     dependentModules.remove(m);
270                 }
271                 indirectModules.remove(m);
<span class="line-modified">272             }</span>
273         });
274 
275         // Get all packages if module is open or if displaying concealed modules
276         for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
277             if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
278                 PackageEntry e = new PackageEntry();
279                 if (mdle.isOpen()) {
280                     e.openedTo = Collections.emptySet();
281                 }
282                 packages.put(pkg, e);
283             }
284         }
285 
286         // Get all exported packages for the module, using the exports directive for the module.
287         for (ModuleElement.ExportsDirective directive : ElementFilter.exportsIn(mdle.getDirectives())) {
288             PackageElement p = directive.getPackage();
289             if (shouldDocument(p)) {
290                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
291                 // Include package if in details mode, or exported to all (i.e. targetModules == null)
292                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
</pre>
<hr />
<pre>
304         // If it is an open module, there will be no separate opens directives.
305         for (ModuleElement.OpensDirective directive : ElementFilter.opensIn(mdle.getDirectives())) {
306             PackageElement p = directive.getPackage();
307             if (shouldDocument(p)) {
308                 List&lt;? extends ModuleElement&gt; targetMdles = directive.getTargetModules();
309                 // Include package if in details mode, or opened to all (i.e. targetModules == null)
310                 if (moduleMode == ModuleMode.ALL || targetMdles == null) {
311                     PackageEntry packageEntry = packages.computeIfAbsent(p, pkg -&gt; new PackageEntry());
312                     SortedSet&lt;ModuleElement&gt; mdleList = new TreeSet&lt;&gt;(utils.makeModuleComparator());
313                     if (targetMdles != null) {
314                         mdleList.addAll(targetMdles);
315                     }
316                     packageEntry.openedTo = mdleList;
317                 }
318             }
319         }
320 
321         // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
322         // the indirect packages tables.
323         dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">324             SortedSet&lt;PackageElement&gt; exportedPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">325             ElementFilter.exportsIn(module.getDirectives()).forEach(directive -&gt; {</span>
326                 PackageElement pkg = directive.getPackage();
327                 if (shouldDocument(pkg)) {
328                     // Qualified exports are not displayed in API mode
329                     if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">330                         exportedPackages.add(pkg);</span>
331                     }
332                 }
333             });
334             // If none of the indirect modules have exported packages to be displayed, we should not be
335             // displaying the table and so it should not be added to the map.
<span class="line-modified">336             if (!exportedPackages.isEmpty()) {</span>
<span class="line-modified">337                 indirectPackages.put(module, exportedPackages);</span>
338             }
<span class="line-modified">339             SortedSet&lt;PackageElement&gt; openPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
340             if (module.isOpen()) {
<span class="line-modified">341                 openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
342             } else {
<span class="line-modified">343                 ElementFilter.opensIn(module.getDirectives()).forEach(directive -&gt; {</span>
344                     PackageElement pkg = directive.getPackage();
345                     if (shouldDocument(pkg)) {
346                         // Qualified opens are not displayed in API mode
347                         if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">348                             openPackages.add(pkg);</span>
349                         }
350                     }
351                 });
352             }
353             // If none of the indirect modules have opened packages to be displayed, we should not be
354             // displaying the table and so it should not be added to the map.
<span class="line-modified">355             if (!openPackages.isEmpty()) {</span>
<span class="line-modified">356                 indirectOpenPackages.put(module, openPackages);</span>
357             }
358         });
359         // Get all the services listed as uses directive.
<span class="line-modified">360         ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
361             TypeElement u = directive.getService();
362             if (shouldDocument(u)) {
363                 uses.add(u);
364             }
365         });
366         // Get all the services and implementations listed as provides directive.
<span class="line-modified">367         ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
368             TypeElement u = directive.getService();
369             if (shouldDocument(u)) {
370                 List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
371                 SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
372                 implSet.addAll(implList);
373                 provides.put(u, implSet);
374             }
375         });
376         // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">377         utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -&gt; {</span>
378             TypeElement t = ch.getServiceType(tree);
379             if (t != null) {
380                 providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
381             }
382         });
383         // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">384         utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -&gt; {</span>
385             TypeElement t = ch.getServiceType(tree);
386             if (t != null) {
387                 usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
388             }
389         });
390     }
391 
392     /**
393      * Returns true if the element should be documented on the module summary page.
394      *
395      * @param element the element to be checked
396      * @return true if the element should be documented
397      */
398     public boolean shouldDocument(Element element) {
399         return (moduleMode == ModuleMode.ALL || utils.isIncluded(element));
400     }
401 
402     /**
403      * Returns true if there are elements to be displayed.
404      *
</pre>
<hr />
<pre>
409         return section != null &amp;&amp; !section.isEmpty();
410     }
411 
412     /**
413      * Returns true if there are elements to be displayed.
414      *
415      * @param section map of elements.
416      * @return true if there are elements to be displayed
417      */
418     public boolean display(Map&lt;? extends Element, ?&gt; section) {
419         return section != null &amp;&amp; !section.isEmpty();
420     }
421 
422     /*
423      * Returns true, in API mode, if at least one type element in
424      * the typeElements set is referenced by a javadoc tag in tagsMap.
425      */
426     private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
427                                     Map&lt;TypeElement, Content&gt; tagsMap) {
428         return typeElements != null &amp;&amp;
<span class="line-modified">429                 typeElements.stream().anyMatch(v -&gt; displayServiceDirective(v, tagsMap));</span>
430     }
431 
432     /*
433      * Returns true, in API mode, if the type element is referenced
434      * from a javadoc tag in tagsMap.
435      */
436     private boolean displayServiceDirective(TypeElement typeElement,
437                                             Map&lt;TypeElement, Content&gt; tagsMap) {
438         return moduleMode == ModuleMode.ALL || tagsMap.containsKey(typeElement);
439     }
440 
441     /**
442      * Add the summary header.
443      *
444      * @param startMarker the marker comment
445      * @param heading the heading for the section
446      * @param htmltree the content tree to which the information is added
447      */
448     public void addSummaryHeader(Content startMarker, Content heading,
449             Content htmltree) {
</pre>
</td>
</tr>
</table>
<center><a href="LinkFactoryImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedFormWriterImpl.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
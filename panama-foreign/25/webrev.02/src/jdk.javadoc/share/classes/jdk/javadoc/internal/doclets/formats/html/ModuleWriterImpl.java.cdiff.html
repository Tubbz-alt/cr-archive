<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LinkFactoryImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedFormWriterImpl.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/ModuleWriterImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 256,22 ***</span>
          dependentModules.forEach((module, mod) -&gt; {
              if (shouldDocument(module)) {
                  indirectModules.put(module, new StringContent(mod));
              }
          });
<span class="line-modified">!         (ElementFilter.requiresIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
              ModuleElement m = directive.getDependency();
              if (shouldDocument(m)) {
                  if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
                      requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">!             } else {</span>
                      // For api mode, just keep the public requires in dependentModules for display of
                      // indirect packages in the &quot;Packages&quot; section.
                      dependentModules.remove(m);
                  }
                  indirectModules.remove(m);
<span class="line-modified">!         }</span>
          });
  
          // Get all packages if module is open or if displaying concealed modules
          for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
              if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
<span class="line-new-header">--- 256,22 ---</span>
          dependentModules.forEach((module, mod) -&gt; {
              if (shouldDocument(module)) {
                  indirectModules.put(module, new StringContent(mod));
              }
          });
<span class="line-modified">!         ElementFilter.requiresIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
              ModuleElement m = directive.getDependency();
              if (shouldDocument(m)) {
                  if (moduleMode == ModuleMode.ALL || directive.isTransitive()) {
                      requires.put(m, new StringContent(utils.getModifiers(directive)));
<span class="line-modified">!                 } else {</span>
                      // For api mode, just keep the public requires in dependentModules for display of
                      // indirect packages in the &quot;Packages&quot; section.
                      dependentModules.remove(m);
                  }
                  indirectModules.remove(m);
<span class="line-modified">!             }</span>
          });
  
          // Get all packages if module is open or if displaying concealed modules
          for (PackageElement pkg : utils.getModulePackageMap().getOrDefault(mdle, Collections.emptySet())) {
              if (shouldDocument(pkg) &amp;&amp; (mdle.isOpen() || moduleMode == ModuleMode.ALL)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,71 ***</span>
          }
  
          // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
          // the indirect packages tables.
          dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">!             SortedSet&lt;PackageElement&gt; exportPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">!             (ElementFilter.exportsIn(module.getDirectives())).forEach((directive) -&gt; {</span>
                  PackageElement pkg = directive.getPackage();
                  if (shouldDocument(pkg)) {
                      // Qualified exports are not displayed in API mode
                      if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">!                         exportPkgList.add(pkg);</span>
                      }
                  }
              });
              // If none of the indirect modules have exported packages to be displayed, we should not be
              // displaying the table and so it should not be added to the map.
<span class="line-modified">!             if (!exportPkgList.isEmpty()) {</span>
<span class="line-modified">!                 indirectPackages.put(module, exportPkgList);</span>
              }
<span class="line-modified">!             SortedSet&lt;PackageElement&gt; openPkgList = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
              if (module.isOpen()) {
<span class="line-modified">!                 openPkgList.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
              } else {
<span class="line-modified">!                 (ElementFilter.opensIn(module.getDirectives())).forEach((directive) -&gt; {</span>
                      PackageElement pkg = directive.getPackage();
                      if (shouldDocument(pkg)) {
                          // Qualified opens are not displayed in API mode
                          if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">!                             openPkgList.add(pkg);</span>
                          }
                      }
                  });
              }
              // If none of the indirect modules have opened packages to be displayed, we should not be
              // displaying the table and so it should not be added to the map.
<span class="line-modified">!             if (!openPkgList.isEmpty()) {</span>
<span class="line-modified">!                 indirectOpenPackages.put(module, openPkgList);</span>
              }
          });
          // Get all the services listed as uses directive.
<span class="line-modified">!         (ElementFilter.usesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
              TypeElement u = directive.getService();
              if (shouldDocument(u)) {
                  uses.add(u);
              }
          });
          // Get all the services and implementations listed as provides directive.
<span class="line-modified">!         (ElementFilter.providesIn(mdle.getDirectives())).forEach((directive) -&gt; {</span>
              TypeElement u = directive.getService();
              if (shouldDocument(u)) {
                  List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
                  SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
                  implSet.addAll(implList);
                  provides.put(u, implSet);
              }
          });
          // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">!         (utils.getBlockTags(mdle, DocTree.Kind.PROVIDES)).forEach((tree) -&gt; {</span>
              TypeElement t = ch.getServiceType(tree);
              if (t != null) {
                  providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
              }
          });
          // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">!         (utils.getBlockTags(mdle, DocTree.Kind.USES)).forEach((tree) -&gt; {</span>
              TypeElement t = ch.getServiceType(tree);
              if (t != null) {
                  usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
              }
          });
<span class="line-new-header">--- 319,71 ---</span>
          }
  
          // Get all the exported and opened packages, for the transitive closure of the module, to be displayed in
          // the indirect packages tables.
          dependentModules.forEach((module, mod) -&gt; {
<span class="line-modified">!             SortedSet&lt;PackageElement&gt; exportedPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
<span class="line-modified">!             ElementFilter.exportsIn(module.getDirectives()).forEach(directive -&gt; {</span>
                  PackageElement pkg = directive.getPackage();
                  if (shouldDocument(pkg)) {
                      // Qualified exports are not displayed in API mode
                      if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">!                         exportedPackages.add(pkg);</span>
                      }
                  }
              });
              // If none of the indirect modules have exported packages to be displayed, we should not be
              // displaying the table and so it should not be added to the map.
<span class="line-modified">!             if (!exportedPackages.isEmpty()) {</span>
<span class="line-modified">!                 indirectPackages.put(module, exportedPackages);</span>
              }
<span class="line-modified">!             SortedSet&lt;PackageElement&gt; openPackages = new TreeSet&lt;&gt;(utils.makePackageComparator());</span>
              if (module.isOpen()) {
<span class="line-modified">!                 openPackages.addAll(utils.getModulePackageMap().getOrDefault(module, Collections.emptySet()));</span>
              } else {
<span class="line-modified">!                 ElementFilter.opensIn(module.getDirectives()).forEach(directive -&gt; {</span>
                      PackageElement pkg = directive.getPackage();
                      if (shouldDocument(pkg)) {
                          // Qualified opens are not displayed in API mode
                          if (moduleMode == ModuleMode.ALL || directive.getTargetModules() == null) {
<span class="line-modified">!                             openPackages.add(pkg);</span>
                          }
                      }
                  });
              }
              // If none of the indirect modules have opened packages to be displayed, we should not be
              // displaying the table and so it should not be added to the map.
<span class="line-modified">!             if (!openPackages.isEmpty()) {</span>
<span class="line-modified">!                 indirectOpenPackages.put(module, openPackages);</span>
              }
          });
          // Get all the services listed as uses directive.
<span class="line-modified">!         ElementFilter.usesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
              TypeElement u = directive.getService();
              if (shouldDocument(u)) {
                  uses.add(u);
              }
          });
          // Get all the services and implementations listed as provides directive.
<span class="line-modified">!         ElementFilter.providesIn(mdle.getDirectives()).forEach(directive -&gt; {</span>
              TypeElement u = directive.getService();
              if (shouldDocument(u)) {
                  List&lt;? extends TypeElement&gt; implList = directive.getImplementations();
                  SortedSet&lt;TypeElement&gt; implSet = new TreeSet&lt;&gt;(utils.makeAllClassesComparator());
                  implSet.addAll(implList);
                  provides.put(u, implSet);
              }
          });
          // Generate the map of all services listed using @provides, and the description.
<span class="line-modified">!         utils.getBlockTags(mdle, DocTree.Kind.PROVIDES).forEach(tree -&gt; {</span>
              TypeElement t = ch.getServiceType(tree);
              if (t != null) {
                  providesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
              }
          });
          // Generate the map of all services listed using @uses, and the description.
<span class="line-modified">!         utils.getBlockTags(mdle, DocTree.Kind.USES).forEach(tree -&gt; {</span>
              TypeElement t = ch.getServiceType(tree);
              if (t != null) {
                  usesTrees.put(t, commentTagsToContent(tree, mdle, ch.getDescription(tree), false, true));
              }
          });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,11 ***</span>
       * the typeElements set is referenced by a javadoc tag in tagsMap.
       */
      private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
                                      Map&lt;TypeElement, Content&gt; tagsMap) {
          return typeElements != null &amp;&amp;
<span class="line-modified">!                 typeElements.stream().anyMatch((v) -&gt; displayServiceDirective(v, tagsMap));</span>
      }
  
      /*
       * Returns true, in API mode, if the type element is referenced
       * from a javadoc tag in tagsMap.
<span class="line-new-header">--- 424,11 ---</span>
       * the typeElements set is referenced by a javadoc tag in tagsMap.
       */
      private boolean displayServices(Set&lt;TypeElement&gt; typeElements,
                                      Map&lt;TypeElement, Content&gt; tagsMap) {
          return typeElements != null &amp;&amp;
<span class="line-modified">!                 typeElements.stream().anyMatch(v -&gt; displayServiceDirective(v, tagsMap));</span>
      }
  
      /*
       * Returns true, in API mode, if the type element is referenced
       * from a javadoc tag in tagsMap.
</pre>
<center><a href="LinkFactoryImpl.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SerializedFormWriterImpl.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
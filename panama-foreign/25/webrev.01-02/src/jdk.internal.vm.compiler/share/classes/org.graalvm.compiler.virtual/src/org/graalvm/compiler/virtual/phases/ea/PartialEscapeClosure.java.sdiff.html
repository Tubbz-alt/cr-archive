<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PEReadEliminationClosure.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapePhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.virtual/src/org/graalvm/compiler/virtual/phases/ea/PartialEscapeClosure.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  51 import org.graalvm.compiler.nodes.FixedNode;
  52 import org.graalvm.compiler.nodes.FixedWithNextNode;
  53 import org.graalvm.compiler.nodes.FrameState;
  54 import org.graalvm.compiler.nodes.Invoke;
  55 import org.graalvm.compiler.nodes.LoopBeginNode;
  56 import org.graalvm.compiler.nodes.LoopExitNode;
  57 import org.graalvm.compiler.nodes.NodeView;
  58 import org.graalvm.compiler.nodes.PhiNode;
  59 import org.graalvm.compiler.nodes.ProxyNode;
  60 import org.graalvm.compiler.nodes.StructuredGraph;
  61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  62 import org.graalvm.compiler.nodes.UnwindNode;
  63 import org.graalvm.compiler.nodes.ValueNode;
  64 import org.graalvm.compiler.nodes.ValuePhiNode;
  65 import org.graalvm.compiler.nodes.ValueProxyNode;
  66 import org.graalvm.compiler.nodes.VirtualState;
  67 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
  68 import org.graalvm.compiler.nodes.cfg.Block;
  69 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  70 import org.graalvm.compiler.nodes.spi.NodeWithState;

  71 import org.graalvm.compiler.nodes.spi.Virtualizable;
  72 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  73 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  74 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  75 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  76 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  77 
  78 import jdk.vm.ci.meta.ConstantReflectionProvider;
  79 import jdk.vm.ci.meta.JavaConstant;
  80 import jdk.vm.ci.meta.JavaKind;
  81 import jdk.vm.ci.meta.MetaAccessProvider;
  82 
  83 public abstract class PartialEscapeClosure&lt;BlockT extends PartialEscapeBlockState&lt;BlockT&gt;&gt; extends EffectsClosure&lt;BlockT&gt; {
  84 
  85     public static final CounterKey COUNTER_MATERIALIZATIONS = DebugContext.counter(&quot;Materializations&quot;);
  86     public static final CounterKey COUNTER_MATERIALIZATIONS_PHI = DebugContext.counter(&quot;MaterializationsPhi&quot;);
  87     public static final CounterKey COUNTER_MATERIALIZATIONS_MERGE = DebugContext.counter(&quot;MaterializationsMerge&quot;);
  88     public static final CounterKey COUNTER_MATERIALIZATIONS_UNHANDLED = DebugContext.counter(&quot;MaterializationsUnhandled&quot;);
  89     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_REITERATION = DebugContext.counter(&quot;MaterializationsLoopReiteration&quot;);
  90     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_END = DebugContext.counter(&quot;MaterializationsLoopEnd&quot;);
</pre>
<hr />
<pre>
 148                     virtual.add(object);
 149                 }
 150             } else {
 151                 ValueNode alias = getAlias(value);
 152                 if (alias instanceof VirtualObjectNode) {
 153                     VirtualObjectNode object = (VirtualObjectNode) alias;
 154                     virtual.add(object);
 155                     effects.replaceFirstInput(usage, value, object);
 156                 }
 157             }
 158         }
 159     }
 160 
 161     /**
 162      * Final subclass of PartialEscapeClosure, for performance and to make everything behave nicely
 163      * with generics.
 164      */
 165     public static final class Final extends PartialEscapeClosure&lt;PartialEscapeBlockState.Final&gt; {
 166 
 167         public Final(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
<span class="line-modified"> 168                         LoweringProvider loweringProvider) {</span>
<span class="line-modified"> 169             super(schedule, metaAccess, constantReflection, constantFieldProvider, loweringProvider);</span>
 170         }
 171 
 172         @Override
 173         protected PartialEscapeBlockState.Final getInitialState() {
 174             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
 175         }
 176 
 177         @Override
 178         protected PartialEscapeBlockState.Final cloneState(PartialEscapeBlockState.Final oldState) {
 179             return new PartialEscapeBlockState.Final(oldState);
 180         }
 181     }
 182 
 183     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
<span class="line-modified"> 184         this(schedule, metaAccess, constantReflection, constantFieldProvider, null);</span>
 185     }
 186 
 187     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
<span class="line-modified"> 188                     LoweringProvider loweringProvider) {</span>
 189         super(schedule, schedule.getCFG());
 190         StructuredGraph graph = schedule.getCFG().graph;
 191         this.hasVirtualInputs = graph.createNodeBitMap();
<span class="line-modified"> 192         this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, this, graph.getAssumptions(), graph.getOptions(), debug, loweringProvider);</span>

 193     }
 194 
 195     /**
 196      * @return true if the node was deleted, false otherwise
 197      */
 198     @Override
 199     protected boolean processNode(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 200         /*
 201          * These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
 202          * and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
 203          * scheduled, but can safely be ignored.
 204          */
 205         if (node instanceof CallTargetNode || node instanceof FrameState || node instanceof ConstantNode) {
 206             return false;
 207         } else if (node instanceof Invoke) {
 208             processNodeInternal(((Invoke) node).callTarget(), state, effects, lastFixedNode);
 209         }
 210         return processNodeInternal(node, state, effects, lastFixedNode);
 211     }
 212 
</pre>
<hr />
<pre>
 828             return resultInts;
 829         }
 830 
 831         private boolean intersectObjectState(PartialEscapeBlockState&lt;?&gt;[] states, int objectIndex) {
 832             for (int i = 0; i &lt; states.length; i++) {
 833                 PartialEscapeBlockState&lt;?&gt; state = states[i];
 834                 if (state.getObjectStateOptional(objectIndex) == null) {
 835                     return false;
 836                 }
 837             }
 838             return true;
 839         }
 840 
 841         /**
 842          * Try to merge multiple virtual object states into a single object state. If the incoming
 843          * object states are compatible, then this method will create PhiNodes for the object&#39;s
 844          * entries where needed. If they are incompatible, then all incoming virtual objects will be
 845          * materialized, and a PhiNode for the materialized values will be created. Object states
 846          * can be incompatible if they contain {@code long} or {@code double} values occupying two
 847          * {@code int} slots in such a way that that their values cannot be merged using PhiNodes.


 848          *
 849          * @param states the predecessor block states of the merge
 850          * @return true if materialization happened during the merge, false otherwise
 851          */
 852         private boolean mergeObjectStates(int resultObject, int[] sourceObjects, PartialEscapeBlockState&lt;?&gt;[] states) {
 853             boolean compatible = true;
 854             boolean ensureVirtual = true;
 855             IntUnaryOperator getObject = index -&gt; sourceObjects == null ? resultObject : sourceObjects[index];
 856 
 857             VirtualObjectNode virtual = virtualObjects.get(resultObject);
 858             int entryCount = virtual.entryCount();
 859 
 860             // determine all entries that have a two-slot value
 861             JavaKind[] twoSlotKinds = null;





 862             outer: for (int i = 0; i &lt; states.length; i++) {
 863                 ObjectState objectState = states[i].getObjectState(getObject.applyAsInt(i));
 864                 ValueNode[] entries = objectState.getEntries();
 865                 int valueIndex = 0;
 866                 ensureVirtual &amp;= objectState.getEnsureVirtualized();
 867                 while (valueIndex &lt; entryCount) {
 868                     JavaKind otherKind = entries[valueIndex].getStackKind();
 869                     JavaKind entryKind = virtual.entryKind(valueIndex);
 870                     if (entryKind == JavaKind.Int &amp;&amp; otherKind.needsTwoSlots()) {
 871                         if (twoSlotKinds == null) {
 872                             twoSlotKinds = new JavaKind[entryCount];
 873                         }
 874                         if (twoSlotKinds[valueIndex] != null &amp;&amp; twoSlotKinds[valueIndex] != otherKind) {
 875                             compatible = false;
 876                             break outer;
 877                         }
 878                         twoSlotKinds[valueIndex] = otherKind;
 879                         // skip the next entry
 880                         valueIndex++;
























































 881                     } else {
 882                         assert entryKind.getStackKind() == otherKind.getStackKind() || (entryKind == JavaKind.Int &amp;&amp; otherKind == JavaKind.Illegal) ||
 883                                         entryKind.getBitCount() &gt;= otherKind.getBitCount() : entryKind + &quot; vs &quot; + otherKind;
 884                     }
 885                     valueIndex++;
 886                 }
 887             }
 888             if (compatible &amp;&amp; twoSlotKinds != null) {
 889                 // if there are two-slot values then make sure the incoming states can be merged
 890                 outer: for (int valueIndex = 0; valueIndex &lt; entryCount; valueIndex++) {
 891                     if (twoSlotKinds[valueIndex] != null) {
 892                         assert valueIndex &lt; virtual.entryCount() - 1 &amp;&amp; virtual.entryKind(valueIndex) == JavaKind.Int &amp;&amp; virtual.entryKind(valueIndex + 1) == JavaKind.Int;
 893                         for (int i = 0; i &lt; states.length; i++) {
 894                             int object = getObject.applyAsInt(i);
 895                             ObjectState objectState = states[i].getObjectState(object);
 896                             ValueNode value = objectState.getEntry(valueIndex);
 897                             JavaKind valueKind = value.getStackKind();
 898                             if (valueKind != twoSlotKinds[valueIndex]) {
 899                                 ValueNode nextValue = objectState.getEntry(valueIndex + 1);
 900                                 if (value.isConstant() &amp;&amp; value.asConstant().equals(JavaConstant.INT_0) &amp;&amp; nextValue.isConstant() &amp;&amp; nextValue.asConstant().equals(JavaConstant.INT_0)) {
 901                                     // rewrite to a zero constant of the larger kind
 902                                     debug.log(&quot;Rewriting entry %s to constant of larger size&quot;, valueIndex);
 903                                     states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(twoSlotKinds[valueIndex], graph()));
<span class="line-modified"> 904                                     states[i].setEntry(object, valueIndex + 1, ConstantNode.forConstant(JavaConstant.forIllegal(), tool.getMetaAccess(), graph()));</span>
 905                                 } else {
 906                                     compatible = false;
 907                                     break outer;
 908                                 }
 909                             }
 910                         }
 911                     }
 912                 }
 913             }

























 914 
 915             if (compatible) {
 916                 // virtual objects are compatible: create phis for all entries that need them
 917                 ValueNode[] values = states[0].getObjectState(getObject.applyAsInt(0)).getEntries().clone();
 918                 PhiNode[] phis = getValuePhis(virtual, virtual.entryCount());
 919                 int valueIndex = 0;
 920                 while (valueIndex &lt; values.length) {
 921                     for (int i = 1; i &lt; states.length; i++) {
 922                         if (phis[valueIndex] == null) {
 923                             ValueNode field = states[i].getObjectState(getObject.applyAsInt(i)).getEntry(valueIndex);
 924                             if (values[valueIndex] != field) {
 925                                 phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
 926                             }
 927                         }
 928                     }
 929                     if (phis[valueIndex] != null &amp;&amp; !phis[valueIndex].stamp(NodeView.DEFAULT).isCompatible(values[valueIndex].stamp(NodeView.DEFAULT))) {
 930                         phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
 931                     }
 932                     if (twoSlotKinds != null &amp;&amp; twoSlotKinds[valueIndex] != null) {
 933                         // skip an entry after a long/double value that occupies two int slots
 934                         valueIndex++;
 935                         phis[valueIndex] = null;
<span class="line-modified"> 936                         values[valueIndex] = ConstantNode.forConstant(JavaConstant.forIllegal(), tool.getMetaAccess(), graph());</span>
 937                     }
 938                     valueIndex++;
 939                 }
 940 
 941                 boolean materialized = false;
 942                 for (int i = 0; i &lt; values.length; i++) {
 943                     PhiNode phi = phis[i];
 944                     if (phi != null) {
 945                         mergeEffects.addFloatingNode(phi, &quot;virtualMergePhi&quot;);
 946                         if (virtual.entryKind(i) == JavaKind.Object) {
 947                             materialized |= mergeObjectEntry(getObject, states, phi, i);
 948                         } else {
 949                             for (int i2 = 0; i2 &lt; states.length; i2++) {
 950                                 ObjectState state = states[i2].getObjectState(getObject.applyAsInt(i2));
 951                                 if (!state.isVirtual()) {
 952                                     break;
 953                                 }
 954                                 setPhiInput(phi, i2, state.getEntry(i));
 955                             }
 956                         }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  51 import org.graalvm.compiler.nodes.FixedNode;
  52 import org.graalvm.compiler.nodes.FixedWithNextNode;
  53 import org.graalvm.compiler.nodes.FrameState;
  54 import org.graalvm.compiler.nodes.Invoke;
  55 import org.graalvm.compiler.nodes.LoopBeginNode;
  56 import org.graalvm.compiler.nodes.LoopExitNode;
  57 import org.graalvm.compiler.nodes.NodeView;
  58 import org.graalvm.compiler.nodes.PhiNode;
  59 import org.graalvm.compiler.nodes.ProxyNode;
  60 import org.graalvm.compiler.nodes.StructuredGraph;
  61 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  62 import org.graalvm.compiler.nodes.UnwindNode;
  63 import org.graalvm.compiler.nodes.ValueNode;
  64 import org.graalvm.compiler.nodes.ValuePhiNode;
  65 import org.graalvm.compiler.nodes.ValueProxyNode;
  66 import org.graalvm.compiler.nodes.VirtualState;
  67 import org.graalvm.compiler.nodes.VirtualState.NodeClosure;
  68 import org.graalvm.compiler.nodes.cfg.Block;
  69 import org.graalvm.compiler.nodes.spi.LoweringProvider;
  70 import org.graalvm.compiler.nodes.spi.NodeWithState;
<span class="line-added">  71 import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;</span>
  72 import org.graalvm.compiler.nodes.spi.Virtualizable;
  73 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  74 import org.graalvm.compiler.nodes.spi.VirtualizerTool;
  75 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  76 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  77 import org.graalvm.compiler.virtual.nodes.VirtualObjectState;
  78 
  79 import jdk.vm.ci.meta.ConstantReflectionProvider;
  80 import jdk.vm.ci.meta.JavaConstant;
  81 import jdk.vm.ci.meta.JavaKind;
  82 import jdk.vm.ci.meta.MetaAccessProvider;
  83 
  84 public abstract class PartialEscapeClosure&lt;BlockT extends PartialEscapeBlockState&lt;BlockT&gt;&gt; extends EffectsClosure&lt;BlockT&gt; {
  85 
  86     public static final CounterKey COUNTER_MATERIALIZATIONS = DebugContext.counter(&quot;Materializations&quot;);
  87     public static final CounterKey COUNTER_MATERIALIZATIONS_PHI = DebugContext.counter(&quot;MaterializationsPhi&quot;);
  88     public static final CounterKey COUNTER_MATERIALIZATIONS_MERGE = DebugContext.counter(&quot;MaterializationsMerge&quot;);
  89     public static final CounterKey COUNTER_MATERIALIZATIONS_UNHANDLED = DebugContext.counter(&quot;MaterializationsUnhandled&quot;);
  90     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_REITERATION = DebugContext.counter(&quot;MaterializationsLoopReiteration&quot;);
  91     public static final CounterKey COUNTER_MATERIALIZATIONS_LOOP_END = DebugContext.counter(&quot;MaterializationsLoopEnd&quot;);
</pre>
<hr />
<pre>
 149                     virtual.add(object);
 150                 }
 151             } else {
 152                 ValueNode alias = getAlias(value);
 153                 if (alias instanceof VirtualObjectNode) {
 154                     VirtualObjectNode object = (VirtualObjectNode) alias;
 155                     virtual.add(object);
 156                     effects.replaceFirstInput(usage, value, object);
 157                 }
 158             }
 159         }
 160     }
 161 
 162     /**
 163      * Final subclass of PartialEscapeClosure, for performance and to make everything behave nicely
 164      * with generics.
 165      */
 166     public static final class Final extends PartialEscapeClosure&lt;PartialEscapeBlockState.Final&gt; {
 167 
 168         public Final(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
<span class="line-modified"> 169                         LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {</span>
<span class="line-modified"> 170             super(schedule, metaAccess, constantReflection, constantFieldProvider, loweringProvider, platformConfigurationProvider);</span>
 171         }
 172 
 173         @Override
 174         protected PartialEscapeBlockState.Final getInitialState() {
 175             return new PartialEscapeBlockState.Final(tool.getOptions(), tool.getDebug());
 176         }
 177 
 178         @Override
 179         protected PartialEscapeBlockState.Final cloneState(PartialEscapeBlockState.Final oldState) {
 180             return new PartialEscapeBlockState.Final(oldState);
 181         }
 182     }
 183 
 184     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider) {
<span class="line-modified"> 185         this(schedule, metaAccess, constantReflection, constantFieldProvider, null, null);</span>
 186     }
 187 
 188     public PartialEscapeClosure(ScheduleResult schedule, MetaAccessProvider metaAccess, ConstantReflectionProvider constantReflection, ConstantFieldProvider constantFieldProvider,
<span class="line-modified"> 189                     LoweringProvider loweringProvider, PlatformConfigurationProvider platformConfigurationProvider) {</span>
 190         super(schedule, schedule.getCFG());
 191         StructuredGraph graph = schedule.getCFG().graph;
 192         this.hasVirtualInputs = graph.createNodeBitMap();
<span class="line-modified"> 193         this.tool = new VirtualizerToolImpl(metaAccess, constantReflection, constantFieldProvider, platformConfigurationProvider, this, graph.getAssumptions(), graph.getOptions(), debug,</span>
<span class="line-added"> 194                         loweringProvider);</span>
 195     }
 196 
 197     /**
 198      * @return true if the node was deleted, false otherwise
 199      */
 200     @Override
 201     protected boolean processNode(Node node, BlockT state, GraphEffectList effects, FixedWithNextNode lastFixedNode) {
 202         /*
 203          * These checks make up for the fact that an earliest schedule moves CallTargetNodes upwards
 204          * and thus materializes virtual objects needlessly. Also, FrameStates and ConstantNodes are
 205          * scheduled, but can safely be ignored.
 206          */
 207         if (node instanceof CallTargetNode || node instanceof FrameState || node instanceof ConstantNode) {
 208             return false;
 209         } else if (node instanceof Invoke) {
 210             processNodeInternal(((Invoke) node).callTarget(), state, effects, lastFixedNode);
 211         }
 212         return processNodeInternal(node, state, effects, lastFixedNode);
 213     }
 214 
</pre>
<hr />
<pre>
 830             return resultInts;
 831         }
 832 
 833         private boolean intersectObjectState(PartialEscapeBlockState&lt;?&gt;[] states, int objectIndex) {
 834             for (int i = 0; i &lt; states.length; i++) {
 835                 PartialEscapeBlockState&lt;?&gt; state = states[i];
 836                 if (state.getObjectStateOptional(objectIndex) == null) {
 837                     return false;
 838                 }
 839             }
 840             return true;
 841         }
 842 
 843         /**
 844          * Try to merge multiple virtual object states into a single object state. If the incoming
 845          * object states are compatible, then this method will create PhiNodes for the object&#39;s
 846          * entries where needed. If they are incompatible, then all incoming virtual objects will be
 847          * materialized, and a PhiNode for the materialized values will be created. Object states
 848          * can be incompatible if they contain {@code long} or {@code double} values occupying two
 849          * {@code int} slots in such a way that that their values cannot be merged using PhiNodes.
<span class="line-added"> 850          * The states may also be incompatible if they contain escaped large writes to byte arrays</span>
<span class="line-added"> 851          * in such a way that they cannot be merged using PhiNodes.</span>
 852          *
 853          * @param states the predecessor block states of the merge
 854          * @return true if materialization happened during the merge, false otherwise
 855          */
 856         private boolean mergeObjectStates(int resultObject, int[] sourceObjects, PartialEscapeBlockState&lt;?&gt;[] states) {
 857             boolean compatible = true;
 858             boolean ensureVirtual = true;
 859             IntUnaryOperator getObject = index -&gt; sourceObjects == null ? resultObject : sourceObjects[index];
 860 
 861             VirtualObjectNode virtual = virtualObjects.get(resultObject);
 862             int entryCount = virtual.entryCount();
 863 
 864             // determine all entries that have a two-slot value
 865             JavaKind[] twoSlotKinds = null;
<span class="line-added"> 866 </span>
<span class="line-added"> 867             // Determine all entries that span multiple slots.</span>
<span class="line-added"> 868             int[] virtualByteCount = null;</span>
<span class="line-added"> 869             JavaKind[] virtualKinds = null;</span>
<span class="line-added"> 870 </span>
 871             outer: for (int i = 0; i &lt; states.length; i++) {
 872                 ObjectState objectState = states[i].getObjectState(getObject.applyAsInt(i));
 873                 ValueNode[] entries = objectState.getEntries();
 874                 int valueIndex = 0;
 875                 ensureVirtual &amp;= objectState.getEnsureVirtualized();
 876                 while (valueIndex &lt; entryCount) {
 877                     JavaKind otherKind = entries[valueIndex].getStackKind();
 878                     JavaKind entryKind = virtual.entryKind(valueIndex);
 879                     if (entryKind == JavaKind.Int &amp;&amp; otherKind.needsTwoSlots()) {
 880                         if (twoSlotKinds == null) {
 881                             twoSlotKinds = new JavaKind[entryCount];
 882                         }
 883                         if (twoSlotKinds[valueIndex] != null &amp;&amp; twoSlotKinds[valueIndex] != otherKind) {
 884                             compatible = false;
 885                             break outer;
 886                         }
 887                         twoSlotKinds[valueIndex] = otherKind;
 888                         // skip the next entry
 889                         valueIndex++;
<span class="line-added"> 890                     } else if (virtual.isVirtualByteArray()) {</span>
<span class="line-added"> 891                         int bytecount = tool.getVirtualByteCount(entries, valueIndex);</span>
<span class="line-added"> 892                         // @formatter:off</span>
<span class="line-added"> 893                         /*</span>
<span class="line-added"> 894                          * Having a bytecount of 1 here can mean two things:</span>
<span class="line-added"> 895                          * - This was a regular byte array access</span>
<span class="line-added"> 896                          * - This is an uninitialized value (ie: default)</span>
<span class="line-added"> 897                          *</span>
<span class="line-added"> 898                          * In the first case, we want to be able to merge regular accesses without</span>
<span class="line-added"> 899                          * issues. But in the second case, if one of the branch has escaped a write</span>
<span class="line-added"> 900                          * (while other branches did not touch the array), we want to be able to</span>
<span class="line-added"> 901                          * propagate the escape to the merge.</span>
<span class="line-added"> 902                          *</span>
<span class="line-added"> 903                          * However, the semantics of virtual object creation in PEA puts a default</span>
<span class="line-added"> 904                          * (0) byte value on all entries. As such, the merging is done in two steps:</span>
<span class="line-added"> 905                          * - For each virtual entry, know if there is an escaped write in one of the</span>
<span class="line-added"> 906                          * branch, and store its byte count, unless it is 1.</span>
<span class="line-added"> 907                          * - Now that we know the byte count, we can escape multiple writes for the</span>
<span class="line-added"> 908                          * default values from branches that did nothing on the entry in question to</span>
<span class="line-added"> 909                          * a default write of a bigger kind.</span>
<span class="line-added"> 910                          *</span>
<span class="line-added"> 911                          * for example, consider:</span>
<span class="line-added"> 912                          *</span>
<span class="line-added"> 913                          * b = new byte[8];</span>
<span class="line-added"> 914                          * if (...) {b[0] &lt;- 1L}</span>
<span class="line-added"> 915                          * else     {}</span>
<span class="line-added"> 916                          *</span>
<span class="line-added"> 917                          * for escape analysis purposes, it can be seen as:</span>
<span class="line-added"> 918                          *</span>
<span class="line-added"> 919                          * b = new byte[8];</span>
<span class="line-added"> 920                          * if (...) {b[0] &lt;- 1L}</span>
<span class="line-added"> 921                          * else     {b[0] &lt;- 0L}</span>
<span class="line-added"> 922                          */</span>
<span class="line-added"> 923                         // @formatter:on</span>
<span class="line-added"> 924                         if (bytecount &gt; 1) {</span>
<span class="line-added"> 925                             if (virtualByteCount == null) {</span>
<span class="line-added"> 926                                 virtualByteCount = new int[entryCount];</span>
<span class="line-added"> 927                             }</span>
<span class="line-added"> 928                             if (virtualKinds == null) {</span>
<span class="line-added"> 929                                 virtualKinds = new JavaKind[entryCount];</span>
<span class="line-added"> 930                             }</span>
<span class="line-added"> 931                             if (virtualByteCount[valueIndex] != 0 &amp;&amp; virtualByteCount[valueIndex] != bytecount) {</span>
<span class="line-added"> 932                                 compatible = false;</span>
<span class="line-added"> 933                                 break outer;</span>
<span class="line-added"> 934                             }</span>
<span class="line-added"> 935                             // Disallow merging ints with floats. Allows merging shorts with chars</span>
<span class="line-added"> 936                             // (working with stack kinds).</span>
<span class="line-added"> 937                             if (virtualKinds[valueIndex] != null &amp;&amp; virtualKinds[valueIndex] != otherKind) {</span>
<span class="line-added"> 938                                 compatible = false;</span>
<span class="line-added"> 939                                 break outer;</span>
<span class="line-added"> 940                             }</span>
<span class="line-added"> 941                             virtualByteCount[valueIndex] = bytecount;</span>
<span class="line-added"> 942                             virtualKinds[valueIndex] = otherKind;</span>
<span class="line-added"> 943                             // skip illegals.</span>
<span class="line-added"> 944                             valueIndex = valueIndex + bytecount - 1;</span>
<span class="line-added"> 945                         }</span>
 946                     } else {
 947                         assert entryKind.getStackKind() == otherKind.getStackKind() || (entryKind == JavaKind.Int &amp;&amp; otherKind == JavaKind.Illegal) ||
 948                                         entryKind.getBitCount() &gt;= otherKind.getBitCount() : entryKind + &quot; vs &quot; + otherKind;
 949                     }
 950                     valueIndex++;
 951                 }
 952             }
 953             if (compatible &amp;&amp; twoSlotKinds != null) {
 954                 // if there are two-slot values then make sure the incoming states can be merged
 955                 outer: for (int valueIndex = 0; valueIndex &lt; entryCount; valueIndex++) {
 956                     if (twoSlotKinds[valueIndex] != null) {
 957                         assert valueIndex &lt; virtual.entryCount() - 1 &amp;&amp; virtual.entryKind(valueIndex) == JavaKind.Int &amp;&amp; virtual.entryKind(valueIndex + 1) == JavaKind.Int;
 958                         for (int i = 0; i &lt; states.length; i++) {
 959                             int object = getObject.applyAsInt(i);
 960                             ObjectState objectState = states[i].getObjectState(object);
 961                             ValueNode value = objectState.getEntry(valueIndex);
 962                             JavaKind valueKind = value.getStackKind();
 963                             if (valueKind != twoSlotKinds[valueIndex]) {
 964                                 ValueNode nextValue = objectState.getEntry(valueIndex + 1);
 965                                 if (value.isConstant() &amp;&amp; value.asConstant().equals(JavaConstant.INT_0) &amp;&amp; nextValue.isConstant() &amp;&amp; nextValue.asConstant().equals(JavaConstant.INT_0)) {
 966                                     // rewrite to a zero constant of the larger kind
 967                                     debug.log(&quot;Rewriting entry %s to constant of larger size&quot;, valueIndex);
 968                                     states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(twoSlotKinds[valueIndex], graph()));
<span class="line-modified"> 969                                     states[i].setEntry(object, valueIndex + 1, tool.getIllegalConstant());</span>
 970                                 } else {
 971                                     compatible = false;
 972                                     break outer;
 973                                 }
 974                             }
 975                         }
 976                     }
 977                 }
 978             }
<span class="line-added"> 979             if (compatible &amp;&amp; virtualByteCount != null) {</span>
<span class="line-added"> 980                 assert twoSlotKinds == null;</span>
<span class="line-added"> 981                 outer: //</span>
<span class="line-added"> 982                 for (int valueIndex = 0; valueIndex &lt; entryCount; valueIndex++) {</span>
<span class="line-added"> 983                     if (virtualByteCount[valueIndex] != 0) {</span>
<span class="line-added"> 984                         int byteCount = virtualByteCount[valueIndex];</span>
<span class="line-added"> 985                         for (int i = 0; i &lt; states.length; i++) {</span>
<span class="line-added"> 986                             int object = getObject.applyAsInt(i);</span>
<span class="line-added"> 987                             ObjectState objectState = states[i].getObjectState(object);</span>
<span class="line-added"> 988                             if (tool.isEntryDefaults(objectState, byteCount, valueIndex)) {</span>
<span class="line-added"> 989                                 // Interpret uninitialized as a corresponding large access.</span>
<span class="line-added"> 990                                 states[i].setEntry(object, valueIndex, ConstantNode.defaultForKind(virtualKinds[valueIndex]));</span>
<span class="line-added"> 991                                 for (int illegalIndex = valueIndex + 1; illegalIndex &lt; valueIndex + byteCount; illegalIndex++) {</span>
<span class="line-added"> 992                                     states[i].setEntry(object, illegalIndex, tool.getIllegalConstant());</span>
<span class="line-added"> 993                                 }</span>
<span class="line-added"> 994                             } else {</span>
<span class="line-added"> 995                                 if (tool.getVirtualByteCount(objectState.getEntries(), valueIndex) != byteCount) {</span>
<span class="line-added"> 996                                     compatible = false;</span>
<span class="line-added"> 997                                     break outer;</span>
<span class="line-added"> 998                                 }</span>
<span class="line-added"> 999                             }</span>
<span class="line-added">1000                         }</span>
<span class="line-added">1001                     }</span>
<span class="line-added">1002                 }</span>
<span class="line-added">1003             }</span>
1004 
1005             if (compatible) {
1006                 // virtual objects are compatible: create phis for all entries that need them
1007                 ValueNode[] values = states[0].getObjectState(getObject.applyAsInt(0)).getEntries().clone();
1008                 PhiNode[] phis = getValuePhis(virtual, virtual.entryCount());
1009                 int valueIndex = 0;
1010                 while (valueIndex &lt; values.length) {
1011                     for (int i = 1; i &lt; states.length; i++) {
1012                         if (phis[valueIndex] == null) {
1013                             ValueNode field = states[i].getObjectState(getObject.applyAsInt(i)).getEntry(valueIndex);
1014                             if (values[valueIndex] != field) {
1015                                 phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
1016                             }
1017                         }
1018                     }
1019                     if (phis[valueIndex] != null &amp;&amp; !phis[valueIndex].stamp(NodeView.DEFAULT).isCompatible(values[valueIndex].stamp(NodeView.DEFAULT))) {
1020                         phis[valueIndex] = createValuePhi(values[valueIndex].stamp(NodeView.DEFAULT).unrestricted());
1021                     }
1022                     if (twoSlotKinds != null &amp;&amp; twoSlotKinds[valueIndex] != null) {
1023                         // skip an entry after a long/double value that occupies two int slots
1024                         valueIndex++;
1025                         phis[valueIndex] = null;
<span class="line-modified">1026                         values[valueIndex] = tool.getIllegalConstant();</span>
1027                     }
1028                     valueIndex++;
1029                 }
1030 
1031                 boolean materialized = false;
1032                 for (int i = 0; i &lt; values.length; i++) {
1033                     PhiNode phi = phis[i];
1034                     if (phi != null) {
1035                         mergeEffects.addFloatingNode(phi, &quot;virtualMergePhi&quot;);
1036                         if (virtual.entryKind(i) == JavaKind.Object) {
1037                             materialized |= mergeObjectEntry(getObject, states, phi, i);
1038                         } else {
1039                             for (int i2 = 0; i2 &lt; states.length; i2++) {
1040                                 ObjectState state = states[i2].getObjectState(getObject.applyAsInt(i2));
1041                                 if (!state.isVirtual()) {
1042                                     break;
1043                                 }
1044                                 setPhiInput(phi, i2, state.getEntry(i));
1045                             }
1046                         }
</pre>
</td>
</tr>
</table>
<center><a href="PEReadEliminationClosure.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../../index.html" target="_top">index</a> <a href="PartialEscapePhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_READ;
  28 import static jdk.vm.ci.code.MemoryBarriers.JMM_POST_VOLATILE_WRITE;
  29 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_READ;
  30 import static jdk.vm.ci.code.MemoryBarriers.JMM_PRE_VOLATILE_WRITE;
  31 import static jdk.vm.ci.meta.DeoptimizationAction.InvalidateReprofile;
  32 import static jdk.vm.ci.meta.DeoptimizationReason.BoundsCheckException;
  33 import static jdk.vm.ci.meta.DeoptimizationReason.NullCheckException;
  34 import static org.graalvm.compiler.core.common.SpeculativeExecutionAttacksMitigations.Options.UseIndexMasking;
  35 import static org.graalvm.compiler.nodes.NamedLocationIdentity.ARRAY_LENGTH_LOCATION;
  36 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMax;
  37 import static org.graalvm.compiler.nodes.calc.BinaryArithmeticNode.branchlessMin;
  38 import static org.graalvm.compiler.nodes.java.ArrayLengthNode.readArrayLength;
  39 import static org.graalvm.compiler.nodes.util.GraphUtil.skipPiWhileNonNull;
  40 
  41 import java.nio.ByteOrder;
  42 import java.util.ArrayList;
  43 import java.util.BitSet;
  44 import java.util.List;
  45 
  46 import org.graalvm.compiler.api.directives.GraalDirectives;
  47 import org.graalvm.compiler.api.replacements.Snippet;
  48 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  49 import org.graalvm.compiler.core.common.GraalOptions;
  50 import org.graalvm.compiler.core.common.LIRKind;
  51 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
  52 import org.graalvm.compiler.core.common.type.AbstractPointerStamp;
  53 import org.graalvm.compiler.core.common.type.IntegerStamp;
  54 import org.graalvm.compiler.core.common.type.ObjectStamp;
  55 import org.graalvm.compiler.core.common.type.Stamp;
  56 import org.graalvm.compiler.core.common.type.StampFactory;
  57 import org.graalvm.compiler.core.common.type.TypeReference;
  58 import org.graalvm.compiler.debug.DebugCloseable;
  59 import org.graalvm.compiler.debug.DebugHandlersFactory;
  60 import org.graalvm.compiler.debug.GraalError;
  61 import org.graalvm.compiler.graph.Node;
  62 import org.graalvm.compiler.nodeinfo.InputType;
  63 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
  64 import org.graalvm.compiler.nodes.ConstantNode;
  65 import org.graalvm.compiler.nodes.EndNode;
  66 import org.graalvm.compiler.nodes.FieldLocationIdentity;
  67 import org.graalvm.compiler.nodes.FixedNode;
  68 import org.graalvm.compiler.nodes.FixedWithNextNode;
  69 import org.graalvm.compiler.nodes.IfNode;
  70 import org.graalvm.compiler.nodes.LogicNode;
  71 import org.graalvm.compiler.nodes.MergeNode;
  72 import org.graalvm.compiler.nodes.NamedLocationIdentity;
  73 import org.graalvm.compiler.nodes.NodeView;
  74 import org.graalvm.compiler.nodes.PhiNode;
  75 import org.graalvm.compiler.nodes.PiNode;
  76 import org.graalvm.compiler.nodes.StructuredGraph;
  77 import org.graalvm.compiler.nodes.ValueNode;
  78 import org.graalvm.compiler.nodes.ValuePhiNode;
  79 import org.graalvm.compiler.nodes.calc.AddNode;
  80 import org.graalvm.compiler.nodes.calc.ConditionalNode;
  81 import org.graalvm.compiler.nodes.calc.IntegerBelowNode;
  82 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  83 import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  84 import org.graalvm.compiler.nodes.calc.IsNullNode;
  85 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  86 import org.graalvm.compiler.nodes.calc.NarrowNode;
<a name="2" id="anc2"></a><span class="line-added">  87 import org.graalvm.compiler.nodes.calc.ReinterpretNode;</span>
  88 import org.graalvm.compiler.nodes.calc.RightShiftNode;
  89 import org.graalvm.compiler.nodes.calc.SignExtendNode;
  90 import org.graalvm.compiler.nodes.calc.SubNode;
  91 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  92 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  93 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  94 import org.graalvm.compiler.nodes.extended.BoxNode;
  95 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  96 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  97 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  98 import org.graalvm.compiler.nodes.extended.GuardingNode;
  99 import org.graalvm.compiler.nodes.extended.JavaReadNode;
 100 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 101 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 102 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 103 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 104 import org.graalvm.compiler.nodes.extended.MembarNode;
 105 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 106 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 107 import org.graalvm.compiler.nodes.extended.UnboxNode;
 108 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 109 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
 110 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 111 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 112 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 113 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 114 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 115 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 116 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 117 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 118 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 119 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 120 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 121 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 122 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 123 import org.graalvm.compiler.nodes.java.NewArrayNode;
 124 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 125 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 126 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 127 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 128 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 129 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
 130 import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
<a name="3" id="anc3"></a><span class="line-modified"> 131 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>
 132 import org.graalvm.compiler.nodes.memory.ReadNode;
 133 import org.graalvm.compiler.nodes.memory.VolatileReadNode;
 134 import org.graalvm.compiler.nodes.memory.WriteNode;
 135 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 136 import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
 137 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<a name="4" id="anc4"></a>
 138 import org.graalvm.compiler.nodes.spi.Lowerable;
 139 import org.graalvm.compiler.nodes.spi.LoweringProvider;
 140 import org.graalvm.compiler.nodes.spi.LoweringTool;
<a name="5" id="anc5"></a><span class="line-added"> 141 import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;</span>
 142 import org.graalvm.compiler.nodes.type.StampTool;
 143 import org.graalvm.compiler.nodes.util.GraphUtil;
 144 import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
 145 import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
 146 import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
 147 import org.graalvm.compiler.nodes.virtual.VirtualInstanceNode;
 148 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
 149 import org.graalvm.compiler.options.OptionValues;
 150 import org.graalvm.compiler.phases.util.Providers;
 151 import org.graalvm.compiler.replacements.SnippetLowerableMemoryNode.SnippetLowering;
 152 import org.graalvm.compiler.replacements.nodes.BinaryMathIntrinsicNode;
 153 import org.graalvm.compiler.replacements.nodes.UnaryMathIntrinsicNode;
 154 import jdk.internal.vm.compiler.word.LocationIdentity;
 155 
 156 import jdk.vm.ci.code.CodeUtil;
 157 import jdk.vm.ci.code.MemoryBarriers;
 158 import jdk.vm.ci.code.TargetDescription;
 159 import jdk.vm.ci.meta.DeoptimizationAction;
 160 import jdk.vm.ci.meta.DeoptimizationReason;
 161 import jdk.vm.ci.meta.JavaConstant;
 162 import jdk.vm.ci.meta.JavaKind;
 163 import jdk.vm.ci.meta.MetaAccessProvider;
 164 import jdk.vm.ci.meta.ResolvedJavaField;
 165 import jdk.vm.ci.meta.ResolvedJavaMethod;
 166 import jdk.vm.ci.meta.ResolvedJavaType;
 167 import jdk.vm.ci.meta.SpeculationLog;
 168 
 169 /**
 170  * VM-independent lowerings for standard Java nodes. VM-specific methods are abstract and must be
 171  * implemented by VM-specific subclasses.
 172  */
 173 public abstract class DefaultJavaLoweringProvider implements LoweringProvider {
 174 
 175     protected final MetaAccessProvider metaAccess;
 176     protected final ForeignCallsProvider foreignCalls;
 177     protected final TargetDescription target;
 178     private final boolean useCompressedOops;
 179     private final ResolvedJavaType objectArrayType;
 180 
 181     private BoxingSnippets.Templates boxingSnippets;
 182     private ConstantStringIndexOfSnippets.Templates indexOfSnippets;
 183 
 184     public DefaultJavaLoweringProvider(MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, TargetDescription target, boolean useCompressedOops) {
 185         this.metaAccess = metaAccess;
 186         this.foreignCalls = foreignCalls;
 187         this.target = target;
 188         this.useCompressedOops = useCompressedOops;
 189         this.objectArrayType = metaAccess.lookupJavaType(Object[].class);
 190     }
 191 
 192     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, Providers providers, SnippetReflectionProvider snippetReflection) {
 193         boxingSnippets = new BoxingSnippets.Templates(options, factories, factory, providers, snippetReflection, target);
 194         indexOfSnippets = new ConstantStringIndexOfSnippets.Templates(options, factories, providers, snippetReflection, target);
 195         providers.getReplacements().registerSnippetTemplateCache(new SnippetCounterNode.SnippetCounterSnippets.Templates(options, factories, providers, snippetReflection, target));
 196     }
 197 
 198     public final TargetDescription getTarget() {
 199         return target;
 200     }
 201 
 202     public MetaAccessProvider getMetaAccess() {
 203         return metaAccess;
 204     }
 205 
 206     @Override
 207     @SuppressWarnings(&quot;try&quot;)
 208     public void lower(Node n, LoweringTool tool) {
 209         assert n instanceof Lowerable;
 210         StructuredGraph graph = (StructuredGraph) n.graph();
 211         try (DebugCloseable context = n.withNodeSourcePosition()) {
 212             if (n instanceof LoadFieldNode) {
 213                 lowerLoadFieldNode((LoadFieldNode) n, tool);
 214             } else if (n instanceof StoreFieldNode) {
 215                 lowerStoreFieldNode((StoreFieldNode) n, tool);
 216             } else if (n instanceof LoadIndexedNode) {
 217                 lowerLoadIndexedNode((LoadIndexedNode) n, tool);
 218             } else if (n instanceof StoreIndexedNode) {
 219                 lowerStoreIndexedNode((StoreIndexedNode) n, tool);
 220             } else if (n instanceof IndexAddressNode) {
 221                 lowerIndexAddressNode((IndexAddressNode) n);
 222             } else if (n instanceof ArrayLengthNode) {
 223                 lowerArrayLengthNode((ArrayLengthNode) n, tool);
 224             } else if (n instanceof LoadHubNode) {
 225                 lowerLoadHubNode((LoadHubNode) n, tool);
 226             } else if (n instanceof LoadHubOrNullNode) {
 227                 lowerLoadHubOrNullNode((LoadHubOrNullNode) n, tool);
 228             } else if (n instanceof LoadArrayComponentHubNode) {
 229                 lowerLoadArrayComponentHubNode((LoadArrayComponentHubNode) n);
 230             } else if (n instanceof MonitorEnterNode) {
 231                 lowerMonitorEnterNode((MonitorEnterNode) n, tool, graph);
 232             } else if (n instanceof UnsafeCompareAndSwapNode) {
 233                 lowerCompareAndSwapNode((UnsafeCompareAndSwapNode) n);
 234             } else if (n instanceof UnsafeCompareAndExchangeNode) {
 235                 lowerCompareAndExchangeNode((UnsafeCompareAndExchangeNode) n);
 236             } else if (n instanceof AtomicReadAndWriteNode) {
 237                 lowerAtomicReadAndWriteNode((AtomicReadAndWriteNode) n);
 238             } else if (n instanceof RawLoadNode) {
 239                 lowerUnsafeLoadNode((RawLoadNode) n, tool);
 240             } else if (n instanceof UnsafeMemoryLoadNode) {
 241                 lowerUnsafeMemoryLoadNode((UnsafeMemoryLoadNode) n);
 242             } else if (n instanceof RawStoreNode) {
 243                 lowerUnsafeStoreNode((RawStoreNode) n);
 244             } else if (n instanceof UnsafeMemoryStoreNode) {
 245                 lowerUnsafeMemoryStoreNode((UnsafeMemoryStoreNode) n);
 246             } else if (n instanceof JavaReadNode) {
 247                 lowerJavaReadNode((JavaReadNode) n);
 248             } else if (n instanceof JavaWriteNode) {
 249                 lowerJavaWriteNode((JavaWriteNode) n);
 250             } else if (n instanceof CommitAllocationNode) {
 251                 lowerCommitAllocationNode((CommitAllocationNode) n, tool);
 252             } else if (n instanceof BoxNode) {
 253                 boxingSnippets.lower((BoxNode) n, tool);
 254             } else if (n instanceof UnboxNode) {
 255                 boxingSnippets.lower((UnboxNode) n, tool);
 256             } else if (n instanceof VerifyHeapNode) {
 257                 lowerVerifyHeap((VerifyHeapNode) n);
 258             } else if (n instanceof UnaryMathIntrinsicNode) {
 259                 lowerUnaryMath((UnaryMathIntrinsicNode) n, tool);
 260             } else if (n instanceof BinaryMathIntrinsicNode) {
 261                 lowerBinaryMath((BinaryMathIntrinsicNode) n, tool);
 262             } else if (n instanceof StringIndexOfNode) {
 263                 lowerIndexOf((StringIndexOfNode) n);
 264             } else if (n instanceof StringLatin1IndexOfNode) {
 265                 lowerLatin1IndexOf((StringLatin1IndexOfNode) n);
 266             } else if (n instanceof StringUTF16IndexOfNode) {
 267                 lowerUTF16IndexOf((StringUTF16IndexOfNode) n);
 268             } else if (n instanceof UnpackEndianHalfNode) {
 269                 lowerSecondHalf((UnpackEndianHalfNode) n);
 270             } else {
 271                 throw GraalError.shouldNotReachHere(&quot;Node implementing Lowerable not handled: &quot; + n);
 272             }
 273         }
 274     }
 275 
 276     private void lowerSecondHalf(UnpackEndianHalfNode n) {
 277         ByteOrder byteOrder = target.arch.getByteOrder();
 278         n.lower(byteOrder);
 279     }
 280 
 281     private void lowerIndexOf(StringIndexOfNode n) {
 282         if (n.getArgument(3).isConstant()) {
 283             SnippetLowering lowering = new SnippetLowering() {
 284                 @Override
 285                 public void lower(SnippetLowerableMemoryNode node, LoweringTool tool) {
 286                     if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 287                         return;
 288                     }
 289                     indexOfSnippets.lower(node, tool);
 290                 }
 291             };
 292             SnippetLowerableMemoryNode snippetLower = new SnippetLowerableMemoryNode(lowering, NamedLocationIdentity.getArrayLocation(JavaKind.Char), n.stamp(NodeView.DEFAULT), n.toArgumentArray());
 293             n.graph().add(snippetLower);
 294             n.graph().replaceFixedWithFixed(n, snippetLower);
 295         }
 296     }
 297 
 298     private void lowerLatin1IndexOf(StringLatin1IndexOfNode n) {
 299         if (n.getArgument(2).isConstant()) {
 300             SnippetLowering lowering = new SnippetLowering() {
 301                 @Override
 302                 public void lower(SnippetLowerableMemoryNode node, LoweringTool tool) {
 303                     if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 304                         return;
 305                     }
 306                     indexOfSnippets.lowerLatin1(node, tool);
 307                 }
 308             };
 309             SnippetLowerableMemoryNode snippetLower = new SnippetLowerableMemoryNode(lowering, NamedLocationIdentity.getArrayLocation(JavaKind.Byte), n.stamp(NodeView.DEFAULT), n.toArgumentArray());
 310             n.graph().add(snippetLower);
 311             n.graph().replaceFixedWithFixed(n, snippetLower);
 312         }
 313     }
 314 
 315     private void lowerUTF16IndexOf(StringUTF16IndexOfNode n) {
 316         if (n.getArgument(2).isConstant()) {
 317             SnippetLowering lowering = new SnippetLowering() {
 318                 @Override
 319                 public void lower(SnippetLowerableMemoryNode node, LoweringTool tool) {
 320                     if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 321                         return;
 322                     }
 323                     indexOfSnippets.lowerUTF16(node, tool);
 324                 }
 325             };
 326             SnippetLowerableMemoryNode snippetLower = new SnippetLowerableMemoryNode(lowering, NamedLocationIdentity.getArrayLocation(JavaKind.Byte), n.stamp(NodeView.DEFAULT), n.toArgumentArray());
 327             n.graph().add(snippetLower);
 328             n.graph().replaceFixedWithFixed(n, snippetLower);
 329         }
 330     }
 331 
 332     private void lowerBinaryMath(BinaryMathIntrinsicNode math, LoweringTool tool) {
 333         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
 334             return;
 335         }
 336         ResolvedJavaMethod method = math.graph().method();
 337         if (method != null) {
 338             if (method.getAnnotation(Snippet.class) != null) {
 339                 // In the context of SnippetStub, i.e., Graal-generated stubs, use the LIR
 340                 // lowering to emit the stub assembly code instead of the Node lowering.
 341                 return;
 342             }
 343             if (method.getName().equalsIgnoreCase(math.getOperation().name()) &amp;&amp; tool.getMetaAccess().lookupJavaType(Math.class).equals(method.getDeclaringClass())) {
 344                 // A root compilation of the intrinsic method should emit the full assembly
 345                 // implementation.
 346                 return;
 347             }
 348         }
 349         StructuredGraph graph = math.graph();
 350         ForeignCallNode call = graph.add(new ForeignCallNode(foreignCalls, math.getOperation().foreignCallDescriptor, math.getX(), math.getY()));
 351         graph.addAfterFixed(tool.lastFixedNode(), call);
 352         math.replaceAtUsages(call);
 353     }
 354 
 355     private void lowerUnaryMath(UnaryMathIntrinsicNode math, LoweringTool tool) {
 356         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
 357             return;
 358         }
 359         ResolvedJavaMethod method = math.graph().method();
 360         if (method != null) {
 361             if (method.getName().equalsIgnoreCase(math.getOperation().name()) &amp;&amp; tool.getMetaAccess().lookupJavaType(Math.class).equals(method.getDeclaringClass())) {
 362                 // A root compilation of the intrinsic method should emit the full assembly
 363                 // implementation.
 364                 return;
 365             }
 366         }
 367         StructuredGraph graph = math.graph();
 368         ForeignCallNode call = math.graph().add(new ForeignCallNode(foreignCalls, math.getOperation().foreignCallDescriptor, math.getValue()));
 369         graph.addAfterFixed(tool.lastFixedNode(), call);
 370         math.replaceAtUsages(call);
 371     }
 372 
 373     protected void lowerVerifyHeap(VerifyHeapNode n) {
 374         GraphUtil.removeFixedWithUnusedInputs(n);
 375     }
 376 
<a name="6" id="anc6"></a><span class="line-modified"> 377     public AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {</span>
 378         ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
 379         return graph.unique(new OffsetAddressNode(object, o));
 380     }
 381 
<a name="7" id="anc7"></a><span class="line-modified"> 382     public AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {</span>
 383         int offset = fieldOffset(field);
 384         if (offset &gt;= 0) {
 385             return createOffsetAddress(graph, object, offset);
 386         } else {
 387             return null;
 388         }
 389     }
 390 
 391     protected abstract JavaKind getStorageKind(ResolvedJavaField field);
 392 
 393     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 394         assert loadField.getStackKind() != JavaKind.Illegal;
 395         StructuredGraph graph = loadField.graph();
 396         ResolvedJavaField field = loadField.field();
 397         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 398         object = createNullCheckedValue(object, loadField, tool);
 399         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 400 
 401         AddressNode address = createFieldAddress(graph, object, field);
 402         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
 403 
 404         ReadNode memoryRead = null;
 405         if (loadField.isVolatile() &amp;&amp; GraalOptions.LateMembars.getValue(graph.getOptions())) {
 406             memoryRead = graph.add(new VolatileReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));
 407         } else {
 408             memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));
 409         }
 410         ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
 411         loadField.replaceAtUsages(readValue);
 412         graph.replaceFixed(loadField, memoryRead);
 413 
 414         if (loadField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 415             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
 416             graph.addBeforeFixed(memoryRead, preMembar);
 417             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
 418             graph.addAfterFixed(memoryRead, postMembar);
 419         }
 420     }
 421 
 422     protected void lowerStoreFieldNode(StoreFieldNode storeField, LoweringTool tool) {
 423         StructuredGraph graph = storeField.graph();
 424         ResolvedJavaField field = storeField.field();
 425         ValueNode object = storeField.isStatic() ? staticFieldBase(graph, field) : storeField.object();
 426         object = createNullCheckedValue(object, storeField, tool);
 427         ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
 428         AddressNode address = createFieldAddress(graph, object, field);
 429         assert address != null;
 430 
 431         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field()), storeField.isVolatile()));
 432         memoryWrite.setStateAfter(storeField.stateAfter());
 433         graph.replaceFixedWithFixed(storeField, memoryWrite);
 434 
 435         if (storeField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 436             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
 437             graph.addBeforeFixed(memoryWrite, preMembar);
 438             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
 439             graph.addAfterFixed(memoryWrite, postMembar);
 440         }
 441     }
 442 
 443     public static final IntegerStamp POSITIVE_ARRAY_INDEX_STAMP = StampFactory.forInteger(32, 0, Integer.MAX_VALUE - 1);
 444 
 445     /**
 446      * Create a PiNode on the index proving that the index is positive. On some platforms this is
 447      * important to allow the index to be used as an int in the address mode.
 448      */
 449     public AddressNode createArrayIndexAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index, GuardingNode boundsCheck) {
 450         ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
 451         return createArrayAddress(graph, array, elementKind, positiveIndex);
 452     }
 453 
 454     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index) {
 455         return createArrayAddress(graph, array, elementKind, elementKind, index);
 456     }
 457 
 458     public AddressNode createArrayAddress(StructuredGraph graph, ValueNode array, JavaKind arrayKind, JavaKind elementKind, ValueNode index) {
 459         ValueNode wordIndex;
 460         if (target.wordSize &gt; 4) {
 461             wordIndex = graph.unique(new SignExtendNode(index, target.wordSize * 8));
 462         } else {
 463             assert target.wordSize == 4 : &quot;unsupported word size&quot;;
 464             wordIndex = index;
 465         }
 466 
 467         int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
 468         ValueNode scaledIndex = graph.unique(new LeftShiftNode(wordIndex, ConstantNode.forInt(shift, graph)));
 469 
 470         int base = metaAccess.getArrayBaseOffset(arrayKind);
 471         ValueNode offset = graph.unique(new AddNode(scaledIndex, ConstantNode.forIntegerKind(target.wordJavaKind, base, graph)));
 472 
 473         return graph.unique(new OffsetAddressNode(array, offset));
 474     }
 475 
 476     protected void lowerIndexAddressNode(IndexAddressNode indexAddress) {
 477         AddressNode lowered = createArrayAddress(indexAddress.graph(), indexAddress.getArray(), indexAddress.getArrayKind(), indexAddress.getElementKind(), indexAddress.getIndex());
 478         indexAddress.replaceAndDelete(lowered);
 479     }
 480 
 481     protected void lowerLoadIndexedNode(LoadIndexedNode loadIndexed, LoweringTool tool) {
 482         StructuredGraph graph = loadIndexed.graph();
 483         ValueNode array = loadIndexed.array();
 484         array = createNullCheckedValue(array, loadIndexed, tool);
 485         JavaKind elementKind = loadIndexed.elementKind();
 486         Stamp loadStamp = loadStamp(loadIndexed.stamp(NodeView.DEFAULT), elementKind);
 487 
 488         GuardingNode boundsCheck = getBoundsCheck(loadIndexed, array, tool);
 489         ValueNode index = loadIndexed.index();
 490         if (UseIndexMasking.getValue(graph.getOptions())) {
 491             index = proxyIndex(loadIndexed, index, array, tool);
 492         }
 493         AddressNode address = createArrayIndexAddress(graph, array, elementKind, index, boundsCheck);
 494 
 495         ReadNode memoryRead = graph.add(new ReadNode(address, NamedLocationIdentity.getArrayLocation(elementKind), loadStamp, BarrierType.NONE));
 496         memoryRead.setGuard(boundsCheck);
 497         ValueNode readValue = implicitLoadConvert(graph, elementKind, memoryRead);
 498 
 499         loadIndexed.replaceAtUsages(readValue);
 500         graph.replaceFixed(loadIndexed, memoryRead);
 501     }
 502 
 503     protected void lowerStoreIndexedNode(StoreIndexedNode storeIndexed, LoweringTool tool) {
 504         StructuredGraph graph = storeIndexed.graph();
 505 
 506         ValueNode value = storeIndexed.value();
 507         ValueNode array = storeIndexed.array();
 508 
 509         array = this.createNullCheckedValue(array, storeIndexed, tool);
 510 
 511         GuardingNode boundsCheck = getBoundsCheck(storeIndexed, array, tool);
 512 
 513         JavaKind elementKind = storeIndexed.elementKind();
 514 
 515         LogicNode condition = null;
 516         if (storeIndexed.getStoreCheck() == null &amp;&amp; elementKind == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(value)) {
 517             /* Array store check. */
 518             TypeReference arrayType = StampTool.typeReferenceOrNull(array);
 519             if (arrayType != null &amp;&amp; arrayType.isExact()) {
 520                 ResolvedJavaType elementType = arrayType.getType().getComponentType();
 521                 if (!elementType.isJavaLangObject()) {
 522                     TypeReference typeReference = TypeReference.createTrusted(storeIndexed.graph().getAssumptions(), elementType);
 523                     LogicNode typeTest = graph.addOrUniqueWithInputs(InstanceOfNode.create(typeReference, value));
 524                     condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 525                 }
 526             } else {
 527                 /*
 528                  * The guard on the read hub should be the null check of the array that was
 529                  * introduced earlier.
 530                  */
 531                 ValueNode arrayClass = createReadHub(graph, array, tool);
 532                 ValueNode componentHub = createReadArrayComponentHub(graph, arrayClass, storeIndexed);
 533                 LogicNode typeTest = graph.unique(InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), componentHub, value, false));
 534                 condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 535             }
 536         }
 537 
 538         AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);
 539         WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),
 540                         arrayStoreBarrierType(storeIndexed.elementKind()), false));
 541         memoryWrite.setGuard(boundsCheck);
 542         if (condition != null) {
 543             tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
 544         }
 545         memoryWrite.setStateAfter(storeIndexed.stateAfter());
 546         graph.replaceFixedWithFixed(storeIndexed, memoryWrite);
 547     }
 548 
 549     protected void lowerArrayLengthNode(ArrayLengthNode arrayLengthNode, LoweringTool tool) {
 550         arrayLengthNode.replaceAtUsages(createReadArrayLength(arrayLengthNode.array(), arrayLengthNode, tool));
 551         StructuredGraph graph = arrayLengthNode.graph();
 552         graph.removeFixed(arrayLengthNode);
 553     }
 554 
 555     /**
 556      * Creates a read node that read the array length and is guarded by a null-check.
 557      *
 558      * The created node is placed before {@code before} in the CFG.
 559      */
 560     protected ReadNode createReadArrayLength(ValueNode array, FixedNode before, LoweringTool tool) {
 561         StructuredGraph graph = array.graph();
 562         ValueNode canonicalArray = this.createNullCheckedValue(skipPiWhileNonNull(array), before, tool);
 563         AddressNode address = createOffsetAddress(graph, canonicalArray, arrayLengthOffset());
 564         ReadNode readArrayLength = graph.add(new ReadNode(address, ARRAY_LENGTH_LOCATION, StampFactory.positiveInt(), BarrierType.NONE));
 565         graph.addBeforeFixed(before, readArrayLength);
 566         return readArrayLength;
 567     }
 568 
 569     protected void lowerLoadHubNode(LoadHubNode loadHub, LoweringTool tool) {
 570         StructuredGraph graph = loadHub.graph();
 571         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 572             return;
 573         }
 574         if (graph.getGuardsStage().allowsFloatingGuards()) {
 575             return;
 576         }
 577         ValueNode hub = createReadHub(graph, loadHub.getValue(), tool);
 578         loadHub.replaceAtUsagesAndDelete(hub);
 579     }
 580 
 581     protected void lowerLoadHubOrNullNode(LoadHubOrNullNode loadHubOrNullNode, LoweringTool tool) {
 582         StructuredGraph graph = loadHubOrNullNode.graph();
 583         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
 584             return;
 585         }
 586         if (graph.getGuardsStage().allowsFloatingGuards()) {
 587             return;
 588         }
 589         final FixedWithNextNode predecessor = tool.lastFixedNode();
 590         final ValueNode value = loadHubOrNullNode.getValue();
 591         AbstractPointerStamp stamp = (AbstractPointerStamp) value.stamp(NodeView.DEFAULT);
 592         final LogicNode isNull = graph.addOrUniqueWithInputs(IsNullNode.create(value));
 593         final EndNode trueEnd = graph.add(new EndNode());
 594         final EndNode falseEnd = graph.add(new EndNode());
 595         final IfNode ifNode = graph.add(new IfNode(isNull, trueEnd, falseEnd, 0.5));
 596         final MergeNode merge = graph.add(new MergeNode());
 597         merge.addForwardEnd(trueEnd);
 598         merge.addForwardEnd(falseEnd);
 599         final AbstractPointerStamp hubStamp = (AbstractPointerStamp) loadHubOrNullNode.stamp(NodeView.DEFAULT);
 600         ValueNode nullHub = ConstantNode.forConstant(hubStamp.asAlwaysNull(), JavaConstant.NULL_POINTER, tool.getMetaAccess(), graph);
 601         final ValueNode nonNullValue = graph.addOrUniqueWithInputs(PiNode.create(value, stamp.asNonNull(), ifNode.falseSuccessor()));
 602         ValueNode hub = createReadHub(graph, nonNullValue, tool);
 603         ValueNode[] values = new ValueNode[]{nullHub, hub};
 604         final PhiNode hubPhi = graph.unique(new ValuePhiNode(hubStamp, merge, values));
 605         final FixedNode oldNext = predecessor.next();
 606         predecessor.setNext(ifNode);
 607         merge.setNext(oldNext);
 608         loadHubOrNullNode.replaceAtUsagesAndDelete(hubPhi);
 609     }
 610 
 611     protected void lowerLoadArrayComponentHubNode(LoadArrayComponentHubNode loadHub) {
 612         StructuredGraph graph = loadHub.graph();
 613         ValueNode hub = createReadArrayComponentHub(graph, loadHub.getValue(), loadHub);
 614         graph.replaceFixed(loadHub, hub);
 615     }
 616 
 617     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 618         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 619         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
<a name="8" id="anc8"></a><span class="line-modified"> 620         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId(), monitorEnter.isBiasable()));</span>
 621         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 622         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 623         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 624     }
 625 
 626     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 627         StructuredGraph graph = cas.graph();
 628         JavaKind valueKind = cas.getValueKind();
 629 
 630         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 631         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 632 
 633         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 634         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
 635         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));
 636         atomicNode.setStateAfter(cas.stateAfter());
 637         graph.replaceFixedWithFixed(cas, atomicNode);
 638     }
 639 
 640     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
 641         StructuredGraph graph = cas.graph();
 642         JavaKind valueKind = cas.getValueKind();
 643 
 644         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 645         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 646 
 647         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
 648         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);
 649         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getKilledLocationIdentity(), barrierType));
 650         ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
 651         atomicNode.setStateAfter(cas.stateAfter());
 652         cas.replaceAtUsages(coercedNode);
 653         graph.replaceFixedWithFixed(cas, atomicNode);
 654     }
 655 
 656     protected void lowerAtomicReadAndWriteNode(AtomicReadAndWriteNode n) {
 657         StructuredGraph graph = n.graph();
 658         JavaKind valueKind = n.getValueKind();
 659 
 660         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 661 
 662         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
 663         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());
 664         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
 665         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));
 666         memoryRead.setStateAfter(n.stateAfter());
 667 
 668         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 669         n.stateAfter().replaceFirstInput(n, memoryRead);
 670         n.replaceAtUsages(readValue);
 671         graph.replaceFixedWithFixed(n, memoryRead);
 672     }
 673 
 674     /**
 675      * @param tool utility for performing the lowering
 676      */
 677     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<a name="9" id="anc9"></a><span class="line-modified"> 678         PlatformConfigurationProvider gc = tool.getProviders().getPlatformConfigurationProvider();</span>
 679         StructuredGraph graph = load.graph();
 680         if (load instanceof GuardedUnsafeLoadNode) {
 681             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 682             GuardingNode guard = guardedLoad.getGuard();
 683             if (guard == null) {
 684                 // can float freely if the guard folded away
 685                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 686                 memoryRead.setForceFixed(false);
 687                 graph.replaceFixedWithFixed(load, memoryRead);
 688             } else {
 689                 // must be guarded, but flows below the guard
 690                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);
 691                 graph.replaceFixedWithFixed(load, memoryRead);
 692             }
 693         } else {
 694             // never had a guarding condition so it must be fixed, creation of the read will force
 695             // it to be fixed
 696             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);
 697             graph.replaceFixedWithFixed(load, memoryRead);
 698         }
 699     }
 700 
 701     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 702         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 703             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 704         } else {
 705             return graph.unique(new OffsetAddressNode(object, offset));
 706         }
 707     }
 708 
<a name="10" id="anc10"></a><span class="line-modified"> 709     protected ReadNode createUnsafeRead(PlatformConfigurationProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 710         boolean compressible = load.accessKind() == JavaKind.Object;
 711         JavaKind readKind = load.accessKind();
 712         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 713         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
 714         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));
 715         if (guard == null) {
 716             // An unsafe read must not float otherwise it may float above
 717             // a test guaranteeing the read is safe.
 718             memoryRead.setForceFixed(true);
 719         } else {
 720             memoryRead.setGuard(guard);
 721         }
 722         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 723         load.replaceAtUsages(readValue);
 724         return memoryRead;
 725     }
 726 
 727     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 728         StructuredGraph graph = load.graph();
 729         JavaKind readKind = load.getKind();
 730         assert readKind != JavaKind.Object;
 731         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, false);
 732         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(load.getAddress()));
 733         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));
 734         // An unsafe read must not float otherwise it may float above
 735         // a test guaranteeing the read is safe.
 736         memoryRead.setForceFixed(true);
 737         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, false), readKind);
 738         load.replaceAtUsages(readValue);
 739         graph.replaceFixedWithFixed(load, memoryRead);
 740     }
 741 
 742     private static ValueNode performBooleanCoercionIfNecessary(ValueNode readValue, JavaKind readKind) {
 743         if (readKind == JavaKind.Boolean) {
 744             StructuredGraph graph = readValue.graph();
 745             IntegerEqualsNode eq = graph.addOrUnique(new IntegerEqualsNode(readValue, ConstantNode.forInt(0, graph)));
 746             return graph.addOrUnique(new ConditionalNode(eq, ConstantNode.forBoolean(false, graph), ConstantNode.forBoolean(true, graph)));
 747         }
 748         return readValue;
 749     }
 750 
 751     protected void lowerUnsafeStoreNode(RawStoreNode store) {
 752         StructuredGraph graph = store.graph();
 753         boolean compressible = store.value().getStackKind() == JavaKind.Object;
 754         JavaKind valueKind = store.accessKind();
 755         ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
 756         AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
 757         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, unsafeStoreBarrierType(store), false));
 758         write.setStateAfter(store.stateAfter());
 759         graph.replaceFixedWithFixed(store, write);
 760     }
 761 
 762     protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
 763         StructuredGraph graph = store.graph();
 764         assert store.getValue().getStackKind() != JavaKind.Object;
 765         JavaKind valueKind = store.getKind();
 766         ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
 767         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
 768         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, BarrierType.NONE, false));
 769         write.setStateAfter(store.stateAfter());
 770         graph.replaceFixedWithFixed(store, write);
 771     }
 772 
 773     protected void lowerJavaReadNode(JavaReadNode read) {
 774         StructuredGraph graph = read.graph();
 775         JavaKind valueKind = read.getReadKind();
 776         Stamp loadStamp = loadStamp(read.stamp(NodeView.DEFAULT), valueKind, read.isCompressible());
 777 
 778         ReadNode memoryRead = graph.add(new ReadNode(read.getAddress(), read.getLocationIdentity(), loadStamp, read.getBarrierType()));
 779         GuardingNode guard = read.getGuard();
 780         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead, read.isCompressible());
 781         if (guard == null) {
 782             // An unsafe read must not float otherwise it may float above
 783             // a test guaranteeing the read is safe.
 784             memoryRead.setForceFixed(true);
 785         } else {
 786             memoryRead.setGuard(guard);
 787         }
 788         read.replaceAtUsages(readValue);
 789         graph.replaceFixed(read, memoryRead);
 790     }
 791 
 792     protected void lowerJavaWriteNode(JavaWriteNode write) {
 793         StructuredGraph graph = write.graph();
 794         ValueNode value = implicitStoreConvert(graph, write.getWriteKind(), write.value(), write.isCompressible());
 795         WriteNode memoryWrite = graph.add(new WriteNode(write.getAddress(), write.getKilledLocationIdentity(), value, write.getBarrierType(), false));
 796         memoryWrite.setStateAfter(write.stateAfter());
 797         graph.replaceFixedWithFixed(write, memoryWrite);
 798         memoryWrite.setGuard(write.getGuard());
 799     }
 800 
 801     @SuppressWarnings(&quot;try&quot;)
 802     protected void lowerCommitAllocationNode(CommitAllocationNode commit, LoweringTool tool) {
 803         StructuredGraph graph = commit.graph();
 804         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
 805             List&lt;AbstractNewObjectNode&gt; recursiveLowerings = new ArrayList&lt;&gt;();
 806 
 807             ValueNode[] allocations = new ValueNode[commit.getVirtualObjects().size()];
 808             BitSet omittedValues = new BitSet();
 809             int valuePos = 0;
 810             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 811                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 812                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 813                     int entryCount = virtual.entryCount();
 814                     AbstractNewObjectNode newObject;
 815                     if (virtual instanceof VirtualInstanceNode) {
 816                         newObject = graph.add(createNewInstanceFromVirtual(virtual));
 817                     } else {
 818                         newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
 819                     }
 820                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects
 821                     newObject.clearEmitMemoryBarrier();
 822 
 823                     recursiveLowerings.add(newObject);
 824                     graph.addBeforeFixed(commit, newObject);
 825                     allocations[objIndex] = newObject;
 826                     for (int i = 0; i &lt; entryCount; i++) {
 827                         ValueNode value = commit.getValues().get(valuePos);
 828                         if (value instanceof VirtualObjectNode) {
 829                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 830                         }
 831                         if (value == null) {
 832                             omittedValues.set(valuePos);
 833                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 834                             // Constant.illegal is always the defaultForKind, so it is skipped
 835                             JavaKind valueKind = value.getStackKind();
 836                             JavaKind entryKind = virtual.entryKind(i);
 837 
 838                             // Truffle requires some leniency in terms of what can be put where:
 839                             assert valueKind.getStackKind() == entryKind.getStackKind() ||
<a name="11" id="anc11"></a><span class="line-modified"> 840                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode) ||</span>
<span class="line-added"> 841                                                             (valueKind == JavaKind.Float &amp;&amp; virtual instanceof VirtualArrayNode));</span>
 842                             AddressNode address = null;
 843                             BarrierType barrierType = null;
 844                             if (virtual instanceof VirtualInstanceNode) {
 845                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 846                                 long offset = fieldOffset(field);
 847                                 if (offset &gt;= 0) {
 848                                     address = createOffsetAddress(graph, newObject, offset);
 849                                     barrierType = fieldInitializationBarrier(entryKind);
 850                                 }
 851                             } else {
 852                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
 853                                 barrierType = arrayInitializationBarrier(entryKind);
 854                             }
 855                             if (address != null) {
<a name="12" id="anc12"></a><span class="line-modified"> 856                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), arrayImplicitStoreConvert(graph, entryKind, value, commit, virtual, valuePos), barrierType, false);</span>
 857                                 graph.addAfterFixed(newObject, graph.add(write));
 858                             }
 859                         }
 860                         valuePos++;
 861                     }
 862                 }
 863             }
 864             valuePos = 0;
 865 
 866             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 867                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 868                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 869                     int entryCount = virtual.entryCount();
 870                     ValueNode newObject = allocations[objIndex];
 871                     for (int i = 0; i &lt; entryCount; i++) {
 872                         if (omittedValues.get(valuePos)) {
 873                             ValueNode value = commit.getValues().get(valuePos);
 874                             assert value instanceof VirtualObjectNode;
 875                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 876                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
 877                                 assert virtual.entryKind(i) == JavaKind.Object &amp;&amp; allocValue.getStackKind() == JavaKind.Object;
 878                                 AddressNode address;
 879                                 BarrierType barrierType;
 880                                 if (virtual instanceof VirtualInstanceNode) {
 881                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
 882                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));
 883                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));
 884                                 } else {
 885                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
 886                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));
 887                                 }
 888                                 if (address != null) {
 889                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);
 890                                     graph.addBeforeFixed(commit, graph.add(write));
 891                                 }
 892                             }
 893                         }
 894                         valuePos++;
 895                     }
 896                 }
 897             }
 898 
<a name="13" id="anc13"></a><span class="line-modified"> 899             finishAllocatedObjects(tool, commit, commit, allocations);</span>
 900             graph.removeFixed(commit);
 901 
 902             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 903                 recursiveLowering.lower(tool);
 904             }
 905         }
 906 
 907     }
 908 
 909     public NewInstanceNode createNewInstanceFromVirtual(VirtualObjectNode virtual) {
 910         return new NewInstanceNode(virtual.type(), true);
 911     }
 912 
 913     protected NewArrayNode createNewArrayFromVirtual(VirtualObjectNode virtual, ValueNode length) {
 914         return new NewArrayNode(((VirtualArrayNode) virtual).componentType(), length, true);
 915     }
 916 
<a name="14" id="anc14"></a><span class="line-modified"> 917     public void finishAllocatedObjects(LoweringTool tool, FixedWithNextNode insertAfter, CommitAllocationNode commit, ValueNode[] allocations) {</span>
<span class="line-added"> 918         FixedWithNextNode insertionPoint = insertAfter;</span>
 919         StructuredGraph graph = commit.graph();
 920         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 921             FixedValueAnchorNode anchor = graph.add(new FixedValueAnchorNode(allocations[objIndex]));
 922             allocations[objIndex] = anchor;
<a name="15" id="anc15"></a><span class="line-modified"> 923             graph.addAfterFixed(insertionPoint, anchor);</span>
<span class="line-added"> 924             insertionPoint = anchor;</span>
 925         }
 926         /*
 927          * Note that the FrameState that is assigned to these MonitorEnterNodes isn&#39;t the correct
 928          * state. It will be the state from before the allocation occurred instead of a valid state
 929          * after the locking is performed. In practice this should be fine since these are newly
 930          * allocated objects. The bytecodes themselves permit allocating an object, doing a
 931          * monitorenter and then dropping all references to the object which would produce the same
 932          * state, though that would normally produce an IllegalMonitorStateException. In HotSpot
 933          * some form of fast path locking should always occur so the FrameState should never
 934          * actually be used.
 935          */
 936         ArrayList&lt;MonitorEnterNode&gt; enters = null;
 937         for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 938             List&lt;MonitorIdNode&gt; locks = commit.getLocks(objIndex);
 939             if (locks.size() &gt; 1) {
 940                 // Ensure that the lock operations are performed in lock depth order
 941                 ArrayList&lt;MonitorIdNode&gt; newList = new ArrayList&lt;&gt;(locks);
 942                 newList.sort((a, b) -&gt; Integer.compare(a.getLockDepth(), b.getLockDepth()));
 943                 locks = newList;
 944             }
 945             int lastDepth = -1;
 946             for (MonitorIdNode monitorId : locks) {
 947                 assert lastDepth &lt; monitorId.getLockDepth();
 948                 lastDepth = monitorId.getLockDepth();
 949                 MonitorEnterNode enter = graph.add(new MonitorEnterNode(allocations[objIndex], monitorId));
<a name="16" id="anc16"></a><span class="line-modified"> 950                 graph.addAfterFixed(insertionPoint, enter);</span>
<span class="line-added"> 951                 insertionPoint = enter;</span>
 952                 if (enters == null) {
 953                     enters = new ArrayList&lt;&gt;();
 954                 }
 955                 enters.add(enter);
 956             }
 957         }
 958         for (Node usage : commit.usages().snapshot()) {
 959             if (usage instanceof AllocatedObjectNode) {
 960                 AllocatedObjectNode addObject = (AllocatedObjectNode) usage;
 961                 int index = commit.getVirtualObjects().indexOf(addObject.getVirtualObject());
 962                 addObject.replaceAtUsagesAndDelete(allocations[index]);
 963             } else {
 964                 assert enters != null;
 965                 commit.replaceAtUsages(InputType.Memory, enters.get(enters.size() - 1));
 966             }
 967         }
 968         if (enters != null) {
 969             for (MonitorEnterNode enter : enters) {
 970                 enter.lower(tool);
 971             }
 972         }
 973         assert commit.hasNoUsages();
<a name="17" id="anc17"></a><span class="line-modified"> 974         insertAllocationBarrier(insertAfter, commit, graph);</span>
 975     }
 976 
 977     /**
 978      * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
 979      * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
 980      * are being written, as if {@link FinalFieldBarrierNode} were emitted.
 981      */
<a name="18" id="anc18"></a><span class="line-modified"> 982     private static void insertAllocationBarrier(FixedWithNextNode insertAfter, CommitAllocationNode commit, StructuredGraph graph) {</span>
 983         int barrier = MemoryBarriers.STORE_STORE;
 984         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 985             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 986                 if (field.isFinal()) {
 987                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 988                     break outer;
 989                 }
 990             }
 991         }
<a name="19" id="anc19"></a><span class="line-modified"> 992         graph.addAfterFixed(insertAfter, graph.add(new MembarNode(barrier, LocationIdentity.init())));</span>
 993     }
 994 
 995     /**
 996      * @param field the field whose barrier type should be returned
 997      */
<a name="20" id="anc20"></a><span class="line-modified"> 998     public BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
 999         return BarrierType.NONE;
1000     }
1001 
<a name="21" id="anc21"></a><span class="line-modified">1002     public BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
1003         if (getStorageKind(field) == JavaKind.Object) {
1004             return BarrierType.FIELD;
1005         }
1006         return BarrierType.NONE;
1007     }
1008 
<a name="22" id="anc22"></a><span class="line-modified">1009     public BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
1010         if (elementKind == JavaKind.Object) {
1011             return BarrierType.ARRAY;
1012         }
1013         return BarrierType.NONE;
1014     }
1015 
1016     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {
1017         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;
1018     }
1019 
1020     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {
1021         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;
1022     }
1023 
1024     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {
1025         if (!store.needsBarrier()) {
1026             return BarrierType.NONE;
1027         }
1028         return guessStoreBarrierType(store.object(), store.value());
1029     }
1030 
1031     private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
1032         if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {
1033             ResolvedJavaType type = StampTool.typeOrNull(object);
1034             // Array types must use a precise barrier, so if the type is unknown or is a supertype
1035             // of Object[] then treat it as an array.
1036             if (type != null &amp;&amp; type.isArray()) {
1037                 return BarrierType.ARRAY;
1038             } else if (type == null || type.isAssignableFrom(objectArrayType)) {
1039                 return BarrierType.UNKNOWN;
1040             } else {
1041                 return BarrierType.FIELD;
1042             }
1043         }
1044         return BarrierType.NONE;
1045     }
1046 
1047     public abstract int fieldOffset(ResolvedJavaField field);
1048 
1049     public FieldLocationIdentity fieldLocationIdentity(ResolvedJavaField field) {
1050         return new FieldLocationIdentity(field);
1051     }
1052 
1053     public abstract ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField field);
1054 
1055     public abstract int arrayLengthOffset();
1056 
1057     public Stamp loadStamp(Stamp stamp, JavaKind kind) {
1058         return loadStamp(stamp, kind, true);
1059     }
1060 
1061     private boolean useCompressedOops(JavaKind kind, boolean compressible) {
1062         return kind == JavaKind.Object &amp;&amp; compressible &amp;&amp; useCompressedOops;
1063     }
1064 
1065     protected abstract Stamp loadCompressedStamp(ObjectStamp stamp);
1066 
1067     /**
1068      * @param compressible whether the stamp should be compressible
1069      */
1070     protected Stamp loadStamp(Stamp stamp, JavaKind kind, boolean compressible) {
1071         if (useCompressedOops(kind, compressible)) {
1072             return loadCompressedStamp((ObjectStamp) stamp);
1073         }
1074 
1075         switch (kind) {
1076             case Boolean:
1077             case Byte:
1078                 return IntegerStamp.OPS.getNarrow().foldStamp(32, 8, stamp);
1079             case Char:
1080             case Short:
1081                 return IntegerStamp.OPS.getNarrow().foldStamp(32, 16, stamp);
1082         }
1083         return stamp;
1084     }
1085 
1086     public final ValueNode implicitLoadConvert(StructuredGraph graph, JavaKind kind, ValueNode value) {
1087         return implicitLoadConvert(graph, kind, value, true);
1088     }
1089 
1090     public ValueNode implicitLoadConvert(JavaKind kind, ValueNode value) {
1091         return implicitLoadConvert(kind, value, true);
1092     }
1093 
1094     protected final ValueNode implicitLoadConvert(StructuredGraph graph, JavaKind kind, ValueNode value, boolean compressible) {
1095         ValueNode ret = implicitLoadConvert(kind, value, compressible);
1096         if (!ret.isAlive()) {
1097             ret = graph.addOrUnique(ret);
1098         }
1099         return ret;
1100     }
1101 
1102     protected abstract ValueNode newCompressionNode(CompressionOp op, ValueNode value);
1103 
1104     /**
1105      * @param compressible whether the convert should be compressible
1106      */
1107     protected ValueNode implicitLoadConvert(JavaKind kind, ValueNode value, boolean compressible) {
1108         if (useCompressedOops(kind, compressible)) {
1109             return newCompressionNode(CompressionOp.Uncompress, value);
1110         }
1111 
1112         switch (kind) {
1113             case Byte:
1114             case Short:
1115                 return new SignExtendNode(value, 32);
1116             case Boolean:
1117             case Char:
1118                 return new ZeroExtendNode(value, 32);
1119         }
1120         return value;
1121     }
1122 
<a name="23" id="anc23"></a><span class="line-added">1123     public ValueNode arrayImplicitStoreConvert(StructuredGraph graph,</span>
<span class="line-added">1124                     JavaKind entryKind,</span>
<span class="line-added">1125                     ValueNode value,</span>
<span class="line-added">1126                     CommitAllocationNode commit,</span>
<span class="line-added">1127                     VirtualObjectNode virtual,</span>
<span class="line-added">1128                     int valuePos) {</span>
<span class="line-added">1129         if (!virtual.isVirtualByteArray()) {</span>
<span class="line-added">1130             return implicitStoreConvert(graph, entryKind, value);</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         // A virtual entry in a byte array can span multiple bytes. This shortens the entry to fit</span>
<span class="line-added">1133         // in its declared size.</span>
<span class="line-added">1134         int entryIndex = valuePos + 1;</span>
<span class="line-added">1135         int bytes = 1;</span>
<span class="line-added">1136         while (entryIndex &lt; commit.getValues().size() &amp;&amp; commit.getValues().get(entryIndex).isIllegalConstant()) {</span>
<span class="line-added">1137             bytes++;</span>
<span class="line-added">1138             entryIndex++;</span>
<span class="line-added">1139         }</span>
<span class="line-added">1140         assert bytes &lt;= value.getStackKind().getByteCount();</span>
<span class="line-added">1141         ValueNode entry = value;</span>
<span class="line-added">1142         if (value.getStackKind() == JavaKind.Float) {</span>
<span class="line-added">1143             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Int, entry, NodeView.DEFAULT));</span>
<span class="line-added">1144         } else if (value.getStackKind() == JavaKind.Double) {</span>
<span class="line-added">1145             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Long, entry, NodeView.DEFAULT));</span>
<span class="line-added">1146         }</span>
<span class="line-added">1147         if (bytes &lt; value.getStackKind().getByteCount()) {</span>
<span class="line-added">1148             entry = graph.unique(new NarrowNode(entry, bytes &lt;&lt; 3));</span>
<span class="line-added">1149         }</span>
<span class="line-added">1150         return entry;</span>
<span class="line-added">1151     }</span>
<span class="line-added">1152 </span>
1153     public final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value) {
1154         return implicitStoreConvert(graph, kind, value, true);
1155     }
1156 
1157     public ValueNode implicitStoreConvert(JavaKind kind, ValueNode value) {
1158         return implicitStoreConvert(kind, value, true);
1159     }
1160 
1161     protected final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value, boolean compressible) {
1162         ValueNode ret = implicitStoreConvert(kind, value, compressible);
1163         if (!ret.isAlive()) {
1164             ret = graph.addOrUnique(ret);
1165         }
1166         return ret;
1167     }
1168 
1169     /**
1170      * @param compressible whether the covert should be compressible
1171      */
1172     protected ValueNode implicitStoreConvert(JavaKind kind, ValueNode value, boolean compressible) {
1173         if (useCompressedOops(kind, compressible)) {
1174             return newCompressionNode(CompressionOp.Compress, value);
1175         }
1176 
1177         switch (kind) {
1178             case Boolean:
1179             case Byte:
1180                 return new NarrowNode(value, 8);
1181             case Char:
1182             case Short:
1183                 return new NarrowNode(value, 16);
1184         }
1185         return value;
1186     }
1187 
1188     protected abstract ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool);
1189 
1190     protected abstract ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor);
1191 
1192     protected ValueNode proxyIndex(AccessIndexedNode n, ValueNode index, ValueNode array, LoweringTool tool) {
1193         StructuredGraph graph = index.graph();
1194         ValueNode arrayLength = readOrCreateArrayLength(n, array, tool, graph);
1195         ValueNode lengthMinusOne = SubNode.create(arrayLength, ConstantNode.forInt(1), NodeView.DEFAULT);
1196         return branchlessMax(branchlessMin(index, lengthMinusOne, NodeView.DEFAULT), ConstantNode.forInt(0), NodeView.DEFAULT);
1197     }
1198 
1199     protected GuardingNode getBoundsCheck(AccessIndexedNode n, ValueNode array, LoweringTool tool) {
1200         if (n.getBoundsCheck() != null) {
1201             return n.getBoundsCheck();
1202         }
1203 
1204         StructuredGraph graph = n.graph();
1205         ValueNode arrayLength = readOrCreateArrayLength(n, array, tool, graph);
1206 
1207         LogicNode boundsCheck = IntegerBelowNode.create(n.index(), arrayLength, NodeView.DEFAULT);
1208         if (boundsCheck.isTautology()) {
1209             return null;
1210         }
1211         return tool.createGuard(n, graph.addOrUniqueWithInputs(boundsCheck), BoundsCheckException, InvalidateReprofile);
1212     }
1213 
1214     private ValueNode readOrCreateArrayLength(AccessIndexedNode n, ValueNode array, LoweringTool tool, StructuredGraph graph) {
1215         ValueNode arrayLength = readArrayLength(array, tool.getConstantReflection());
1216         if (arrayLength == null) {
1217             arrayLength = createReadArrayLength(array, n, tool);
1218         } else {
1219             arrayLength = arrayLength.isAlive() ? arrayLength : graph.addOrUniqueWithInputs(arrayLength);
1220         }
1221         return arrayLength;
1222     }
1223 
1224     protected GuardingNode createNullCheck(ValueNode object, FixedNode before, LoweringTool tool) {
1225         if (StampTool.isPointerNonNull(object)) {
1226             return null;
1227         }
1228         return tool.createGuard(before, before.graph().unique(IsNullNode.create(object)), NullCheckException, InvalidateReprofile, SpeculationLog.NO_SPECULATION, true, null);
1229     }
1230 
1231     protected ValueNode createNullCheckedValue(ValueNode object, FixedNode before, LoweringTool tool) {
1232         GuardingNode nullCheck = createNullCheck(object, before, tool);
1233         if (nullCheck == null) {
1234             return object;
1235         }
1236         return before.graph().maybeAddOrUnique(PiNode.create(object, (object.stamp(NodeView.DEFAULT)).join(StampFactory.objectNonNull()), (ValueNode) nullCheck));
1237     }
1238 
1239     @Override
1240     public ValueNode reconstructArrayIndex(JavaKind elementKind, AddressNode address) {
1241         StructuredGraph graph = address.graph();
1242         ValueNode offset = ((OffsetAddressNode) address).getOffset();
1243 
1244         int base = metaAccess.getArrayBaseOffset(elementKind);
1245         ValueNode scaledIndex = graph.unique(new SubNode(offset, ConstantNode.forIntegerStamp(offset.stamp(NodeView.DEFAULT), base, graph)));
1246 
1247         int shift = CodeUtil.log2(metaAccess.getArrayIndexScale(elementKind));
1248         ValueNode ret = graph.unique(new RightShiftNode(scaledIndex, ConstantNode.forInt(shift, graph)));
1249         return IntegerConvertNode.convert(ret, StampFactory.forKind(JavaKind.Int), graph, NodeView.DEFAULT);
1250     }
1251 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
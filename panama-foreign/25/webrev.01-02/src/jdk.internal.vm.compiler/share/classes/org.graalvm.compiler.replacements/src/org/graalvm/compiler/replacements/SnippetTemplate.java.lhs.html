<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static java.util.FormattableFlags.ALTERNATE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
  30 import static org.graalvm.compiler.debug.DebugContext.applyFormattingFlagsAndWidth;
  31 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
  32 import static org.graalvm.compiler.graph.iterators.NodePredicates.isNotA;
  33 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
  34 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
  35 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
  36 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
  37 
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Method;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Collections;
  44 import java.util.Formattable;
  45 import java.util.Formatter;
  46 import java.util.LinkedHashMap;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.atomic.AtomicInteger;
  50 import java.util.concurrent.atomic.AtomicReference;
  51 import java.util.function.Predicate;
  52 
  53 import jdk.internal.vm.compiler.collections.EconomicMap;
  54 import jdk.internal.vm.compiler.collections.EconomicSet;
  55 import jdk.internal.vm.compiler.collections.Equivalence;
  56 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  57 import org.graalvm.compiler.api.replacements.Fold;
  58 import org.graalvm.compiler.api.replacements.Snippet;
  59 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  60 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
  61 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  62 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  63 import org.graalvm.compiler.core.common.GraalOptions;
  64 import org.graalvm.compiler.core.common.type.Stamp;
  65 import org.graalvm.compiler.core.common.type.StampFactory;
  66 import org.graalvm.compiler.core.common.type.StampPair;
  67 import org.graalvm.compiler.core.common.type.TypeReference;
  68 import org.graalvm.compiler.debug.Assertions;
  69 import org.graalvm.compiler.debug.CounterKey;
  70 import org.graalvm.compiler.debug.DebugCloseable;
  71 import org.graalvm.compiler.debug.DebugContext;
  72 import org.graalvm.compiler.debug.DebugContext.Description;
  73 import org.graalvm.compiler.debug.DebugHandlersFactory;
  74 import org.graalvm.compiler.debug.GraalError;
  75 import org.graalvm.compiler.debug.TimerKey;
  76 import org.graalvm.compiler.graph.Graph.Mark;
  77 import org.graalvm.compiler.graph.Node;
  78 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  79 import org.graalvm.compiler.graph.NodeClass;
  80 import org.graalvm.compiler.graph.NodeSourcePosition;
  81 import org.graalvm.compiler.graph.Position;
  82 import org.graalvm.compiler.loop.LoopEx;
  83 import org.graalvm.compiler.loop.LoopsData;
  84 import org.graalvm.compiler.loop.phases.LoopTransformations;
  85 import org.graalvm.compiler.nodeinfo.InputType;
  86 import org.graalvm.compiler.nodeinfo.NodeInfo;
  87 import org.graalvm.compiler.nodes.AbstractBeginNode;
  88 import org.graalvm.compiler.nodes.AbstractMergeNode;
  89 import org.graalvm.compiler.nodes.ConstantNode;
  90 import org.graalvm.compiler.nodes.ControlSinkNode;
  91 import org.graalvm.compiler.nodes.DeoptimizingNode;
  92 import org.graalvm.compiler.nodes.FixedNode;
  93 import org.graalvm.compiler.nodes.FixedWithNextNode;
  94 import org.graalvm.compiler.nodes.FrameState;
  95 import org.graalvm.compiler.nodes.InliningLog;
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<a name="2" id="anc2"></a><span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
<a name="3" id="anc3"></a>

 121 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 122 import org.graalvm.compiler.nodes.spi.CoreProviders;
 123 import org.graalvm.compiler.nodes.spi.LoweringTool;
 124 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 125 import org.graalvm.compiler.nodes.util.GraphUtil;
 126 import org.graalvm.compiler.options.Option;
 127 import org.graalvm.compiler.options.OptionKey;
 128 import org.graalvm.compiler.options.OptionValues;
 129 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 130 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 131 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 133 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 134 import org.graalvm.compiler.phases.common.LoweringPhase;
 135 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 136 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 137 import org.graalvm.compiler.phases.util.Providers;
 138 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 139 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 140 import org.graalvm.util.CollectionsUtil;
 141 import jdk.internal.vm.compiler.word.LocationIdentity;
 142 import jdk.internal.vm.compiler.word.WordBase;
 143 
 144 import jdk.vm.ci.code.TargetDescription;
 145 import jdk.vm.ci.meta.Constant;
 146 import jdk.vm.ci.meta.ConstantReflectionProvider;
 147 import jdk.vm.ci.meta.JavaConstant;
 148 import jdk.vm.ci.meta.JavaKind;
 149 import jdk.vm.ci.meta.Local;
 150 import jdk.vm.ci.meta.LocalVariableTable;
 151 import jdk.vm.ci.meta.MetaAccessProvider;
 152 import jdk.vm.ci.meta.ResolvedJavaMethod;
 153 import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter;
 154 import jdk.vm.ci.meta.ResolvedJavaType;
 155 import jdk.vm.ci.meta.Signature;
 156 
 157 /**
 158  * A snippet template is a graph created by parsing a snippet method and then specialized by binding
 159  * constants to the snippet&#39;s {@link ConstantParameter} parameters.
 160  *
 161  * Snippet templates can be managed in a cache maintained by {@link AbstractTemplates}.
 162  */
 163 public class SnippetTemplate {
 164 
 165     private boolean mayRemoveLocation = false;
 166 
 167     /**
 168      * Holds the {@link ResolvedJavaMethod} of the snippet, together with some information about the
 169      * method that needs to be computed only once. The {@link SnippetInfo} should be created once
 170      * per snippet and then cached.
 171      */
 172     public abstract static class SnippetInfo {
 173 
 174         protected final ResolvedJavaMethod method;
 175         protected final ResolvedJavaMethod original;
 176         protected final LocationIdentity[] privateLocations;
 177         protected final Object receiver;
 178 
 179         public Object getReceiver() {
 180             return receiver;
 181         }
 182 
 183         boolean hasReceiver() {
 184             assert hasReceiver(method) == (receiver != null) : &quot;Snippet with the receiver must have it set as constant. Snippet: &quot; + this;
 185             return hasReceiver(method);
 186         }
 187 
 188         static boolean hasReceiver(ResolvedJavaMethod method) {
 189             return method.hasReceiver();
 190         }
 191 
 192         /**
 193          * Lazily constructed parts of {@link SnippetInfo}.
 194          */
 195         static class Lazy {
 196             Lazy(ResolvedJavaMethod method) {
 197                 int count = method.getSignature().getParameterCount(hasReceiver(method));
 198                 constantParameters = new boolean[count];
 199                 varargsParameters = new boolean[count];
 200                 nonNullParameters = new boolean[count];
 201                 int offset = hasReceiver(method) ? 1 : 0;
 202                 for (int i = offset; i &lt; count; i++) {
 203                     constantParameters[i] = method.getParameterAnnotation(ConstantParameter.class, i - offset) != null;
 204                     varargsParameters[i] = method.getParameterAnnotation(VarargsParameter.class, i - offset) != null;
 205                     nonNullParameters[i] = method.getParameterAnnotation(NonNullParameter.class, i - offset) != null;
 206 
 207                     assert !constantParameters[i - offset] || !varargsParameters[i - offset] : &quot;Parameter cannot be annotated with both @&quot; + ConstantParameter.class.getSimpleName() + &quot; and @&quot; +
 208                                     VarargsParameter.class.getSimpleName();
 209                 }
 210                 if (method.hasReceiver()) {
 211                     // Receiver must be constant.
 212                     assert !constantParameters[0];
 213                     constantParameters[0] = true;
 214                 }
 215 
 216                 // Retrieve the names only when assertions are turned on. Parameter annotations are
 217                 // unsupported in the native image.
 218                 assert IS_IN_NATIVE_IMAGE || initNames(method, count);
 219             }
 220 
 221             final boolean[] constantParameters;
 222             final boolean[] varargsParameters;
 223             final boolean[] nonNullParameters;
 224 
 225             /**
 226              * The parameter names, taken from the local variables table. Only used for assertion
 227              * checking, so use only within an assert statement.
 228              */
 229             String[] names;
 230 
 231             private boolean initNames(ResolvedJavaMethod method, int parameterCount) {
 232                 names = new String[parameterCount];
 233                 int offset = 0;
 234                 if (method.hasReceiver()) {
 235                     names[0] = &quot;this&quot;;
 236                     offset = 1;
 237                 }
 238                 Parameter[] params = method.getParameters();
 239                 if (params != null) {
 240                     for (int i = offset; i &lt; names.length; i++) {
 241                         if (params[i - offset].isNamePresent()) {
 242                             names[i] = params[i - offset].getName();
 243                         }
 244                     }
 245                 } else {
 246                     int slotIdx = 0;
 247                     LocalVariableTable localVariableTable = method.getLocalVariableTable();
 248                     if (localVariableTable != null) {
 249                         for (int i = 0; i &lt; names.length; i++) {
 250                             Local local = localVariableTable.getLocal(slotIdx, 0);
 251                             if (local != null) {
 252                                 names[i] = local.getName();
 253                             }
 254                             JavaKind kind = method.getSignature().getParameterKind(i);
 255                             slotIdx += kind.getSlotCount();
 256                         }
 257                     }
 258                 }
 259                 return true;
 260             }
 261         }
 262 
 263         /**
 264          * Times instantiations of all templates derived from this snippet.
 265          */
 266         private final TimerKey instantiationTimer;
 267 
 268         /**
 269          * Counts instantiations of all templates derived from this snippet.
 270          */
 271         private final CounterKey instantiationCounter;
 272 
 273         protected abstract Lazy lazy();
 274 
 275         protected SnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 276             this.method = method;
 277             this.original = original;
 278             this.privateLocations = privateLocations;
 279             instantiationCounter = DebugContext.counter(&quot;SnippetInstantiationCount[%s]&quot;, method.getName());
 280             instantiationTimer = DebugContext.timer(&quot;SnippetInstantiationTime[%s]&quot;, method.getName());
 281             this.receiver = receiver;
 282         }
 283 
 284         public ResolvedJavaMethod getMethod() {
 285             return method;
 286         }
 287 
 288         public int getParameterCount() {
 289             return lazy().constantParameters.length;
 290         }
 291 
 292         public boolean isConstantParameter(int paramIdx) {
 293             return lazy().constantParameters[paramIdx];
 294         }
 295 
 296         public boolean isVarargsParameter(int paramIdx) {
 297             return lazy().varargsParameters[paramIdx];
 298         }
 299 
 300         public boolean isNonNullParameter(int paramIdx) {
 301             return lazy().nonNullParameters[paramIdx];
 302         }
 303 
 304         public String getParameterName(int paramIdx) {
 305             String[] names = lazy().names;
 306             if (names != null) {
 307                 return names[paramIdx];
 308             }
 309             return null;
 310         }
 311 
 312         @Override
 313         public String toString() {
 314             return getClass().getSimpleName() + &quot;:&quot; + method.format(&quot;%h.%n&quot;);
 315         }
 316     }
 317 
 318     protected static class LazySnippetInfo extends SnippetInfo {
 319         protected final AtomicReference&lt;Lazy&gt; lazy = new AtomicReference&lt;&gt;(null);
 320 
 321         protected LazySnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 322             super(method, original, privateLocations, receiver);
 323         }
 324 
 325         @Override
 326         protected Lazy lazy() {
 327             if (lazy.get() == null) {
 328                 lazy.compareAndSet(null, new Lazy(method));
 329             }
 330             return lazy.get();
 331         }
 332     }
 333 
 334     protected static class EagerSnippetInfo extends SnippetInfo {
 335         protected final Lazy lazy;
 336 
 337         protected EagerSnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 338             super(method, original, privateLocations, receiver);
 339             lazy = new Lazy(method);
 340         }
 341 
 342         @Override
 343         protected Lazy lazy() {
 344             return lazy;
 345         }
 346     }
 347 
 348     /**
 349      * Values that are bound to the snippet method parameters. The methods {@link #add},
 350      * {@link #addConst}, and {@link #addVarargs} must be called in the same order as in the
 351      * signature of the snippet method. The parameter name is passed to the add methods for
 352      * assertion checking, i.e., to enforce that the order matches. Which method needs to be called
 353      * depends on the annotation of the snippet method parameter:
 354      * &lt;ul&gt;
 355      * &lt;li&gt;Use {@link #add} for a parameter without an annotation. The value is bound when the
 356      * {@link SnippetTemplate} is {@link SnippetTemplate#instantiate instantiated}.
 357      * &lt;li&gt;Use {@link #addConst} for a parameter annotated with {@link ConstantParameter}. The value
 358      * is bound when the {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created}.
 359      * &lt;li&gt;Use {@link #addVarargs} for an array parameter annotated with {@link VarargsParameter}. A
 360      * separate {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created} for every
 361      * distinct array length. The actual values are bound when the {@link SnippetTemplate} is
 362      * {@link SnippetTemplate#instantiate instantiated}
 363      * &lt;/ul&gt;
 364      */
 365     public static class Arguments implements Formattable {
 366 
 367         protected final SnippetInfo info;
 368         protected final CacheKey cacheKey;
 369         protected final Object[] values;
 370         protected final Stamp[] constStamps;
 371         protected boolean cacheable;
 372 
 373         protected int nextParamIdx;
 374 
 375         public Arguments(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 376             this.info = info;
 377             this.cacheKey = new CacheKey(info, guardsStage, loweringStage);
 378             this.values = new Object[info.getParameterCount()];
 379             this.constStamps = new Stamp[info.getParameterCount()];
 380             this.cacheable = true;
 381             if (info.hasReceiver()) {
 382                 addConst(&quot;this&quot;, info.getReceiver());
 383             }
 384         }
 385 
 386         public Arguments add(String name, Object value) {
 387             assert check(name, false, false);
 388             values[nextParamIdx] = value;
 389             nextParamIdx++;
 390             return this;
 391         }
 392 
 393         public Arguments addConst(String name, Object value) {
 394             assert value != null;
 395             return addConst(name, value, null);
 396         }
 397 
 398         public Arguments addConst(String name, Object value, Stamp stamp) {
 399             assert check(name, true, false);
 400             values[nextParamIdx] = value;
 401             constStamps[nextParamIdx] = stamp;
 402             cacheKey.setParam(nextParamIdx, value);
 403             nextParamIdx++;
 404             return this;
 405         }
 406 
 407         public Arguments addVarargs(String name, Class&lt;?&gt; componentType, Stamp argStamp, Object value) {
 408             assert check(name, false, true);
 409             Varargs varargs = new Varargs(componentType, argStamp, value);
 410             values[nextParamIdx] = varargs;
 411             // A separate template is necessary for every distinct array length
 412             cacheKey.setParam(nextParamIdx, varargs.length);
 413             nextParamIdx++;
 414             return this;
 415         }
 416 
 417         public void setCacheable(boolean cacheable) {
 418             this.cacheable = cacheable;
 419         }
 420 
 421         private boolean check(String name, boolean constParam, boolean varargsParam) {
 422             assert nextParamIdx &lt; info.getParameterCount() : &quot;too many parameters: &quot; + name + &quot;  &quot; + this;
 423             assert info.getParameterName(nextParamIdx) == null || info.getParameterName(nextParamIdx).equals(name) : &quot;wrong parameter name at &quot; + nextParamIdx + &quot; : &quot; + name + &quot;  &quot; + this;
 424             assert constParam == info.isConstantParameter(nextParamIdx) : &quot;Parameter &quot; + (constParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + ConstantParameter.class.getSimpleName() + &quot;: &quot; + name +
 425                             &quot;  &quot; + this;
 426             assert varargsParam == info.isVarargsParameter(nextParamIdx) : &quot;Parameter &quot; + (varargsParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + VarargsParameter.class.getSimpleName() + &quot;: &quot; + name +
 427                             &quot;  &quot; + this;
 428             return true;
 429         }
 430 
 431         @Override
 432         public String toString() {
 433             StringBuilder result = new StringBuilder();
 434             result.append(&quot;Parameters&lt;&quot;).append(info.method.format(&quot;%h.%n&quot;)).append(&quot; [&quot;);
 435             String sep = &quot;&quot;;
 436             for (int i = 0; i &lt; info.getParameterCount(); i++) {
 437                 result.append(sep);
 438                 if (info.isConstantParameter(i)) {
 439                     result.append(&quot;const &quot;);
 440                 } else if (info.isVarargsParameter(i)) {
 441                     result.append(&quot;varargs &quot;);
 442                 }
 443                 result.append(info.getParameterName(i)).append(&quot; = &quot;).append(values[i]);
 444                 sep = &quot;, &quot;;
 445             }
 446             result.append(&quot;&gt;&quot;);
 447             return result.toString();
 448         }
 449 
 450         @Override
 451         public void formatTo(Formatter formatter, int flags, int width, int precision) {
 452             if ((flags &amp; ALTERNATE) == 0) {
 453                 formatter.format(applyFormattingFlagsAndWidth(toString(), flags, width));
 454             } else {
 455                 StringBuilder sb = new StringBuilder();
 456                 sb.append(info.method.getName()).append(&#39;(&#39;);
 457                 String sep = &quot;&quot;;
 458                 for (int i = 0; i &lt; info.getParameterCount(); i++) {
 459                     if (info.isConstantParameter(i)) {
 460                         sb.append(sep);
 461                         if (info.getParameterName(i) != null) {
 462                             sb.append(info.getParameterName(i));
 463                         } else {
 464                             sb.append(i);
 465                         }
 466                         sb.append(&#39;=&#39;).append(values[i]);
 467                         sep = &quot;, &quot;;
 468                     }
 469                 }
 470                 sb.append(&quot;)&quot;);
 471                 String string = sb.toString();
 472                 if (string.indexOf(&#39;%&#39;) != -1) {
 473                     // Quote any % signs
 474                     string = string.replace(&quot;%&quot;, &quot;%%&quot;);
 475                 }
 476                 formatter.format(applyFormattingFlagsAndWidth(string, flags &amp; ~ALTERNATE, width));
 477             }
 478         }
 479     }
 480 
 481     /**
 482      * Wrapper for the prototype value of a {@linkplain VarargsParameter varargs} parameter.
 483      */
 484     static class Varargs {
 485 
 486         protected final Class&lt;?&gt; componentType;
 487         protected final Stamp stamp;
 488         protected final Object value;
 489         protected final int length;
 490 
 491         protected Varargs(Class&lt;?&gt; componentType, Stamp stamp, Object value) {
 492             this.componentType = componentType;
 493             this.stamp = stamp;
 494             this.value = value;
 495             if (value instanceof List) {
 496                 this.length = ((List&lt;?&gt;) value).size();
 497             } else {
 498                 this.length = Array.getLength(value);
 499             }
 500         }
 501 
 502         @Override
 503         public String toString() {
 504             if (value instanceof boolean[]) {
 505                 return Arrays.toString((boolean[]) value);
 506             }
 507             if (value instanceof byte[]) {
 508                 return Arrays.toString((byte[]) value);
 509             }
 510             if (value instanceof char[]) {
 511                 return Arrays.toString((char[]) value);
 512             }
 513             if (value instanceof short[]) {
 514                 return Arrays.toString((short[]) value);
 515             }
 516             if (value instanceof int[]) {
 517                 return Arrays.toString((int[]) value);
 518             }
 519             if (value instanceof long[]) {
 520                 return Arrays.toString((long[]) value);
 521             }
 522             if (value instanceof float[]) {
 523                 return Arrays.toString((float[]) value);
 524             }
 525             if (value instanceof double[]) {
 526                 return Arrays.toString((double[]) value);
 527             }
 528             if (value instanceof Object[]) {
 529                 return Arrays.toString((Object[]) value);
 530             }
 531             return String.valueOf(value);
 532         }
 533     }
 534 
 535     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 536     static final class VarargsPlaceholderNode extends FloatingNode implements ArrayLengthProvider {
 537 
 538         public static final NodeClass&lt;VarargsPlaceholderNode&gt; TYPE = NodeClass.create(VarargsPlaceholderNode.class);
 539         protected final Varargs varargs;
 540 
 541         protected VarargsPlaceholderNode(Varargs varargs, MetaAccessProvider metaAccess) {
 542             super(TYPE, StampFactory.objectNonNull(TypeReference.createExactTrusted(metaAccess.lookupJavaType(varargs.componentType).getArrayClass())));
 543             this.varargs = varargs;
 544         }
 545 
 546         @Override
 547         public ValueNode findLength(FindLengthMode mode, ConstantReflectionProvider constantReflection) {
 548             return ConstantNode.forInt(varargs.length);
 549         }
 550     }
 551 
 552     static class CacheKey {
 553 
 554         private final ResolvedJavaMethod method;
 555         private final Object[] values;
 556         private final GuardsStage guardsStage;
 557         private final LoweringTool.LoweringStage loweringStage;
 558         private int hash;
 559 
 560         protected CacheKey(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 561             this.method = info.method;
 562             this.guardsStage = guardsStage;
 563             this.loweringStage = loweringStage;
 564             this.values = new Object[info.getParameterCount()];
 565             this.hash = info.method.hashCode() + 31 * guardsStage.ordinal();
 566         }
 567 
 568         protected void setParam(int paramIdx, Object value) {
 569             values[paramIdx] = value;
 570             hash = (hash * 31) ^ (value == null ? 0 : value.hashCode());
 571         }
 572 
 573         @Override
 574         public boolean equals(Object obj) {
 575             if (!(obj instanceof CacheKey)) {
 576                 return false;
 577             }
 578             CacheKey other = (CacheKey) obj;
 579             if (!method.equals(other.method)) {
 580                 return false;
 581             }
 582             if (guardsStage != other.guardsStage || loweringStage != other.loweringStage) {
 583                 return false;
 584             }
 585             for (int i = 0; i &lt; values.length; i++) {
 586                 if (values[i] != null &amp;&amp; !values[i].equals(other.values[i])) {
 587                     return false;
 588                 }
 589             }
 590             return true;
 591         }
 592 
 593         @Override
 594         public int hashCode() {
 595             return hash;
 596         }
 597     }
 598 
 599     private static final TimerKey SnippetTemplateCreationTime = DebugContext.timer(&quot;SnippetTemplateCreationTime&quot;);
 600     private static final CounterKey SnippetTemplates = DebugContext.counter(&quot;SnippetTemplateCount&quot;);
 601 
 602     static class Options {
 603         @Option(help = &quot;Use a LRU cache for snippet templates.&quot;)//
 604         public static final OptionKey&lt;Boolean&gt; UseSnippetTemplateCache = new OptionKey&lt;&gt;(true);
 605 
 606         @Option(help = &quot;&quot;)//
 607         static final OptionKey&lt;Integer&gt; MaxTemplatesPerSnippet = new OptionKey&lt;&gt;(50);
 608     }
 609 
 610     /**
 611      * Base class for snippet classes. It provides a cache for {@link SnippetTemplate}s.
 612      */
 613     public abstract static class AbstractTemplates implements org.graalvm.compiler.api.replacements.SnippetTemplateCache {
 614 
 615         protected final OptionValues options;
 616         protected final Providers providers;
 617         protected final SnippetReflectionProvider snippetReflection;
 618         protected final Iterable&lt;DebugHandlersFactory&gt; factories;
 619         protected final TargetDescription target;
 620         private final Map&lt;CacheKey, SnippetTemplate&gt; templates;
 621 
 622         protected AbstractTemplates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
 623             this.options = options;
 624             this.providers = providers;
 625             this.snippetReflection = snippetReflection;
 626             this.target = target;
 627             this.factories = factories;
 628             if (Options.UseSnippetTemplateCache.getValue(options)) {
 629                 int size = Options.MaxTemplatesPerSnippet.getValue(options);
 630                 this.templates = Collections.synchronizedMap(new LRUCache&lt;&gt;(size, size));
 631             } else {
 632                 this.templates = null;
 633             }
 634         }
 635 
 636         public Providers getProviders() {
 637             return providers;
 638         }
 639 
 640         public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
 641             for (Method m : declaringClass.getDeclaredMethods()) {
 642                 if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
 643                     return m;
 644                 }
 645             }
 646             return null;
 647         }
 648 
 649         public static ResolvedJavaMethod findMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; declaringClass, String methodName) {
 650             ResolvedJavaType type = metaAccess.lookupJavaType(declaringClass);
 651             ResolvedJavaMethod result = null;
 652             for (ResolvedJavaMethod m : type.getDeclaredMethods()) {
 653                 if (m.getName().equals(methodName)) {
 654                     if (!Assertions.assertionsEnabled()) {
 655                         return m;
 656                     } else {
 657                         assert result == null : &quot;multiple definitions found&quot;;
 658                         result = m;
 659                     }
 660                 }
 661             }
 662             if (result == null) {
 663                 throw new GraalError(&quot;Could not find method in &quot; + declaringClass + &quot; named &quot; + methodName);
 664             }
 665             return result;
 666         }
 667 
 668         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, LocationIdentity... initialPrivateLocations) {
 669             return snippet(declaringClass, methodName, null, null, initialPrivateLocations);
 670         }
 671 
 672         /**
 673          * Finds the unique method in {@code declaringClass} named {@code methodName} annotated by
 674          * {@link Snippet} and returns a {@link SnippetInfo} value describing it. There must be
 675          * exactly one snippet method in {@code declaringClass} with a given name.
 676          */
 677         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
 678             assert methodName != null;
 679             ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
 680             assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
 681             assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
 682             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options), options);
 683             LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
 684             if (GraalOptions.EagerSnippets.getValue(options)) {
 685                 return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
 686             } else {
 687                 return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
 688             }
 689         }
 690 
 691         static final AtomicInteger nextSnippetTemplateId = new AtomicInteger();
 692 
 693         private DebugContext openDebugContext(DebugContext outer, Arguments args) {
 694             if (DebugStubsAndSnippets.getValue(options)) {
 695                 Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
 696                 return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
 697             }
 698             return DebugContext.disabled(options);
 699         }
 700 
 701         /**
 702          * Gets a template for a given key, creating it first if necessary.
 703          */
 704         @SuppressWarnings(&quot;try&quot;)
 705         public SnippetTemplate template(ValueNode replacee, final Arguments args) {
 706             StructuredGraph graph = replacee.graph();
 707             DebugContext outer = graph.getDebug();
 708             SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
 709             if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
 710                 try (DebugContext debug = openDebugContext(outer, args)) {
 711                     try (DebugCloseable a = SnippetTemplateCreationTime.start(debug); DebugContext.Scope s = debug.scope(&quot;SnippetSpecialization&quot;, args.info.method)) {
 712                         SnippetTemplates.increment(debug);
 713                         OptionValues snippetOptions = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));
 714                         template = new SnippetTemplate(snippetOptions, debug, providers, snippetReflection, args, graph.trackNodeSourcePosition(), replacee);
 715                         if (Options.UseSnippetTemplateCache.getValue(snippetOptions) &amp;&amp; args.cacheable) {
 716                             templates.put(args.cacheKey, template);
 717                         }
 718                     } catch (Throwable e) {
 719                         throw debug.handle(e);
 720                     }
 721                 }
 722             }
 723             return template;
 724         }
 725     }
 726 
 727     private static final class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
 728         private static final long serialVersionUID = 1L;
 729         private final int maxCacheSize;
 730 
 731         LRUCache(int initialCapacity, int maxCacheSize) {
 732             super(initialCapacity, 0.75F, true);
 733             this.maxCacheSize = maxCacheSize;
 734         }
 735 
 736         @Override
 737         protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {
 738             return size() &gt; maxCacheSize;
 739         }
 740     }
 741 
 742     // These values must be compared with equals() not &#39;==&#39; to support replay compilation.
 743     private static final Object UNUSED_PARAMETER = &quot;UNUSED_PARAMETER&quot;;
 744     private static final Object CONSTANT_PARAMETER = &quot;CONSTANT_PARAMETER&quot;;
 745 
 746     /**
 747      * Determines if any parameter of a given method is annotated with {@link ConstantParameter}.
 748      */
 749     public static boolean hasConstantParameter(ResolvedJavaMethod method) {
 750         for (ConstantParameter p : method.getParameterAnnotations(ConstantParameter.class)) {
 751             if (p != null) {
 752                 return true;
 753             }
 754         }
 755         return false;
 756     }
 757 
 758     private final SnippetReflectionProvider snippetReflection;
 759 
 760     /**
 761      * Creates a snippet template.
 762      */
 763     @SuppressWarnings(&quot;try&quot;)
 764     protected SnippetTemplate(OptionValues options, DebugContext debug, final Providers providers, SnippetReflectionProvider snippetReflection, Arguments args, boolean trackNodeSourcePosition,
 765                     Node replacee) {
 766         this.snippetReflection = snippetReflection;
 767         this.info = args.info;
 768 
 769         Object[] constantArgs = getConstantArgs(args);
 770         boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
 771         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition(),
 772                         options);
 773 
 774         ResolvedJavaMethod method = snippetGraph.method();
 775         Signature signature = method.getSignature();
 776 
 777         // Copy snippet graph, replacing constant parameters with given arguments
 778         final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
 779                         snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
 780         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
 781         try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
 782             if (!snippetGraph.isUnsafeAccessTrackingEnabled()) {
 783                 snippetCopy.disableUnsafeAccessTracking();
 784             }
 785 
 786             EconomicMap&lt;Node, Node&gt; nodeReplacements = EconomicMap.create(Equivalence.IDENTITY);
 787             nodeReplacements.put(snippetGraph.start(), snippetCopy.start());
 788 
 789             MetaAccessProvider metaAccess = providers.getMetaAccess();
 790             assert checkTemplate(metaAccess, args, method, signature);
 791 
 792             int parameterCount = args.info.getParameterCount();
 793             VarargsPlaceholderNode[] placeholders = new VarargsPlaceholderNode[parameterCount];
 794 
 795             for (int i = 0; i &lt; parameterCount; i++) {
 796                 ParameterNode parameter = snippetGraph.getParameter(i);
 797                 if (parameter != null) {
 798                     if (args.info.isConstantParameter(i)) {
 799                         Object arg = args.values[i];
 800                         JavaKind kind = signature.getParameterKind(i);
 801                         ConstantNode constantNode;
 802                         if (arg instanceof Constant) {
 803                             Stamp stamp = args.constStamps[i];
 804                             if (stamp == null) {
 805                                 assert arg instanceof JavaConstant : &quot;could not determine type of constant &quot; + arg;
 806                                 constantNode = ConstantNode.forConstant((JavaConstant) arg, metaAccess, snippetCopy);
 807                             } else {
 808                                 constantNode = ConstantNode.forConstant(stamp, (Constant) arg, metaAccess, snippetCopy);
 809                             }
 810                         } else {
 811                             constantNode = ConstantNode.forConstant(snippetReflection.forBoxed(kind, arg), metaAccess, snippetCopy);
 812                         }
 813                         nodeReplacements.put(parameter, constantNode);
 814                     } else if (args.info.isVarargsParameter(i)) {
 815                         Varargs varargs = (Varargs) args.values[i];
 816                         VarargsPlaceholderNode placeholder = snippetCopy.unique(new VarargsPlaceholderNode(varargs, providers.getMetaAccess()));
 817                         nodeReplacements.put(parameter, placeholder);
 818                         placeholders[i] = placeholder;
 819                     } else if (args.info.isNonNullParameter(i)) {
 820                         parameter.setStamp(parameter.stamp(NodeView.DEFAULT).join(StampFactory.objectNonNull()));
 821                     }
 822                 }
 823             }
 824             try (InliningLog.UpdateScope updateScope = snippetCopy.getInliningLog().openDefaultUpdateScope()) {
 825                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = snippetCopy.addDuplicates(snippetGraph.getNodes(), snippetGraph, snippetGraph.getNodeCount(), nodeReplacements);
 826                 if (updateScope != null) {
 827                     snippetCopy.getInliningLog().replaceLog(duplicates, snippetGraph.getInliningLog());
 828                 }
 829             }
 830 
 831             debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before specialization&quot;);
 832 
 833             // Gather the template parameters
 834             parameters = new Object[parameterCount];
 835             for (int i = 0; i &lt; parameterCount; i++) {
 836                 if (args.info.isConstantParameter(i)) {
 837                     parameters[i] = CONSTANT_PARAMETER;
 838                 } else if (args.info.isVarargsParameter(i)) {
 839                     assert snippetCopy.getParameter(i) == null;
 840                     Varargs varargs = (Varargs) args.values[i];
 841                     int length = varargs.length;
 842                     ParameterNode[] params = new ParameterNode[length];
 843                     Stamp stamp = varargs.stamp;
 844                     for (int j = 0; j &lt; length; j++) {
 845                         // Use a decimal friendly numbering make it more obvious how values map
 846                         assert parameterCount &lt; 10000;
 847                         int idx = (i + 1) * 10000 + j;
 848                         assert idx &gt;= parameterCount : &quot;collision in parameter numbering&quot;;
 849                         ParameterNode local = snippetCopy.addOrUnique(new ParameterNode(idx, StampPair.createSingle(stamp)));
 850                         params[j] = local;
 851                     }
 852                     parameters[i] = params;
 853 
 854                     VarargsPlaceholderNode placeholder = placeholders[i];
 855                     if (placeholder != null) {
 856                         for (Node usage : placeholder.usages().snapshot()) {
 857                             if (usage instanceof LoadIndexedNode) {
 858                                 LoadIndexedNode loadIndexed = (LoadIndexedNode) usage;
 859                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before replacing %s&quot;, loadIndexed);
 860                                 LoadSnippetVarargParameterNode loadSnippetParameter = snippetCopy.add(
 861                                                 new LoadSnippetVarargParameterNode(params, loadIndexed.index(), loadIndexed.stamp(NodeView.DEFAULT)));
 862                                 snippetCopy.replaceFixedWithFixed(loadIndexed, loadSnippetParameter);
 863                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;After replacing %s&quot;, loadIndexed);
 864                             } else if (usage instanceof StoreIndexedNode) {
 865                                 /*
 866                                  * The template lowering doesn&#39;t really treat this as an array so
 867                                  * you can&#39;t store back into the varargs. Allocate your own array if
 868                                  * you really need this and EA should eliminate it.
 869                                  */
 870                                 throw new GraalError(&quot;Can&#39;t store into VarargsParameter array&quot;);
 871                             }
 872                         }
 873                     }
 874                 } else {
 875                     ParameterNode local = snippetCopy.getParameter(i);
 876                     if (local == null) {
 877                         // Parameter value was eliminated
 878                         parameters[i] = UNUSED_PARAMETER;
 879                     } else {
 880                         parameters[i] = local;
 881                     }
 882                 }
 883             }
 884 
 885             explodeLoops(snippetCopy, providers);
 886 
 887             GuardsStage guardsStage = args.cacheKey.guardsStage;
 888             // Perform lowering on the snippet
 889             if (!guardsStage.allowsFloatingGuards()) {
 890                 new GuardLoweringPhase().apply(snippetCopy, null);
 891             }
 892             snippetCopy.setGuardsStage(guardsStage);
 893             try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
 894                 new LoweringPhase(CanonicalizerPhase.create(), args.cacheKey.loweringStage).apply(snippetCopy, providers);
 895             } catch (Throwable e) {
 896                 throw debug.handle(e);
 897             }
 898 
 899             ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
 900             ArrayList&lt;DeoptimizingNode&gt; curDeoptNodes = new ArrayList&lt;&gt;();
 901             ArrayList&lt;ValueNode&gt; curPlaceholderStampedNodes = new ArrayList&lt;&gt;();
 902             for (Node node : snippetCopy.getNodes()) {
 903                 if (node instanceof ValueNode) {
 904                     ValueNode valueNode = (ValueNode) node;
 905                     if (valueNode.stamp(NodeView.DEFAULT) == PlaceholderStamp.singleton()) {
 906                         curPlaceholderStampedNodes.add(valueNode);
 907                     }
 908                 }
 909 
 910                 if (node instanceof StateSplit) {
 911                     StateSplit stateSplit = (StateSplit) node;
 912                     FrameState frameState = stateSplit.stateAfter();
 913                     if (stateSplit.hasSideEffect()) {
 914                         curSideEffectNodes.add((StateSplit) node);
 915                     }
 916                     if (frameState != null) {
 917                         stateSplit.setStateAfter(null);
 918                     }
 919                 }
 920                 if (node instanceof DeoptimizingNode) {
 921                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 922                     if (deoptNode.canDeoptimize()) {
 923                         curDeoptNodes.add(deoptNode);
 924                     }
 925                 }
 926             }
 927 
 928             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 929 
 930             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 931 
<a name="4" id="anc4"></a><span class="line-modified"> 932             new FloatingReadPhase(true, true).apply(snippetCopy);</span>


 933 
 934             if (!guardsStage.requiresValueProxies()) {
 935                 new RemoveValueProxyPhase().apply(snippetCopy);
 936             }
 937 
 938             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 939             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 940 
 941             this.snippet = snippetCopy;
 942 
 943             StartNode entryPointNode = snippet.start();
 944             if (anchor.hasNoUsages()) {
 945                 anchor.safeDelete();
 946                 this.memoryAnchor = null;
 947             } else {
 948                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 949                 // anywhere)
 950                 boolean needsMemoryMaps = false;
 951                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 952                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 953                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 954                         needsMemoryMaps = true;
 955                         break;
 956                     }
 957                 }
 958                 boolean needsAnchor;
 959                 if (needsMemoryMaps) {
 960                     needsAnchor = true;
 961                 } else {
 962                     // Check that all those memory maps where the only usages of the anchor
 963                     needsAnchor = anchor.usages().filter(isNotA(MemoryMapNode.class)).isNotEmpty();
 964                     // Remove the useless memory map
 965                     MemoryMapNode memoryMap = null;
 966                     for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 967                         if (memoryMap == null) {
 968                             memoryMap = retNode.getMemoryMap();
 969                         } else {
 970                             assert memoryMap == retNode.getMemoryMap();
 971                         }
 972                         retNode.setMemoryMap(null);
 973                     }
 974                     if (memoryMap != null) {
 975                         memoryMap.safeDelete();
 976                     }
 977                 }
 978                 if (needsAnchor) {
 979                     snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
 980                     this.memoryAnchor = anchor;
 981                 } else {
 982                     anchor.safeDelete();
 983                     this.memoryAnchor = null;
 984                 }
 985             }
 986             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate after fixing memory anchoring&quot;);
 987 
 988             List&lt;ReturnNode&gt; returnNodes = snippet.getNodes(ReturnNode.TYPE).snapshot();
 989             if (returnNodes.isEmpty()) {
 990                 this.returnNode = null;
 991             } else if (returnNodes.size() == 1) {
 992                 this.returnNode = returnNodes.get(0);
 993             } else {
 994                 AbstractMergeNode merge = snippet.add(new MergeNode());
 995                 List&lt;MemoryMapNode&gt; memMaps = new ArrayList&lt;&gt;();
 996                 for (ReturnNode retNode : returnNodes) {
 997                     MemoryMapNode memoryMapNode = retNode.getMemoryMap();
 998                     if (memoryMapNode != null) {
 999                         memMaps.add(memoryMapNode);
1000                     }
1001                 }
1002 
1003                 ValueNode returnValue = InliningUtil.mergeReturns(merge, returnNodes);
1004                 this.returnNode = snippet.add(new ReturnNode(returnValue));
1005                 if (!memMaps.isEmpty()) {
1006                     MemoryMapImpl mmap = FloatingReadPhase.mergeMemoryMaps(merge, memMaps);
1007                     MemoryMapNode memoryMap = snippet.unique(new MemoryMapNode(mmap.getMap()));
1008                     this.returnNode.setMemoryMap(memoryMap);
1009                     for (MemoryMapNode mm : memMaps) {
1010                         if (mm != memoryMap &amp;&amp; mm.isAlive()) {
1011                             assert mm.hasNoUsages();
1012                             GraphUtil.killWithUnusedFloatingInputs(mm);
1013                         }
1014                     }
1015                 }
1016                 merge.setNext(this.returnNode);
1017             }
1018 
1019             assert verifyIntrinsicsProcessed(snippetCopy);
1020 
1021             this.sideEffectNodes = curSideEffectNodes;
1022             this.deoptNodes = curDeoptNodes;
1023             this.placeholderStampedNodes = curPlaceholderStampedNodes;
1024 
1025             nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());
1026             for (Node node : snippet.getNodes()) {
1027                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {
1028                     nodes.add(node);
1029                 }
1030             }
1031 
1032             if (debug.areMetricsEnabled()) {
1033                 DebugContext.counter(&quot;SnippetTemplateNodeCount[%#s]&quot;, args).add(debug, nodes.size());
1034             }
1035             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate final state&quot;);
1036             this.snippet.freeze();
1037 
1038         } catch (Throwable ex) {
1039             throw debug.handle(ex);
1040         }
1041     }
1042 
1043     private static boolean verifyIntrinsicsProcessed(StructuredGraph snippetCopy) {
1044         for (MethodCallTargetNode target : snippetCopy.getNodes(MethodCallTargetNode.TYPE)) {
1045             ResolvedJavaMethod targetMethod = target.targetMethod();
1046             if (targetMethod != null) {
1047                 assert targetMethod.getAnnotation(Fold.class) == null &amp;&amp; targetMethod.getAnnotation(NodeIntrinsic.class) == null : &quot;plugin should have been processed&quot;;
1048             }
1049         }
1050         return true;
1051     }
1052 
1053     public static void explodeLoops(final StructuredGraph snippetCopy, CoreProviders providers) {
1054         // Do any required loop explosion
1055         boolean exploded = false;
1056         do {
1057             exploded = false;
1058             ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
1059             if (explodeLoop != null) { // Earlier canonicalization may have removed the loop
1060                 // altogether
1061                 LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
1062                 if (loopBegin != null) {
1063                     LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
1064                     Mark mark = snippetCopy.getMark();
1065                     CanonicalizerPhase canonicalizer = null;
1066                     if (GraalOptions.ImmutableCode.getValue(snippetCopy.getOptions())) {
1067                         canonicalizer = CanonicalizerPhase.createWithoutReadCanonicalization();
1068                     } else {
1069                         canonicalizer = CanonicalizerPhase.create();
1070                     }
1071                     LoopTransformations.fullUnroll(loop, providers, canonicalizer);
1072                     CanonicalizerPhase.create().applyIncremental(snippetCopy, providers, mark, false);
1073                     loop.deleteUnusedNodes();
1074                 }
1075                 GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
1076                 exploded = true;
1077             }
1078         } while (exploded);
1079     }
1080 
1081     protected Object[] getConstantArgs(Arguments args) {
1082         Object[] constantArgs = args.values.clone();
1083         for (int i = 0; i &lt; args.info.getParameterCount(); i++) {
1084             if (!args.info.isConstantParameter(i)) {
1085                 constantArgs[i] = null;
1086             } else {
1087                 assert constantArgs[i] != null : &quot;Can&#39;t pass raw null through as argument&quot;;
1088             }
1089         }
1090         return constantArgs;
1091     }
1092 
1093     private static boolean checkAllVarargPlaceholdersAreDeleted(int parameterCount, VarargsPlaceholderNode[] placeholders) {
1094         for (int i = 0; i &lt; parameterCount; i++) {
1095             if (placeholders[i] != null) {
1096                 assert placeholders[i].isDeleted() : placeholders[i];
1097             }
1098         }
1099         return true;
1100     }
1101 
1102     private static boolean checkConstantArgument(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int paramIndex, String name, Object arg, JavaKind kind) {
1103         ResolvedJavaType type = signature.getParameterType(paramIndex, method.getDeclaringClass()).resolve(method.getDeclaringClass());
1104         if (metaAccess.lookupJavaType(WordBase.class).isAssignableFrom(type)) {
1105             assert arg instanceof JavaConstant : method + &quot;: word constant parameters must be passed boxed in a Constant value: &quot; + arg;
1106             return true;
1107         }
1108         if (kind != JavaKind.Object) {
1109             assert arg != null &amp;&amp; kind.toBoxedJavaClass() == arg.getClass() : method + &quot;: wrong value kind for &quot; + name + &quot;: expected &quot; + kind + &quot;, got &quot; +
1110                             (arg == null ? &quot;null&quot; : arg.getClass().getSimpleName());
1111         }
1112         return true;
1113     }
1114 
1115     private static boolean checkVarargs(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int i, String name, Varargs varargs) {
1116         ResolvedJavaType type = (ResolvedJavaType) signature.getParameterType(i, method.getDeclaringClass());
1117         assert type.isArray() : &quot;varargs parameter must be an array type&quot;;
1118         assert type.getComponentType().isAssignableFrom(metaAccess.lookupJavaType(varargs.componentType)) : &quot;componentType for &quot; + name + &quot; not matching &quot; + type.toJavaName() + &quot; instance: &quot; +
1119                         varargs.componentType;
1120         return true;
1121     }
1122 
1123     /**
1124      * The graph built from the snippet method.
1125      */
1126     private final StructuredGraph snippet;
1127 
1128     private final SnippetInfo info;
1129 
1130     /**
1131      * The named parameters of this template that must be bound to values during instantiation. For
1132      * a parameter that is still live after specialization, the value in this map is either a
1133      * {@link ParameterNode} instance or a {@link ParameterNode} array. For an eliminated parameter,
1134      * the value is identical to the key.
1135      */
1136     private final Object[] parameters;
1137 
1138     /**
1139      * The return node (if any) of the snippet.
1140      */
1141     private final ReturnNode returnNode;
1142 
1143     /**
1144      * The memory anchor (if any) of the snippet.
1145      */
1146     private final MemoryAnchorNode memoryAnchor;
1147 
1148     /**
1149      * Nodes that inherit the {@link StateSplit#stateAfter()} from the replacee during
1150      * instantiation.
1151      */
1152     private final ArrayList&lt;StateSplit&gt; sideEffectNodes;
1153 
1154     /**
1155      * Nodes that inherit a deoptimization {@link FrameState} from the replacee during
1156      * instantiation.
1157      */
1158     private final ArrayList&lt;DeoptimizingNode&gt; deoptNodes;
1159 
1160     /**
1161      * Nodes that have a stamp originating from a {@link Placeholder}.
1162      */
1163     private final ArrayList&lt;ValueNode&gt; placeholderStampedNodes;
1164 
1165     /**
1166      * The nodes to be inlined when this specialization is instantiated.
1167      */
1168     private final ArrayList&lt;Node&gt; nodes;
1169 
1170     /**
1171      * Gets the instantiation-time bindings to this template&#39;s parameters.
1172      *
1173      * @return the map that will be used to bind arguments to parameters when inlining this template
1174      */
1175     private EconomicMap&lt;Node, Node&gt; bind(StructuredGraph replaceeGraph, MetaAccessProvider metaAccess, Arguments args) {
1176         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
1177         assert args.info.getParameterCount() == parameters.length : &quot;number of args (&quot; + args.info.getParameterCount() + &quot;) != number of parameters (&quot; + parameters.length + &quot;)&quot;;
1178         for (int i = 0; i &lt; parameters.length; i++) {
1179             Object parameter = parameters[i];
1180             assert parameter != null : this + &quot; has no parameter named &quot; + args.info.getParameterName(i);
1181             Object argument = args.values[i];
1182             if (parameter instanceof ParameterNode) {
1183                 if (argument instanceof ValueNode) {
1184                     replacements.put((ParameterNode) parameter, (ValueNode) argument);
1185                 } else {
1186                     JavaKind kind = ((ParameterNode) parameter).getStackKind();
1187                     assert argument != null || kind == JavaKind.Object : this + &quot; cannot accept null for non-object parameter named &quot; + args.info.getParameterName(i);
1188                     JavaConstant constant = forBoxed(argument, kind);
1189                     replacements.put((ParameterNode) parameter, ConstantNode.forConstant(constant, metaAccess, replaceeGraph));
1190                 }
1191             } else if (parameter instanceof ParameterNode[]) {
1192                 ParameterNode[] params = (ParameterNode[]) parameter;
1193                 Varargs varargs = (Varargs) argument;
1194                 int length = params.length;
1195                 List&lt;?&gt; list = null;
1196                 Object array = null;
1197                 if (varargs.value instanceof List) {
1198                     list = (List&lt;?&gt;) varargs.value;
1199                     assert list.size() == length : length + &quot; != &quot; + list.size();
1200                 } else {
1201                     array = varargs.value;
1202                     assert array != null &amp;&amp; array.getClass().isArray();
1203                     assert Array.getLength(array) == length : length + &quot; != &quot; + Array.getLength(array);
1204                 }
1205 
1206                 for (int j = 0; j &lt; length; j++) {
1207                     ParameterNode param = params[j];
1208                     assert param != null;
1209                     Object value = list != null ? list.get(j) : Array.get(array, j);
1210                     if (value instanceof ValueNode) {
1211                         replacements.put(param, (ValueNode) value);
1212                     } else {
1213                         JavaConstant constant = forBoxed(value, param.getStackKind());
1214                         ConstantNode element = ConstantNode.forConstant(constant, metaAccess, replaceeGraph);
1215                         replacements.put(param, element);
1216                     }
1217                 }
1218             } else {
1219                 assert parameter.equals(CONSTANT_PARAMETER) || parameter.equals(UNUSED_PARAMETER) : &quot;unexpected entry for parameter: &quot; + args.info.getParameterName(i) + &quot; -&gt; &quot; + parameter;
1220             }
1221         }
1222         return replacements;
1223     }
1224 
1225     /**
1226      * Converts a Java boxed value to a {@link JavaConstant} of the right kind. This adjusts for the
1227      * limitation that a {@link Local}&#39;s kind is a {@linkplain JavaKind#getStackKind() stack kind}
1228      * and so cannot be used for re-boxing primitives smaller than an int.
1229      *
1230      * @param argument a Java boxed value
1231      * @param localKind the kind of the {@link Local} to which {@code argument} will be bound
1232      */
1233     protected JavaConstant forBoxed(Object argument, JavaKind localKind) {
1234         assert localKind == localKind.getStackKind();
1235         if (localKind == JavaKind.Int) {
1236             return JavaConstant.forBoxedPrimitive(argument);
1237         }
1238         return snippetReflection.forBoxed(localKind, argument);
1239     }
1240 
1241     /**
1242      * Logic for replacing a snippet-lowered node at its usages with the return value of the
1243      * snippet. An alternative to the {@linkplain SnippetTemplate#DEFAULT_REPLACER default}
1244      * replacement logic can be used to handle mismatches between the stamp of the node being
1245      * lowered and the stamp of the snippet&#39;s return value.
1246      */
1247     public interface UsageReplacer {
1248         /**
1249          * Replaces all usages of {@code oldNode} with direct or indirect usages of {@code newNode}.
1250          */
1251         void replace(ValueNode oldNode, ValueNode newNode);
1252     }
1253 
1254     /**
1255      * Represents the default {@link UsageReplacer usage replacer} logic which simply delegates to
1256      * {@link Node#replaceAtUsages(Node)}.
1257      */
1258     public static final UsageReplacer DEFAULT_REPLACER = new UsageReplacer() {
1259 
1260         @Override
1261         public void replace(ValueNode oldNode, ValueNode newNode) {
1262             if (newNode == null) {
1263                 assert oldNode.hasNoUsages();
1264             } else {
1265                 oldNode.replaceAtUsages(newNode);
1266             }
1267         }
1268     };
1269 
1270     private boolean assertSnippetKills(ValueNode replacee) {
1271         if (!replacee.graph().isAfterFloatingReadPhase()) {
1272             // no floating reads yet, ignore locations created while lowering
1273             return true;
1274         }
1275         if (returnNode == null) {
1276             // The snippet terminates control flow
1277             return true;
1278         }
1279         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1280         if (memoryMap == null || memoryMap.isEmpty()) {
1281             // there are no kills in the snippet graph
1282             return true;
1283         }
1284 
1285         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1286         kills.addAll(memoryMap.getLocations());
1287 
<a name="5" id="anc5"></a><span class="line-modified">1288         if (replacee instanceof MemoryCheckpoint.Single) {</span>
1289             // check if some node in snippet graph also kills the same location
<a name="6" id="anc6"></a><span class="line-modified">1290             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getKilledLocationIdentity();</span>
1291             if (locationIdentity.isAny()) {
1292                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1293                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1294                 return true;
1295             }
1296             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1297             kills.remove(locationIdentity);
1298         }
<a name="7" id="anc7"></a><span class="line-modified">1299         assert !(replacee instanceof MemoryCheckpoint.Multi) : replacee + &quot; multi not supported (yet)&quot;;</span>
1300 
1301         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1302         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1303             kills.remove(any());
1304         }
1305 
1306         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1307         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1308 
1309         /*
1310          * Kills to private locations are safe, since there can be no floating read to these
1311          * locations except reads that are introduced by the snippet itself or related snippets in
1312          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1313          * their snippet, so they can not float above a kill in another instance of the same
1314          * snippet.
1315          */
1316         for (LocationIdentity p : this.info.privateLocations) {
1317             kills.remove(p);
1318         }
1319 
1320         assert kills.isEmpty() : &quot;snippet graph kills non-private locations &quot; + kills + &quot; that replacee (&quot; + replacee + &quot;) doesn&#39;t kill&quot;;
1321         return true;
1322     }
1323 
1324     private static class MemoryInputMap implements MemoryMap {
1325 
1326         private final LocationIdentity locationIdentity;
1327         private final MemoryNode lastLocationAccess;
1328 
1329         MemoryInputMap(ValueNode replacee) {
1330             if (replacee instanceof MemoryAccess) {
1331                 MemoryAccess access = (MemoryAccess) replacee;
1332                 locationIdentity = access.getLocationIdentity();
1333                 lastLocationAccess = access.getLastLocationAccess();
1334             } else {
1335                 locationIdentity = null;
1336                 lastLocationAccess = null;
1337             }
1338         }
1339 
1340         @Override
1341         public MemoryNode getLastLocationAccess(LocationIdentity location) {
1342             if (locationIdentity != null &amp;&amp; locationIdentity.equals(location)) {
1343                 return lastLocationAccess;
1344             } else {
1345                 return null;
1346             }
1347         }
1348 
1349         @Override
1350         public Collection&lt;LocationIdentity&gt; getLocations() {
1351             if (locationIdentity == null) {
1352                 return Collections.emptySet();
1353             } else {
1354                 return Collections.singleton(locationIdentity);
1355             }
1356         }
1357     }
1358 
1359     private class MemoryOutputMap extends MemoryInputMap {
1360 
1361         private final UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
1362 
1363         MemoryOutputMap(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1364             super(replacee);
1365             this.duplicates = duplicates;
1366         }
1367 
1368         @Override
1369         public MemoryNode getLastLocationAccess(LocationIdentity locationIdentity) {
1370             MemoryMapNode memoryMap = returnNode.getMemoryMap();
1371             assert memoryMap != null : &quot;no memory map stored for this snippet graph (snippet doesn&#39;t have a ReturnNode?)&quot;;
1372             MemoryNode lastLocationAccess = memoryMap.getLastLocationAccess(locationIdentity);
1373             assert lastLocationAccess != null : locationIdentity;
1374             if (lastLocationAccess == memoryAnchor) {
1375                 return super.getLastLocationAccess(locationIdentity);
1376             } else {
1377                 return (MemoryNode) duplicates.get(ValueNodeUtil.asNode(lastLocationAccess));
1378             }
1379         }
1380 
1381         @Override
1382         public Collection&lt;LocationIdentity&gt; getLocations() {
1383             return returnNode.getMemoryMap().getLocations();
1384         }
1385     }
1386 
1387     private void rewireMemoryGraph(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1388         if (replacee.graph().isAfterFloatingReadPhase()) {
1389             // rewire outgoing memory edges
1390             replaceMemoryUsages(replacee, new MemoryOutputMap(replacee, duplicates));
1391 
1392             if (returnNode != null) {
1393                 ReturnNode ret = (ReturnNode) duplicates.get(returnNode);
1394                 if (ret != null) {
1395                     MemoryMapNode memoryMap = ret.getMemoryMap();
1396                     if (memoryMap != null) {
1397                         ret.setMemoryMap(null);
1398                         memoryMap.safeDelete();
1399                     }
1400                 }
1401             }
1402             if (memoryAnchor != null) {
1403                 // rewire incoming memory edges
1404                 MemoryAnchorNode memoryDuplicate = (MemoryAnchorNode) duplicates.get(memoryAnchor);
1405                 replaceMemoryUsages(memoryDuplicate, new MemoryInputMap(replacee));
1406 
1407                 if (memoryDuplicate.hasNoUsages()) {
1408                     if (memoryDuplicate.next() != null) {
1409                         memoryDuplicate.graph().removeFixed(memoryDuplicate);
1410                     } else {
1411                         // this was a dummy memory node used when instantiating pure data-flow
1412                         // snippets: it was not attached to the control flow.
1413                         memoryDuplicate.safeDelete();
1414                     }
1415                 }
1416             }
1417         }
1418     }
1419 
1420     private static LocationIdentity getLocationIdentity(Node node) {
1421         if (node instanceof MemoryAccess) {
1422             return ((MemoryAccess) node).getLocationIdentity();
1423         } else if (node instanceof MemoryProxy) {
1424             return ((MemoryProxy) node).getLocationIdentity();
1425         } else if (node instanceof MemoryPhiNode) {
1426             return ((MemoryPhiNode) node).getLocationIdentity();
1427         } else {
1428             return null;
1429         }
1430     }
1431 
1432     private void replaceMemoryUsages(ValueNode node, MemoryMap map) {
1433         for (Node usage : node.usages().snapshot()) {
1434             if (usage instanceof MemoryMapNode) {
1435                 continue;
1436             }
1437 
1438             LocationIdentity location = getLocationIdentity(usage);
1439             if (location != null) {
1440                 for (Position pos : usage.inputPositions()) {
1441                     if (pos.getInputType() == InputType.Memory &amp;&amp; pos.get(usage) == node) {
1442                         MemoryNode replacement = map.getLastLocationAccess(location);
1443                         if (replacement == null) {
1444                             assert mayRemoveLocation || LocationIdentity.any().equals(location) ||
1445                                             CollectionsUtil.anyMatch(info.privateLocations, Predicate.isEqual(location)) : &quot;Snippet &quot; +
1446                                                             info.method.format(&quot;%h.%n&quot;) + &quot; contains access to the non-private location &quot; +
1447                                                             location + &quot;, but replacee doesn&#39;t access this location.&quot; + map.getLocations();
1448                         } else {
1449                             pos.set(usage, replacement.asNode());
1450                         }
1451                     }
1452                 }
1453             }
1454         }
1455     }
1456 
1457     /**
1458      * Replaces a given fixed node with this specialized snippet.
1459      *
1460      * @param metaAccess
1461      * @param replacee the node that will be replaced
1462      * @param replacer object that replaces the usages of {@code replacee}
1463      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1464      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1465      */
1466     @SuppressWarnings(&quot;try&quot;)
1467     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args) {
1468         return instantiate(metaAccess, replacee, replacer, args, true);
1469     }
1470 
1471     /**
1472      * Replaces a given fixed node with this specialized snippet.
1473      *
1474      * @param metaAccess
1475      * @param replacee the node that will be replaced
1476      * @param replacer object that replaces the usages of {@code replacee}
1477      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1478      * @param killReplacee is true, the replacee node is deleted
1479      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1480      */
1481     @SuppressWarnings(&quot;try&quot;)
1482     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args, boolean killReplacee) {
1483         DebugContext debug = replacee.getDebug();
1484         assert assertSnippetKills(replacee);
1485         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1486             args.info.instantiationCounter.increment(debug);
1487             // Inline the snippet nodes, replacing parameters with the given args in the process
1488             StartNode entryPointNode = snippet.start();
1489             FixedNode firstCFGNode = entryPointNode.next();
1490             StructuredGraph replaceeGraph = replacee.graph();
1491             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1492             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1493             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1494 
1495             // Re-wire the control flow graph around the replacee
1496             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1497             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1498 
1499             rewireFrameStates(replacee, duplicates);
1500 
1501             updateStamps(replacee, duplicates);
1502 
1503             rewireMemoryGraph(replacee, duplicates);
1504 
1505             // Replace all usages of the replacee with the value returned by the snippet
1506             ValueNode returnValue = null;
1507             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1508                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1509                 returnValue = returnDuplicate.result();
<a name="8" id="anc8"></a><span class="line-modified">1510                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryCheckpoint) {</span>
1511                     replacer.replace(replacee, null);
1512                 } else {
1513                     assert returnValue != null || replacee.hasNoUsages();
1514                     replacer.replace(replacee, returnValue);
1515                 }
1516                 if (returnDuplicate.isAlive()) {
1517                     FixedNode next = null;
1518                     if (replacee instanceof FixedWithNextNode) {
1519                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1520                         next = fwn.next();
1521                         fwn.setNext(null);
1522                     }
1523                     returnDuplicate.replaceAndDelete(next);
1524                 }
1525             }
1526 
1527             if (killReplacee) {
1528                 // Remove the replacee from its graph
1529                 GraphUtil.killCFG(replacee);
1530             }
1531 
1532             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1533             return duplicates;
1534         }
1535     }
1536 
1537     private UnmodifiableEconomicMap&lt;Node, Node&gt; inlineSnippet(Node replacee, DebugContext debug, StructuredGraph replaceeGraph, EconomicMap&lt;Node, Node&gt; replacements) {
1538         Mark mark = replaceeGraph.getMark();
1539         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {
1540             InliningLog log = replaceeGraph.getInliningLog();
1541             if (oldNode == null) {
1542                 log.trackNewCallsite(newNode);
1543             }
1544         })) {
1545             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacements);
1546             if (scope != null) {
1547                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());
1548             }
1549             NodeSourcePosition position = replacee.getNodeSourcePosition();
1550             InliningUtil.updateSourcePosition(replaceeGraph, duplicates, mark, position, true);
1551             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining snippet %s&quot;, snippet.method());
1552             return duplicates;
1553         }
1554     }
1555 
1556     private void propagateStamp(Node node) {
1557         if (node instanceof PhiNode) {
1558             PhiNode phi = (PhiNode) node;
1559             if (phi.inferStamp()) {
1560                 for (Node usage : node.usages()) {
1561                     propagateStamp(usage);
1562                 }
1563             }
1564         }
1565     }
1566 
1567     private void updateStamps(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1568         for (ValueNode node : placeholderStampedNodes) {
1569             ValueNode dup = (ValueNode) duplicates.get(node);
1570             Stamp replaceeStamp = replacee.stamp(NodeView.DEFAULT);
1571             if (node instanceof Placeholder) {
1572                 Placeholder placeholderDup = (Placeholder) dup;
1573                 placeholderDup.makeReplacement(replaceeStamp);
1574             } else {
1575                 dup.setStamp(replaceeStamp);
1576             }
1577         }
1578         for (ParameterNode paramNode : snippet.getNodes(ParameterNode.TYPE)) {
1579             for (Node usage : paramNode.usages()) {
1580                 Node usageDup = duplicates.get(usage);
1581                 propagateStamp(usageDup);
1582             }
1583         }
1584     }
1585 
1586     /**
1587      * Gets a copy of the specialized graph.
1588      */
1589     public StructuredGraph copySpecializedGraph(DebugContext debugForCopy) {
1590         return (StructuredGraph) snippet.copy(debugForCopy);
1591     }
1592 
1593     /**
1594      * Replaces a given floating node with this specialized snippet.
1595      *
1596      * @param metaAccess
1597      * @param replacee the node that will be replaced
1598      * @param replacer object that replaces the usages of {@code replacee}
1599      * @param tool lowering tool used to insert the snippet into the control-flow
1600      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1601      */
1602     @SuppressWarnings(&quot;try&quot;)
1603     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, LoweringTool tool, Arguments args) {
1604         DebugContext debug = replacee.getDebug();
1605         assert assertSnippetKills(replacee);
1606         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1607             args.info.instantiationCounter.increment(debug);
1608 
1609             // Inline the snippet nodes, replacing parameters with the given args in the process
1610             StartNode entryPointNode = snippet.start();
1611             FixedNode firstCFGNode = entryPointNode.next();
1612             StructuredGraph replaceeGraph = replacee.graph();
1613             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1614             replacements.put(entryPointNode, tool.getCurrentGuardAnchor().asNode());
1615             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1616 
1617             FixedWithNextNode lastFixedNode = tool.lastFixedNode();
1618             assert lastFixedNode != null &amp;&amp; lastFixedNode.isAlive() : replaceeGraph + &quot; lastFixed=&quot; + lastFixedNode;
1619             FixedNode next = lastFixedNode.next();
1620             lastFixedNode.setNext(null);
1621             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1622             replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
1623 
1624             // floating nodes are not state-splits not need to re-wire frame states
1625             assert !(replacee instanceof StateSplit);
1626             updateStamps(replacee, duplicates);
1627 
1628             rewireMemoryGraph(replacee, duplicates);
1629 
1630             // Replace all usages of the replacee with the value returned by the snippet
1631             ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1632             ValueNode returnValue = returnDuplicate.result();
1633             assert returnValue != null || replacee.hasNoUsages();
1634             replacer.replace(replacee, returnValue);
1635 
1636             if (returnDuplicate.isAlive()) {
1637                 returnDuplicate.replaceAndDelete(next);
1638             }
1639 
1640             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1641         }
1642     }
1643 
1644     /**
1645      * Replaces a given floating node with this specialized snippet.
1646      *
1647      * This snippet must be pure data-flow
1648      *
1649      * @param metaAccess
1650      * @param replacee the node that will be replaced
1651      * @param replacer object that replaces the usages of {@code replacee}
1652      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1653      */
1654     @SuppressWarnings(&quot;try&quot;)
1655     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, Arguments args) {
1656         DebugContext debug = replacee.getDebug();
1657         assert assertSnippetKills(replacee);
1658         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1659             args.info.instantiationCounter.increment(debug);
1660 
1661             // Inline the snippet nodes, replacing parameters with the given args in the process
1662             StartNode entryPointNode = snippet.start();
1663             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1664             StructuredGraph replaceeGraph = replacee.graph();
1665             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1666             MemoryAnchorNode anchorDuplicate = null;
1667             if (memoryAnchor != null) {
1668                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode());
1669                 replacements.put(memoryAnchor, anchorDuplicate);
1670             }
1671             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1672             for (Node n : nodes) {
1673                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1674                     floatingNodes.add(n);
1675                 }
1676             }
1677             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1678 
1679             // floating nodes are not state-splits not need to re-wire frame states
1680             assert !(replacee instanceof StateSplit);
1681             updateStamps(replacee, duplicates);
1682 
1683             rewireMemoryGraph(replacee, duplicates);
1684             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1685 
1686             // Replace all usages of the replacee with the value returned by the snippet
1687             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1688             replacer.replace(replacee, returnValue);
1689 
1690             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1691         }
1692     }
1693 
1694     protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1695         if (replacee.graph().getGuardsStage().areFrameStatesAtSideEffects() &amp;&amp; replacee instanceof StateSplit) {
1696             for (StateSplit sideEffectNode : sideEffectNodes) {
1697                 assert ((StateSplit) replacee).hasSideEffect();
1698                 Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
1699                 ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
1700             }
1701         } else if (replacee.graph().getGuardsStage().areFrameStatesAtDeopts() &amp;&amp; replacee instanceof DeoptimizingNode) {
1702             DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;
1703 
1704             FrameState stateBefore = null;
1705             FrameState stateDuring = null;
1706             FrameState stateAfter = null;
1707             if (replaceeDeopt.canDeoptimize()) {
1708                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {
1709                     stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();
1710                 }
1711                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {
1712                     stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();
1713                 }
1714                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {
1715                     stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();
1716                 }
1717             }
1718 
1719             for (DeoptimizingNode deoptNode : deoptNodes) {
1720                 DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());
1721                 if (deoptDup.canDeoptimize()) {
1722                     if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {
1723                         ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);
1724                     }
1725                     if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {
1726                         // compute a state &quot;during&quot; for a DeoptDuring inside the snippet depending
1727                         // on what kind of states we had on the node we are replacing.
1728                         // If the original node had a state &quot;during&quot; already, we just use that,
1729                         // otherwise we need to find a strategy to compute a state during based on
1730                         // some other state (before or after).
1731                         DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;
1732                         if (stateDuring != null) {
1733                             deoptDupDuring.setStateDuring(stateDuring);
1734                         } else if (stateAfter != null) {
1735                             deoptDupDuring.computeStateDuring(stateAfter);
1736                         } else if (stateBefore != null) {
1737                             assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;
1738                             deoptDupDuring.setStateDuring(stateBefore);
1739                         }
1740                     }
1741                     if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {
1742                         DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;
1743                         if (stateAfter != null) {
1744                             deoptDupAfter.setStateAfter(stateAfter);
1745                         } else {
1746                             assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;
1747                             deoptDupAfter.setStateAfter(stateBefore);
1748                         }
1749 
1750                     }
1751                 }
1752             }
1753         }
1754     }
1755 
1756     @Override
1757     public String toString() {
1758         StringBuilder buf = new StringBuilder(snippet.toString()).append(&#39;(&#39;);
1759         String sep = &quot;&quot;;
1760         for (int i = 0; i &lt; parameters.length; i++) {
1761             String name = &quot;[&quot; + i + &quot;]&quot;;
1762             Object value = parameters[i];
1763             buf.append(sep);
1764             sep = &quot;, &quot;;
1765             if (value == null) {
1766                 buf.append(&quot;&lt;null&gt; &quot;).append(name);
1767             } else if (value.equals(UNUSED_PARAMETER)) {
1768                 buf.append(&quot;&lt;unused&gt; &quot;).append(name);
1769             } else if (value.equals(CONSTANT_PARAMETER)) {
1770                 buf.append(&quot;&lt;constant&gt; &quot;).append(name);
1771             } else if (value instanceof ParameterNode) {
1772                 ParameterNode param = (ParameterNode) value;
1773                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1774             } else {
1775                 ParameterNode[] params = (ParameterNode[]) value;
1776                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1777                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1778             }
1779         }
1780         return buf.append(&#39;)&#39;).toString();
1781     }
1782 
1783     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1784         int offset = args.info.hasReceiver() ? 1 : 0;
1785         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1786             if (args.info.isConstantParameter(i)) {
1787                 JavaKind kind = signature.getParameterKind(i - offset);
1788                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1789 
1790             } else if (args.info.isVarargsParameter(i)) {
1791                 assert args.values[i] instanceof Varargs;
1792                 Varargs varargs = (Varargs) args.values[i];
<a name="9" id="anc9"></a><span class="line-modified">1793                 assert checkVarargs(metaAccess, method, signature, i, args.info.getParameterName(i), varargs);</span>
1794             }
1795         }
1796         return true;
1797     }
1798 
1799     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1800         this.mayRemoveLocation = mayRemoveLocation;
1801     }
1802 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
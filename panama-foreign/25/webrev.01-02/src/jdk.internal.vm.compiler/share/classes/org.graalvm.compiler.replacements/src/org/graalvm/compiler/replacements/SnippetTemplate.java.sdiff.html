<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PEGraphDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;


 121 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 122 import org.graalvm.compiler.nodes.spi.CoreProviders;
 123 import org.graalvm.compiler.nodes.spi.LoweringTool;
 124 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 125 import org.graalvm.compiler.nodes.util.GraphUtil;
 126 import org.graalvm.compiler.options.Option;
 127 import org.graalvm.compiler.options.OptionKey;
 128 import org.graalvm.compiler.options.OptionValues;
 129 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 130 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 131 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 133 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 134 import org.graalvm.compiler.phases.common.LoweringPhase;
 135 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 136 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 137 import org.graalvm.compiler.phases.util.Providers;
 138 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 139 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 140 import org.graalvm.util.CollectionsUtil;
</pre>
<hr />
<pre>
 912                     FrameState frameState = stateSplit.stateAfter();
 913                     if (stateSplit.hasSideEffect()) {
 914                         curSideEffectNodes.add((StateSplit) node);
 915                     }
 916                     if (frameState != null) {
 917                         stateSplit.setStateAfter(null);
 918                     }
 919                 }
 920                 if (node instanceof DeoptimizingNode) {
 921                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 922                     if (deoptNode.canDeoptimize()) {
 923                         curDeoptNodes.add(deoptNode);
 924                     }
 925                 }
 926             }
 927 
 928             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 929 
 930             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 931 
<span class="line-modified"> 932             new FloatingReadPhase(true, true).apply(snippetCopy);</span>


 933 
 934             if (!guardsStage.requiresValueProxies()) {
 935                 new RemoveValueProxyPhase().apply(snippetCopy);
 936             }
 937 
 938             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 939             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 940 
 941             this.snippet = snippetCopy;
 942 
 943             StartNode entryPointNode = snippet.start();
 944             if (anchor.hasNoUsages()) {
 945                 anchor.safeDelete();
 946                 this.memoryAnchor = null;
 947             } else {
 948                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 949                 // anywhere)
 950                 boolean needsMemoryMaps = false;
 951                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 952                     MemoryMapNode memoryMap = retNode.getMemoryMap();
</pre>
<hr />
<pre>
1268     };
1269 
1270     private boolean assertSnippetKills(ValueNode replacee) {
1271         if (!replacee.graph().isAfterFloatingReadPhase()) {
1272             // no floating reads yet, ignore locations created while lowering
1273             return true;
1274         }
1275         if (returnNode == null) {
1276             // The snippet terminates control flow
1277             return true;
1278         }
1279         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1280         if (memoryMap == null || memoryMap.isEmpty()) {
1281             // there are no kills in the snippet graph
1282             return true;
1283         }
1284 
1285         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1286         kills.addAll(memoryMap.getLocations());
1287 
<span class="line-modified">1288         if (replacee instanceof MemoryCheckpoint.Single) {</span>
1289             // check if some node in snippet graph also kills the same location
<span class="line-modified">1290             LocationIdentity locationIdentity = ((MemoryCheckpoint.Single) replacee).getKilledLocationIdentity();</span>
1291             if (locationIdentity.isAny()) {
1292                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1293                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1294                 return true;
1295             }
1296             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1297             kills.remove(locationIdentity);
1298         }
<span class="line-modified">1299         assert !(replacee instanceof MemoryCheckpoint.Multi) : replacee + &quot; multi not supported (yet)&quot;;</span>
1300 
1301         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1302         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1303             kills.remove(any());
1304         }
1305 
1306         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1307         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1308 
1309         /*
1310          * Kills to private locations are safe, since there can be no floating read to these
1311          * locations except reads that are introduced by the snippet itself or related snippets in
1312          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1313          * their snippet, so they can not float above a kill in another instance of the same
1314          * snippet.
1315          */
1316         for (LocationIdentity p : this.info.privateLocations) {
1317             kills.remove(p);
1318         }
1319 
</pre>
<hr />
<pre>
1490             StructuredGraph replaceeGraph = replacee.graph();
1491             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1492             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1493             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1494 
1495             // Re-wire the control flow graph around the replacee
1496             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1497             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1498 
1499             rewireFrameStates(replacee, duplicates);
1500 
1501             updateStamps(replacee, duplicates);
1502 
1503             rewireMemoryGraph(replacee, duplicates);
1504 
1505             // Replace all usages of the replacee with the value returned by the snippet
1506             ValueNode returnValue = null;
1507             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1508                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1509                 returnValue = returnDuplicate.result();
<span class="line-modified">1510                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryCheckpoint) {</span>
1511                     replacer.replace(replacee, null);
1512                 } else {
1513                     assert returnValue != null || replacee.hasNoUsages();
1514                     replacer.replace(replacee, returnValue);
1515                 }
1516                 if (returnDuplicate.isAlive()) {
1517                     FixedNode next = null;
1518                     if (replacee instanceof FixedWithNextNode) {
1519                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1520                         next = fwn.next();
1521                         fwn.setNext(null);
1522                     }
1523                     returnDuplicate.replaceAndDelete(next);
1524                 }
1525             }
1526 
1527             if (killReplacee) {
1528                 // Remove the replacee from its graph
1529                 GraphUtil.killCFG(replacee);
1530             }
</pre>
<hr />
<pre>
1773                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1774             } else {
1775                 ParameterNode[] params = (ParameterNode[]) value;
1776                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1777                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1778             }
1779         }
1780         return buf.append(&#39;)&#39;).toString();
1781     }
1782 
1783     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1784         int offset = args.info.hasReceiver() ? 1 : 0;
1785         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1786             if (args.info.isConstantParameter(i)) {
1787                 JavaKind kind = signature.getParameterKind(i - offset);
1788                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1789 
1790             } else if (args.info.isVarargsParameter(i)) {
1791                 assert args.values[i] instanceof Varargs;
1792                 Varargs varargs = (Varargs) args.values[i];
<span class="line-modified">1793                 assert checkVarargs(metaAccess, method, signature, i, args.info.getParameterName(i), varargs);</span>
1794             }
1795         }
1796         return true;
1797     }
1798 
1799     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1800         this.mayRemoveLocation = mayRemoveLocation;
1801     }
1802 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
</pre>
<hr />
<pre>
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryKill;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
<span class="line-added"> 121 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;</span>
<span class="line-added"> 122 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;</span>
 123 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 124 import org.graalvm.compiler.nodes.spi.CoreProviders;
 125 import org.graalvm.compiler.nodes.spi.LoweringTool;
 126 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 127 import org.graalvm.compiler.nodes.util.GraphUtil;
 128 import org.graalvm.compiler.options.Option;
 129 import org.graalvm.compiler.options.OptionKey;
 130 import org.graalvm.compiler.options.OptionValues;
 131 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 132 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 133 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 134 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 135 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 136 import org.graalvm.compiler.phases.common.LoweringPhase;
 137 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 138 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 139 import org.graalvm.compiler.phases.util.Providers;
 140 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 141 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 142 import org.graalvm.util.CollectionsUtil;
</pre>
<hr />
<pre>
 914                     FrameState frameState = stateSplit.stateAfter();
 915                     if (stateSplit.hasSideEffect()) {
 916                         curSideEffectNodes.add((StateSplit) node);
 917                     }
 918                     if (frameState != null) {
 919                         stateSplit.setStateAfter(null);
 920                     }
 921                 }
 922                 if (node instanceof DeoptimizingNode) {
 923                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 924                     if (deoptNode.canDeoptimize()) {
 925                         curDeoptNodes.add(deoptNode);
 926                     }
 927                 }
 928             }
 929 
 930             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 931 
 932             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 933 
<span class="line-modified"> 934             if (((StructuredGraph) replacee.graph()).isAfterFloatingReadPhase()) {</span>
<span class="line-added"> 935                 new FloatingReadPhase(true, true).apply(snippetCopy);</span>
<span class="line-added"> 936             }</span>
 937 
 938             if (!guardsStage.requiresValueProxies()) {
 939                 new RemoveValueProxyPhase().apply(snippetCopy);
 940             }
 941 
 942             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 943             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 944 
 945             this.snippet = snippetCopy;
 946 
 947             StartNode entryPointNode = snippet.start();
 948             if (anchor.hasNoUsages()) {
 949                 anchor.safeDelete();
 950                 this.memoryAnchor = null;
 951             } else {
 952                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 953                 // anywhere)
 954                 boolean needsMemoryMaps = false;
 955                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 956                     MemoryMapNode memoryMap = retNode.getMemoryMap();
</pre>
<hr />
<pre>
1272     };
1273 
1274     private boolean assertSnippetKills(ValueNode replacee) {
1275         if (!replacee.graph().isAfterFloatingReadPhase()) {
1276             // no floating reads yet, ignore locations created while lowering
1277             return true;
1278         }
1279         if (returnNode == null) {
1280             // The snippet terminates control flow
1281             return true;
1282         }
1283         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1284         if (memoryMap == null || memoryMap.isEmpty()) {
1285             // there are no kills in the snippet graph
1286             return true;
1287         }
1288 
1289         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1290         kills.addAll(memoryMap.getLocations());
1291 
<span class="line-modified">1292         if (replacee instanceof SingleMemoryKill) {</span>
1293             // check if some node in snippet graph also kills the same location
<span class="line-modified">1294             LocationIdentity locationIdentity = ((SingleMemoryKill) replacee).getKilledLocationIdentity();</span>
1295             if (locationIdentity.isAny()) {
1296                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1297                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1298                 return true;
1299             }
1300             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1301             kills.remove(locationIdentity);
1302         }
<span class="line-modified">1303         assert !(replacee instanceof MultiMemoryKill) : replacee + &quot; multi not supported (yet)&quot;;</span>
1304 
1305         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1306         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1307             kills.remove(any());
1308         }
1309 
1310         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1311         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1312 
1313         /*
1314          * Kills to private locations are safe, since there can be no floating read to these
1315          * locations except reads that are introduced by the snippet itself or related snippets in
1316          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1317          * their snippet, so they can not float above a kill in another instance of the same
1318          * snippet.
1319          */
1320         for (LocationIdentity p : this.info.privateLocations) {
1321             kills.remove(p);
1322         }
1323 
</pre>
<hr />
<pre>
1494             StructuredGraph replaceeGraph = replacee.graph();
1495             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1496             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1497             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1498 
1499             // Re-wire the control flow graph around the replacee
1500             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1501             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1502 
1503             rewireFrameStates(replacee, duplicates);
1504 
1505             updateStamps(replacee, duplicates);
1506 
1507             rewireMemoryGraph(replacee, duplicates);
1508 
1509             // Replace all usages of the replacee with the value returned by the snippet
1510             ValueNode returnValue = null;
1511             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1512                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1513                 returnValue = returnDuplicate.result();
<span class="line-modified">1514                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryKill) {</span>
1515                     replacer.replace(replacee, null);
1516                 } else {
1517                     assert returnValue != null || replacee.hasNoUsages();
1518                     replacer.replace(replacee, returnValue);
1519                 }
1520                 if (returnDuplicate.isAlive()) {
1521                     FixedNode next = null;
1522                     if (replacee instanceof FixedWithNextNode) {
1523                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1524                         next = fwn.next();
1525                         fwn.setNext(null);
1526                     }
1527                     returnDuplicate.replaceAndDelete(next);
1528                 }
1529             }
1530 
1531             if (killReplacee) {
1532                 // Remove the replacee from its graph
1533                 GraphUtil.killCFG(replacee);
1534             }
</pre>
<hr />
<pre>
1777                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1778             } else {
1779                 ParameterNode[] params = (ParameterNode[]) value;
1780                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1781                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1782             }
1783         }
1784         return buf.append(&#39;)&#39;).toString();
1785     }
1786 
1787     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1788         int offset = args.info.hasReceiver() ? 1 : 0;
1789         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1790             if (args.info.isConstantParameter(i)) {
1791                 JavaKind kind = signature.getParameterKind(i - offset);
1792                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1793 
1794             } else if (args.info.isVarargsParameter(i)) {
1795                 assert args.values[i] instanceof Varargs;
1796                 Varargs varargs = (Varargs) args.values[i];
<span class="line-modified">1797                 assert checkVarargs(metaAccess, method, signature, i - offset, args.info.getParameterName(i), varargs);</span>
1798             }
1799         }
1800         return true;
1801     }
1802 
1803     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1804         this.mayRemoveLocation = mayRemoveLocation;
1805     }
1806 }
</pre>
</td>
</tr>
</table>
<center><a href="PEGraphDecoder.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="StandardGraphBuilderPlugins.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
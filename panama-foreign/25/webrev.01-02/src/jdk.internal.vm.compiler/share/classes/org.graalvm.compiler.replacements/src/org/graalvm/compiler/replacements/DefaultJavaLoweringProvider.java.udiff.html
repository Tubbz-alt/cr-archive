<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/PointerTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeIntrinsificationProvider.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,10 +82,11 @@</span>
  import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
  import org.graalvm.compiler.nodes.calc.IntegerEqualsNode;
  import org.graalvm.compiler.nodes.calc.IsNullNode;
  import org.graalvm.compiler.nodes.calc.LeftShiftNode;
  import org.graalvm.compiler.nodes.calc.NarrowNode;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.calc.ReinterpretNode;</span>
  import org.graalvm.compiler.nodes.calc.RightShiftNode;
  import org.graalvm.compiler.nodes.calc.SignExtendNode;
  import org.graalvm.compiler.nodes.calc.SubNode;
  import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -125,21 +126,21 @@</span>
  import org.graalvm.compiler.nodes.java.StoreFieldNode;
  import org.graalvm.compiler.nodes.java.StoreIndexedNode;
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
  import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
  import org.graalvm.compiler.nodes.java.ValueCompareAndSwapNode;
<span class="udiff-line-modified-removed">- import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
<span class="udiff-line-modified-added">+ import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>
  import org.graalvm.compiler.nodes.memory.ReadNode;
  import org.graalvm.compiler.nodes.memory.VolatileReadNode;
  import org.graalvm.compiler.nodes.memory.WriteNode;
  import org.graalvm.compiler.nodes.memory.address.AddressNode;
  import org.graalvm.compiler.nodes.memory.address.IndexAddressNode;
  import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
<span class="udiff-line-removed">- import org.graalvm.compiler.nodes.spi.GCProvider;</span>
  import org.graalvm.compiler.nodes.spi.Lowerable;
  import org.graalvm.compiler.nodes.spi.LoweringProvider;
  import org.graalvm.compiler.nodes.spi.LoweringTool;
<span class="udiff-line-added">+ import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;</span>
  import org.graalvm.compiler.nodes.type.StampTool;
  import org.graalvm.compiler.nodes.util.GraphUtil;
  import org.graalvm.compiler.nodes.virtual.AllocatedObjectNode;
  import org.graalvm.compiler.nodes.virtual.CommitAllocationNode;
  import org.graalvm.compiler.nodes.virtual.VirtualArrayNode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -371,16 +372,16 @@</span>
  
      protected void lowerVerifyHeap(VerifyHeapNode n) {
          GraphUtil.removeFixedWithUnusedInputs(n);
      }
  
<span class="udiff-line-modified-removed">-     protected AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {</span>
<span class="udiff-line-modified-added">+     public AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {</span>
          ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
          return graph.unique(new OffsetAddressNode(object, o));
      }
  
<span class="udiff-line-modified-removed">-     protected AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {</span>
<span class="udiff-line-modified-added">+     public AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {</span>
          int offset = fieldOffset(field);
          if (offset &gt;= 0) {
              return createOffsetAddress(graph, object, offset);
          } else {
              return null;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -614,11 +615,11 @@</span>
      }
  
      protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
          ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
          ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
<span class="udiff-line-modified-removed">-         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId()));</span>
<span class="udiff-line-modified-added">+         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId(), monitorEnter.isBiasable()));</span>
          rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
          rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
          graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -672,11 +673,11 @@</span>
  
      /**
       * @param tool utility for performing the lowering
       */
      protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="udiff-line-modified-removed">-         GCProvider gc = tool.getProviders().getGC();</span>
<span class="udiff-line-modified-added">+         PlatformConfigurationProvider gc = tool.getProviders().getPlatformConfigurationProvider();</span>
          StructuredGraph graph = load.graph();
          if (load instanceof GuardedUnsafeLoadNode) {
              GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
              GuardingNode guard = guardedLoad.getGuard();
              if (guard == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -703,11 +704,11 @@</span>
          } else {
              return graph.unique(new OffsetAddressNode(object, offset));
          }
      }
  
<span class="udiff-line-modified-removed">-     protected ReadNode createUnsafeRead(GCProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
<span class="udiff-line-modified-added">+     protected ReadNode createUnsafeRead(PlatformConfigurationProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
          boolean compressible = load.accessKind() == JavaKind.Object;
          JavaKind readKind = load.accessKind();
          Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
          AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
          ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -834,11 +835,12 @@</span>
                              JavaKind valueKind = value.getStackKind();
                              JavaKind entryKind = virtual.entryKind(i);
  
                              // Truffle requires some leniency in terms of what can be put where:
                              assert valueKind.getStackKind() == entryKind.getStackKind() ||
<span class="udiff-line-modified-removed">-                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode));</span>
<span class="udiff-line-modified-added">+                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode) ||</span>
<span class="udiff-line-added">+                                                             (valueKind == JavaKind.Float &amp;&amp; virtual instanceof VirtualArrayNode));</span>
                              AddressNode address = null;
                              BarrierType barrierType = null;
                              if (virtual instanceof VirtualInstanceNode) {
                                  ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
                                  long offset = fieldOffset(field);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -849,11 +851,11 @@</span>
                              } else {
                                  address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));
                                  barrierType = arrayInitializationBarrier(entryKind);
                              }
                              if (address != null) {
<span class="udiff-line-modified-removed">-                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, entryKind, value), barrierType, false);</span>
<span class="udiff-line-modified-added">+                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), arrayImplicitStoreConvert(graph, entryKind, value, commit, virtual, valuePos), barrierType, false);</span>
                                  graph.addAfterFixed(newObject, graph.add(write));
                              }
                          }
                          valuePos++;
                      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -892,11 +894,11 @@</span>
                          valuePos++;
                      }
                  }
              }
  
<span class="udiff-line-modified-removed">-             finishAllocatedObjects(tool, commit, allocations);</span>
<span class="udiff-line-modified-added">+             finishAllocatedObjects(tool, commit, commit, allocations);</span>
              graph.removeFixed(commit);
  
              for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
                  recursiveLowering.lower(tool);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -910,16 +912,18 @@</span>
  
      protected NewArrayNode createNewArrayFromVirtual(VirtualObjectNode virtual, ValueNode length) {
          return new NewArrayNode(((VirtualArrayNode) virtual).componentType(), length, true);
      }
  
<span class="udiff-line-modified-removed">-     public void finishAllocatedObjects(LoweringTool tool, CommitAllocationNode commit, ValueNode[] allocations) {</span>
<span class="udiff-line-modified-added">+     public void finishAllocatedObjects(LoweringTool tool, FixedWithNextNode insertAfter, CommitAllocationNode commit, ValueNode[] allocations) {</span>
<span class="udiff-line-added">+         FixedWithNextNode insertionPoint = insertAfter;</span>
          StructuredGraph graph = commit.graph();
          for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
              FixedValueAnchorNode anchor = graph.add(new FixedValueAnchorNode(allocations[objIndex]));
              allocations[objIndex] = anchor;
<span class="udiff-line-modified-removed">-             graph.addBeforeFixed(commit, anchor);</span>
<span class="udiff-line-modified-added">+             graph.addAfterFixed(insertionPoint, anchor);</span>
<span class="udiff-line-added">+             insertionPoint = anchor;</span>
          }
          /*
           * Note that the FrameState that is assigned to these MonitorEnterNodes isn&#39;t the correct
           * state. It will be the state from before the allocation occurred instead of a valid state
           * after the locking is performed. In practice this should be fine since these are newly
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -941,11 +945,12 @@</span>
              int lastDepth = -1;
              for (MonitorIdNode monitorId : locks) {
                  assert lastDepth &lt; monitorId.getLockDepth();
                  lastDepth = monitorId.getLockDepth();
                  MonitorEnterNode enter = graph.add(new MonitorEnterNode(allocations[objIndex], monitorId));
<span class="udiff-line-modified-removed">-                 graph.addBeforeFixed(commit, enter);</span>
<span class="udiff-line-modified-added">+                 graph.addAfterFixed(insertionPoint, enter);</span>
<span class="udiff-line-added">+                 insertionPoint = enter;</span>
                  if (enters == null) {
                      enters = new ArrayList&lt;&gt;();
                  }
                  enters.add(enter);
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -964,46 +969,46 @@</span>
              for (MonitorEnterNode enter : enters) {
                  enter.lower(tool);
              }
          }
          assert commit.hasNoUsages();
<span class="udiff-line-modified-removed">-         insertAllocationBarrier(commit, graph);</span>
<span class="udiff-line-modified-added">+         insertAllocationBarrier(insertAfter, commit, graph);</span>
      }
  
      /**
       * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
       * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
       * are being written, as if {@link FinalFieldBarrierNode} were emitted.
       */
<span class="udiff-line-modified-removed">-     private static void insertAllocationBarrier(CommitAllocationNode commit, StructuredGraph graph) {</span>
<span class="udiff-line-modified-added">+     private static void insertAllocationBarrier(FixedWithNextNode insertAfter, CommitAllocationNode commit, StructuredGraph graph) {</span>
          int barrier = MemoryBarriers.STORE_STORE;
          outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
              for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
                  if (field.isFinal()) {
                      barrier = barrier | MemoryBarriers.LOAD_STORE;
                      break outer;
                  }
              }
          }
<span class="udiff-line-modified-removed">-         graph.addAfterFixed(commit, graph.add(new MembarNode(barrier, LocationIdentity.init())));</span>
<span class="udiff-line-modified-added">+         graph.addAfterFixed(insertAfter, graph.add(new MembarNode(barrier, LocationIdentity.init())));</span>
      }
  
      /**
       * @param field the field whose barrier type should be returned
       */
<span class="udiff-line-modified-removed">-     protected BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
<span class="udiff-line-modified-added">+     public BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
          return BarrierType.NONE;
      }
  
<span class="udiff-line-modified-removed">-     protected BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
<span class="udiff-line-modified-added">+     public BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
          if (getStorageKind(field) == JavaKind.Object) {
              return BarrierType.FIELD;
          }
          return BarrierType.NONE;
      }
  
<span class="udiff-line-modified-removed">-     protected BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
<span class="udiff-line-modified-added">+     public BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
          if (elementKind == JavaKind.Object) {
              return BarrierType.ARRAY;
          }
          return BarrierType.NONE;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1113,10 +1118,40 @@</span>
                  return new ZeroExtendNode(value, 32);
          }
          return value;
      }
  
<span class="udiff-line-added">+     public ValueNode arrayImplicitStoreConvert(StructuredGraph graph,</span>
<span class="udiff-line-added">+                     JavaKind entryKind,</span>
<span class="udiff-line-added">+                     ValueNode value,</span>
<span class="udiff-line-added">+                     CommitAllocationNode commit,</span>
<span class="udiff-line-added">+                     VirtualObjectNode virtual,</span>
<span class="udiff-line-added">+                     int valuePos) {</span>
<span class="udiff-line-added">+         if (!virtual.isVirtualByteArray()) {</span>
<span class="udiff-line-added">+             return implicitStoreConvert(graph, entryKind, value);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // A virtual entry in a byte array can span multiple bytes. This shortens the entry to fit</span>
<span class="udiff-line-added">+         // in its declared size.</span>
<span class="udiff-line-added">+         int entryIndex = valuePos + 1;</span>
<span class="udiff-line-added">+         int bytes = 1;</span>
<span class="udiff-line-added">+         while (entryIndex &lt; commit.getValues().size() &amp;&amp; commit.getValues().get(entryIndex).isIllegalConstant()) {</span>
<span class="udiff-line-added">+             bytes++;</span>
<span class="udiff-line-added">+             entryIndex++;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         assert bytes &lt;= value.getStackKind().getByteCount();</span>
<span class="udiff-line-added">+         ValueNode entry = value;</span>
<span class="udiff-line-added">+         if (value.getStackKind() == JavaKind.Float) {</span>
<span class="udiff-line-added">+             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Int, entry, NodeView.DEFAULT));</span>
<span class="udiff-line-added">+         } else if (value.getStackKind() == JavaKind.Double) {</span>
<span class="udiff-line-added">+             entry = graph.addOrUnique(ReinterpretNode.create(JavaKind.Long, entry, NodeView.DEFAULT));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         if (bytes &lt; value.getStackKind().getByteCount()) {</span>
<span class="udiff-line-added">+             entry = graph.unique(new NarrowNode(entry, bytes &lt;&lt; 3));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return entry;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      public final ValueNode implicitStoreConvert(StructuredGraph graph, JavaKind kind, ValueNode value) {
          return implicitStoreConvert(graph, kind, value, true);
      }
  
      public ValueNode implicitStoreConvert(JavaKind kind, ValueNode value) {
</pre>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/PointerTest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="NodeIntrinsificationProvider.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static java.util.FormattableFlags.ALTERNATE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
  30 import static org.graalvm.compiler.debug.DebugContext.applyFormattingFlagsAndWidth;
  31 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
  32 import static org.graalvm.compiler.graph.iterators.NodePredicates.isNotA;
  33 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
  34 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
  35 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
  36 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
  37 
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Method;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Collections;
  44 import java.util.Formattable;
  45 import java.util.Formatter;
  46 import java.util.LinkedHashMap;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.atomic.AtomicInteger;
  50 import java.util.concurrent.atomic.AtomicReference;
  51 import java.util.function.Predicate;
  52 
  53 import jdk.internal.vm.compiler.collections.EconomicMap;
  54 import jdk.internal.vm.compiler.collections.EconomicSet;
  55 import jdk.internal.vm.compiler.collections.Equivalence;
  56 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  57 import org.graalvm.compiler.api.replacements.Fold;
  58 import org.graalvm.compiler.api.replacements.Snippet;
  59 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  60 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
  61 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  62 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  63 import org.graalvm.compiler.core.common.GraalOptions;
  64 import org.graalvm.compiler.core.common.type.Stamp;
  65 import org.graalvm.compiler.core.common.type.StampFactory;
  66 import org.graalvm.compiler.core.common.type.StampPair;
  67 import org.graalvm.compiler.core.common.type.TypeReference;
  68 import org.graalvm.compiler.debug.Assertions;
  69 import org.graalvm.compiler.debug.CounterKey;
  70 import org.graalvm.compiler.debug.DebugCloseable;
  71 import org.graalvm.compiler.debug.DebugContext;
  72 import org.graalvm.compiler.debug.DebugContext.Description;
  73 import org.graalvm.compiler.debug.DebugHandlersFactory;
  74 import org.graalvm.compiler.debug.GraalError;
  75 import org.graalvm.compiler.debug.TimerKey;
  76 import org.graalvm.compiler.graph.Graph.Mark;
  77 import org.graalvm.compiler.graph.Node;
  78 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  79 import org.graalvm.compiler.graph.NodeClass;
  80 import org.graalvm.compiler.graph.NodeSourcePosition;
  81 import org.graalvm.compiler.graph.Position;
  82 import org.graalvm.compiler.loop.LoopEx;
  83 import org.graalvm.compiler.loop.LoopsData;
  84 import org.graalvm.compiler.loop.phases.LoopTransformations;
  85 import org.graalvm.compiler.nodeinfo.InputType;
  86 import org.graalvm.compiler.nodeinfo.NodeInfo;
  87 import org.graalvm.compiler.nodes.AbstractBeginNode;
  88 import org.graalvm.compiler.nodes.AbstractMergeNode;
  89 import org.graalvm.compiler.nodes.ConstantNode;
  90 import org.graalvm.compiler.nodes.ControlSinkNode;
  91 import org.graalvm.compiler.nodes.DeoptimizingNode;
  92 import org.graalvm.compiler.nodes.FixedNode;
  93 import org.graalvm.compiler.nodes.FixedWithNextNode;
  94 import org.graalvm.compiler.nodes.FrameState;
  95 import org.graalvm.compiler.nodes.InliningLog;
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
<a name="2" id="anc2"></a><span class="line-modified"> 116 import org.graalvm.compiler.nodes.memory.MemoryKill;</span>
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
 119 import org.graalvm.compiler.nodes.memory.MemoryNode;
 120 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
<a name="3" id="anc3"></a><span class="line-added"> 121 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;</span>
<span class="line-added"> 122 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;</span>
 123 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 124 import org.graalvm.compiler.nodes.spi.CoreProviders;
 125 import org.graalvm.compiler.nodes.spi.LoweringTool;
 126 import org.graalvm.compiler.nodes.spi.MemoryProxy;
 127 import org.graalvm.compiler.nodes.util.GraphUtil;
 128 import org.graalvm.compiler.options.Option;
 129 import org.graalvm.compiler.options.OptionKey;
 130 import org.graalvm.compiler.options.OptionValues;
 131 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 132 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 133 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 134 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 135 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 136 import org.graalvm.compiler.phases.common.LoweringPhase;
 137 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 138 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 139 import org.graalvm.compiler.phases.util.Providers;
 140 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 141 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 142 import org.graalvm.util.CollectionsUtil;
 143 import jdk.internal.vm.compiler.word.LocationIdentity;
 144 import jdk.internal.vm.compiler.word.WordBase;
 145 
 146 import jdk.vm.ci.code.TargetDescription;
 147 import jdk.vm.ci.meta.Constant;
 148 import jdk.vm.ci.meta.ConstantReflectionProvider;
 149 import jdk.vm.ci.meta.JavaConstant;
 150 import jdk.vm.ci.meta.JavaKind;
 151 import jdk.vm.ci.meta.Local;
 152 import jdk.vm.ci.meta.LocalVariableTable;
 153 import jdk.vm.ci.meta.MetaAccessProvider;
 154 import jdk.vm.ci.meta.ResolvedJavaMethod;
 155 import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter;
 156 import jdk.vm.ci.meta.ResolvedJavaType;
 157 import jdk.vm.ci.meta.Signature;
 158 
 159 /**
 160  * A snippet template is a graph created by parsing a snippet method and then specialized by binding
 161  * constants to the snippet&#39;s {@link ConstantParameter} parameters.
 162  *
 163  * Snippet templates can be managed in a cache maintained by {@link AbstractTemplates}.
 164  */
 165 public class SnippetTemplate {
 166 
 167     private boolean mayRemoveLocation = false;
 168 
 169     /**
 170      * Holds the {@link ResolvedJavaMethod} of the snippet, together with some information about the
 171      * method that needs to be computed only once. The {@link SnippetInfo} should be created once
 172      * per snippet and then cached.
 173      */
 174     public abstract static class SnippetInfo {
 175 
 176         protected final ResolvedJavaMethod method;
 177         protected final ResolvedJavaMethod original;
 178         protected final LocationIdentity[] privateLocations;
 179         protected final Object receiver;
 180 
 181         public Object getReceiver() {
 182             return receiver;
 183         }
 184 
 185         boolean hasReceiver() {
 186             assert hasReceiver(method) == (receiver != null) : &quot;Snippet with the receiver must have it set as constant. Snippet: &quot; + this;
 187             return hasReceiver(method);
 188         }
 189 
 190         static boolean hasReceiver(ResolvedJavaMethod method) {
 191             return method.hasReceiver();
 192         }
 193 
 194         /**
 195          * Lazily constructed parts of {@link SnippetInfo}.
 196          */
 197         static class Lazy {
 198             Lazy(ResolvedJavaMethod method) {
 199                 int count = method.getSignature().getParameterCount(hasReceiver(method));
 200                 constantParameters = new boolean[count];
 201                 varargsParameters = new boolean[count];
 202                 nonNullParameters = new boolean[count];
 203                 int offset = hasReceiver(method) ? 1 : 0;
 204                 for (int i = offset; i &lt; count; i++) {
 205                     constantParameters[i] = method.getParameterAnnotation(ConstantParameter.class, i - offset) != null;
 206                     varargsParameters[i] = method.getParameterAnnotation(VarargsParameter.class, i - offset) != null;
 207                     nonNullParameters[i] = method.getParameterAnnotation(NonNullParameter.class, i - offset) != null;
 208 
 209                     assert !constantParameters[i - offset] || !varargsParameters[i - offset] : &quot;Parameter cannot be annotated with both @&quot; + ConstantParameter.class.getSimpleName() + &quot; and @&quot; +
 210                                     VarargsParameter.class.getSimpleName();
 211                 }
 212                 if (method.hasReceiver()) {
 213                     // Receiver must be constant.
 214                     assert !constantParameters[0];
 215                     constantParameters[0] = true;
 216                 }
 217 
 218                 // Retrieve the names only when assertions are turned on. Parameter annotations are
 219                 // unsupported in the native image.
 220                 assert IS_IN_NATIVE_IMAGE || initNames(method, count);
 221             }
 222 
 223             final boolean[] constantParameters;
 224             final boolean[] varargsParameters;
 225             final boolean[] nonNullParameters;
 226 
 227             /**
 228              * The parameter names, taken from the local variables table. Only used for assertion
 229              * checking, so use only within an assert statement.
 230              */
 231             String[] names;
 232 
 233             private boolean initNames(ResolvedJavaMethod method, int parameterCount) {
 234                 names = new String[parameterCount];
 235                 int offset = 0;
 236                 if (method.hasReceiver()) {
 237                     names[0] = &quot;this&quot;;
 238                     offset = 1;
 239                 }
 240                 Parameter[] params = method.getParameters();
 241                 if (params != null) {
 242                     for (int i = offset; i &lt; names.length; i++) {
 243                         if (params[i - offset].isNamePresent()) {
 244                             names[i] = params[i - offset].getName();
 245                         }
 246                     }
 247                 } else {
 248                     int slotIdx = 0;
 249                     LocalVariableTable localVariableTable = method.getLocalVariableTable();
 250                     if (localVariableTable != null) {
 251                         for (int i = 0; i &lt; names.length; i++) {
 252                             Local local = localVariableTable.getLocal(slotIdx, 0);
 253                             if (local != null) {
 254                                 names[i] = local.getName();
 255                             }
 256                             JavaKind kind = method.getSignature().getParameterKind(i);
 257                             slotIdx += kind.getSlotCount();
 258                         }
 259                     }
 260                 }
 261                 return true;
 262             }
 263         }
 264 
 265         /**
 266          * Times instantiations of all templates derived from this snippet.
 267          */
 268         private final TimerKey instantiationTimer;
 269 
 270         /**
 271          * Counts instantiations of all templates derived from this snippet.
 272          */
 273         private final CounterKey instantiationCounter;
 274 
 275         protected abstract Lazy lazy();
 276 
 277         protected SnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 278             this.method = method;
 279             this.original = original;
 280             this.privateLocations = privateLocations;
 281             instantiationCounter = DebugContext.counter(&quot;SnippetInstantiationCount[%s]&quot;, method.getName());
 282             instantiationTimer = DebugContext.timer(&quot;SnippetInstantiationTime[%s]&quot;, method.getName());
 283             this.receiver = receiver;
 284         }
 285 
 286         public ResolvedJavaMethod getMethod() {
 287             return method;
 288         }
 289 
 290         public int getParameterCount() {
 291             return lazy().constantParameters.length;
 292         }
 293 
 294         public boolean isConstantParameter(int paramIdx) {
 295             return lazy().constantParameters[paramIdx];
 296         }
 297 
 298         public boolean isVarargsParameter(int paramIdx) {
 299             return lazy().varargsParameters[paramIdx];
 300         }
 301 
 302         public boolean isNonNullParameter(int paramIdx) {
 303             return lazy().nonNullParameters[paramIdx];
 304         }
 305 
 306         public String getParameterName(int paramIdx) {
 307             String[] names = lazy().names;
 308             if (names != null) {
 309                 return names[paramIdx];
 310             }
 311             return null;
 312         }
 313 
 314         @Override
 315         public String toString() {
 316             return getClass().getSimpleName() + &quot;:&quot; + method.format(&quot;%h.%n&quot;);
 317         }
 318     }
 319 
 320     protected static class LazySnippetInfo extends SnippetInfo {
 321         protected final AtomicReference&lt;Lazy&gt; lazy = new AtomicReference&lt;&gt;(null);
 322 
 323         protected LazySnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 324             super(method, original, privateLocations, receiver);
 325         }
 326 
 327         @Override
 328         protected Lazy lazy() {
 329             if (lazy.get() == null) {
 330                 lazy.compareAndSet(null, new Lazy(method));
 331             }
 332             return lazy.get();
 333         }
 334     }
 335 
 336     protected static class EagerSnippetInfo extends SnippetInfo {
 337         protected final Lazy lazy;
 338 
 339         protected EagerSnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 340             super(method, original, privateLocations, receiver);
 341             lazy = new Lazy(method);
 342         }
 343 
 344         @Override
 345         protected Lazy lazy() {
 346             return lazy;
 347         }
 348     }
 349 
 350     /**
 351      * Values that are bound to the snippet method parameters. The methods {@link #add},
 352      * {@link #addConst}, and {@link #addVarargs} must be called in the same order as in the
 353      * signature of the snippet method. The parameter name is passed to the add methods for
 354      * assertion checking, i.e., to enforce that the order matches. Which method needs to be called
 355      * depends on the annotation of the snippet method parameter:
 356      * &lt;ul&gt;
 357      * &lt;li&gt;Use {@link #add} for a parameter without an annotation. The value is bound when the
 358      * {@link SnippetTemplate} is {@link SnippetTemplate#instantiate instantiated}.
 359      * &lt;li&gt;Use {@link #addConst} for a parameter annotated with {@link ConstantParameter}. The value
 360      * is bound when the {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created}.
 361      * &lt;li&gt;Use {@link #addVarargs} for an array parameter annotated with {@link VarargsParameter}. A
 362      * separate {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created} for every
 363      * distinct array length. The actual values are bound when the {@link SnippetTemplate} is
 364      * {@link SnippetTemplate#instantiate instantiated}
 365      * &lt;/ul&gt;
 366      */
 367     public static class Arguments implements Formattable {
 368 
 369         protected final SnippetInfo info;
 370         protected final CacheKey cacheKey;
 371         protected final Object[] values;
 372         protected final Stamp[] constStamps;
 373         protected boolean cacheable;
 374 
 375         protected int nextParamIdx;
 376 
 377         public Arguments(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 378             this.info = info;
 379             this.cacheKey = new CacheKey(info, guardsStage, loweringStage);
 380             this.values = new Object[info.getParameterCount()];
 381             this.constStamps = new Stamp[info.getParameterCount()];
 382             this.cacheable = true;
 383             if (info.hasReceiver()) {
 384                 addConst(&quot;this&quot;, info.getReceiver());
 385             }
 386         }
 387 
 388         public Arguments add(String name, Object value) {
 389             assert check(name, false, false);
 390             values[nextParamIdx] = value;
 391             nextParamIdx++;
 392             return this;
 393         }
 394 
 395         public Arguments addConst(String name, Object value) {
 396             assert value != null;
 397             return addConst(name, value, null);
 398         }
 399 
 400         public Arguments addConst(String name, Object value, Stamp stamp) {
 401             assert check(name, true, false);
 402             values[nextParamIdx] = value;
 403             constStamps[nextParamIdx] = stamp;
 404             cacheKey.setParam(nextParamIdx, value);
 405             nextParamIdx++;
 406             return this;
 407         }
 408 
 409         public Arguments addVarargs(String name, Class&lt;?&gt; componentType, Stamp argStamp, Object value) {
 410             assert check(name, false, true);
 411             Varargs varargs = new Varargs(componentType, argStamp, value);
 412             values[nextParamIdx] = varargs;
 413             // A separate template is necessary for every distinct array length
 414             cacheKey.setParam(nextParamIdx, varargs.length);
 415             nextParamIdx++;
 416             return this;
 417         }
 418 
 419         public void setCacheable(boolean cacheable) {
 420             this.cacheable = cacheable;
 421         }
 422 
 423         private boolean check(String name, boolean constParam, boolean varargsParam) {
 424             assert nextParamIdx &lt; info.getParameterCount() : &quot;too many parameters: &quot; + name + &quot;  &quot; + this;
 425             assert info.getParameterName(nextParamIdx) == null || info.getParameterName(nextParamIdx).equals(name) : &quot;wrong parameter name at &quot; + nextParamIdx + &quot; : &quot; + name + &quot;  &quot; + this;
 426             assert constParam == info.isConstantParameter(nextParamIdx) : &quot;Parameter &quot; + (constParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + ConstantParameter.class.getSimpleName() + &quot;: &quot; + name +
 427                             &quot;  &quot; + this;
 428             assert varargsParam == info.isVarargsParameter(nextParamIdx) : &quot;Parameter &quot; + (varargsParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + VarargsParameter.class.getSimpleName() + &quot;: &quot; + name +
 429                             &quot;  &quot; + this;
 430             return true;
 431         }
 432 
 433         @Override
 434         public String toString() {
 435             StringBuilder result = new StringBuilder();
 436             result.append(&quot;Parameters&lt;&quot;).append(info.method.format(&quot;%h.%n&quot;)).append(&quot; [&quot;);
 437             String sep = &quot;&quot;;
 438             for (int i = 0; i &lt; info.getParameterCount(); i++) {
 439                 result.append(sep);
 440                 if (info.isConstantParameter(i)) {
 441                     result.append(&quot;const &quot;);
 442                 } else if (info.isVarargsParameter(i)) {
 443                     result.append(&quot;varargs &quot;);
 444                 }
 445                 result.append(info.getParameterName(i)).append(&quot; = &quot;).append(values[i]);
 446                 sep = &quot;, &quot;;
 447             }
 448             result.append(&quot;&gt;&quot;);
 449             return result.toString();
 450         }
 451 
 452         @Override
 453         public void formatTo(Formatter formatter, int flags, int width, int precision) {
 454             if ((flags &amp; ALTERNATE) == 0) {
 455                 formatter.format(applyFormattingFlagsAndWidth(toString(), flags, width));
 456             } else {
 457                 StringBuilder sb = new StringBuilder();
 458                 sb.append(info.method.getName()).append(&#39;(&#39;);
 459                 String sep = &quot;&quot;;
 460                 for (int i = 0; i &lt; info.getParameterCount(); i++) {
 461                     if (info.isConstantParameter(i)) {
 462                         sb.append(sep);
 463                         if (info.getParameterName(i) != null) {
 464                             sb.append(info.getParameterName(i));
 465                         } else {
 466                             sb.append(i);
 467                         }
 468                         sb.append(&#39;=&#39;).append(values[i]);
 469                         sep = &quot;, &quot;;
 470                     }
 471                 }
 472                 sb.append(&quot;)&quot;);
 473                 String string = sb.toString();
 474                 if (string.indexOf(&#39;%&#39;) != -1) {
 475                     // Quote any % signs
 476                     string = string.replace(&quot;%&quot;, &quot;%%&quot;);
 477                 }
 478                 formatter.format(applyFormattingFlagsAndWidth(string, flags &amp; ~ALTERNATE, width));
 479             }
 480         }
 481     }
 482 
 483     /**
 484      * Wrapper for the prototype value of a {@linkplain VarargsParameter varargs} parameter.
 485      */
 486     static class Varargs {
 487 
 488         protected final Class&lt;?&gt; componentType;
 489         protected final Stamp stamp;
 490         protected final Object value;
 491         protected final int length;
 492 
 493         protected Varargs(Class&lt;?&gt; componentType, Stamp stamp, Object value) {
 494             this.componentType = componentType;
 495             this.stamp = stamp;
 496             this.value = value;
 497             if (value instanceof List) {
 498                 this.length = ((List&lt;?&gt;) value).size();
 499             } else {
 500                 this.length = Array.getLength(value);
 501             }
 502         }
 503 
 504         @Override
 505         public String toString() {
 506             if (value instanceof boolean[]) {
 507                 return Arrays.toString((boolean[]) value);
 508             }
 509             if (value instanceof byte[]) {
 510                 return Arrays.toString((byte[]) value);
 511             }
 512             if (value instanceof char[]) {
 513                 return Arrays.toString((char[]) value);
 514             }
 515             if (value instanceof short[]) {
 516                 return Arrays.toString((short[]) value);
 517             }
 518             if (value instanceof int[]) {
 519                 return Arrays.toString((int[]) value);
 520             }
 521             if (value instanceof long[]) {
 522                 return Arrays.toString((long[]) value);
 523             }
 524             if (value instanceof float[]) {
 525                 return Arrays.toString((float[]) value);
 526             }
 527             if (value instanceof double[]) {
 528                 return Arrays.toString((double[]) value);
 529             }
 530             if (value instanceof Object[]) {
 531                 return Arrays.toString((Object[]) value);
 532             }
 533             return String.valueOf(value);
 534         }
 535     }
 536 
 537     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 538     static final class VarargsPlaceholderNode extends FloatingNode implements ArrayLengthProvider {
 539 
 540         public static final NodeClass&lt;VarargsPlaceholderNode&gt; TYPE = NodeClass.create(VarargsPlaceholderNode.class);
 541         protected final Varargs varargs;
 542 
 543         protected VarargsPlaceholderNode(Varargs varargs, MetaAccessProvider metaAccess) {
 544             super(TYPE, StampFactory.objectNonNull(TypeReference.createExactTrusted(metaAccess.lookupJavaType(varargs.componentType).getArrayClass())));
 545             this.varargs = varargs;
 546         }
 547 
 548         @Override
 549         public ValueNode findLength(FindLengthMode mode, ConstantReflectionProvider constantReflection) {
 550             return ConstantNode.forInt(varargs.length);
 551         }
 552     }
 553 
 554     static class CacheKey {
 555 
 556         private final ResolvedJavaMethod method;
 557         private final Object[] values;
 558         private final GuardsStage guardsStage;
 559         private final LoweringTool.LoweringStage loweringStage;
 560         private int hash;
 561 
 562         protected CacheKey(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 563             this.method = info.method;
 564             this.guardsStage = guardsStage;
 565             this.loweringStage = loweringStage;
 566             this.values = new Object[info.getParameterCount()];
 567             this.hash = info.method.hashCode() + 31 * guardsStage.ordinal();
 568         }
 569 
 570         protected void setParam(int paramIdx, Object value) {
 571             values[paramIdx] = value;
 572             hash = (hash * 31) ^ (value == null ? 0 : value.hashCode());
 573         }
 574 
 575         @Override
 576         public boolean equals(Object obj) {
 577             if (!(obj instanceof CacheKey)) {
 578                 return false;
 579             }
 580             CacheKey other = (CacheKey) obj;
 581             if (!method.equals(other.method)) {
 582                 return false;
 583             }
 584             if (guardsStage != other.guardsStage || loweringStage != other.loweringStage) {
 585                 return false;
 586             }
 587             for (int i = 0; i &lt; values.length; i++) {
 588                 if (values[i] != null &amp;&amp; !values[i].equals(other.values[i])) {
 589                     return false;
 590                 }
 591             }
 592             return true;
 593         }
 594 
 595         @Override
 596         public int hashCode() {
 597             return hash;
 598         }
 599     }
 600 
 601     private static final TimerKey SnippetTemplateCreationTime = DebugContext.timer(&quot;SnippetTemplateCreationTime&quot;);
 602     private static final CounterKey SnippetTemplates = DebugContext.counter(&quot;SnippetTemplateCount&quot;);
 603 
 604     static class Options {
 605         @Option(help = &quot;Use a LRU cache for snippet templates.&quot;)//
 606         public static final OptionKey&lt;Boolean&gt; UseSnippetTemplateCache = new OptionKey&lt;&gt;(true);
 607 
 608         @Option(help = &quot;&quot;)//
 609         static final OptionKey&lt;Integer&gt; MaxTemplatesPerSnippet = new OptionKey&lt;&gt;(50);
 610     }
 611 
 612     /**
 613      * Base class for snippet classes. It provides a cache for {@link SnippetTemplate}s.
 614      */
 615     public abstract static class AbstractTemplates implements org.graalvm.compiler.api.replacements.SnippetTemplateCache {
 616 
 617         protected final OptionValues options;
 618         protected final Providers providers;
 619         protected final SnippetReflectionProvider snippetReflection;
 620         protected final Iterable&lt;DebugHandlersFactory&gt; factories;
 621         protected final TargetDescription target;
 622         private final Map&lt;CacheKey, SnippetTemplate&gt; templates;
 623 
 624         protected AbstractTemplates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
 625             this.options = options;
 626             this.providers = providers;
 627             this.snippetReflection = snippetReflection;
 628             this.target = target;
 629             this.factories = factories;
 630             if (Options.UseSnippetTemplateCache.getValue(options)) {
 631                 int size = Options.MaxTemplatesPerSnippet.getValue(options);
 632                 this.templates = Collections.synchronizedMap(new LRUCache&lt;&gt;(size, size));
 633             } else {
 634                 this.templates = null;
 635             }
 636         }
 637 
 638         public Providers getProviders() {
 639             return providers;
 640         }
 641 
 642         public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
 643             for (Method m : declaringClass.getDeclaredMethods()) {
 644                 if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
 645                     return m;
 646                 }
 647             }
 648             return null;
 649         }
 650 
 651         public static ResolvedJavaMethod findMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; declaringClass, String methodName) {
 652             ResolvedJavaType type = metaAccess.lookupJavaType(declaringClass);
 653             ResolvedJavaMethod result = null;
 654             for (ResolvedJavaMethod m : type.getDeclaredMethods()) {
 655                 if (m.getName().equals(methodName)) {
 656                     if (!Assertions.assertionsEnabled()) {
 657                         return m;
 658                     } else {
 659                         assert result == null : &quot;multiple definitions found&quot;;
 660                         result = m;
 661                     }
 662                 }
 663             }
 664             if (result == null) {
 665                 throw new GraalError(&quot;Could not find method in &quot; + declaringClass + &quot; named &quot; + methodName);
 666             }
 667             return result;
 668         }
 669 
 670         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, LocationIdentity... initialPrivateLocations) {
 671             return snippet(declaringClass, methodName, null, null, initialPrivateLocations);
 672         }
 673 
 674         /**
 675          * Finds the unique method in {@code declaringClass} named {@code methodName} annotated by
 676          * {@link Snippet} and returns a {@link SnippetInfo} value describing it. There must be
 677          * exactly one snippet method in {@code declaringClass} with a given name.
 678          */
 679         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
 680             assert methodName != null;
 681             ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
 682             assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
 683             assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
 684             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options), options);
 685             LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
 686             if (GraalOptions.EagerSnippets.getValue(options)) {
 687                 return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
 688             } else {
 689                 return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
 690             }
 691         }
 692 
 693         static final AtomicInteger nextSnippetTemplateId = new AtomicInteger();
 694 
 695         private DebugContext openDebugContext(DebugContext outer, Arguments args) {
 696             if (DebugStubsAndSnippets.getValue(options)) {
 697                 Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
 698                 return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
 699             }
 700             return DebugContext.disabled(options);
 701         }
 702 
 703         /**
 704          * Gets a template for a given key, creating it first if necessary.
 705          */
 706         @SuppressWarnings(&quot;try&quot;)
 707         public SnippetTemplate template(ValueNode replacee, final Arguments args) {
 708             StructuredGraph graph = replacee.graph();
 709             DebugContext outer = graph.getDebug();
 710             SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
 711             if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
 712                 try (DebugContext debug = openDebugContext(outer, args)) {
 713                     try (DebugCloseable a = SnippetTemplateCreationTime.start(debug); DebugContext.Scope s = debug.scope(&quot;SnippetSpecialization&quot;, args.info.method)) {
 714                         SnippetTemplates.increment(debug);
 715                         OptionValues snippetOptions = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));
 716                         template = new SnippetTemplate(snippetOptions, debug, providers, snippetReflection, args, graph.trackNodeSourcePosition(), replacee);
 717                         if (Options.UseSnippetTemplateCache.getValue(snippetOptions) &amp;&amp; args.cacheable) {
 718                             templates.put(args.cacheKey, template);
 719                         }
 720                     } catch (Throwable e) {
 721                         throw debug.handle(e);
 722                     }
 723                 }
 724             }
 725             return template;
 726         }
 727     }
 728 
 729     private static final class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
 730         private static final long serialVersionUID = 1L;
 731         private final int maxCacheSize;
 732 
 733         LRUCache(int initialCapacity, int maxCacheSize) {
 734             super(initialCapacity, 0.75F, true);
 735             this.maxCacheSize = maxCacheSize;
 736         }
 737 
 738         @Override
 739         protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {
 740             return size() &gt; maxCacheSize;
 741         }
 742     }
 743 
 744     // These values must be compared with equals() not &#39;==&#39; to support replay compilation.
 745     private static final Object UNUSED_PARAMETER = &quot;UNUSED_PARAMETER&quot;;
 746     private static final Object CONSTANT_PARAMETER = &quot;CONSTANT_PARAMETER&quot;;
 747 
 748     /**
 749      * Determines if any parameter of a given method is annotated with {@link ConstantParameter}.
 750      */
 751     public static boolean hasConstantParameter(ResolvedJavaMethod method) {
 752         for (ConstantParameter p : method.getParameterAnnotations(ConstantParameter.class)) {
 753             if (p != null) {
 754                 return true;
 755             }
 756         }
 757         return false;
 758     }
 759 
 760     private final SnippetReflectionProvider snippetReflection;
 761 
 762     /**
 763      * Creates a snippet template.
 764      */
 765     @SuppressWarnings(&quot;try&quot;)
 766     protected SnippetTemplate(OptionValues options, DebugContext debug, final Providers providers, SnippetReflectionProvider snippetReflection, Arguments args, boolean trackNodeSourcePosition,
 767                     Node replacee) {
 768         this.snippetReflection = snippetReflection;
 769         this.info = args.info;
 770 
 771         Object[] constantArgs = getConstantArgs(args);
 772         boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
 773         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition(),
 774                         options);
 775 
 776         ResolvedJavaMethod method = snippetGraph.method();
 777         Signature signature = method.getSignature();
 778 
 779         // Copy snippet graph, replacing constant parameters with given arguments
 780         final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
 781                         snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
 782         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
 783         try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
 784             if (!snippetGraph.isUnsafeAccessTrackingEnabled()) {
 785                 snippetCopy.disableUnsafeAccessTracking();
 786             }
 787 
 788             EconomicMap&lt;Node, Node&gt; nodeReplacements = EconomicMap.create(Equivalence.IDENTITY);
 789             nodeReplacements.put(snippetGraph.start(), snippetCopy.start());
 790 
 791             MetaAccessProvider metaAccess = providers.getMetaAccess();
 792             assert checkTemplate(metaAccess, args, method, signature);
 793 
 794             int parameterCount = args.info.getParameterCount();
 795             VarargsPlaceholderNode[] placeholders = new VarargsPlaceholderNode[parameterCount];
 796 
 797             for (int i = 0; i &lt; parameterCount; i++) {
 798                 ParameterNode parameter = snippetGraph.getParameter(i);
 799                 if (parameter != null) {
 800                     if (args.info.isConstantParameter(i)) {
 801                         Object arg = args.values[i];
 802                         JavaKind kind = signature.getParameterKind(i);
 803                         ConstantNode constantNode;
 804                         if (arg instanceof Constant) {
 805                             Stamp stamp = args.constStamps[i];
 806                             if (stamp == null) {
 807                                 assert arg instanceof JavaConstant : &quot;could not determine type of constant &quot; + arg;
 808                                 constantNode = ConstantNode.forConstant((JavaConstant) arg, metaAccess, snippetCopy);
 809                             } else {
 810                                 constantNode = ConstantNode.forConstant(stamp, (Constant) arg, metaAccess, snippetCopy);
 811                             }
 812                         } else {
 813                             constantNode = ConstantNode.forConstant(snippetReflection.forBoxed(kind, arg), metaAccess, snippetCopy);
 814                         }
 815                         nodeReplacements.put(parameter, constantNode);
 816                     } else if (args.info.isVarargsParameter(i)) {
 817                         Varargs varargs = (Varargs) args.values[i];
 818                         VarargsPlaceholderNode placeholder = snippetCopy.unique(new VarargsPlaceholderNode(varargs, providers.getMetaAccess()));
 819                         nodeReplacements.put(parameter, placeholder);
 820                         placeholders[i] = placeholder;
 821                     } else if (args.info.isNonNullParameter(i)) {
 822                         parameter.setStamp(parameter.stamp(NodeView.DEFAULT).join(StampFactory.objectNonNull()));
 823                     }
 824                 }
 825             }
 826             try (InliningLog.UpdateScope updateScope = snippetCopy.getInliningLog().openDefaultUpdateScope()) {
 827                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = snippetCopy.addDuplicates(snippetGraph.getNodes(), snippetGraph, snippetGraph.getNodeCount(), nodeReplacements);
 828                 if (updateScope != null) {
 829                     snippetCopy.getInliningLog().replaceLog(duplicates, snippetGraph.getInliningLog());
 830                 }
 831             }
 832 
 833             debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before specialization&quot;);
 834 
 835             // Gather the template parameters
 836             parameters = new Object[parameterCount];
 837             for (int i = 0; i &lt; parameterCount; i++) {
 838                 if (args.info.isConstantParameter(i)) {
 839                     parameters[i] = CONSTANT_PARAMETER;
 840                 } else if (args.info.isVarargsParameter(i)) {
 841                     assert snippetCopy.getParameter(i) == null;
 842                     Varargs varargs = (Varargs) args.values[i];
 843                     int length = varargs.length;
 844                     ParameterNode[] params = new ParameterNode[length];
 845                     Stamp stamp = varargs.stamp;
 846                     for (int j = 0; j &lt; length; j++) {
 847                         // Use a decimal friendly numbering make it more obvious how values map
 848                         assert parameterCount &lt; 10000;
 849                         int idx = (i + 1) * 10000 + j;
 850                         assert idx &gt;= parameterCount : &quot;collision in parameter numbering&quot;;
 851                         ParameterNode local = snippetCopy.addOrUnique(new ParameterNode(idx, StampPair.createSingle(stamp)));
 852                         params[j] = local;
 853                     }
 854                     parameters[i] = params;
 855 
 856                     VarargsPlaceholderNode placeholder = placeholders[i];
 857                     if (placeholder != null) {
 858                         for (Node usage : placeholder.usages().snapshot()) {
 859                             if (usage instanceof LoadIndexedNode) {
 860                                 LoadIndexedNode loadIndexed = (LoadIndexedNode) usage;
 861                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before replacing %s&quot;, loadIndexed);
 862                                 LoadSnippetVarargParameterNode loadSnippetParameter = snippetCopy.add(
 863                                                 new LoadSnippetVarargParameterNode(params, loadIndexed.index(), loadIndexed.stamp(NodeView.DEFAULT)));
 864                                 snippetCopy.replaceFixedWithFixed(loadIndexed, loadSnippetParameter);
 865                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;After replacing %s&quot;, loadIndexed);
 866                             } else if (usage instanceof StoreIndexedNode) {
 867                                 /*
 868                                  * The template lowering doesn&#39;t really treat this as an array so
 869                                  * you can&#39;t store back into the varargs. Allocate your own array if
 870                                  * you really need this and EA should eliminate it.
 871                                  */
 872                                 throw new GraalError(&quot;Can&#39;t store into VarargsParameter array&quot;);
 873                             }
 874                         }
 875                     }
 876                 } else {
 877                     ParameterNode local = snippetCopy.getParameter(i);
 878                     if (local == null) {
 879                         // Parameter value was eliminated
 880                         parameters[i] = UNUSED_PARAMETER;
 881                     } else {
 882                         parameters[i] = local;
 883                     }
 884                 }
 885             }
 886 
 887             explodeLoops(snippetCopy, providers);
 888 
 889             GuardsStage guardsStage = args.cacheKey.guardsStage;
 890             // Perform lowering on the snippet
 891             if (!guardsStage.allowsFloatingGuards()) {
 892                 new GuardLoweringPhase().apply(snippetCopy, null);
 893             }
 894             snippetCopy.setGuardsStage(guardsStage);
 895             try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
 896                 new LoweringPhase(CanonicalizerPhase.create(), args.cacheKey.loweringStage).apply(snippetCopy, providers);
 897             } catch (Throwable e) {
 898                 throw debug.handle(e);
 899             }
 900 
 901             ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
 902             ArrayList&lt;DeoptimizingNode&gt; curDeoptNodes = new ArrayList&lt;&gt;();
 903             ArrayList&lt;ValueNode&gt; curPlaceholderStampedNodes = new ArrayList&lt;&gt;();
 904             for (Node node : snippetCopy.getNodes()) {
 905                 if (node instanceof ValueNode) {
 906                     ValueNode valueNode = (ValueNode) node;
 907                     if (valueNode.stamp(NodeView.DEFAULT) == PlaceholderStamp.singleton()) {
 908                         curPlaceholderStampedNodes.add(valueNode);
 909                     }
 910                 }
 911 
 912                 if (node instanceof StateSplit) {
 913                     StateSplit stateSplit = (StateSplit) node;
 914                     FrameState frameState = stateSplit.stateAfter();
 915                     if (stateSplit.hasSideEffect()) {
 916                         curSideEffectNodes.add((StateSplit) node);
 917                     }
 918                     if (frameState != null) {
 919                         stateSplit.setStateAfter(null);
 920                     }
 921                 }
 922                 if (node instanceof DeoptimizingNode) {
 923                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 924                     if (deoptNode.canDeoptimize()) {
 925                         curDeoptNodes.add(deoptNode);
 926                     }
 927                 }
 928             }
 929 
 930             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 931 
 932             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 933 
<a name="4" id="anc4"></a><span class="line-modified"> 934             if (((StructuredGraph) replacee.graph()).isAfterFloatingReadPhase()) {</span>
<span class="line-added"> 935                 new FloatingReadPhase(true, true).apply(snippetCopy);</span>
<span class="line-added"> 936             }</span>
 937 
 938             if (!guardsStage.requiresValueProxies()) {
 939                 new RemoveValueProxyPhase().apply(snippetCopy);
 940             }
 941 
 942             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode());
 943             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 944 
 945             this.snippet = snippetCopy;
 946 
 947             StartNode entryPointNode = snippet.start();
 948             if (anchor.hasNoUsages()) {
 949                 anchor.safeDelete();
 950                 this.memoryAnchor = null;
 951             } else {
 952                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 953                 // anywhere)
 954                 boolean needsMemoryMaps = false;
 955                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 956                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 957                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 958                         needsMemoryMaps = true;
 959                         break;
 960                     }
 961                 }
 962                 boolean needsAnchor;
 963                 if (needsMemoryMaps) {
 964                     needsAnchor = true;
 965                 } else {
 966                     // Check that all those memory maps where the only usages of the anchor
 967                     needsAnchor = anchor.usages().filter(isNotA(MemoryMapNode.class)).isNotEmpty();
 968                     // Remove the useless memory map
 969                     MemoryMapNode memoryMap = null;
 970                     for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 971                         if (memoryMap == null) {
 972                             memoryMap = retNode.getMemoryMap();
 973                         } else {
 974                             assert memoryMap == retNode.getMemoryMap();
 975                         }
 976                         retNode.setMemoryMap(null);
 977                     }
 978                     if (memoryMap != null) {
 979                         memoryMap.safeDelete();
 980                     }
 981                 }
 982                 if (needsAnchor) {
 983                     snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
 984                     this.memoryAnchor = anchor;
 985                 } else {
 986                     anchor.safeDelete();
 987                     this.memoryAnchor = null;
 988                 }
 989             }
 990             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate after fixing memory anchoring&quot;);
 991 
 992             List&lt;ReturnNode&gt; returnNodes = snippet.getNodes(ReturnNode.TYPE).snapshot();
 993             if (returnNodes.isEmpty()) {
 994                 this.returnNode = null;
 995             } else if (returnNodes.size() == 1) {
 996                 this.returnNode = returnNodes.get(0);
 997             } else {
 998                 AbstractMergeNode merge = snippet.add(new MergeNode());
 999                 List&lt;MemoryMapNode&gt; memMaps = new ArrayList&lt;&gt;();
1000                 for (ReturnNode retNode : returnNodes) {
1001                     MemoryMapNode memoryMapNode = retNode.getMemoryMap();
1002                     if (memoryMapNode != null) {
1003                         memMaps.add(memoryMapNode);
1004                     }
1005                 }
1006 
1007                 ValueNode returnValue = InliningUtil.mergeReturns(merge, returnNodes);
1008                 this.returnNode = snippet.add(new ReturnNode(returnValue));
1009                 if (!memMaps.isEmpty()) {
1010                     MemoryMapImpl mmap = FloatingReadPhase.mergeMemoryMaps(merge, memMaps);
1011                     MemoryMapNode memoryMap = snippet.unique(new MemoryMapNode(mmap.getMap()));
1012                     this.returnNode.setMemoryMap(memoryMap);
1013                     for (MemoryMapNode mm : memMaps) {
1014                         if (mm != memoryMap &amp;&amp; mm.isAlive()) {
1015                             assert mm.hasNoUsages();
1016                             GraphUtil.killWithUnusedFloatingInputs(mm);
1017                         }
1018                     }
1019                 }
1020                 merge.setNext(this.returnNode);
1021             }
1022 
1023             assert verifyIntrinsicsProcessed(snippetCopy);
1024 
1025             this.sideEffectNodes = curSideEffectNodes;
1026             this.deoptNodes = curDeoptNodes;
1027             this.placeholderStampedNodes = curPlaceholderStampedNodes;
1028 
1029             nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());
1030             for (Node node : snippet.getNodes()) {
1031                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {
1032                     nodes.add(node);
1033                 }
1034             }
1035 
1036             if (debug.areMetricsEnabled()) {
1037                 DebugContext.counter(&quot;SnippetTemplateNodeCount[%#s]&quot;, args).add(debug, nodes.size());
1038             }
1039             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate final state&quot;);
1040             this.snippet.freeze();
1041 
1042         } catch (Throwable ex) {
1043             throw debug.handle(ex);
1044         }
1045     }
1046 
1047     private static boolean verifyIntrinsicsProcessed(StructuredGraph snippetCopy) {
1048         for (MethodCallTargetNode target : snippetCopy.getNodes(MethodCallTargetNode.TYPE)) {
1049             ResolvedJavaMethod targetMethod = target.targetMethod();
1050             if (targetMethod != null) {
1051                 assert targetMethod.getAnnotation(Fold.class) == null &amp;&amp; targetMethod.getAnnotation(NodeIntrinsic.class) == null : &quot;plugin should have been processed&quot;;
1052             }
1053         }
1054         return true;
1055     }
1056 
1057     public static void explodeLoops(final StructuredGraph snippetCopy, CoreProviders providers) {
1058         // Do any required loop explosion
1059         boolean exploded = false;
1060         do {
1061             exploded = false;
1062             ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
1063             if (explodeLoop != null) { // Earlier canonicalization may have removed the loop
1064                 // altogether
1065                 LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
1066                 if (loopBegin != null) {
1067                     LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
1068                     Mark mark = snippetCopy.getMark();
1069                     CanonicalizerPhase canonicalizer = null;
1070                     if (GraalOptions.ImmutableCode.getValue(snippetCopy.getOptions())) {
1071                         canonicalizer = CanonicalizerPhase.createWithoutReadCanonicalization();
1072                     } else {
1073                         canonicalizer = CanonicalizerPhase.create();
1074                     }
1075                     LoopTransformations.fullUnroll(loop, providers, canonicalizer);
1076                     CanonicalizerPhase.create().applyIncremental(snippetCopy, providers, mark, false);
1077                     loop.deleteUnusedNodes();
1078                 }
1079                 GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
1080                 exploded = true;
1081             }
1082         } while (exploded);
1083     }
1084 
1085     protected Object[] getConstantArgs(Arguments args) {
1086         Object[] constantArgs = args.values.clone();
1087         for (int i = 0; i &lt; args.info.getParameterCount(); i++) {
1088             if (!args.info.isConstantParameter(i)) {
1089                 constantArgs[i] = null;
1090             } else {
1091                 assert constantArgs[i] != null : &quot;Can&#39;t pass raw null through as argument&quot;;
1092             }
1093         }
1094         return constantArgs;
1095     }
1096 
1097     private static boolean checkAllVarargPlaceholdersAreDeleted(int parameterCount, VarargsPlaceholderNode[] placeholders) {
1098         for (int i = 0; i &lt; parameterCount; i++) {
1099             if (placeholders[i] != null) {
1100                 assert placeholders[i].isDeleted() : placeholders[i];
1101             }
1102         }
1103         return true;
1104     }
1105 
1106     private static boolean checkConstantArgument(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int paramIndex, String name, Object arg, JavaKind kind) {
1107         ResolvedJavaType type = signature.getParameterType(paramIndex, method.getDeclaringClass()).resolve(method.getDeclaringClass());
1108         if (metaAccess.lookupJavaType(WordBase.class).isAssignableFrom(type)) {
1109             assert arg instanceof JavaConstant : method + &quot;: word constant parameters must be passed boxed in a Constant value: &quot; + arg;
1110             return true;
1111         }
1112         if (kind != JavaKind.Object) {
1113             assert arg != null &amp;&amp; kind.toBoxedJavaClass() == arg.getClass() : method + &quot;: wrong value kind for &quot; + name + &quot;: expected &quot; + kind + &quot;, got &quot; +
1114                             (arg == null ? &quot;null&quot; : arg.getClass().getSimpleName());
1115         }
1116         return true;
1117     }
1118 
1119     private static boolean checkVarargs(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int i, String name, Varargs varargs) {
1120         ResolvedJavaType type = (ResolvedJavaType) signature.getParameterType(i, method.getDeclaringClass());
1121         assert type.isArray() : &quot;varargs parameter must be an array type&quot;;
1122         assert type.getComponentType().isAssignableFrom(metaAccess.lookupJavaType(varargs.componentType)) : &quot;componentType for &quot; + name + &quot; not matching &quot; + type.toJavaName() + &quot; instance: &quot; +
1123                         varargs.componentType;
1124         return true;
1125     }
1126 
1127     /**
1128      * The graph built from the snippet method.
1129      */
1130     private final StructuredGraph snippet;
1131 
1132     private final SnippetInfo info;
1133 
1134     /**
1135      * The named parameters of this template that must be bound to values during instantiation. For
1136      * a parameter that is still live after specialization, the value in this map is either a
1137      * {@link ParameterNode} instance or a {@link ParameterNode} array. For an eliminated parameter,
1138      * the value is identical to the key.
1139      */
1140     private final Object[] parameters;
1141 
1142     /**
1143      * The return node (if any) of the snippet.
1144      */
1145     private final ReturnNode returnNode;
1146 
1147     /**
1148      * The memory anchor (if any) of the snippet.
1149      */
1150     private final MemoryAnchorNode memoryAnchor;
1151 
1152     /**
1153      * Nodes that inherit the {@link StateSplit#stateAfter()} from the replacee during
1154      * instantiation.
1155      */
1156     private final ArrayList&lt;StateSplit&gt; sideEffectNodes;
1157 
1158     /**
1159      * Nodes that inherit a deoptimization {@link FrameState} from the replacee during
1160      * instantiation.
1161      */
1162     private final ArrayList&lt;DeoptimizingNode&gt; deoptNodes;
1163 
1164     /**
1165      * Nodes that have a stamp originating from a {@link Placeholder}.
1166      */
1167     private final ArrayList&lt;ValueNode&gt; placeholderStampedNodes;
1168 
1169     /**
1170      * The nodes to be inlined when this specialization is instantiated.
1171      */
1172     private final ArrayList&lt;Node&gt; nodes;
1173 
1174     /**
1175      * Gets the instantiation-time bindings to this template&#39;s parameters.
1176      *
1177      * @return the map that will be used to bind arguments to parameters when inlining this template
1178      */
1179     private EconomicMap&lt;Node, Node&gt; bind(StructuredGraph replaceeGraph, MetaAccessProvider metaAccess, Arguments args) {
1180         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
1181         assert args.info.getParameterCount() == parameters.length : &quot;number of args (&quot; + args.info.getParameterCount() + &quot;) != number of parameters (&quot; + parameters.length + &quot;)&quot;;
1182         for (int i = 0; i &lt; parameters.length; i++) {
1183             Object parameter = parameters[i];
1184             assert parameter != null : this + &quot; has no parameter named &quot; + args.info.getParameterName(i);
1185             Object argument = args.values[i];
1186             if (parameter instanceof ParameterNode) {
1187                 if (argument instanceof ValueNode) {
1188                     replacements.put((ParameterNode) parameter, (ValueNode) argument);
1189                 } else {
1190                     JavaKind kind = ((ParameterNode) parameter).getStackKind();
1191                     assert argument != null || kind == JavaKind.Object : this + &quot; cannot accept null for non-object parameter named &quot; + args.info.getParameterName(i);
1192                     JavaConstant constant = forBoxed(argument, kind);
1193                     replacements.put((ParameterNode) parameter, ConstantNode.forConstant(constant, metaAccess, replaceeGraph));
1194                 }
1195             } else if (parameter instanceof ParameterNode[]) {
1196                 ParameterNode[] params = (ParameterNode[]) parameter;
1197                 Varargs varargs = (Varargs) argument;
1198                 int length = params.length;
1199                 List&lt;?&gt; list = null;
1200                 Object array = null;
1201                 if (varargs.value instanceof List) {
1202                     list = (List&lt;?&gt;) varargs.value;
1203                     assert list.size() == length : length + &quot; != &quot; + list.size();
1204                 } else {
1205                     array = varargs.value;
1206                     assert array != null &amp;&amp; array.getClass().isArray();
1207                     assert Array.getLength(array) == length : length + &quot; != &quot; + Array.getLength(array);
1208                 }
1209 
1210                 for (int j = 0; j &lt; length; j++) {
1211                     ParameterNode param = params[j];
1212                     assert param != null;
1213                     Object value = list != null ? list.get(j) : Array.get(array, j);
1214                     if (value instanceof ValueNode) {
1215                         replacements.put(param, (ValueNode) value);
1216                     } else {
1217                         JavaConstant constant = forBoxed(value, param.getStackKind());
1218                         ConstantNode element = ConstantNode.forConstant(constant, metaAccess, replaceeGraph);
1219                         replacements.put(param, element);
1220                     }
1221                 }
1222             } else {
1223                 assert parameter.equals(CONSTANT_PARAMETER) || parameter.equals(UNUSED_PARAMETER) : &quot;unexpected entry for parameter: &quot; + args.info.getParameterName(i) + &quot; -&gt; &quot; + parameter;
1224             }
1225         }
1226         return replacements;
1227     }
1228 
1229     /**
1230      * Converts a Java boxed value to a {@link JavaConstant} of the right kind. This adjusts for the
1231      * limitation that a {@link Local}&#39;s kind is a {@linkplain JavaKind#getStackKind() stack kind}
1232      * and so cannot be used for re-boxing primitives smaller than an int.
1233      *
1234      * @param argument a Java boxed value
1235      * @param localKind the kind of the {@link Local} to which {@code argument} will be bound
1236      */
1237     protected JavaConstant forBoxed(Object argument, JavaKind localKind) {
1238         assert localKind == localKind.getStackKind();
1239         if (localKind == JavaKind.Int) {
1240             return JavaConstant.forBoxedPrimitive(argument);
1241         }
1242         return snippetReflection.forBoxed(localKind, argument);
1243     }
1244 
1245     /**
1246      * Logic for replacing a snippet-lowered node at its usages with the return value of the
1247      * snippet. An alternative to the {@linkplain SnippetTemplate#DEFAULT_REPLACER default}
1248      * replacement logic can be used to handle mismatches between the stamp of the node being
1249      * lowered and the stamp of the snippet&#39;s return value.
1250      */
1251     public interface UsageReplacer {
1252         /**
1253          * Replaces all usages of {@code oldNode} with direct or indirect usages of {@code newNode}.
1254          */
1255         void replace(ValueNode oldNode, ValueNode newNode);
1256     }
1257 
1258     /**
1259      * Represents the default {@link UsageReplacer usage replacer} logic which simply delegates to
1260      * {@link Node#replaceAtUsages(Node)}.
1261      */
1262     public static final UsageReplacer DEFAULT_REPLACER = new UsageReplacer() {
1263 
1264         @Override
1265         public void replace(ValueNode oldNode, ValueNode newNode) {
1266             if (newNode == null) {
1267                 assert oldNode.hasNoUsages();
1268             } else {
1269                 oldNode.replaceAtUsages(newNode);
1270             }
1271         }
1272     };
1273 
1274     private boolean assertSnippetKills(ValueNode replacee) {
1275         if (!replacee.graph().isAfterFloatingReadPhase()) {
1276             // no floating reads yet, ignore locations created while lowering
1277             return true;
1278         }
1279         if (returnNode == null) {
1280             // The snippet terminates control flow
1281             return true;
1282         }
1283         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1284         if (memoryMap == null || memoryMap.isEmpty()) {
1285             // there are no kills in the snippet graph
1286             return true;
1287         }
1288 
1289         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1290         kills.addAll(memoryMap.getLocations());
1291 
<a name="5" id="anc5"></a><span class="line-modified">1292         if (replacee instanceof SingleMemoryKill) {</span>
1293             // check if some node in snippet graph also kills the same location
<a name="6" id="anc6"></a><span class="line-modified">1294             LocationIdentity locationIdentity = ((SingleMemoryKill) replacee).getKilledLocationIdentity();</span>
1295             if (locationIdentity.isAny()) {
1296                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1297                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1298                 return true;
1299             }
1300             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1301             kills.remove(locationIdentity);
1302         }
<a name="7" id="anc7"></a><span class="line-modified">1303         assert !(replacee instanceof MultiMemoryKill) : replacee + &quot; multi not supported (yet)&quot;;</span>
1304 
1305         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1306         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1307             kills.remove(any());
1308         }
1309 
1310         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1311         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1312 
1313         /*
1314          * Kills to private locations are safe, since there can be no floating read to these
1315          * locations except reads that are introduced by the snippet itself or related snippets in
1316          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1317          * their snippet, so they can not float above a kill in another instance of the same
1318          * snippet.
1319          */
1320         for (LocationIdentity p : this.info.privateLocations) {
1321             kills.remove(p);
1322         }
1323 
1324         assert kills.isEmpty() : &quot;snippet graph kills non-private locations &quot; + kills + &quot; that replacee (&quot; + replacee + &quot;) doesn&#39;t kill&quot;;
1325         return true;
1326     }
1327 
1328     private static class MemoryInputMap implements MemoryMap {
1329 
1330         private final LocationIdentity locationIdentity;
1331         private final MemoryNode lastLocationAccess;
1332 
1333         MemoryInputMap(ValueNode replacee) {
1334             if (replacee instanceof MemoryAccess) {
1335                 MemoryAccess access = (MemoryAccess) replacee;
1336                 locationIdentity = access.getLocationIdentity();
1337                 lastLocationAccess = access.getLastLocationAccess();
1338             } else {
1339                 locationIdentity = null;
1340                 lastLocationAccess = null;
1341             }
1342         }
1343 
1344         @Override
1345         public MemoryNode getLastLocationAccess(LocationIdentity location) {
1346             if (locationIdentity != null &amp;&amp; locationIdentity.equals(location)) {
1347                 return lastLocationAccess;
1348             } else {
1349                 return null;
1350             }
1351         }
1352 
1353         @Override
1354         public Collection&lt;LocationIdentity&gt; getLocations() {
1355             if (locationIdentity == null) {
1356                 return Collections.emptySet();
1357             } else {
1358                 return Collections.singleton(locationIdentity);
1359             }
1360         }
1361     }
1362 
1363     private class MemoryOutputMap extends MemoryInputMap {
1364 
1365         private final UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
1366 
1367         MemoryOutputMap(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1368             super(replacee);
1369             this.duplicates = duplicates;
1370         }
1371 
1372         @Override
1373         public MemoryNode getLastLocationAccess(LocationIdentity locationIdentity) {
1374             MemoryMapNode memoryMap = returnNode.getMemoryMap();
1375             assert memoryMap != null : &quot;no memory map stored for this snippet graph (snippet doesn&#39;t have a ReturnNode?)&quot;;
1376             MemoryNode lastLocationAccess = memoryMap.getLastLocationAccess(locationIdentity);
1377             assert lastLocationAccess != null : locationIdentity;
1378             if (lastLocationAccess == memoryAnchor) {
1379                 return super.getLastLocationAccess(locationIdentity);
1380             } else {
1381                 return (MemoryNode) duplicates.get(ValueNodeUtil.asNode(lastLocationAccess));
1382             }
1383         }
1384 
1385         @Override
1386         public Collection&lt;LocationIdentity&gt; getLocations() {
1387             return returnNode.getMemoryMap().getLocations();
1388         }
1389     }
1390 
1391     private void rewireMemoryGraph(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1392         if (replacee.graph().isAfterFloatingReadPhase()) {
1393             // rewire outgoing memory edges
1394             replaceMemoryUsages(replacee, new MemoryOutputMap(replacee, duplicates));
1395 
1396             if (returnNode != null) {
1397                 ReturnNode ret = (ReturnNode) duplicates.get(returnNode);
1398                 if (ret != null) {
1399                     MemoryMapNode memoryMap = ret.getMemoryMap();
1400                     if (memoryMap != null) {
1401                         ret.setMemoryMap(null);
1402                         memoryMap.safeDelete();
1403                     }
1404                 }
1405             }
1406             if (memoryAnchor != null) {
1407                 // rewire incoming memory edges
1408                 MemoryAnchorNode memoryDuplicate = (MemoryAnchorNode) duplicates.get(memoryAnchor);
1409                 replaceMemoryUsages(memoryDuplicate, new MemoryInputMap(replacee));
1410 
1411                 if (memoryDuplicate.hasNoUsages()) {
1412                     if (memoryDuplicate.next() != null) {
1413                         memoryDuplicate.graph().removeFixed(memoryDuplicate);
1414                     } else {
1415                         // this was a dummy memory node used when instantiating pure data-flow
1416                         // snippets: it was not attached to the control flow.
1417                         memoryDuplicate.safeDelete();
1418                     }
1419                 }
1420             }
1421         }
1422     }
1423 
1424     private static LocationIdentity getLocationIdentity(Node node) {
1425         if (node instanceof MemoryAccess) {
1426             return ((MemoryAccess) node).getLocationIdentity();
1427         } else if (node instanceof MemoryProxy) {
1428             return ((MemoryProxy) node).getLocationIdentity();
1429         } else if (node instanceof MemoryPhiNode) {
1430             return ((MemoryPhiNode) node).getLocationIdentity();
1431         } else {
1432             return null;
1433         }
1434     }
1435 
1436     private void replaceMemoryUsages(ValueNode node, MemoryMap map) {
1437         for (Node usage : node.usages().snapshot()) {
1438             if (usage instanceof MemoryMapNode) {
1439                 continue;
1440             }
1441 
1442             LocationIdentity location = getLocationIdentity(usage);
1443             if (location != null) {
1444                 for (Position pos : usage.inputPositions()) {
1445                     if (pos.getInputType() == InputType.Memory &amp;&amp; pos.get(usage) == node) {
1446                         MemoryNode replacement = map.getLastLocationAccess(location);
1447                         if (replacement == null) {
1448                             assert mayRemoveLocation || LocationIdentity.any().equals(location) ||
1449                                             CollectionsUtil.anyMatch(info.privateLocations, Predicate.isEqual(location)) : &quot;Snippet &quot; +
1450                                                             info.method.format(&quot;%h.%n&quot;) + &quot; contains access to the non-private location &quot; +
1451                                                             location + &quot;, but replacee doesn&#39;t access this location.&quot; + map.getLocations();
1452                         } else {
1453                             pos.set(usage, replacement.asNode());
1454                         }
1455                     }
1456                 }
1457             }
1458         }
1459     }
1460 
1461     /**
1462      * Replaces a given fixed node with this specialized snippet.
1463      *
1464      * @param metaAccess
1465      * @param replacee the node that will be replaced
1466      * @param replacer object that replaces the usages of {@code replacee}
1467      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1468      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1469      */
1470     @SuppressWarnings(&quot;try&quot;)
1471     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args) {
1472         return instantiate(metaAccess, replacee, replacer, args, true);
1473     }
1474 
1475     /**
1476      * Replaces a given fixed node with this specialized snippet.
1477      *
1478      * @param metaAccess
1479      * @param replacee the node that will be replaced
1480      * @param replacer object that replaces the usages of {@code replacee}
1481      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1482      * @param killReplacee is true, the replacee node is deleted
1483      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1484      */
1485     @SuppressWarnings(&quot;try&quot;)
1486     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args, boolean killReplacee) {
1487         DebugContext debug = replacee.getDebug();
1488         assert assertSnippetKills(replacee);
1489         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1490             args.info.instantiationCounter.increment(debug);
1491             // Inline the snippet nodes, replacing parameters with the given args in the process
1492             StartNode entryPointNode = snippet.start();
1493             FixedNode firstCFGNode = entryPointNode.next();
1494             StructuredGraph replaceeGraph = replacee.graph();
1495             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1496             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1497             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1498 
1499             // Re-wire the control flow graph around the replacee
1500             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1501             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1502 
1503             rewireFrameStates(replacee, duplicates);
1504 
1505             updateStamps(replacee, duplicates);
1506 
1507             rewireMemoryGraph(replacee, duplicates);
1508 
1509             // Replace all usages of the replacee with the value returned by the snippet
1510             ValueNode returnValue = null;
1511             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1512                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1513                 returnValue = returnDuplicate.result();
<a name="8" id="anc8"></a><span class="line-modified">1514                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryKill) {</span>
1515                     replacer.replace(replacee, null);
1516                 } else {
1517                     assert returnValue != null || replacee.hasNoUsages();
1518                     replacer.replace(replacee, returnValue);
1519                 }
1520                 if (returnDuplicate.isAlive()) {
1521                     FixedNode next = null;
1522                     if (replacee instanceof FixedWithNextNode) {
1523                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1524                         next = fwn.next();
1525                         fwn.setNext(null);
1526                     }
1527                     returnDuplicate.replaceAndDelete(next);
1528                 }
1529             }
1530 
1531             if (killReplacee) {
1532                 // Remove the replacee from its graph
1533                 GraphUtil.killCFG(replacee);
1534             }
1535 
1536             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1537             return duplicates;
1538         }
1539     }
1540 
1541     private UnmodifiableEconomicMap&lt;Node, Node&gt; inlineSnippet(Node replacee, DebugContext debug, StructuredGraph replaceeGraph, EconomicMap&lt;Node, Node&gt; replacements) {
1542         Mark mark = replaceeGraph.getMark();
1543         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {
1544             InliningLog log = replaceeGraph.getInliningLog();
1545             if (oldNode == null) {
1546                 log.trackNewCallsite(newNode);
1547             }
1548         })) {
1549             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacements);
1550             if (scope != null) {
1551                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());
1552             }
1553             NodeSourcePosition position = replacee.getNodeSourcePosition();
1554             InliningUtil.updateSourcePosition(replaceeGraph, duplicates, mark, position, true);
1555             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining snippet %s&quot;, snippet.method());
1556             return duplicates;
1557         }
1558     }
1559 
1560     private void propagateStamp(Node node) {
1561         if (node instanceof PhiNode) {
1562             PhiNode phi = (PhiNode) node;
1563             if (phi.inferStamp()) {
1564                 for (Node usage : node.usages()) {
1565                     propagateStamp(usage);
1566                 }
1567             }
1568         }
1569     }
1570 
1571     private void updateStamps(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1572         for (ValueNode node : placeholderStampedNodes) {
1573             ValueNode dup = (ValueNode) duplicates.get(node);
1574             Stamp replaceeStamp = replacee.stamp(NodeView.DEFAULT);
1575             if (node instanceof Placeholder) {
1576                 Placeholder placeholderDup = (Placeholder) dup;
1577                 placeholderDup.makeReplacement(replaceeStamp);
1578             } else {
1579                 dup.setStamp(replaceeStamp);
1580             }
1581         }
1582         for (ParameterNode paramNode : snippet.getNodes(ParameterNode.TYPE)) {
1583             for (Node usage : paramNode.usages()) {
1584                 Node usageDup = duplicates.get(usage);
1585                 propagateStamp(usageDup);
1586             }
1587         }
1588     }
1589 
1590     /**
1591      * Gets a copy of the specialized graph.
1592      */
1593     public StructuredGraph copySpecializedGraph(DebugContext debugForCopy) {
1594         return (StructuredGraph) snippet.copy(debugForCopy);
1595     }
1596 
1597     /**
1598      * Replaces a given floating node with this specialized snippet.
1599      *
1600      * @param metaAccess
1601      * @param replacee the node that will be replaced
1602      * @param replacer object that replaces the usages of {@code replacee}
1603      * @param tool lowering tool used to insert the snippet into the control-flow
1604      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1605      */
1606     @SuppressWarnings(&quot;try&quot;)
1607     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, LoweringTool tool, Arguments args) {
1608         DebugContext debug = replacee.getDebug();
1609         assert assertSnippetKills(replacee);
1610         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1611             args.info.instantiationCounter.increment(debug);
1612 
1613             // Inline the snippet nodes, replacing parameters with the given args in the process
1614             StartNode entryPointNode = snippet.start();
1615             FixedNode firstCFGNode = entryPointNode.next();
1616             StructuredGraph replaceeGraph = replacee.graph();
1617             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1618             replacements.put(entryPointNode, tool.getCurrentGuardAnchor().asNode());
1619             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1620 
1621             FixedWithNextNode lastFixedNode = tool.lastFixedNode();
1622             assert lastFixedNode != null &amp;&amp; lastFixedNode.isAlive() : replaceeGraph + &quot; lastFixed=&quot; + lastFixedNode;
1623             FixedNode next = lastFixedNode.next();
1624             lastFixedNode.setNext(null);
1625             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1626             replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
1627 
1628             // floating nodes are not state-splits not need to re-wire frame states
1629             assert !(replacee instanceof StateSplit);
1630             updateStamps(replacee, duplicates);
1631 
1632             rewireMemoryGraph(replacee, duplicates);
1633 
1634             // Replace all usages of the replacee with the value returned by the snippet
1635             ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1636             ValueNode returnValue = returnDuplicate.result();
1637             assert returnValue != null || replacee.hasNoUsages();
1638             replacer.replace(replacee, returnValue);
1639 
1640             if (returnDuplicate.isAlive()) {
1641                 returnDuplicate.replaceAndDelete(next);
1642             }
1643 
1644             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1645         }
1646     }
1647 
1648     /**
1649      * Replaces a given floating node with this specialized snippet.
1650      *
1651      * This snippet must be pure data-flow
1652      *
1653      * @param metaAccess
1654      * @param replacee the node that will be replaced
1655      * @param replacer object that replaces the usages of {@code replacee}
1656      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1657      */
1658     @SuppressWarnings(&quot;try&quot;)
1659     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, Arguments args) {
1660         DebugContext debug = replacee.getDebug();
1661         assert assertSnippetKills(replacee);
1662         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1663             args.info.instantiationCounter.increment(debug);
1664 
1665             // Inline the snippet nodes, replacing parameters with the given args in the process
1666             StartNode entryPointNode = snippet.start();
1667             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1668             StructuredGraph replaceeGraph = replacee.graph();
1669             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1670             MemoryAnchorNode anchorDuplicate = null;
1671             if (memoryAnchor != null) {
1672                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode());
1673                 replacements.put(memoryAnchor, anchorDuplicate);
1674             }
1675             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1676             for (Node n : nodes) {
1677                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1678                     floatingNodes.add(n);
1679                 }
1680             }
1681             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1682 
1683             // floating nodes are not state-splits not need to re-wire frame states
1684             assert !(replacee instanceof StateSplit);
1685             updateStamps(replacee, duplicates);
1686 
1687             rewireMemoryGraph(replacee, duplicates);
1688             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1689 
1690             // Replace all usages of the replacee with the value returned by the snippet
1691             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1692             replacer.replace(replacee, returnValue);
1693 
1694             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1695         }
1696     }
1697 
1698     protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1699         if (replacee.graph().getGuardsStage().areFrameStatesAtSideEffects() &amp;&amp; replacee instanceof StateSplit) {
1700             for (StateSplit sideEffectNode : sideEffectNodes) {
1701                 assert ((StateSplit) replacee).hasSideEffect();
1702                 Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
1703                 ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
1704             }
1705         } else if (replacee.graph().getGuardsStage().areFrameStatesAtDeopts() &amp;&amp; replacee instanceof DeoptimizingNode) {
1706             DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;
1707 
1708             FrameState stateBefore = null;
1709             FrameState stateDuring = null;
1710             FrameState stateAfter = null;
1711             if (replaceeDeopt.canDeoptimize()) {
1712                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {
1713                     stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();
1714                 }
1715                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {
1716                     stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();
1717                 }
1718                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {
1719                     stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();
1720                 }
1721             }
1722 
1723             for (DeoptimizingNode deoptNode : deoptNodes) {
1724                 DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());
1725                 if (deoptDup.canDeoptimize()) {
1726                     if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {
1727                         ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);
1728                     }
1729                     if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {
1730                         // compute a state &quot;during&quot; for a DeoptDuring inside the snippet depending
1731                         // on what kind of states we had on the node we are replacing.
1732                         // If the original node had a state &quot;during&quot; already, we just use that,
1733                         // otherwise we need to find a strategy to compute a state during based on
1734                         // some other state (before or after).
1735                         DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;
1736                         if (stateDuring != null) {
1737                             deoptDupDuring.setStateDuring(stateDuring);
1738                         } else if (stateAfter != null) {
1739                             deoptDupDuring.computeStateDuring(stateAfter);
1740                         } else if (stateBefore != null) {
1741                             assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;
1742                             deoptDupDuring.setStateDuring(stateBefore);
1743                         }
1744                     }
1745                     if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {
1746                         DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;
1747                         if (stateAfter != null) {
1748                             deoptDupAfter.setStateAfter(stateAfter);
1749                         } else {
1750                             assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;
1751                             deoptDupAfter.setStateAfter(stateBefore);
1752                         }
1753 
1754                     }
1755                 }
1756             }
1757         }
1758     }
1759 
1760     @Override
1761     public String toString() {
1762         StringBuilder buf = new StringBuilder(snippet.toString()).append(&#39;(&#39;);
1763         String sep = &quot;&quot;;
1764         for (int i = 0; i &lt; parameters.length; i++) {
1765             String name = &quot;[&quot; + i + &quot;]&quot;;
1766             Object value = parameters[i];
1767             buf.append(sep);
1768             sep = &quot;, &quot;;
1769             if (value == null) {
1770                 buf.append(&quot;&lt;null&gt; &quot;).append(name);
1771             } else if (value.equals(UNUSED_PARAMETER)) {
1772                 buf.append(&quot;&lt;unused&gt; &quot;).append(name);
1773             } else if (value.equals(CONSTANT_PARAMETER)) {
1774                 buf.append(&quot;&lt;constant&gt; &quot;).append(name);
1775             } else if (value instanceof ParameterNode) {
1776                 ParameterNode param = (ParameterNode) value;
1777                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1778             } else {
1779                 ParameterNode[] params = (ParameterNode[]) value;
1780                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1781                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1782             }
1783         }
1784         return buf.append(&#39;)&#39;).toString();
1785     }
1786 
1787     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1788         int offset = args.info.hasReceiver() ? 1 : 0;
1789         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1790             if (args.info.isConstantParameter(i)) {
1791                 JavaKind kind = signature.getParameterKind(i - offset);
1792                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1793 
1794             } else if (args.info.isVarargsParameter(i)) {
1795                 assert args.values[i] instanceof Varargs;
1796                 Varargs varargs = (Varargs) args.values[i];
<a name="9" id="anc9"></a><span class="line-modified">1797                 assert checkVarargs(metaAccess, method, signature, i - offset, args.info.getParameterName(i), varargs);</span>
1798             }
1799         }
1800         return true;
1801     }
1802 
1803     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1804         this.mayRemoveLocation = mayRemoveLocation;
1805     }
1806 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
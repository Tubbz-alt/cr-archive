<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotGraphBuilderPlugins.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 28 import static org.graalvm.compiler.hotspot.HotSpotBackend.BASE64_ENCODE_BLOCK;
 29 import static org.graalvm.compiler.hotspot.HotSpotBackend.GHASH_PROCESS_BLOCKS;
 30 import static org.graalvm.compiler.hotspot.meta.HotSpotAOTProfilingPlugin.Options.TieredAOT;
 31 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.JAVA_THREAD_THREAD_OBJECT_LOCATION;
 32 import static org.graalvm.compiler.java.BytecodeParserOptions.InlineDuringParsing;
 33 
 34 import java.lang.invoke.ConstantCallSite;
 35 import java.lang.invoke.MutableCallSite;
 36 import java.lang.invoke.VolatileCallSite;
 37 import java.lang.reflect.Array;
 38 import java.lang.reflect.Type;
 39 import java.math.BigInteger;
 40 import java.util.zip.CRC32;
 41 
 42 import jdk.internal.vm.compiler.collections.Pair;
 43 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
 44 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 45 import org.graalvm.compiler.core.common.type.ObjectStamp;
 46 import org.graalvm.compiler.core.common.type.StampFactory;
 47 import org.graalvm.compiler.core.common.type.TypeReference;
 48 import org.graalvm.compiler.debug.GraalError;
 49 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 50 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 51 import org.graalvm.compiler.hotspot.nodes.CurrentJavaThreadNode;
 52 import org.graalvm.compiler.hotspot.replacements.AESCryptSubstitutions;
 53 import org.graalvm.compiler.hotspot.replacements.ArraysSupportSubstitutions;
 54 import org.graalvm.compiler.hotspot.replacements.BigIntegerSubstitutions;
 55 import org.graalvm.compiler.hotspot.replacements.CRC32CSubstitutions;
 56 import org.graalvm.compiler.hotspot.replacements.CRC32Substitutions;
 57 import org.graalvm.compiler.hotspot.replacements.CallSiteTargetNode;
 58 import org.graalvm.compiler.hotspot.replacements.CipherBlockChainingSubstitutions;
 59 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 60 import org.graalvm.compiler.hotspot.replacements.CounterModeSubstitutions;
 61 import org.graalvm.compiler.hotspot.replacements.DigestBaseSubstitutions;
 62 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 63 import org.graalvm.compiler.hotspot.replacements.HotSpotArraySubstitutions;
 64 import org.graalvm.compiler.hotspot.replacements.HotSpotClassSubstitutions;
 65 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 66 import org.graalvm.compiler.hotspot.replacements.ObjectCloneNode;
 67 import org.graalvm.compiler.hotspot.replacements.ReflectionGetCallerClassNode;
 68 import org.graalvm.compiler.hotspot.replacements.ReflectionSubstitutions;
 69 import org.graalvm.compiler.hotspot.replacements.SHA2Substitutions;
 70 import org.graalvm.compiler.hotspot.replacements.SHA5Substitutions;
 71 import org.graalvm.compiler.hotspot.replacements.SHASubstitutions;
 72 import org.graalvm.compiler.hotspot.replacements.StringUTF16Substitutions;
 73 import org.graalvm.compiler.hotspot.replacements.ThreadSubstitutions;
 74 import org.graalvm.compiler.hotspot.word.HotSpotWordTypes;
 75 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 76 import org.graalvm.compiler.nodes.ConstantNode;
 77 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 78 import org.graalvm.compiler.nodes.NodeView;
 79 import org.graalvm.compiler.nodes.ValueNode;
 80 import org.graalvm.compiler.nodes.calc.AddNode;
 81 import org.graalvm.compiler.nodes.calc.IntegerConvertNode;
 82 import org.graalvm.compiler.nodes.calc.LeftShiftNode;
 83 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 84 import org.graalvm.compiler.nodes.graphbuilderconf.ForeignCallPlugin;
 85 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;
 86 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
 87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
 88 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin.Receiver;
 89 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
 90 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins.Registration;
 91 import org.graalvm.compiler.nodes.graphbuilderconf.NodeIntrinsicPluginFactory;
<a name="2" id="anc2"></a><span class="line-modified"> 92 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>
 93 import org.graalvm.compiler.nodes.memory.ReadNode;
 94 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 95 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 96 import org.graalvm.compiler.nodes.spi.Replacements;
 97 import org.graalvm.compiler.nodes.util.GraphUtil;
 98 import org.graalvm.compiler.options.OptionValues;
 99 import org.graalvm.compiler.phases.tiers.CompilerConfiguration;
100 import org.graalvm.compiler.replacements.InlineDuringParsingPlugin;
101 import org.graalvm.compiler.replacements.MethodHandlePlugin;
102 import org.graalvm.compiler.replacements.NodeIntrinsificationProvider;
103 import org.graalvm.compiler.replacements.ReplacementsImpl;
104 import org.graalvm.compiler.replacements.StandardGraphBuilderPlugins;
105 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
106 import org.graalvm.compiler.serviceprovider.GraalServices;
107 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
108 import org.graalvm.compiler.word.WordOperationPlugin;
109 import org.graalvm.compiler.word.WordTypes;
110 import jdk.internal.vm.compiler.word.LocationIdentity;
111 
112 import jdk.vm.ci.code.CodeUtil;
113 import jdk.vm.ci.code.TargetDescription;
114 import jdk.vm.ci.hotspot.VMIntrinsicMethod;
115 import jdk.vm.ci.meta.ConstantReflectionProvider;
116 import jdk.vm.ci.meta.DeoptimizationAction;
117 import jdk.vm.ci.meta.JavaKind;
118 import jdk.vm.ci.meta.MetaAccessProvider;
119 import jdk.vm.ci.meta.ResolvedJavaMethod;
120 import jdk.vm.ci.services.Services;
121 import sun.misc.Unsafe;
122 
123 /**
124  * Defines the {@link Plugins} used when running on HotSpot.
125  */
126 public class HotSpotGraphBuilderPlugins {
127 
128     /**
129      * Creates a {@link Plugins} object that should be used when running on HotSpot.
130      *
131      * @param constantReflection
132      * @param snippetReflection
133      * @param foreignCalls
134      * @param options
135      * @param target
136      */
137     public static Plugins create(HotSpotGraalRuntimeProvider graalRuntime,
138                     CompilerConfiguration compilerConfiguration,
139                     GraalHotSpotVMConfig config,
140                     HotSpotWordTypes wordTypes,
141                     MetaAccessProvider metaAccess,
142                     ConstantReflectionProvider constantReflection,
143                     SnippetReflectionProvider snippetReflection,
144                     ForeignCallsProvider foreignCalls,
145                     ReplacementsImpl replacements,
<a name="3" id="anc3"></a><span class="line-modified">146                     OptionValues options,</span>
<span class="line-added">147                     TargetDescription target) {</span>
148         InvocationPlugins invocationPlugins = new HotSpotInvocationPlugins(graalRuntime, config, compilerConfiguration);
149 
150         Plugins plugins = new Plugins(invocationPlugins);
151         NodeIntrinsificationProvider nodeIntrinsificationProvider = new NodeIntrinsificationProvider(metaAccess, snippetReflection, foreignCalls, wordTypes, target);
152         HotSpotWordOperationPlugin wordOperationPlugin = new HotSpotWordOperationPlugin(snippetReflection, wordTypes);
153         HotSpotNodePlugin nodePlugin = new HotSpotNodePlugin(wordOperationPlugin, config, wordTypes);
154 
155         plugins.appendTypePlugin(nodePlugin);
156         plugins.appendNodePlugin(nodePlugin);
157         if (!GeneratePIC.getValue(options)) {
158             plugins.appendNodePlugin(new MethodHandlePlugin(constantReflection.getMethodHandleAccess(), true));
159         }
160         plugins.appendInlineInvokePlugin(replacements);
161         if (InlineDuringParsing.getValue(options)) {
162             plugins.appendInlineInvokePlugin(new InlineDuringParsingPlugin());
163         }
164 
165         if (GeneratePIC.getValue(options)) {
166             plugins.setClassInitializationPlugin(new HotSpotAOTClassInitializationPlugin());
167             if (TieredAOT.getValue(options)) {
168                 plugins.setProfilingPlugin(new HotSpotAOTProfilingPlugin());
169             }
170         } else {
171             if (config.instanceKlassInitThreadOffset != -1) {
172                 plugins.setClassInitializationPlugin(new HotSpotJITClassInitializationPlugin());
173             }
174         }
175 
176         invocationPlugins.defer(new Runnable() {
177 
178             @Override
179             public void run() {
180                 registerObjectPlugins(invocationPlugins, options, config, replacements);
181                 registerClassPlugins(plugins, config, replacements);
182                 registerSystemPlugins(invocationPlugins, foreignCalls);
183                 registerThreadPlugins(invocationPlugins, metaAccess, wordTypes, config, replacements);
184                 if (!GeneratePIC.getValue(options)) {
185                     registerCallSitePlugins(invocationPlugins);
186                 }
187                 registerReflectionPlugins(invocationPlugins, replacements);
188                 registerConstantPoolPlugins(invocationPlugins, wordTypes, config, replacements);
189                 registerAESPlugins(invocationPlugins, config, replacements);
190                 registerCRC32Plugins(invocationPlugins, config, replacements);
191                 registerCRC32CPlugins(invocationPlugins, config, replacements);
192                 registerBigIntegerPlugins(invocationPlugins, config, replacements);
193                 registerSHAPlugins(invocationPlugins, config, replacements);
194                 registerGHASHPlugins(invocationPlugins, config, metaAccess, foreignCalls);
195                 registerCounterModePlugins(invocationPlugins, config, replacements);
196                 registerBase64Plugins(invocationPlugins, config, metaAccess, foreignCalls);
197                 registerUnsafePlugins(invocationPlugins, config, replacements);
198                 StandardGraphBuilderPlugins.registerInvocationPlugins(metaAccess, snippetReflection, invocationPlugins, replacements, true, false, true);
199                 registerArrayPlugins(invocationPlugins, replacements);
200                 registerStringPlugins(invocationPlugins, replacements);
201                 registerArraysSupportPlugins(invocationPlugins, config, replacements);
202 
203                 for (NodeIntrinsicPluginFactory factory : GraalServices.load(NodeIntrinsicPluginFactory.class)) {
204                     factory.registerPlugins(invocationPlugins, nodeIntrinsificationProvider);
205                 }
206             }
207         });
208         return plugins;
209     }
210 
211     private static void registerObjectPlugins(InvocationPlugins plugins, OptionValues options, GraalHotSpotVMConfig config, Replacements replacements) {
212         Registration r = new Registration(plugins, Object.class, replacements);
213         if (!GeneratePIC.getValue(options)) {
214             // FIXME: clone() requires speculation and requires a fix in here (to check that
215             // b.getAssumptions() != null), and in ReplacementImpl.getSubstitution() where there is
216             // an instantiation of IntrinsicGraphBuilder using a constructor that sets
217             // AllowAssumptions to YES automatically. The former has to inherit the assumptions
218             // settings from the root compile instead. So, for now, I&#39;m disabling it for
219             // GeneratePIC.
220             r.register1(&quot;clone&quot;, Receiver.class, new InvocationPlugin() {
221                 @Override
222                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
223                     ValueNode object = receiver.get();
224                     b.addPush(JavaKind.Object, new ObjectCloneNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), object));
225                     return true;
226                 }
227 
228                 @Override
229                 public boolean inlineOnly() {
230                     return true;
231                 }
232             });
233         }
234         r.register1(&quot;hashCode&quot;, Receiver.class, new InvocationPlugin() {
235             @Override
236             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
237                 ValueNode object = receiver.get();
238                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));
239                 return true;
240             }
241 
242             @Override
243             public boolean inlineOnly() {
244                 return true;
245             }
246         });
247         if (config.inlineNotify()) {
248             r.register1(&quot;notify&quot;, Receiver.class, new InvocationPlugin() {
249                 @Override
250                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
251                     ValueNode object = receiver.get();
252                     b.add(new FastNotifyNode(object, false, b.bci()));
253                     return true;
254                 }
255 
256                 @Override
257                 public boolean inlineOnly() {
258                     return true;
259                 }
260             });
261         }
262         if (config.inlineNotifyAll()) {
263             r.register1(&quot;notifyAll&quot;, Receiver.class, new InvocationPlugin() {
264                 @Override
265                 public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
266                     ValueNode object = receiver.get();
267                     b.add(new FastNotifyNode(object, true, b.bci()));
268                     return true;
269                 }
270 
271                 @Override
272                 public boolean inlineOnly() {
273                     return true;
274                 }
275             });
276         }
277     }
278 
279     private static void registerClassPlugins(Plugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
280         Registration r = new Registration(plugins.getInvocationPlugins(), Class.class, replacements);
281 
282         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getModifiers&quot;, Receiver.class);
283         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isInterface&quot;, Receiver.class);
284         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isArray&quot;, Receiver.class);
285         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;isPrimitive&quot;, Receiver.class);
286         r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getSuperclass&quot;, Receiver.class);
287 
288         if (config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;, Integer.MAX_VALUE) != Integer.MAX_VALUE) {
289             r.registerMethodSubstitution(HotSpotClassSubstitutions.class, &quot;getComponentType&quot;, Receiver.class);
290         }
291     }
292 
293     private static void registerCallSitePlugins(InvocationPlugins plugins) {
294         InvocationPlugin plugin = new InvocationPlugin() {
295             @Override
296             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
297                 ValueNode callSite = receiver.get();
298                 ValueNode folded = CallSiteTargetNode.tryFold(GraphUtil.originalValue(callSite, true), b.getMetaAccess(), b.getAssumptions());
299                 if (folded != null) {
300                     b.addPush(JavaKind.Object, folded);
301                 } else {
302                     b.addPush(JavaKind.Object, new CallSiteTargetNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions()), callSite));
303                 }
304                 return true;
305             }
306 
307             @Override
308             public boolean inlineOnly() {
309                 return true;
310             }
311         };
312         plugins.register(plugin, ConstantCallSite.class, &quot;getTarget&quot;, Receiver.class);
313         plugins.register(plugin, MutableCallSite.class, &quot;getTarget&quot;, Receiver.class);
314         plugins.register(plugin, VolatileCallSite.class, &quot;getTarget&quot;, Receiver.class);
315     }
316 
317     private static void registerReflectionPlugins(InvocationPlugins plugins, Replacements replacements) {
318         Registration r = new Registration(plugins, reflectionClass, replacements);
319         r.register0(&quot;getCallerClass&quot;, new InvocationPlugin() {
320             @Override
321             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
322                 b.addPush(JavaKind.Object, new ReflectionGetCallerClassNode(b.getInvokeKind(), targetMethod, b.bci(), b.getInvokeReturnStamp(b.getAssumptions())));
323                 return true;
324             }
325 
326             @Override
327             public boolean inlineOnly() {
328                 return true;
329             }
330         });
331         r.registerMethodSubstitution(ReflectionSubstitutions.class, &quot;getClassAccessFlags&quot;, Class.class);
332     }
333 
334     private static void registerUnsafePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
335         Registration r;
336         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
337             r = new Registration(plugins, Unsafe.class, replacements);
338         } else {
339             r = new Registration(plugins, &quot;jdk.internal.misc.Unsafe&quot;, replacements);
340         }
341         String substituteMethodName = config.doingUnsafeAccessOffset != Integer.MAX_VALUE ? &quot;copyMemoryGuarded&quot; : &quot;copyMemory&quot;;
342         r.registerMethodSubstitution(HotSpotUnsafeSubstitutions.class, HotSpotUnsafeSubstitutions.copyMemoryName, substituteMethodName, Receiver.class, Object.class, long.class, Object.class,
343                         long.class, long.class);
344     }
345 
346     private static final LocationIdentity INSTANCE_KLASS_CONSTANTS = NamedLocationIdentity.immutable(&quot;InstanceKlass::_constants&quot;);
347     private static final LocationIdentity CONSTANT_POOL_LENGTH = NamedLocationIdentity.immutable(&quot;ConstantPool::_length&quot;);
348 
349     /**
350      * Emits a node to get the metaspace {@code ConstantPool} pointer given the value of the
351      * {@code constantPoolOop} field in a ConstantPool value.
352      *
353      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
354      * @return a node representing the metaspace {@code ConstantPool} pointer associated with
355      *         {@code constantPoolOop}
356      */
357     private static ValueNode getMetaspaceConstantPool(GraphBuilderContext b, ValueNode constantPoolOop, WordTypes wordTypes, GraalHotSpotVMConfig config) {
358         // ConstantPool.constantPoolOop is in fact the holder class.
359         ValueNode value = b.nullCheckedValue(constantPoolOop, DeoptimizationAction.None);
360         ValueNode klass = b.add(ClassGetHubNode.create(value, b.getMetaAccess(), b.getConstantReflection(), false));
361 
362         boolean notCompressible = false;
363         AddressNode constantsAddress = b.add(new OffsetAddressNode(klass, b.add(ConstantNode.forLong(config.instanceKlassConstantsOffset))));
364         return WordOperationPlugin.readOp(b, wordTypes.getWordKind(), constantsAddress, INSTANCE_KLASS_CONSTANTS, BarrierType.NONE, notCompressible);
365     }
366 
367     /**
368      * Emits a node representing an element in a metaspace {@code ConstantPool}.
369      *
370      * @param constantPoolOop value of the {@code constantPoolOop} field in a ConstantPool value
371      */
372     private static boolean readMetaspaceConstantPoolElement(GraphBuilderContext b, ValueNode constantPoolOop, ValueNode index, JavaKind elementKind, WordTypes wordTypes, GraalHotSpotVMConfig config) {
373         ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
374         int shift = CodeUtil.log2(wordTypes.getWordKind().getByteCount());
375         ValueNode scaledIndex = b.add(new LeftShiftNode(IntegerConvertNode.convert(index, StampFactory.forKind(JavaKind.Long), NodeView.DEFAULT), b.add(ConstantNode.forInt(shift))));
376         ValueNode offset = b.add(new AddNode(scaledIndex, b.add(ConstantNode.forLong(config.constantPoolSize))));
377         AddressNode elementAddress = b.add(new OffsetAddressNode(constants, offset));
378         boolean notCompressible = false;
379         ValueNode elementValue = WordOperationPlugin.readOp(b, elementKind, elementAddress, NamedLocationIdentity.getArrayLocation(elementKind), BarrierType.NONE, notCompressible);
380         b.addPush(elementKind, elementValue);
381         return true;
382     }
383 
384     private static void registerConstantPoolPlugins(InvocationPlugins plugins, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
385         Registration r = new Registration(plugins, constantPoolClass, replacements);
386 
387         r.register2(&quot;getSize0&quot;, Receiver.class, Object.class, new InvocationPlugin() {
388             @Override
389             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop) {
390                 boolean notCompressible = false;
391                 ValueNode constants = getMetaspaceConstantPool(b, constantPoolOop, wordTypes, config);
392                 AddressNode lengthAddress = b.add(new OffsetAddressNode(constants, b.add(ConstantNode.forLong(config.constantPoolLengthOffset))));
393                 ValueNode length = WordOperationPlugin.readOp(b, JavaKind.Int, lengthAddress, CONSTANT_POOL_LENGTH, BarrierType.NONE, notCompressible);
394                 b.addPush(JavaKind.Int, length);
395                 return true;
396             }
397         });
398 
399         r.register3(&quot;getIntAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
400             @Override
401             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
402                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Int, wordTypes, config);
403             }
404         });
405         r.register3(&quot;getLongAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
406             @Override
407             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
408                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Long, wordTypes, config);
409             }
410         });
411         r.register3(&quot;getFloatAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
412             @Override
413             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
414                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Float, wordTypes, config);
415             }
416         });
417         r.register3(&quot;getDoubleAt0&quot;, Receiver.class, Object.class, int.class, new InvocationPlugin() {
418             @Override
419             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode constantPoolOop, ValueNode index) {
420                 return readMetaspaceConstantPoolElement(b, constantPoolOop, index, JavaKind.Double, wordTypes, config);
421             }
422         });
423     }
424 
425     private static void registerSystemPlugins(InvocationPlugins plugins, ForeignCallsProvider foreignCalls) {
426         Registration r = new Registration(plugins, System.class);
427         r.register0(&quot;currentTimeMillis&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_MILLIS));
428         r.register0(&quot;nanoTime&quot;, new ForeignCallPlugin(foreignCalls, HotSpotHostForeignCallsProvider.JAVA_TIME_NANOS));
429         r.register1(&quot;identityHashCode&quot;, Object.class, new InvocationPlugin() {
430             @Override
431             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode object) {
432                 b.addPush(JavaKind.Int, new IdentityHashCodeNode(object));
433                 return true;
434             }
435 
436             @Override
437             public boolean inlineOnly() {
438                 return true;
439             }
440         });
441         r.register5(&quot;arraycopy&quot;, Object.class, int.class, Object.class, int.class, int.class, new InvocationPlugin() {
442             @Override
443             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver, ValueNode src, ValueNode srcPos, ValueNode dst, ValueNode dstPos, ValueNode length) {
444                 b.add(new ArrayCopyNode(b.bci(), src, srcPos, dst, dstPos, length));
445                 return true;
446             }
447 
448             @Override
449             public boolean inlineOnly() {
450                 return true;
451             }
452         });
453     }
454 
455     private static void registerArrayPlugins(InvocationPlugins plugins, Replacements replacements) {
456         Registration r = new Registration(plugins, Array.class, replacements);
457         r.setAllowOverwrite(true);
458         r.registerMethodSubstitution(HotSpotArraySubstitutions.class, &quot;newInstance&quot;, Class.class, int.class);
459     }
460 
461     private static void registerStringPlugins(InvocationPlugins plugins, Replacements replacements) {
462         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
463             final Registration utf16r = new Registration(plugins, &quot;java.lang.StringUTF16&quot;, replacements);
464             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;toBytes&quot;, char[].class, int.class, int.class);
465             utf16r.registerMethodSubstitution(StringUTF16Substitutions.class, &quot;getChars&quot;, byte[].class, int.class, int.class, char[].class, int.class);
466         }
467     }
468 
469     private static void registerThreadPlugins(InvocationPlugins plugins, MetaAccessProvider metaAccess, WordTypes wordTypes, GraalHotSpotVMConfig config, Replacements replacements) {
470         Registration r = new Registration(plugins, Thread.class, replacements);
471         r.register0(&quot;currentThread&quot;, new InvocationPlugin() {
472             @Override
473             public boolean apply(GraphBuilderContext b, ResolvedJavaMethod targetMethod, Receiver receiver) {
474                 CurrentJavaThreadNode thread = b.add(new CurrentJavaThreadNode(wordTypes.getWordKind()));
475                 ValueNode offset = b.add(ConstantNode.forLong(config.threadObjectOffset));
476                 AddressNode address = b.add(new OffsetAddressNode(thread, offset));
477                 // JavaThread::_threadObj is never compressed
478                 ObjectStamp stamp = StampFactory.objectNonNull(TypeReference.create(b.getAssumptions(), metaAccess.lookupJavaType(Thread.class)));
479                 b.addPush(JavaKind.Object, new ReadNode(address, JAVA_THREAD_THREAD_OBJECT_LOCATION, stamp, BarrierType.NONE));
480                 return true;
481             }
482         });
483 
484         if (config.osThreadInterruptedOffset != Integer.MAX_VALUE) {
485             r.registerMethodSubstitution(ThreadSubstitutions.class, &quot;isInterrupted&quot;, Receiver.class, boolean.class);
486         }
487 
488     }
489 
490     public static final String reflectionClass;
491     public static final String constantPoolClass;
492 
493     static {
494         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
495             reflectionClass = &quot;sun.reflect.Reflection&quot;;
496             constantPoolClass = &quot;sun.reflect.ConstantPool&quot;;
497         } else {
498             reflectionClass = &quot;jdk.internal.reflect.Reflection&quot;;
499             constantPoolClass = &quot;jdk.internal.reflect.ConstantPool&quot;;
500         }
501     }
502 
503     public static String lookupIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
504         return selectIntrinsicName(config, className, name1, name2).getLeft();
505     }
506 
507     /**
508      * Returns a pair of Strings where the left one represents the matched intrinsic name and the
509      * right one represents the mismatched intrinsic name.
510      */
511     public static Pair&lt;String, String&gt; selectIntrinsicName(GraalHotSpotVMConfig config, String className, String name1, String name2) {
512         boolean foundName1 = false;
513         boolean foundName2 = false;
514         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
515             if (className.equals(intrinsic.declaringClass)) {
516                 if (name1.equals(intrinsic.name)) {
517                     foundName1 = true;
518                 } else if (name2.equals(intrinsic.name)) {
519                     foundName2 = true;
520                 }
521             }
522         }
523         if (foundName1 &amp;&amp; !foundName2) {
524             return Pair.create(name1, name2);
525         } else if (foundName2 &amp;&amp; !foundName1) {
526             return Pair.create(name2, name1);
527         }
528         throw GraalError.shouldNotReachHere();
529     }
530 
531     public static boolean isIntrinsicName(GraalHotSpotVMConfig config, String className, String name) {
532         for (VMIntrinsicMethod intrinsic : config.getStore().getIntrinsics()) {
533             if (className.equals(intrinsic.declaringClass)) {
534                 if (name.equals(intrinsic.name)) {
535                     return true;
536                 }
537             }
538         }
539         return false;
540     }
541 
542     private static void registerAESPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
543         if (config.useAESIntrinsics) {
544             assert config.aescryptEncryptBlockStub != 0L;
545             assert config.aescryptDecryptBlockStub != 0L;
546             assert config.cipherBlockChainingEncryptAESCryptStub != 0L;
547             assert config.cipherBlockChainingDecryptAESCryptStub != 0L;
548             String arch = config.osArch;
549             String decryptSuffix = arch.equals(&quot;sparc&quot;) ? &quot;WithOriginalKey&quot; : &quot;&quot;;
550 
551             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CipherBlockChaining&quot;, replacements);
552 
553             Pair&lt;String, String&gt; cbcEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implEncrypt&quot;, &quot;encrypt&quot;);
554             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcEncryptName, Receiver.class, byte[].class, int.class, int.class,
555                             byte[].class, int.class);
556 
557             Pair&lt;String, String&gt; cbcDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/CipherBlockChaining&quot;, &quot;implDecrypt&quot;, &quot;decrypt&quot;);
558             registerAndCheckMismatch(r, CipherBlockChainingSubstitutions.class, cbcDecryptName, cbcDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, int.class,
559                             byte[].class, int.class);
560 
561             r = new Registration(plugins, &quot;com.sun.crypto.provider.AESCrypt&quot;, replacements);
562 
563             Pair&lt;String, String&gt; aesEncryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implEncryptBlock&quot;, &quot;encryptBlock&quot;);
564             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesEncryptName, Receiver.class, byte[].class, int.class, byte[].class, int.class);
565 
566             Pair&lt;String, String&gt; aesDecryptName = selectIntrinsicName(config, &quot;com/sun/crypto/provider/AESCrypt&quot;, &quot;implDecryptBlock&quot;, &quot;decryptBlock&quot;);
567             registerAndCheckMismatch(r, AESCryptSubstitutions.class, aesDecryptName, aesDecryptName.getLeft() + decryptSuffix, Receiver.class, byte[].class, int.class, byte[].class, int.class);
568         }
569     }
570 
571     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, Type... argumentTypes) {
572         try {
573             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), argumentTypes);
574         } catch (NoSuchMethodError e) {
575             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
576                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
577         }
578     }
579 
580     private static void registerAndCheckMismatch(Registration r, Class&lt;?&gt; substitutionClass, Pair&lt;String, String&gt; intrinsicNames, String substituteName, Type... argumentTypes) {
581         try {
582             r.registerMethodSubstitution(substitutionClass, intrinsicNames.getLeft(), substituteName, argumentTypes);
583         } catch (NoSuchMethodError e) {
584             throw new GraalError(e, &quot;Found method named &#39;%s&#39; instead of &#39;%s&#39; in class &#39;%s&#39;. This is most likely because the JVMCI JDK in %s was built on an incompatible base JDK.&quot;,
585                             intrinsicNames.getRight(), intrinsicNames.getLeft(), r.getDeclaringType().getTypeName(), Services.getSavedProperties().get(&quot;java.home&quot;));
586         }
587     }
588 
589     private static void registerBigIntegerPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
590         Registration r = new Registration(plugins, BigInteger.class, replacements);
591         assert !config.useMultiplyToLenIntrinsic() || config.multiplyToLen != 0L;
592         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
593             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;multiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
594                             int.class, int[].class);
595         } else {
596             r.registerConditionalMethodSubstitution(config.useMultiplyToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implMultiplyToLen&quot;, &quot;multiplyToLenStatic&quot;, int[].class, int.class, int[].class,
597                             int.class, int[].class);
598         }
599         r.registerConditionalMethodSubstitution(config.useMulAddIntrinsic(), BigIntegerSubstitutions.class, &quot;implMulAdd&quot;, int[].class, int[].class, int.class, int.class, int.class);
600         r.registerConditionalMethodSubstitution(config.useMontgomeryMultiplyIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomeryMultiply&quot;, int[].class, int[].class, int[].class, int.class,
601                         long.class, int[].class);
602         r.registerConditionalMethodSubstitution(config.useMontgomerySquareIntrinsic(), BigIntegerSubstitutions.class, &quot;implMontgomerySquare&quot;, int[].class, int[].class, int.class, long.class,
603                         int[].class);
604         r.registerConditionalMethodSubstitution(config.useSquareToLenIntrinsic(), BigIntegerSubstitutions.class, &quot;implSquareToLen&quot;, int[].class, int.class, int[].class, int.class);
605     }
606 
607     private static void registerSHAPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
608         boolean useSha1 = config.useSHA1Intrinsics();
609         boolean useSha256 = config.useSHA256Intrinsics();
610         boolean useSha512 = config.useSHA512Intrinsics();
611 
612         if (isIntrinsicName(config, &quot;sun/security/provider/DigestBase&quot;, &quot;implCompressMultiBlock0&quot;) &amp;&amp; (useSha1 || useSha256 || useSha512)) {
613             Registration r = new Registration(plugins, &quot;sun.security.provider.DigestBase&quot;, replacements);
614             r.registerMethodSubstitution(DigestBaseSubstitutions.class, &quot;implCompressMultiBlock0&quot;, Receiver.class, byte[].class, int.class, int.class);
615         }
616 
617         Pair&lt;String, String&gt; implCompressName = selectIntrinsicName(config, &quot;sun/security/provider/SHA&quot;, &quot;implCompress&quot;, &quot;implCompress0&quot;);
618         if (useSha1) {
619             assert config.sha1ImplCompress != 0L;
620             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA&quot;, replacements);
621             registerAndCheckMismatch(r, SHASubstitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
622         }
623         if (useSha256) {
624             assert config.sha256ImplCompress != 0L;
625             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA2&quot;, replacements);
626             registerAndCheckMismatch(r, SHA2Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
627         }
628         if (useSha512) {
629             assert config.sha512ImplCompress != 0L;
630             Registration r = new Registration(plugins, &quot;sun.security.provider.SHA5&quot;, replacements);
631             registerAndCheckMismatch(r, SHA5Substitutions.class, implCompressName, &quot;implCompress0&quot;, Receiver.class, byte[].class, int.class);
632         }
633     }
634 
635     private static void registerGHASHPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
636         if (config.useGHASHIntrinsics()) {
637             assert config.ghashProcessBlocks != 0L;
638             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.GHASH&quot;);
639             r.register5(&quot;processBlocks&quot;,
640                             byte[].class,
641                             int.class,
642                             int.class,
643                             long[].class,
644                             long[].class,
645                             new InvocationPlugin() {
646                                 @Override
647                                 public boolean apply(GraphBuilderContext b,
648                                                 ResolvedJavaMethod targetMethod,
649                                                 Receiver receiver,
650                                                 ValueNode data,
651                                                 ValueNode inOffset,
652                                                 ValueNode blocks,
653                                                 ValueNode state,
654                                                 ValueNode hashSubkey) {
655                                     int longArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Long);
656                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
657                                     ValueNode dataOffset = AddNode.create(ConstantNode.forInt(byteArrayBaseOffset), inOffset, NodeView.DEFAULT);
658                                     ComputeObjectAddressNode dataAddress = b.add(new ComputeObjectAddressNode(data, dataOffset));
659                                     ComputeObjectAddressNode stateAddress = b.add(new ComputeObjectAddressNode(state, ConstantNode.forInt(longArrayBaseOffset)));
660                                     ComputeObjectAddressNode hashSubkeyAddress = b.add(new ComputeObjectAddressNode(hashSubkey, ConstantNode.forInt(longArrayBaseOffset)));
661                                     b.add(new ForeignCallNode(foreignCalls, GHASH_PROCESS_BLOCKS, stateAddress, hashSubkeyAddress, dataAddress, blocks));
662                                     return true;
663                                 }
664                             });
665         }
666     }
667 
668     private static void registerCounterModePlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
<a name="4" id="anc4"></a><span class="line-modified">669         if (isIntrinsicName(config, &quot;com/sun/crypto/provider/CounterMode&quot;, &quot;implCrypt&quot;)) {</span>
670             assert !config.useAESCTRIntrinsics || config.counterModeAESCrypt != 0L;
671             Registration r = new Registration(plugins, &quot;com.sun.crypto.provider.CounterMode&quot;, replacements);
672             r.registerConditionalMethodSubstitution(config.useAESCTRIntrinsics, CounterModeSubstitutions.class, &quot;implCrypt&quot;, Receiver.class, byte[].class, int.class, int.class, byte[].class,
673                             int.class);
674         }
675     }
676 
677     private static void registerBase64Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls) {
678         if (config.useBase64Intrinsics()) {
679             Registration r = new Registration(plugins, &quot;java.util.Base64$Encoder&quot;);
680             r.register7(&quot;encodeBlock&quot;,
681                             Receiver.class,
682                             byte[].class,
683                             int.class,
684                             int.class,
685                             byte[].class,
686                             int.class,
687                             boolean.class,
688                             new InvocationPlugin() {
689                                 @Override
690                                 public boolean apply(GraphBuilderContext b,
691                                                 ResolvedJavaMethod targetMethod,
692                                                 Receiver receiver,
693                                                 ValueNode src,
694                                                 ValueNode sp,
695                                                 ValueNode sl,
696                                                 ValueNode dst,
697                                                 ValueNode dp,
698                                                 ValueNode isURL) {
699                                     int byteArrayBaseOffset = metaAccess.getArrayBaseOffset(JavaKind.Byte);
700                                     ComputeObjectAddressNode srcAddress = b.add(new ComputeObjectAddressNode(src, ConstantNode.forInt(byteArrayBaseOffset)));
701                                     ComputeObjectAddressNode dstAddress = b.add(new ComputeObjectAddressNode(dst, ConstantNode.forInt(byteArrayBaseOffset)));
702                                     b.add(new ForeignCallNode(foreignCalls, BASE64_ENCODE_BLOCK, srcAddress, sp, sl, dstAddress, dp, isURL));
703                                     return true;
704                                 }
705                             });
706         }
707     }
708 
709     private static void registerCRC32Plugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
710         Registration r = new Registration(plugins, CRC32.class, replacements);
711         r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;update&quot;, int.class, int.class);
712         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
713             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
714             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer&quot;, int.class, long.class, int.class, int.class);
715         } else {
716             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateBytes0&quot;, int.class, byte[].class, int.class, int.class);
717             r.registerConditionalMethodSubstitution(config.useCRC32Intrinsics, CRC32Substitutions.class, &quot;updateByteBuffer0&quot;, int.class, long.class, int.class, int.class);
718         }
719     }
720 
721     private static void registerCRC32CPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
722         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
723             Registration r = new Registration(plugins, &quot;java.util.zip.CRC32C&quot;, replacements);
724             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateBytes&quot;, int.class, byte[].class, int.class, int.class);
725             r.registerConditionalMethodSubstitution(config.useCRC32CIntrinsics, CRC32CSubstitutions.class, &quot;updateDirectByteBuffer&quot;, int.class, long.class, int.class, int.class);
726         }
727     }
728 
729     private static void registerArraysSupportPlugins(InvocationPlugins plugins, GraalHotSpotVMConfig config, Replacements replacements) {
730         if (JavaVersionUtil.JAVA_SPEC &gt; 8) {
731             Registration r = new Registration(plugins, &quot;jdk.internal.util.ArraysSupport&quot;, replacements);
732             r.registerConditionalMethodSubstitution(config.useVectorizedMismatchIntrinsic, ArraysSupportSubstitutions.class, &quot;vectorizedMismatch&quot;, Object.class, long.class, Object.class, long.class,
733                             int.class, int.class);
734         }
735     }
736 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
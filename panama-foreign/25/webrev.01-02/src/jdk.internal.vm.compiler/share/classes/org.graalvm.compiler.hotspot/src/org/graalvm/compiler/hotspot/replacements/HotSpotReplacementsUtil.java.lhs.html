<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_METAACCESS;
 28 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.VERIFY_OOP;
 30 
 31 import java.lang.ref.Reference;
 32 
 33 import org.graalvm.compiler.api.replacements.Fold;
 34 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 35 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.TypeReference;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 41 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 42 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.word.KlassPointer;
 45 import org.graalvm.compiler.nodes.CanonicalizableLocation;
 46 import org.graalvm.compiler.nodes.CompressionNode;
 47 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 53 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 54 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 55 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 56 import org.graalvm.compiler.nodes.extended.StoreHubNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
<a name="2" id="anc2"></a><span class="line-modified"> 58 import org.graalvm.compiler.nodes.memory.Access;</span>
 59 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 60 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 61 import org.graalvm.compiler.nodes.type.StampTool;
 62 import org.graalvm.compiler.replacements.ReplacementsUtil;
 63 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 64 import org.graalvm.compiler.replacements.nodes.WriteRegisterNode;
 65 import org.graalvm.compiler.word.Word;
 66 import jdk.internal.vm.compiler.word.LocationIdentity;
 67 import jdk.internal.vm.compiler.word.WordFactory;
 68 
 69 import jdk.vm.ci.code.Register;
 70 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 71 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 72 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 73 import jdk.vm.ci.meta.Assumptions;
 74 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 75 import jdk.vm.ci.meta.JavaKind;
 76 import jdk.vm.ci.meta.MetaAccessProvider;
 77 import jdk.vm.ci.meta.ResolvedJavaField;
 78 import jdk.vm.ci.meta.ResolvedJavaType;
 79 import jdk.vm.ci.meta.UnresolvedJavaType;
 80 
 81 //JaCoCo Exclude
 82 
 83 /**
 84  * A collection of methods used in HotSpot snippets, substitutions and stubs.
 85  */
 86 public class HotSpotReplacementsUtil {
 87 
 88     abstract static class HotSpotOptimizingLocationIdentity extends NamedLocationIdentity implements CanonicalizableLocation {
 89 
 90         HotSpotOptimizingLocationIdentity(String name) {
 91             super(name, true);
 92         }
 93 
 94         @Override
 95         public abstract ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool);
 96 
 97         protected ValueNode findReadHub(ValueNode object) {
 98             ValueNode base = object;
 99             if (base instanceof CompressionNode) {
100                 base = ((CompressionNode) base).getValue();
101             }
<a name="3" id="anc3"></a><span class="line-modified">102             if (base instanceof Access) {</span>
<span class="line-modified">103                 Access access = (Access) base;</span>
104                 if (access.getLocationIdentity().equals(HUB_LOCATION) || access.getLocationIdentity().equals(COMPRESSED_HUB_LOCATION)) {
105                     AddressNode address = access.getAddress();
106                     if (address instanceof OffsetAddressNode) {
107                         OffsetAddressNode offset = (OffsetAddressNode) address;
108                         return offset.getBase();
109                     }
110                 }
111             } else if (base instanceof LoadHubNode) {
112                 LoadHubNode loadhub = (LoadHubNode) base;
113                 return loadhub.getValue();
114             }
115             return null;
116         }
117 
118         /**
119          * Fold reads that convert from Class -&gt; Hub -&gt; Class or vice versa.
120          *
121          * @param read
122          * @param object
123          * @param otherLocation
124          * @return an earlier read or the original {@code read}
125          */
126         protected static ValueNode foldIndirection(ValueNode read, ValueNode object, LocationIdentity otherLocation) {
<a name="4" id="anc4"></a><span class="line-modified">127             if (object instanceof Access) {</span>
<span class="line-modified">128                 Access access = (Access) object;</span>
129                 if (access.getLocationIdentity().equals(otherLocation)) {
130                     AddressNode address = access.getAddress();
131                     if (address instanceof OffsetAddressNode) {
132                         OffsetAddressNode offset = (OffsetAddressNode) address;
133                         assert offset.getBase().stamp(NodeView.DEFAULT).isCompatible(read.stamp(NodeView.DEFAULT));
134                         return offset.getBase();
135                     }
136                 }
137             }
138             return read;
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {
159         for (ResolvedJavaField field : type.getInstanceFields(true)) {
160             if (field.getName().equals(fieldName)) {
161                 return field.getOffset();
162             }
163         }
164         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
165     }
166 
167     public static HotSpotJVMCIRuntime runtime() {
168         return HotSpotJVMCIRuntime.runtime();
169     }
170 
171     @Fold
172     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
173         return injectedVMConfig.heapWordSize;
174     }
175 
176     @Fold
177     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
178         return config.klassLayoutHelperNeutralValue;
179     }
180 
181     @Fold
182     public static boolean useTLAB(@InjectedParameter GraalHotSpotVMConfig config) {
183         return config.useTLAB;
184     }
185 
<a name="5" id="anc5"></a>




186     @Fold
187     public static boolean verifyOops(@InjectedParameter GraalHotSpotVMConfig config) {
188         return config.verifyOops;
189     }
190 
191     /**
192      * @see GraalHotSpotVMConfig#doingUnsafeAccessOffset
193      */
194     @Fold
195     public static int doingUnsafeAccessOffset(@InjectedParameter GraalHotSpotVMConfig config) {
196         return config.doingUnsafeAccessOffset;
197     }
198 
199     public static final LocationIdentity EXCEPTION_OOP_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionOop&quot;);
200 
201     /**
202      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
203      */
204     @Fold
205     public static int threadExceptionOopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
206         return config.threadExceptionOopOffset;
207     }
208 
209     public static final LocationIdentity EXCEPTION_PC_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionPc&quot;);
210 
211     @Fold
212     public static int threadExceptionPcOffset(@InjectedParameter GraalHotSpotVMConfig config) {
213         return config.threadExceptionPcOffset;
214     }
215 
216     public static final LocationIdentity TLAB_TOP_LOCATION = NamedLocationIdentity.mutable(&quot;TlabTop&quot;);
217 
218     @Fold
219     public static int threadTlabTopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
220         return config.threadTlabTopOffset();
221     }
222 
223     public static final LocationIdentity TLAB_END_LOCATION = NamedLocationIdentity.mutable(&quot;TlabEnd&quot;);
224 
225     @Fold
226     static int threadTlabEndOffset(@InjectedParameter GraalHotSpotVMConfig config) {
227         return config.threadTlabEndOffset();
228     }
229 
230     public static final LocationIdentity PENDING_EXCEPTION_LOCATION = NamedLocationIdentity.mutable(&quot;PendingException&quot;);
231 
232     /**
233      * @see GraalHotSpotVMConfig#pendingExceptionOffset
234      */
235     @Fold
236     static int threadPendingExceptionOffset(@InjectedParameter GraalHotSpotVMConfig config) {
237         return config.pendingExceptionOffset;
238     }
239 
240     /**
241      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
242      */
243     public static Object readExceptionOop(Word thread) {
244         return thread.readObject(threadExceptionOopOffset(INJECTED_VMCONFIG), EXCEPTION_OOP_LOCATION);
245     }
246 
247     public static Word readExceptionPc(Word thread) {
248         return thread.readWord(threadExceptionPcOffset(INJECTED_VMCONFIG), EXCEPTION_PC_LOCATION);
249     }
250 
251     /**
252      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
253      */
254     public static void writeExceptionOop(Word thread, Object value) {
255         thread.writeObject(threadExceptionOopOffset(INJECTED_VMCONFIG), value, EXCEPTION_OOP_LOCATION);
256     }
257 
258     public static void writeExceptionPc(Word thread, Word value) {
259         thread.writeWord(threadExceptionPcOffset(INJECTED_VMCONFIG), value, EXCEPTION_PC_LOCATION);
260     }
261 
262     public static Word readTlabTop(Word thread) {
263         return thread.readWord(threadTlabTopOffset(INJECTED_VMCONFIG), TLAB_TOP_LOCATION);
264     }
265 
266     public static Word readTlabEnd(Word thread) {
267         return thread.readWord(threadTlabEndOffset(INJECTED_VMCONFIG), TLAB_END_LOCATION);
268     }
269 
270     public static void writeTlabTop(Word thread, Word top) {
271         thread.writeWord(threadTlabTopOffset(INJECTED_VMCONFIG), top, TLAB_TOP_LOCATION);
272     }
273 
274     /**
275      * Clears the pending exception for the given thread.
276      *
277      * @return the pending exception, or null if there was none
278      */
279     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
280     public static Object clearPendingException(Word thread) {
281         Object result = thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
282         thread.writeObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), null, PENDING_EXCEPTION_LOCATION);
283         return result;
284     }
285 
286     /**
287      * Gets the pending exception for the given thread.
288      *
289      * @return the pending exception, or null if there was none
290      */
291     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
292     public static Object getPendingException(Word thread) {
293         return thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
294     }
295 
296     /*
297      * As far as Java code is concerned this can be considered immutable: it is set just after the
298      * JavaThread is created, before it is published. After that, it is never changed.
299      */
300     public static final LocationIdentity JAVA_THREAD_THREAD_OBJECT_LOCATION = NamedLocationIdentity.immutable(&quot;JavaThread::_threadObj&quot;);
301 
302     @Fold
303     public static int threadObjectOffset(@InjectedParameter GraalHotSpotVMConfig config) {
304         return config.threadObjectOffset;
305     }
306 
307     public static final LocationIdentity JAVA_THREAD_OSTHREAD_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_osthread&quot;);
308 
309     @Fold
310     public static int osThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
311         assert config.osThreadOffset != Integer.MAX_VALUE;
312         return config.osThreadOffset;
313     }
314 
315     @Fold
316     public static int osThreadInterruptedOffset(@InjectedParameter GraalHotSpotVMConfig config) {
317         assert config.osThreadInterruptedOffset != Integer.MAX_VALUE;
318         return config.osThreadInterruptedOffset;
319     }
320 
321     @Fold
322     public static JavaKind getWordKind() {
323         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
324     }
325 
326     @Fold
327     public static int wordSize() {
328         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
329     }
330 
331     @Fold
332     public static int pageSize(@InjectedParameter GraalHotSpotVMConfig config) {
333         return config.vmPageSize;
334     }
335 
336     public static final LocationIdentity PROTOTYPE_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;PrototypeMarkWord&quot;);
337 
338     @Fold
339     public static int prototypeMarkWordOffset(@InjectedParameter GraalHotSpotVMConfig config) {
340         return config.prototypeMarkWordOffset;
341     }
342 
343     public static final LocationIdentity KLASS_ACCESS_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_access_flags&quot;);
344 
345     @Fold
346     public static int klassAccessFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
347         return config.klassAccessFlagsOffset;
348     }
349 
350     @Fold
351     public static int jvmAccWrittenFlags(@InjectedParameter GraalHotSpotVMConfig config) {
352         return config.jvmAccWrittenFlags;
353     }
354 
355     public static final LocationIdentity KLASS_LAYOUT_HELPER_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Klass::_layout_helper&quot;) {
356         @Override
357         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
358             ValueNode javaObject = findReadHub(object);
359             if (javaObject != null) {
360                 if (javaObject.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
361                     ObjectStamp stamp = (ObjectStamp) javaObject.stamp(NodeView.DEFAULT);
362                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) stamp.javaType(tool.getMetaAccess());
363                     if (type.isArray() &amp;&amp; !type.getComponentType().isPrimitive()) {
364                         int layout = type.layoutHelper();
365                         return ConstantNode.forInt(layout);
366                     }
367                 }
368             }
369             return read;
370         }
371     };
372 
373     @Fold
374     public static int allocatePrefetchStyle(@InjectedParameter GraalHotSpotVMConfig config) {
375         return config.allocatePrefetchStyle;
376     }
377 
378     @Fold
379     public static int allocatePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
380         return config.allocatePrefetchLines;
381     }
382 
383     @Fold
384     public static int allocatePrefetchDistance(@InjectedParameter GraalHotSpotVMConfig config) {
385         return config.allocatePrefetchDistance;
386     }
387 
388     @Fold
389     public static int allocateInstancePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
390         return config.allocateInstancePrefetchLines;
391     }
392 
393     @Fold
394     public static int allocatePrefetchStepSize(@InjectedParameter GraalHotSpotVMConfig config) {
395         return config.allocatePrefetchStepSize;
396     }
397 
398     @Fold
399     public static int invocationCounterIncrement(@InjectedParameter GraalHotSpotVMConfig config) {
400         return config.invocationCounterIncrement;
401     }
402 
403     @Fold
404     public static int invocationCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
405         return config.invocationCounterOffset;
406     }
407 
408     @Fold
409     public static int backedgeCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
410         return config.backedgeCounterOffset;
411     }
412 
413     @Fold
414     public static int invocationCounterShift(@InjectedParameter GraalHotSpotVMConfig config) {
415         return config.invocationCounterShift;
416     }
417 
418     @Fold
419     public static int stackBias(@InjectedParameter GraalHotSpotVMConfig config) {
420         return config.stackBias;
421     }
422 
423     @NodeIntrinsic(value = KlassLayoutHelperNode.class)
424     public static native int readLayoutHelper(KlassPointer object);
425 
426     /**
427      * Checks if class {@code klass} is an array.
428      *
429      * See: Klass::layout_helper_is_array
430      *
431      * @param klassNonNull the class to be checked
432      * @return true if klassNonNull is an array, false otherwise
433      */
434     public static boolean klassIsArray(KlassPointer klassNonNull) {
435         /*
436          * The less-than check only works if both values are ints. We use local variables to make
437          * sure these are still ints and haven&#39;t changed.
438          */
439         final int layoutHelper = readLayoutHelper(klassNonNull);
440         final int layoutHelperNeutralValue = klassLayoutHelperNeutralValue(INJECTED_VMCONFIG);
441         return (layoutHelper &lt; layoutHelperNeutralValue);
442     }
443 
444     public static final LocationIdentity ARRAY_KLASS_COMPONENT_MIRROR = NamedLocationIdentity.immutable(&quot;ArrayKlass::_component_mirror&quot;);
445 
446     @Fold
447     public static int arrayKlassComponentMirrorOffset(@InjectedParameter GraalHotSpotVMConfig config) {
448         return config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;);
449     }
450 
451     public static final LocationIdentity KLASS_SUPER_KLASS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super&quot;);
452 
453     @Fold
454     public static int klassSuperKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
455         return config.klassSuperKlassOffset;
456     }
457 
458     public static final LocationIdentity MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;MarkWord&quot;);
459 
460     @Fold
461     public static int markOffset(@InjectedParameter GraalHotSpotVMConfig config) {
462         return config.markOffset;
463     }
464 
465     public static final LocationIdentity HUB_WRITE_LOCATION = NamedLocationIdentity.mutable(&quot;Hub:write&quot;);
466 
467     public static final LocationIdentity HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Hub&quot;) {
468         @Override
469         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
470             TypeReference constantType = StampTool.typeReferenceOrNull(object);
471             if (constantType != null &amp;&amp; constantType.isExact()) {
472                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(constantType.getType()), tool.getMetaAccess());
473             }
474             return read;
475         }
476     };
477 
478     public static final LocationIdentity COMPRESSED_HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;CompressedHub&quot;) {
479         @Override
480         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
481             TypeReference constantType = StampTool.typeReferenceOrNull(object);
482             if (constantType != null &amp;&amp; constantType.isExact()) {
483                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), ((HotSpotMetaspaceConstant) tool.getConstantReflection().asObjectHub(constantType.getType())).compress(),
484                                 tool.getMetaAccess());
485             }
486             return read;
487         }
488     };
489 
490     @Fold
491     static int hubOffset(@InjectedParameter GraalHotSpotVMConfig config) {
492         return config.hubOffset;
493     }
494 
495     public static void initializeObjectHeader(Word memory, Word markWord, KlassPointer hub) {
496         memory.writeWord(markOffset(INJECTED_VMCONFIG), markWord, MARK_WORD_LOCATION);
497         StoreHubNode.write(memory, hub);
498     }
499 
500     @Fold
501     public static int unlockedMask(@InjectedParameter GraalHotSpotVMConfig config) {
502         return config.unlockedMask;
503     }
504 
505     @Fold
506     public static int monitorMask(@InjectedParameter GraalHotSpotVMConfig config) {
507         return config.monitorMask;
508     }
509 
510     @Fold
511     public static int objectMonitorOwnerOffset(@InjectedParameter GraalHotSpotVMConfig config) {
512         return config.objectMonitorOwner;
513     }
514 
515     @Fold
516     public static int objectMonitorRecursionsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
517         return config.objectMonitorRecursions;
518     }
519 
520     @Fold
521     public static int objectMonitorCxqOffset(@InjectedParameter GraalHotSpotVMConfig config) {
522         return config.objectMonitorCxq;
523     }
524 
525     @Fold
526     public static int objectMonitorEntryListOffset(@InjectedParameter GraalHotSpotVMConfig config) {
527         return config.objectMonitorEntryList;
528     }
529 
530     @Fold
531     public static int objectMonitorSuccOffset(@InjectedParameter GraalHotSpotVMConfig config) {
532         return config.objectMonitorSucc;
533     }
534 
535     /**
536      * Mask for a biasable, locked or unlocked mark word.
537      *
538      * &lt;pre&gt;
539      * +----------------------------------+-+-+
540      * |                                 1|1|1|
541      * +----------------------------------+-+-+
542      * &lt;/pre&gt;
543      *
544      */
545     @Fold
546     public static int biasedLockMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
547         return config.biasedLockMaskInPlace;
548     }
549 
550     @Fold
551     public static int epochMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
552         return config.epochMaskInPlace;
553     }
554 
555     /**
556      * Pattern for a biasable, unlocked mark word.
557      *
558      * &lt;pre&gt;
559      * +----------------------------------+-+-+
560      * |                                 1|0|1|
561      * +----------------------------------+-+-+
562      * &lt;/pre&gt;
563      *
564      */
565     @Fold
566     public static int biasedLockPattern(@InjectedParameter GraalHotSpotVMConfig config) {
567         return config.biasedLockPattern;
568     }
569 
570     @Fold
571     public static int ageMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
572         return config.ageMaskInPlace;
573     }
574 
575     @Fold
576     public static int metaspaceArrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
577         return config.metaspaceArrayLengthOffset;
578     }
579 
580     @Fold
581     public static int metaspaceArrayBaseOffset(@InjectedParameter GraalHotSpotVMConfig config) {
582         return config.metaspaceArrayBaseOffset;
583     }
584 
585     @Fold
586     public static int arrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
587         return config.arrayOopDescLengthOffset();
588     }
589 
590     public static Word arrayStart(int[] a) {
591         return WordFactory.unsigned(ComputeObjectAddressNode.get(a, ReplacementsUtil.getArrayBaseOffset(INJECTED_METAACCESS, JavaKind.Int)));
592     }
593 
594     /**
595      * Idiom for making {@link GraalHotSpotVMConfig} a constant.
596      */
597     @Fold
598     public static int objectAlignment(@InjectedParameter GraalHotSpotVMConfig config) {
599         return config.objectAlignment;
600     }
601 
<a name="6" id="anc6"></a><span class="line-removed">602     /**</span>
<span class="line-removed">603      * Calls {@link #arrayAllocationSize(int, int, int, int)} using an injected VM configuration</span>
<span class="line-removed">604      * object.</span>
<span class="line-removed">605      */</span>
<span class="line-removed">606     public static long arrayAllocationSize(int length, int headerSize, int log2ElementSize) {</span>
<span class="line-removed">607         return arrayAllocationSize(length, headerSize, log2ElementSize, objectAlignment(INJECTED_VMCONFIG));</span>
<span class="line-removed">608     }</span>
<span class="line-removed">609 </span>
<span class="line-removed">610     /**</span>
<span class="line-removed">611      * Computes the size of the memory chunk allocated for an array. This size accounts for the</span>
<span class="line-removed">612      * array header size, body size and any padding after the last element to satisfy object</span>
<span class="line-removed">613      * alignment requirements.</span>
<span class="line-removed">614      *</span>
<span class="line-removed">615      * @param length the number of elements in the array</span>
<span class="line-removed">616      * @param headerSize the size of the array header</span>
<span class="line-removed">617      * @param log2ElementSize log2 of the size of an element in the array</span>
<span class="line-removed">618      * @param alignment the {@linkplain GraalHotSpotVMConfig#objectAlignment object alignment</span>
<span class="line-removed">619      *            requirement}</span>
<span class="line-removed">620      * @return the size of the memory chunk</span>
<span class="line-removed">621      */</span>
<span class="line-removed">622     public static long arrayAllocationSize(int length, int headerSize, int log2ElementSize, int alignment) {</span>
<span class="line-removed">623         long size = ((long) length &lt;&lt; log2ElementSize) + headerSize + (alignment - 1);</span>
<span class="line-removed">624         long mask = ~(alignment - 1);</span>
<span class="line-removed">625         return size &amp; mask;</span>
<span class="line-removed">626     }</span>
<span class="line-removed">627 </span>
628     @Fold
629     public static int instanceHeaderSize(@InjectedParameter GraalHotSpotVMConfig config) {
630         return config.useCompressedClassPointers ? (2 * wordSize()) - 4 : 2 * wordSize();
631     }
632 
633     @Fold
634     public static byte dirtyCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
635         return config.dirtyCardValue;
636     }
637 
638     @Fold
639     public static byte g1YoungCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
640         return config.g1YoungCardValue;
641     }
642 
643     @Fold
644     public static int cardTableShift(@InjectedParameter GraalHotSpotVMConfig config) {
645         return config.cardtableShift;
646     }
647 
648     @Fold
649     public static int g1CardQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
650         return config.g1CardQueueIndexOffset;
651     }
652 
653     @Fold
654     public static int g1CardQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
655         return config.g1CardQueueBufferOffset;
656     }
657 
658     @Fold
659     public static int g1SATBQueueMarkingOffset(@InjectedParameter GraalHotSpotVMConfig config) {
660         return config.g1SATBQueueMarkingOffset;
661     }
662 
663     @Fold
664     public static int g1SATBQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
665         return config.g1SATBQueueIndexOffset;
666     }
667 
668     @Fold
669     public static int g1SATBQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
670         return config.g1SATBQueueBufferOffset;
671     }
672 
673     public static final LocationIdentity KLASS_SUPER_CHECK_OFFSET_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super_check_offset&quot;);
674 
675     @Fold
676     public static int superCheckOffsetOffset(@InjectedParameter GraalHotSpotVMConfig config) {
677         return config.superCheckOffsetOffset;
678     }
679 
680     public static final LocationIdentity SECONDARY_SUPER_CACHE_LOCATION = NamedLocationIdentity.mutable(&quot;SecondarySuperCache&quot;);
681 
682     @Fold
683     public static int secondarySuperCacheOffset(@InjectedParameter GraalHotSpotVMConfig config) {
684         return config.secondarySuperCacheOffset;
685     }
686 
687     public static final LocationIdentity SECONDARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupers&quot;);
688 
689     @Fold
690     public static int secondarySupersOffset(@InjectedParameter GraalHotSpotVMConfig config) {
691         return config.secondarySupersOffset;
692     }
693 
694     public static final LocationIdentity DISPLACED_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;DisplacedMarkWord&quot;);
695 
696     public static final LocationIdentity OBJECT_MONITOR_OWNER_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_owner&quot;);
697 
698     public static final LocationIdentity OBJECT_MONITOR_RECURSION_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_recursions&quot;);
699 
700     public static final LocationIdentity OBJECT_MONITOR_CXQ_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_cxq&quot;);
701 
702     public static final LocationIdentity OBJECT_MONITOR_ENTRY_LIST_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_EntryList&quot;);
703 
704     public static final LocationIdentity OBJECT_MONITOR_SUCC_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_succ&quot;);
705 
706     @Fold
707     public static int lockDisplacedMarkOffset(@InjectedParameter GraalHotSpotVMConfig config) {
708         return config.basicLockDisplacedHeaderOffset;
709     }
710 
711     @Fold
712     public static boolean useBiasedLocking(@InjectedParameter GraalHotSpotVMConfig config) {
713         return config.useBiasedLocking;
714     }
715 
716     @Fold
717     static int uninitializedIdentityHashCodeValue(@InjectedParameter GraalHotSpotVMConfig config) {
718         return config.uninitializedIdentityHashCodeValue;
719     }
720 
721     @Fold
722     static int identityHashCodeShift(@InjectedParameter GraalHotSpotVMConfig config) {
723         return config.identityHashCodeShift;
724     }
725 
726     /**
727      * Loads the hub of an object (without null checking it first).
728      */
729     public static KlassPointer loadHub(Object object) {
730         return loadHubIntrinsic(object);
731     }
732 
733     public static Object verifyOop(Object object) {
734         if (verifyOops(INJECTED_VMCONFIG)) {
735             verifyOopStub(VERIFY_OOP, object);
736         }
737         return object;
738     }
739 
740     @NodeIntrinsic(ForeignCallNode.class)
741     private static native Object verifyOopStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
742 
743     public static Word loadWordFromObject(Object object, int offset) {
744         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
745         return loadWordFromObjectIntrinsic(object, offset, LocationIdentity.any(), getWordKind());
746     }
747 
748     public static Word loadWordFromObject(Object object, int offset, LocationIdentity identity) {
749         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
750         return loadWordFromObjectIntrinsic(object, offset, identity, getWordKind());
751     }
752 
753     public static KlassPointer loadKlassFromObject(Object object, int offset, LocationIdentity identity) {
754         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadKlassFromObject&quot;);
755         return loadKlassFromObjectIntrinsic(object, offset, identity, getWordKind());
756     }
757 
758     /**
759      * Reads the value of a given register.
760      *
761      * @param register a register which must not be available to the register allocator
762      * @return the value of {@code register} as a word
763      */
764     public static Word registerAsWord(@ConstantNodeParameter Register register) {
765         return registerAsWord(register, true, false);
766     }
767 
768     @NodeIntrinsic(value = ReadRegisterNode.class)
769     public static native Word registerAsWord(@ConstantNodeParameter Register register, @ConstantNodeParameter boolean directUse, @ConstantNodeParameter boolean incoming);
770 
771     @NodeIntrinsic(value = WriteRegisterNode.class)
772     public static native void writeRegisterAsWord(@ConstantNodeParameter Register register, Word value);
773 
774     @NodeIntrinsic(value = RawLoadNode.class)
775     private static native Word loadWordFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
776 
777     @NodeIntrinsic(value = RawLoadNode.class)
778     private static native KlassPointer loadKlassFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
779 
780     @NodeIntrinsic(value = LoadHubNode.class)
781     public static native KlassPointer loadHubIntrinsic(Object object);
782 
783     @NodeIntrinsic(value = LoadHubOrNullNode.class)
784     public static native KlassPointer loadHubOrNullIntrinsic(Object object);
785 
786     static final LocationIdentity CLASS_INIT_STATE_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitState&quot;);
787 
788     static final LocationIdentity CLASS_INIT_THREAD_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitThread&quot;);
789 
790     @Fold
791     static int instanceKlassInitStateOffset(@InjectedParameter GraalHotSpotVMConfig config) {
792         return config.instanceKlassInitStateOffset;
793     }
794 
795     @Fold
796     static int instanceKlassInitThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
797         assert config.instanceKlassInitThreadOffset != -1;
798         return config.instanceKlassInitThreadOffset;
799     }
800 
801     @Fold
802     public static int instanceKlassStateFullyInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
803         return config.instanceKlassStateFullyInitialized;
804     }
805 
806     @Fold
807     public static int instanceKlassStateBeingInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
808         assert config.instanceKlassStateBeingInitialized != -1;
809         return config.instanceKlassStateBeingInitialized;
810     }
811 
812     /**
813      *
814      * @param hub the hub of an InstanceKlass
815      * @return true is the InstanceKlass represented by hub is fully initialized
816      */
817     public static boolean isInstanceKlassFullyInitialized(KlassPointer hub) {
818         return readInstanceKlassInitState(hub) == instanceKlassStateFullyInitialized(INJECTED_VMCONFIG);
819     }
820 
821     static byte readInstanceKlassInitState(KlassPointer hub) {
822         return hub.readByte(instanceKlassInitStateOffset(INJECTED_VMCONFIG), CLASS_INIT_STATE_LOCATION);
823     }
824 
825     static Word readInstanceKlassInitThread(KlassPointer hub) {
826         return hub.readWord(instanceKlassInitThreadOffset(INJECTED_VMCONFIG), CLASS_INIT_THREAD_LOCATION);
827     }
828 
829     public static final LocationIdentity KLASS_MODIFIER_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_modifier_flags&quot;);
830 
831     @Fold
832     public static int klassModifierFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
833         return config.klassModifierFlagsOffset;
834     }
835 
836     public static final LocationIdentity CLASS_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._klass&quot;) {
837         @Override
838         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
839             return foldIndirection(read, object, CLASS_MIRROR_LOCATION);
840         }
841     };
842 
843     public static final LocationIdentity CLASS_ARRAY_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._array_klass&quot;) {
844         @Override
845         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
846             return foldIndirection(read, object, ARRAY_KLASS_COMPONENT_MIRROR);
847         }
848     };
849 
850     @Fold
851     public static int arrayKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
852         return config.arrayKlassOffset;
853     }
854 
855     public static final LocationIdentity CLASS_MIRROR_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror&quot;);
856 
857     public static final LocationIdentity CLASS_MIRROR_HANDLE_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror handle&quot;);
858 
859     @Fold
860     public static int layoutHelperHeaderSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
861         return config.layoutHelperHeaderSizeShift;
862     }
863 
864     @Fold
865     public static int layoutHelperHeaderSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
866         return config.layoutHelperHeaderSizeMask;
867     }
868 
869     @Fold
870     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
871         return config.layoutHelperLog2ElementSizeShift;
872     }
873 
874     @Fold
875     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
876         return config.layoutHelperLog2ElementSizeMask;
877     }
878 
879     @NodeIntrinsic(ForeignCallNode.class)
880     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
881 
882     @Fold
883     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
884         return config.gcTotalCollectionsAddress();
885     }
886 
887     @Fold
888     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
889         return getFieldOffset(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);
890     }
891 
892     @Fold
893     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
894         return metaAccessProvider.lookupJavaType(Reference.class);
895     }
896 
897     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
898         @Override
899         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
900             ValueNode javaObject = findReadHub(object);
901             if (javaObject != null) {
902                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
903                 if (type != null &amp;&amp; type.isArray()) {
904                     ResolvedJavaType element = type.getComponentType();
905                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
906                         Assumptions assumptions = object.graph().getAssumptions();
907                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
908                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
909                             leafType.recordTo(assumptions);
910                             return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(leafType.getResult()), tool.getMetaAccess());
911                         }
912                     }
913                 }
914             }
915             return read;
916         }
917     };
918 
919     @Fold
920     public static int arrayClassElementOffset(@InjectedParameter GraalHotSpotVMConfig config) {
921         return config.arrayClassElementOffset;
922     }
923 
924     public static final LocationIdentity PRIMARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;PrimarySupers&quot;);
925 
926     public static final LocationIdentity METASPACE_ARRAY_LENGTH_LOCATION = NamedLocationIdentity.immutable(&quot;MetaspaceArrayLength&quot;);
927 
928     public static final LocationIdentity SECONDARY_SUPERS_ELEMENT_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupersElement&quot;);
929 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases/src/org/graalvm/compiler/phases/schedule/SchedulePhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.phases.schedule;
  26 
  27 import static jdk.internal.vm.compiler.collections.Equivalence.IDENTITY;
  28 import static org.graalvm.compiler.core.common.GraalOptions.GuardPriorities;
  29 import static org.graalvm.compiler.core.common.GraalOptions.OptScheduleOutOfLoops;
  30 import static org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph.strictlyDominates;
  31 
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Comparator;
  35 import java.util.EnumMap;
  36 import java.util.Formatter;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.SortedSet;
  40 import java.util.TreeSet;
  41 import java.util.function.Function;
  42 
  43 import jdk.internal.vm.compiler.collections.EconomicSet;
  44 import org.graalvm.compiler.core.common.SuppressFBWarnings;
  45 import org.graalvm.compiler.core.common.cfg.AbstractControlFlowGraph;
  46 import org.graalvm.compiler.core.common.cfg.BlockMap;
  47 import org.graalvm.compiler.debug.Assertions;
  48 import org.graalvm.compiler.graph.Graph.NodeEvent;
  49 import org.graalvm.compiler.graph.Graph.NodeEventListener;
  50 import org.graalvm.compiler.graph.Graph.NodeEventScope;
  51 import org.graalvm.compiler.graph.Node;
  52 import org.graalvm.compiler.graph.NodeBitMap;
  53 import org.graalvm.compiler.graph.NodeMap;
  54 import org.graalvm.compiler.graph.NodeStack;
  55 import org.graalvm.compiler.nodes.AbstractBeginNode;
  56 import org.graalvm.compiler.nodes.AbstractEndNode;
  57 import org.graalvm.compiler.nodes.AbstractMergeNode;
  58 import org.graalvm.compiler.nodes.ControlSinkNode;
  59 import org.graalvm.compiler.nodes.ControlSplitNode;
  60 import org.graalvm.compiler.nodes.DeoptimizeNode;
  61 import org.graalvm.compiler.nodes.FixedNode;
  62 import org.graalvm.compiler.nodes.GuardNode;
  63 import org.graalvm.compiler.nodes.IfNode;
  64 import org.graalvm.compiler.nodes.KillingBeginNode;
  65 import org.graalvm.compiler.nodes.LoopBeginNode;
  66 import org.graalvm.compiler.nodes.LoopExitNode;
  67 import org.graalvm.compiler.nodes.PhiNode;
  68 import org.graalvm.compiler.nodes.ProxyNode;
  69 import org.graalvm.compiler.nodes.StartNode;
  70 import org.graalvm.compiler.nodes.StaticDeoptimizingNode;
  71 import org.graalvm.compiler.nodes.StaticDeoptimizingNode.GuardPriority;
  72 import org.graalvm.compiler.nodes.StructuredGraph;
  73 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
  74 import org.graalvm.compiler.nodes.StructuredGraph.ScheduleResult;
  75 import org.graalvm.compiler.nodes.ValueNode;
  76 import org.graalvm.compiler.nodes.VirtualState;
  77 import org.graalvm.compiler.nodes.calc.ConvertNode;
  78 import org.graalvm.compiler.nodes.calc.IsNullNode;
  79 import org.graalvm.compiler.nodes.cfg.Block;
  80 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  81 import org.graalvm.compiler.nodes.cfg.HIRLoop;
  82 import org.graalvm.compiler.nodes.cfg.LocationSet;
  83 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
<a name="2" id="anc2"></a><span class="line-modified">  84 import org.graalvm.compiler.nodes.memory.MemoryCheckpoint;</span>

  85 import org.graalvm.compiler.nodes.spi.ValueProxy;
  86 import org.graalvm.compiler.options.OptionValues;
  87 import org.graalvm.compiler.phases.Phase;
  88 import jdk.internal.vm.compiler.word.LocationIdentity;
  89 
  90 public final class SchedulePhase extends Phase {
  91 
  92     public enum SchedulingStrategy {
  93         EARLIEST_WITH_GUARD_ORDER,
  94         EARLIEST,
  95         LATEST,
  96         LATEST_OUT_OF_LOOPS,
  97         LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
  98 
  99         public boolean isEarliest() {
 100             return this == EARLIEST || this == EARLIEST_WITH_GUARD_ORDER;
 101         }
 102 
 103         public boolean isLatest() {
 104             return !isEarliest();
 105         }
 106 
 107         public boolean scheduleOutOfLoops() {
 108             return this == LATEST_OUT_OF_LOOPS || this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
 109         }
 110 
 111         public boolean considerImplicitNullChecks() {
 112             return this == LATEST_OUT_OF_LOOPS_IMPLICIT_NULL_CHECKS;
 113         }
 114     }
 115 
 116     private final SchedulingStrategy selectedStrategy;
 117 
 118     private final boolean immutableGraph;
 119 
 120     public SchedulePhase(OptionValues options) {
 121         this(false, options);
 122     }
 123 
 124     public SchedulePhase(boolean immutableGraph, OptionValues options) {
 125         this(OptScheduleOutOfLoops.getValue(options) ? SchedulingStrategy.LATEST_OUT_OF_LOOPS : SchedulingStrategy.LATEST, immutableGraph);
 126     }
 127 
 128     public SchedulePhase(SchedulingStrategy strategy) {
 129         this(strategy, false);
 130     }
 131 
 132     public SchedulePhase(SchedulingStrategy strategy, boolean immutableGraph) {
 133         this.selectedStrategy = strategy;
 134         this.immutableGraph = immutableGraph;
 135     }
 136 
 137     private NodeEventScope verifyImmutableGraph(StructuredGraph graph) {
 138         if (immutableGraph &amp;&amp; Assertions.assertionsEnabled()) {
 139             return graph.trackNodeEvents(new NodeEventListener() {
 140                 @Override
 141                 public void changed(NodeEvent e, Node node) {
 142                     assert false : &quot;graph changed: &quot; + e + &quot; on node &quot; + node;
 143                 }
 144             });
 145         } else {
 146             return null;
 147         }
 148     }
 149 
 150     @Override
 151     @SuppressWarnings(&quot;try&quot;)
 152     protected void run(StructuredGraph graph) {
 153         try (NodeEventScope scope = verifyImmutableGraph(graph)) {
 154             Instance inst = new Instance();
 155             inst.run(graph, selectedStrategy, immutableGraph);
 156         }
 157     }
 158 
 159     public static void run(StructuredGraph graph, SchedulingStrategy strategy, ControlFlowGraph cfg) {
 160         Instance inst = new Instance(cfg);
 161         inst.run(graph, strategy, false);
 162     }
 163 
 164     public static class Instance {
 165 
 166         private static final double IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR = 2;
 167         /**
 168          * Map from blocks to the nodes in each block.
 169          */
 170         protected ControlFlowGraph cfg;
 171         protected BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap;
 172         protected NodeMap&lt;Block&gt; nodeToBlockMap;
 173 
 174         public Instance() {
 175             this(null);
 176         }
 177 
 178         public Instance(ControlFlowGraph cfg) {
 179             this.cfg = cfg;
 180         }
 181 
 182         @SuppressWarnings(&quot;try&quot;)
 183         public void run(StructuredGraph graph, SchedulingStrategy selectedStrategy, boolean immutableGraph) {
 184             // assert GraphOrder.assertNonCyclicGraph(graph);
 185 
 186             if (this.cfg == null) {
 187                 this.cfg = ControlFlowGraph.compute(graph, true, true, true, false);
 188             }
 189 
 190             NodeMap&lt;Block&gt; currentNodeMap = graph.createNodeMap();
 191             NodeBitMap visited = graph.createNodeBitMap();
 192             BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 193             this.nodeToBlockMap = currentNodeMap;
 194             this.blockToNodesMap = earliestBlockToNodesMap;
 195 
 196             scheduleEarliestIterative(earliestBlockToNodesMap, currentNodeMap, visited, graph, immutableGraph, selectedStrategy == SchedulingStrategy.EARLIEST_WITH_GUARD_ORDER);
 197 
 198             if (!selectedStrategy.isEarliest()) {
 199                 // For non-earliest schedules, we need to do a second pass.
 200                 BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap = new BlockMap&lt;&gt;(cfg);
 201                 for (Block b : cfg.getBlocks()) {
 202                     latestBlockToNodesMap.put(b, new ArrayList&lt;&gt;());
 203                 }
 204 
 205                 BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = calcLatestBlocks(selectedStrategy, currentNodeMap, earliestBlockToNodesMap, visited, latestBlockToNodesMap, immutableGraph);
 206                 sortNodesLatestWithinBlock(cfg, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 207 
 208                 assert verifySchedule(cfg, latestBlockToNodesMap, currentNodeMap);
 209                 assert (!Assertions.detailedAssertionsEnabled(graph.getOptions())) ||
 210                                 ScheduleVerification.check(cfg.getStartBlock(), latestBlockToNodesMap, currentNodeMap);
 211 
 212                 this.blockToNodesMap = latestBlockToNodesMap;
 213 
 214             }
 215             cfg.setNodeToBlock(currentNodeMap);
 216 
 217             graph.setLastSchedule(new ScheduleResult(this.cfg, this.nodeToBlockMap, this.blockToNodesMap));
 218         }
 219 
 220         @SuppressFBWarnings(value = &quot;RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE&quot;, justification = &quot;false positive found by findbugs&quot;)
 221         private BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; calcLatestBlocks(SchedulingStrategy strategy, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, NodeBitMap visited,
 222                         BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, boolean immutableGraph) {
 223             BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap = new BlockMap&lt;&gt;(cfg);
 224             Block[] reversePostOrder = cfg.reversePostOrder();
 225             for (int j = reversePostOrder.length - 1; j &gt;= 0; --j) {
 226                 Block currentBlock = reversePostOrder[j];
 227                 List&lt;Node&gt; blockToNodes = earliestBlockToNodesMap.get(currentBlock);
 228                 LocationSet killed = null;
 229                 int previousIndex = blockToNodes.size();
 230                 for (int i = blockToNodes.size() - 1; i &gt;= 0; --i) {
 231                     Node currentNode = blockToNodes.get(i);
 232                     assert currentNodeMap.get(currentNode) == currentBlock;
 233                     assert !(currentNode instanceof PhiNode) &amp;&amp; !(currentNode instanceof ProxyNode);
 234                     assert visited.isMarked(currentNode);
 235                     if (currentNode instanceof FixedNode) {
 236                         // For these nodes, the earliest is at the same time the latest block.
 237                     } else {
 238                         Block latestBlock = null;
 239 
 240                         if (currentBlock.getFirstDominated() == null &amp;&amp; !(currentNode instanceof VirtualState)) {
 241                             // This block doesn&#39;t dominate any other blocks =&gt;
 242                             // node must be scheduled in earliest block.
 243                             latestBlock = currentBlock;
 244                         }
 245 
 246                         LocationIdentity constrainingLocation = null;
 247                         if (latestBlock == null &amp;&amp; currentNode instanceof FloatingReadNode) {
 248                             // We are scheduling a floating read node =&gt; check memory
 249                             // anti-dependencies.
 250                             FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 251                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 252                             if (location.isMutable()) {
 253                                 // Location can be killed.
 254                                 constrainingLocation = location;
 255                                 if (currentBlock.canKill(location)) {
 256                                     if (killed == null) {
 257                                         killed = new LocationSet();
 258                                     }
 259                                     fillKillSet(killed, blockToNodes.subList(i + 1, previousIndex));
 260                                     previousIndex = i;
 261                                     if (killed.contains(location)) {
 262                                         // Earliest block kills location =&gt; we need to stay within
 263                                         // earliest block.
 264                                         latestBlock = currentBlock;
 265                                     }
 266                                 }
 267                             }
 268                         }
 269 
 270                         if (latestBlock == null) {
 271                             // We are not constraint within earliest block =&gt; calculate optimized
 272                             // schedule.
 273                             calcLatestBlock(currentBlock, strategy, currentNode, currentNodeMap, constrainingLocation, watchListMap, latestBlockToNodesMap, visited, immutableGraph);
 274                         } else {
 275                             selectLatestBlock(currentNode, currentBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 276                         }
 277                     }
 278                 }
 279             }
 280             return watchListMap;
 281         }
 282 
 283         protected static void selectLatestBlock(Node currentNode, Block currentBlock, Block latestBlock, NodeMap&lt;Block&gt; currentNodeMap, BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap,
 284                         LocationIdentity constrainingLocation, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap) {
 285 
 286             assert checkLatestEarliestRelation(currentNode, currentBlock, latestBlock);
 287             if (currentBlock != latestBlock) {
 288 
 289                 currentNodeMap.setAndGrow(currentNode, latestBlock);
 290 
 291                 if (constrainingLocation != null &amp;&amp; latestBlock.canKill(constrainingLocation)) {
 292                     if (watchListMap.get(latestBlock) == null) {
 293                         watchListMap.put(latestBlock, new ArrayList&lt;&gt;());
 294                     }
 295                     watchListMap.get(latestBlock).add((FloatingReadNode) currentNode);
 296                 }
 297             }
 298 
 299             latestBlockToNodesMap.get(latestBlock).add(currentNode);
 300         }
 301 
 302         private static boolean checkLatestEarliestRelation(Node currentNode, Block earliestBlock, Block latestBlock) {
 303             assert AbstractControlFlowGraph.dominates(earliestBlock, latestBlock) || (currentNode instanceof VirtualState &amp;&amp; latestBlock == earliestBlock.getDominator()) : String.format(
 304                             &quot;%s %s (%s) %s (%s)&quot;, currentNode, earliestBlock, earliestBlock.getBeginNode(), latestBlock, latestBlock.getBeginNode());
 305             return true;
 306         }
 307 
 308         private static boolean verifySchedule(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap, NodeMap&lt;Block&gt; nodeMap) {
 309             for (Block b : cfg.getBlocks()) {
 310                 List&lt;Node&gt; nodes = blockToNodesMap.get(b);
 311                 for (Node n : nodes) {
 312                     assert n.isAlive();
 313                     assert nodeMap.get(n) == b;
 314                     StructuredGraph g = (StructuredGraph) n.graph();
 315                     if (g.hasLoops() &amp;&amp; g.getGuardsStage() == GuardsStage.AFTER_FSA &amp;&amp; n instanceof DeoptimizeNode) {
 316                         assert b.getLoopDepth() == 0 : n;
 317                     }
 318                 }
 319             }
 320             return true;
 321         }
 322 
 323         public static Block checkKillsBetween(Block earliestBlock, Block latestBlock, LocationIdentity location) {
 324             assert strictlyDominates(earliestBlock, latestBlock);
 325             Block current = latestBlock.getDominator();
 326 
 327             // Collect dominator chain that needs checking.
 328             List&lt;Block&gt; dominatorChain = new ArrayList&lt;&gt;();
 329             dominatorChain.add(latestBlock);
 330             while (current != earliestBlock) {
 331                 // Current is an intermediate dominator between earliestBlock and latestBlock.
 332                 assert strictlyDominates(earliestBlock, current) &amp;&amp; strictlyDominates(current, latestBlock);
 333                 if (current.canKill(location)) {
 334                     dominatorChain.clear();
 335                 }
 336                 dominatorChain.add(current);
 337                 current = current.getDominator();
 338             }
 339 
 340             // The first element of dominatorChain now contains the latest possible block.
 341             assert dominatorChain.size() &gt;= 1;
 342             assert dominatorChain.get(dominatorChain.size() - 1).getDominator() == earliestBlock;
 343 
 344             Block lastBlock = earliestBlock;
 345             for (int i = dominatorChain.size() - 1; i &gt;= 0; --i) {
 346                 Block currentBlock = dominatorChain.get(i);
 347                 if (currentBlock.getLoopDepth() &gt; lastBlock.getLoopDepth()) {
 348                     // We are entering a loop boundary. The new loops must not kill the location for
 349                     // the crossing to be safe.
 350                     if (currentBlock.getLoop() != null &amp;&amp; ((HIRLoop) currentBlock.getLoop()).canKill(location)) {
 351                         break;
 352                     }
 353                 }
 354 
 355                 if (currentBlock.canKillBetweenThisAndDominator(location)) {
 356                     break;
 357                 }
 358                 lastBlock = currentBlock;
 359             }
 360 
 361             if (lastBlock.getBeginNode() instanceof KillingBeginNode) {
 362                 LocationIdentity locationIdentity = ((KillingBeginNode) lastBlock.getBeginNode()).getKilledLocationIdentity();
 363                 if ((locationIdentity.isAny() || locationIdentity.equals(location)) &amp;&amp; lastBlock != earliestBlock) {
 364                     // The begin of this block kills the location, so we *have* to schedule the node
 365                     // in the dominating block.
 366                     lastBlock = lastBlock.getDominator();
 367                 }
 368             }
 369 
 370             return lastBlock;
 371         }
 372 
 373         private static void fillKillSet(LocationSet killed, List&lt;Node&gt; subList) {
 374             if (!killed.isAny()) {
 375                 for (Node n : subList) {
 376                     // Check if this node kills a node in the watch list.
<a name="3" id="anc3"></a><span class="line-modified"> 377                     if (n instanceof MemoryCheckpoint.Single) {</span>
<span class="line-modified"> 378                         LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
 379                         killed.add(identity);
 380                         if (killed.isAny()) {
 381                             return;
 382                         }
<a name="4" id="anc4"></a><span class="line-modified"> 383                     } else if (n instanceof MemoryCheckpoint.Multi) {</span>
<span class="line-modified"> 384                         for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
 385                             killed.add(identity);
 386                             if (killed.isAny()) {
 387                                 return;
 388                             }
 389                         }
 390                     }
 391                 }
 392             }
 393         }
 394 
 395         private static void sortNodesLatestWithinBlock(ControlFlowGraph cfg, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; currentNodeMap,
 396                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap visited) {
 397             for (Block b : cfg.getBlocks()) {
 398                 sortNodesLatestWithinBlock(b, earliestBlockToNodesMap, latestBlockToNodesMap, currentNodeMap, watchListMap, visited);
 399             }
 400         }
 401 
 402         private static void sortNodesLatestWithinBlock(Block b, BlockMap&lt;List&lt;Node&gt;&gt; earliestBlockToNodesMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeMap&lt;Block&gt; nodeMap,
 403                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, NodeBitMap unprocessed) {
 404             List&lt;Node&gt; earliestSorting = earliestBlockToNodesMap.get(b);
 405             ArrayList&lt;Node&gt; result = new ArrayList&lt;&gt;(earliestSorting.size());
 406             ArrayList&lt;FloatingReadNode&gt; watchList = null;
 407             if (watchListMap != null) {
 408                 watchList = watchListMap.get(b);
 409                 assert watchList == null || !b.getKillLocations().isEmpty();
 410             }
 411             AbstractBeginNode beginNode = b.getBeginNode();
 412             if (beginNode instanceof LoopExitNode) {
 413                 LoopExitNode loopExitNode = (LoopExitNode) beginNode;
 414                 for (ProxyNode proxy : loopExitNode.proxies()) {
 415                     unprocessed.clear(proxy);
 416                     ValueNode value = proxy.value();
 417                     // if multiple proxies reference the same value, schedule the value of a
 418                     // proxy once
 419                     if (value != null &amp;&amp; nodeMap.get(value) == b &amp;&amp; unprocessed.isMarked(value)) {
 420                         sortIntoList(value, b, result, nodeMap, unprocessed, null);
 421                     }
 422                 }
 423             }
 424             FixedNode endNode = b.getEndNode();
 425             FixedNode fixedEndNode = null;
 426             if (isFixedEnd(endNode)) {
 427                 // Only if the end node is either a control split or an end node, we need to force
 428                 // it to be the last node in the schedule.
 429                 fixedEndNode = endNode;
 430             }
 431             for (Node n : earliestSorting) {
 432                 if (n != fixedEndNode) {
 433                     if (n instanceof FixedNode) {
 434                         assert nodeMap.get(n) == b;
 435                         checkWatchList(b, nodeMap, unprocessed, result, watchList, n);
 436                         sortIntoList(n, b, result, nodeMap, unprocessed, null);
 437                     } else if (nodeMap.get(n) == b &amp;&amp; n instanceof FloatingReadNode) {
 438                         FloatingReadNode floatingReadNode = (FloatingReadNode) n;
 439                         if (isImplicitNullOpportunity(floatingReadNode, b)) {
 440                             // Schedule at the beginning of the block.
 441                             sortIntoList(floatingReadNode, b, result, nodeMap, unprocessed, null);
 442                         } else {
 443                             LocationIdentity location = floatingReadNode.getLocationIdentity();
 444                             if (b.canKill(location)) {
 445                                 // This read can be killed in this block, add to watch list.
 446                                 if (watchList == null) {
 447                                     watchList = new ArrayList&lt;&gt;();
 448                                 }
 449                                 watchList.add(floatingReadNode);
 450                             }
 451                         }
 452                     }
 453                 }
 454             }
 455 
 456             for (Node n : latestBlockToNodesMap.get(b)) {
 457                 assert nodeMap.get(n) == b : n;
 458                 assert !(n instanceof FixedNode);
 459                 if (unprocessed.isMarked(n)) {
 460                     sortIntoList(n, b, result, nodeMap, unprocessed, fixedEndNode);
 461                 }
 462             }
 463 
 464             if (endNode != null &amp;&amp; unprocessed.isMarked(endNode)) {
 465                 sortIntoList(endNode, b, result, nodeMap, unprocessed, null);
 466             }
 467 
 468             latestBlockToNodesMap.put(b, result);
 469         }
 470 
 471         private static void checkWatchList(Block b, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, ArrayList&lt;Node&gt; result, ArrayList&lt;FloatingReadNode&gt; watchList, Node n) {
 472             if (watchList != null &amp;&amp; !watchList.isEmpty()) {
 473                 // Check if this node kills a node in the watch list.
<a name="5" id="anc5"></a><span class="line-modified"> 474                 if (n instanceof MemoryCheckpoint.Single) {</span>
<span class="line-modified"> 475                     LocationIdentity identity = ((MemoryCheckpoint.Single) n).getKilledLocationIdentity();</span>
 476                     checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
<a name="6" id="anc6"></a><span class="line-modified"> 477                 } else if (n instanceof MemoryCheckpoint.Multi) {</span>
<span class="line-modified"> 478                     for (LocationIdentity identity : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
 479                         checkWatchList(watchList, identity, b, result, nodeMap, unprocessed);
 480                     }
 481                 }
 482             }
 483         }
 484 
 485         private static void checkWatchList(ArrayList&lt;FloatingReadNode&gt; watchList, LocationIdentity identity, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed) {
 486             if (identity.isImmutable()) {
 487                 // Nothing to do. This can happen for an initialization write.
 488             } else if (identity.isAny()) {
 489                 for (FloatingReadNode r : watchList) {
 490                     if (unprocessed.isMarked(r)) {
 491                         sortIntoList(r, b, result, nodeMap, unprocessed, null);
 492                     }
 493                 }
 494                 watchList.clear();
 495             } else {
 496                 int index = 0;
 497                 while (index &lt; watchList.size()) {
 498                     FloatingReadNode r = watchList.get(index);
 499                     LocationIdentity locationIdentity = r.getLocationIdentity();
 500                     assert locationIdentity.isMutable();
 501                     if (unprocessed.isMarked(r)) {
 502                         if (identity.overlaps(locationIdentity)) {
 503                             sortIntoList(r, b, result, nodeMap, unprocessed, null);
 504                         } else {
 505                             ++index;
 506                             continue;
 507                         }
 508                     }
 509                     int lastIndex = watchList.size() - 1;
 510                     watchList.set(index, watchList.get(lastIndex));
 511                     watchList.remove(lastIndex);
 512                 }
 513             }
 514         }
 515 
 516         private static void sortIntoList(Node n, Block b, ArrayList&lt;Node&gt; result, NodeMap&lt;Block&gt; nodeMap, NodeBitMap unprocessed, Node excludeNode) {
 517             assert unprocessed.isMarked(n) : n;
 518             assert nodeMap.get(n) == b;
 519 
 520             if (n instanceof PhiNode) {
 521                 return;
 522             }
 523 
 524             unprocessed.clear(n);
 525 
 526             for (Node input : n.inputs()) {
 527                 if (nodeMap.get(input) == b &amp;&amp; unprocessed.isMarked(input) &amp;&amp; input != excludeNode) {
 528                     sortIntoList(input, b, result, nodeMap, unprocessed, excludeNode);
 529                 }
 530             }
 531 
 532             if (n instanceof ProxyNode) {
 533                 // Skip proxy nodes.
 534             } else {
 535                 result.add(n);
 536             }
 537 
 538         }
 539 
 540         protected void calcLatestBlock(Block earliestBlock, SchedulingStrategy strategy, Node currentNode, NodeMap&lt;Block&gt; currentNodeMap, LocationIdentity constrainingLocation,
 541                         BlockMap&lt;ArrayList&lt;FloatingReadNode&gt;&gt; watchListMap, BlockMap&lt;List&lt;Node&gt;&gt; latestBlockToNodesMap, NodeBitMap visited, boolean immutableGraph) {
 542             Block latestBlock = null;
 543             if (!currentNode.hasUsages()) {
 544                 assert currentNode instanceof GuardNode;
 545                 latestBlock = earliestBlock;
 546             } else {
 547                 assert currentNode.hasUsages();
 548                 for (Node usage : currentNode.usages()) {
 549                     if (immutableGraph &amp;&amp; !visited.contains(usage)) {
 550                         /*
 551                          * Normally, dead nodes are deleted by the scheduler before we reach this
 552                          * point. Only when the scheduler is asked to not modify a graph, we can see
 553                          * dead nodes here.
 554                          */
 555                         continue;
 556                     }
 557                     latestBlock = calcBlockForUsage(currentNode, usage, latestBlock, currentNodeMap);
 558                 }
 559 
 560                 assert latestBlock != null : currentNode;
 561 
 562                 if (strategy.scheduleOutOfLoops()) {
 563                     Block currentBlock = latestBlock;
 564                     while (currentBlock.getLoopDepth() &gt; earliestBlock.getLoopDepth() &amp;&amp; currentBlock != earliestBlock.getDominator()) {
 565                         Block previousCurrentBlock = currentBlock;
 566                         currentBlock = currentBlock.getDominator();
 567                         if (previousCurrentBlock.isLoopHeader()) {
 568                             if (currentBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() || ((StructuredGraph) currentNode.graph()).hasValueProxies()) {
 569                                 // Only assign new latest block if frequency is actually lower or if
 570                                 // loop proxies would be required otherwise.
 571                                 latestBlock = currentBlock;
 572                             }
 573                         }
 574                     }
 575                 }
 576 
 577                 if (latestBlock != earliestBlock &amp;&amp; latestBlock != earliestBlock.getDominator() &amp;&amp; constrainingLocation != null) {
 578                     latestBlock = checkKillsBetween(earliestBlock, latestBlock, constrainingLocation);
 579                 }
 580             }
 581 
 582             if (latestBlock != earliestBlock &amp;&amp; strategy.considerImplicitNullChecks() &amp;&amp; isImplicitNullOpportunity(currentNode, earliestBlock) &amp;&amp;
 583                             earliestBlock.getRelativeFrequency() &lt; latestBlock.getRelativeFrequency() * IMPLICIT_NULL_CHECK_OPPORTUNITY_PROBABILITY_FACTOR) {
 584                 latestBlock = earliestBlock;
 585             }
 586 
 587             selectLatestBlock(currentNode, earliestBlock, latestBlock, currentNodeMap, watchListMap, constrainingLocation, latestBlockToNodesMap);
 588         }
 589 
 590         protected static boolean isImplicitNullOpportunity(Node currentNode, Block block) {
 591             if (currentNode instanceof FloatingReadNode) {
 592                 FloatingReadNode floatingReadNode = (FloatingReadNode) currentNode;
 593                 Node pred = block.getBeginNode().predecessor();
 594                 if (pred instanceof IfNode) {
 595                     IfNode ifNode = (IfNode) pred;
 596                     if (ifNode.condition() instanceof IsNullNode &amp;&amp; ifNode.getTrueSuccessorProbability() == 0.0) {
 597                         IsNullNode isNullNode = (IsNullNode) ifNode.condition();
 598                         if (getUnproxifiedUncompressed(floatingReadNode.getAddress().getBase()) == getUnproxifiedUncompressed(isNullNode.getValue())) {
 599                             return true;
 600                         }
 601                     }
 602                 }
 603             }
 604             return false;
 605         }
 606 
 607         private static Node getUnproxifiedUncompressed(Node node) {
 608             Node result = node;
 609             while (true) {
 610                 if (result instanceof ValueProxy) {
 611                     ValueProxy valueProxy = (ValueProxy) result;
 612                     result = valueProxy.getOriginalNode();
 613                 } else if (result instanceof ConvertNode) {
 614                     ConvertNode convertNode = (ConvertNode) result;
 615                     if (convertNode.mayNullCheckSkipConversion()) {
 616                         result = convertNode.getValue();
 617                     } else {
 618                         break;
 619                     }
 620                 } else {
 621                     break;
 622                 }
 623             }
 624             return result;
 625         }
 626 
 627         private static Block calcBlockForUsage(Node node, Node usage, Block startBlock, NodeMap&lt;Block&gt; currentNodeMap) {
 628             assert !(node instanceof PhiNode);
 629             Block currentBlock = startBlock;
 630             if (usage instanceof PhiNode) {
 631                 // An input to a PhiNode is used at the end of the predecessor block that
 632                 // corresponds to the PhiNode input. One PhiNode can use an input multiple times.
 633                 PhiNode phi = (PhiNode) usage;
 634                 AbstractMergeNode merge = phi.merge();
 635                 Block mergeBlock = currentNodeMap.get(merge);
 636                 for (int i = 0; i &lt; phi.valueCount(); ++i) {
 637                     if (phi.valueAt(i) == node) {
 638                         Block otherBlock = mergeBlock.getPredecessors()[i];
 639                         currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 640                     }
 641                 }
 642             } else if (usage instanceof AbstractBeginNode) {
 643                 AbstractBeginNode abstractBeginNode = (AbstractBeginNode) usage;
 644                 if (abstractBeginNode instanceof StartNode) {
 645                     currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, currentNodeMap.get(abstractBeginNode));
 646                 } else {
 647                     Block otherBlock = currentNodeMap.get(abstractBeginNode).getDominator();
 648                     currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 649                 }
 650             } else {
 651                 // All other types of usages: Put the input into the same block as the usage.
 652                 Block otherBlock = currentNodeMap.get(usage);
 653                 if (usage instanceof ProxyNode) {
 654                     ProxyNode proxyNode = (ProxyNode) usage;
 655                     otherBlock = currentNodeMap.get(proxyNode.proxyPoint());
 656 
 657                 }
 658                 currentBlock = AbstractControlFlowGraph.commonDominatorTyped(currentBlock, otherBlock);
 659             }
 660             return currentBlock;
 661         }
 662 
 663         /**
 664          * Micro block that is allocated for each fixed node and captures all floating nodes that
 665          * need to be scheduled immediately after the corresponding fixed node.
 666          */
 667         private static class MicroBlock {
 668             private final int id;
 669             private int nodeCount;
 670             private NodeEntry head;
 671             private NodeEntry tail;
 672 
 673             MicroBlock(int id) {
 674                 this.id = id;
 675             }
 676 
 677             /**
 678              * Adds a new floating node into the micro block.
 679              */
 680             public void add(Node node) {
 681                 assert !(node instanceof FixedNode) : node;
 682                 NodeEntry newTail = new NodeEntry(node);
 683                 if (tail == null) {
 684                     tail = head = newTail;
 685                 } else {
 686                     tail.next = newTail;
 687                     tail = newTail;
 688                 }
 689                 nodeCount++;
 690             }
 691 
 692             /**
 693              * Number of nodes in this micro block.
 694              */
 695             public int getNodeCount() {
 696                 assert getActualNodeCount() == nodeCount : getActualNodeCount() + &quot; != &quot; + nodeCount;
 697                 return nodeCount;
 698             }
 699 
 700             private int getActualNodeCount() {
 701                 int count = 0;
 702                 for (NodeEntry e = head; e != null; e = e.next) {
 703                     count++;
 704                 }
 705                 return count;
 706             }
 707 
 708             /**
 709              * The id of the micro block, with a block always associated with a lower id than its
 710              * successors.
 711              */
 712             public int getId() {
 713                 return id;
 714             }
 715 
 716             /**
 717              * First node of the linked list of nodes of this micro block.
 718              */
 719             public NodeEntry getFirstNode() {
 720                 return head;
 721             }
 722 
 723             /**
 724              * Takes all nodes in this micro blocks and prepends them to the nodes of the given
 725              * parameter.
 726              *
 727              * @param newBlock the new block for the nodes
 728              */
 729             public void prependChildrenTo(MicroBlock newBlock) {
 730                 if (tail != null) {
 731                     assert head != null;
 732                     tail.next = newBlock.head;
 733                     newBlock.head = head;
 734                     head = tail = null;
 735                     newBlock.nodeCount += nodeCount;
 736                     nodeCount = 0;
 737                 }
 738             }
 739 
 740             @Override
 741             public String toString() {
 742                 return String.format(&quot;MicroBlock[id=%d]&quot;, id);
 743             }
 744 
 745             @Override
 746             public int hashCode() {
 747                 return id;
 748             }
 749         }
 750 
 751         /**
 752          * Entry in the linked list of nodes.
 753          */
 754         private static class NodeEntry {
 755             private final Node node;
 756             private NodeEntry next;
 757 
 758             NodeEntry(Node node) {
 759                 this.node = node;
 760                 this.next = null;
 761             }
 762 
 763             public NodeEntry getNext() {
 764                 return next;
 765             }
 766 
 767             public Node getNode() {
 768                 return node;
 769             }
 770         }
 771 
 772         private void scheduleEarliestIterative(BlockMap&lt;List&lt;Node&gt;&gt; blockToNodes, NodeMap&lt;Block&gt; nodeToBlock, NodeBitMap visited, StructuredGraph graph, boolean immutableGraph,
 773                         boolean withGuardOrder) {
 774 
 775             NodeMap&lt;MicroBlock&gt; entries = graph.createNodeMap();
 776             NodeStack stack = new NodeStack();
 777 
 778             // Initialize with fixed nodes.
 779             MicroBlock startBlock = null;
 780             int nextId = 1;
 781             for (Block b : cfg.reversePostOrder()) {
 782                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 783                     MicroBlock microBlock = new MicroBlock(nextId++);
 784                     entries.set(current, microBlock);
 785                     boolean isNew = visited.checkAndMarkInc(current);
 786                     assert isNew;
 787                     if (startBlock == null) {
 788                         startBlock = microBlock;
 789                     }
 790                 }
 791             }
 792 
 793             if (graph.getGuardsStage().allowsFloatingGuards() &amp;&amp; graph.getNodes(GuardNode.TYPE).isNotEmpty()) {
 794                 // Now process guards.
 795                 if (GuardPriorities.getValue(graph.getOptions()) &amp;&amp; withGuardOrder) {
 796                     EnumMap&lt;GuardPriority, List&lt;GuardNode&gt;&gt; guardsByPriority = new EnumMap&lt;&gt;(GuardPriority.class);
 797                     for (GuardNode guard : graph.getNodes(GuardNode.TYPE)) {
 798                         guardsByPriority.computeIfAbsent(guard.computePriority(), p -&gt; new ArrayList&lt;&gt;()).add(guard);
 799                     }
 800                     // `EnumMap.values` returns values in &quot;natural&quot; key order
 801                     for (List&lt;GuardNode&gt; guards : guardsByPriority.values()) {
 802                         processNodes(visited, entries, stack, startBlock, guards);
 803                     }
 804                     GuardOrder.resortGuards(graph, entries, stack);
 805                 } else {
 806                     processNodes(visited, entries, stack, startBlock, graph.getNodes(GuardNode.TYPE));
 807                 }
 808             } else {
 809                 assert graph.getNodes(GuardNode.TYPE).isEmpty();
 810             }
 811 
 812             // Now process inputs of fixed nodes.
 813             for (Block b : cfg.reversePostOrder()) {
 814                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 815                     processNodes(visited, entries, stack, startBlock, current.inputs());
 816                 }
 817             }
 818 
 819             if (visited.getCounter() &lt; graph.getNodeCount()) {
 820                 // Visit back input edges of loop phis.
 821                 boolean changed;
 822                 boolean unmarkedPhi;
 823                 do {
 824                     changed = false;
 825                     unmarkedPhi = false;
 826                     for (LoopBeginNode loopBegin : graph.getNodes(LoopBeginNode.TYPE)) {
 827                         for (PhiNode phi : loopBegin.phis()) {
 828                             if (visited.isMarked(phi)) {
 829                                 for (int i = 0; i &lt; loopBegin.getLoopEndCount(); ++i) {
 830                                     Node node = phi.valueAt(i + loopBegin.forwardEndCount());
 831                                     if (node != null &amp;&amp; entries.get(node) == null) {
 832                                         changed = true;
 833                                         processStack(node, startBlock, entries, visited, stack);
 834                                     }
 835                                 }
 836                             } else {
 837                                 unmarkedPhi = true;
 838                             }
 839                         }
 840                     }
 841 
 842                     /*
 843                      * the processing of one loop phi could have marked a previously checked loop
 844                      * phi, therefore this needs to be iterative.
 845                      */
 846                 } while (unmarkedPhi &amp;&amp; changed);
 847             }
 848 
 849             // Check for dead nodes.
 850             if (!immutableGraph &amp;&amp; visited.getCounter() &lt; graph.getNodeCount()) {
 851                 for (Node n : graph.getNodes()) {
 852                     if (!visited.isMarked(n)) {
 853                         n.clearInputs();
 854                         n.markDeleted();
 855                     }
 856                 }
 857             }
 858 
 859             for (Block b : cfg.reversePostOrder()) {
 860                 FixedNode fixedNode = b.getEndNode();
 861                 if (fixedNode instanceof ControlSplitNode) {
 862                     ControlSplitNode controlSplitNode = (ControlSplitNode) fixedNode;
 863                     MicroBlock endBlock = entries.get(fixedNode);
 864                     AbstractBeginNode primarySuccessor = controlSplitNode.getPrimarySuccessor();
 865                     if (primarySuccessor != null) {
 866                         endBlock.prependChildrenTo(entries.get(primarySuccessor));
 867                     } else {
 868                         assert endBlock.tail == null;
 869                     }
 870                 }
 871             }
 872 
 873             // Create lists for each block
 874             for (Block b : cfg.reversePostOrder()) {
 875                 // Count nodes in block
 876                 int totalCount = 0;
 877                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 878                     MicroBlock microBlock = entries.get(current);
 879                     totalCount += microBlock.getNodeCount() + 1;
 880                 }
 881 
 882                 // Initialize with begin node, it is always the first node.
 883                 ArrayList&lt;Node&gt; nodes = new ArrayList&lt;&gt;(totalCount);
 884                 blockToNodes.put(b, nodes);
 885 
 886                 for (FixedNode current : b.getBeginNode().getBlockNodes()) {
 887                     MicroBlock microBlock = entries.get(current);
 888                     nodeToBlock.set(current, b);
 889                     nodes.add(current);
 890                     NodeEntry next = microBlock.getFirstNode();
 891                     while (next != null) {
 892                         Node nextNode = next.getNode();
 893                         nodeToBlock.set(nextNode, b);
 894                         nodes.add(nextNode);
 895                         next = next.getNext();
 896                     }
 897                 }
 898             }
 899 
 900             assert (!Assertions.detailedAssertionsEnabled(cfg.graph.getOptions())) || ScheduleVerification.check(cfg.getStartBlock(), blockToNodes, nodeToBlock);
 901         }
 902 
 903         private static void processNodes(NodeBitMap visited, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack, MicroBlock startBlock, Iterable&lt;? extends Node&gt; nodes) {
 904             for (Node node : nodes) {
 905                 if (entries.get(node) == null) {
 906                     processStack(node, startBlock, entries, visited, stack);
 907                 }
 908             }
 909         }
 910 
 911         private static void processStackPhi(NodeStack stack, PhiNode phiNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 912             stack.pop();
 913             if (visited.checkAndMarkInc(phiNode)) {
 914                 MicroBlock mergeBlock = nodeToBlock.get(phiNode.merge());
 915                 assert mergeBlock != null : phiNode;
 916                 nodeToBlock.set(phiNode, mergeBlock);
 917                 AbstractMergeNode merge = phiNode.merge();
 918                 for (int i = 0; i &lt; merge.forwardEndCount(); ++i) {
 919                     Node input = phiNode.valueAt(i);
 920                     if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
 921                         stack.push(input);
 922                     }
 923                 }
 924             }
 925         }
 926 
 927         private static void processStackProxy(NodeStack stack, ProxyNode proxyNode, NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeBitMap visited) {
 928             stack.pop();
 929             if (visited.checkAndMarkInc(proxyNode)) {
 930                 nodeToBlock.set(proxyNode, nodeToBlock.get(proxyNode.proxyPoint()));
 931                 Node input = proxyNode.value();
 932                 if (input != null &amp;&amp; nodeToBlock.get(input) == null) {
 933                     stack.push(input);
 934                 }
 935             }
 936         }
 937 
 938         private static void processStack(Node first, MicroBlock startBlock, NodeMap&lt;MicroBlock&gt; nodeToMicroBlock, NodeBitMap visited, NodeStack stack) {
 939             assert stack.isEmpty();
 940             assert !visited.isMarked(first);
 941             stack.push(first);
 942             Node current = first;
 943             while (true) {
 944                 if (current instanceof PhiNode) {
 945                     processStackPhi(stack, (PhiNode) current, nodeToMicroBlock, visited);
 946                 } else if (current instanceof ProxyNode) {
 947                     processStackProxy(stack, (ProxyNode) current, nodeToMicroBlock, visited);
 948                 } else {
 949                     MicroBlock currentBlock = nodeToMicroBlock.get(current);
 950                     if (currentBlock == null) {
 951                         MicroBlock earliestBlock = processInputs(nodeToMicroBlock, stack, startBlock, current);
 952                         if (earliestBlock == null) {
 953                             // We need to delay until inputs are processed.
 954                         } else {
 955                             // Can immediately process and pop.
 956                             stack.pop();
 957                             visited.checkAndMarkInc(current);
 958                             nodeToMicroBlock.set(current, earliestBlock);
 959                             earliestBlock.add(current);
 960                         }
 961                     } else {
 962                         stack.pop();
 963                     }
 964                 }
 965 
 966                 if (stack.isEmpty()) {
 967                     break;
 968                 }
 969                 current = stack.peek();
 970             }
 971         }
 972 
 973         private static class GuardOrder {
 974             /**
 975              * After an earliest schedule, this will re-sort guards to honor their
 976              * {@linkplain StaticDeoptimizingNode#computePriority() priority}.
 977              *
 978              * Note that this only changes the order of nodes within {@linkplain MicroBlock
 979              * micro-blocks}, nodes will not be moved from one micro-block to another.
 980              */
 981             private static void resortGuards(StructuredGraph graph, NodeMap&lt;MicroBlock&gt; entries, NodeStack stack) {
 982                 assert stack.isEmpty();
 983                 EconomicSet&lt;MicroBlock&gt; blocksWithGuards = EconomicSet.create(IDENTITY);
 984                 for (GuardNode guard : graph.getNodes(GuardNode.TYPE)) {
 985                     MicroBlock block = entries.get(guard);
 986                     assert block != null : guard + &quot;should already be scheduled to a micro-block&quot;;
 987                     blocksWithGuards.add(block);
 988                 }
 989                 assert !blocksWithGuards.isEmpty();
 990                 NodeMap&lt;GuardPriority&gt; priorities = graph.createNodeMap();
 991                 NodeBitMap blockNodes = graph.createNodeBitMap();
 992                 for (MicroBlock block : blocksWithGuards) {
 993                     MicroBlock newBlock = resortGuards(block, stack, blockNodes, priorities);
 994                     assert stack.isEmpty();
 995                     assert blockNodes.isEmpty();
 996                     if (newBlock != null) {
 997                         assert block.getNodeCount() == newBlock.getNodeCount();
 998                         block.head = newBlock.head;
 999                         block.tail = newBlock.tail;
1000                     }
1001                 }
1002             }
1003 
1004             /**
1005              * This resorts guards within one micro-block.
1006              *
1007              * {@code stack}, {@code blockNodes} and {@code priorities} are just temporary
1008              * data-structures which are allocated once by the callers of this method. They should
1009              * be in their &quot;initial&quot;/&quot;empty&quot; state when calling this method and when it returns.
1010              */
1011             private static MicroBlock resortGuards(MicroBlock block, NodeStack stack, NodeBitMap blockNodes, NodeMap&lt;GuardPriority&gt; priorities) {
1012                 if (!propagatePriority(block, stack, priorities, blockNodes)) {
1013                     return null;
1014                 }
1015 
1016                 Function&lt;GuardNode, GuardPriority&gt; transitiveGuardPriorityGetter = priorities::get;
1017                 Comparator&lt;GuardNode&gt; globalGuardPriorityComparator = Comparator.comparing(transitiveGuardPriorityGetter).thenComparing(GuardNode::computePriority).thenComparingInt(Node::hashCode);
1018 
1019                 SortedSet&lt;GuardNode&gt; availableGuards = new TreeSet&lt;&gt;(globalGuardPriorityComparator);
1020                 MicroBlock newBlock = new MicroBlock(block.getId());
1021 
1022                 NodeBitMap sorted = blockNodes;
1023                 sorted.invert();
1024 
1025                 for (NodeEntry e = block.head; e != null; e = e.next) {
1026                     checkIfAvailable(e.node, stack, sorted, newBlock, availableGuards, false);
1027                 }
1028                 do {
1029                     while (!stack.isEmpty()) {
1030                         checkIfAvailable(stack.pop(), stack, sorted, newBlock, availableGuards, true);
1031                     }
1032                     Iterator&lt;GuardNode&gt; iterator = availableGuards.iterator();
1033                     if (iterator.hasNext()) {
1034                         addNodeToResort(iterator.next(), stack, sorted, newBlock, true);
1035                         iterator.remove();
1036                     }
1037                 } while (!stack.isEmpty() || !availableGuards.isEmpty());
1038 
1039                 blockNodes.clearAll();
1040                 return newBlock;
1041             }
1042 
1043             /**
1044              * This checks if {@code n} can be scheduled, if it is the case, it schedules it now by
1045              * calling {@link #addNodeToResort(Node, NodeStack, NodeBitMap, MicroBlock, boolean)}.
1046              */
1047             private static void checkIfAvailable(Node n, NodeStack stack, NodeBitMap sorted, Instance.MicroBlock newBlock, SortedSet&lt;GuardNode&gt; availableGuardNodes, boolean pushUsages) {
1048                 if (sorted.isMarked(n)) {
1049                     return;
1050                 }
1051                 for (Node in : n.inputs()) {
1052                     if (!sorted.isMarked(in)) {
1053                         return;
1054                     }
1055                 }
1056                 if (n instanceof GuardNode) {
1057                     availableGuardNodes.add((GuardNode) n);
1058                 } else {
1059                     addNodeToResort(n, stack, sorted, newBlock, pushUsages);
1060                 }
1061             }
1062 
1063             /**
1064              * Add a node to the re-sorted micro-block. This also pushes nodes that need to be
1065              * (re-)examined on the stack.
1066              */
1067             private static void addNodeToResort(Node n, NodeStack stack, NodeBitMap sorted, MicroBlock newBlock, boolean pushUsages) {
1068                 sorted.mark(n);
1069                 newBlock.add(n);
1070                 if (pushUsages) {
1071                     for (Node u : n.usages()) {
1072                         if (!sorted.isMarked(u)) {
1073                             stack.push(u);
1074                         }
1075                     }
1076                 }
1077             }
1078 
1079             /**
1080              * This fills in a map of transitive priorities ({@code priorities}). It also marks the
1081              * nodes from this micro-block in {@code blockNodes}.
1082              *
1083              * The transitive priority of a guard is the highest of its priority and the priority of
1084              * the guards that depend on it (transitively).
1085              *
1086              * This method returns {@code false} if no re-ordering is necessary in this micro-block.
1087              */
1088             private static boolean propagatePriority(MicroBlock block, NodeStack stack, NodeMap&lt;GuardPriority&gt; priorities, NodeBitMap blockNodes) {
1089                 assert stack.isEmpty();
1090                 assert blockNodes.isEmpty();
1091                 GuardPriority lowestPriority = GuardPriority.highest();
1092                 for (NodeEntry e = block.head; e != null; e = e.next) {
1093                     blockNodes.mark(e.node);
1094                     if (e.node instanceof GuardNode) {
1095                         GuardNode guard = (GuardNode) e.node;
1096                         GuardPriority priority = guard.computePriority();
1097                         if (lowestPriority != null) {
1098                             if (priority.isLowerPriorityThan(lowestPriority)) {
1099                                 lowestPriority = priority;
1100                             } else if (priority.isHigherPriorityThan(lowestPriority)) {
1101                                 lowestPriority = null;
1102                             }
1103                         }
1104                         stack.push(guard);
1105                         priorities.set(guard, priority);
1106                     }
1107                 }
1108                 if (lowestPriority != null) {
1109                     stack.clear();
1110                     blockNodes.clearAll();
1111                     return false;
1112                 }
1113 
1114                 do {
1115                     Node current = stack.pop();
1116                     assert blockNodes.isMarked(current);
1117                     GuardPriority priority = priorities.get(current);
1118                     for (Node input : current.inputs()) {
1119                         if (!blockNodes.isMarked(input)) {
1120                             continue;
1121                         }
1122                         GuardPriority inputPriority = priorities.get(input);
1123                         if (inputPriority == null || inputPriority.isLowerPriorityThan(priority)) {
1124                             priorities.set(input, priority);
1125                             stack.push(input);
1126                         }
1127                     }
1128                 } while (!stack.isEmpty());
1129                 return true;
1130             }
1131         }
1132 
1133         /**
1134          * Processes the inputs of given block. Pushes unprocessed inputs onto the stack. Returns
1135          * null if there were still unprocessed inputs, otherwise returns the earliest block given
1136          * node can be scheduled in.
1137          */
1138         private static MicroBlock processInputs(NodeMap&lt;MicroBlock&gt; nodeToBlock, NodeStack stack, MicroBlock startBlock, Node current) {
1139             if (current.getNodeClass().isLeafNode()) {
1140                 return startBlock;
1141             }
1142 
1143             MicroBlock earliestBlock = startBlock;
1144             for (Node input : current.inputs()) {
1145                 MicroBlock inputBlock = nodeToBlock.get(input);
1146                 if (inputBlock == null) {
1147                     earliestBlock = null;
1148                     stack.push(input);
1149                 } else if (earliestBlock != null &amp;&amp; inputBlock.getId() &gt; earliestBlock.getId()) {
1150                     earliestBlock = inputBlock;
1151                 }
1152             }
1153             return earliestBlock;
1154         }
1155 
1156         private static boolean isFixedEnd(FixedNode endNode) {
1157             return endNode instanceof ControlSplitNode || endNode instanceof ControlSinkNode || endNode instanceof AbstractEndNode;
1158         }
1159 
1160         public String printScheduleHelper(String desc) {
1161             Formatter buf = new Formatter();
1162             buf.format(&quot;=== %s / %s ===%n&quot;, getCFG().getStartBlock().getBeginNode().graph(), desc);
1163             for (Block b : getCFG().getBlocks()) {
1164                 buf.format(&quot;==== b: %s (loopDepth: %s). &quot;, b, b.getLoopDepth());
1165                 buf.format(&quot;dom: %s. &quot;, b.getDominator());
1166                 buf.format(&quot;preds: %s. &quot;, Arrays.toString(b.getPredecessors()));
1167                 buf.format(&quot;succs: %s ====%n&quot;, Arrays.toString(b.getSuccessors()));
1168 
1169                 if (blockToNodesMap.get(b) != null) {
1170                     for (Node n : nodesFor(b)) {
1171                         printNode(n);
1172                     }
1173                 } else {
1174                     for (Node n : b.getNodes()) {
1175                         printNode(n);
1176                     }
1177                 }
1178             }
1179             buf.format(&quot;%n&quot;);
1180             return buf.toString();
1181         }
1182 
1183         private static void printNode(Node n) {
1184             Formatter buf = new Formatter();
1185             buf.format(&quot;%s&quot;, n);
<a name="7" id="anc7"></a><span class="line-modified">1186             if (n instanceof MemoryCheckpoint.Single) {</span>
<span class="line-modified">1187                 buf.format(&quot; // kills %s&quot;, ((MemoryCheckpoint.Single) n).getKilledLocationIdentity());</span>
<span class="line-modified">1188             } else if (n instanceof MemoryCheckpoint.Multi) {</span>
1189                 buf.format(&quot; // kills &quot;);
<a name="8" id="anc8"></a><span class="line-modified">1190                 for (LocationIdentity locid : ((MemoryCheckpoint.Multi) n).getKilledLocationIdentities()) {</span>
1191                     buf.format(&quot;%s, &quot;, locid);
1192                 }
1193             } else if (n instanceof FloatingReadNode) {
1194                 FloatingReadNode frn = (FloatingReadNode) n;
1195                 buf.format(&quot; // from %s&quot;, frn.getLocationIdentity());
1196                 buf.format(&quot;, lastAccess: %s&quot;, frn.getLastLocationAccess());
1197                 buf.format(&quot;, address: %s&quot;, frn.getAddress());
1198             } else if (n instanceof GuardNode) {
1199                 buf.format(&quot;, anchor: %s&quot;, ((GuardNode) n).getAnchor());
1200             }
1201             n.getDebug().log(&quot;%s&quot;, buf);
1202         }
1203 
1204         public ControlFlowGraph getCFG() {
1205             return cfg;
1206         }
1207 
1208         /**
1209          * Gets the nodes in a given block.
1210          */
1211         public List&lt;Node&gt; nodesFor(Block block) {
1212             return blockToNodesMap.get(block);
1213         }
1214     }
1215 
1216 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
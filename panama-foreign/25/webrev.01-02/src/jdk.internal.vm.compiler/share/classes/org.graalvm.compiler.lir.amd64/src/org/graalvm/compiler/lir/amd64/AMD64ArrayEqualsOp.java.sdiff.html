<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArrayCompareToOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.lir.amd64/src/org/graalvm/compiler/lir/amd64/AMD64ArrayEqualsOp.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
241      */
242     private void emitVectorCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
243                     Register result, Register array1, Register array2, Register length,
244                     Label trueLabel, Label falseLabel) {
245         assert supportsSSE41(crb.target);
246 
247         Register vector1 = asRegister(vectorTemp1);
248         Register vector2 = asRegister(vectorTemp2);
249 
250         int elementsPerVector = getElementsPerVector(vectorSize);
251 
252         Label loop = new Label();
253         Label compareTail = new Label();
254 
255         boolean requiresNaNCheck = kind1.isNumericFloat();
256         Label loopCheck = new Label();
257         Label nanCheck = new Label();
258 
259         // Compare 16-byte vectors
260         masm.andl(result, elementsPerVector - 1); // tail count
<span class="line-modified">261         masm.andl(length, ~(elementsPerVector - 1)); // vector count</span>
<span class="line-removed">262         masm.jcc(ConditionFlag.Zero, compareTail);</span>
263 
264         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
265         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
266         masm.negq(length);
267 
268         // Align the main loop
269         masm.align(crb.target.wordSize * 2);
270         masm.bind(loop);
271         emitVectorLoad1(masm, vector1, array1, length, 0, vectorSize);
272         emitVectorLoad2(masm, vector2, array2, length, 0, vectorSize);
273         emitVectorCmp(masm, vector1, vector2, vectorSize);
274         masm.jcc(ConditionFlag.NotZero, requiresNaNCheck ? nanCheck : falseLabel);
275 
276         masm.bind(loopCheck);
<span class="line-modified">277         masm.addq(length, elementsPerVector);</span>
<span class="line-removed">278         masm.jcc(ConditionFlag.NotZero, loop);</span>
279 
<span class="line-modified">280         masm.testl(result, result);</span>
<span class="line-removed">281         masm.jcc(ConditionFlag.Zero, trueLabel);</span>
282 
283         if (requiresNaNCheck) {
284             Label unalignedCheck = new Label();
285             masm.jmpb(unalignedCheck);
286             masm.bind(nanCheck);
287             emitFloatCompareWithinRange(crb, masm, array1, array2, length, 0, falseLabel, elementsPerVector);
288             masm.jmpb(loopCheck);
289             masm.bind(unalignedCheck);
290         }
291 
292         /*
293          * Compare the remaining bytes with an unaligned memory load aligned to the end of the
294          * array.
295          */
296         emitVectorLoad1(masm, vector1, array1, result, scaleDisplacement1(-vectorSize.getBytes()), vectorSize);
297         emitVectorLoad2(masm, vector2, array2, result, scaleDisplacement2(-vectorSize.getBytes()), vectorSize);
298         emitVectorCmp(masm, vector1, vector2, vectorSize);
299         if (requiresNaNCheck) {
300             masm.jcc(ConditionFlag.Zero, trueLabel);
301             emitFloatCompareWithinRange(crb, masm, array1, array2, result, -vectorSize.getBytes(), falseLabel, elementsPerVector);
</pre>
<hr />
<pre>
469     private static final int VECTOR_SIZE = 8;
470 
471     /**
472      * Emits code that uses 8-byte vector compares.
473      */
474     private void emit8ByteCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
475                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
476         assert kind1 == kind2;
477         Label loop = new Label();
478         Label compareTail = new Label();
479 
480         int elementsPerVector = 8 &gt;&gt; arrayIndexScale1.log2;
481 
482         boolean requiresNaNCheck = kind1.isNumericFloat();
483         Label loopCheck = new Label();
484         Label nanCheck = new Label();
485 
486         Register temp = asRegister(temp4);
487 
488         masm.andl(result, elementsPerVector - 1); // tail count
<span class="line-modified">489         masm.andl(length, ~(elementsPerVector - 1));  // vector count</span>
<span class="line-removed">490         masm.jcc(ConditionFlag.Zero, compareTail);</span>
491 
492         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
493         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
494         masm.negq(length);
495 
496         // Align the main loop
497         masm.align(crb.target.wordSize * 2);
498         masm.bind(loop);
499         masm.movq(temp, new AMD64Address(array1, length, arrayIndexScale1, 0));
<span class="line-modified">500         masm.cmpq(temp, new AMD64Address(array2, length, arrayIndexScale2, 0));</span>
<span class="line-removed">501         masm.jcc(ConditionFlag.NotEqual, requiresNaNCheck ? nanCheck : falseLabel);</span>
502 
503         masm.bind(loopCheck);
<span class="line-modified">504         masm.addq(length, elementsPerVector);</span>
<span class="line-removed">505         masm.jccb(ConditionFlag.NotZero, loop);</span>
506 
<span class="line-modified">507         masm.testl(result, result);</span>
<span class="line-removed">508         masm.jcc(ConditionFlag.Zero, trueLabel);</span>
509 
510         if (requiresNaNCheck) {
511             // NaN check is slow path and hence placed outside of the main loop.
512             Label unalignedCheck = new Label();
513             masm.jmpb(unalignedCheck);
514             masm.bind(nanCheck);
515             // At most two iterations, unroll in the emitted code.
516             for (int offset = 0; offset &lt; VECTOR_SIZE; offset += kind1.getByteCount()) {
517                 emitFloatCompare(masm, array1, array2, length, offset, falseLabel, kind1.getByteCount() == VECTOR_SIZE);
518             }
519             masm.jmpb(loopCheck);
520             masm.bind(unalignedCheck);
521         }
522 
523         /*
524          * Compare the remaining bytes with an unaligned memory load aligned to the end of the
525          * array.
526          */
527         masm.movq(temp, new AMD64Address(array1, result, arrayIndexScale1, -VECTOR_SIZE));
<span class="line-removed">528         masm.cmpq(temp, new AMD64Address(array2, result, arrayIndexScale2, -VECTOR_SIZE));</span>
529         if (requiresNaNCheck) {
<span class="line-modified">530             masm.jcc(ConditionFlag.Equal, trueLabel);</span>
531             // At most two iterations, unroll in the emitted code.
532             for (int offset = 0; offset &lt; VECTOR_SIZE; offset += kind1.getByteCount()) {
533                 emitFloatCompare(masm, array1, array2, result, -VECTOR_SIZE + offset, falseLabel, kind1.getByteCount() == VECTOR_SIZE);
534             }
535         } else {
<span class="line-modified">536             masm.jccb(ConditionFlag.NotEqual, falseLabel);</span>
537         }
538         masm.jmpb(trueLabel);
539 
540         masm.bind(compareTail);
541         masm.movl(length, result);
542     }
543 
544     /**
545      * Emits code to compare the remaining 1 to 4 bytes.
546      */
547     private void emitTailCompares(AMD64MacroAssembler masm,
548                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
549         assert kind1 == kind2;
550         Label compare2Bytes = new Label();
551         Label compare1Byte = new Label();
552 
553         Register temp = asRegister(temp4);
554 
555         if (kind1.getByteCount() &lt;= 4) {
556             // Compare trailing 4 bytes, if any.
<span class="line-modified">557             masm.testl(result, arrayIndexScale1.log2 == 0 ? 4 : 4 &gt;&gt; arrayIndexScale1.log2);</span>
<span class="line-removed">558             masm.jccb(ConditionFlag.Zero, compare2Bytes);</span>
559             masm.movl(temp, new AMD64Address(array1, 0));
<span class="line-removed">560             masm.cmpl(temp, new AMD64Address(array2, 0));</span>
561             if (kind1 == JavaKind.Float) {
<span class="line-modified">562                 masm.jccb(ConditionFlag.Equal, trueLabel);</span>
563                 emitFloatCompare(masm, array1, array2, Register.None, 0, falseLabel, true);
564                 masm.jmpb(trueLabel);
565             } else {
<span class="line-modified">566                 masm.jccb(ConditionFlag.NotEqual, falseLabel);</span>
567             }
568             if (kind1.getByteCount() &lt;= 2) {
569                 // Move array pointers forward.
570                 masm.leaq(array1, new AMD64Address(array1, 4));
571                 masm.leaq(array2, new AMD64Address(array2, 4));
572 
573                 // Compare trailing 2 bytes, if any.
574                 masm.bind(compare2Bytes);
<span class="line-modified">575                 masm.testl(result, arrayIndexScale1.log2 == 0 ? 2 : 2 &gt;&gt; arrayIndexScale1.log2);</span>
<span class="line-removed">576                 masm.jccb(ConditionFlag.Zero, compare1Byte);</span>
577                 masm.movzwl(temp, new AMD64Address(array1, 0));
578                 masm.movzwl(length, new AMD64Address(array2, 0));
<span class="line-modified">579                 masm.cmpl(temp, length);</span>
<span class="line-removed">580                 masm.jccb(ConditionFlag.NotEqual, falseLabel);</span>
581 
582                 // The one-byte tail compare is only required for boolean and byte arrays.
583                 if (kind1.getByteCount() &lt;= 1) {
584                     // Move array pointers forward before we compare the last trailing byte.
585                     masm.leaq(array1, new AMD64Address(array1, 2));
586                     masm.leaq(array2, new AMD64Address(array2, 2));
587 
588                     // Compare trailing byte, if any.

589                     masm.bind(compare1Byte);
<span class="line-modified">590                     masm.testl(result, 1);</span>
<span class="line-removed">591                     masm.jccb(ConditionFlag.Zero, trueLabel);</span>
592                     masm.movzbl(temp, new AMD64Address(array1, 0));
593                     masm.movzbl(length, new AMD64Address(array2, 0));
<span class="line-modified">594                     masm.cmpl(temp, length);</span>
<span class="line-removed">595                     masm.jccb(ConditionFlag.NotEqual, falseLabel);</span>
596                 } else {
597                     masm.bind(compare1Byte);
598                 }
599             } else {
600                 masm.bind(compare2Bytes);
601             }
602         }
603     }
604 
605     private void emitDifferentKindsElementWiseCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
606                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
607         assert kind1 != kind2;
608         assert kind1.isNumericInteger() &amp;&amp; kind2.isNumericInteger();
609         Label loop = new Label();
610         Label compareTail = new Label();
611 
612         int elementsPerLoopIteration = 4;
613 
614         Register tmp1 = asRegister(temp4);
615         Register tmp2 = asRegister(temp5);
616 
617         masm.andl(result, elementsPerLoopIteration - 1); // tail count
<span class="line-modified">618         masm.andl(length, ~(elementsPerLoopIteration - 1));  // bulk loop count</span>
<span class="line-removed">619         masm.jcc(ConditionFlag.Zero, compareTail);</span>
620 
621         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
622         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
623         masm.negq(length);
624 
625         // clear comparison registers because of the missing movzlq instruction
626         masm.xorq(tmp1, tmp1);
627         masm.xorq(tmp2, tmp2);
628 
629         // Align the main loop
630         masm.align(crb.target.wordSize * 2);
631         masm.bind(loop);
632         for (int i = 0; i &lt; elementsPerLoopIteration; i++) {
633             emitMovBytes(masm, tmp1, new AMD64Address(array1, length, arrayIndexScale1, i &lt;&lt; arrayIndexScale1.log2), kind1.getByteCount());
634             emitMovBytes(masm, tmp2, new AMD64Address(array2, length, arrayIndexScale2, i &lt;&lt; arrayIndexScale2.log2), kind2.getByteCount());
<span class="line-modified">635             masm.cmpq(tmp1, tmp2);</span>
<span class="line-removed">636             masm.jcc(ConditionFlag.NotEqual, falseLabel);</span>
637         }
<span class="line-modified">638         masm.addq(length, elementsPerLoopIteration);</span>
<span class="line-removed">639         masm.jccb(ConditionFlag.NotZero, loop);</span>
640 
641         masm.bind(compareTail);
<span class="line-modified">642         masm.testl(result, result);</span>
<span class="line-removed">643         masm.jcc(ConditionFlag.Zero, trueLabel);</span>
644         for (int i = 0; i &lt; elementsPerLoopIteration - 1; i++) {
645             emitMovBytes(masm, tmp1, new AMD64Address(array1, length, arrayIndexScale1, 0), kind1.getByteCount());
646             emitMovBytes(masm, tmp2, new AMD64Address(array2, length, arrayIndexScale2, 0), kind2.getByteCount());
<span class="line-modified">647             masm.cmpq(tmp1, tmp2);</span>
<span class="line-removed">648             masm.jcc(ConditionFlag.NotEqual, falseLabel);</span>
649             if (i &lt; elementsPerLoopIteration - 2) {
650                 masm.incrementq(length, 1);
<span class="line-modified">651                 masm.decrementq(result, 1);</span>
<span class="line-removed">652                 masm.jcc(ConditionFlag.Zero, trueLabel);</span>
653             } else {
654                 masm.jmpb(trueLabel);
655             }
656         }
657     }
658 
659     /**
660      * Emits code to fall through if {@code src} is NaN, otherwise jump to {@code branchOrdered}.
661      */
662     private void emitNaNCheck(AMD64MacroAssembler masm, AMD64Address src, Label branchIfNonNaN) {
663         assert kind1.isNumericFloat();
664         Register tempXMMReg = asRegister(tempXMM);
665         if (kind1 == JavaKind.Float) {
666             masm.movflt(tempXMMReg, src);
667         } else {
668             masm.movdbl(tempXMMReg, src);
669         }
670         SSEOp.UCOMIS.emit(masm, kind1 == JavaKind.Float ? OperandSize.PS : OperandSize.PD, tempXMMReg, tempXMMReg);
671         masm.jcc(ConditionFlag.NoParity, branchIfNonNaN);
672     }
673 
674     /**
675      * Emits code to compare if two floats are bitwise equal or both NaN.
676      */
677     private void emitFloatCompare(AMD64MacroAssembler masm, Register base1, Register base2, Register index, int offset, Label falseLabel,
678                     boolean skipBitwiseCompare) {
679         AMD64Address address1 = new AMD64Address(base1, index, arrayIndexScale1, offset);
680         AMD64Address address2 = new AMD64Address(base2, index, arrayIndexScale2, offset);
681 
682         Label bitwiseEqual = new Label();
683 
684         if (!skipBitwiseCompare) {
685             // Bitwise compare
686             Register temp = asRegister(temp4);
687 
688             if (kind1 == JavaKind.Float) {
689                 masm.movl(temp, address1);
<span class="line-modified">690                 masm.cmpl(temp, address2);</span>
691             } else {
692                 masm.movq(temp, address1);
<span class="line-modified">693                 masm.cmpq(temp, address2);</span>
694             }
<span class="line-removed">695             masm.jccb(ConditionFlag.Equal, bitwiseEqual);</span>
696         }
697 
698         emitNaNCheck(masm, address1, falseLabel);
699         emitNaNCheck(masm, address2, falseLabel);
700 
701         masm.bind(bitwiseEqual);
702     }
703 
704     /**
705      * Emits code to compare float equality within a range.
706      */
707     private void emitFloatCompareWithinRange(CompilationResultBuilder crb, AMD64MacroAssembler masm,
708                     Register base1, Register base2, Register index, int offset, Label falseLabel, int range) {
709         assert kind1.isNumericFloat();
710         Label loop = new Label();
711         Register i = asRegister(temp5);
712 
713         masm.movq(i, range);
714         masm.negq(i);
715         // Align the main loop
716         masm.align(crb.target.wordSize * 2);
717         masm.bind(loop);
718         emitFloatCompare(masm, base1, base2, index, offset, falseLabel, range == 1);
719         masm.incrementq(index, 1);
<span class="line-modified">720         masm.incrementq(i, 1);</span>
<span class="line-removed">721         masm.jccb(ConditionFlag.NotZero, loop);</span>
722         // Floats within the range are equal, revert change to the register index
723         masm.subq(index, range);
724     }
725 
726     private boolean constantLengthCompareNeedsTmpArrayPointers() {
727         AVXKind.AVXSize vSize = vectorSize;
728         if (constantLength() &lt; getElementsPerVector(vectorSize)) {
729             vSize = AVXKind.AVXSize.XMM;
730         }
731         int vectorCount = constantLength() &amp; ~(2 * getElementsPerVector(vSize) - 1);
732         return vectorCount &gt; 0;
733     }
734 
735     /**
736      * Emits specialized assembly for checking equality of memory regions
737      * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
738      * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
739      */
740     private void emitConstantLengthArrayCompareBytes(
741                     CompilationResultBuilder crb,
</pre>
<hr />
<pre>
776                 Label loopBegin = new Label();
777                 Register tmpArrayPtr1 = asRegister(temp1);
778                 Register tmpArrayPtr2 = asRegister(temp2);
779                 asm.leaq(tmpArrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));
780                 asm.leaq(tmpArrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));
781                 arrayPtr1 = tmpArrayPtr1;
782                 arrayPtr2 = tmpArrayPtr2;
783                 asm.movq(tmp, -vectorCount);
784                 asm.align(crb.target.wordSize * 2);
785                 asm.bind(loopBegin);
786                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp, arrayBaseOffset1, vSize);
787                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp, arrayBaseOffset2, vSize);
788                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp, arrayBaseOffset1 + scaleDisplacement1(bytesPerVector), vSize);
789                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp, arrayBaseOffset2 + scaleDisplacement2(bytesPerVector), vSize);
790                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
791                 emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
792                 emitVectorTest(asm, tmpVectors[0], vSize);
793                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
794                 emitVectorTest(asm, tmpVectors[2], vSize);
795                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
<span class="line-modified">796                 asm.addq(tmp, elementsPerVectorLoop);</span>
<span class="line-removed">797                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, loopBegin);</span>
798             }
799             if (tailCount &gt; 0) {
800                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, arrayBaseOffset1 + (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);
801                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, arrayBaseOffset2 + (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);
802                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
803                 if (tailCount &gt; elementsPerVector) {
804                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, arrayBaseOffset1, vSize);
805                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, arrayBaseOffset2, vSize);
806                     emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
807                     emitVectorTest(asm, tmpVectors[2], vSize);
808                     asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
809                 }
810                 emitVectorTest(asm, tmpVectors[0], vSize);
811                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
812             }
813         }
814     }
815 
816     private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
817         switch (size) {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
241      */
242     private void emitVectorCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
243                     Register result, Register array1, Register array2, Register length,
244                     Label trueLabel, Label falseLabel) {
245         assert supportsSSE41(crb.target);
246 
247         Register vector1 = asRegister(vectorTemp1);
248         Register vector2 = asRegister(vectorTemp2);
249 
250         int elementsPerVector = getElementsPerVector(vectorSize);
251 
252         Label loop = new Label();
253         Label compareTail = new Label();
254 
255         boolean requiresNaNCheck = kind1.isNumericFloat();
256         Label loopCheck = new Label();
257         Label nanCheck = new Label();
258 
259         // Compare 16-byte vectors
260         masm.andl(result, elementsPerVector - 1); // tail count
<span class="line-modified">261         masm.andlAndJcc(length, ~(elementsPerVector - 1), ConditionFlag.Zero, compareTail, false);</span>

262 
263         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
264         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
265         masm.negq(length);
266 
267         // Align the main loop
268         masm.align(crb.target.wordSize * 2);
269         masm.bind(loop);
270         emitVectorLoad1(masm, vector1, array1, length, 0, vectorSize);
271         emitVectorLoad2(masm, vector2, array2, length, 0, vectorSize);
272         emitVectorCmp(masm, vector1, vector2, vectorSize);
273         masm.jcc(ConditionFlag.NotZero, requiresNaNCheck ? nanCheck : falseLabel);
274 
275         masm.bind(loopCheck);
<span class="line-modified">276         masm.addqAndJcc(length, elementsPerVector, ConditionFlag.NotZero, loop, false);</span>

277 
<span class="line-modified">278         masm.testlAndJcc(result, result, ConditionFlag.Zero, trueLabel, false);</span>

279 
280         if (requiresNaNCheck) {
281             Label unalignedCheck = new Label();
282             masm.jmpb(unalignedCheck);
283             masm.bind(nanCheck);
284             emitFloatCompareWithinRange(crb, masm, array1, array2, length, 0, falseLabel, elementsPerVector);
285             masm.jmpb(loopCheck);
286             masm.bind(unalignedCheck);
287         }
288 
289         /*
290          * Compare the remaining bytes with an unaligned memory load aligned to the end of the
291          * array.
292          */
293         emitVectorLoad1(masm, vector1, array1, result, scaleDisplacement1(-vectorSize.getBytes()), vectorSize);
294         emitVectorLoad2(masm, vector2, array2, result, scaleDisplacement2(-vectorSize.getBytes()), vectorSize);
295         emitVectorCmp(masm, vector1, vector2, vectorSize);
296         if (requiresNaNCheck) {
297             masm.jcc(ConditionFlag.Zero, trueLabel);
298             emitFloatCompareWithinRange(crb, masm, array1, array2, result, -vectorSize.getBytes(), falseLabel, elementsPerVector);
</pre>
<hr />
<pre>
466     private static final int VECTOR_SIZE = 8;
467 
468     /**
469      * Emits code that uses 8-byte vector compares.
470      */
471     private void emit8ByteCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
472                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
473         assert kind1 == kind2;
474         Label loop = new Label();
475         Label compareTail = new Label();
476 
477         int elementsPerVector = 8 &gt;&gt; arrayIndexScale1.log2;
478 
479         boolean requiresNaNCheck = kind1.isNumericFloat();
480         Label loopCheck = new Label();
481         Label nanCheck = new Label();
482 
483         Register temp = asRegister(temp4);
484 
485         masm.andl(result, elementsPerVector - 1); // tail count
<span class="line-modified">486         masm.andlAndJcc(length, ~(elementsPerVector - 1), ConditionFlag.Zero, compareTail, false);</span>

487 
488         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
489         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
490         masm.negq(length);
491 
492         // Align the main loop
493         masm.align(crb.target.wordSize * 2);
494         masm.bind(loop);
495         masm.movq(temp, new AMD64Address(array1, length, arrayIndexScale1, 0));
<span class="line-modified">496         masm.cmpqAndJcc(temp, new AMD64Address(array2, length, arrayIndexScale2, 0), ConditionFlag.NotEqual, requiresNaNCheck ? nanCheck : falseLabel, false);</span>

497 
498         masm.bind(loopCheck);
<span class="line-modified">499         masm.addqAndJcc(length, elementsPerVector, ConditionFlag.NotZero, loop, true);</span>

500 
<span class="line-modified">501         masm.testlAndJcc(result, result, ConditionFlag.Zero, trueLabel, false);</span>

502 
503         if (requiresNaNCheck) {
504             // NaN check is slow path and hence placed outside of the main loop.
505             Label unalignedCheck = new Label();
506             masm.jmpb(unalignedCheck);
507             masm.bind(nanCheck);
508             // At most two iterations, unroll in the emitted code.
509             for (int offset = 0; offset &lt; VECTOR_SIZE; offset += kind1.getByteCount()) {
510                 emitFloatCompare(masm, array1, array2, length, offset, falseLabel, kind1.getByteCount() == VECTOR_SIZE);
511             }
512             masm.jmpb(loopCheck);
513             masm.bind(unalignedCheck);
514         }
515 
516         /*
517          * Compare the remaining bytes with an unaligned memory load aligned to the end of the
518          * array.
519          */
520         masm.movq(temp, new AMD64Address(array1, result, arrayIndexScale1, -VECTOR_SIZE));

521         if (requiresNaNCheck) {
<span class="line-modified">522             masm.cmpqAndJcc(temp, new AMD64Address(array2, result, arrayIndexScale2, -VECTOR_SIZE), ConditionFlag.Equal, trueLabel, false);</span>
523             // At most two iterations, unroll in the emitted code.
524             for (int offset = 0; offset &lt; VECTOR_SIZE; offset += kind1.getByteCount()) {
525                 emitFloatCompare(masm, array1, array2, result, -VECTOR_SIZE + offset, falseLabel, kind1.getByteCount() == VECTOR_SIZE);
526             }
527         } else {
<span class="line-modified">528             masm.cmpqAndJcc(temp, new AMD64Address(array2, result, arrayIndexScale2, -VECTOR_SIZE), ConditionFlag.NotEqual, falseLabel, true);</span>
529         }
530         masm.jmpb(trueLabel);
531 
532         masm.bind(compareTail);
533         masm.movl(length, result);
534     }
535 
536     /**
537      * Emits code to compare the remaining 1 to 4 bytes.
538      */
539     private void emitTailCompares(AMD64MacroAssembler masm,
540                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
541         assert kind1 == kind2;
542         Label compare2Bytes = new Label();
543         Label compare1Byte = new Label();
544 
545         Register temp = asRegister(temp4);
546 
547         if (kind1.getByteCount() &lt;= 4) {
548             // Compare trailing 4 bytes, if any.
<span class="line-modified">549             masm.testlAndJcc(result, arrayIndexScale1.log2 == 0 ? 4 : 4 &gt;&gt; arrayIndexScale1.log2, ConditionFlag.Zero, compare2Bytes, true);</span>

550             masm.movl(temp, new AMD64Address(array1, 0));

551             if (kind1 == JavaKind.Float) {
<span class="line-modified">552                 masm.cmplAndJcc(temp, new AMD64Address(array2, 0), ConditionFlag.Equal, trueLabel, true);</span>
553                 emitFloatCompare(masm, array1, array2, Register.None, 0, falseLabel, true);
554                 masm.jmpb(trueLabel);
555             } else {
<span class="line-modified">556                 masm.cmplAndJcc(temp, new AMD64Address(array2, 0), ConditionFlag.NotEqual, falseLabel, true);</span>
557             }
558             if (kind1.getByteCount() &lt;= 2) {
559                 // Move array pointers forward.
560                 masm.leaq(array1, new AMD64Address(array1, 4));
561                 masm.leaq(array2, new AMD64Address(array2, 4));
562 
563                 // Compare trailing 2 bytes, if any.
564                 masm.bind(compare2Bytes);
<span class="line-modified">565                 masm.testlAndJcc(result, arrayIndexScale1.log2 == 0 ? 2 : 2 &gt;&gt; arrayIndexScale1.log2, ConditionFlag.Zero, compare1Byte, true);</span>

566                 masm.movzwl(temp, new AMD64Address(array1, 0));
567                 masm.movzwl(length, new AMD64Address(array2, 0));
<span class="line-modified">568                 masm.cmplAndJcc(temp, length, ConditionFlag.NotEqual, falseLabel, true);</span>

569 
570                 // The one-byte tail compare is only required for boolean and byte arrays.
571                 if (kind1.getByteCount() &lt;= 1) {
572                     // Move array pointers forward before we compare the last trailing byte.
573                     masm.leaq(array1, new AMD64Address(array1, 2));
574                     masm.leaq(array2, new AMD64Address(array2, 2));
575 
576                     // Compare trailing byte, if any.
<span class="line-added">577                     // TODO (yz) this can be optimized, i.e., bind after padding</span>
578                     masm.bind(compare1Byte);
<span class="line-modified">579                     masm.testlAndJcc(result, 1, ConditionFlag.Zero, trueLabel, true);</span>

580                     masm.movzbl(temp, new AMD64Address(array1, 0));
581                     masm.movzbl(length, new AMD64Address(array2, 0));
<span class="line-modified">582                     masm.cmplAndJcc(temp, length, ConditionFlag.NotEqual, falseLabel, true);</span>

583                 } else {
584                     masm.bind(compare1Byte);
585                 }
586             } else {
587                 masm.bind(compare2Bytes);
588             }
589         }
590     }
591 
592     private void emitDifferentKindsElementWiseCompare(CompilationResultBuilder crb, AMD64MacroAssembler masm,
593                     Register result, Register array1, Register array2, Register length, Label trueLabel, Label falseLabel) {
594         assert kind1 != kind2;
595         assert kind1.isNumericInteger() &amp;&amp; kind2.isNumericInteger();
596         Label loop = new Label();
597         Label compareTail = new Label();
598 
599         int elementsPerLoopIteration = 4;
600 
601         Register tmp1 = asRegister(temp4);
602         Register tmp2 = asRegister(temp5);
603 
604         masm.andl(result, elementsPerLoopIteration - 1); // tail count
<span class="line-modified">605         masm.andlAndJcc(length, ~(elementsPerLoopIteration - 1), ConditionFlag.Zero, compareTail, false);</span>

606 
607         masm.leaq(array1, new AMD64Address(array1, length, arrayIndexScale1, 0));
608         masm.leaq(array2, new AMD64Address(array2, length, arrayIndexScale2, 0));
609         masm.negq(length);
610 
611         // clear comparison registers because of the missing movzlq instruction
612         masm.xorq(tmp1, tmp1);
613         masm.xorq(tmp2, tmp2);
614 
615         // Align the main loop
616         masm.align(crb.target.wordSize * 2);
617         masm.bind(loop);
618         for (int i = 0; i &lt; elementsPerLoopIteration; i++) {
619             emitMovBytes(masm, tmp1, new AMD64Address(array1, length, arrayIndexScale1, i &lt;&lt; arrayIndexScale1.log2), kind1.getByteCount());
620             emitMovBytes(masm, tmp2, new AMD64Address(array2, length, arrayIndexScale2, i &lt;&lt; arrayIndexScale2.log2), kind2.getByteCount());
<span class="line-modified">621             masm.cmpqAndJcc(tmp1, tmp2, ConditionFlag.NotEqual, falseLabel, false);</span>

622         }
<span class="line-modified">623         masm.addqAndJcc(length, elementsPerLoopIteration, ConditionFlag.NotZero, loop, true);</span>

624 
625         masm.bind(compareTail);
<span class="line-modified">626         masm.testlAndJcc(result, result, ConditionFlag.Zero, trueLabel, false);</span>

627         for (int i = 0; i &lt; elementsPerLoopIteration - 1; i++) {
628             emitMovBytes(masm, tmp1, new AMD64Address(array1, length, arrayIndexScale1, 0), kind1.getByteCount());
629             emitMovBytes(masm, tmp2, new AMD64Address(array2, length, arrayIndexScale2, 0), kind2.getByteCount());
<span class="line-modified">630             masm.cmpqAndJcc(tmp1, tmp2, ConditionFlag.NotEqual, falseLabel, false);</span>

631             if (i &lt; elementsPerLoopIteration - 2) {
632                 masm.incrementq(length, 1);
<span class="line-modified">633                 masm.decqAndJcc(result, ConditionFlag.Zero, trueLabel, false);</span>

634             } else {
635                 masm.jmpb(trueLabel);
636             }
637         }
638     }
639 
640     /**
641      * Emits code to fall through if {@code src} is NaN, otherwise jump to {@code branchOrdered}.
642      */
643     private void emitNaNCheck(AMD64MacroAssembler masm, AMD64Address src, Label branchIfNonNaN) {
644         assert kind1.isNumericFloat();
645         Register tempXMMReg = asRegister(tempXMM);
646         if (kind1 == JavaKind.Float) {
647             masm.movflt(tempXMMReg, src);
648         } else {
649             masm.movdbl(tempXMMReg, src);
650         }
651         SSEOp.UCOMIS.emit(masm, kind1 == JavaKind.Float ? OperandSize.PS : OperandSize.PD, tempXMMReg, tempXMMReg);
652         masm.jcc(ConditionFlag.NoParity, branchIfNonNaN);
653     }
654 
655     /**
656      * Emits code to compare if two floats are bitwise equal or both NaN.
657      */
658     private void emitFloatCompare(AMD64MacroAssembler masm, Register base1, Register base2, Register index, int offset, Label falseLabel,
659                     boolean skipBitwiseCompare) {
660         AMD64Address address1 = new AMD64Address(base1, index, arrayIndexScale1, offset);
661         AMD64Address address2 = new AMD64Address(base2, index, arrayIndexScale2, offset);
662 
663         Label bitwiseEqual = new Label();
664 
665         if (!skipBitwiseCompare) {
666             // Bitwise compare
667             Register temp = asRegister(temp4);
668 
669             if (kind1 == JavaKind.Float) {
670                 masm.movl(temp, address1);
<span class="line-modified">671                 masm.cmplAndJcc(temp, address2, ConditionFlag.Equal, bitwiseEqual, true);</span>
672             } else {
673                 masm.movq(temp, address1);
<span class="line-modified">674                 masm.cmpqAndJcc(temp, address2, ConditionFlag.Equal, bitwiseEqual, true);</span>
675             }

676         }
677 
678         emitNaNCheck(masm, address1, falseLabel);
679         emitNaNCheck(masm, address2, falseLabel);
680 
681         masm.bind(bitwiseEqual);
682     }
683 
684     /**
685      * Emits code to compare float equality within a range.
686      */
687     private void emitFloatCompareWithinRange(CompilationResultBuilder crb, AMD64MacroAssembler masm,
688                     Register base1, Register base2, Register index, int offset, Label falseLabel, int range) {
689         assert kind1.isNumericFloat();
690         Label loop = new Label();
691         Register i = asRegister(temp5);
692 
693         masm.movq(i, range);
694         masm.negq(i);
695         // Align the main loop
696         masm.align(crb.target.wordSize * 2);
697         masm.bind(loop);
698         emitFloatCompare(masm, base1, base2, index, offset, falseLabel, range == 1);
699         masm.incrementq(index, 1);
<span class="line-modified">700         masm.incqAndJcc(i, ConditionFlag.NotZero, loop, true);</span>

701         // Floats within the range are equal, revert change to the register index
702         masm.subq(index, range);
703     }
704 
705     private boolean constantLengthCompareNeedsTmpArrayPointers() {
706         AVXKind.AVXSize vSize = vectorSize;
707         if (constantLength() &lt; getElementsPerVector(vectorSize)) {
708             vSize = AVXKind.AVXSize.XMM;
709         }
710         int vectorCount = constantLength() &amp; ~(2 * getElementsPerVector(vSize) - 1);
711         return vectorCount &gt; 0;
712     }
713 
714     /**
715      * Emits specialized assembly for checking equality of memory regions
716      * {@code arrayPtr1[0..nBytes]} and {@code arrayPtr2[0..nBytes]}. If they match, execution
717      * continues directly after the emitted code block, otherwise we jump to {@code noMatch}.
718      */
719     private void emitConstantLengthArrayCompareBytes(
720                     CompilationResultBuilder crb,
</pre>
<hr />
<pre>
755                 Label loopBegin = new Label();
756                 Register tmpArrayPtr1 = asRegister(temp1);
757                 Register tmpArrayPtr2 = asRegister(temp2);
758                 asm.leaq(tmpArrayPtr1, new AMD64Address(arrayPtr1, vectorCount &lt;&lt; arrayIndexScale1.log2));
759                 asm.leaq(tmpArrayPtr2, new AMD64Address(arrayPtr2, vectorCount &lt;&lt; arrayIndexScale2.log2));
760                 arrayPtr1 = tmpArrayPtr1;
761                 arrayPtr2 = tmpArrayPtr2;
762                 asm.movq(tmp, -vectorCount);
763                 asm.align(crb.target.wordSize * 2);
764                 asm.bind(loopBegin);
765                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, tmp, arrayBaseOffset1, vSize);
766                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, tmp, arrayBaseOffset2, vSize);
767                 emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, tmp, arrayBaseOffset1 + scaleDisplacement1(bytesPerVector), vSize);
768                 emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, tmp, arrayBaseOffset2 + scaleDisplacement2(bytesPerVector), vSize);
769                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
770                 emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
771                 emitVectorTest(asm, tmpVectors[0], vSize);
772                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
773                 emitVectorTest(asm, tmpVectors[2], vSize);
774                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
<span class="line-modified">775                 asm.addqAndJcc(tmp, elementsPerVectorLoop, AMD64Assembler.ConditionFlag.NotZero, loopBegin, true);</span>

776             }
777             if (tailCount &gt; 0) {
778                 emitVectorLoad1(asm, tmpVectors[0], arrayPtr1, arrayBaseOffset1 + (tailCount &lt;&lt; arrayIndexScale1.log2) - scaleDisplacement1(bytesPerVector), vSize);
779                 emitVectorLoad2(asm, tmpVectors[1], arrayPtr2, arrayBaseOffset2 + (tailCount &lt;&lt; arrayIndexScale2.log2) - scaleDisplacement2(bytesPerVector), vSize);
780                 emitVectorXor(asm, tmpVectors[0], tmpVectors[1], vSize);
781                 if (tailCount &gt; elementsPerVector) {
782                     emitVectorLoad1(asm, tmpVectors[2], arrayPtr1, arrayBaseOffset1, vSize);
783                     emitVectorLoad2(asm, tmpVectors[3], arrayPtr2, arrayBaseOffset2, vSize);
784                     emitVectorXor(asm, tmpVectors[2], tmpVectors[3], vSize);
785                     emitVectorTest(asm, tmpVectors[2], vSize);
786                     asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
787                 }
788                 emitVectorTest(asm, tmpVectors[0], vSize);
789                 asm.jccb(AMD64Assembler.ConditionFlag.NotZero, noMatch);
790             }
791         }
792     }
793 
794     private void emitMovBytes(AMD64MacroAssembler asm, Register dst, AMD64Address src, int size) {
795         switch (size) {
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArrayCompareToOp.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64ArrayIndexOfOp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CardTableBarrierSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../graphbuilderconf/LoopExplosionPlugin.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2019, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.nodes.gc;
 27 
<span class="line-removed"> 28 import java.lang.ref.Reference;</span>
<span class="line-removed"> 29 </span>
 30 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 31 import org.graalvm.compiler.debug.GraalError;
 32 import org.graalvm.compiler.nodes.NodeView;
 33 import org.graalvm.compiler.nodes.StructuredGraph;
 34 import org.graalvm.compiler.nodes.ValueNode;
 35 import org.graalvm.compiler.nodes.extended.ArrayRangeWrite;
 36 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 37 import org.graalvm.compiler.nodes.java.AbstractCompareAndSwapNode;
 38 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 39 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
<span class="line-modified"> 40 import org.graalvm.compiler.nodes.memory.HeapAccess;</span>
<span class="line-removed"> 41 import org.graalvm.compiler.nodes.memory.HeapAccess.BarrierType;</span>
 42 import org.graalvm.compiler.nodes.memory.ReadNode;
 43 import org.graalvm.compiler.nodes.memory.WriteNode;
 44 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 45 import org.graalvm.compiler.nodes.type.StampTool;
 46 
 47 import jdk.vm.ci.meta.JavaKind;
<span class="line-removed"> 48 import jdk.vm.ci.meta.MetaAccessProvider;</span>
<span class="line-removed"> 49 import jdk.vm.ci.meta.ResolvedJavaField;</span>
 50 import jdk.vm.ci.meta.ResolvedJavaType;
 51 
 52 public class G1BarrierSet implements BarrierSet {
 53 
<span class="line-removed"> 54     private final long referentFieldOffset;</span>
 55     private final ResolvedJavaType referenceType;

 56 
<span class="line-modified"> 57     public G1BarrierSet(MetaAccessProvider metaAccess) {</span>
<span class="line-modified"> 58         this.referenceType = metaAccess.lookupJavaType(Reference.class);</span>
<span class="line-modified"> 59         int offset = -1;</span>
<span class="line-removed"> 60         for (ResolvedJavaField field : referenceType.getInstanceFields(true)) {</span>
<span class="line-removed"> 61             if (field.getName().equals(&quot;referent&quot;)) {</span>
<span class="line-removed"> 62                 offset = field.getOffset();</span>
<span class="line-removed"> 63             }</span>
<span class="line-removed"> 64         }</span>
<span class="line-removed"> 65         if (offset == 1) {</span>
<span class="line-removed"> 66             throw new GraalError(&quot;Can&#39;t find Reference.referent field&quot;);</span>
<span class="line-removed"> 67         }</span>
<span class="line-removed"> 68         this.referentFieldOffset = offset;</span>
 69     }
 70 
 71     @Override
 72     public BarrierType readBarrierType(RawLoadNode load) {
 73         if (load.object().getStackKind() == JavaKind.Object &amp;&amp;
 74                         load.accessKind() == JavaKind.Object &amp;&amp;
 75                         !StampTool.isPointerAlwaysNull(load.object())) {
 76             if (load.offset().isJavaConstant() &amp;&amp; referentFieldOffset != load.offset().asJavaConstant().asLong()) {
 77                 // Reading at a constant offset which is different than the referent field.
 78                 return BarrierType.NONE;
 79             }
 80             ResolvedJavaType type = StampTool.typeOrNull(load.object());
 81             if (type != null &amp;&amp; referenceType.isAssignableFrom(type)) {
 82                 // It&#39;s definitely a field of a Reference type
 83                 if (load.offset().isJavaConstant() &amp;&amp; referentFieldOffset == load.offset().asJavaConstant().asLong()) {
 84                     // Exactly Reference.referent
 85                     return BarrierType.WEAK_FIELD;
 86                 }
 87                 // An unknown offset into Reference
 88                 return BarrierType.MAYBE_WEAK_FIELD;
</pre>
<hr />
<pre>
100     public void addBarriers(FixedAccessNode n) {
101         if (n instanceof ReadNode) {
102             addReadNodeBarriers((ReadNode) n);
103         } else if (n instanceof WriteNode) {
104             WriteNode write = (WriteNode) n;
105             addWriteBarriers(write, write.value(), null, true, write.getNullCheck());
106         } else if (n instanceof LoweredAtomicReadAndWriteNode) {
107             LoweredAtomicReadAndWriteNode atomic = (LoweredAtomicReadAndWriteNode) n;
108             addWriteBarriers(atomic, atomic.getNewValue(), null, true, atomic.getNullCheck());
109         } else if (n instanceof AbstractCompareAndSwapNode) {
110             AbstractCompareAndSwapNode cmpSwap = (AbstractCompareAndSwapNode) n;
111             addWriteBarriers(cmpSwap, cmpSwap.getNewValue(), cmpSwap.getExpectedValue(), false, false);
112         } else if (n instanceof ArrayRangeWrite) {
113             addArrayRangeBarriers((ArrayRangeWrite) n);
114         } else {
115             GraalError.guarantee(n.getBarrierType() == BarrierType.NONE, &quot;missed a node that requires a GC barrier: %s&quot;, n.getClass());
116         }
117     }
118 
119     private static void addReadNodeBarriers(ReadNode node) {
<span class="line-modified">120         if (node.getBarrierType() == HeapAccess.BarrierType.WEAK_FIELD || node.getBarrierType() == BarrierType.MAYBE_WEAK_FIELD) {</span>
121             StructuredGraph graph = node.graph();
122             G1ReferentFieldReadBarrier barrier = graph.add(new G1ReferentFieldReadBarrier(node.getAddress(), node, node.getBarrierType() == BarrierType.MAYBE_WEAK_FIELD));
123             graph.addAfterFixed(node, barrier);
124         }
125     }
126 
127     private void addWriteBarriers(FixedAccessNode node, ValueNode writtenValue, ValueNode expectedValue, boolean doLoad, boolean nullCheck) {
<span class="line-modified">128         HeapAccess.BarrierType barrierType = node.getBarrierType();</span>
129         switch (barrierType) {
130             case NONE:
131                 // nothing to do
132                 break;
133             case FIELD:
134             case ARRAY:
135             case UNKNOWN:
136                 if (isObjectValue(writtenValue)) {
137                     StructuredGraph graph = node.graph();
138                     boolean init = node.getLocationIdentity().isInit();
139                     if (!init) {
140                         // The pre barrier does nothing if the value being read is null, so it can
141                         // be explicitly skipped when this is an initializing store.
142                         addG1PreWriteBarrier(node, node.getAddress(), expectedValue, doLoad, nullCheck, graph);
143                     }
144                     if (writeRequiresPostBarrier(node, writtenValue)) {
<span class="line-modified">145                         boolean precise = barrierType != HeapAccess.BarrierType.FIELD;</span>
146                         addG1PostWriteBarrier(node, node.getAddress(), writtenValue, precise, graph);
147                     }
148                 }
149                 break;
150             default:
151                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
152         }
153     }
154 
155     @SuppressWarnings(&quot;unused&quot;)
156     protected boolean writeRequiresPostBarrier(FixedAccessNode initializingWrite, ValueNode writtenValue) {
157         // Without help from the runtime all writes require an explicit post barrier.
158         return true;
159     }
160 
161     private static void addArrayRangeBarriers(ArrayRangeWrite write) {
162         if (write.writesObjectArray()) {
163             StructuredGraph graph = write.asNode().graph();
164             if (!write.isInitialization()) {
165                 // The pre barrier does nothing if the value being read is null, so it can
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * Copyright (c) 2019, Red Hat Inc. All rights reserved.
  4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  5  *
  6  * This code is free software; you can redistribute it and/or modify it
  7  * under the terms of the GNU General Public License version 2 only, as
  8  * published by the Free Software Foundation.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 
 26 package org.graalvm.compiler.nodes.gc;
 27 


 28 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
 29 import org.graalvm.compiler.debug.GraalError;
 30 import org.graalvm.compiler.nodes.NodeView;
 31 import org.graalvm.compiler.nodes.StructuredGraph;
 32 import org.graalvm.compiler.nodes.ValueNode;
 33 import org.graalvm.compiler.nodes.extended.ArrayRangeWrite;
 34 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 35 import org.graalvm.compiler.nodes.java.AbstractCompareAndSwapNode;
 36 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 37 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
<span class="line-modified"> 38 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;</span>

 39 import org.graalvm.compiler.nodes.memory.ReadNode;
 40 import org.graalvm.compiler.nodes.memory.WriteNode;
 41 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 42 import org.graalvm.compiler.nodes.type.StampTool;
 43 
 44 import jdk.vm.ci.meta.JavaKind;


 45 import jdk.vm.ci.meta.ResolvedJavaType;
 46 
 47 public class G1BarrierSet implements BarrierSet {
 48 

 49     private final ResolvedJavaType referenceType;
<span class="line-added"> 50     private final long referentFieldOffset;</span>
 51 
<span class="line-modified"> 52     public G1BarrierSet(ResolvedJavaType referenceType, long referentFieldOffset) {</span>
<span class="line-modified"> 53         this.referenceType = referenceType;</span>
<span class="line-modified"> 54         this.referentFieldOffset = referentFieldOffset;</span>









 55     }
 56 
 57     @Override
 58     public BarrierType readBarrierType(RawLoadNode load) {
 59         if (load.object().getStackKind() == JavaKind.Object &amp;&amp;
 60                         load.accessKind() == JavaKind.Object &amp;&amp;
 61                         !StampTool.isPointerAlwaysNull(load.object())) {
 62             if (load.offset().isJavaConstant() &amp;&amp; referentFieldOffset != load.offset().asJavaConstant().asLong()) {
 63                 // Reading at a constant offset which is different than the referent field.
 64                 return BarrierType.NONE;
 65             }
 66             ResolvedJavaType type = StampTool.typeOrNull(load.object());
 67             if (type != null &amp;&amp; referenceType.isAssignableFrom(type)) {
 68                 // It&#39;s definitely a field of a Reference type
 69                 if (load.offset().isJavaConstant() &amp;&amp; referentFieldOffset == load.offset().asJavaConstant().asLong()) {
 70                     // Exactly Reference.referent
 71                     return BarrierType.WEAK_FIELD;
 72                 }
 73                 // An unknown offset into Reference
 74                 return BarrierType.MAYBE_WEAK_FIELD;
</pre>
<hr />
<pre>
 86     public void addBarriers(FixedAccessNode n) {
 87         if (n instanceof ReadNode) {
 88             addReadNodeBarriers((ReadNode) n);
 89         } else if (n instanceof WriteNode) {
 90             WriteNode write = (WriteNode) n;
 91             addWriteBarriers(write, write.value(), null, true, write.getNullCheck());
 92         } else if (n instanceof LoweredAtomicReadAndWriteNode) {
 93             LoweredAtomicReadAndWriteNode atomic = (LoweredAtomicReadAndWriteNode) n;
 94             addWriteBarriers(atomic, atomic.getNewValue(), null, true, atomic.getNullCheck());
 95         } else if (n instanceof AbstractCompareAndSwapNode) {
 96             AbstractCompareAndSwapNode cmpSwap = (AbstractCompareAndSwapNode) n;
 97             addWriteBarriers(cmpSwap, cmpSwap.getNewValue(), cmpSwap.getExpectedValue(), false, false);
 98         } else if (n instanceof ArrayRangeWrite) {
 99             addArrayRangeBarriers((ArrayRangeWrite) n);
100         } else {
101             GraalError.guarantee(n.getBarrierType() == BarrierType.NONE, &quot;missed a node that requires a GC barrier: %s&quot;, n.getClass());
102         }
103     }
104 
105     private static void addReadNodeBarriers(ReadNode node) {
<span class="line-modified">106         if (node.getBarrierType() == BarrierType.WEAK_FIELD || node.getBarrierType() == BarrierType.MAYBE_WEAK_FIELD) {</span>
107             StructuredGraph graph = node.graph();
108             G1ReferentFieldReadBarrier barrier = graph.add(new G1ReferentFieldReadBarrier(node.getAddress(), node, node.getBarrierType() == BarrierType.MAYBE_WEAK_FIELD));
109             graph.addAfterFixed(node, barrier);
110         }
111     }
112 
113     private void addWriteBarriers(FixedAccessNode node, ValueNode writtenValue, ValueNode expectedValue, boolean doLoad, boolean nullCheck) {
<span class="line-modified">114         BarrierType barrierType = node.getBarrierType();</span>
115         switch (barrierType) {
116             case NONE:
117                 // nothing to do
118                 break;
119             case FIELD:
120             case ARRAY:
121             case UNKNOWN:
122                 if (isObjectValue(writtenValue)) {
123                     StructuredGraph graph = node.graph();
124                     boolean init = node.getLocationIdentity().isInit();
125                     if (!init) {
126                         // The pre barrier does nothing if the value being read is null, so it can
127                         // be explicitly skipped when this is an initializing store.
128                         addG1PreWriteBarrier(node, node.getAddress(), expectedValue, doLoad, nullCheck, graph);
129                     }
130                     if (writeRequiresPostBarrier(node, writtenValue)) {
<span class="line-modified">131                         boolean precise = barrierType != BarrierType.FIELD;</span>
132                         addG1PostWriteBarrier(node, node.getAddress(), writtenValue, precise, graph);
133                     }
134                 }
135                 break;
136             default:
137                 throw new GraalError(&quot;unexpected barrier type: &quot; + barrierType);
138         }
139     }
140 
141     @SuppressWarnings(&quot;unused&quot;)
142     protected boolean writeRequiresPostBarrier(FixedAccessNode initializingWrite, ValueNode writtenValue) {
143         // Without help from the runtime all writes require an explicit post barrier.
144         return true;
145     }
146 
147     private static void addArrayRangeBarriers(ArrayRangeWrite write) {
148         if (write.writesObjectArray()) {
149             StructuredGraph graph = write.asNode().graph();
150             if (!write.isInitialization()) {
151                 // The pre barrier does nothing if the value being read is null, so it can
</pre>
</td>
</tr>
</table>
<center><a href="CardTableBarrierSet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../graphbuilderconf/LoopExplosionPlugin.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
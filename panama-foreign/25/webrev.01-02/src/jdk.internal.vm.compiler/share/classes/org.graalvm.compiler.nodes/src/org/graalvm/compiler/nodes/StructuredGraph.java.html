<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.nodes;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collections;
  29 import java.util.Iterator;
  30 import java.util.List;
  31 import java.util.SortedSet;
  32 import java.util.TreeSet;
  33 import java.util.concurrent.atomic.AtomicLong;
  34 import java.util.function.Consumer;
  35 import java.util.stream.Collectors;
  36 
  37 import jdk.internal.vm.compiler.collections.EconomicMap;
  38 import jdk.internal.vm.compiler.collections.EconomicSet;
  39 import jdk.internal.vm.compiler.collections.Equivalence;
  40 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  41 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  42 import org.graalvm.compiler.api.replacements.Snippet;
  43 import org.graalvm.compiler.core.common.CancellationBailoutException;
  44 import org.graalvm.compiler.core.common.CompilationIdentifier;
  45 import org.graalvm.compiler.core.common.GraalOptions;
  46 import org.graalvm.compiler.core.common.cfg.BlockMap;
  47 import org.graalvm.compiler.core.common.type.Stamp;
  48 import org.graalvm.compiler.debug.DebugContext;
  49 import org.graalvm.compiler.debug.JavaMethodContext;
  50 import org.graalvm.compiler.debug.TTY;
  51 import org.graalvm.compiler.graph.Graph;
  52 import org.graalvm.compiler.graph.Node;
  53 import org.graalvm.compiler.graph.NodeMap;
  54 import org.graalvm.compiler.graph.NodeSourcePosition;
  55 import org.graalvm.compiler.nodes.calc.FloatingNode;
  56 import org.graalvm.compiler.nodes.cfg.Block;
  57 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
  58 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  59 import org.graalvm.compiler.nodes.spi.VirtualizableAllocation;
  60 import org.graalvm.compiler.nodes.util.GraphUtil;
  61 import org.graalvm.compiler.options.OptionValues;
  62 
  63 import jdk.vm.ci.code.BytecodeFrame;
  64 import jdk.vm.ci.meta.Assumptions;
  65 import jdk.vm.ci.meta.Assumptions.Assumption;
  66 import jdk.vm.ci.meta.DefaultProfilingInfo;
  67 import jdk.vm.ci.meta.JavaMethod;
  68 import jdk.vm.ci.meta.ProfilingInfo;
  69 import jdk.vm.ci.meta.ResolvedJavaField;
  70 import jdk.vm.ci.meta.ResolvedJavaMethod;
  71 import jdk.vm.ci.meta.SpeculationLog;
  72 import jdk.vm.ci.meta.TriState;
  73 import jdk.vm.ci.runtime.JVMCICompiler;
  74 
  75 /**
  76  * A graph that contains at least one distinguished node : the {@link #start() start} node. This
  77  * node is the start of the control flow of the graph.
  78  */
  79 public final class StructuredGraph extends Graph implements JavaMethodContext {
  80 
  81     /**
  82      * The different stages of the compilation of a {@link Graph} regarding the status of
  83      * {@link GuardNode guards}, {@link DeoptimizingNode deoptimizations} and {@link FrameState
  84      * framestates}. The stage of a graph progresses monotonously.
  85      *
  86      */
  87     public enum GuardsStage {
  88         /**
  89          * During this stage, there can be {@link FloatingNode floating} {@link DeoptimizingNode}
  90          * such as {@link GuardNode GuardNodes}. New {@link DeoptimizingNode DeoptimizingNodes} can
  91          * be introduced without constraints. {@link FrameState} nodes are associated with
  92          * {@link StateSplit} nodes.
  93          */
  94         FLOATING_GUARDS,
  95         /**
  96          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
  97          * {@link FixedNode fixed} but new {@link DeoptimizingNode DeoptimizingNodes} can still be
  98          * introduced. {@link FrameState} nodes are still associated with {@link StateSplit} nodes.
  99          */
 100         FIXED_DEOPTS,
 101         /**
 102          * During this stage, all {@link DeoptimizingNode DeoptimizingNodes} must be
 103          * {@link FixedNode fixed}. New {@link DeoptimizingNode DeoptimizingNodes} can not be
 104          * introduced any more. {@link FrameState} nodes are now associated with
 105          * {@link DeoptimizingNode} nodes.
 106          */
 107         AFTER_FSA;
 108 
 109         public boolean allowsFloatingGuards() {
 110             return this == FLOATING_GUARDS;
 111         }
 112 
 113         public boolean allowsGuardInsertion() {
 114             return this.ordinal() &lt;= FIXED_DEOPTS.ordinal();
 115         }
 116 
 117         public boolean areFrameStatesAtDeopts() {
 118             return this == AFTER_FSA;
 119         }
 120 
 121         public boolean areFrameStatesAtSideEffects() {
 122             return !this.areFrameStatesAtDeopts();
 123         }
 124 
 125         public boolean areDeoptsFixed() {
 126             return this.ordinal() &gt;= FIXED_DEOPTS.ordinal();
 127         }
 128 
 129         public boolean requiresValueProxies() {
 130             return this != AFTER_FSA;
 131         }
 132     }
 133 
 134     /**
 135      * Constants denoting whether or not {@link Assumption}s can be made while processing a graph.
 136      */
 137     public enum AllowAssumptions {
 138         YES,
 139         NO;
 140         public static AllowAssumptions ifTrue(boolean flag) {
 141             return flag ? YES : NO;
 142         }
 143 
 144         public static AllowAssumptions ifNonNull(Assumptions assumptions) {
 145             return assumptions != null ? YES : NO;
 146         }
 147     }
 148 
 149     public static class ScheduleResult {
 150         private final ControlFlowGraph cfg;
 151         private final NodeMap&lt;Block&gt; nodeToBlockMap;
 152         private final BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap;
 153 
 154         public ScheduleResult(ControlFlowGraph cfg, NodeMap&lt;Block&gt; nodeToBlockMap, BlockMap&lt;List&lt;Node&gt;&gt; blockToNodesMap) {
 155             this.cfg = cfg;
 156             this.nodeToBlockMap = nodeToBlockMap;
 157             this.blockToNodesMap = blockToNodesMap;
 158         }
 159 
 160         public ControlFlowGraph getCFG() {
 161             return cfg;
 162         }
 163 
 164         public NodeMap&lt;Block&gt; getNodeToBlockMap() {
 165             return nodeToBlockMap;
 166         }
 167 
 168         public BlockMap&lt;List&lt;Node&gt;&gt; getBlockToNodesMap() {
 169             return blockToNodesMap;
 170         }
 171 
 172         public List&lt;Node&gt; nodesFor(Block block) {
 173             return blockToNodesMap.get(block);
 174         }
 175     }
 176 
 177     /**
 178      * Object used to create a {@link StructuredGraph}.
 179      */
 180     public static class Builder {
 181         private String name;
 182         private final Assumptions assumptions;
 183         private SpeculationLog speculationLog;
 184         private ResolvedJavaMethod rootMethod;
 185         private CompilationIdentifier compilationId = CompilationIdentifier.INVALID_COMPILATION_ID;
 186         private int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
 187         private boolean useProfilingInfo = true;
 188         private boolean recordInlinedMethods = true;
 189         private boolean trackNodeSourcePosition;
 190         private final OptionValues options;
 191         private Cancellable cancellable = null;
 192         private final DebugContext debug;
 193         private NodeSourcePosition callerContext;
 194         private boolean isSubstitution;
 195 
 196         /**
 197          * Creates a builder for a graph.
 198          */
 199         public Builder(OptionValues options, DebugContext debug, AllowAssumptions allowAssumptions) {
 200             this.options = options;
 201             this.debug = debug;
 202             this.assumptions = allowAssumptions == AllowAssumptions.YES ? new Assumptions() : null;
 203             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 204         }
 205 
 206         /**
 207          * Creates a builder for a graph that does not support {@link Assumptions}.
 208          */
 209         public Builder(OptionValues options, DebugContext debug) {
 210             this.options = options;
 211             this.debug = debug;
 212             this.assumptions = null;
 213             this.trackNodeSourcePosition = Graph.trackNodeSourcePositionDefault(options, debug);
 214         }
 215 
 216         public String getName() {
 217             return name;
 218         }
 219 
 220         public Builder name(String s) {
 221             this.name = s;
 222             return this;
 223         }
 224 
 225         /**
 226          * @see StructuredGraph#isSubstitution
 227          */
 228         public Builder setIsSubstitution(boolean flag) {
 229             this.isSubstitution = flag;
 230             return this;
 231         }
 232 
 233         public ResolvedJavaMethod getMethod() {
 234             return rootMethod;
 235         }
 236 
 237         public Builder method(ResolvedJavaMethod method) {
 238             this.rootMethod = method;
 239             return this;
 240         }
 241 
 242         public DebugContext getDebug() {
 243             return debug;
 244         }
 245 
 246         public SpeculationLog getSpeculationLog() {
 247             return speculationLog;
 248         }
 249 
 250         public Builder speculationLog(SpeculationLog log) {
 251             this.speculationLog = log;
 252             return this;
 253         }
 254 
 255         public CompilationIdentifier getCompilationId() {
 256             return compilationId;
 257         }
 258 
 259         public Builder compilationId(CompilationIdentifier id) {
 260             this.compilationId = id;
 261             return this;
 262         }
 263 
 264         public Cancellable getCancellable() {
 265             return cancellable;
 266         }
 267 
 268         public Builder cancellable(Cancellable cancel) {
 269             this.cancellable = cancel;
 270             return this;
 271         }
 272 
 273         public int getEntryBCI() {
 274             return entryBCI;
 275         }
 276 
 277         public Builder entryBCI(int bci) {
 278             this.entryBCI = bci;
 279             return this;
 280         }
 281 
 282         public boolean getUseProfilingInfo() {
 283             return useProfilingInfo;
 284         }
 285 
 286         public Builder useProfilingInfo(boolean flag) {
 287             this.useProfilingInfo = flag;
 288             return this;
 289         }
 290 
 291         public boolean getRecordInlinedMethods() {
 292             return recordInlinedMethods;
 293         }
 294 
 295         public Builder recordInlinedMethods(boolean flag) {
 296             this.recordInlinedMethods = flag;
 297             return this;
 298         }
 299 
 300         public Builder trackNodeSourcePosition(boolean flag) {
 301             if (flag) {
 302                 this.trackNodeSourcePosition = true;
 303             }
 304             return this;
 305         }
 306 
 307         public Builder callerContext(NodeSourcePosition context) {
 308             this.callerContext = context;
 309             return this;
 310         }
 311 
 312         public StructuredGraph build() {
 313             List&lt;ResolvedJavaMethod&gt; inlinedMethods = recordInlinedMethods ? new ArrayList&lt;&gt;() : null;
 314             // @formatter:off
 315             return new StructuredGraph(name,
 316                             rootMethod,
 317                             entryBCI,
 318                             assumptions,
 319                             speculationLog,
 320                             useProfilingInfo,
 321                             isSubstitution,
 322                             inlinedMethods,
 323                             trackNodeSourcePosition,
 324                             compilationId,
 325                             options,
 326                             debug,
 327                             cancellable,
 328                             callerContext);
 329             // @formatter:on
 330         }
 331     }
 332 
 333     public static final long INVALID_GRAPH_ID = -1;
 334     private static final AtomicLong uniqueGraphIds = new AtomicLong();
 335 
 336     private StartNode start;
 337     private ResolvedJavaMethod rootMethod;
 338     private final long graphId;
 339     private final CompilationIdentifier compilationId;
 340     private final int entryBCI;
 341     private GuardsStage guardsStage = GuardsStage.FLOATING_GUARDS;
 342     private boolean isAfterFloatingReadPhase = false;
 343     private boolean isAfterFixedReadPhase = false;
 344     private boolean hasValueProxies = true;
 345     private boolean isAfterExpandLogic = false;
 346     private final boolean useProfilingInfo;
 347     private final Cancellable cancellable;
 348     private final boolean isSubstitution;
 349 
 350     /**
 351      * The assumptions made while constructing and transforming this graph.
 352      */
 353     private final Assumptions assumptions;
 354 
 355     private SpeculationLog speculationLog;
 356 
 357     private ScheduleResult lastSchedule;
 358 
 359     private final InliningLog inliningLog;
 360 
 361     /**
 362      * Call stack (context) leading to construction of this graph.
 363      */
 364     private final NodeSourcePosition callerContext;
 365 
 366     /**
 367      * Records the methods that were used while constructing this graph, one entry for each time a
 368      * specific method is used. This will be {@code null} if recording of inlined methods is
 369      * disabled for the graph.
 370      */
 371     private final List&lt;ResolvedJavaMethod&gt; methods;
 372 
 373     /**
 374      * Records the fields that were accessed while constructing this graph.
 375      */
 376     private EconomicSet&lt;ResolvedJavaField&gt; fields = null;
 377 
 378     private enum UnsafeAccessState {
 379         NO_ACCESS,
 380         HAS_ACCESS,
 381         DISABLED
 382     }
 383 
 384     private UnsafeAccessState hasUnsafeAccess = UnsafeAccessState.NO_ACCESS;
 385 
 386     public static final boolean USE_PROFILING_INFO = true;
 387 
 388     public static final boolean NO_PROFILING_INFO = false;
 389 
 390     private StructuredGraph(String name,
 391                     ResolvedJavaMethod method,
 392                     int entryBCI,
 393                     Assumptions assumptions,
 394                     SpeculationLog speculationLog,
 395                     boolean useProfilingInfo,
 396                     boolean isSubstitution,
 397                     List&lt;ResolvedJavaMethod&gt; methods,
 398                     boolean trackNodeSourcePosition,
 399                     CompilationIdentifier compilationId,
 400                     OptionValues options,
 401                     DebugContext debug,
 402                     Cancellable cancellable,
 403                     NodeSourcePosition context) {
 404         super(name, options, debug, trackNodeSourcePosition);
 405         this.setStart(add(new StartNode()));
 406         this.rootMethod = method;
 407         this.graphId = uniqueGraphIds.incrementAndGet();
 408         this.compilationId = compilationId;
 409         this.entryBCI = entryBCI;
 410         this.assumptions = assumptions;
 411         this.methods = methods;
 412         this.speculationLog = speculationLog;
 413         this.useProfilingInfo = useProfilingInfo;
 414         this.isSubstitution = isSubstitution;
 415         assert checkIsSubstitutionInvariants(method, isSubstitution);
 416         this.cancellable = cancellable;
 417         this.inliningLog = new InliningLog(rootMethod, GraalOptions.TraceInlining.getValue(options));
 418         this.callerContext = context;
 419     }
 420 
 421     private static boolean checkIsSubstitutionInvariants(ResolvedJavaMethod method, boolean isSubstitution) {
 422         if (method != null) {
 423             if (method.getAnnotation(Snippet.class) != null || method.getAnnotation(MethodSubstitution.class) != null) {
 424                 assert isSubstitution : &quot;Graph for method &quot; + method.format(&quot;%H.%n(%p)&quot;) +
 425                                 &quot; annotated by &quot; + Snippet.class.getName() + &quot; or &quot; +
 426                                 MethodSubstitution.class.getName() +
 427                                 &quot; must have its `isSubstitution` field set to true&quot;;
 428             }
 429         }
 430         return true;
 431     }
 432 
 433     public void setLastSchedule(ScheduleResult result) {
 434         lastSchedule = result;
 435     }
 436 
 437     public ScheduleResult getLastSchedule() {
 438         return lastSchedule;
 439     }
 440 
 441     public void clearLastSchedule() {
 442         setLastSchedule(null);
 443     }
 444 
 445     @Override
 446     public boolean maybeCompress() {
 447         if (super.maybeCompress()) {
 448             /*
 449              * The schedule contains a NodeMap which is unusable after compression.
 450              */
 451             clearLastSchedule();
 452             return true;
 453         }
 454         return false;
 455     }
 456 
 457     public Stamp getReturnStamp() {
 458         Stamp returnStamp = null;
 459         for (ReturnNode returnNode : getNodes(ReturnNode.TYPE)) {
 460             ValueNode result = returnNode.result();
 461             if (result != null) {
 462                 if (returnStamp == null) {
 463                     returnStamp = result.stamp(NodeView.DEFAULT);
 464                 } else {
 465                     returnStamp = returnStamp.meet(result.stamp(NodeView.DEFAULT));
 466                 }
 467             }
 468         }
 469         return returnStamp;
 470     }
 471 
 472     @Override
 473     public String toString() {
 474         StringBuilder buf = new StringBuilder(getClass().getSimpleName() + &quot;:&quot; + graphId);
 475         String sep = &quot;{&quot;;
 476         if (name != null) {
 477             buf.append(sep);
 478             buf.append(name);
 479             sep = &quot;, &quot;;
 480         }
 481         if (method() != null) {
 482             buf.append(sep);
 483             buf.append(method());
 484             sep = &quot;, &quot;;
 485         }
 486 
 487         if (!sep.equals(&quot;{&quot;)) {
 488             buf.append(&quot;}&quot;);
 489         }
 490         return buf.toString();
 491     }
 492 
 493     public StartNode start() {
 494         return start;
 495     }
 496 
 497     /**
 498      * Gets the root method from which this graph was built.
 499      *
 500      * @return null if this method was not built from a method or the method is not available
 501      */
 502     public ResolvedJavaMethod method() {
 503         return rootMethod;
 504     }
 505 
 506     public int getEntryBCI() {
 507         return entryBCI;
 508     }
 509 
 510     public Cancellable getCancellable() {
 511         return cancellable;
 512     }
 513 
 514     public void checkCancellation() {
 515         if (cancellable != null &amp;&amp; cancellable.isCancelled()) {
 516             CancellationBailoutException.cancelCompilation();
 517         }
 518     }
 519 
 520     public boolean isOSR() {
 521         return entryBCI != JVMCICompiler.INVOCATION_ENTRY_BCI;
 522     }
 523 
 524     public long graphId() {
 525         return graphId;
 526     }
 527 
 528     /**
 529      * @see CompilationIdentifier
 530      */
 531     public CompilationIdentifier compilationId() {
 532         return compilationId;
 533     }
 534 
 535     public void setStart(StartNode start) {
 536         this.start = start;
 537     }
 538 
 539     public InliningLog getInliningLog() {
 540         return inliningLog;
 541     }
 542 
 543     public void logInliningTree() {
 544         if (GraalOptions.TraceInlining.getValue(getOptions())) {
 545             String formattedTree = getInliningLog().formatAsTree(true);
 546             if (formattedTree != null) {
 547                 TTY.println(formattedTree);
 548             }
 549         }
 550     }
 551 
 552     /**
 553      * Creates a copy of this graph.
 554      *
 555      * If a node contains an array of objects, only shallow copy of the field is applied.
 556      *
 557      * @param newName the name of the copy, used for debugging purposes (can be null)
 558      * @param duplicationMapCallback consumer of the duplication map created during the copying
 559      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 560      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 561      *            accessed by multiple threads).
 562      */
 563     @Override
 564     protected Graph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, DebugContext debugForCopy) {
 565         return copy(newName, duplicationMapCallback, compilationId, debugForCopy);
 566     }
 567 
 568     @SuppressWarnings(&quot;try&quot;)
 569     private StructuredGraph copy(String newName, Consumer&lt;UnmodifiableEconomicMap&lt;Node, Node&gt;&gt; duplicationMapCallback, CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 570         AllowAssumptions allowAssumptions = AllowAssumptions.ifNonNull(assumptions);
 571         StructuredGraph copy = new StructuredGraph(newName,
 572                         method(),
 573                         entryBCI,
 574                         assumptions == null ? null : new Assumptions(),
 575                         speculationLog,
 576                         useProfilingInfo,
 577                         isSubstitution,
 578                         methods != null ? new ArrayList&lt;&gt;(methods) : null,
 579                         trackNodeSourcePosition,
 580                         newCompilationId,
 581                         getOptions(), debugForCopy, null, callerContext);
 582         if (allowAssumptions == AllowAssumptions.YES &amp;&amp; assumptions != null) {
 583             copy.assumptions.record(assumptions);
 584         }
 585         copy.hasUnsafeAccess = hasUnsafeAccess;
 586         copy.setGuardsStage(getGuardsStage());
 587         copy.isAfterFloatingReadPhase = isAfterFloatingReadPhase;
 588         copy.hasValueProxies = hasValueProxies;
 589         copy.isAfterExpandLogic = isAfterExpandLogic;
 590         copy.trackNodeSourcePosition = trackNodeSourcePosition;
 591         if (fields != null) {
 592             copy.fields = createFieldSet(fields);
 593         }
 594         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
 595         replacements.put(start, copy.start);
 596         UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
 597         try (InliningLog.UpdateScope scope = copy.getInliningLog().openDefaultUpdateScope()) {
 598             duplicates = copy.addDuplicates(getNodes(), this, this.getNodeCount(), replacements);
 599             if (scope != null) {
 600                 copy.getInliningLog().replaceLog(duplicates, this.getInliningLog());
 601             }
 602         }
 603         if (duplicationMapCallback != null) {
 604             duplicationMapCallback.accept(duplicates);
 605         }
 606         return copy;
 607     }
 608 
 609     /**
 610      * @param debugForCopy the debug context for the graph copy. This must not be the debug for this
 611      *            graph if this graph can be accessed from multiple threads (e.g., it&#39;s in a cache
 612      *            accessed by multiple threads).
 613      */
 614     public StructuredGraph copyWithIdentifier(CompilationIdentifier newCompilationId, DebugContext debugForCopy) {
 615         return copy(name, null, newCompilationId, debugForCopy);
 616     }
 617 
 618     public ParameterNode getParameter(int index) {
 619         for (ParameterNode param : getNodes(ParameterNode.TYPE)) {
 620             if (param.index() == index) {
 621                 return param;
 622             }
 623         }
 624         return null;
 625     }
 626 
 627     public Iterable&lt;Invoke&gt; getInvokes() {
 628         final Iterator&lt;MethodCallTargetNode&gt; callTargets = getNodes(MethodCallTargetNode.TYPE).iterator();
 629         return new Iterable&lt;Invoke&gt;() {
 630 
 631             private Invoke next;
 632 
 633             @Override
 634             public Iterator&lt;Invoke&gt; iterator() {
 635                 return new Iterator&lt;Invoke&gt;() {
 636 
 637                     @Override
 638                     public boolean hasNext() {
 639                         if (next == null) {
 640                             while (callTargets.hasNext()) {
 641                                 Invoke i = callTargets.next().invoke();
 642                                 if (i != null) {
 643                                     next = i;
 644                                     return true;
 645                                 }
 646                             }
 647                             return false;
 648                         } else {
 649                             return true;
 650                         }
 651                     }
 652 
 653                     @Override
 654                     public Invoke next() {
 655                         try {
 656                             return next;
 657                         } finally {
 658                             next = null;
 659                         }
 660                     }
 661 
 662                     @Override
 663                     public void remove() {
 664                         throw new UnsupportedOperationException();
 665                     }
 666                 };
 667             }
 668         };
 669     }
 670 
 671     public boolean hasLoops() {
 672         return hasNode(LoopBeginNode.TYPE);
 673     }
 674 
 675     /**
 676      * Unlinks a node from all its control flow neighbors and then removes it from its graph. The
 677      * node must have no {@linkplain Node#usages() usages}.
 678      *
 679      * @param node the node to be unlinked and removed
 680      */
 681     @SuppressWarnings(&quot;static-method&quot;)
 682     public void removeFixed(FixedWithNextNode node) {
 683         assert node != null;
 684         if (node instanceof AbstractBeginNode) {
 685             ((AbstractBeginNode) node).prepareDelete();
 686         }
 687         assert node.hasNoUsages() : node + &quot; &quot; + node.getUsageCount() + &quot;, &quot; + node.usages().first();
 688         GraphUtil.unlinkFixedNode(node);
 689         node.safeDelete();
 690     }
 691 
 692     public void replaceFixed(FixedWithNextNode node, Node replacement) {
 693         if (replacement instanceof FixedWithNextNode) {
 694             replaceFixedWithFixed(node, (FixedWithNextNode) replacement);
 695         } else {
 696             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 697             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 698             replaceFixedWithFloating(node, (FloatingNode) replacement);
 699         }
 700     }
 701 
 702     public void replaceFixedWithFixed(FixedWithNextNode node, FixedWithNextNode replacement) {
 703         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 704         FixedNode next = node.next();
 705         node.setNext(null);
 706         replacement.setNext(next);
 707         node.replaceAndDelete(replacement);
 708         if (node == start) {
 709             setStart((StartNode) replacement);
 710         }
 711     }
 712 
 713     @SuppressWarnings(&quot;static-method&quot;)
 714     public void replaceFixedWithFloating(FixedWithNextNode node, ValueNode replacement) {
 715         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 716         GraphUtil.unlinkFixedNode(node);
 717         node.replaceAtUsagesAndDelete(replacement);
 718     }
 719 
 720     @SuppressWarnings(&quot;static-method&quot;)
 721     public void removeSplit(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 722         assert node != null;
 723         assert node.hasNoUsages();
 724         assert survivingSuccessor != null;
 725         node.clearSuccessors();
 726         node.replaceAtPredecessor(survivingSuccessor);
 727         node.safeDelete();
 728     }
 729 
 730     @SuppressWarnings(&quot;static-method&quot;)
 731     public void removeSplitPropagate(ControlSplitNode node, AbstractBeginNode survivingSuccessor) {
 732         assert node != null;
 733         assert node.hasNoUsages();
 734         assert survivingSuccessor != null;
 735         List&lt;Node&gt; snapshot = node.successors().snapshot();
 736         node.clearSuccessors();
 737         node.replaceAtPredecessor(survivingSuccessor);
 738         node.safeDelete();
 739         for (Node successor : snapshot) {
 740             if (successor != null &amp;&amp; successor.isAlive()) {
 741                 if (successor != survivingSuccessor) {
 742                     GraphUtil.killCFG((FixedNode) successor);
 743                 }
 744             }
 745         }
 746     }
 747 
 748     public void replaceSplit(ControlSplitNode node, Node replacement, AbstractBeginNode survivingSuccessor) {
 749         if (replacement instanceof FixedWithNextNode) {
 750             replaceSplitWithFixed(node, (FixedWithNextNode) replacement, survivingSuccessor);
 751         } else {
 752             assert replacement != null : &quot;cannot replace &quot; + node + &quot; with null&quot;;
 753             assert replacement instanceof FloatingNode : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 754             replaceSplitWithFloating(node, (FloatingNode) replacement, survivingSuccessor);
 755         }
 756     }
 757 
 758     @SuppressWarnings(&quot;static-method&quot;)
 759     public void replaceSplitWithFixed(ControlSplitNode node, FixedWithNextNode replacement, AbstractBeginNode survivingSuccessor) {
 760         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 761         assert survivingSuccessor != null;
 762         node.clearSuccessors();
 763         replacement.setNext(survivingSuccessor);
 764         node.replaceAndDelete(replacement);
 765     }
 766 
 767     @SuppressWarnings(&quot;static-method&quot;)
 768     public void replaceSplitWithFloating(ControlSplitNode node, FloatingNode replacement, AbstractBeginNode survivingSuccessor) {
 769         assert node != null &amp;&amp; replacement != null &amp;&amp; node.isAlive() &amp;&amp; replacement.isAlive() : &quot;cannot replace &quot; + node + &quot; with &quot; + replacement;
 770         assert survivingSuccessor != null;
 771         node.clearSuccessors();
 772         node.replaceAtPredecessor(survivingSuccessor);
 773         node.replaceAtUsagesAndDelete(replacement);
 774     }
 775 
 776     @SuppressWarnings(&quot;static-method&quot;)
 777     public void addAfterFixed(FixedWithNextNode node, FixedNode newNode) {
 778         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; after &quot; + node;
 779         FixedNode next = node.next();
 780         node.setNext(newNode);
 781         if (next != null) {
 782             assert newNode instanceof FixedWithNextNode;
 783             FixedWithNextNode newFixedWithNext = (FixedWithNextNode) newNode;
 784             assert newFixedWithNext.next() == null;
 785             newFixedWithNext.setNext(next);
 786         }
 787     }
 788 
 789     @SuppressWarnings(&quot;static-method&quot;)
 790     public void addBeforeFixed(FixedNode node, FixedWithNextNode newNode) {
 791         assert node != null &amp;&amp; newNode != null &amp;&amp; node.isAlive() &amp;&amp; newNode.isAlive() : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 792         assert node.predecessor() != null &amp;&amp; node.predecessor() instanceof FixedWithNextNode : &quot;cannot add &quot; + newNode + &quot; before &quot; + node;
 793         assert newNode.next() == null : newNode;
 794         assert !(node instanceof AbstractMergeNode);
 795         FixedWithNextNode pred = (FixedWithNextNode) node.predecessor();
 796         pred.setNext(newNode);
 797         newNode.setNext(node);
 798     }
 799 
 800     public void reduceDegenerateLoopBegin(LoopBeginNode begin) {
 801         assert begin.loopEnds().isEmpty() : &quot;Loop begin still has backedges&quot;;
 802         if (begin.forwardEndCount() == 1) { // bypass merge and remove
 803             reduceTrivialMerge(begin);
 804         } else { // convert to merge
 805             AbstractMergeNode merge = this.add(new MergeNode());
 806             for (EndNode end : begin.forwardEnds()) {
 807                 merge.addForwardEnd(end);
 808             }
 809             this.replaceFixedWithFixed(begin, merge);
 810         }
 811     }
 812 
 813     @SuppressWarnings(&quot;static-method&quot;)
 814     public void reduceTrivialMerge(AbstractMergeNode merge) {
 815         assert merge.forwardEndCount() == 1;
 816         assert !(merge instanceof LoopBeginNode) || ((LoopBeginNode) merge).loopEnds().isEmpty();
 817         for (PhiNode phi : merge.phis().snapshot()) {
 818             assert phi.valueCount() == 1;
 819             ValueNode singleValue = phi.valueAt(0);
 820             if (phi.hasUsages()) {
 821                 phi.replaceAtUsagesAndDelete(singleValue);
 822             } else {
 823                 phi.safeDelete();
 824                 if (singleValue != null) {
 825                     GraphUtil.tryKillUnused(singleValue);
 826                 }
 827             }
 828         }
 829         // remove loop exits
 830         if (merge instanceof LoopBeginNode) {
 831             ((LoopBeginNode) merge).removeExits();
 832         }
 833         AbstractEndNode singleEnd = merge.forwardEndAt(0);
 834         FixedNode sux = merge.next();
 835         FrameState stateAfter = merge.stateAfter();
 836         // evacuateGuards
 837         merge.prepareDelete((FixedNode) singleEnd.predecessor());
 838         merge.safeDelete();
 839         if (stateAfter != null) {
 840             GraphUtil.tryKillUnused(stateAfter);
 841         }
 842         if (sux == null) {
 843             singleEnd.replaceAtPredecessor(null);
 844             singleEnd.safeDelete();
 845         } else {
 846             singleEnd.replaceAndDelete(sux);
 847         }
 848     }
 849 
 850     public GuardsStage getGuardsStage() {
 851         return guardsStage;
 852     }
 853 
 854     public void setGuardsStage(GuardsStage guardsStage) {
 855         assert guardsStage.ordinal() &gt;= this.guardsStage.ordinal();
 856         this.guardsStage = guardsStage;
 857     }
 858 
 859     public boolean isAfterFloatingReadPhase() {
 860         return isAfterFloatingReadPhase;
 861     }
 862 
 863     public boolean isAfterFixedReadPhase() {
 864         return isAfterFixedReadPhase;
 865     }
 866 
 867     public void setAfterFloatingReadPhase(boolean state) {
 868         assert state : &quot;cannot &#39;unapply&#39; floating read phase on graph&quot;;
 869         isAfterFloatingReadPhase = state;
 870     }
 871 
 872     public void setAfterFixReadPhase(boolean state) {
 873         assert state : &quot;cannot &#39;unapply&#39; fix reads phase on graph&quot;;
 874         isAfterFixedReadPhase = state;
 875     }
 876 
 877     public boolean hasValueProxies() {
 878         return hasValueProxies;
 879     }
 880 
 881     public void setHasValueProxies(boolean state) {
 882         assert !state : &quot;cannot &#39;unapply&#39; value proxy removal on graph&quot;;
 883         hasValueProxies = state;
 884     }
 885 
 886     public boolean isAfterExpandLogic() {
 887         return isAfterExpandLogic;
 888     }
 889 
 890     public void setAfterExpandLogic() {
 891         isAfterExpandLogic = true;
 892     }
 893 
 894     /**
 895      * Determines if {@link ProfilingInfo} is used during construction of this graph.
 896      */
 897     public boolean useProfilingInfo() {
 898         return useProfilingInfo;
 899     }
 900 
 901     /**
 902      * Returns true if this graph is built without parsing the {@linkplain #method() root method} or
 903      * if the root method is annotated by {@link Snippet} or {@link MethodSubstitution}. This is
 904      * preferred over querying annotations directly as querying annotations can cause class loading.
 905      */
 906     public boolean isSubstitution() {
 907         return isSubstitution;
 908     }
 909 
 910     /**
 911      * Gets the profiling info for the {@linkplain #method() root method} of this graph.
 912      */
 913     public ProfilingInfo getProfilingInfo() {
 914         return getProfilingInfo(method());
 915     }
 916 
 917     /**
 918      * Gets the profiling info for a given method that is or will be part of this graph, taking into
 919      * account {@link #useProfilingInfo()}.
 920      */
 921     public ProfilingInfo getProfilingInfo(ResolvedJavaMethod m) {
 922         if (useProfilingInfo &amp;&amp; m != null) {
 923             return m.getProfilingInfo();
 924         } else {
 925             return DefaultProfilingInfo.get(TriState.UNKNOWN);
 926         }
 927     }
 928 
 929     /**
 930      * Gets the object for recording assumptions while constructing of this graph.
 931      *
 932      * @return {@code null} if assumptions cannot be made for this graph
 933      */
 934     public Assumptions getAssumptions() {
 935         return assumptions;
 936     }
 937 
 938     /**
 939      * Checks that any method referenced from a {@link FrameState} is also in the set of methods
 940      * parsed while building this graph.
 941      */
 942     private boolean checkFrameStatesAgainstInlinedMethods() {
 943         for (FrameState fs : getNodes(FrameState.TYPE)) {
 944             if (!BytecodeFrame.isPlaceholderBci(fs.bci)) {
 945                 ResolvedJavaMethod m = fs.code.getMethod();
 946                 if (!m.equals(rootMethod) &amp;&amp; !methods.contains(m)) {
 947                     SortedSet&lt;String&gt; haystack = new TreeSet&lt;&gt;();
 948                     if (!methods.contains(rootMethod)) {
 949                         haystack.add(rootMethod.format(&quot;%H.%n(%p)&quot;));
 950                     }
 951                     for (ResolvedJavaMethod e : methods) {
 952                         haystack.add(e.format(&quot;%H.%n(%p)&quot;));
 953                     }
 954                     throw new AssertionError(String.format(&quot;Could not find %s from %s in set(%s)&quot;, m.format(&quot;%H.%n(%p)&quot;), fs, haystack.stream().collect(Collectors.joining(System.lineSeparator()))));
 955                 }
 956             }
 957         }
 958         return true;
 959     }
 960 
 961     private static EconomicSet&lt;ResolvedJavaField&gt; createFieldSet(EconomicSet&lt;ResolvedJavaField&gt; init) {
 962         // Multiple ResolvedJavaField objects can represent the same field so they
 963         // need to be compared with equals().
 964         if (init != null) {
 965             return EconomicSet.create(Equivalence.DEFAULT, init);
 966         }
 967         return EconomicSet.create(Equivalence.DEFAULT);
 968     }
 969 
 970     /**
 971      * Gets an unmodifiable view of the methods that were inlined while constructing this graph.
 972      */
 973     public List&lt;ResolvedJavaMethod&gt; getMethods() {
 974         if (methods != null) {
 975             assert isSubstitution || checkFrameStatesAgainstInlinedMethods();
 976             return Collections.unmodifiableList(methods);
 977         }
 978         return Collections.emptyList();
 979     }
 980 
 981     /**
 982      * Records that {@code method} was used to build this graph.
 983      */
 984     public void recordMethod(ResolvedJavaMethod method) {
 985         if (methods != null) {
 986             methods.add(method);
 987         }
 988     }
 989 
 990     /**
 991      * Updates the {@linkplain #getMethods() methods} used to build this graph with the methods used
 992      * to build another graph.
 993      */
 994     public void updateMethods(StructuredGraph other) {
 995         if (methods != null) {
 996             if (other.rootMethod != null) {
 997                 methods.add(other.rootMethod);
 998             }
 999             for (ResolvedJavaMethod m : other.methods) {
1000                 methods.add(m);
1001             }
1002         }
1003     }
1004 
1005     /**
1006      * Gets an unmodifiable view of the fields that were accessed while constructing this graph.
1007      *
1008      * @return {@code null} if no field accesses were recorded
1009      */
1010     public EconomicSet&lt;ResolvedJavaField&gt; getFields() {
1011         return fields;
1012     }
1013 
1014     /**
1015      * Records that {@code field} was accessed in this graph.
1016      */
1017     public void recordField(ResolvedJavaField field) {
1018         assert GraalOptions.GeneratePIC.getValue(getOptions());
1019         if (this.fields == null) {
1020             this.fields = createFieldSet(null);
1021         }
1022         fields.add(field);
1023     }
1024 
1025     /**
1026      * Updates the {@linkplain #getFields() fields} of this graph with the accessed fields of
1027      * another graph.
1028      */
1029     public void updateFields(StructuredGraph other) {
1030         assert this != other;
1031         assert GraalOptions.GeneratePIC.getValue(getOptions());
1032         if (other.fields != null) {
1033             if (this.fields == null) {
1034                 this.fields = createFieldSet(null);
1035             }
1036             this.fields.addAll(other.fields);
1037         }
1038     }
1039 
1040     /**
1041      * Gets the input bytecode {@linkplain ResolvedJavaMethod#getCodeSize() size} from which this
1042      * graph is constructed. This ignores how many bytecodes in each constituent method are actually
1043      * parsed (which may be none for methods whose IR is retrieved from a cache or less than the
1044      * full amount for any given method due to profile guided branch pruning).
1045      */
1046     public int getBytecodeSize() {
1047         int res = 0;
1048         if (rootMethod != null) {
1049             res += rootMethod.getCodeSize();
1050         }
1051         if (methods != null) {
1052             for (ResolvedJavaMethod e : methods) {
1053                 res += e.getCodeSize();
1054             }
1055         }
1056         return res;
1057     }
1058 
1059     @Override
1060     public JavaMethod asJavaMethod() {
1061         return method();
1062     }
1063 
1064     public boolean hasUnsafeAccess() {
1065         return hasUnsafeAccess == UnsafeAccessState.HAS_ACCESS;
1066     }
1067 
1068     public void markUnsafeAccess() {
1069         if (hasUnsafeAccess == UnsafeAccessState.DISABLED) {
1070             return;
1071         }
1072         hasUnsafeAccess = UnsafeAccessState.HAS_ACCESS;
1073     }
1074 
1075     public void disableUnsafeAccessTracking() {
1076         hasUnsafeAccess = UnsafeAccessState.DISABLED;
1077     }
1078 
1079     public boolean isUnsafeAccessTrackingEnabled() {
1080         return hasUnsafeAccess != UnsafeAccessState.DISABLED;
1081     }
1082 
1083     public SpeculationLog getSpeculationLog() {
1084         return speculationLog;
1085     }
1086 
1087     public void clearAllStateAfter() {
1088         for (Node node : getNodes()) {
1089             if (node instanceof StateSplit) {
1090                 FrameState stateAfter = ((StateSplit) node).stateAfter();
1091                 if (stateAfter != null) {
1092                     ((StateSplit) node).setStateAfter(null);
1093                     // 2 nodes referencing the same framestate
1094                     if (stateAfter.isAlive()) {
1095                         GraphUtil.killWithUnusedFloatingInputs(stateAfter);
1096                     }
1097                 }
1098             }
1099         }
1100     }
1101 
1102     public boolean hasVirtualizableAllocation() {
1103         for (Node n : getNodes()) {
1104             if (n instanceof VirtualizableAllocation) {
1105                 return true;
1106             }
1107         }
1108         return false;
1109     }
1110 
1111     @Override
1112     protected void afterRegister(Node node) {
1113         assert hasValueProxies() || !(node instanceof ValueProxyNode);
1114         if (GraalOptions.TraceInlining.getValue(getOptions())) {
1115             if (node instanceof Invokable) {
1116                 ((Invokable) node).updateInliningLogAfterRegister(this);
1117             }
1118         }
1119     }
1120 
1121     public NodeSourcePosition getCallerContext() {
1122         return callerContext;
1123     }
1124 }
    </pre>
  </body>
</html>
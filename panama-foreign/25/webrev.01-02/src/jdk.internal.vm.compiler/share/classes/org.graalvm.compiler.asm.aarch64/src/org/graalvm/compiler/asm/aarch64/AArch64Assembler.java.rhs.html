<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.asm.aarch64/src/org/graalvm/compiler/asm/aarch64/AArch64Assembler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2018, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 
  26 package org.graalvm.compiler.asm.aarch64;
  27 
  28 import static jdk.vm.ci.aarch64.AArch64.CPU;
  29 import static jdk.vm.ci.aarch64.AArch64.SIMD;
  30 import static jdk.vm.ci.aarch64.AArch64.cpuRegisters;
  31 import static jdk.vm.ci.aarch64.AArch64.r0;
  32 import static jdk.vm.ci.aarch64.AArch64.sp;
  33 import static jdk.vm.ci.aarch64.AArch64.zr;
  34 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADD;
  35 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDS;
  36 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADDV;
  37 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADR;
  38 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ADRP;
  39 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.AND;
  40 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ANDS;
  41 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ASRV;
  42 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BFM;
  43 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BIC;
  44 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BICS;
  45 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BLR;
  46 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BR;
  47 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.BRK;
  48 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CAS;
  49 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CCMP;
  50 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLREX;
  51 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLS;
  52 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CLZ;
  53 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CNT;
  54 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSEL;
  55 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSINC;
  56 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.CSNEG;
  57 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DC;
  58 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.DMB;
  59 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EON;
  60 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EOR;
  61 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.EXTR;
  62 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FABS;
  63 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FADD;
  64 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCCMP;
  65 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMP;
  66 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCMPZERO;
  67 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCSEL;
  68 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTDS;
  69 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTSD;
  70 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FCVTZS;
  71 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FDIV;
  72 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMADD;
  73 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMOV;
  74 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMSUB;
  75 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FMUL;
  76 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FNEG;
  77 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTM;
  78 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTN;
  79 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTP;
  80 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FRINTZ;
  81 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSQRT;
  82 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.FSUB;
  83 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HINT;
  84 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.HLT;
<a name="2" id="anc2"></a><span class="line-added">  85 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ISB;</span>
  86 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDADD;
  87 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAR;
  88 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDAXR;
  89 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDP;
  90 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDR;
  91 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDRS;
  92 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LDXR;
  93 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSLV;
  94 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.LSRV;
  95 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MADD;
  96 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVK;
  97 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVN;
  98 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MOVZ;
  99 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MRS;
 100 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.MSUB;
 101 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORN;
 102 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.ORR;
 103 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RBIT;
 104 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RET;
 105 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVW;
 106 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.REVX;
 107 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.RORV;
 108 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SBFM;
 109 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SCVTF;
 110 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SDIV;
 111 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLR;
 112 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STLXR;
 113 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STP;
 114 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STR;
 115 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.STXR;
 116 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUB;
 117 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SUBS;
 118 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.SWP;
 119 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBNZ;
 120 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.TBZ;
 121 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UBFM;
 122 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UDIV;
 123 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.Instruction.UMOV;
 124 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP32;
 125 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.FP64;
 126 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General32;
 127 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.General64;
 128 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.floatFromSize;
 129 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.generalFromSize;
 130 import static org.graalvm.compiler.asm.aarch64.AArch64Assembler.InstructionType.simdFromSize;
 131 
 132 import java.util.Arrays;
 133 
 134 import org.graalvm.compiler.asm.Assembler;
 135 import org.graalvm.compiler.asm.aarch64.AArch64Address.AddressingMode;
 136 import org.graalvm.compiler.core.common.NumUtil;
 137 import org.graalvm.compiler.debug.GraalError;
 138 
 139 import jdk.vm.ci.aarch64.AArch64;
 140 import jdk.vm.ci.aarch64.AArch64.CPUFeature;
 141 import jdk.vm.ci.aarch64.AArch64.Flag;
 142 import jdk.vm.ci.code.Register;
 143 import jdk.vm.ci.code.TargetDescription;
 144 
 145 public abstract class AArch64Assembler extends Assembler {
 146 
 147     public static class LogicalImmediateTable {
 148 
 149         private static final Immediate[] IMMEDIATE_TABLE = buildImmediateTable();
 150 
 151         private static final int ImmediateOffset = 10;
 152         private static final int ImmediateRotateOffset = 16;
 153         private static final int ImmediateSizeOffset = 22;
 154 
 155         /**
 156          * Specifies whether immediate can be represented in all cases (YES), as a 64bit instruction
 157          * (SIXTY_FOUR_BIT_ONLY) or not at all (NO).
 158          */
 159         enum Representable {
 160             YES,
 161             SIXTY_FOUR_BIT_ONLY,
 162             NO
 163         }
 164 
 165         /**
 166          * Tests whether an immediate can be encoded for logical instructions.
 167          *
 168          * @param is64bit if true immediate is considered a 64-bit pattern. If false we may use a
 169          *            64-bit instruction to load the 32-bit pattern into a register.
 170          * @return enum specifying whether immediate can be used for 32- and 64-bit logical
 171          *         instructions ({@code #Representable.YES}), for 64-bit instructions only (
 172          *         {@link Representable#SIXTY_FOUR_BIT_ONLY}) or not at all (
 173          *         {@link Representable#NO}).
 174          */
 175         public static Representable isRepresentable(boolean is64bit, long immediate) {
 176             int pos = getLogicalImmTablePos(is64bit, immediate);
 177             if (pos &lt; 0) {
 178                 // if 32bit instruction we can try again as 64bit immediate which may succeed.
 179                 // i.e. 0xffffffff fails as a 32bit immediate but works as 64bit one.
 180                 if (!is64bit) {
 181                     assert NumUtil.isUnsignedNbit(32, immediate);
 182                     pos = getLogicalImmTablePos(true, immediate);
 183                     return pos &gt;= 0 ? Representable.SIXTY_FOUR_BIT_ONLY : Representable.NO;
 184                 }
 185                 return Representable.NO;
 186             }
 187             Immediate imm = IMMEDIATE_TABLE[pos];
 188             return imm.only64bit() ? Representable.SIXTY_FOUR_BIT_ONLY : Representable.YES;
 189         }
 190 
 191         public static Representable isRepresentable(int immediate) {
 192             return isRepresentable(false, immediate &amp; 0xFFFF_FFFFL);
 193         }
 194 
 195         public static int getLogicalImmEncoding(boolean is64bit, long value) {
 196             int pos = getLogicalImmTablePos(is64bit, value);
 197             assert pos &gt;= 0 : &quot;Value cannot be represented as logical immediate: &quot; + value + &quot;, is64bit=&quot; + is64bit;
 198             Immediate imm = IMMEDIATE_TABLE[pos];
 199             assert is64bit || !imm.only64bit() : &quot;Immediate can only be represented for 64bit, but 32bit instruction specified&quot;;
 200             return IMMEDIATE_TABLE[pos].encoding;
 201         }
 202 
 203         /**
 204          * @param is64bit if true also allow 64-bit only encodings to be returned.
 205          * @return If positive the return value is the position into the IMMEDIATE_TABLE for the
 206          *         given immediate, if negative the immediate cannot be encoded.
 207          */
 208         private static int getLogicalImmTablePos(boolean is64bit, long value) {
 209             Immediate imm;
 210             if (!is64bit) {
 211                 // 32bit instructions can only have 32bit immediates.
 212                 if (!NumUtil.isUnsignedNbit(32, value)) {
 213                     return -1;
 214                 }
 215                 // If we have a 32bit instruction (and therefore immediate) we have to duplicate it
 216                 // across 64bit to find it in the table.
 217                 imm = new Immediate(value &lt;&lt; 32 | value);
 218             } else {
 219                 imm = new Immediate(value);
 220             }
 221             int pos = Arrays.binarySearch(IMMEDIATE_TABLE, imm);
 222             if (pos &lt; 0) {
 223                 return -1;
 224             }
 225             if (!is64bit &amp;&amp; IMMEDIATE_TABLE[pos].only64bit()) {
 226                 return -1;
 227             }
 228             return pos;
 229         }
 230 
 231         /**
 232          * To quote 5.4.2: [..] an immediate is a 32 or 64 bit pattern viewed as a vector of
 233          * identical elements of size e = 2, 4, 8, 16, 32 or (in the case of bimm64) 64 bits. Each
 234          * element contains the same sub-pattern: a single run of 1 to e-1 non-zero bits, rotated by
 235          * 0 to e-1 bits. It is encoded in the following: 10-16: rotation amount (6bit) starting
 236          * from 1s in the LSB (i.e. 0111-&gt;1011-&gt;1101-&gt;1110) 16-22: This stores a combination of the
 237          * number of set bits and the pattern size. The pattern size is encoded as follows (x is
 238          * used to store the number of 1 bits - 1) e pattern 2 1111xx 4 1110xx 8 110xxx 16 10xxxx 32
 239          * 0xxxxx 64 xxxxxx 22: if set we have an instruction with 64bit pattern?
 240          */
 241         private static final class Immediate implements Comparable&lt;Immediate&gt; {
 242             public final long imm;
 243             public final int encoding;
 244 
 245             Immediate(long imm, boolean is64, int s, int r) {
 246                 this.imm = imm;
 247                 this.encoding = computeEncoding(is64, s, r);
 248             }
 249 
 250             // Used to be able to binary search for an immediate in the table.
 251             Immediate(long imm) {
 252                 this(imm, false, 0, 0);
 253             }
 254 
 255             /**
 256              * Returns true if this pattern is only representable as 64bit.
 257              */
 258             public boolean only64bit() {
 259                 return (encoding &amp; (1 &lt;&lt; ImmediateSizeOffset)) != 0;
 260             }
 261 
 262             private static int computeEncoding(boolean is64, int s, int r) {
 263                 int sf = is64 ? 1 : 0;
 264                 return sf &lt;&lt; ImmediateSizeOffset | r &lt;&lt; ImmediateRotateOffset | s &lt;&lt; ImmediateOffset;
 265             }
 266 
 267             @Override
 268             public int compareTo(Immediate o) {
 269                 return Long.compare(imm, o.imm);
 270             }
 271         }
 272 
 273         private static Immediate[] buildImmediateTable() {
 274             final int nrImmediates = 5334;
 275             final Immediate[] table = new Immediate[nrImmediates];
 276             int nrImms = 0;
 277             for (int logE = 1; logE &lt;= 6; logE++) {
 278                 int e = 1 &lt;&lt; logE;
 279                 long mask = NumUtil.getNbitNumberLong(e);
 280                 for (int nrOnes = 1; nrOnes &lt; e; nrOnes++) {
 281                     long val = (1L &lt;&lt; nrOnes) - 1;
 282                     // r specifies how much we rotate the value
 283                     for (int r = 0; r &lt; e; r++) {
 284                         long immediate = (val &gt;&gt;&gt; r | val &lt;&lt; (e - r)) &amp; mask;
 285                         // Duplicate pattern to fill whole 64bit range.
 286                         switch (logE) {
 287                             case 1:
 288                                 immediate |= immediate &lt;&lt; 2;
 289                                 immediate |= immediate &lt;&lt; 4;
 290                                 immediate |= immediate &lt;&lt; 8;
 291                                 immediate |= immediate &lt;&lt; 16;
 292                                 immediate |= immediate &lt;&lt; 32;
 293                                 break;
 294                             case 2:
 295                                 immediate |= immediate &lt;&lt; 4;
 296                                 immediate |= immediate &lt;&lt; 8;
 297                                 immediate |= immediate &lt;&lt; 16;
 298                                 immediate |= immediate &lt;&lt; 32;
 299                                 break;
 300                             case 3:
 301                                 immediate |= immediate &lt;&lt; 8;
 302                                 immediate |= immediate &lt;&lt; 16;
 303                                 immediate |= immediate &lt;&lt; 32;
 304                                 break;
 305                             case 4:
 306                                 immediate |= immediate &lt;&lt; 16;
 307                                 immediate |= immediate &lt;&lt; 32;
 308                                 break;
 309                             case 5:
 310                                 immediate |= immediate &lt;&lt; 32;
 311                                 break;
 312                         }
 313                         // 5 - logE can underflow to -1, but we shift this bogus result
 314                         // out of the masked area.
 315                         int sizeEncoding = (1 &lt;&lt; (5 - logE)) - 1;
 316                         int s = ((sizeEncoding &lt;&lt; (logE + 1)) &amp; 0x3f) | (nrOnes - 1);
 317                         table[nrImms++] = new Immediate(immediate, /* is64bit */e == 64, s, r);
 318                     }
 319                 }
 320             }
 321             Arrays.sort(table);
 322             assert nrImms == nrImmediates : nrImms + &quot; instead of &quot; + nrImmediates + &quot; in table.&quot;;
 323             assert checkDuplicates(table) : &quot;Duplicate values in table.&quot;;
 324             return table;
 325         }
 326 
 327         private static boolean checkDuplicates(Immediate[] table) {
 328             for (int i = 0; i &lt; table.length - 1; i++) {
 329                 if (table[i].imm &gt;= table[i + 1].imm) {
 330                     return false;
 331                 }
 332             }
 333             return true;
 334         }
 335     }
 336 
 337     private static final int RdOffset = 0;
 338     private static final int Rs1Offset = 5;
 339     private static final int Rs2Offset = 16;
 340     private static final int Rs3Offset = 10;
 341     private static final int RtOffset = 0;
 342     private static final int RnOffset = 5;
 343     private static final int Rt2Offset = 10;
 344 
 345     /* Helper functions */
 346     private static int rd(Register reg) {
 347         return reg.encoding &lt;&lt; RdOffset;
 348     }
 349 
 350     private static int rs1(Register reg) {
 351         return reg.encoding &lt;&lt; Rs1Offset;
 352     }
 353 
 354     private static int rs2(Register reg) {
 355         return reg.encoding &lt;&lt; Rs2Offset;
 356     }
 357 
 358     private static int rs3(Register reg) {
 359         return reg.encoding &lt;&lt; Rs3Offset;
 360     }
 361 
 362     private static int rt(Register reg) {
 363         return reg.encoding &lt;&lt; RtOffset;
 364     }
 365 
 366     private static int rt2(Register reg) {
 367         return reg.encoding &lt;&lt; Rt2Offset;
 368     }
 369 
 370     private static int rn(Register reg) {
 371         return reg.encoding &lt;&lt; RnOffset;
 372     }
 373 
 374     private static int maskField(int sizeInBits, int n) {
 375         assert NumUtil.isSignedNbit(sizeInBits, n);
 376         return n &amp; NumUtil.getNbitNumberInt(sizeInBits);
 377     }
 378 
 379     /**
 380      * Enumeration of all different lane types of SIMD register.
 381      *
 382      * Byte(B):8b/lane; HalfWord(H):16b/lane; Word(S):32b/lane; DoubleWord(D):64b/lane.
 383      */
 384     public enum SIMDElementSize {
 385         Byte(0, 8),
 386         HalfWord(1, 16),
 387         Word(2, 32),
 388         DoubleWord(3, 64);
 389 
 390         public final int encoding;
 391         public final int nbits;
 392 
 393         SIMDElementSize(int encoding, int nbits) {
 394             this.encoding = encoding;
 395             this.nbits = nbits;
 396         }
 397     }
 398 
 399     /**
 400      * Enumeration of all different instruction kinds: General32/64 are the general instructions
 401      * (integer, branch, etc.), for 32-, respectively 64-bit operands. FP32/64 is the encoding for
 402      * the 32/64bit float operations. SIMDByte/HalfWord/Word/DoubleWord is the encoding for SIMD
 403      * instructions
 404      */
 405     protected enum InstructionType {
 406         General32(0b00 &lt;&lt; 30, 32, true),
 407         General64(0b10 &lt;&lt; 30, 64, true),
 408         FP32(0x00000000, 32, false),
 409         FP64(0x00400000, 64, false),
 410 
 411         SIMDByte(0x01, 8, false),
 412         SIMDHalfWord(0x02, 16, false),
 413         SIMDWord(0x04, 32, false),
 414         SIMDDoubleWord(0x08, 64, false);
 415 
 416         public final int encoding;
 417         public final int width;
 418         public final boolean isGeneral;
 419 
 420         InstructionType(int encoding, int width, boolean isGeneral) {
 421             this.encoding = encoding;
 422             this.width = width;
 423             this.isGeneral = isGeneral;
 424         }
 425 
 426         public static InstructionType generalFromSize(int size) {
 427             assert size == 32 || size == 64;
 428             return size == 32 ? General32 : General64;
 429         }
 430 
 431         public static InstructionType floatFromSize(int size) {
 432             assert size == 32 || size == 64;
 433             return size == 32 ? FP32 : FP64;
 434         }
 435 
 436         public static InstructionType simdFromSize(int size) {
 437             switch (size) {
 438                 case 8:
 439                     return SIMDByte;
 440                 case 16:
 441                     return SIMDHalfWord;
 442                 case 32:
 443                     return SIMDWord;
 444                 case 64:
 445                     return SIMDDoubleWord;
 446                 default:
 447                     throw GraalError.shouldNotReachHere();
 448             }
 449         }
 450     }
 451 
 452     private static final int ImmediateOffset = 10;
 453     private static final int ImmediateRotateOffset = 16;
 454     private static final int ImmediateSizeOffset = 22;
 455     private static final int ExtendTypeOffset = 13;
 456 
 457     private static final int AddSubImmOp = 0x11000000;
 458     private static final int AddSubShift12 = 0b01 &lt;&lt; 22;
 459     private static final int AddSubSetFlag = 0x20000000;
 460 
 461     private static final int LogicalImmOp = 0x12000000;
 462 
 463     private static final int MoveWideImmOp = 0x12800000;
 464     private static final int MoveWideImmOffset = 5;
 465     private static final int MoveWideShiftOffset = 21;
 466 
 467     private static final int BitfieldImmOp = 0x13000000;
 468 
 469     private static final int AddSubShiftedOp = 0x0B000000;
 470     private static final int ShiftTypeOffset = 22;
 471 
 472     private static final int AddSubExtendedOp = 0x0B200000;
 473 
 474     private static final int MulOp = 0x1B000000;
 475     private static final int SignedMulLongOp = 0x9B200000;
 476     private static final int DataProcessing1SourceOp = 0x5AC00000;
 477     private static final int DataProcessing2SourceOp = 0x1AC00000;
 478 
 479     private static final int Fp1SourceOp = 0x1E204000;
 480     private static final int Fp2SourceOp = 0x1E200800;
 481     private static final int Fp3SourceOp = 0x1F000000;
 482 
 483     private static final int FpConvertOp = 0x1E200000;
 484     private static final int FpImmOp = 0x1E201000;
 485     private static final int FpImmOffset = 13;
 486 
 487     private static final int FpCmpOp = 0x1E202000;
 488     private static final int FpCmpeOp = 0x1E202010;
 489 
 490     private static final int PcRelImmHiOffset = 5;
 491     private static final int PcRelImmLoOffset = 29;
 492 
 493     private static final int PcRelImmOp = 0x10000000;
 494 
 495     private static final int UnconditionalBranchImmOp = 0x14000000;
 496     private static final int UnconditionalBranchRegOp = 0xD6000000;
 497     private static final int CompareBranchOp = 0x34000000;
 498 
 499     private static final int ConditionalBranchImmOffset = 5;
 500 
 501     private static final int ConditionalSelectOp = 0x1A800000;
 502     private static final int ConditionalConditionOffset = 12;
 503 
 504     private static final int LoadStoreScaledOp = 0b111_0_01_00 &lt;&lt; 22;
 505     private static final int LoadStoreUnscaledOp = 0b111_0_00_00 &lt;&lt; 22;
 506 
 507     private static final int LoadStoreRegisterOp = 0b111_0_00_00_1 &lt;&lt; 21 | 0b10 &lt;&lt; 10;
 508 
 509     private static final int LoadLiteralOp = 0x18000000;
 510 
 511     private static final int LoadStorePostIndexedOp = 0b111_0_00_00_0 &lt;&lt; 21 | 0b01 &lt;&lt; 10;
 512     private static final int LoadStorePreIndexedOp = 0b111_0_00_00_0 &lt;&lt; 21 | 0b11 &lt;&lt; 10;
 513 
 514     private static final int LoadStoreUnscaledImmOffset = 12;
 515     private static final int LoadStoreScaledImmOffset = 10;
 516     private static final int LoadStoreScaledRegOffset = 12;
 517     private static final int LoadStoreIndexedImmOffset = 12;
 518     private static final int LoadStoreTransferSizeOffset = 30;
 519     private static final int LoadStoreFpFlagOffset = 26;
 520     private static final int LoadLiteralImmeOffset = 5;
 521 
 522     private static final int LoadStorePairOp = 0b101_0 &lt;&lt; 26;
 523     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPostIndexOp = 0b101_0_001 &lt;&lt; 23;
 524     @SuppressWarnings(&quot;unused&quot;) private static final int LoadStorePairPreIndexOp = 0b101_0_011 &lt;&lt; 23;
 525     private static final int LoadStorePairImm7Offset = 15;
 526 
 527     private static final int LogicalShiftOp = 0x0A000000;
 528 
 529     private static final int ExceptionOp = 0xD4000000;
 530     private static final int SystemImmediateOffset = 5;
 531 
 532     @SuppressWarnings(&quot;unused&quot;) private static final int SimdImmediateOffset = 16;
 533 
 534     private static final int BarrierOp = 0xD503301F;
 535     private static final int BarrierKindOffset = 8;
 536 
 537     private static final int CASAcquireOffset = 22;
 538     private static final int CASReleaseOffset = 15;
 539 
 540     private static final int LDADDAcquireOffset = 23;
 541     private static final int LDADDReleaseOffset = 22;
 542 
 543     private static final int SIMDImm5Offset = 16;
 544     private static final int SIMDQBitOffset = 30;
 545     private static final int SIMDSizeOffset = 22;
 546 
 547     /**
 548      * Encoding for all instructions.
 549      */
 550     public enum Instruction {
 551         BCOND(0x54000000),
 552         CBNZ(0x01000000),
 553         CBZ(0x00000000),
 554         TBZ(0x36000000),
 555         TBNZ(0x37000000),
 556 
 557         B(0x00000000),
 558         BL(0x80000000),
 559         BR(0x001F0000),
 560         BLR(0x003F0000),
 561         RET(0x005F0000),
 562 
 563         LDR(0x00000000),
 564         LDRS(0x00800000),
 565         LDXR(0x081f7c00),
 566         LDAR(0x8dffc00),
 567         LDAXR(0x85ffc00),
 568 
 569         STR(0x00000000),
 570         STXR(0x08007c00),
 571         STLR(0x089ffc00),
 572         STLXR(0x0800fc00),
 573 
 574         LDP(0b1 &lt;&lt; 22),
 575         STP(0b0 &lt;&lt; 22),
 576 
 577         CAS(0x08A07C00),
 578         LDADD(0x38200000),
 579         SWP(0x38208000),
 580 
 581         ADR(0x00000000),
 582         ADRP(0x80000000),
 583 
 584         ADD(0x00000000),
 585         ADDS(ADD.encoding | AddSubSetFlag),
 586         SUB(0x40000000),
 587         SUBS(SUB.encoding | AddSubSetFlag),
 588 
 589         CCMP(0x7A400000),
 590 
 591         NOT(0x00200000),
 592         AND(0x00000000),
 593         BIC(AND.encoding | NOT.encoding),
 594         ORR(0x20000000),
 595         ORN(ORR.encoding | NOT.encoding),
 596         EOR(0x40000000),
 597         EON(EOR.encoding | NOT.encoding),
 598         ANDS(0x60000000),
 599         BICS(ANDS.encoding | NOT.encoding),
 600 
 601         ASRV(0x00002800),
 602         RORV(0x00002C00),
 603         LSRV(0x00002400),
 604         LSLV(0x00002000),
 605 
 606         CLS(0x00001400),
 607         CLZ(0x00001000),
 608         RBIT(0x00000000),
 609         REVX(0x00000C00),
 610         REVW(0x00000800),
 611 
 612         MOVN(0x00000000),
 613         MOVZ(0x40000000),
 614         MOVK(0x60000000),
 615 
 616         CSEL(0x00000000),
 617         CSNEG(0x40000400),
 618         CSINC(0x00000400),
 619 
 620         BFM(0x20000000),
 621         SBFM(0x00000000),
 622         UBFM(0x40000000),
 623         EXTR(0x13800000),
 624 
 625         MADD(0x00000000),
 626         MSUB(0x00008000),
 627         SDIV(0x00000C00),
 628         UDIV(0x00000800),
 629 
 630         FMOV(0x00000000),
 631         FMOVCPU2FPU(0x00070000),
 632         FMOVFPU2CPU(0x00060000),
 633 
 634         FCVTDS(0x00028000),
 635         FCVTSD(0x00020000),
 636 
 637         FCVTZS(0x00180000),
 638         SCVTF(0x00020000),
 639 
 640         FABS(0x00008000),
 641         FSQRT(0x00018000),
 642         FNEG(0x00010000),
 643 
 644         FRINTM(0x00050000),
 645         FRINTN(0x00040000),
 646         FRINTP(0x00048000),
 647         FRINTZ(0x00058000),
 648 
 649         FADD(0x00002000),
 650         FSUB(0x00003000),
 651         FMUL(0x00000000),
 652         FDIV(0x00001000),
 653         FMAX(0x00004000),
 654         FMIN(0x00005000),
 655 
 656         FMADD(0x00000000),
 657         FMSUB(0x00008000),
 658 
 659         FCMP(0x00000000),
 660         FCMPZERO(0x00000008),
 661         FCCMP(0x1E200400),
 662         FCSEL(0x1E200C00),
 663 
 664         INS(0x4e081c00),
 665         UMOV(0x0e003c00),
 666 
 667         CNT(0xe205800),
 668         USRA(0x6f001400),
 669 
 670         HLT(0x00400000),
 671         BRK(0x00200000),
 672 
 673         CLREX(0xd5033f5f),
 674         HINT(0xD503201F),
 675         DMB(0x000000A0),
 676 
 677         MRS(0xD5300000),
 678         MSR(0xD5100000),
 679         DC(0xD5087000),
<a name="3" id="anc3"></a><span class="line-added"> 680         ISB(0x000000C0),</span>
 681 
 682         BLR_NATIVE(0xc0000000),
 683 
 684         ADDV(0x0e31b800);
 685 
 686         public final int encoding;
 687 
 688         Instruction(int encoding) {
 689             this.encoding = encoding;
 690         }
 691 
 692     }
 693 
 694     public enum SystemRegister {
 695         FPCR(0b11, 0b011, 0b0100, 0b0100, 0b000),
 696         FPSR(0b11, 0b011, 0b0100, 0b0100, 0b001);
 697 
 698         SystemRegister(int op0, int op1, int crn, int crm, int op2) {
 699             this.op0 = op0;
 700             this.op1 = op1;
 701             this.crn = crn;
 702             this.crm = crm;
 703             this.op2 = op2;
 704         }
 705 
 706         public int encoding() {
 707             return op0 &lt;&lt; 19 | op1 &lt;&lt; 16 | crn &lt;&lt; 12 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;
 708         }
 709 
 710         private final int op0;
 711         private final int op1;
 712         private final int crn;
 713         private final int crm;
 714         private final int op2;
 715     }
 716 
 717     public enum DataCacheOperationType {
 718         ZVA(0b011, 0b0100, 0b001);
 719 
 720         DataCacheOperationType(int op1, int crm, int op2) {
 721             this.op1 = op1;
 722             this.crm = crm;
 723             this.op2 = op2;
 724         }
 725 
 726         public int encoding() {
 727             return op1 &lt;&lt; 16 | crm &lt;&lt; 8 | op2 &lt;&lt; 5;
 728         }
 729 
 730         private final int op1;
 731         private final int crm;
 732         private final int op2;
 733     }
 734 
 735     public enum ShiftType {
 736         LSL(0),
 737         LSR(1),
 738         ASR(2),
 739         ROR(3);
 740 
 741         public final int encoding;
 742 
 743         ShiftType(int encoding) {
 744             this.encoding = encoding;
 745         }
 746     }
 747 
 748     public enum ExtendType {
 749         UXTB(0),
 750         UXTH(1),
 751         UXTW(2),
 752         UXTX(3),
 753         SXTB(4),
 754         SXTH(5),
 755         SXTW(6),
 756         SXTX(7);
 757 
 758         public final int encoding;
 759 
 760         ExtendType(int encoding) {
 761             this.encoding = encoding;
 762         }
 763     }
 764 
 765     /**
 766      * Condition Flags for branches. See 4.3
 767      */
 768     public enum ConditionFlag {
 769         // Integer | Floating-point meanings
 770         /** Equal | Equal. */
 771         EQ(0x0),
 772 
 773         /** Not Equal | Not equal or unordered. */
 774         NE(0x1),
 775 
 776         /** Unsigned Higher or Same | Greater than, equal or unordered. */
 777         HS(0x2),
 778 
 779         /** Unsigned lower | less than. */
 780         LO(0x3),
 781 
 782         /** Minus (negative) | less than. */
 783         MI(0x4),
 784 
 785         /** Plus (positive or zero) | greater than, equal or unordered. */
 786         PL(0x5),
 787 
 788         /** Overflow set | unordered. */
 789         VS(0x6),
 790 
 791         /** Overflow clear | ordered. */
 792         VC(0x7),
 793 
 794         /** Unsigned higher | greater than or unordered. */
 795         HI(0x8),
 796 
 797         /** Unsigned lower or same | less than or equal. */
 798         LS(0x9),
 799 
 800         /** Signed greater than or equal | greater than or equal. */
 801         GE(0xA),
 802 
 803         /** Signed less than | less than or unordered. */
 804         LT(0xB),
 805 
 806         /** Signed greater than | greater than. */
 807         GT(0xC),
 808 
 809         /** Signed less than or equal | less than, equal or unordered. */
 810         LE(0xD),
 811 
 812         /** Always | always. */
 813         AL(0xE),
 814 
 815         /** Always | always (identical to AL, just to have valid 0b1111 encoding). */
 816         NV(0xF);
 817 
 818         public final int encoding;
 819 
 820         ConditionFlag(int encoding) {
 821             this.encoding = encoding;
 822         }
 823 
 824         /**
 825          * @return ConditionFlag specified by decoding.
 826          */
 827         public static ConditionFlag fromEncoding(int encoding) {
 828             return values()[encoding];
 829         }
 830 
 831         public ConditionFlag negate() {
 832             switch (this) {
 833                 case EQ:
 834                     return NE;
 835                 case NE:
 836                     return EQ;
 837                 case HS:
 838                     return LO;
 839                 case LO:
 840                     return HS;
 841                 case MI:
 842                     return PL;
 843                 case PL:
 844                     return MI;
 845                 case VS:
 846                     return VC;
 847                 case VC:
 848                     return VS;
 849                 case HI:
 850                     return LS;
 851                 case LS:
 852                     return HI;
 853                 case GE:
 854                     return LT;
 855                 case LT:
 856                     return GE;
 857                 case GT:
 858                     return LE;
 859                 case LE:
 860                     return GT;
 861                 case AL:
 862                 case NV:
 863                 default:
 864                     throw GraalError.shouldNotReachHere();
 865             }
 866         }
 867     }
 868 
 869     public AArch64Assembler(TargetDescription target) {
 870         super(target);
 871     }
 872 
 873     public boolean supports(CPUFeature feature) {
 874         return ((AArch64) target.arch).getFeatures().contains(feature);
 875     }
 876 
 877     public boolean isFlagSet(Flag flag) {
 878         return ((AArch64) target.arch).getFlags().contains(flag);
 879     }
 880 
 881     /* Conditional Branch (5.2.1) */
 882 
 883     /**
 884      * Branch conditionally.
 885      *
 886      * @param condition may not be null.
 887      * @param imm21 Signed 21-bit offset, has to be word aligned.
 888      */
 889     protected void b(ConditionFlag condition, int imm21) {
 890         b(condition, imm21, -1);
 891     }
 892 
 893     /**
 894      * Branch conditionally. Inserts instruction into code buffer at pos.
 895      *
 896      * @param condition may not be null.
 897      * @param imm21 Signed 21-bit offset, has to be word aligned.
 898      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 899      */
 900     protected void b(ConditionFlag condition, int imm21, int pos) {
 901         if (pos == -1) {
 902             emitInt(Instruction.BCOND.encoding | getConditionalBranchImm(imm21) | condition.encoding);
 903         } else {
 904             emitInt(Instruction.BCOND.encoding | getConditionalBranchImm(imm21) | condition.encoding, pos);
 905         }
 906     }
 907 
 908     /**
 909      * Compare register and branch if non-zero.
 910      *
 911      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 912      * @param size Instruction size in bits. Should be either 32 or 64.
 913      * @param imm21 Signed 21-bit offset, has to be word aligned.
 914      */
 915     protected void cbnz(int size, Register reg, int imm21) {
 916         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBNZ, -1);
 917     }
 918 
 919     /**
 920      * Compare register and branch if non-zero.
 921      *
 922      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 923      * @param size Instruction size in bits. Should be either 32 or 64.
 924      * @param imm21 Signed 21-bit offset, has to be word aligned.
 925      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 926      */
 927     protected void cbnz(int size, Register reg, int imm21, int pos) {
 928         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBNZ, pos);
 929     }
 930 
 931     /**
 932      * Compare and branch if zero.
 933      *
 934      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 935      * @param size Instruction size in bits. Should be either 32 or 64.
 936      * @param imm21 Signed 21-bit offset, has to be word aligned.
 937      */
 938     protected void cbz(int size, Register reg, int imm21) {
 939         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBZ, -1);
 940     }
 941 
 942     /**
 943      * Compare register and branch if zero.
 944      *
 945      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 946      * @param size Instruction size in bits. Should be either 32 or 64.
 947      * @param imm21 Signed 21-bit offset, has to be word aligned.
 948      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 949      */
 950     protected void cbz(int size, Register reg, int imm21, int pos) {
 951         conditionalBranchInstruction(reg, imm21, generalFromSize(size), Instruction.CBZ, pos);
 952     }
 953 
 954     /**
 955      * Test a single bit and branch if the bit is nonzero.
 956      *
 957      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 958      * @param uimm6 Unsigned 6-bit bit index.
 959      * @param imm16 signed 16 bit offset
 960      */
 961     protected void tbnz(Register reg, int uimm6, int imm16) {
 962         tbnz(reg, uimm6, imm16, -1);
 963     }
 964 
 965     /**
 966      * Test a single bit and branch if the bit is zero.
 967      *
 968      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 969      * @param uimm6 Unsigned 6-bit bit index.
 970      * @param imm16 signed 16 bit offset
 971      */
 972     protected void tbz(Register reg, int uimm6, int imm16) {
 973         tbz(reg, uimm6, imm16, -1);
 974     }
 975 
 976     /**
 977      * Test a single bit and branch if the bit is nonzero.
 978      *
 979      * @param reg general purpose register. May not be null, zero-register or stackpointer.
 980      * @param uimm6 Unsigned 6-bit bit index.
 981      * @param imm16 signed 16 bit offset
 982      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
 983      */
 984     protected void tbnz(Register reg, int uimm6, int imm16, int pos) {
 985         assert reg.getRegisterCategory().equals(CPU);
 986         assert NumUtil.isUnsignedNbit(6, uimm6);
 987         assert NumUtil.isSignedNbit(16, imm16) : String.format(&quot;Offset value must fit in 16 bits signed: 0x%x&quot;, imm16);
 988         assert (imm16 &amp; 3) == 0 : String.format(&quot;Lower two bits must be zero: 0x%x&quot;, imm16 &amp; 3);
 989         // size bit is overloaded as top bit of uimm6 bit index
 990         int size = (((uimm6 &gt;&gt; 5) &amp; 1) == 0 ? 32 : 64);
 991         // remaining 5 bits are encoded lower down
 992         int uimm5 = uimm6 &amp; 0x1F;
 993         int imm14 = (imm16 &amp; NumUtil.getNbitNumberInt(16)) &gt;&gt; 2;
 994         InstructionType type = generalFromSize(size);
 995         int encoding = type.encoding | TBNZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
 996         if (pos == -1) {
 997             emitInt(encoding);
 998         } else {
 999             emitInt(encoding, pos);
1000         }
1001     }
1002 
1003     /**
1004      * Test a single bit and branch if the bit is zero.
1005      *
1006      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1007      * @param uimm6 Unsigned 6-bit bit index.
1008      * @param imm16 signed 16 bit offset
1009      * @param pos Position at which instruction is inserted into buffer. -1 means insert at end.
1010      */
1011     protected void tbz(Register reg, int uimm6, int imm16, int pos) {
1012         assert reg.getRegisterCategory().equals(CPU);
1013         assert NumUtil.isUnsignedNbit(6, uimm6);
1014         assert NumUtil.isSignedNbit(16, imm16) : String.format(&quot;Offset value must fit in 16 bits signed: 0x%x&quot;, imm16);
1015         assert (imm16 &amp; 3) == 0 : String.format(&quot;Lower two bits must be zero: 0x%x&quot;, imm16 &amp; 3);
1016         // size bit is overloaded as top bit of uimm6 bit index
1017         int size = (((uimm6 &gt;&gt; 5) &amp; 1) == 0 ? 32 : 64);
1018         // remaining 5 bits are encoded lower down
1019         int uimm5 = uimm6 &amp; 0x1F;
1020         int imm14 = (imm16 &amp; NumUtil.getNbitNumberInt(16)) &gt;&gt; 2;
1021         InstructionType type = generalFromSize(size);
1022         int encoding = type.encoding | TBZ.encoding | (uimm5 &lt;&lt; 19) | (imm14 &lt;&lt; 5) | rd(reg);
1023         if (pos == -1) {
1024             emitInt(encoding);
1025         } else {
1026             emitInt(encoding, pos);
1027         }
1028     }
1029 
1030     private void conditionalBranchInstruction(Register reg, int imm21, InstructionType type, Instruction instr, int pos) {
1031         assert reg.getRegisterCategory().equals(CPU);
1032         int instrEncoding = instr.encoding | CompareBranchOp;
1033         if (pos == -1) {
1034             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg));
1035         } else {
1036             emitInt(type.encoding | instrEncoding | getConditionalBranchImm(imm21) | rd(reg), pos);
1037         }
1038     }
1039 
1040     private static int getConditionalBranchImm(int imm21) {
1041         assert NumUtil.isSignedNbit(21, imm21) &amp;&amp; (imm21 &amp; 0x3) == 0 : String.format(&quot;Immediate has to be 21bit signed number and word aligned got value 0x%x&quot;, imm21);
1042         int imm = (imm21 &amp; NumUtil.getNbitNumberInt(21)) &gt;&gt; 2;
1043         return imm &lt;&lt; ConditionalBranchImmOffset;
1044     }
1045 
1046     /* Unconditional Branch (immediate) (5.2.2) */
1047 
1048     /**
1049      * @param imm28 Signed 28-bit offset, has to be word aligned.
1050      */
1051     protected void b(int imm28) {
1052         unconditionalBranchImmInstruction(imm28, Instruction.B, -1);
1053     }
1054 
1055     /**
1056      *
1057      * @param imm28 Signed 28-bit offset, has to be word aligned.
1058      * @param pos Position where instruction is inserted into code buffer.
1059      */
1060     protected void b(int imm28, int pos) {
1061         unconditionalBranchImmInstruction(imm28, Instruction.B, pos);
1062     }
1063 
1064     /**
1065      * Branch and link return address to register X30.
1066      *
1067      * @param imm28 Signed 28-bit offset, has to be word aligned.
1068      */
1069     public void bl(int imm28) {
1070         unconditionalBranchImmInstruction(imm28, Instruction.BL, -1);
1071     }
1072 
1073     private void unconditionalBranchImmInstruction(int imm28, Instruction instr, int pos) {
1074         assert NumUtil.isSignedNbit(28, imm28) &amp;&amp; (imm28 &amp; 0x3) == 0 : &quot;Immediate has to be 28bit signed number and word aligned&quot;;
1075         int imm = (imm28 &amp; NumUtil.getNbitNumberInt(28)) &gt;&gt; 2;
1076         int instrEncoding = instr.encoding | UnconditionalBranchImmOp;
1077         if (pos == -1) {
1078             annotatePatchingImmediate(position(), instr, 26, 0, 2);
1079             emitInt(instrEncoding | imm);
1080         } else {
1081             annotatePatchingImmediate(pos, instr, 26, 0, 2);
1082             emitInt(instrEncoding | imm, pos);
1083         }
1084     }
1085 
1086     /* Unconditional Branch (register) (5.2.3) */
1087 
1088     /**
1089      * Branches to address in register and writes return address into register X30.
1090      *
1091      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1092      */
1093     public void blr(Register reg) {
1094         unconditionalBranchRegInstruction(BLR, reg);
1095     }
1096 
1097     /**
1098      * Branches to address in register.
1099      *
1100      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1101      */
1102     protected void br(Register reg) {
1103         unconditionalBranchRegInstruction(BR, reg);
1104     }
1105 
1106     /**
1107      * Return to address in register.
1108      *
1109      * @param reg general purpose register. May not be null, zero-register or stackpointer.
1110      */
1111     public void ret(Register reg) {
1112         unconditionalBranchRegInstruction(RET, reg);
1113     }
1114 
1115     private void unconditionalBranchRegInstruction(Instruction instr, Register reg) {
1116         assert reg.getRegisterCategory().equals(CPU);
1117         assert !reg.equals(zr);
1118         assert !reg.equals(sp);
1119         emitInt(instr.encoding | UnconditionalBranchRegOp | rs1(reg));
1120 
1121     }
1122 
1123     /* Load-Store Single Register (5.3.1) */
1124 
1125     /**
1126      * Loads a srcSize value from address into rt zero-extending it.
1127      *
1128      * @param srcSize size of memory read in bits. Must be 8, 16, 32 or 64.
1129      * @param rt general purpose register. May not be null or stackpointer.
1130      * @param address all addressing modes allowed. May not be null.
1131      */
1132     public void ldr(int srcSize, Register rt, AArch64Address address) {
1133         assert rt.getRegisterCategory().equals(CPU);
1134         assert srcSize == 8 || srcSize == 16 || srcSize == 32 || srcSize == 64;
1135         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1136         loadStoreInstruction(LDR, rt, address, General32, transferSize);
1137     }
1138 
1139     /**
1140      * Loads a srcSize value from address into rt sign-extending it.
1141      *
1142      * @param targetSize size of target register in bits. Must be 32 or 64.
1143      * @param srcSize size of memory read in bits. Must be 8, 16 or 32, but may not be equivalent to
1144      *            targetSize.
1145      * @param rt general purpose register. May not be null or stackpointer.
1146      * @param address all addressing modes allowed. May not be null.
1147      */
1148     protected void ldrs(int targetSize, int srcSize, Register rt, AArch64Address address) {
1149         assert rt.getRegisterCategory().equals(CPU);
1150         assert (srcSize == 8 || srcSize == 16 || srcSize == 32) &amp;&amp; srcSize != targetSize;
1151         int transferSize = NumUtil.log2Ceil(srcSize / 8);
1152         loadStoreInstruction(LDRS, rt, address, generalFromSize(targetSize), transferSize);
1153     }
1154 
1155     public enum PrefetchMode {
1156         PLDL1KEEP(0b00000),
1157         PLDL1STRM(0b00001),
1158         PLDL2KEEP(0b00010),
1159         PLDL2STRM(0b00011),
1160         PLDL3KEEP(0b00100),
1161         PLDL3STRM(0b00101),
1162 
1163         PLIL1KEEP(0b01000),
1164         PLIL1STRM(0b01001),
1165         PLIL2KEEP(0b01010),
1166         PLIL2STRM(0b01011),
1167         PLIL3KEEP(0b01100),
1168         PLIL3STRM(0b01101),
1169 
1170         PSTL1KEEP(0b10000),
1171         PSTL1STRM(0b10001),
1172         PSTL2KEEP(0b10010),
1173         PSTL2STRM(0b10011),
1174         PSTL3KEEP(0b10100),
1175         PSTL3STRM(0b10101);
1176 
1177         private final int encoding;
1178 
1179         PrefetchMode(int encoding) {
1180             this.encoding = encoding;
1181         }
1182 
1183         private static PrefetchMode[] modes = {
1184                         PLDL1KEEP,
1185                         PLDL1STRM,
1186                         PLDL2KEEP,
1187                         PLDL2STRM,
1188                         PLDL3KEEP,
1189                         PLDL3STRM,
1190 
1191                         null,
1192                         null,
1193 
1194                         PLIL1KEEP,
1195                         PLIL1STRM,
1196                         PLIL2KEEP,
1197                         PLIL2STRM,
1198                         PLIL3KEEP,
1199                         PLIL3STRM,
1200 
1201                         null,
1202                         null,
1203 
1204                         PSTL1KEEP,
1205                         PSTL1STRM,
1206                         PSTL2KEEP,
1207                         PSTL2STRM,
1208                         PSTL3KEEP,
1209                         PSTL3STRM
1210         };
1211 
1212         public static PrefetchMode lookup(int enc) {
1213             assert enc &gt;= 00 &amp;&amp; enc &lt; modes.length;
1214             return modes[enc];
1215         }
1216 
1217         public Register toRegister() {
1218             return cpuRegisters.get(encoding);
1219         }
1220     }
1221 
1222     /*
1223      * implements a prefetch at a 64-bit aligned address using a scaled 12 bit or unscaled 9 bit
1224      * displacement addressing mode
1225      *
1226      * @param rt general purpose register. May not be null, zr or stackpointer.
1227      *
1228      * @param address only displacement addressing modes allowed. May not be null.
1229      */
1230     public void prfm(AArch64Address address, PrefetchMode mode) {
1231         assert (address.getAddressingMode() == AddressingMode.IMMEDIATE_SCALED ||
1232                         address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED ||
1233                         address.getAddressingMode() == AddressingMode.REGISTER_OFFSET);
1234         assert mode != null;
1235         final int srcSize = 64;
1236         final int transferSize = NumUtil.log2Ceil(srcSize / 8);
1237         final Register rt = mode.toRegister();
1238         // this looks weird but that&#39;s because loadStoreInstruction is weird
1239         // instruction select fields are size [31:30], v [26] and opc [25:24]
1240         // prfm requires size == 0b11, v == 0b0 and opc == 0b11
1241         // passing LDRS ensures opc[1] == 0b1
1242         // (n.b. passing LDR/STR makes no difference to opc[1:0]!!)
1243         // passing General64 ensures opc[0] == 0b1 and v = 0b0
1244         // (n.b. passing General32 ensures opc[0] == 0b0 and v = 0b0)
1245         // srcSize 64 ensures size == 0b11
1246         loadStoreInstruction(LDRS, rt, address, General64, transferSize);
1247     }
1248 
1249     /**
1250      * Stores register rt into memory pointed by address.
1251      *
1252      * @param destSize number of bits written to memory. Must be 8, 16, 32 or 64.
1253      * @param rt general purpose register. May not be null or stackpointer.
1254      * @param address all addressing modes allowed. May not be null.
1255      */
1256     public void str(int destSize, Register rt, AArch64Address address) {
1257         assert rt.getRegisterCategory().equals(CPU) : rt;
1258         assert destSize == 8 || destSize == 16 || destSize == 32 || destSize == 64;
1259         int transferSize = NumUtil.log2Ceil(destSize / 8);
1260         loadStoreInstruction(STR, rt, address, General64, transferSize);
1261     }
1262 
1263     private void loadStoreInstruction(Instruction instr, Register reg, AArch64Address address, InstructionType type, int log2TransferSize) {
1264         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1265         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1266         int is32Bit = type.width == 32 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1267         int isFloat = !type.isGeneral ? 1 &lt;&lt; LoadStoreFpFlagOffset : 0;
1268         int memop = instr.encoding | transferSizeEncoding | is32Bit | isFloat | rt(reg);
1269         switch (address.getAddressingMode()) {
1270             case IMMEDIATE_SCALED:
1271                 annotatePatchingImmediate(position(), instr, 12, LoadStoreScaledImmOffset, log2TransferSize);
1272                 emitInt(memop | LoadStoreScaledOp | address.getImmediate() &lt;&lt; LoadStoreScaledImmOffset | rs1(address.getBase()));
1273                 break;
1274             case IMMEDIATE_UNSCALED:
1275                 annotatePatchingImmediate(position(), instr, 9, LoadStoreUnscaledImmOffset, 0);
1276                 emitInt(memop | LoadStoreUnscaledOp | address.getImmediate() &lt;&lt; LoadStoreUnscaledImmOffset | rs1(address.getBase()));
1277                 break;
1278             case BASE_REGISTER_ONLY:
1279                 emitInt(memop | LoadStoreScaledOp | rs1(address.getBase()));
1280                 break;
1281             case EXTENDED_REGISTER_OFFSET:
1282             case REGISTER_OFFSET:
1283                 ExtendType extendType = address.getAddressingMode() == AddressingMode.EXTENDED_REGISTER_OFFSET ? address.getExtendType() : ExtendType.UXTX;
1284                 boolean shouldScale = address.isScaled() &amp;&amp; log2TransferSize != 0;
1285                 emitInt(memop | LoadStoreRegisterOp | rs2(address.getOffset()) | extendType.encoding &lt;&lt; ExtendTypeOffset | (shouldScale ? 1 : 0) &lt;&lt; LoadStoreScaledRegOffset | rs1(address.getBase()));
1286                 break;
1287             case PC_LITERAL:
1288                 assert log2TransferSize &gt;= 2 : &quot;PC literal loads only works for load/stores of 32-bit and larger&quot;;
1289                 transferSizeEncoding = (log2TransferSize - 2) &lt;&lt; LoadStoreTransferSizeOffset;
1290                 annotatePatchingImmediate(position(), instr, 21, LoadLiteralImmeOffset, 2);
1291                 emitInt(transferSizeEncoding | isFloat | LoadLiteralOp | rd(reg) | address.getImmediate() &lt;&lt; LoadLiteralImmeOffset);
1292                 break;
1293             case IMMEDIATE_POST_INDEXED:
1294                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);
1295                 emitInt(memop | LoadStorePostIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1296                 break;
1297             case IMMEDIATE_PRE_INDEXED:
1298                 annotatePatchingImmediate(position(), instr, 9, LoadStoreIndexedImmOffset, 0);
1299                 emitInt(memop | LoadStorePreIndexedOp | rs1(address.getBase()) | address.getImmediate() &lt;&lt; LoadStoreIndexedImmOffset);
1300                 break;
1301             default:
1302                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1303         }
1304     }
1305 
1306     /**
1307      * Insert ldp/stp at the specified position.
1308      */
1309     protected void insertLdpStp(int size, Instruction instr, Register rt, Register rt2, Register base, int offset, int position) {
1310         InstructionType type = generalFromSize(size);
1311         int scaledOffset = maskField(7, offset);
1312         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(base) | rt(rt);
1313         emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23), position);
1314     }
1315 
1316     /**
1317      * Load Pair of Registers calculates an address from a base register value and an immediate
1318      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1319      * two registers.
1320      */
1321     public void ldp(int size, Register rt, Register rt2, AArch64Address address) {
1322         assert size == 32 || size == 64;
1323         loadStorePairInstruction(size, LDP, rt, rt2, address);
1324     }
1325 
1326     /**
1327      * Store Pair of Registers calculates an address from a base register value and an immediate
1328      * offset, and stores two 32-bit words or two 64-bit doublewords to the calculated address, from
1329      * two registers.
1330      */
1331     public void stp(int size, Register rt, Register rt2, AArch64Address address) {
1332         assert size == 32 || size == 64;
1333         loadStorePairInstruction(size, STP, rt, rt2, address);
1334     }
1335 
1336     private void loadStorePairInstruction(int size, Instruction instr, Register rt, Register rt2, AArch64Address address) {
1337         InstructionType type = generalFromSize(size);
1338         // LDP/STP uses a 7-bit scaled offset
1339         int offset = address.getImmediateRaw();
1340         if (address.getAddressingMode() == AddressingMode.IMMEDIATE_UNSCALED) {
1341             int sizeInBytes = size / Byte.SIZE;
1342             long mask = sizeInBytes - 1;
1343             assert (offset &amp; mask) == 0 : &quot;LDP/STP only supports aligned offset.&quot;;
1344             offset = offset / sizeInBytes;
1345         }
1346         int scaledOffset = maskField(7, offset);
1347         int memop = type.encoding | instr.encoding | scaledOffset &lt;&lt; LoadStorePairImm7Offset | rt2(rt2) | rn(address.getBase()) | rt(rt);
1348         switch (address.getAddressingMode()) {
1349             case IMMEDIATE_SCALED:
1350             case IMMEDIATE_UNSCALED:
1351                 emitInt(memop | LoadStorePairOp | (0b010 &lt;&lt; 23));
1352                 break;
1353             case IMMEDIATE_POST_INDEXED:
1354                 emitInt(memop | LoadStorePairOp | (0b001 &lt;&lt; 23));
1355                 break;
1356             case IMMEDIATE_PRE_INDEXED:
1357                 emitInt(memop | LoadStorePairOp | (0b011 &lt;&lt; 23));
1358                 break;
1359             default:
1360                 throw GraalError.shouldNotReachHere(&quot;Unhandled addressing mode: &quot; + address.getAddressingMode());
1361         }
1362     }
1363 
1364     /* Load-Store Exclusive (5.3.6) */
1365 
1366     /**
1367      * Load address exclusive. Natural alignment of address is required.
1368      *
1369      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1370      * @param rt general purpose register. May not be null or stackpointer.
1371      * @param rn general purpose register.
1372      */
1373     protected void ldxr(int size, Register rt, Register rn) {
1374         assert size == 8 || size == 16 || size == 32 || size == 64;
1375         int transferSize = NumUtil.log2Ceil(size / 8);
1376         exclusiveLoadInstruction(LDXR, rt, rn, transferSize);
1377     }
1378 
1379     /**
1380      * Store address exclusive. Natural alignment of address is required. rs and rt may not point to
1381      * the same register.
1382      *
1383      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1384      * @param rs general purpose register. Set to exclusive access status. 0 means success,
1385      *            everything else failure. May not be null, or stackpointer.
1386      * @param rt general purpose register. May not be null or stackpointer.
1387      * @param rn general purpose register.
1388      */
1389     protected void stxr(int size, Register rs, Register rt, Register rn) {
1390         assert size == 8 || size == 16 || size == 32 || size == 64;
1391         int transferSize = NumUtil.log2Ceil(size / 8);
1392         exclusiveStoreInstruction(STXR, rs, rt, rn, transferSize);
1393     }
1394 
1395     /* Load-Acquire/Store-Release (5.3.7) */
1396 
1397     /* non exclusive access */
1398     /**
1399      * Load acquire. Natural alignment of address is required.
1400      *
1401      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1402      * @param rt general purpose register. May not be null or stackpointer.
1403      * @param rn general purpose register.
1404      */
1405     protected void ldar(int size, Register rt, Register rn) {
1406         assert size == 8 || size == 16 || size == 32 || size == 64;
1407         int transferSize = NumUtil.log2Ceil(size / 8);
1408         exclusiveLoadInstruction(LDAR, rt, rn, transferSize);
1409     }
1410 
1411     /**
1412      * Store-release. Natural alignment of address is required.
1413      *
1414      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1415      * @param rt general purpose register. May not be null or stackpointer.
1416      * @param rn general purpose register.
1417      */
1418     protected void stlr(int size, Register rt, Register rn) {
1419         assert size == 8 || size == 16 || size == 32 || size == 64;
1420         int transferSize = NumUtil.log2Ceil(size / 8);
1421         // Hack: Passing the zero-register means it is ignored when building the encoding.
1422         exclusiveStoreInstruction(STLR, r0, rt, rn, transferSize);
1423     }
1424 
1425     /* exclusive access */
1426     /**
1427      * Load acquire exclusive. Natural alignment of address is required.
1428      *
1429      * @param size size of memory read in bits. Must be 8, 16, 32 or 64.
1430      * @param rt general purpose register. May not be null or stackpointer.
1431      * @param rn general purpose register.
1432      */
1433     public void ldaxr(int size, Register rt, Register rn) {
1434         assert size == 8 || size == 16 || size == 32 || size == 64;
1435         int transferSize = NumUtil.log2Ceil(size / 8);
1436         exclusiveLoadInstruction(LDAXR, rt, rn, transferSize);
1437     }
1438 
1439     /**
1440      * Store-release exclusive. Natural alignment of address is required. rs and rt may not point to
1441      * the same register.
1442      *
1443      * @param size size of bits written to memory. Must be 8, 16, 32 or 64.
1444      * @param rs general purpose register. Set to exclusive access status. 0 means success,
1445      *            everything else failure. May not be null, or stackpointer.
1446      * @param rt general purpose register. May not be null or stackpointer.
1447      * @param rn general purpose register.
1448      */
1449     public void stlxr(int size, Register rs, Register rt, Register rn) {
1450         assert size == 8 || size == 16 || size == 32 || size == 64;
1451         int transferSize = NumUtil.log2Ceil(size / 8);
1452         exclusiveStoreInstruction(STLXR, rs, rt, rn, transferSize);
1453     }
1454 
1455     private void exclusiveLoadInstruction(Instruction instr, Register reg, Register rn, int log2TransferSize) {
1456         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1457         assert reg.getRegisterCategory().equals(CPU);
1458         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1459         emitInt(transferSizeEncoding | instr.encoding | 1 &lt;&lt; ImmediateSizeOffset | rn(rn) | rt(reg));
1460     }
1461 
1462     /**
1463      * Stores data from rt into address and sets rs to the returned exclusive access status.
1464      *
1465      * @param rs general purpose register into which the exclusive access status is written. May not
1466      *            be null.
1467      * @param rt general purpose register containing data to be written to memory at address. May
1468      *            not be null
1469      * @param rn general purpose register containing the address specifying where rt is written to.
1470      * @param log2TransferSize log2Ceil of memory transfer size.
1471      */
1472     private void exclusiveStoreInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize) {
1473         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1474         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1475         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1476         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt));
1477     }
1478 
1479     /**
1480      * Compare And Swap word or doubleword in memory. This reads a value from an address rn,
1481      * compares it against a given value rs, and, if equal, stores the value rt to memory. The value
1482      * read from address rn is stored in register rs.
1483      *
1484      * @param size size of bits read from memory. Must be 32 or 64.
1485      * @param rs general purpose register to be compared and loaded. May not be null.
1486      * @param rt general purpose register to be conditionally stored. May not be null.
1487      * @param rn general purpose register containing the address from which to read.
1488      * @param acquire boolean value signifying if the load should use acquire semantics.
1489      * @param release boolean value signifying if the store should use release semantics.
1490      */
1491     public void cas(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1492         assert size == 32 || size == 64;
1493         int transferSize = NumUtil.log2Ceil(size / 8);
1494         compareAndSwapInstruction(CAS, rs, rt, rn, transferSize, acquire, release);
1495     }
1496 
1497     private void compareAndSwapInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1498         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1499         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1500         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1501         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; CASAcquireOffset | (release ? 1 : 0) &lt;&lt; CASReleaseOffset);
1502     }
1503 
1504     /**
1505      * Atomic add. This reads a value from an address rn, stores the value in rt, and adds the value
1506      * in rs to it, and stores the result back at address rn. The initial value read from memory is
1507      * stored in rt.
1508      *
1509      * @param size size of operand to read from memory. Must be 8, 16, 32, or 64.
1510      * @param rs general purpose register to be added to contents. May not be null.
1511      * @param rt general purpose register to be loaded. May not be null.
1512      * @param rn general purpose register or stack pointer holding an address from which to load.
1513      * @param acquire boolean value signifying if the load should use acquire semantics.
1514      * @param release boolean value signifying if the store should use release semantics.
1515      */
1516     public void ldadd(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1517         assert size == 8 || size == 16 || size == 32 || size == 64;
1518         int transferSize = NumUtil.log2Ceil(size / 8);
1519         loadAndAddInstruction(LDADD, rs, rt, rn, transferSize, acquire, release);
1520     }
1521 
1522     private void loadAndAddInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1523         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1524         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1525         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1526         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; LDADDAcquireOffset | (release ? 1 : 0) &lt;&lt; LDADDReleaseOffset);
1527     }
1528 
1529     /**
1530      * Atomic swap. This reads a value from an address rn, stores the value in rt, and then stores
1531      * the value in rs back at address rn.
1532      *
1533      * @param size size of operand to read from memory. Must be 8, 16, 32, or 64.
1534      * @param rs general purpose register to be stored. May not be null.
1535      * @param rt general purpose register to be loaded. May not be null.
1536      * @param rn general purpose register or stack pointer holding an address from which to load.
1537      * @param acquire boolean value signifying if the load should use acquire semantics.
1538      * @param release boolean value signifying if the store should use release semantics.
1539      */
1540     public void swp(int size, Register rs, Register rt, Register rn, boolean acquire, boolean release) {
1541         assert size == 8 || size == 16 || size == 32 || size == 64;
1542         int transferSize = NumUtil.log2Ceil(size / 8);
1543         swapInstruction(SWP, rs, rt, rn, transferSize, acquire, release);
1544     }
1545 
1546     private void swapInstruction(Instruction instr, Register rs, Register rt, Register rn, int log2TransferSize, boolean acquire, boolean release) {
1547         assert log2TransferSize &gt;= 0 &amp;&amp; log2TransferSize &lt; 4;
1548         assert rt.getRegisterCategory().equals(CPU) &amp;&amp; rs.getRegisterCategory().equals(CPU) &amp;&amp; !rs.equals(rt);
1549         int transferSizeEncoding = log2TransferSize &lt;&lt; LoadStoreTransferSizeOffset;
1550         emitInt(transferSizeEncoding | instr.encoding | rs2(rs) | rn(rn) | rt(rt) | (acquire ? 1 : 0) &lt;&lt; LDADDAcquireOffset | (release ? 1 : 0) &lt;&lt; LDADDReleaseOffset);
1551     }
1552 
1553     /* PC-relative Address Calculation (5.4.4) */
1554 
1555     /**
1556      * Address of page: sign extends 21-bit offset, shifts if left by 12 and adds it to the value of
1557      * the PC with its bottom 12-bits cleared, writing the result to dst. No offset is emitted; the
1558      * instruction will be patched later.
1559      *
1560      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1561      */
1562     public void adrp(Register dst) {
1563         emitInt(ADRP.encoding | PcRelImmOp | rd(dst));
1564     }
1565 
1566     /**
1567      * Adds a 21-bit signed offset to the program counter and writes the result to dst.
1568      *
1569      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1570      * @param imm21 Signed 21-bit offset.
1571      */
1572     public void adr(Register dst, int imm21) {
1573         emitInt(ADR.encoding | PcRelImmOp | rd(dst) | getPcRelativeImmEncoding(imm21));
1574     }
1575 
1576     /**
1577      * Adds a 21-bit signed offset to the program counter and writes the result to dst.
1578      *
1579      * @param dst general purpose register. May not be null, zero-register or stackpointer.
1580      * @param imm21 Signed 21-bit offset.
1581      * @param pos the position in the code that the instruction is emitted.
1582      */
1583     public void adr(Register dst, int imm21, int pos) {
1584         emitInt(ADR.encoding | PcRelImmOp | rd(dst) | getPcRelativeImmEncoding(imm21), pos);
1585     }
1586 
1587     private static int getPcRelativeImmEncoding(int imm21) {
1588         assert NumUtil.isSignedNbit(21, imm21);
1589         int imm = imm21 &amp; NumUtil.getNbitNumberInt(21);
1590         // higher 19 bit
1591         int immHi = (imm &gt;&gt; 2) &lt;&lt; PcRelImmHiOffset;
1592         // lower 2 bit
1593         int immLo = (imm &amp; 0x3) &lt;&lt; PcRelImmLoOffset;
1594         return immHi | immLo;
1595     }
1596 
1597     /* Arithmetic (Immediate) (5.4.1) */
1598 
1599     /**
1600      * dst = src + aimm.
1601      *
1602      * @param size register size. Has to be 32 or 64.
1603      * @param dst general purpose register. May not be null or zero-register.
1604      * @param src general purpose register. May not be null or zero-register.
1605      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1606      *            the lower 12-bit cleared.
1607      */
1608     protected void add(int size, Register dst, Register src, int aimm) {
1609         assert !dst.equals(zr);
1610         assert !src.equals(zr);
1611         addSubImmInstruction(ADD, dst, src, aimm, generalFromSize(size));
1612     }
1613 
1614     /**
1615      * dst = src + aimm and sets condition flags.
1616      *
1617      * @param size register size. Has to be 32 or 64.
1618      * @param dst general purpose register. May not be null or stackpointer.
1619      * @param src general purpose register. May not be null or zero-register.
1620      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1621      *            the lower 12-bit cleared.
1622      */
1623     protected void adds(int size, Register dst, Register src, int aimm) {
1624         assert !dst.equals(sp);
1625         assert !src.equals(zr);
1626         addSubImmInstruction(ADDS, dst, src, aimm, generalFromSize(size));
1627     }
1628 
1629     /**
1630      * dst = src - aimm.
1631      *
1632      * @param size register size. Has to be 32 or 64.
1633      * @param dst general purpose register. May not be null or zero-register.
1634      * @param src general purpose register. May not be null or zero-register.
1635      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1636      *            the lower 12-bit cleared.
1637      */
1638     protected void sub(int size, Register dst, Register src, int aimm) {
1639         assert !dst.equals(zr);
1640         assert !src.equals(zr);
1641         addSubImmInstruction(SUB, dst, src, aimm, generalFromSize(size));
1642     }
1643 
1644     /**
1645      * dst = src - aimm and sets condition flags.
1646      *
1647      * @param size register size. Has to be 32 or 64.
1648      * @param dst general purpose register. May not be null or stackpointer.
1649      * @param src general purpose register. May not be null or zero-register.
1650      * @param aimm arithmetic immediate. Either unsigned 12-bit value or unsigned 24-bit value with
1651      *            the lower 12-bit cleared.
1652      */
1653     protected void subs(int size, Register dst, Register src, int aimm) {
1654         assert !dst.equals(sp);
1655         assert !src.equals(zr);
1656         addSubImmInstruction(SUBS, dst, src, aimm, generalFromSize(size));
1657     }
1658 
1659     private void addSubImmInstruction(Instruction instr, Register dst, Register src, int aimm, InstructionType type) {
1660         emitInt(type.encoding | instr.encoding | AddSubImmOp | encodeAimm(aimm) | rd(dst) | rs1(src));
1661     }
1662 
1663     public void ccmp(int size, Register x, Register y, int aimm, ConditionFlag condition) {
1664         emitInt(generalFromSize(size).encoding | CCMP.encoding | rs1(x) | rs2(y) | encodeAimm(aimm) | condition.encoding &lt;&lt; ConditionalConditionOffset);
1665     }
1666 
1667     /**
1668      * Encodes arithmetic immediate.
1669      *
1670      * @param imm Immediate has to be either an unsigned 12-bit value or an unsigned 24-bit value
1671      *            with the lower 12 bits zero.
1672      * @return Representation of immediate for use with arithmetic instructions.
1673      */
1674     private static int encodeAimm(int imm) {
1675         assert isAimm(imm) : &quot;Immediate has to be legal arithmetic immediate value &quot; + imm;
1676         if (NumUtil.isUnsignedNbit(12, imm)) {
1677             return imm &lt;&lt; ImmediateOffset;
1678         } else {
1679             // First 12-bit are zero, so shift immediate 12-bit and set flag to indicate
1680             // shifted immediate value.
1681             return (imm &gt;&gt;&gt; 12 &lt;&lt; ImmediateOffset) | AddSubShift12;
1682         }
1683     }
1684 
1685     /**
1686      * Checks whether immediate can be encoded as an arithmetic immediate.
1687      *
1688      * @param imm Immediate has to be either an unsigned 12bit value or un unsigned 24bit value with
1689      *            the lower 12 bits 0.
1690      * @return true if valid arithmetic immediate, false otherwise.
1691      */
1692     protected static boolean isAimm(int imm) {
1693         return NumUtil.isUnsignedNbit(12, imm) || NumUtil.isUnsignedNbit(12, imm &gt;&gt;&gt; 12) &amp;&amp; (imm &amp; 0xfff) == 0;
1694     }
1695 
1696     /* Logical (immediate) (5.4.2) */
1697 
1698     /**
1699      * dst = src &amp; bimm.
1700      *
1701      * @param size register size. Has to be 32 or 64.
1702      * @param dst general purpose register. May not be null or zero-register.
1703      * @param src general purpose register. May not be null or stack-pointer.
1704      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1705      */
1706     public void and(int size, Register dst, Register src, long bimm) {
1707         assert !dst.equals(zr);
1708         assert !src.equals(sp);
1709         logicalImmInstruction(AND, dst, src, bimm, generalFromSize(size));
1710     }
1711 
1712     /**
1713      * dst = src &amp; bimm and sets condition flags.
1714      *
1715      * @param size register size. Has to be 32 or 64.
1716      * @param dst general purpose register. May not be null or stack-pointer.
1717      * @param src general purpose register. May not be null or stack-pointer.
1718      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1719      */
1720     public void ands(int size, Register dst, Register src, long bimm) {
1721         assert !dst.equals(sp);
1722         assert !src.equals(sp);
1723         logicalImmInstruction(ANDS, dst, src, bimm, generalFromSize(size));
1724     }
1725 
1726     /**
1727      * dst = src ^ bimm.
1728      *
1729      * @param size register size. Has to be 32 or 64.
1730      * @param dst general purpose register. May not be null or zero-register.
1731      * @param src general purpose register. May not be null or stack-pointer.
1732      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1733      */
1734     public void eor(int size, Register dst, Register src, long bimm) {
1735         assert !dst.equals(zr);
1736         assert !src.equals(sp);
1737         logicalImmInstruction(EOR, dst, src, bimm, generalFromSize(size));
1738     }
1739 
1740     /**
1741      * dst = src | bimm.
1742      *
1743      * @param size register size. Has to be 32 or 64.
1744      * @param dst general purpose register. May not be null or zero-register.
1745      * @param src general purpose register. May not be null or stack-pointer.
1746      * @param bimm logical immediate. See {@link LogicalImmediateTable} for exact definition.
1747      */
1748     protected void orr(int size, Register dst, Register src, long bimm) {
1749         assert !dst.equals(zr);
1750         assert !src.equals(sp);
1751         logicalImmInstruction(ORR, dst, src, bimm, generalFromSize(size));
1752     }
1753 
1754     private void logicalImmInstruction(Instruction instr, Register dst, Register src, long bimm, InstructionType type) {
1755         // Mask higher bits off, since we always pass longs around even for the 32-bit instruction.
1756         long bimmValue;
1757         if (type == General32) {
1758             assert (bimm &gt;&gt; 32) == 0 || (bimm &gt;&gt; 32) == -1L : &quot;Higher order bits for 32-bit instruction must either all be 0 or 1.&quot;;
1759             bimmValue = bimm &amp; NumUtil.getNbitNumberLong(32);
1760         } else {
1761             bimmValue = bimm;
1762         }
1763         int immEncoding = LogicalImmediateTable.getLogicalImmEncoding(type == General64, bimmValue);
1764         emitInt(type.encoding | instr.encoding | LogicalImmOp | immEncoding | rd(dst) | rs1(src));
1765     }
1766 
1767     /* Move (wide immediate) (5.4.3) */
1768 
1769     /**
1770      * dst = uimm16 &lt;&lt; shiftAmt.
1771      *
1772      * @param size register size. Has to be 32 or 64.
1773      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1774      * @param uimm16 16-bit unsigned immediate
1775      * @param shiftAmt amount by which uimm16 is left shifted. Can be any multiple of 16 smaller
1776      *            than size.
1777      */
1778     protected void movz(int size, Register dst, int uimm16, int shiftAmt) {
1779         moveWideImmInstruction(MOVZ, dst, uimm16, shiftAmt, generalFromSize(size));
1780     }
1781 
1782     /**
1783      * dst = ~(uimm16 &lt;&lt; shiftAmt).
1784      *
1785      * @param size register size. Has to be 32 or 64.
1786      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1787      * @param uimm16 16-bit unsigned immediate
1788      * @param shiftAmt amount by which uimm16 is left shifted. Can be any multiple of 16 smaller
1789      *            than size.
1790      */
1791     protected void movn(int size, Register dst, int uimm16, int shiftAmt) {
1792         moveWideImmInstruction(MOVN, dst, uimm16, shiftAmt, generalFromSize(size));
1793     }
1794 
1795     /**
1796      * dst&lt;pos+15:pos&gt; = uimm16.
1797      *
1798      * @param size register size. Has to be 32 or 64.
1799      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1800      * @param uimm16 16-bit unsigned immediate
1801      * @param pos position into which uimm16 is inserted. Can be any multiple of 16 smaller than
1802      *            size.
1803      */
1804     protected void movk(int size, Register dst, int uimm16, int pos) {
1805         moveWideImmInstruction(MOVK, dst, uimm16, pos, generalFromSize(size));
1806     }
1807 
1808     private void moveWideImmInstruction(Instruction instr, Register dst, int uimm16, int shiftAmt, InstructionType type) {
1809         assert dst.getRegisterCategory().equals(CPU);
1810         assert NumUtil.isUnsignedNbit(16, uimm16) : &quot;Immediate has to be unsigned 16bit&quot;;
1811         assert shiftAmt == 0 || shiftAmt == 16 || (type == InstructionType.General64 &amp;&amp; (shiftAmt == 32 || shiftAmt == 48)) : &quot;Invalid shift amount: &quot; + shiftAmt;
1812         int shiftValue = shiftAmt &gt;&gt; 4;
1813         emitInt(type.encoding | instr.encoding | MoveWideImmOp | rd(dst) | uimm16 &lt;&lt; MoveWideImmOffset | shiftValue &lt;&lt; MoveWideShiftOffset);
1814     }
1815 
1816     /* Bitfield Operations (5.4.5) */
1817 
1818     /**
1819      * Bitfield move.
1820      *
1821      * @param size register size. Has to be 32 or 64.
1822      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1823      * @param src general purpose register. May not be null, stackpointer or zero-register.
1824      * @param r must be in the range 0 to size - 1
1825      * @param s must be in the range 0 to size - 1
1826      */
1827     public void bfm(int size, Register dst, Register src, int r, int s) {
1828         bitfieldInstruction(BFM, dst, src, r, s, generalFromSize(size));
1829     }
1830 
1831     /**
1832      * Unsigned bitfield move.
1833      *
1834      * @param size register size. Has to be 32 or 64.
1835      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1836      * @param src general purpose register. May not be null, stackpointer or zero-register.
1837      * @param r must be in the range 0 to size - 1
1838      * @param s must be in the range 0 to size - 1
1839      */
1840     public void ubfm(int size, Register dst, Register src, int r, int s) {
1841         bitfieldInstruction(UBFM, dst, src, r, s, generalFromSize(size));
1842     }
1843 
1844     /**
1845      * Signed bitfield move.
1846      *
1847      * @param size register size. Has to be 32 or 64.
1848      * @param dst general purpose register. May not be null, stackpointer or zero-register.
1849      * @param src general purpose register. May not be null, stackpointer or zero-register.
1850      * @param r must be in the range 0 to size - 1
1851      * @param s must be in the range 0 to size - 1
1852      */
1853     protected void sbfm(int size, Register dst, Register src, int r, int s) {
1854         bitfieldInstruction(SBFM, dst, src, r, s, generalFromSize(size));
1855     }
1856 
1857     private void bitfieldInstruction(Instruction instr, Register dst, Register src, int r, int s, InstructionType type) {
1858         assert !dst.equals(sp) &amp;&amp; !dst.equals(zr);
1859         assert !src.equals(sp) &amp;&amp; !src.equals(zr);
1860         assert s &gt;= 0 &amp;&amp; s &lt; type.width &amp;&amp; r &gt;= 0 &amp;&amp; r &lt; type.width;
1861         int sf = type == General64 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1862         emitInt(type.encoding | instr.encoding | BitfieldImmOp | sf | r &lt;&lt; ImmediateRotateOffset | s &lt;&lt; ImmediateOffset | rd(dst) | rs1(src));
1863     }
1864 
1865     /* Extract (Immediate) (5.4.6) */
1866 
1867     /**
1868      * Extract. dst = src1:src2&lt;lsb+31:lsb&gt;
1869      *
1870      * @param size register size. Has to be 32 or 64.
1871      * @param dst general purpose register. May not be null or stackpointer.
1872      * @param src1 general purpose register. May not be null or stackpointer.
1873      * @param src2 general purpose register. May not be null or stackpointer.
1874      * @param lsb must be in range 0 to size - 1.
1875      */
1876     protected void extr(int size, Register dst, Register src1, Register src2, int lsb) {
1877         assert !dst.equals(sp);
1878         assert !src1.equals(sp);
1879         assert !src2.equals(sp);
1880         InstructionType type = generalFromSize(size);
1881         assert lsb &gt;= 0 &amp;&amp; lsb &lt; type.width;
1882         int sf = type == General64 ? 1 &lt;&lt; ImmediateSizeOffset : 0;
1883         emitInt(type.encoding | EXTR.encoding | sf | lsb &lt;&lt; ImmediateOffset | rd(dst) | rs1(src1) | rs2(src2));
1884     }
1885 
1886     /* Arithmetic (shifted register) (5.5.1) */
1887 
1888     /**
1889      * dst = src1 + shiftType(src2, imm).
1890      *
1891      * @param size register size. Has to be 32 or 64.
1892      * @param dst general purpose register. May not be null or stackpointer.
1893      * @param src1 general purpose register. May not be null or stackpointer.
1894      * @param src2 general purpose register. May not be null or stackpointer.
1895      * @param shiftType any type but ROR.
1896      * @param imm must be in range 0 to size - 1.
1897      */
1898     protected void add(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1899         addSubShiftedInstruction(ADD, dst, src1, src2, shiftType, imm, generalFromSize(size));
1900     }
1901 
1902     /**
1903      * dst = src1 + shiftType(src2, imm) and sets condition flags.
1904      *
1905      * @param size register size. Has to be 32 or 64.
1906      * @param dst general purpose register. May not be null or stackpointer.
1907      * @param src1 general purpose register. May not be null or stackpointer.
1908      * @param src2 general purpose register. May not be null or stackpointer.
1909      * @param shiftType any type but ROR.
1910      * @param imm must be in range 0 to size - 1.
1911      */
1912     public void adds(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1913         addSubShiftedInstruction(ADDS, dst, src1, src2, shiftType, imm, generalFromSize(size));
1914     }
1915 
1916     /**
1917      * dst = src1 - shiftType(src2, imm).
1918      *
1919      * @param size register size. Has to be 32 or 64.
1920      * @param dst general purpose register. May not be null or stackpointer.
1921      * @param src1 general purpose register. May not be null or stackpointer.
1922      * @param src2 general purpose register. May not be null or stackpointer.
1923      * @param shiftType any type but ROR.
1924      * @param imm must be in range 0 to size - 1.
1925      */
1926     protected void sub(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1927         addSubShiftedInstruction(SUB, dst, src1, src2, shiftType, imm, generalFromSize(size));
1928     }
1929 
1930     /**
1931      * dst = src1 - shiftType(src2, imm) and sets condition flags.
1932      *
1933      * @param size register size. Has to be 32 or 64.
1934      * @param dst general purpose register. May not be null or stackpointer.
1935      * @param src1 general purpose register. May not be null or stackpointer.
1936      * @param src2 general purpose register. May not be null or stackpointer.
1937      * @param shiftType any type but ROR.
1938      * @param imm must be in range 0 to size - 1.
1939      */
1940     public void subs(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int imm) {
1941         addSubShiftedInstruction(SUBS, dst, src1, src2, shiftType, imm, generalFromSize(size));
1942     }
1943 
1944     private void addSubShiftedInstruction(Instruction instr, Register dst, Register src1, Register src2, ShiftType shiftType, int imm, InstructionType type) {
1945         assert shiftType != ShiftType.ROR;
1946         assert imm &gt;= 0 &amp;&amp; imm &lt; type.width;
1947         emitInt(type.encoding | instr.encoding | AddSubShiftedOp | imm &lt;&lt; ImmediateOffset | shiftType.encoding &lt;&lt; ShiftTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
1948     }
1949 
1950     /* Arithmetic (extended register) (5.5.2) */
1951     /**
1952      * dst = src1 + extendType(src2) &lt;&lt; imm.
1953      *
1954      * @param size register size. Has to be 32 or 64.
1955      * @param dst general purpose register. May not be null or zero-register..
1956      * @param src1 general purpose register. May not be null or zero-register.
1957      * @param src2 general purpose register. May not be null or stackpointer.
1958      * @param extendType defines how src2 is extended to the same size as src1.
1959      * @param shiftAmt must be in range 0 to 4.
1960      */
1961     public void add(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1962         assert !dst.equals(zr);
1963         assert !src1.equals(zr);
1964         assert !src2.equals(sp);
1965         addSubExtendedInstruction(ADD, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
1966     }
1967 
1968     /**
1969      * dst = src1 + extendType(src2) &lt;&lt; imm and sets condition flags.
1970      *
1971      * @param size register size. Has to be 32 or 64.
1972      * @param dst general purpose register. May not be null or stackpointer..
1973      * @param src1 general purpose register. May not be null or zero-register.
1974      * @param src2 general purpose register. May not be null or stackpointer.
1975      * @param extendType defines how src2 is extended to the same size as src1.
1976      * @param shiftAmt must be in range 0 to 4.
1977      */
1978     protected void adds(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1979         assert !dst.equals(sp);
1980         assert !src1.equals(zr);
1981         assert !src2.equals(sp);
1982         addSubExtendedInstruction(ADDS, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
1983     }
1984 
1985     /**
1986      * dst = src1 - extendType(src2) &lt;&lt; imm.
1987      *
1988      * @param size register size. Has to be 32 or 64.
1989      * @param dst general purpose register. May not be null or zero-register..
1990      * @param src1 general purpose register. May not be null or zero-register.
1991      * @param src2 general purpose register. May not be null or stackpointer.
1992      * @param extendType defines how src2 is extended to the same size as src1.
1993      * @param shiftAmt must be in range 0 to 4.
1994      */
1995     protected void sub(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
1996         assert !dst.equals(zr);
1997         assert !src1.equals(zr);
1998         assert !src2.equals(sp);
1999         addSubExtendedInstruction(SUB, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
2000     }
2001 
2002     /**
2003      * dst = src1 - extendType(src2) &lt;&lt; imm and sets flags.
2004      *
2005      * @param size register size. Has to be 32 or 64.
2006      * @param dst general purpose register. May not be null or stackpointer..
2007      * @param src1 general purpose register. May not be null or zero-register.
2008      * @param src2 general purpose register. May not be null or stackpointer.
2009      * @param extendType defines how src2 is extended to the same size as src1.
2010      * @param shiftAmt must be in range 0 to 4.
2011      */
2012     public void subs(int size, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt) {
2013         assert !dst.equals(sp);
2014         assert !src1.equals(zr);
2015         assert !src2.equals(sp);
2016         addSubExtendedInstruction(SUBS, dst, src1, src2, extendType, shiftAmt, generalFromSize(size));
2017     }
2018 
2019     private void addSubExtendedInstruction(Instruction instr, Register dst, Register src1, Register src2, ExtendType extendType, int shiftAmt, InstructionType type) {
2020         assert shiftAmt &gt;= 0 &amp;&amp; shiftAmt &lt;= 4;
2021         emitInt(type.encoding | instr.encoding | AddSubExtendedOp | shiftAmt &lt;&lt; ImmediateOffset | extendType.encoding &lt;&lt; ExtendTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
2022     }
2023 
2024     /* Logical (shifted register) (5.5.3) */
2025     /**
2026      * dst = src1 &amp; shiftType(src2, imm).
2027      *
2028      * @param size register size. Has to be 32 or 64.
2029      * @param dst general purpose register. May not be null or stackpointer.
2030      * @param src1 general purpose register. May not be null or stackpointer.
2031      * @param src2 general purpose register. May not be null or stackpointer.
2032      * @param shiftType all types allowed, may not be null.
2033      * @param shiftAmt must be in range 0 to size - 1.
2034      */
2035     protected void and(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2036         logicalRegInstruction(AND, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2037     }
2038 
2039     /**
2040      * dst = src1 &amp; shiftType(src2, imm) and sets condition flags.
2041      *
2042      * @param size register size. Has to be 32 or 64.
2043      * @param dst general purpose register. May not be null or stackpointer.
2044      * @param src1 general purpose register. May not be null or stackpointer.
2045      * @param src2 general purpose register. May not be null or stackpointer.
2046      * @param shiftType all types allowed, may not be null.
2047      * @param shiftAmt must be in range 0 to size - 1.
2048      */
2049     protected void ands(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2050         logicalRegInstruction(ANDS, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2051     }
2052 
2053     /**
2054      * dst = src1 &amp; ~(shiftType(src2, imm)).
2055      *
2056      * @param size register size. Has to be 32 or 64.
2057      * @param dst general purpose register. May not be null or stackpointer.
2058      * @param src1 general purpose register. May not be null or stackpointer.
2059      * @param src2 general purpose register. May not be null or stackpointer.
2060      * @param shiftType all types allowed, may not be null.
2061      * @param shiftAmt must be in range 0 to size - 1.
2062      */
2063     protected void bic(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2064         logicalRegInstruction(BIC, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2065     }
2066 
2067     /**
2068      * dst = src1 &amp; ~(shiftType(src2, imm)) and sets condition flags.
2069      *
2070      * @param size register size. Has to be 32 or 64.
2071      * @param dst general purpose register. May not be null or stackpointer.
2072      * @param src1 general purpose register. May not be null or stackpointer.
2073      * @param src2 general purpose register. May not be null or stackpointer.
2074      * @param shiftType all types allowed, may not be null.
2075      * @param shiftAmt must be in range 0 to size - 1.
2076      */
2077     protected void bics(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2078         logicalRegInstruction(BICS, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2079     }
2080 
2081     /**
2082      * dst = src1 ^ ~(shiftType(src2, imm)).
2083      *
2084      * @param size register size. Has to be 32 or 64.
2085      * @param dst general purpose register. May not be null or stackpointer.
2086      * @param src1 general purpose register. May not be null or stackpointer.
2087      * @param src2 general purpose register. May not be null or stackpointer.
2088      * @param shiftType all types allowed, may not be null.
2089      * @param shiftAmt must be in range 0 to size - 1.
2090      */
2091     protected void eon(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2092         logicalRegInstruction(EON, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2093     }
2094 
2095     /**
2096      * dst = src1 ^ shiftType(src2, imm).
2097      *
2098      * @param size register size. Has to be 32 or 64.
2099      * @param dst general purpose register. May not be null or stackpointer.
2100      * @param src1 general purpose register. May not be null or stackpointer.
2101      * @param src2 general purpose register. May not be null or stackpointer.
2102      * @param shiftType all types allowed, may not be null.
2103      * @param shiftAmt must be in range 0 to size - 1.
2104      */
2105     protected void eor(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2106         logicalRegInstruction(EOR, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2107     }
2108 
2109     /**
2110      * dst = src1 | shiftType(src2, imm).
2111      *
2112      * @param size register size. Has to be 32 or 64.
2113      * @param dst general purpose register. May not be null or stackpointer.
2114      * @param src1 general purpose register. May not be null or stackpointer.
2115      * @param src2 general purpose register. May not be null or stackpointer.
2116      * @param shiftType all types allowed, may not be null.
2117      * @param shiftAmt must be in range 0 to size - 1.
2118      */
2119     protected void orr(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2120         logicalRegInstruction(ORR, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2121     }
2122 
2123     /**
2124      * dst = src1 | ~(shiftType(src2, imm)).
2125      *
2126      * @param size register size. Has to be 32 or 64.
2127      * @param dst general purpose register. May not be null or stackpointer.
2128      * @param src1 general purpose register. May not be null or stackpointer.
2129      * @param src2 general purpose register. May not be null or stackpointer.
2130      * @param shiftType all types allowed, may not be null.
2131      * @param shiftAmt must be in range 0 to size - 1.
2132      */
2133     protected void orn(int size, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt) {
2134         logicalRegInstruction(ORN, dst, src1, src2, shiftType, shiftAmt, generalFromSize(size));
2135     }
2136 
2137     private void logicalRegInstruction(Instruction instr, Register dst, Register src1, Register src2, ShiftType shiftType, int shiftAmt, InstructionType type) {
2138         assert !dst.equals(sp);
2139         assert !src1.equals(sp);
2140         assert !src2.equals(sp);
2141         assert shiftAmt &gt;= 0 &amp;&amp; shiftAmt &lt; type.width;
2142         emitInt(type.encoding | instr.encoding | LogicalShiftOp | shiftAmt &lt;&lt; ImmediateOffset | shiftType.encoding &lt;&lt; ShiftTypeOffset | rd(dst) | rs1(src1) | rs2(src2));
2143     }
2144 
2145     /* Variable Shift (5.5.4) */
2146     /**
2147      * dst = src1 &gt;&gt; (src2 &amp; log2(size)).
2148      *
2149      * @param size register size. Has to be 32 or 64.
2150      * @param dst general purpose register. May not be null or stackpointer.
2151      * @param src1 general purpose register. May not be null or stackpointer.
2152      * @param src2 general purpose register. May not be null or stackpointer.
2153      */
2154     protected void asr(int size, Register dst, Register src1, Register src2) {
2155         dataProcessing2SourceOp(ASRV, dst, src1, src2, generalFromSize(size));
2156     }
2157 
2158     /**
2159      * dst = src1 &lt;&lt; (src2 &amp; log2(size)).
2160      *
2161      * @param size register size. Has to be 32 or 64.
2162      * @param dst general purpose register. May not be null or stackpointer.
2163      * @param src1 general purpose register. May not be null or stackpointer.
2164      * @param src2 general purpose register. May not be null or stackpointer.
2165      */
2166     protected void lsl(int size, Register dst, Register src1, Register src2) {
2167         dataProcessing2SourceOp(LSLV, dst, src1, src2, generalFromSize(size));
2168     }
2169 
2170     /**
2171      * dst = src1 &gt;&gt;&gt; (src2 &amp; log2(size)).
2172      *
2173      * @param size register size. Has to be 32 or 64.
2174      * @param dst general purpose register. May not be null or stackpointer.
2175      * @param src1 general purpose register. May not be null or stackpointer.
2176      * @param src2 general purpose register. May not be null or stackpointer.
2177      */
2178     protected void lsr(int size, Register dst, Register src1, Register src2) {
2179         dataProcessing2SourceOp(LSRV, dst, src1, src2, generalFromSize(size));
2180     }
2181 
2182     /**
<a name="4" id="anc4"></a><span class="line-modified">2183      * dst = rotateRight(src1, (src2 &amp; (size - 1))).</span>
2184      *
2185      * @param size register size. Has to be 32 or 64.
2186      * @param dst general purpose register. May not be null or stackpointer.
2187      * @param src1 general purpose register. May not be null or stackpointer.
2188      * @param src2 general purpose register. May not be null or stackpointer.
2189      */
<a name="5" id="anc5"></a><span class="line-modified">2190     protected void rorv(int size, Register dst, Register src1, Register src2) {</span>
2191         dataProcessing2SourceOp(RORV, dst, src1, src2, generalFromSize(size));
2192     }
2193 
2194     /* Bit Operations (5.5.5) */
2195 
2196     /**
2197      * Counts leading sign bits. Sets Wd to the number of consecutive bits following the topmost bit
2198      * in dst, that are the same as the topmost bit. The count does not include the topmost bit
2199      * itself , so the result will be in the range 0 to size-1 inclusive.
2200      *
2201      * @param size register size. Has to be 32 or 64.
2202      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2203      * @param src source register. May not be null, zero-register or the stackpointer.
2204      */
2205     protected void cls(int size, Register dst, Register src) {
2206         dataProcessing1SourceOp(CLS, dst, src, generalFromSize(size));
2207     }
2208 
2209     /**
2210      * Counts leading zeros.
2211      *
2212      * @param size register size. Has to be 32 or 64.
2213      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2214      * @param src source register. May not be null, zero-register or the stackpointer.
2215      */
2216     public void clz(int size, Register dst, Register src) {
2217         dataProcessing1SourceOp(CLZ, dst, src, generalFromSize(size));
2218     }
2219 
2220     /**
2221      * Reverses bits.
2222      *
2223      * @param size register size. Has to be 32 or 64.
2224      * @param dst general purpose register. May not be null, zero-register or the stackpointer.
2225      * @param src source register. May not be null, zero-register or the stackpointer.
2226      */
2227     public void rbit(int size, Register dst, Register src) {
2228         dataProcessing1SourceOp(RBIT, dst, src, generalFromSize(size));
2229     }
2230 
2231     /**
2232      * Reverses bytes.
2233      *
2234      * @param size register size. Has to be 32 or 64.
2235      * @param dst general purpose register. May not be null or the stackpointer.
2236      * @param src source register. May not be null or the stackpointer.
2237      */
2238     public void rev(int size, Register dst, Register src) {
2239         if (size == 64) {
2240             dataProcessing1SourceOp(REVX, dst, src, generalFromSize(size));
2241         } else {
2242             assert size == 32;
2243             dataProcessing1SourceOp(REVW, dst, src, generalFromSize(size));
2244         }
2245     }
2246 
2247     /* Conditional Data Processing (5.5.6) */
2248 
2249     /**
2250      * Conditional select. dst = src1 if condition else src2.
2251      *
2252      * @param size register size. Has to be 32 or 64.
2253      * @param dst general purpose register. May not be null or the stackpointer.
2254      * @param src1 general purpose register. May not be null or the stackpointer.
2255      * @param src2 general purpose register. May not be null or the stackpointer.
2256      * @param condition any condition flag. May not be null.
2257      */
2258     protected void csel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2259         conditionalSelectInstruction(CSEL, dst, src1, src2, condition, generalFromSize(size));
2260     }
2261 
2262     /**
2263      * Conditional select negate. dst = src1 if condition else -src2.
2264      *
2265      * @param size register size. Has to be 32 or 64.
2266      * @param dst general purpose register. May not be null or the stackpointer.
2267      * @param src1 general purpose register. May not be null or the stackpointer.
2268      * @param src2 general purpose register. May not be null or the stackpointer.
2269      * @param condition any condition flag. May not be null.
2270      */
2271     protected void csneg(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2272         conditionalSelectInstruction(CSNEG, dst, src1, src2, condition, generalFromSize(size));
2273     }
2274 
2275     /**
2276      * Conditional increase. dst = src1 if condition else src2 + 1.
2277      *
2278      * @param size register size. Has to be 32 or 64.
2279      * @param dst general purpose register. May not be null or the stackpointer.
2280      * @param src1 general purpose register. May not be null or the stackpointer.
2281      * @param src2 general purpose register. May not be null or the stackpointer.
2282      * @param condition any condition flag. May not be null.
2283      */
2284     protected void csinc(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2285         conditionalSelectInstruction(CSINC, dst, src1, src2, condition, generalFromSize(size));
2286     }
2287 
2288     private void conditionalSelectInstruction(Instruction instr, Register dst, Register src1, Register src2, ConditionFlag condition, InstructionType type) {
2289         assert !dst.equals(sp);
2290         assert !src1.equals(sp);
2291         assert !src2.equals(sp);
2292         emitInt(type.encoding | instr.encoding | ConditionalSelectOp | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2293     }
2294 
2295     /* Integer Multiply/Divide (5.6) */
2296 
2297     /**
2298      * dst = src1 * src2 + src3.
2299      *
2300      * @param size register size. Has to be 32 or 64.
2301      * @param dst general purpose register. May not be null or the stackpointer.
2302      * @param src1 general purpose register. May not be null or the stackpointer.
2303      * @param src2 general purpose register. May not be null or the stackpointer.
2304      * @param src3 general purpose register. May not be null or the stackpointer.
2305      */
2306     protected void madd(int size, Register dst, Register src1, Register src2, Register src3) {
2307         mulInstruction(MADD, dst, src1, src2, src3, generalFromSize(size));
2308     }
2309 
2310     /**
2311      * dst = src3 - src1 * src2.
2312      *
2313      * @param size register size. Has to be 32 or 64.
2314      * @param dst general purpose register. May not be null or the stackpointer.
2315      * @param src1 general purpose register. May not be null or the stackpointer.
2316      * @param src2 general purpose register. May not be null or the stackpointer.
2317      * @param src3 general purpose register. May not be null or the stackpointer.
2318      */
2319     protected void msub(int size, Register dst, Register src1, Register src2, Register src3) {
2320         mulInstruction(MSUB, dst, src1, src2, src3, generalFromSize(size));
2321     }
2322 
2323     /**
2324      * Signed multiply high. dst = (src1 * src2)[127:64]
2325      *
2326      * @param dst general purpose register. May not be null or the stackpointer.
2327      * @param src1 general purpose register. May not be null or the stackpointer.
2328      * @param src2 general purpose register. May not be null or the stackpointer.
2329      */
2330     protected void smulh(Register dst, Register src1, Register src2) {
2331         assert !dst.equals(sp);
2332         assert !src1.equals(sp);
2333         assert !src2.equals(sp);
2334         emitInt(0b10011011010 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2335     }
2336 
2337     /**
2338      * Unsigned multiply high. dst = (src1 * src2)[127:64]
2339      *
2340      * @param dst general purpose register. May not be null or the stackpointer.
2341      * @param src1 general purpose register. May not be null or the stackpointer.
2342      * @param src2 general purpose register. May not be null or the stackpointer.
2343      */
2344     protected void umulh(Register dst, Register src1, Register src2) {
2345         assert !dst.equals(sp);
2346         assert !src1.equals(sp);
2347         assert !src2.equals(sp);
2348         emitInt(0b10011011110 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2349     }
2350 
2351     /**
2352      * Unsigned multiply add-long. xDst = xSrc3 + (wSrc1 * wSrc2)
2353      *
2354      * @param dst general purpose register. May not be null or the stackpointer.
2355      * @param src1 general purpose register. May not be null or the stackpointer.
2356      * @param src2 general purpose register. May not be null or the stackpointer.
2357      * @param src3 general purpose register. May not be null or the stackpointer.
2358      */
2359     protected void umaddl(Register dst, Register src1, Register src2, Register src3) {
2360         assert !dst.equals(sp);
2361         assert !src1.equals(sp);
2362         assert !src2.equals(sp);
2363         assert !src3.equals(sp);
2364         emitInt(0b10011011101 &lt;&lt; 21 | dst.encoding | rs1(src1) | rs2(src2) | 0b011111 &lt;&lt; ImmediateOffset);
2365     }
2366 
2367     /**
2368      * Signed multiply-add long. xDst = xSrc3 + (wSrc1 * wSrc2)
2369      *
2370      * @param dst general purpose register. May not be null or the stackpointer.
2371      * @param src1 general purpose register. May not be null or the stackpointer.
2372      * @param src2 general purpose register. May not be null or the stackpointer.
2373      * @param src3 general purpose register. May not be null or the stackpointer.
2374      */
2375     public void smaddl(Register dst, Register src1, Register src2, Register src3) {
2376         smullInstruction(MADD, dst, src1, src2, src3);
2377     }
2378 
2379     /**
2380      * Signed multiply-sub long. xDst = xSrc3 - (wSrc1 * wSrc2)
2381      *
2382      * @param dst general purpose register. May not be null or the stackpointer.
2383      * @param src1 general purpose register. May not be null or the stackpointer.
2384      * @param src2 general purpose register. May not be null or the stackpointer.
2385      * @param src3 general purpose register. May not be null or the stackpointer.
2386      */
2387     public void smsubl(Register dst, Register src1, Register src2, Register src3) {
2388         smullInstruction(MSUB, dst, src1, src2, src3);
2389     }
2390 
2391     private void mulInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {
2392         assert !dst.equals(sp);
2393         assert !src1.equals(sp);
2394         assert !src2.equals(sp);
2395         assert !src3.equals(sp);
2396         emitInt(type.encoding | instr.encoding | MulOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2397     }
2398 
2399     private void smullInstruction(Instruction instr, Register dst, Register src1, Register src2, Register src3) {
2400         assert !dst.equals(sp);
2401         assert !src1.equals(sp);
2402         assert !src2.equals(sp);
2403         assert !src3.equals(sp);
2404         emitInt(instr.encoding | SignedMulLongOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2405     }
2406 
2407     /**
2408      * Signed divide. dst = src1 / src2.
2409      *
2410      * @param size register size. Has to be 32 or 64.
2411      * @param dst general purpose register. May not be null or the stackpointer.
2412      * @param src1 general purpose register. May not be null or the stackpointer.
2413      * @param src2 general purpose register. May not be null or the stackpointer.
2414      */
2415     public void sdiv(int size, Register dst, Register src1, Register src2) {
2416         dataProcessing2SourceOp(SDIV, dst, src1, src2, generalFromSize(size));
2417     }
2418 
2419     /**
2420      * Unsigned divide. dst = src1 / src2.
2421      *
2422      * @param size register size. Has to be 32 or 64.
2423      * @param dst general purpose register. May not be null or the stackpointer.
2424      * @param src1 general purpose register. May not be null or the stackpointer.
2425      * @param src2 general purpose register. May not be null or the stackpointer.
2426      */
2427     public void udiv(int size, Register dst, Register src1, Register src2) {
2428         dataProcessing2SourceOp(UDIV, dst, src1, src2, generalFromSize(size));
2429     }
2430 
2431     private void dataProcessing1SourceOp(Instruction instr, Register dst, Register src, InstructionType type) {
2432         emitInt(type.encoding | instr.encoding | DataProcessing1SourceOp | rd(dst) | rs1(src));
2433     }
2434 
2435     private void dataProcessing2SourceOp(Instruction instr, Register dst, Register src1, Register src2, InstructionType type) {
2436         assert !dst.equals(sp);
2437         assert !src1.equals(sp);
2438         assert !src2.equals(sp);
2439         emitInt(type.encoding | instr.encoding | DataProcessing2SourceOp | rd(dst) | rs1(src1) | rs2(src2));
2440     }
2441 
2442     /* Floating point operations */
2443 
2444     /* Load-Store Single FP register (5.7.1.1) */
2445     /**
2446      * Floating point load.
2447      *
2448      * @param size number of bits read from memory into rt. Must be 32 or 64.
2449      * @param rt floating point register. May not be null.
2450      * @param address all addressing modes allowed. May not be null.
2451      */
2452     public void fldr(int size, Register rt, AArch64Address address) {
2453         assert rt.getRegisterCategory().equals(SIMD);
2454         assert size == 32 || size == 64;
2455         int transferSize = NumUtil.log2Ceil(size / 8);
2456         loadStoreInstruction(LDR, rt, address, InstructionType.FP32, transferSize);
2457     }
2458 
2459     /**
2460      * Floating point store.
2461      *
2462      * @param size number of bits read from memory into rt. Must be 32 or 64.
2463      * @param rt floating point register. May not be null.
2464      * @param address all addressing modes allowed. May not be null.
2465      */
2466     public void fstr(int size, Register rt, AArch64Address address) {
2467         assert rt.getRegisterCategory().equals(SIMD);
2468         assert size == 32 || size == 64;
2469         int transferSize = NumUtil.log2Ceil(size / 8);
2470         loadStoreInstruction(STR, rt, address, InstructionType.FP64, transferSize);
2471     }
2472 
2473     /* Floating-point Move (register) (5.7.2) */
2474 
2475     /**
2476      * Floating point move.
2477      *
2478      * @param size register size. Has to be 32 or 64.
2479      * @param dst floating point register. May not be null.
2480      * @param src floating point register. May not be null.
2481      */
2482     protected void fmov(int size, Register dst, Register src) {
2483         fpDataProcessing1Source(FMOV, dst, src, floatFromSize(size));
2484     }
2485 
2486     /**
2487      * Move size bits from floating point register unchanged to general purpose register.
2488      *
2489      * @param size number of bits read from memory into rt. Must be 32 or 64.
2490      * @param dst general purpose register. May not be null, stack-pointer or zero-register
2491      * @param src floating point register. May not be null.
2492      */
2493     protected void fmovFpu2Cpu(int size, Register dst, Register src) {
2494         assert dst.getRegisterCategory().equals(CPU);
2495         assert src.getRegisterCategory().equals(SIMD);
2496         fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVFPU2CPU);
2497     }
2498 
2499     /**
2500      * Move size bits from general purpose register unchanged to floating point register.
2501      *
2502      * @param size register size. Has to be 32 or 64.
2503      * @param dst floating point register. May not be null.
2504      * @param src general purpose register. May not be null or stack-pointer.
2505      */
2506     protected void fmovCpu2Fpu(int size, Register dst, Register src) {
2507         assert dst.getRegisterCategory().equals(SIMD);
2508         assert src.getRegisterCategory().equals(CPU);
2509         fmovCpuFpuInstruction(dst, src, size == 64, Instruction.FMOVCPU2FPU);
2510     }
2511 
2512     private void fmovCpuFpuInstruction(Register dst, Register src, boolean is64bit, Instruction instr) {
2513         int sf = is64bit ? FP64.encoding | General64.encoding : FP32.encoding | General32.encoding;
2514         emitInt(sf | instr.encoding | FpConvertOp | rd(dst) | rs1(src));
2515     }
2516 
2517     /* Floating-point Move (immediate) (5.7.3) */
2518 
2519     /**
2520      * Move immediate into register.
2521      *
2522      * @param size register size. Has to be 32 or 64.
2523      * @param dst floating point register. May not be null.
2524      * @param imm immediate that is loaded into dst. If size is 32 only float immediates can be
2525      *            loaded, i.e. (float) imm == imm must be true. In all cases
2526      *            {@code isFloatImmediate}, respectively {@code #isDoubleImmediate} must be true
2527      *            depending on size.
2528      */
2529     protected void fmov(int size, Register dst, double imm) {
2530         assert dst.getRegisterCategory().equals(SIMD);
2531         InstructionType type = floatFromSize(size);
2532         int immEncoding;
2533         if (type == FP64) {
2534             immEncoding = getDoubleImmediate(imm);
2535         } else {
2536             assert imm == (float) imm : &quot;float mov must use an immediate that can be represented using a float.&quot;;
2537             immEncoding = getFloatImmediate((float) imm);
2538         }
2539         emitInt(type.encoding | FMOV.encoding | FpImmOp | immEncoding | rd(dst));
2540     }
2541 
2542     private static int getDoubleImmediate(double imm) {
2543         assert isDoubleImmediate(imm);
2544         // bits: aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2545         // 0000.0000.0000.0000.0000.0000.0000.0000
2546         long repr = Double.doubleToRawLongBits(imm);
2547         int a = (int) (repr &gt;&gt;&gt; 63) &lt;&lt; 7;
2548         int b = (int) ((repr &gt;&gt;&gt; 61) &amp; 0x1) &lt;&lt; 6;
2549         int cToH = (int) (repr &gt;&gt;&gt; 48) &amp; 0x3f;
2550         return (a | b | cToH) &lt;&lt; FpImmOffset;
2551     }
2552 
2553     protected static boolean isDoubleImmediate(double imm) {
2554         // Valid values will have the form:
2555         // aBbb.bbbb.bbcd.efgh.0000.0000.0000.0000
2556         // 0000.0000.0000.0000.0000.0000.0000.0000
2557         long bits = Double.doubleToRawLongBits(imm);
2558         // lower 48 bits are cleared
2559         if ((bits &amp; NumUtil.getNbitNumberLong(48)) != 0) {
2560             return false;
2561         }
2562         // bits[61..54] are all set or all cleared.
2563         long pattern = (bits &gt;&gt; 54) &amp; NumUtil.getNbitNumberLong(7);
2564         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberLong(7)) {
2565             return false;
2566         }
2567         // bits[62] and bits[61] are opposites.
2568         boolean result = ((bits ^ (bits &lt;&lt; 1)) &amp; (1L &lt;&lt; 62)) != 0;
2569         return result;
2570     }
2571 
2572     private static int getFloatImmediate(float imm) {
2573         assert isFloatImmediate(imm);
2574         // bits: aBbb.bbbc.defg.h000.0000.0000.0000.0000
2575         int repr = Float.floatToRawIntBits(imm);
2576         int a = (repr &gt;&gt;&gt; 31) &lt;&lt; 7;
2577         int b = ((repr &gt;&gt;&gt; 29) &amp; 0x1) &lt;&lt; 6;
2578         int cToH = (repr &gt;&gt;&gt; 19) &amp; NumUtil.getNbitNumberInt(6);
2579         return (a | b | cToH) &lt;&lt; FpImmOffset;
2580     }
2581 
2582     protected static boolean isFloatImmediate(float imm) {
2583         // Valid values will have the form:
2584         // aBbb.bbbc.defg.h000.0000.0000.0000.0000
2585         int bits = Float.floatToRawIntBits(imm);
2586         // lower 20 bits are cleared.
2587         if ((bits &amp; NumUtil.getNbitNumberInt(19)) != 0) {
2588             return false;
2589         }
2590         // bits[29..25] are all set or all cleared
2591         int pattern = (bits &gt;&gt; 25) &amp; NumUtil.getNbitNumberInt(5);
2592         if (pattern != 0 &amp;&amp; pattern != NumUtil.getNbitNumberInt(5)) {
2593             return false;
2594         }
2595         // bits[29] and bits[30] have to be opposite
2596         return ((bits ^ (bits &lt;&lt; 1)) &amp; (1 &lt;&lt; 30)) != 0;
2597     }
2598 
2599     /* Convert Floating-point Precision (5.7.4.1) */
2600     /* Converts float to double and vice-versa */
2601 
2602     /**
2603      * Convert float to double and vice-versa.
2604      *
2605      * @param srcSize size of source register in bits.
2606      * @param dst floating point register. May not be null.
2607      * @param src floating point register. May not be null.
2608      */
2609     public void fcvt(int srcSize, Register dst, Register src) {
2610         if (srcSize == 32) {
2611             fpDataProcessing1Source(FCVTDS, dst, src, floatFromSize(srcSize));
2612         } else {
2613             fpDataProcessing1Source(FCVTSD, dst, src, floatFromSize(srcSize));
2614         }
2615     }
2616 
2617     /* Convert to Integer (5.7.4.2) */
2618 
2619     /**
2620      * Convert floating point to integer. Rounds towards zero.
2621      *
2622      * @param targetSize size of integer register. 32 or 64.
2623      * @param srcSize size of floating point register. 32 or 64.
2624      * @param dst general purpose register. May not be null, the zero-register or the stackpointer.
2625      * @param src floating point register. May not be null.
2626      */
2627     public void fcvtzs(int targetSize, int srcSize, Register dst, Register src) {
2628         assert !dst.equals(zr) &amp;&amp; !dst.equals(sp);
2629         assert src.getRegisterCategory().equals(SIMD);
2630         fcvtCpuFpuInstruction(FCVTZS, dst, src, generalFromSize(targetSize), floatFromSize(srcSize));
2631     }
2632 
2633     /* Convert from Integer (5.7.4.2) */
2634     /**
2635      * Converts integer to floating point. Uses rounding mode defined by FCPR.
2636      *
2637      * @param targetSize size of floating point register. 32 or 64.
2638      * @param srcSize size of integer register. 32 or 64.
2639      * @param dst floating point register. May not be null.
2640      * @param src general purpose register. May not be null or the stackpointer.
2641      */
2642     public void scvtf(int targetSize, int srcSize, Register dst, Register src) {
2643         assert dst.getRegisterCategory().equals(SIMD);
2644         assert !src.equals(sp);
2645         fcvtCpuFpuInstruction(SCVTF, dst, src, floatFromSize(targetSize), generalFromSize(srcSize));
2646     }
2647 
2648     private void fcvtCpuFpuInstruction(Instruction instr, Register dst, Register src, InstructionType type1, InstructionType type2) {
2649         emitInt(type1.encoding | type2.encoding | instr.encoding | FpConvertOp | rd(dst) | rs1(src));
2650     }
2651 
2652     /* Floating-point Round to Integral (5.7.5) */
2653 
2654     /**
2655      * Rounds floating-point to integral. Rounds towards zero.
2656      *
2657      * @param size register size.
2658      * @param dst floating point register. May not be null.
2659      * @param src floating point register. May not be null.
2660      */
2661     protected void frintz(int size, Register dst, Register src) {
2662         fpDataProcessing1Source(FRINTZ, dst, src, floatFromSize(size));
2663     }
2664 
2665     /**
2666      * Rounds floating-point to integral. Rounds towards nearest with ties to even.
2667      *
2668      * @param size register size.
2669      * @param dst floating point register. May not be null.
2670      * @param src floating point register. May not be null.
2671      */
2672     public void frintn(int size, Register dst, Register src) {
2673         fpDataProcessing1Source(FRINTN, dst, src, floatFromSize(size));
2674     }
2675 
2676     /**
2677      * Rounds floating-point to integral. Rounds towards minus infinity.
2678      *
2679      * @param size register size.
2680      * @param dst floating point register. May not be null.
2681      * @param src floating point register. May not be null.
2682      */
2683     public void frintm(int size, Register dst, Register src) {
2684         fpDataProcessing1Source(FRINTM, dst, src, floatFromSize(size));
2685     }
2686 
2687     /**
2688      * Rounds floating-point to integral. Rounds towards plus infinity.
2689      *
2690      * @param size register size.
2691      * @param dst floating point register. May not be null.
2692      * @param src floating point register. May not be null.
2693      */
2694     public void frintp(int size, Register dst, Register src) {
2695         fpDataProcessing1Source(FRINTP, dst, src, floatFromSize(size));
2696     }
2697 
2698     /* Floating-point Arithmetic (1 source) (5.7.6) */
2699 
2700     /**
2701      * dst = |src|.
2702      *
2703      * @param size register size.
2704      * @param dst floating point register. May not be null.
2705      * @param src floating point register. May not be null.
2706      */
2707     public void fabs(int size, Register dst, Register src) {
2708         fpDataProcessing1Source(FABS, dst, src, floatFromSize(size));
2709     }
2710 
2711     /**
2712      * dst = -neg.
2713      *
2714      * @param size register size.
2715      * @param dst floating point register. May not be null.
2716      * @param src floating point register. May not be null.
2717      */
2718     public void fneg(int size, Register dst, Register src) {
2719         fpDataProcessing1Source(FNEG, dst, src, floatFromSize(size));
2720     }
2721 
2722     /**
2723      * dst = Sqrt(src).
2724      *
2725      * @param size register size.
2726      * @param dst floating point register. May not be null.
2727      * @param src floating point register. May not be null.
2728      */
2729     public void fsqrt(int size, Register dst, Register src) {
2730         fpDataProcessing1Source(FSQRT, dst, src, floatFromSize(size));
2731     }
2732 
2733     private void fpDataProcessing1Source(Instruction instr, Register dst, Register src, InstructionType type) {
2734         assert dst.getRegisterCategory().equals(SIMD);
2735         assert src.getRegisterCategory().equals(SIMD);
2736         emitInt(type.encoding | instr.encoding | Fp1SourceOp | rd(dst) | rs1(src));
2737     }
2738 
2739     /* Floating-point Arithmetic (2 source) (5.7.7) */
2740 
2741     /**
2742      * dst = src1 + src2.
2743      *
2744      * @param size register size.
2745      * @param dst floating point register. May not be null.
2746      * @param src1 floating point register. May not be null.
2747      * @param src2 floating point register. May not be null.
2748      */
2749     public void fadd(int size, Register dst, Register src1, Register src2) {
2750         fpDataProcessing2Source(FADD, dst, src1, src2, floatFromSize(size));
2751     }
2752 
2753     /**
2754      * dst = src1 - src2.
2755      *
2756      * @param size register size.
2757      * @param dst floating point register. May not be null.
2758      * @param src1 floating point register. May not be null.
2759      * @param src2 floating point register. May not be null.
2760      */
2761     public void fsub(int size, Register dst, Register src1, Register src2) {
2762         fpDataProcessing2Source(FSUB, dst, src1, src2, floatFromSize(size));
2763     }
2764 
2765     /**
2766      * dst = src1 * src2.
2767      *
2768      * @param size register size.
2769      * @param dst floating point register. May not be null.
2770      * @param src1 floating point register. May not be null.
2771      * @param src2 floating point register. May not be null.
2772      */
2773     public void fmul(int size, Register dst, Register src1, Register src2) {
2774         fpDataProcessing2Source(FMUL, dst, src1, src2, floatFromSize(size));
2775     }
2776 
2777     /**
2778      * dst = src1 / src2.
2779      *
2780      * @param size register size.
2781      * @param dst floating point register. May not be null.
2782      * @param src1 floating point register. May not be null.
2783      * @param src2 floating point register. May not be null.
2784      */
2785     public void fdiv(int size, Register dst, Register src1, Register src2) {
2786         fpDataProcessing2Source(FDIV, dst, src1, src2, floatFromSize(size));
2787     }
2788 
2789     private void fpDataProcessing2Source(Instruction instr, Register dst, Register src1, Register src2, InstructionType type) {
2790         assert dst.getRegisterCategory().equals(SIMD);
2791         assert src1.getRegisterCategory().equals(SIMD);
2792         assert src2.getRegisterCategory().equals(SIMD);
2793         emitInt(type.encoding | instr.encoding | Fp2SourceOp | rd(dst) | rs1(src1) | rs2(src2));
2794     }
2795 
2796     /* Floating-point Multiply-Add (5.7.9) */
2797 
2798     /**
2799      * dst = src1 * src2 + src3.
2800      *
2801      * @param size register size.
2802      * @param dst floating point register. May not be null.
2803      * @param src1 floating point register. May not be null.
2804      * @param src2 floating point register. May not be null.
2805      * @param src3 floating point register. May not be null.
2806      */
2807     protected void fmadd(int size, Register dst, Register src1, Register src2, Register src3) {
2808         fpDataProcessing3Source(FMADD, dst, src1, src2, src3, floatFromSize(size));
2809     }
2810 
2811     /**
2812      * dst = src3 - src1 * src2.
2813      *
2814      * @param size register size.
2815      * @param dst floating point register. May not be null.
2816      * @param src1 floating point register. May not be null.
2817      * @param src2 floating point register. May not be null.
2818      * @param src3 floating point register. May not be null.
2819      */
2820     protected void fmsub(int size, Register dst, Register src1, Register src2, Register src3) {
2821         fpDataProcessing3Source(FMSUB, dst, src1, src2, src3, floatFromSize(size));
2822     }
2823 
2824     private void fpDataProcessing3Source(Instruction instr, Register dst, Register src1, Register src2, Register src3, InstructionType type) {
2825         assert dst.getRegisterCategory().equals(SIMD);
2826         assert src1.getRegisterCategory().equals(SIMD);
2827         assert src2.getRegisterCategory().equals(SIMD);
2828         assert src3.getRegisterCategory().equals(SIMD);
2829         emitInt(type.encoding | instr.encoding | Fp3SourceOp | rd(dst) | rs1(src1) | rs2(src2) | rs3(src3));
2830     }
2831 
2832     /* Floating-point Comparison (5.7.10) */
2833 
2834     /**
2835      * Compares src1 to src2.
2836      *
2837      * @param size register size.
2838      * @param src1 floating point register. May not be null.
2839      * @param src2 floating point register. May not be null.
2840      */
2841     public void fcmp(int size, Register src1, Register src2) {
2842         assert src1.getRegisterCategory().equals(SIMD);
2843         assert src2.getRegisterCategory().equals(SIMD);
2844         InstructionType type = floatFromSize(size);
2845         emitInt(type.encoding | FCMP.encoding | FpCmpOp | rs1(src1) | rs2(src2));
2846     }
2847 
2848     /**
2849      * Signalling compares src1 to src2.
2850      *
2851      * @param size register size.
2852      * @param src1 floating point register. May not be null.
2853      * @param src2 floating point register. May not be null.
2854      */
2855     public void fcmpe(int size, Register src1, Register src2) {
2856         assert src1.getRegisterCategory().equals(SIMD);
2857         assert src2.getRegisterCategory().equals(SIMD);
2858         InstructionType type = floatFromSize(size);
2859         emitInt(type.encoding | FCMP.encoding | FpCmpeOp | rs1(src1) | rs2(src2));
2860     }
2861 
2862     /**
2863      * Conditional compare. NZCV = fcmp(src1, src2) if condition else uimm4.
2864      *
2865      * @param size register size.
2866      * @param src1 floating point register. May not be null.
2867      * @param src2 floating point register. May not be null.
2868      * @param uimm4 condition flags that are used if condition is false.
2869      * @param condition every condition allowed. May not be null.
2870      */
2871     public void fccmp(int size, Register src1, Register src2, int uimm4, ConditionFlag condition) {
2872         assert NumUtil.isUnsignedNbit(4, uimm4);
2873         assert src1.getRegisterCategory().equals(SIMD);
2874         assert src2.getRegisterCategory().equals(SIMD);
2875         InstructionType type = floatFromSize(size);
2876         emitInt(type.encoding | FCCMP.encoding | uimm4 | condition.encoding &lt;&lt; ConditionalConditionOffset | rs1(src1) | rs2(src2));
2877     }
2878 
2879     /**
2880      * Compare register to 0.0 .
2881      *
2882      * @param size register size.
2883      * @param src floating point register. May not be null.
2884      */
2885     public void fcmpZero(int size, Register src) {
2886         assert src.getRegisterCategory().equals(SIMD);
2887         InstructionType type = floatFromSize(size);
2888         emitInt(type.encoding | FCMPZERO.encoding | FpCmpOp | rs1(src));
2889     }
2890 
2891     /**
2892      * Signalling compare register to 0.0 .
2893      *
2894      * @param size register size.
2895      * @param src floating point register. May not be null.
2896      */
2897     public void fcmpeZero(int size, Register src) {
2898         assert src.getRegisterCategory().equals(SIMD);
2899         InstructionType type = floatFromSize(size);
2900         emitInt(type.encoding | FCMPZERO.encoding | FpCmpeOp | rs1(src));
2901     }
2902 
2903     /* Floating-point Conditional Select (5.7.11) */
2904 
2905     /**
2906      * Conditional select. dst = src1 if condition else src2.
2907      *
2908      * @param size register size.
2909      * @param dst floating point register. May not be null.
2910      * @param src1 floating point register. May not be null.
2911      * @param src2 floating point register. May not be null.
2912      * @param condition every condition allowed. May not be null.
2913      */
2914     protected void fcsel(int size, Register dst, Register src1, Register src2, ConditionFlag condition) {
2915         assert dst.getRegisterCategory().equals(SIMD);
2916         assert src1.getRegisterCategory().equals(SIMD);
2917         assert src2.getRegisterCategory().equals(SIMD);
2918         InstructionType type = floatFromSize(size);
2919         emitInt(type.encoding | FCSEL.encoding | rd(dst) | rs1(src1) | rs2(src2) | condition.encoding &lt;&lt; ConditionalConditionOffset);
2920     }
2921 
2922     /* Debug exceptions (5.9.1.2) */
2923 
2924     /**
2925      * Halting mode software breakpoint: Enters halting mode debug state if enabled, else treated as
2926      * UNALLOCATED instruction.
2927      *
2928      * @param uimm16 Arbitrary 16-bit unsigned payload.
2929      */
2930     protected void hlt(int uimm16) {
2931         exceptionInstruction(HLT, uimm16);
2932     }
2933 
2934     /**
2935      * Monitor mode software breakpoint: exception routed to a debug monitor executing in a higher
2936      * exception level.
2937      *
2938      * @param uimm16 Arbitrary 16-bit unsigned payload.
2939      */
2940     protected void brk(int uimm16) {
2941         exceptionInstruction(BRK, uimm16);
2942     }
2943 
2944     private void exceptionInstruction(Instruction instr, int uimm16) {
2945         assert NumUtil.isUnsignedNbit(16, uimm16);
2946         emitInt(instr.encoding | ExceptionOp | uimm16 &lt;&lt; SystemImmediateOffset);
2947     }
2948 
2949     /* Architectural hints (5.9.4) */
2950     public enum SystemHint {
2951         NOP(0x0),
2952         YIELD(0x1),
2953         WFE(0x2),
2954         WFI(0x3),
2955         SEV(0x4),
2956         SEVL(0x5),
2957         CSDB(0x14);
2958 
2959         private final int encoding;
2960 
2961         SystemHint(int encoding) {
2962             this.encoding = encoding;
2963         }
2964     }
2965 
2966     /**
2967      * Architectural hints.
2968      *
2969      * @param hint Can be any of the defined hints. May not be null.
2970      */
2971     protected void hint(SystemHint hint) {
2972         emitInt(HINT.encoding | hint.encoding &lt;&lt; SystemImmediateOffset);
2973     }
2974 
2975     /**
2976      * Clear Exclusive: clears the local record of the executing processor that an address has had a
2977      * request for an exclusive access.
2978      */
2979     protected void clrex() {
2980         emitInt(CLREX.encoding);
2981     }
2982 
2983     /**
2984      * Possible barrier definitions for Aarch64. LOAD_LOAD and LOAD_STORE map to the same underlying
2985      * barrier.
2986      *
2987      * We only need synchronization across the inner shareable domain (see B2-90 in the Reference
2988      * documentation).
2989      */
2990     public enum BarrierKind {
2991         LOAD_LOAD(0x9, &quot;ISHLD&quot;),
2992         LOAD_STORE(0x9, &quot;ISHLD&quot;),
2993         STORE_STORE(0xA, &quot;ISHST&quot;),
<a name="6" id="anc6"></a><span class="line-modified">2994         ANY_ANY(0xB, &quot;ISH&quot;),</span>
<span class="line-added">2995         SYSTEM(0xF, &quot;SYS&quot;);</span>
2996 
2997         public final int encoding;
2998         public final String optionName;
2999 
3000         BarrierKind(int encoding, String optionName) {
3001             this.encoding = encoding;
3002             this.optionName = optionName;
3003         }
3004     }
3005 
3006     /**
3007      * Data Memory Barrier.
3008      *
3009      * @param barrierKind barrier that is issued. May not be null.
3010      */
3011     public void dmb(BarrierKind barrierKind) {
3012         emitInt(DMB.encoding | BarrierOp | barrierKind.encoding &lt;&lt; BarrierKindOffset);
3013     }
3014 
<a name="7" id="anc7"></a><span class="line-added">3015     /**</span>
<span class="line-added">3016      * Instruction Synchronization Barrier.</span>
<span class="line-added">3017      */</span>
<span class="line-added">3018     public void isb() {</span>
<span class="line-added">3019         emitInt(ISB.encoding | BarrierOp | BarrierKind.SYSTEM.encoding &lt;&lt; BarrierKindOffset);</span>
<span class="line-added">3020     }</span>
<span class="line-added">3021 </span>
3022     public void mrs(Register dst, SystemRegister systemRegister) {
3023         emitInt(MRS.encoding | systemRegister.encoding() | rt(dst));
3024     }
3025 
3026     public void msr(SystemRegister systemRegister, Register src) {
3027         emitInt(MRS.encoding | systemRegister.encoding() | rt(src));
3028     }
3029 
3030     public void dc(DataCacheOperationType type, Register src) {
3031         emitInt(DC.encoding | type.encoding() | rt(src));
3032     }
3033 
3034     public void annotatePatchingImmediate(int pos, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {
3035         if (codePatchingAnnotationConsumer != null) {
3036             codePatchingAnnotationConsumer.accept(new SingleInstructionAnnotation(pos, instruction, operandSizeBits, offsetBits, shift));
3037         }
3038     }
3039 
<a name="8" id="anc8"></a><span class="line-modified">3040     public abstract static class PatchableCodeAnnotation extends CodeAnnotation {</span>
<span class="line-modified">3041 </span>
<span class="line-modified">3042         PatchableCodeAnnotation(int instructionStartPosition) {</span>
<span class="line-added">3043             super(instructionStartPosition);</span>
3044         }
<a name="9" id="anc9"></a><span class="line-added">3045 </span>
<span class="line-added">3046         abstract void patch(int codePos, int relative, byte[] code);</span>
3047     }
3048 
<a name="10" id="anc10"></a><span class="line-modified">3049     /**</span>
<span class="line-added">3050      * Contains methods used for patching instruction(s) within AArch64.</span>
<span class="line-added">3051      */</span>
<span class="line-added">3052     public static class PatcherUtil {</span>
<span class="line-added">3053         /**</span>
<span class="line-added">3054          * Method to patch a series a bytes within a byte address with a given value.</span>
<span class="line-added">3055          *</span>
<span class="line-added">3056          * @param code the array of bytes in which patch is to be performed</span>
<span class="line-added">3057          * @param codePos where in the array the patch should be performed</span>
<span class="line-added">3058          * @param value the value to be added to the series of bytes</span>
<span class="line-added">3059          * @param bitsUsed the number of bits to patch within each byte</span>
<span class="line-added">3060          * @param offsets where with the bytes the value should be added</span>
<span class="line-added">3061          */</span>
<span class="line-added">3062         public static void writeBitSequence(byte[] code, int codePos, int value, int[] bitsUsed, int[] offsets) {</span>
<span class="line-added">3063             assert bitsUsed.length == offsets.length : &quot;bitsUsed and offsets parameter arrays do not match&quot;;</span>
<span class="line-added">3064             int curValue = value;</span>
<span class="line-added">3065             for (int i = 0; i &lt; bitsUsed.length; i++) {</span>
<span class="line-added">3066                 int usedBits = bitsUsed[i];</span>
<span class="line-added">3067                 if (usedBits == 0) {</span>
<span class="line-added">3068                     continue;</span>
<span class="line-added">3069                 }</span>
<span class="line-added">3070 </span>
<span class="line-added">3071                 int offset = offsets[i];</span>
<span class="line-added">3072                 int mask = (1 &lt;&lt; usedBits) - 1;</span>
<span class="line-added">3073 </span>
<span class="line-added">3074                 byte patchTarget = code[codePos + i];</span>
<span class="line-added">3075                 byte patch = (byte) (((curValue &amp; mask) &lt;&lt; offset) &amp; 0xFF);</span>
<span class="line-added">3076                 byte retainedPatchTarget = (byte) (patchTarget &amp; ((~(mask &lt;&lt; offset)) &amp; 0xFF));</span>
<span class="line-added">3077                 patchTarget = (byte) (retainedPatchTarget | patch);</span>
<span class="line-added">3078                 code[codePos + i] = patchTarget;</span>
<span class="line-added">3079                 curValue = curValue &gt;&gt; usedBits;</span>
<span class="line-added">3080             }</span>
<span class="line-added">3081         }</span>
<span class="line-added">3082 </span>
<span class="line-added">3083         public static int computeRelativePageDifference(int target, int curPos, int pageSize) {</span>
<span class="line-added">3084             int relative = target / pageSize - curPos / pageSize;</span>
<span class="line-added">3085             return relative;</span>
<span class="line-added">3086         }</span>
<span class="line-added">3087     }</span>
<span class="line-added">3088 </span>
<span class="line-added">3089     public static class SingleInstructionAnnotation extends PatchableCodeAnnotation {</span>
3090 
3091         /**
3092          * The size of the operand, in bytes.
3093          */
3094         public final int operandSizeBits;
3095         public final int offsetBits;
3096         public final Instruction instruction;
3097         public final int shift;
3098 
3099         SingleInstructionAnnotation(int instructionPosition, Instruction instruction, int operandSizeBits, int offsetBits, int shift) {
3100             super(instructionPosition);
3101             this.operandSizeBits = operandSizeBits;
3102             this.offsetBits = offsetBits;
3103             this.shift = shift;
3104             this.instruction = instruction;
3105         }
<a name="11" id="anc11"></a>
3106 
<a name="12" id="anc12"></a><span class="line-modified">3107         @Override</span>
<span class="line-added">3108         public String toString() {</span>
<span class="line-added">3109             return &quot;SINGLE_INSTRUCTION&quot;;</span>
<span class="line-added">3110         }</span>
3111 
<a name="13" id="anc13"></a><span class="line-modified">3112         @Override</span>
<span class="line-modified">3113         public void patch(int codePos, int relative, byte[] code) {</span>
<span class="line-modified">3114             int curValue = relative;</span>
<span class="line-modified">3115             assert (curValue &amp; ((1 &lt;&lt; shift) - 1)) == 0 : &quot;relative offset has incorrect alignment&quot;;</span>
<span class="line-added">3116             curValue = curValue &gt;&gt; shift;</span>
3117 
<a name="14" id="anc14"></a><span class="line-modified">3118             // right this is only BL instructions are being patched here</span>
<span class="line-modified">3119             assert instruction == AArch64Assembler.Instruction.BL : &quot;trying to patch an unexpected instruction&quot;;</span>
<span class="line-modified">3120             GraalError.guarantee(NumUtil.isSignedNbit(operandSizeBits, curValue), &quot;value too large to fit into space&quot;);</span>
<span class="line-added">3121 </span>
<span class="line-added">3122             // fill in immediate operand of operandSizeBits starting at offsetBits within</span>
<span class="line-added">3123             // instruction</span>
<span class="line-added">3124             int bitsRemaining = operandSizeBits;</span>
<span class="line-added">3125             int offsetRemaining = offsetBits;</span>
<span class="line-added">3126 </span>
<span class="line-added">3127             int[] bitsUsed = new int[4];</span>
<span class="line-added">3128             int[] offsets = new int[4];</span>
<span class="line-added">3129 </span>
<span class="line-added">3130             for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-added">3131                 if (offsetRemaining &gt;= 8) {</span>
<span class="line-added">3132                     offsetRemaining -= 8;</span>
<span class="line-added">3133                     continue;</span>
<span class="line-added">3134                 }</span>
<span class="line-added">3135                 offsets[i] = offsetRemaining;</span>
<span class="line-added">3136                 // number of bits to be filled within this byte</span>
<span class="line-added">3137                 int bits = Math.min(8 - offsetRemaining, bitsRemaining);</span>
<span class="line-added">3138                 bitsUsed[i] = bits;</span>
<span class="line-added">3139                 bitsRemaining -= bits;</span>
<span class="line-added">3140 </span>
<span class="line-added">3141                 offsetRemaining = 0;</span>
<span class="line-added">3142             }</span>
<span class="line-added">3143             PatcherUtil.writeBitSequence(code, instructionPosition, curValue, bitsUsed, offsets);</span>
3144         }
3145     }
3146 
3147     /**
3148      * dst[0...n] = countBitCountOfEachByte(src[0...n]), n = size/8.
3149      *
3150      * @param size register size. Has to be 64 or 128.
3151      * @param dst SIMD register. Should not be null.
3152      * @param src SIMD register. Should not be null.
3153      */
3154     public void cnt(int size, Register dst, Register src) {
3155         assert 64 == size || 128 == size : &quot;Invalid size for cnt&quot;;
3156         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | CNT.encoding | rd(dst) | rs1(src));
3157     }
3158 
3159     /**
3160      * dst = src[0] + ....+ src[n].
3161      *
3162      * @param size register size. Has to be 64 or 128.
3163      * @param laneWidth the width that SIMD register is treated as different lanes with.
3164      * @param dst SIMD register. Should not be null.
3165      * @param src SIMD register. Should not be null.
3166      */
3167     public void addv(int size, SIMDElementSize laneWidth, Register dst, Register src) {
3168         assert 64 == size || 128 == size : &quot;Invalid size for addv&quot;;
3169         assert SIMDElementSize.DoubleWord != laneWidth : &quot;Invalid lane width for addv&quot;;
3170         assert 64 != size || SIMDElementSize.Word != laneWidth : &quot;Invalid size and lane combination for addv&quot;;
3171         emitInt((size &gt;&gt; 7) &lt;&lt; SIMDQBitOffset | laneWidth.encoding &lt;&lt; SIMDSizeOffset | ADDV.encoding | rd(dst) | rs1(src));
3172     }
3173 
3174     /**
3175      * dst = src[srcIdx].
3176      *
3177      * @param size register size. Can be 8, 16, 32 or 64.
3178      * @param dst general purpose register. Should not be null or zero-register.
3179      * @param srcIdx lane index of source register that dest data is from.
3180      * @param src SIMD register. Should not be null.
3181      */
3182     public void umov(int size, Register dst, int srcIdx, Register src) {
3183         assert (srcIdx + 1) * size &lt;= 128 : &quot;Invalid src vectRegister index&quot;;
3184         InstructionType simdDataType = simdFromSize(size);
3185         int imm5 = simdDataType.encoding | srcIdx &lt;&lt; Integer.numberOfTrailingZeros(simdDataType.encoding) + 1;
3186         emitInt((size &gt;&gt; 6) &lt;&lt; SIMDQBitOffset | imm5 &lt;&lt; SIMDImm5Offset | UMOV.encoding | rd(dst) | rs1(src));
3187     }
3188 }
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/Fields.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64SuitesCreator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalOptions.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/Fields.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.common;
 26 
 27 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;
 28 
 29 import java.util.ArrayList;

 30 import java.util.Collections;
 31 
 32 import org.graalvm.compiler.debug.GraalError;
 33 
 34 import sun.misc.Unsafe;
 35 
 36 /**
 37  * Describes fields in a class, primarily for access via {@link Unsafe}.
 38  */
 39 public class Fields {
 40 
 41     private static final Unsafe UNSAFE = getUnsafe();
 42 
 43     /**
 44      * Offsets used with {@link Unsafe} to access the fields.
 45      */
 46     protected final long[] offsets;
 47 
 48     /**
 49      * The names of the fields.
</pre>
<hr />
<pre>
129                     UNSAFE.putInt(to, offset, UNSAFE.getInt(from, offset));
130                 } else if (type == Long.TYPE) {
131                     UNSAFE.putLong(to, offset, UNSAFE.getLong(from, offset));
132                 } else if (type == Boolean.TYPE) {
133                     UNSAFE.putBoolean(to, offset, UNSAFE.getBoolean(from, offset));
134                 } else if (type == Float.TYPE) {
135                     UNSAFE.putFloat(to, offset, UNSAFE.getFloat(from, offset));
136                 } else if (type == Double.TYPE) {
137                     UNSAFE.putDouble(to, offset, UNSAFE.getDouble(from, offset));
138                 } else if (type == Short.TYPE) {
139                     UNSAFE.putShort(to, offset, UNSAFE.getShort(from, offset));
140                 } else if (type == Character.TYPE) {
141                     UNSAFE.putChar(to, offset, UNSAFE.getChar(from, offset));
142                 } else if (type == Byte.TYPE) {
143                     UNSAFE.putByte(to, offset, UNSAFE.getByte(from, offset));
144                 } else {
145                     assert false : &quot;unhandled property type: &quot; + type;
146                 }
147             } else {
148                 Object obj = UNSAFE.getObject(from, offset);







149                 UNSAFE.putObject(to, offset, trans == null ? obj : trans.apply(index, obj));
150             }
151         }
152     }
153 
























154     /**
155      * Gets the value of a field for a given object.
156      *
157      * @param object the object whose field is to be read
158      * @param index the index of the field (between 0 and {@link #getCount()})
159      * @return the value of the specified field which will be boxed if the field type is primitive
160      */
161     public Object get(Object object, int index) {
162         long offset = offsets[index];
163         Class&lt;?&gt; type = types[index];
164         Object value = null;
165         if (type.isPrimitive()) {
166             if (type == Integer.TYPE) {
167                 value = UNSAFE.getInt(object, offset);
168             } else if (type == Long.TYPE) {
169                 value = UNSAFE.getLong(object, offset);
170             } else if (type == Boolean.TYPE) {
171                 value = UNSAFE.getBoolean(object, offset);
172             } else if (type == Float.TYPE) {
173                 value = UNSAFE.getFloat(object, offset);
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.core.common;
 26 
 27 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;
 28 
 29 import java.util.ArrayList;
<span class="line-added"> 30 import java.util.Arrays;</span>
 31 import java.util.Collections;
 32 
 33 import org.graalvm.compiler.debug.GraalError;
 34 
 35 import sun.misc.Unsafe;
 36 
 37 /**
 38  * Describes fields in a class, primarily for access via {@link Unsafe}.
 39  */
 40 public class Fields {
 41 
 42     private static final Unsafe UNSAFE = getUnsafe();
 43 
 44     /**
 45      * Offsets used with {@link Unsafe} to access the fields.
 46      */
 47     protected final long[] offsets;
 48 
 49     /**
 50      * The names of the fields.
</pre>
<hr />
<pre>
130                     UNSAFE.putInt(to, offset, UNSAFE.getInt(from, offset));
131                 } else if (type == Long.TYPE) {
132                     UNSAFE.putLong(to, offset, UNSAFE.getLong(from, offset));
133                 } else if (type == Boolean.TYPE) {
134                     UNSAFE.putBoolean(to, offset, UNSAFE.getBoolean(from, offset));
135                 } else if (type == Float.TYPE) {
136                     UNSAFE.putFloat(to, offset, UNSAFE.getFloat(from, offset));
137                 } else if (type == Double.TYPE) {
138                     UNSAFE.putDouble(to, offset, UNSAFE.getDouble(from, offset));
139                 } else if (type == Short.TYPE) {
140                     UNSAFE.putShort(to, offset, UNSAFE.getShort(from, offset));
141                 } else if (type == Character.TYPE) {
142                     UNSAFE.putChar(to, offset, UNSAFE.getChar(from, offset));
143                 } else if (type == Byte.TYPE) {
144                     UNSAFE.putByte(to, offset, UNSAFE.getByte(from, offset));
145                 } else {
146                     assert false : &quot;unhandled property type: &quot; + type;
147                 }
148             } else {
149                 Object obj = UNSAFE.getObject(from, offset);
<span class="line-added">150                 if (obj != null &amp;&amp; type.isArray()) {</span>
<span class="line-added">151                     if (type.getComponentType().isPrimitive()) {</span>
<span class="line-added">152                         obj = copyObjectAsArray(obj);</span>
<span class="line-added">153                     } else {</span>
<span class="line-added">154                         obj = ((Object[]) obj).clone();</span>
<span class="line-added">155                     }</span>
<span class="line-added">156                 }</span>
157                 UNSAFE.putObject(to, offset, trans == null ? obj : trans.apply(index, obj));
158             }
159         }
160     }
161 
<span class="line-added">162     private static Object copyObjectAsArray(Object obj) {</span>
<span class="line-added">163         Object objCopy;</span>
<span class="line-added">164         if (obj instanceof int[]) {</span>
<span class="line-added">165             objCopy = Arrays.copyOf((int[]) obj, ((int[]) obj).length);</span>
<span class="line-added">166         } else if (obj instanceof short[]) {</span>
<span class="line-added">167             objCopy = Arrays.copyOf((short[]) obj, ((short[]) obj).length);</span>
<span class="line-added">168         } else if (obj instanceof long[]) {</span>
<span class="line-added">169             objCopy = Arrays.copyOf((long[]) obj, ((long[]) obj).length);</span>
<span class="line-added">170         } else if (obj instanceof float[]) {</span>
<span class="line-added">171             objCopy = Arrays.copyOf((float[]) obj, ((float[]) obj).length);</span>
<span class="line-added">172         } else if (obj instanceof double[]) {</span>
<span class="line-added">173             objCopy = Arrays.copyOf((double[]) obj, ((double[]) obj).length);</span>
<span class="line-added">174         } else if (obj instanceof boolean[]) {</span>
<span class="line-added">175             objCopy = Arrays.copyOf((boolean[]) obj, ((boolean[]) obj).length);</span>
<span class="line-added">176         } else if (obj instanceof byte[]) {</span>
<span class="line-added">177             objCopy = Arrays.copyOf((byte[]) obj, ((byte[]) obj).length);</span>
<span class="line-added">178         } else if (obj instanceof char[]) {</span>
<span class="line-added">179             objCopy = Arrays.copyOf((char[]) obj, ((char[]) obj).length);</span>
<span class="line-added">180         } else {</span>
<span class="line-added">181             throw GraalError.shouldNotReachHere();</span>
<span class="line-added">182         }</span>
<span class="line-added">183         return objCopy;</span>
<span class="line-added">184     }</span>
<span class="line-added">185 </span>
186     /**
187      * Gets the value of a field for a given object.
188      *
189      * @param object the object whose field is to be read
190      * @param index the index of the field (between 0 and {@link #getCount()})
191      * @return the value of the specified field which will be boxed if the field type is primitive
192      */
193     public Object get(Object object, int index) {
194         long offset = offsets[index];
195         Class&lt;?&gt; type = types[index];
196         Object value = null;
197         if (type.isPrimitive()) {
198             if (type == Integer.TYPE) {
199                 value = UNSAFE.getInt(object, offset);
200             } else if (type == Long.TYPE) {
201                 value = UNSAFE.getLong(object, offset);
202             } else if (type == Boolean.TYPE) {
203                 value = UNSAFE.getBoolean(object, offset);
204             } else if (type == Float.TYPE) {
205                 value = UNSAFE.getFloat(object, offset);
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64SuitesCreator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="GraalOptions.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64LIRGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
<span class="line-modified"> 31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;</span>
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
</pre>
<hr />
<pre>
 61 import org.graalvm.compiler.lir.ConstantValue;
 62 import org.graalvm.compiler.lir.LIRFrameState;
 63 import org.graalvm.compiler.lir.LIRInstruction;
 64 import org.graalvm.compiler.lir.LIRValueUtil;
 65 import org.graalvm.compiler.lir.LabelRef;
 66 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 67 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;
 68 import org.graalvm.compiler.lir.SwitchStrategy;
 69 import org.graalvm.compiler.lir.Variable;
 70 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 72 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 73 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 74 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 76 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 77 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64Call;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;



 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;
 87 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 89 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;



 90 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64Move;
 92 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 93 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
 94 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
 95 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
 96 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
 97 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
 98 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
 99 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
100 import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;
101 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;
102 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
103 import org.graalvm.compiler.lir.gen.LIRGenerator;
104 import org.graalvm.compiler.lir.hashing.Hasher;
105 import org.graalvm.compiler.phases.util.Providers;
106 
107 import jdk.vm.ci.amd64.AMD64;
108 import jdk.vm.ci.amd64.AMD64Kind;
109 import jdk.vm.ci.code.CallingConvention;
110 import jdk.vm.ci.code.Register;
111 import jdk.vm.ci.code.RegisterValue;
112 import jdk.vm.ci.code.StackSlot;
113 import jdk.vm.ci.meta.AllocatableValue;

114 import jdk.vm.ci.meta.JavaConstant;
115 import jdk.vm.ci.meta.JavaKind;
116 import jdk.vm.ci.meta.PlatformKind;
117 import jdk.vm.ci.meta.VMConstant;
118 import jdk.vm.ci.meta.Value;
119 import jdk.vm.ci.meta.ValueKind;
120 
121 /**
122  * This class implements the AMD64 specific portion of the LIR generator.
123  */
124 public abstract class AMD64LIRGenerator extends LIRGenerator {
125 
126     public AMD64LIRGenerator(LIRKindTool lirKindTool, AMD64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
127         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
128     }
129 
130     /**
131      * Checks whether the supplied constant can be used without loading it into a register for store
132      * operations, i.e., on the right hand side of a memory access.
133      *
</pre>
<hr />
<pre>
294     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
295         Variable result = newVariable(kind);
296         AMD64AddressValue addressValue = asAddressValue(address);
297         append(new AMD64Move.AtomicReadAndWriteOp((AMD64Kind) kind.getPlatformKind(), result, addressValue, asAllocatable(newValue)));
298         return result;
299     }
300 
301     @Override
302     public void emitNullCheck(Value address, LIRFrameState state) {
303         append(new AMD64Move.NullCheckOp(asAddressValue(address), state));
304     }
305 
306     @Override
307     public void emitJump(LabelRef label) {
308         assert label != null;
309         append(new JumpOp(label));
310     }
311 
312     @Override
313     public void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {
<span class="line-removed">314         Condition finalCondition = emitCompare(cmpKind, left, right, cond);</span>
315         if (cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE) {

316             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));





317         } else {
<span class="line-modified">318             append(new BranchOp(finalCondition, trueLabel, falseLabel, trueLabelProbability));</span>




































319         }



320     }
321 
322     public void emitCompareBranchMemory(AMD64Kind cmpKind, Value left, AMD64AddressValue right, LIRFrameState state, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel,
323                     double trueLabelProbability) {
<span class="line-removed">324         boolean mirrored = emitCompareMemory(cmpKind, left, right, state);</span>
<span class="line-removed">325         Condition finalCondition = mirrored ? cond.mirror() : cond;</span>
326         if (cmpKind.isXMM()) {
<span class="line-modified">327             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>








328         } else {
<span class="line-modified">329             append(new BranchOp(finalCondition, trueLabel, falseLabel, trueLabelProbability));</span>


















330         }
331     }
332 
333     @Override
334     public void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpLIRKind, double overflowProbability) {
335         append(new BranchOp(ConditionFlag.Overflow, overflow, noOverflow, overflowProbability));
336     }
337 
338     @Override
339     public void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
<span class="line-modified">340         emitIntegerTest(left, right);</span>
<span class="line-modified">341         append(new BranchOp(Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>














342     }
343 
344     @Override
345     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {
346         boolean isFloatComparison = cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE;
347 
348         Condition finalCondition = cond;
349         Value finalTrueValue = trueValue;
350         Value finalFalseValue = falseValue;
351         if (isFloatComparison) {
352             // eliminate the parity check in case of a float comparison
353             Value finalLeft = left;
354             Value finalRight = right;
355             if (unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(finalCondition)) {
356                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.mirror())) {
357                     finalCondition = finalCondition.mirror();
358                     finalLeft = right;
359                     finalRight = left;
360                 } else if (finalCondition != Condition.EQ &amp;&amp; finalCondition != Condition.NE) {
361                     // negating EQ and NE does not make any sense as we would need to negate
</pre>
<hr />
<pre>
419     }
420 
421     private void emitIntegerTest(Value a, Value b) {
422         if (a.getPlatformKind().getVectorLength() &gt; 1) {
423             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));
424         } else {
425             assert ((AMD64Kind) a.getPlatformKind()).isInteger();
426             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;
427             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {
428                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));
429             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {
430                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));
431             } else if (isAllocatableValue(b)) {
432                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));
433             } else {
434                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));
435             }
436         }
437     }
438 
<span class="line-removed">439     /**</span>
<span class="line-removed">440      * This method emits the compare against memory instruction, and may reorder the operands. It</span>
<span class="line-removed">441      * returns true if it did so.</span>
<span class="line-removed">442      *</span>
<span class="line-removed">443      * @param b the right operand of the comparison</span>
<span class="line-removed">444      * @return true if the left and right operands were switched, false otherwise</span>
<span class="line-removed">445      */</span>
<span class="line-removed">446     private boolean emitCompareMemory(AMD64Kind cmpKind, Value a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">447         OperandSize size;</span>
<span class="line-removed">448         switch (cmpKind) {</span>
<span class="line-removed">449             case BYTE:</span>
<span class="line-removed">450                 size = OperandSize.BYTE;</span>
<span class="line-removed">451                 break;</span>
<span class="line-removed">452             case WORD:</span>
<span class="line-removed">453                 size = OperandSize.WORD;</span>
<span class="line-removed">454                 break;</span>
<span class="line-removed">455             case DWORD:</span>
<span class="line-removed">456                 size = OperandSize.DWORD;</span>
<span class="line-removed">457                 break;</span>
<span class="line-removed">458             case QWORD:</span>
<span class="line-removed">459                 size = OperandSize.QWORD;</span>
<span class="line-removed">460                 break;</span>
<span class="line-removed">461             case SINGLE:</span>
<span class="line-removed">462                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(a), b, state));</span>
<span class="line-removed">463                 return false;</span>
<span class="line-removed">464             case DOUBLE:</span>
<span class="line-removed">465                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(a), b, state));</span>
<span class="line-removed">466                 return false;</span>
<span class="line-removed">467             default:</span>
<span class="line-removed">468                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);</span>
<span class="line-removed">469         }</span>
<span class="line-removed">470 </span>
<span class="line-removed">471         if (isConstantValue(a)) {</span>
<span class="line-removed">472             return emitCompareMemoryConOp(size, asConstantValue(a), b, state);</span>
<span class="line-removed">473         } else {</span>
<span class="line-removed">474             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
<span class="line-removed">475         }</span>
<span class="line-removed">476     }</span>
<span class="line-removed">477 </span>
<span class="line-removed">478     protected boolean emitCompareMemoryConOp(OperandSize size, ConstantValue a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">479         if (JavaConstant.isNull(a.getConstant())) {</span>
<span class="line-removed">480             append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, 0, state));</span>
<span class="line-removed">481             return true;</span>
<span class="line-removed">482         } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
<span class="line-removed">483             VMConstant vc = (VMConstant) a.getConstant();</span>
<span class="line-removed">484             append(new AMD64BinaryConsumer.MemoryVMConstOp(CMP.getMIOpcode(size, false), b, vc, state));</span>
<span class="line-removed">485             return true;</span>
<span class="line-removed">486         } else {</span>
<span class="line-removed">487             if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-removed">488                 long value = a.getJavaConstant().asLong();</span>
<span class="line-removed">489                 if (NumUtil.is32bit(value)) {</span>
<span class="line-removed">490                     append(new AMD64BinaryConsumer.MemoryConstOp(CMP, size, b, (int) value, state));</span>
<span class="line-removed">491                     return true;</span>
<span class="line-removed">492                 }</span>
<span class="line-removed">493             }</span>
<span class="line-removed">494             return emitCompareRegMemoryOp(size, asAllocatable(a), b, state);</span>
<span class="line-removed">495         }</span>
<span class="line-removed">496     }</span>
<span class="line-removed">497 </span>
<span class="line-removed">498     private boolean emitCompareRegMemoryOp(OperandSize size, AllocatableValue a, AMD64AddressValue b, LIRFrameState state) {</span>
<span class="line-removed">499         AMD64RMOp op = CMP.getRMOpcode(size);</span>
<span class="line-removed">500         append(new AMD64BinaryConsumer.MemoryRMOp(op, size, a, b, state));</span>
<span class="line-removed">501         return false;</span>
<span class="line-removed">502     }</span>
<span class="line-removed">503 </span>
504     /**
505      * This method emits the compare instruction, and may reorder the operands. It returns true if
506      * it did so.
507      *
508      * @param a the left operand of the comparison
509      * @param b the right operand of the comparison
510      * @param cond the condition of the comparison
511      * @return true if the left and right operands were switched, false otherwise
512      */
513     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
514         if (LIRValueUtil.isVariable(b)) {
515             emitRawCompare(cmpKind, b, a);
516             return cond.mirror();
517         } else {
518             emitRawCompare(cmpKind, a, b);
519             return cond;
520         }
521     }
522 
523     private void emitRawCompare(PlatformKind cmpKind, Value left, Value right) {
</pre>
<hr />
<pre>
542         } else {
543             append(new AMD64Call.DirectNearForeignCallOp(linkage, result, arguments, temps, info));
544         }
545     }
546 
547     @Override
548     public Variable emitByteSwap(Value input) {
549         Variable result = newVariable(LIRKind.combine(input));
550         append(new AMD64ByteSwapOp(result, input));
551         return result;
552     }
553 
554     @Override
555     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
556         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
557         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
558         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
559         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
560         emitMove(cnt1, length1);
561         emitMove(cnt2, length2);
<span class="line-modified">562         append(new AMD64ArrayCompareToOp(this, kind1, kind2, raxRes, array1, array2, cnt1, cnt2));</span>
563         Variable result = newVariable(resultKind);
564         emitMove(result, raxRes);
565         return result;
566     }
567 
568     @Override
569     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {
570         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
571         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));
572         return result;
573     }
574 
575     @Override
576     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {
577         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
578         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));
579         return result;
580     }
581 
582     /**
583      * Return the maximum size of vector registers used in SSE/AVX instructions.
584      */
585     protected int getMaxVectorSize() {
586         // default for &quot;unlimited&quot;
587         return -1;
588     }
589 







590     @Override
591     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {
592         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
593         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,
594                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));
595         return result;
596     }
597 
598     @Override
599     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
600         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
601         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
602         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
603 
604         emitMove(rsrc, src);
605         emitMove(rdst, dst);
606         emitMove(rlen, len);
607 
<span class="line-modified">608         append(new AMD64StringLatin1InflateOp(this, rsrc, rdst, rlen));</span>
609     }
610 
611     @Override
612     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
613         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
614         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
615         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
616 
617         emitMove(rsrc, src);
618         emitMove(rdst, dst);
619         emitMove(rlen, len);
620 
621         LIRKind reskind = LIRKind.value(AMD64Kind.DWORD);
622         RegisterValue rres = AMD64.rax.asValue(reskind);
623 
<span class="line-modified">624         append(new AMD64StringUTF16CompressOp(this, rres, rsrc, rdst, rlen));</span>
625 
626         Variable res = newVariable(reskind);
627         emitMove(res, rres);
628         return res;
629     }
630 
631     @Override
632     public void emitReturn(JavaKind kind, Value input) {
633         AllocatableValue operand = Value.ILLEGAL;
634         if (input != null) {
635             operand = resultOperandFor(kind, input.getValueKind());
636             emitMove(operand, input);
637         }
638         append(new ReturnOp(operand));
639     }
640 
641     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue temp) {
642         return new StrategySwitchOp(strategy, keyTargets, defaultTarget, key, temp);
643     }
644 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 
 26 package org.graalvm.compiler.core.amd64;
 27 
 28 import static jdk.vm.ci.code.ValueUtil.asRegister;
 29 import static jdk.vm.ci.code.ValueUtil.isAllocatableValue;
 30 import static jdk.vm.ci.code.ValueUtil.isRegister;
<span class="line-modified"> 31 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.BYTE;</span>
 32 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
 33 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
 34 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
 35 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
 36 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
 37 import static org.graalvm.compiler.lir.LIRValueUtil.asConstant;
 38 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
 39 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
 40 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
 41 import static org.graalvm.compiler.lir.LIRValueUtil.isIntConstant;
 42 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
 43 
 44 import java.util.Optional;
 45 
 46 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
 47 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
 48 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
 49 import org.graalvm.compiler.asm.amd64.AMD64Assembler.ConditionFlag;
 50 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
 51 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRMOp;
</pre>
<hr />
<pre>
 61 import org.graalvm.compiler.lir.ConstantValue;
 62 import org.graalvm.compiler.lir.LIRFrameState;
 63 import org.graalvm.compiler.lir.LIRInstruction;
 64 import org.graalvm.compiler.lir.LIRValueUtil;
 65 import org.graalvm.compiler.lir.LabelRef;
 66 import org.graalvm.compiler.lir.StandardOp.JumpOp;
 67 import org.graalvm.compiler.lir.StandardOp.ZapRegistersOp;
 68 import org.graalvm.compiler.lir.SwitchStrategy;
 69 import org.graalvm.compiler.lir.Variable;
 70 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 71 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 72 import org.graalvm.compiler.lir.amd64.AMD64ArrayCompareToOp;
 73 import org.graalvm.compiler.lir.amd64.AMD64ArrayEqualsOp;
 74 import org.graalvm.compiler.lir.amd64.AMD64ArrayIndexOfOp;
 75 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 76 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 77 import org.graalvm.compiler.lir.amd64.AMD64ByteSwapOp;
 78 import org.graalvm.compiler.lir.amd64.AMD64Call;
 79 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow;
 80 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.BranchOp;
<span class="line-added"> 81 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpBranchOp;</span>
<span class="line-added"> 82 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpConstBranchOp;</span>
<span class="line-added"> 83 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CmpDataBranchOp;</span>
 84 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondMoveOp;
 85 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.CondSetOp;
 86 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatBranchOp;
 87 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondMoveOp;
 88 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.FloatCondSetOp;
 89 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.HashTableSwitchOp;
 90 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.ReturnOp;
 91 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.StrategySwitchOp;
 92 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TableSwitchOp;
<span class="line-added"> 93 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestBranchOp;</span>
<span class="line-added"> 94 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestByteBranchOp;</span>
<span class="line-added"> 95 import org.graalvm.compiler.lir.amd64.AMD64ControlFlow.TestConstBranchOp;</span>
 96 import org.graalvm.compiler.lir.amd64.AMD64LFenceOp;
 97 import org.graalvm.compiler.lir.amd64.AMD64Move;
 98 import org.graalvm.compiler.lir.amd64.AMD64Move.CompareAndSwapOp;
 99 import org.graalvm.compiler.lir.amd64.AMD64Move.MembarOp;
100 import org.graalvm.compiler.lir.amd64.AMD64Move.StackLeaOp;
101 import org.graalvm.compiler.lir.amd64.AMD64PauseOp;
102 import org.graalvm.compiler.lir.amd64.AMD64StringLatin1InflateOp;
103 import org.graalvm.compiler.lir.amd64.AMD64StringUTF16CompressOp;
104 import org.graalvm.compiler.lir.amd64.AMD64ZapRegistersOp;
105 import org.graalvm.compiler.lir.amd64.AMD64ZapStackOp;
106 import org.graalvm.compiler.lir.amd64.AMD64ZeroMemoryOp;
107 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorCompareOp;
108 import org.graalvm.compiler.lir.gen.LIRGenerationResult;
109 import org.graalvm.compiler.lir.gen.LIRGenerator;
110 import org.graalvm.compiler.lir.hashing.Hasher;
111 import org.graalvm.compiler.phases.util.Providers;
112 
113 import jdk.vm.ci.amd64.AMD64;
114 import jdk.vm.ci.amd64.AMD64Kind;
115 import jdk.vm.ci.code.CallingConvention;
116 import jdk.vm.ci.code.Register;
117 import jdk.vm.ci.code.RegisterValue;
118 import jdk.vm.ci.code.StackSlot;
119 import jdk.vm.ci.meta.AllocatableValue;
<span class="line-added">120 import jdk.vm.ci.meta.Constant;</span>
121 import jdk.vm.ci.meta.JavaConstant;
122 import jdk.vm.ci.meta.JavaKind;
123 import jdk.vm.ci.meta.PlatformKind;
124 import jdk.vm.ci.meta.VMConstant;
125 import jdk.vm.ci.meta.Value;
126 import jdk.vm.ci.meta.ValueKind;
127 
128 /**
129  * This class implements the AMD64 specific portion of the LIR generator.
130  */
131 public abstract class AMD64LIRGenerator extends LIRGenerator {
132 
133     public AMD64LIRGenerator(LIRKindTool lirKindTool, AMD64ArithmeticLIRGenerator arithmeticLIRGen, MoveFactory moveFactory, Providers providers, LIRGenerationResult lirGenRes) {
134         super(lirKindTool, arithmeticLIRGen, moveFactory, providers, lirGenRes);
135     }
136 
137     /**
138      * Checks whether the supplied constant can be used without loading it into a register for store
139      * operations, i.e., on the right hand side of a memory access.
140      *
</pre>
<hr />
<pre>
301     public Value emitAtomicReadAndWrite(Value address, ValueKind&lt;?&gt; kind, Value newValue) {
302         Variable result = newVariable(kind);
303         AMD64AddressValue addressValue = asAddressValue(address);
304         append(new AMD64Move.AtomicReadAndWriteOp((AMD64Kind) kind.getPlatformKind(), result, addressValue, asAllocatable(newValue)));
305         return result;
306     }
307 
308     @Override
309     public void emitNullCheck(Value address, LIRFrameState state) {
310         append(new AMD64Move.NullCheckOp(asAddressValue(address), state));
311     }
312 
313     @Override
314     public void emitJump(LabelRef label) {
315         assert label != null;
316         append(new JumpOp(label));
317     }
318 
319     @Override
320     public void emitCompareBranch(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {

321         if (cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE) {
<span class="line-added">322             Condition finalCondition = emitCompare(cmpKind, left, right, cond);</span>
323             append(new FloatBranchOp(finalCondition, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));
<span class="line-added">324             return;</span>
<span class="line-added">325         }</span>
<span class="line-added">326 </span>
<span class="line-added">327         if (LIRValueUtil.isVariable(right)) {</span>
<span class="line-added">328             emitRawCompareBranch(OperandSize.get(cmpKind), load(right), loadNonConst(left), cond.mirror(), trueLabel, falseLabel, trueLabelProbability);</span>
329         } else {
<span class="line-modified">330             emitRawCompareBranch(OperandSize.get(cmpKind), load(left), loadNonConst(right), cond, trueLabel, falseLabel, trueLabelProbability);</span>
<span class="line-added">331         }</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
<span class="line-added">334     private void emitRawCompareBranch(OperandSize size, Variable left, Value right, Condition cond, LabelRef trueLabel, LabelRef falseLabel, double trueLabelProbability) {</span>
<span class="line-added">335         if (isConstantValue(right)) {</span>
<span class="line-added">336             Constant c = LIRValueUtil.asConstant(right);</span>
<span class="line-added">337             if (JavaConstant.isNull(c)) {</span>
<span class="line-added">338                 AMD64ArithmeticLIRGenerator arithmeticLIRGenerator = (AMD64ArithmeticLIRGenerator) arithmeticLIRGen;</span>
<span class="line-added">339                 if (arithmeticLIRGenerator.mustReplaceNullWithNullRegister(c)) {</span>
<span class="line-added">340                     append(new CmpBranchOp(size, left, arithmeticLIRGenerator.getNullRegisterValue(), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">341                 } else {</span>
<span class="line-added">342                     append(new TestBranchOp(size, left, left, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">343                 }</span>
<span class="line-added">344                 return;</span>
<span class="line-added">345             } else if (c instanceof VMConstant) {</span>
<span class="line-added">346                 VMConstant vc = (VMConstant) c;</span>
<span class="line-added">347                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getResult().getLIR().getOptions()) &amp;&amp; target().inlineObjects) {</span>
<span class="line-added">348                     append(new CmpConstBranchOp(DWORD, left, vc, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">349                 } else {</span>
<span class="line-added">350                     append(new CmpDataBranchOp(size, left, vc, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">351                 }</span>
<span class="line-added">352                 return;</span>
<span class="line-added">353             } else if (c instanceof JavaConstant) {</span>
<span class="line-added">354                 JavaConstant jc = (JavaConstant) c;</span>
<span class="line-added">355                 if (jc.isDefaultForKind()) {</span>
<span class="line-added">356                     if (size == BYTE) {</span>
<span class="line-added">357                         append(new TestByteBranchOp(left, left, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">358                     } else {</span>
<span class="line-added">359                         append(new TestBranchOp(size, left, left, null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">360                     }</span>
<span class="line-added">361                     return;</span>
<span class="line-added">362                 } else if (NumUtil.is32bit(jc.asLong())) {</span>
<span class="line-added">363                     append(new CmpConstBranchOp(size, left, (int) jc.asLong(), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">364                     return;</span>
<span class="line-added">365                 }</span>
<span class="line-added">366             }</span>
367         }
<span class="line-added">368 </span>
<span class="line-added">369         // fallback: load, then compare</span>
<span class="line-added">370         append(new CmpBranchOp(size, left, asAllocatable(right), null, cond, trueLabel, falseLabel, trueLabelProbability));</span>
371     }
372 
373     public void emitCompareBranchMemory(AMD64Kind cmpKind, Value left, AMD64AddressValue right, LIRFrameState state, Condition cond, boolean unorderedIsTrue, LabelRef trueLabel, LabelRef falseLabel,
374                     double trueLabelProbability) {


375         if (cmpKind.isXMM()) {
<span class="line-modified">376             if (cmpKind == AMD64Kind.SINGLE) {</span>
<span class="line-added">377                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PS, asAllocatable(left), right, state));</span>
<span class="line-added">378                 append(new FloatBranchOp(cond, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">379             } else if (cmpKind == AMD64Kind.DOUBLE) {</span>
<span class="line-added">380                 append(new AMD64BinaryConsumer.MemoryRMOp(SSEOp.UCOMIS, PD, asAllocatable(left), right, state));</span>
<span class="line-added">381                 append(new FloatBranchOp(cond, unorderedIsTrue, trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">382             } else {</span>
<span class="line-added">383                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);</span>
<span class="line-added">384             }</span>
385         } else {
<span class="line-modified">386             OperandSize size = OperandSize.get(cmpKind);</span>
<span class="line-added">387             if (isConstantValue(left)) {</span>
<span class="line-added">388                 ConstantValue a = asConstantValue(left);</span>
<span class="line-added">389                 if (JavaConstant.isNull(a.getConstant())) {</span>
<span class="line-added">390                     append(new CmpConstBranchOp(size, right, 0, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">391                     return;</span>
<span class="line-added">392                 } else if (a.getConstant() instanceof VMConstant &amp;&amp; size == DWORD &amp;&amp; target().inlineObjects) {</span>
<span class="line-added">393                     VMConstant vc = (VMConstant) a.getConstant();</span>
<span class="line-added">394                     append(new CmpConstBranchOp(size, right, vc, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">395                     return;</span>
<span class="line-added">396                 } else if (a.getConstant() instanceof JavaConstant &amp;&amp; a.getJavaConstant().getJavaKind() != JavaKind.Object) {</span>
<span class="line-added">397                     long value = a.getJavaConstant().asLong();</span>
<span class="line-added">398                     if (NumUtil.is32bit(value)) {</span>
<span class="line-added">399                         append(new CmpConstBranchOp(size, right, (int) value, state, cond.mirror(), trueLabel, falseLabel, trueLabelProbability));</span>
<span class="line-added">400                         return;</span>
<span class="line-added">401                     }</span>
<span class="line-added">402                 }</span>
<span class="line-added">403             }</span>
<span class="line-added">404             append(new CmpBranchOp(size, asAllocatable(left), right, state, cond, trueLabel, falseLabel, trueLabelProbability));</span>
405         }
406     }
407 
408     @Override
409     public void emitOverflowCheckBranch(LabelRef overflow, LabelRef noOverflow, LIRKind cmpLIRKind, double overflowProbability) {
410         append(new BranchOp(ConditionFlag.Overflow, overflow, noOverflow, overflowProbability));
411     }
412 
413     @Override
414     public void emitIntegerTestBranch(Value left, Value right, LabelRef trueDestination, LabelRef falseDestination, double trueDestinationProbability) {
<span class="line-modified">415         if (left.getPlatformKind().getVectorLength() &gt; 1) {</span>
<span class="line-modified">416             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(left), asAllocatable(left), asAllocatable(right)));</span>
<span class="line-added">417             append(new BranchOp(Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">418         } else {</span>
<span class="line-added">419             assert ((AMD64Kind) left.getPlatformKind()).isInteger();</span>
<span class="line-added">420             OperandSize size = left.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;</span>
<span class="line-added">421             if (isJavaConstant(right) &amp;&amp; NumUtil.is32bit(asJavaConstant(right).asLong())) {</span>
<span class="line-added">422                 append(new TestConstBranchOp(size, asAllocatable(left), (int) asJavaConstant(right).asLong(), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">423             } else if (isJavaConstant(left) &amp;&amp; NumUtil.is32bit(asJavaConstant(left).asLong())) {</span>
<span class="line-added">424                 append(new TestConstBranchOp(size, asAllocatable(right), (int) asJavaConstant(left).asLong(), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">425             } else if (isAllocatableValue(right)) {</span>
<span class="line-added">426                 append(new TestBranchOp(size, asAllocatable(right), asAllocatable(left), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">427             } else {</span>
<span class="line-added">428                 append(new TestBranchOp(size, asAllocatable(left), asAllocatable(right), null, Condition.EQ, trueDestination, falseDestination, trueDestinationProbability));</span>
<span class="line-added">429             }</span>
<span class="line-added">430         }</span>
431     }
432 
433     @Override
434     public Variable emitConditionalMove(PlatformKind cmpKind, Value left, Value right, Condition cond, boolean unorderedIsTrue, Value trueValue, Value falseValue) {
435         boolean isFloatComparison = cmpKind == AMD64Kind.SINGLE || cmpKind == AMD64Kind.DOUBLE;
436 
437         Condition finalCondition = cond;
438         Value finalTrueValue = trueValue;
439         Value finalFalseValue = falseValue;
440         if (isFloatComparison) {
441             // eliminate the parity check in case of a float comparison
442             Value finalLeft = left;
443             Value finalRight = right;
444             if (unorderedIsTrue != AMD64ControlFlow.trueOnUnordered(finalCondition)) {
445                 if (unorderedIsTrue == AMD64ControlFlow.trueOnUnordered(finalCondition.mirror())) {
446                     finalCondition = finalCondition.mirror();
447                     finalLeft = right;
448                     finalRight = left;
449                 } else if (finalCondition != Condition.EQ &amp;&amp; finalCondition != Condition.NE) {
450                     // negating EQ and NE does not make any sense as we would need to negate
</pre>
<hr />
<pre>
508     }
509 
510     private void emitIntegerTest(Value a, Value b) {
511         if (a.getPlatformKind().getVectorLength() &gt; 1) {
512             append(new AMD64VectorCompareOp(VexRMOp.VPTEST, getRegisterSize(a), asAllocatable(a), asAllocatable(b)));
513         } else {
514             assert ((AMD64Kind) a.getPlatformKind()).isInteger();
515             OperandSize size = a.getPlatformKind() == AMD64Kind.QWORD ? QWORD : DWORD;
516             if (isJavaConstant(b) &amp;&amp; NumUtil.is32bit(asJavaConstant(b).asLong())) {
517                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(a), (int) asJavaConstant(b).asLong()));
518             } else if (isJavaConstant(a) &amp;&amp; NumUtil.is32bit(asJavaConstant(a).asLong())) {
519                 append(new AMD64BinaryConsumer.ConstOp(AMD64MIOp.TEST, size, asAllocatable(b), (int) asJavaConstant(a).asLong()));
520             } else if (isAllocatableValue(b)) {
521                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(b), asAllocatable(a)));
522             } else {
523                 append(new AMD64BinaryConsumer.Op(AMD64RMOp.TEST, size, asAllocatable(a), asAllocatable(b)));
524             }
525         }
526     }
527 

































































528     /**
529      * This method emits the compare instruction, and may reorder the operands. It returns true if
530      * it did so.
531      *
532      * @param a the left operand of the comparison
533      * @param b the right operand of the comparison
534      * @param cond the condition of the comparison
535      * @return true if the left and right operands were switched, false otherwise
536      */
537     private Condition emitCompare(PlatformKind cmpKind, Value a, Value b, Condition cond) {
538         if (LIRValueUtil.isVariable(b)) {
539             emitRawCompare(cmpKind, b, a);
540             return cond.mirror();
541         } else {
542             emitRawCompare(cmpKind, a, b);
543             return cond;
544         }
545     }
546 
547     private void emitRawCompare(PlatformKind cmpKind, Value left, Value right) {
</pre>
<hr />
<pre>
566         } else {
567             append(new AMD64Call.DirectNearForeignCallOp(linkage, result, arguments, temps, info));
568         }
569     }
570 
571     @Override
572     public Variable emitByteSwap(Value input) {
573         Variable result = newVariable(LIRKind.combine(input));
574         append(new AMD64ByteSwapOp(result, input));
575         return result;
576     }
577 
578     @Override
579     public Variable emitArrayCompareTo(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length1, Value length2) {
580         LIRKind resultKind = LIRKind.value(AMD64Kind.DWORD);
581         RegisterValue raxRes = AMD64.rax.asValue(resultKind);
582         RegisterValue cnt1 = AMD64.rcx.asValue(length1.getValueKind());
583         RegisterValue cnt2 = AMD64.rdx.asValue(length2.getValueKind());
584         emitMove(cnt1, length1);
585         emitMove(cnt2, length2);
<span class="line-modified">586         append(new AMD64ArrayCompareToOp(this, getAVX3Threshold(), kind1, kind2, raxRes, array1, array2, cnt1, cnt2));</span>
587         Variable result = newVariable(resultKind);
588         emitMove(result, raxRes);
589         return result;
590     }
591 
592     @Override
593     public Variable emitArrayEquals(JavaKind kind, Value array1, Value array2, Value length, boolean directPointers) {
594         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
595         append(new AMD64ArrayEqualsOp(this, kind, kind, result, array1, array2, length, directPointers, getMaxVectorSize()));
596         return result;
597     }
598 
599     @Override
600     public Variable emitArrayEquals(JavaKind kind1, JavaKind kind2, Value array1, Value array2, Value length, boolean directPointers) {
601         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
602         append(new AMD64ArrayEqualsOp(this, kind1, kind2, result, array1, array2, length, directPointers, getMaxVectorSize()));
603         return result;
604     }
605 
606     /**
607      * Return the maximum size of vector registers used in SSE/AVX instructions.
608      */
609     protected int getMaxVectorSize() {
610         // default for &quot;unlimited&quot;
611         return -1;
612     }
613 
<span class="line-added">614     /**</span>
<span class="line-added">615      * Return the minimal array size for using AVX3 instructions.</span>
<span class="line-added">616      */</span>
<span class="line-added">617     protected int getAVX3Threshold() {</span>
<span class="line-added">618         return 4096;</span>
<span class="line-added">619     }</span>
<span class="line-added">620 </span>
621     @Override
622     public Variable emitArrayIndexOf(JavaKind arrayKind, JavaKind valueKind, boolean findTwoConsecutive, Value arrayPointer, Value arrayLength, Value fromIndex, Value... searchValues) {
623         Variable result = newVariable(LIRKind.value(AMD64Kind.DWORD));
624         append(new AMD64ArrayIndexOfOp(arrayKind, valueKind, findTwoConsecutive, getMaxVectorSize(), this, result,
625                         asAllocatable(arrayPointer), asAllocatable(arrayLength), asAllocatable(fromIndex), searchValues));
626         return result;
627     }
628 
629     @Override
630     public void emitStringLatin1Inflate(Value src, Value dst, Value len) {
631         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
632         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
633         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
634 
635         emitMove(rsrc, src);
636         emitMove(rdst, dst);
637         emitMove(rlen, len);
638 
<span class="line-modified">639         append(new AMD64StringLatin1InflateOp(this, getAVX3Threshold(), rsrc, rdst, rlen));</span>
640     }
641 
642     @Override
643     public Variable emitStringUTF16Compress(Value src, Value dst, Value len) {
644         RegisterValue rsrc = AMD64.rsi.asValue(src.getValueKind());
645         RegisterValue rdst = AMD64.rdi.asValue(dst.getValueKind());
646         RegisterValue rlen = AMD64.rdx.asValue(len.getValueKind());
647 
648         emitMove(rsrc, src);
649         emitMove(rdst, dst);
650         emitMove(rlen, len);
651 
652         LIRKind reskind = LIRKind.value(AMD64Kind.DWORD);
653         RegisterValue rres = AMD64.rax.asValue(reskind);
654 
<span class="line-modified">655         append(new AMD64StringUTF16CompressOp(this, getAVX3Threshold(), rres, rsrc, rdst, rlen));</span>
656 
657         Variable res = newVariable(reskind);
658         emitMove(res, rres);
659         return res;
660     }
661 
662     @Override
663     public void emitReturn(JavaKind kind, Value input) {
664         AllocatableValue operand = Value.ILLEGAL;
665         if (input != null) {
666             operand = resultOperandFor(kind, input.getValueKind());
667             emitMove(operand, input);
668         }
669         append(new ReturnOp(operand));
670     }
671 
672     protected StrategySwitchOp createStrategySwitchOp(SwitchStrategy strategy, LabelRef[] keyTargets, LabelRef defaultTarget, Variable key, AllocatableValue temp) {
673         return new StrategySwitchOp(strategy, keyTargets, defaultTarget, key, temp);
674     }
675 
</pre>
</td>
</tr>
</table>
<center><a href="AMD64ArithmeticLIRGenerator.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="AMD64NodeMatchRules.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.core.amd64/src/org/graalvm/compiler/core/amd64/AMD64ArithmeticLIRGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 
  26 package org.graalvm.compiler.core.amd64;
  27 
  28 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.ADD;
  29 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.AND;
  30 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.CMP;
  31 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.OR;
  32 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.SUB;
  33 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic.XOR;
  34 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NEG;
  35 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp.NOT;
  36 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.BSF;
  37 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.BSR;
  38 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.LZCNT;
  39 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOV;
  40 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSD;
  41 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSS;
  42 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSX;
  43 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXB;
  44 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVSXD;
  45 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVZX;
  46 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.MOVZXB;
  47 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.POPCNT;
  48 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TEST;
  49 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TESTB;
  50 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp.TZCNT;
  51 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.ROL;
  52 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.ROR;
  53 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SAR;
  54 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SHL;
  55 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift.SHR;
  56 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSD;
  57 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VADDSS;
  58 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSD;
  59 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VDIVSS;
  60 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SD;
  61 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VFMADD231SS;
  62 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSD;
  63 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VMULSS;
  64 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPD;
  65 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VORPS;
  66 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSD;
  67 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VSUBSS;
  68 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VXORPD;
  69 import static org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp.VXORPS;
  70 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.BYTE;
  71 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.DWORD;
  72 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PD;
  73 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.PS;
  74 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.QWORD;
  75 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SD;
  76 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.SS;
  77 import static org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize.WORD;
  78 import static org.graalvm.compiler.core.common.GraalOptions.GeneratePIC;
  79 import static org.graalvm.compiler.lir.LIRValueUtil.asConstantValue;
  80 import static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;
  81 import static org.graalvm.compiler.lir.LIRValueUtil.isConstantValue;
  82 import static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;
  83 import static org.graalvm.compiler.lir.amd64.AMD64Arithmetic.DREM;
  84 import static org.graalvm.compiler.lir.amd64.AMD64Arithmetic.FREM;
  85 
  86 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64BinaryArithmetic;
  87 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MIOp;
  88 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MOp;
  89 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64MROp;
  90 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMIOp;
  91 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64RMOp;
  92 import org.graalvm.compiler.asm.amd64.AMD64Assembler.AMD64Shift;
  93 import org.graalvm.compiler.asm.amd64.AMD64Assembler.SSEOp;
  94 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexGeneralPurposeRMOp;
  95 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexGeneralPurposeRVMOp;
  96 import org.graalvm.compiler.asm.amd64.AMD64Assembler.VexRVMOp;
  97 import org.graalvm.compiler.asm.amd64.AMD64BaseAssembler.OperandSize;
  98 import org.graalvm.compiler.asm.amd64.AVXKind;
  99 import org.graalvm.compiler.asm.amd64.AVXKind.AVXSize;
 100 import org.graalvm.compiler.core.common.LIRKind;
 101 import org.graalvm.compiler.core.common.NumUtil;
 102 import org.graalvm.compiler.core.common.calc.FloatConvert;
 103 import org.graalvm.compiler.debug.GraalError;
 104 import org.graalvm.compiler.lir.ConstantValue;
 105 import org.graalvm.compiler.lir.LIRFrameState;
 106 import org.graalvm.compiler.lir.LIRValueUtil;
 107 import org.graalvm.compiler.lir.Variable;
 108 import org.graalvm.compiler.lir.amd64.AMD64AddressValue;
 109 import org.graalvm.compiler.lir.amd64.AMD64Arithmetic.FPDivRemOp;
 110 import org.graalvm.compiler.lir.amd64.AMD64ArithmeticLIRGeneratorTool;
 111 import org.graalvm.compiler.lir.amd64.AMD64Binary;
 112 import org.graalvm.compiler.lir.amd64.AMD64BinaryConsumer;
 113 import org.graalvm.compiler.lir.amd64.AMD64ClearRegisterOp;
 114 import org.graalvm.compiler.lir.amd64.AMD64MathCosOp;
 115 import org.graalvm.compiler.lir.amd64.AMD64MathExpOp;
 116 import org.graalvm.compiler.lir.amd64.AMD64MathLog10Op;
 117 import org.graalvm.compiler.lir.amd64.AMD64MathLogOp;
 118 import org.graalvm.compiler.lir.amd64.AMD64MathPowOp;
 119 import org.graalvm.compiler.lir.amd64.AMD64MathSinOp;
 120 import org.graalvm.compiler.lir.amd64.AMD64MathTanOp;
 121 import org.graalvm.compiler.lir.amd64.AMD64Move;
 122 import org.graalvm.compiler.lir.amd64.AMD64MulDivOp;
 123 import org.graalvm.compiler.lir.amd64.AMD64ShiftOp;
 124 import org.graalvm.compiler.lir.amd64.AMD64SignExtendOp;
 125 import org.graalvm.compiler.lir.amd64.AMD64Ternary;
 126 import org.graalvm.compiler.lir.amd64.AMD64Unary;
 127 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary;
 128 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryConstFloatOp;
 129 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorBinary.AVXBinaryOp;
 130 import org.graalvm.compiler.lir.amd64.vector.AMD64VectorUnary;
 131 import org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;
 132 
 133 import jdk.vm.ci.amd64.AMD64;
 134 import jdk.vm.ci.amd64.AMD64.CPUFeature;
 135 import jdk.vm.ci.amd64.AMD64Kind;
 136 import jdk.vm.ci.code.CodeUtil;
 137 import jdk.vm.ci.code.Register;
 138 import jdk.vm.ci.code.RegisterValue;
 139 import jdk.vm.ci.code.TargetDescription;
 140 import jdk.vm.ci.meta.AllocatableValue;
 141 import jdk.vm.ci.meta.Constant;
 142 import jdk.vm.ci.meta.JavaConstant;
 143 import jdk.vm.ci.meta.JavaKind;
 144 import jdk.vm.ci.meta.PlatformKind;
 145 import jdk.vm.ci.meta.VMConstant;
 146 import jdk.vm.ci.meta.Value;
 147 import jdk.vm.ci.meta.ValueKind;
 148 
 149 /**
 150  * This class implements the AMD64 specific portion of the LIR generator.
 151  */
 152 public class AMD64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AMD64ArithmeticLIRGeneratorTool {
 153 
 154     private static final RegisterValue RCX_I = AMD64.rcx.asValue(LIRKind.value(AMD64Kind.DWORD));
 155 
 156     public AMD64ArithmeticLIRGenerator(AllocatableValue nullRegisterValue) {
 157         this.nullRegisterValue = nullRegisterValue;
 158     }
 159 
 160     private final AllocatableValue nullRegisterValue;
 161 
 162     @Override
 163     public Variable emitNegate(Value inputVal) {
 164         AllocatableValue input = asAllocatable(inputVal);
 165         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
 166         boolean isAvx = supportAVX();
 167         switch ((AMD64Kind) input.getPlatformKind()) {
 168             case DWORD:
 169                 getLIRGen().append(new AMD64Unary.MOp(NEG, DWORD, result, input));
 170                 break;
 171             case QWORD:
 172                 getLIRGen().append(new AMD64Unary.MOp(NEG, QWORD, result, input));
 173                 break;
 174             case SINGLE:
 175                 JavaConstant floatMask = JavaConstant.forFloat(Float.intBitsToFloat(0x80000000));
 176                 if (isAvx) {
 177                     getLIRGen().append(new AVXBinaryOp(VXORPS, getRegisterSize(result), result, asAllocatable(input), asAllocatable(getLIRGen().emitJavaConstant(floatMask))));
 178                 } else {
 179                     getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.XOR, PS, result, input, floatMask, 16));
 180                 }
 181                 break;
 182             case DOUBLE:
 183                 JavaConstant doubleMask = JavaConstant.forDouble(Double.longBitsToDouble(0x8000000000000000L));
 184                 if (isAvx) {
 185                     getLIRGen().append(new AVXBinaryOp(VXORPD, getRegisterSize(result), result, asAllocatable(input), asAllocatable(getLIRGen().emitJavaConstant(doubleMask))));
 186                 } else {
 187                     getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.XOR, PD, result, input, doubleMask, 16));
 188                 }
 189                 break;
 190             default:
 191                 throw GraalError.shouldNotReachHere(input.getPlatformKind().toString());
 192         }
 193         return result;
 194     }
 195 
 196     @Override
 197     public Variable emitNot(Value inputVal) {
 198         AllocatableValue input = asAllocatable(inputVal);
 199         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
 200         switch ((AMD64Kind) input.getPlatformKind()) {
 201             case DWORD:
 202                 getLIRGen().append(new AMD64Unary.MOp(NOT, DWORD, result, input));
 203                 break;
 204             case QWORD:
 205                 getLIRGen().append(new AMD64Unary.MOp(NOT, QWORD, result, input));
 206                 break;
 207             default:
 208                 throw GraalError.shouldNotReachHere();
 209         }
 210         return result;
 211     }
 212 
 213     private Variable emitBinary(LIRKind resultKind, AMD64BinaryArithmetic op, OperandSize size, boolean commutative, Value a, Value b, boolean setFlags) {
 214         if (isJavaConstant(b)) {
 215             return emitBinaryConst(resultKind, op, size, commutative, asAllocatable(a), asConstantValue(b), setFlags);
 216         } else if (commutative &amp;&amp; isJavaConstant(a)) {
 217             return emitBinaryConst(resultKind, op, size, commutative, asAllocatable(b), asConstantValue(a), setFlags);
 218         } else {
 219             return emitBinaryVar(resultKind, op.getRMOpcode(size), size, commutative, asAllocatable(a), asAllocatable(b));
 220         }
 221     }
 222 
 223     private Variable emitBinary(LIRKind resultKind, AMD64RMOp op, OperandSize size, boolean commutative, Value a, Value b) {
 224         if (isJavaConstant(b)) {
 225             return emitBinaryConst(resultKind, op, size, asAllocatable(a), asJavaConstant(b));
 226         } else if (commutative &amp;&amp; isJavaConstant(a)) {
 227             return emitBinaryConst(resultKind, op, size, asAllocatable(b), asJavaConstant(a));
 228         } else {
 229             return emitBinaryVar(resultKind, op, size, commutative, asAllocatable(a), asAllocatable(b));
 230         }
 231     }
 232 
 233     private Variable emitBinaryConst(LIRKind resultKind, AMD64BinaryArithmetic op, OperandSize size, boolean commutative, AllocatableValue a, ConstantValue b, boolean setFlags) {
 234         long value = b.getJavaConstant().asLong();
 235         if (NumUtil.isInt(value)) {
 236             Variable result = getLIRGen().newVariable(resultKind);
 237             int constant = (int) value;
 238 
 239             if (!setFlags) {
 240                 AMD64MOp mop = getMOp(op, constant);
 241                 if (mop != null) {
 242                     getLIRGen().append(new AMD64Unary.MOp(mop, size, result, a));
 243                     return result;
 244                 }
 245             }
 246 
 247             getLIRGen().append(new AMD64Binary.ConstOp(op, size, result, a, constant));
 248             return result;
 249         } else {
 250             return emitBinaryVar(resultKind, op.getRMOpcode(size), size, commutative, a, asAllocatable(b));
 251         }
 252     }
 253 
 254     private static AMD64MOp getMOp(AMD64BinaryArithmetic op, int constant) {
 255         if (constant == 1) {
 256             if (op.equals(AMD64BinaryArithmetic.ADD)) {
 257                 return AMD64MOp.INC;
 258             }
 259             if (op.equals(AMD64BinaryArithmetic.SUB)) {
 260                 return AMD64MOp.DEC;
 261             }
 262         } else if (constant == -1) {
 263             if (op.equals(AMD64BinaryArithmetic.ADD)) {
 264                 return AMD64MOp.DEC;
 265             }
 266             if (op.equals(AMD64BinaryArithmetic.SUB)) {
 267                 return AMD64MOp.INC;
 268             }
 269         }
 270         return null;
 271     }
 272 
 273     private Variable emitBinaryConst(LIRKind resultKind, AMD64RMOp op, OperandSize size, AllocatableValue a, JavaConstant b) {
 274         Variable result = getLIRGen().newVariable(resultKind);
 275         getLIRGen().append(new AMD64Binary.DataTwoOp(op, size, result, a, b));
 276         return result;
 277     }
 278 
 279     private Variable emitBinaryVar(LIRKind resultKind, AMD64RMOp op, OperandSize size, boolean commutative, AllocatableValue a, AllocatableValue b) {
 280         Variable result = getLIRGen().newVariable(resultKind);
 281         if (commutative) {
 282             getLIRGen().append(new AMD64Binary.CommutativeTwoOp(op, size, result, a, b));
 283         } else {
 284             getLIRGen().append(new AMD64Binary.TwoOp(op, size, result, a, b));
 285         }
 286         return result;
 287     }
 288 
 289     @Override
 290     protected boolean isNumericInteger(PlatformKind kind) {
 291         return ((AMD64Kind) kind).isInteger();
 292     }
 293 
 294     private Variable emitBaseOffsetLea(LIRKind resultKind, Value base, int offset, OperandSize size) {
 295         Variable result = getLIRGen().newVariable(resultKind);
 296         AMD64AddressValue address = new AMD64AddressValue(resultKind, asAllocatable(base), offset);
 297         getLIRGen().append(new AMD64Move.LeaOp(result, address, size));
 298         return result;
 299     }
 300 
 301     @Override
 302     public Variable emitAdd(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 303         boolean isAvx = supportAVX();
 304         switch ((AMD64Kind) a.getPlatformKind()) {
 305             case DWORD:
 306                 if (isJavaConstant(b) &amp;&amp; !setFlags) {
 307                     long displacement = asJavaConstant(b).asLong();
 308                     if (NumUtil.isInt(displacement) &amp;&amp; displacement != 1 &amp;&amp; displacement != -1) {
 309                         return emitBaseOffsetLea(resultKind, a, (int) displacement, OperandSize.DWORD);
 310                     }
 311                 }
 312                 return emitBinary(resultKind, ADD, DWORD, true, a, b, setFlags);
 313             case QWORD:
 314                 if (isJavaConstant(b) &amp;&amp; !setFlags) {
 315                     long displacement = asJavaConstant(b).asLong();
 316                     if (NumUtil.isInt(displacement) &amp;&amp; displacement != 1 &amp;&amp; displacement != -1) {
 317                         return emitBaseOffsetLea(resultKind, a, (int) displacement, OperandSize.QWORD);
 318                     }
 319                 }
 320                 return emitBinary(resultKind, ADD, QWORD, true, a, b, setFlags);
 321             case SINGLE:
 322                 if (isAvx) {
 323                     return emitBinary(resultKind, VADDSS, a, b);
 324                 } else {
 325                     return emitBinary(resultKind, SSEOp.ADD, SS, true, a, b);
 326                 }
 327             case DOUBLE:
 328                 if (isAvx) {
 329                     return emitBinary(resultKind, VADDSD, a, b);
 330                 } else {
 331                     return emitBinary(resultKind, SSEOp.ADD, SD, true, a, b);
 332                 }
 333             default:
 334                 throw GraalError.shouldNotReachHere();
 335         }
 336     }
 337 
 338     @Override
 339     public Variable emitSub(LIRKind resultKind, Value a, Value b, boolean setFlags) {
 340         boolean isAvx = supportAVX();
 341         switch ((AMD64Kind) a.getPlatformKind()) {
 342             case DWORD:
 343                 return emitBinary(resultKind, SUB, DWORD, false, a, b, setFlags);
 344             case QWORD:
 345                 return emitBinary(resultKind, SUB, QWORD, false, a, b, setFlags);
 346             case SINGLE:
 347                 if (isAvx) {
 348                     return emitBinary(resultKind, VSUBSS, a, b);
 349                 } else {
 350                     return emitBinary(resultKind, SSEOp.SUB, SS, false, a, b);
 351                 }
 352             case DOUBLE:
 353                 if (isAvx) {
 354                     return emitBinary(resultKind, VSUBSD, a, b);
 355                 } else {
 356                     return emitBinary(resultKind, SSEOp.SUB, SD, false, a, b);
 357                 }
 358             default:
 359                 throw GraalError.shouldNotReachHere();
 360         }
 361     }
 362 
 363     private Variable emitIMULConst(OperandSize size, AllocatableValue a, ConstantValue b) {
 364         long value = b.getJavaConstant().asLong();
 365         if (NumUtil.isInt(value)) {
 366             int imm = (int) value;
 367             AMD64RMIOp op;
 368             if (NumUtil.isByte(imm)) {
 369                 op = AMD64RMIOp.IMUL_SX;
 370             } else {
 371                 op = AMD64RMIOp.IMUL;
 372             }
 373 
 374             Variable ret = getLIRGen().newVariable(LIRKind.combine(a, b));
 375             getLIRGen().append(new AMD64Binary.RMIOp(op, size, ret, a, imm));
 376             return ret;
 377         } else {
 378             return emitBinaryVar(LIRKind.combine(a, b), AMD64RMOp.IMUL, size, true, a, asAllocatable(b));
 379         }
 380     }
 381 
 382     private Variable emitIMUL(OperandSize size, Value a, Value b) {
 383         if (isJavaConstant(b)) {
 384             return emitIMULConst(size, asAllocatable(a), asConstantValue(b));
 385         } else if (isJavaConstant(a)) {
 386             return emitIMULConst(size, asAllocatable(b), asConstantValue(a));
 387         } else {
 388             return emitBinaryVar(LIRKind.combine(a, b), AMD64RMOp.IMUL, size, true, asAllocatable(a), asAllocatable(b));
 389         }
 390     }
 391 
 392     @Override
 393     public Variable emitMul(Value a, Value b, boolean setFlags) {
 394         boolean isAvx = supportAVX();
 395         LIRKind resultKind = LIRKind.combine(a, b);
 396         switch ((AMD64Kind) a.getPlatformKind()) {
 397             case DWORD:
 398                 return emitIMUL(DWORD, a, b);
 399             case QWORD:
 400                 return emitIMUL(QWORD, a, b);
 401             case SINGLE:
 402                 if (isAvx) {
 403                     return emitBinary(resultKind, VMULSS, a, b);
 404                 } else {
 405                     return emitBinary(resultKind, SSEOp.MUL, SS, true, a, b);
 406                 }
 407             case DOUBLE:
 408                 if (isAvx) {
 409                     return emitBinary(resultKind, VMULSD, a, b);
 410                 } else {
 411                     return emitBinary(resultKind, SSEOp.MUL, SD, true, a, b);
 412                 }
 413             default:
 414                 throw GraalError.shouldNotReachHere();
 415         }
 416     }
 417 
 418     private RegisterValue moveToReg(Register reg, Value v) {
 419         RegisterValue ret = reg.asValue(v.getValueKind());
 420         getLIRGen().emitMove(ret, v);
 421         return ret;
 422     }
 423 
 424     private Value emitMulHigh(AMD64MOp opcode, OperandSize size, Value a, Value b) {
 425         AMD64MulDivOp mulHigh = getLIRGen().append(new AMD64MulDivOp(opcode, size, LIRKind.combine(a, b), moveToReg(AMD64.rax, a), asAllocatable(b)));
 426         return getLIRGen().emitMove(mulHigh.getHighResult());
 427     }
 428 
 429     @Override
 430     public Value emitMulHigh(Value a, Value b) {
 431         switch ((AMD64Kind) a.getPlatformKind()) {
 432             case DWORD:
 433                 return emitMulHigh(AMD64MOp.IMUL, DWORD, a, b);
 434             case QWORD:
 435                 return emitMulHigh(AMD64MOp.IMUL, QWORD, a, b);
 436             default:
 437                 throw GraalError.shouldNotReachHere();
 438         }
 439     }
 440 
 441     @Override
 442     public Value emitUMulHigh(Value a, Value b) {
 443         switch ((AMD64Kind) a.getPlatformKind()) {
 444             case DWORD:
 445                 return emitMulHigh(AMD64MOp.MUL, DWORD, a, b);
 446             case QWORD:
 447                 return emitMulHigh(AMD64MOp.MUL, QWORD, a, b);
 448             default:
 449                 throw GraalError.shouldNotReachHere();
 450         }
 451     }
 452 
 453     public Value emitBinaryMemory(VexRVMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {
 454         assert (size.isXmmType() &amp;&amp; supportAVX());
 455         Variable result = getLIRGen().newVariable(LIRKind.combine(a));
 456         getLIRGen().append(new AMD64VectorBinary.AVXBinaryMemoryOp(op, getRegisterSize(result), result, a, location, state));
 457         return result;
 458     }
 459 
 460     public Value emitBinaryMemory(AMD64RMOp op, OperandSize size, AllocatableValue a, AMD64AddressValue location, LIRFrameState state) {
 461         Variable result = getLIRGen().newVariable(LIRKind.combine(a));
 462         getLIRGen().append(new AMD64Binary.MemoryTwoOp(op, size, result, a, location, state));
 463         return result;
 464     }
 465 
 466     protected Value emitConvertMemoryOp(PlatformKind kind, AMD64RMOp op, OperandSize size, AMD64AddressValue address, LIRFrameState state) {
 467         Variable result = getLIRGen().newVariable(LIRKind.value(kind));
 468         getLIRGen().append(new AMD64Unary.MemoryOp(op, size, result, address, state));
 469         return result;
 470     }
 471 
 472     protected Value emitZeroExtendMemory(AMD64Kind memoryKind, int resultBits, AMD64AddressValue address, LIRFrameState state) {
 473         // Issue a zero extending load of the proper bit size and set the result to
 474         // the proper kind.
 475         Variable result = getLIRGen().newVariable(LIRKind.value(resultBits &lt;= 32 ? AMD64Kind.DWORD : AMD64Kind.QWORD));
 476         switch (memoryKind) {
 477             case BYTE:
 478                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVZXB, DWORD, result, address, state));
 479                 break;
 480             case WORD:
 481                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVZX, DWORD, result, address, state));
 482                 break;
 483             case DWORD:
 484                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, DWORD, result, address, state));
 485                 break;
 486             case QWORD:
 487                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, QWORD, result, address, state));
 488                 break;
 489             default:
 490                 throw GraalError.shouldNotReachHere();
 491         }
 492         return result;
 493     }
 494 
 495     private AMD64MulDivOp emitIDIV(OperandSize size, Value a, Value b, LIRFrameState state) {
 496         LIRKind kind = LIRKind.combine(a, b);
 497 
 498         AMD64SignExtendOp sx = getLIRGen().append(new AMD64SignExtendOp(size, kind, moveToReg(AMD64.rax, a)));
 499         return getLIRGen().append(new AMD64MulDivOp(AMD64MOp.IDIV, size, kind, sx.getHighResult(), sx.getLowResult(), asAllocatable(b), state));
 500     }
 501 
 502     private AMD64MulDivOp emitDIV(OperandSize size, Value a, Value b, LIRFrameState state) {
 503         LIRKind kind = LIRKind.combine(a, b);
 504 
 505         RegisterValue rax = moveToReg(AMD64.rax, a);
 506         RegisterValue rdx = AMD64.rdx.asValue(kind);
 507         getLIRGen().append(new AMD64ClearRegisterOp(size, rdx));
 508         return getLIRGen().append(new AMD64MulDivOp(AMD64MOp.DIV, size, kind, rdx, rax, asAllocatable(b), state));
 509     }
 510 
 511     public Value[] emitSignedDivRem(Value a, Value b, LIRFrameState state) {
 512         AMD64MulDivOp op;
 513         switch ((AMD64Kind) a.getPlatformKind()) {
 514             case DWORD:
 515                 op = emitIDIV(DWORD, a, b, state);
 516                 break;
 517             case QWORD:
 518                 op = emitIDIV(QWORD, a, b, state);
 519                 break;
 520             default:
 521                 throw GraalError.shouldNotReachHere();
 522         }
 523         return new Value[]{getLIRGen().emitMove(op.getQuotient()), getLIRGen().emitMove(op.getRemainder())};
 524     }
 525 
 526     public Value[] emitUnsignedDivRem(Value a, Value b, LIRFrameState state) {
 527         AMD64MulDivOp op;
 528         switch ((AMD64Kind) a.getPlatformKind()) {
 529             case DWORD:
 530                 op = emitDIV(DWORD, a, b, state);
 531                 break;
 532             case QWORD:
 533                 op = emitDIV(QWORD, a, b, state);
 534                 break;
 535             default:
 536                 throw GraalError.shouldNotReachHere();
 537         }
 538         return new Value[]{getLIRGen().emitMove(op.getQuotient()), getLIRGen().emitMove(op.getRemainder())};
 539     }
 540 
 541     @Override
 542     public Value emitDiv(Value a, Value b, LIRFrameState state) {
 543         boolean isAvx = supportAVX();
 544         LIRKind resultKind = LIRKind.combine(a, b);
 545         switch ((AMD64Kind) a.getPlatformKind()) {
 546             case DWORD:
 547                 AMD64MulDivOp op = emitIDIV(DWORD, a, b, state);
 548                 return getLIRGen().emitMove(op.getQuotient());
 549             case QWORD:
 550                 AMD64MulDivOp lop = emitIDIV(QWORD, a, b, state);
 551                 return getLIRGen().emitMove(lop.getQuotient());
 552             case SINGLE:
 553                 if (isAvx) {
 554                     return emitBinary(resultKind, VDIVSS, a, b);
 555                 } else {
 556                     return emitBinary(resultKind, SSEOp.DIV, SS, false, a, b);
 557                 }
 558             case DOUBLE:
 559                 if (isAvx) {
 560                     return emitBinary(resultKind, VDIVSD, a, b);
 561                 } else {
 562                     return emitBinary(resultKind, SSEOp.DIV, SD, false, a, b);
 563                 }
 564             default:
 565                 throw GraalError.shouldNotReachHere();
 566         }
 567     }
 568 
 569     @Override
 570     public Value emitRem(Value a, Value b, LIRFrameState state) {
 571         switch ((AMD64Kind) a.getPlatformKind()) {
 572             case DWORD:
 573                 AMD64MulDivOp op = emitIDIV(DWORD, a, b, state);
 574                 return getLIRGen().emitMove(op.getRemainder());
 575             case QWORD:
 576                 AMD64MulDivOp lop = emitIDIV(QWORD, a, b, state);
 577                 return getLIRGen().emitMove(lop.getRemainder());
 578             case SINGLE: {
 579                 Variable result = getLIRGen().newVariable(LIRKind.combine(a, b));
 580                 getLIRGen().append(new FPDivRemOp(FREM, result, getLIRGen().load(a), getLIRGen().load(b)));
 581                 return result;
 582             }
 583             case DOUBLE: {
 584                 Variable result = getLIRGen().newVariable(LIRKind.combine(a, b));
 585                 getLIRGen().append(new FPDivRemOp(DREM, result, getLIRGen().load(a), getLIRGen().load(b)));
 586                 return result;
 587             }
 588             default:
 589                 throw GraalError.shouldNotReachHere();
 590         }
 591     }
 592 
 593     @Override
 594     public Variable emitUDiv(Value a, Value b, LIRFrameState state) {
 595         AMD64MulDivOp op;
 596         switch ((AMD64Kind) a.getPlatformKind()) {
 597             case DWORD:
 598                 op = emitDIV(DWORD, a, b, state);
 599                 break;
 600             case QWORD:
 601                 op = emitDIV(QWORD, a, b, state);
 602                 break;
 603             default:
 604                 throw GraalError.shouldNotReachHere();
 605         }
 606         return getLIRGen().emitMove(op.getQuotient());
 607     }
 608 
 609     @Override
 610     public Variable emitURem(Value a, Value b, LIRFrameState state) {
 611         AMD64MulDivOp op;
 612         switch ((AMD64Kind) a.getPlatformKind()) {
 613             case DWORD:
 614                 op = emitDIV(DWORD, a, b, state);
 615                 break;
 616             case QWORD:
 617                 op = emitDIV(QWORD, a, b, state);
 618                 break;
 619             default:
 620                 throw GraalError.shouldNotReachHere();
 621         }
 622         return getLIRGen().emitMove(op.getRemainder());
 623     }
 624 
 625     @Override
 626     public Variable emitAnd(Value a, Value b) {
 627         LIRKind resultKind = LIRKind.combine(a, b);
 628         switch ((AMD64Kind) a.getPlatformKind()) {
 629             case DWORD:
 630                 return emitBinary(resultKind, AND, DWORD, true, a, b, false);
 631             case QWORD:
 632                 return emitBinary(resultKind, AND, QWORD, true, a, b, false);
 633             case SINGLE:
 634                 return emitBinary(resultKind, SSEOp.AND, PS, true, a, b);
 635             case DOUBLE:
 636                 return emitBinary(resultKind, SSEOp.AND, PD, true, a, b);
 637             default:
 638                 throw GraalError.shouldNotReachHere();
 639         }
 640     }
 641 
 642     @Override
 643     public Variable emitOr(Value a, Value b) {
 644         boolean isAvx = supportAVX();
 645         LIRKind resultKind = LIRKind.combine(a, b);
 646         switch ((AMD64Kind) a.getPlatformKind()) {
 647             case DWORD:
 648                 return emitBinary(resultKind, OR, DWORD, true, a, b, false);
 649             case QWORD:
 650                 return emitBinary(resultKind, OR, QWORD, true, a, b, false);
 651             case SINGLE:
 652                 if (isAvx) {
 653                     return emitBinary(resultKind, VORPS, a, b);
 654                 } else {
 655                     return emitBinary(resultKind, SSEOp.OR, PS, true, a, b);
 656                 }
 657             case DOUBLE:
 658                 if (isAvx) {
 659                     return emitBinary(resultKind, VORPD, a, b);
 660                 } else {
 661                     return emitBinary(resultKind, SSEOp.OR, PD, true, a, b);
 662                 }
 663             default:
 664                 throw GraalError.shouldNotReachHere();
 665         }
 666     }
 667 
 668     @Override
 669     public Variable emitXor(Value a, Value b) {
 670         boolean isAvx = supportAVX();
 671         LIRKind resultKind = LIRKind.combine(a, b);
 672         switch ((AMD64Kind) a.getPlatformKind()) {
 673             case DWORD:
 674                 return emitBinary(resultKind, XOR, DWORD, true, a, b, false);
 675             case QWORD:
 676                 return emitBinary(resultKind, XOR, QWORD, true, a, b, false);
 677             case SINGLE:
 678                 if (isAvx) {
 679                     return emitBinary(resultKind, VXORPS, a, b);
 680                 } else {
 681                     return emitBinary(resultKind, SSEOp.XOR, PS, true, a, b);
 682                 }
 683             case DOUBLE:
 684                 if (isAvx) {
 685                     return emitBinary(resultKind, VXORPD, a, b);
 686                 } else {
 687                     return emitBinary(resultKind, SSEOp.XOR, PD, true, a, b);
 688                 }
 689             default:
 690                 throw GraalError.shouldNotReachHere();
 691         }
 692     }
 693 
 694     private Variable emitShift(AMD64Shift op, OperandSize size, Value a, Value b) {
 695         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b).changeType(a.getPlatformKind()));
 696         AllocatableValue input = asAllocatable(a);
 697         if (isJavaConstant(b)) {
 698             JavaConstant c = asJavaConstant(b);
 699             if (c.asLong() == 1) {
 700                 getLIRGen().append(new AMD64Unary.MOp(op.m1Op, size, result, input));
 701             } else {
 702                 /*
 703                  * c needs to be masked here, because shifts with immediate expect a byte.
 704                  */
 705                 getLIRGen().append(new AMD64Binary.ConstOp(op.miOp, size, result, input, (byte) c.asLong()));
 706             }
 707         } else {
 708             getLIRGen().emitMove(RCX_I, b);
 709             getLIRGen().append(new AMD64ShiftOp(op.mcOp, size, result, input, RCX_I));
 710         }
 711         return result;
 712     }
 713 
 714     @Override
 715     public Variable emitShl(Value a, Value b) {
 716         switch ((AMD64Kind) a.getPlatformKind()) {
 717             case DWORD:
 718                 return emitShift(SHL, DWORD, a, b);
 719             case QWORD:
 720                 return emitShift(SHL, QWORD, a, b);
 721             default:
 722                 throw GraalError.shouldNotReachHere();
 723         }
 724     }
 725 
 726     @Override
 727     public Variable emitShr(Value a, Value b) {
 728         switch ((AMD64Kind) a.getPlatformKind()) {
 729             case DWORD:
 730                 return emitShift(SAR, DWORD, a, b);
 731             case QWORD:
 732                 return emitShift(SAR, QWORD, a, b);
 733             default:
 734                 throw GraalError.shouldNotReachHere();
 735         }
 736     }
 737 
 738     @Override
 739     public Variable emitUShr(Value a, Value b) {
 740         switch ((AMD64Kind) a.getPlatformKind()) {
 741             case DWORD:
 742                 return emitShift(SHR, DWORD, a, b);
 743             case QWORD:
 744                 return emitShift(SHR, QWORD, a, b);
 745             default:
 746                 throw GraalError.shouldNotReachHere();
 747         }
 748     }
 749 
 750     public Variable emitRol(Value a, Value b) {
 751         switch ((AMD64Kind) a.getPlatformKind()) {
 752             case DWORD:
 753                 return emitShift(ROL, DWORD, a, b);
 754             case QWORD:
 755                 return emitShift(ROL, QWORD, a, b);
 756             default:
 757                 throw GraalError.shouldNotReachHere();
 758         }
 759     }
 760 
 761     @Override
 762     public Variable emitRor(Value a, Value b) {
 763         switch ((AMD64Kind) a.getPlatformKind()) {
 764             case DWORD:
 765                 return emitShift(ROR, DWORD, a, b);
 766             case QWORD:
 767                 return emitShift(ROR, QWORD, a, b);
 768             default:
 769                 throw GraalError.shouldNotReachHere();
 770         }
 771     }
 772 
 773     private AllocatableValue emitConvertOp(LIRKind kind, AMD64RMOp op, OperandSize size, Value input) {
 774         Variable result = getLIRGen().newVariable(kind);
 775         getLIRGen().append(new AMD64Unary.RMOp(op, size, result, asAllocatable(input)));
 776         return result;
 777     }
 778 
 779     private AllocatableValue emitConvertOp(LIRKind kind, AMD64MROp op, OperandSize size, Value input) {
 780         Variable result = getLIRGen().newVariable(kind);
 781         getLIRGen().append(new AMD64Unary.MROp(op, size, result, asAllocatable(input)));
 782         return result;
 783     }
 784 
 785     @Override
 786     public Value emitReinterpret(LIRKind to, Value inputVal) {
 787         ValueKind&lt;?&gt; from = inputVal.getValueKind();
 788         if (to.equals(from)) {
 789             return inputVal;
 790         }
 791 
 792         AllocatableValue input = asAllocatable(inputVal);
 793         /*
 794          * Conversions between integer to floating point types require moves between CPU and FPU
 795          * registers.
 796          */
<a name="2" id="anc2"></a><span class="line-modified"> 797         AMD64Kind fromKind = scalarKind((AMD64Kind) from.getPlatformKind());</span>
<span class="line-modified"> 798         AMD64Kind toKind = scalarKind((AMD64Kind) to.getPlatformKind());</span>
<span class="line-added"> 799         switch (toKind) {</span>
 800             case DWORD:
 801                 switch (fromKind) {
 802                     case SINGLE:
 803                         return emitConvertOp(to, AMD64MROp.MOVD, DWORD, input);
 804                 }
 805                 break;
 806             case QWORD:
 807                 switch (fromKind) {
 808                     case DOUBLE:
 809                         return emitConvertOp(to, AMD64MROp.MOVQ, QWORD, input);
 810                 }
 811                 break;
 812             case SINGLE:
 813                 switch (fromKind) {
 814                     case DWORD:
 815                         return emitConvertOp(to, AMD64RMOp.MOVD, DWORD, input);
 816                 }
 817                 break;
 818             case DOUBLE:
 819                 switch (fromKind) {
 820                     case QWORD:
 821                         return emitConvertOp(to, AMD64RMOp.MOVQ, QWORD, input);
 822                 }
 823                 break;
 824         }
<a name="3" id="anc3"></a><span class="line-modified"> 825         throw GraalError.shouldNotReachHere(toKind + &quot; &quot; + fromKind);</span>
<span class="line-added"> 826     }</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828     private static AMD64Kind scalarKind(AMD64Kind kind) {</span>
<span class="line-added"> 829         AMD64Kind resultKind = kind;</span>
<span class="line-added"> 830         if (kind.isXMM() &amp;&amp; kind.getVectorLength() &gt; 1) {</span>
<span class="line-added"> 831             if (kind.getSizeInBytes() == AMD64Kind.SINGLE.getSizeInBytes()) {</span>
<span class="line-added"> 832                 resultKind = AMD64Kind.SINGLE;</span>
<span class="line-added"> 833             } else if (kind.getSizeInBytes() == AMD64Kind.DOUBLE.getSizeInBytes()) {</span>
<span class="line-added"> 834                 resultKind = AMD64Kind.DOUBLE;</span>
<span class="line-added"> 835             } else {</span>
<span class="line-added"> 836                 GraalError.shouldNotReachHere(&quot;no equal size scalar kind for &quot; + kind);</span>
<span class="line-added"> 837             }</span>
<span class="line-added"> 838         }</span>
<span class="line-added"> 839         return resultKind;</span>
 840     }
 841 
 842     @Override
 843     public Value emitFloatConvert(FloatConvert op, Value input) {
 844         switch (op) {
 845             case D2F:
 846                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSD2SS, SD, input);
 847             case D2I:
 848                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSD2SI, DWORD, input);
 849             case D2L:
 850                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSD2SI, QWORD, input);
 851             case F2D:
 852                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSS2SD, SS, input);
 853             case F2I:
 854                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DWORD), SSEOp.CVTTSS2SI, DWORD, input);
 855             case F2L:
 856                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.QWORD), SSEOp.CVTTSS2SI, QWORD, input);
 857             case I2D:
 858                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, DWORD, input);
 859             case I2F:
 860                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSI2SS, DWORD, input);
 861             case L2D:
 862                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.DOUBLE), SSEOp.CVTSI2SD, QWORD, input);
 863             case L2F:
 864                 return emitConvertOp(LIRKind.combine(input).changeType(AMD64Kind.SINGLE), SSEOp.CVTSI2SS, QWORD, input);
 865             default:
 866                 throw GraalError.shouldNotReachHere();
 867         }
 868     }
 869 
 870     @Override
 871     public Value emitNarrow(Value inputVal, int bits) {
 872         if (inputVal.getPlatformKind() == AMD64Kind.QWORD &amp;&amp; bits &lt;= 32) {
 873             // TODO make it possible to reinterpret Long as Int in LIR without move
 874             return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), AMD64RMOp.MOV, DWORD, inputVal);
 875         } else {
 876             return inputVal;
 877         }
 878     }
 879 
 880     @Override
 881     public Value emitSignExtend(Value inputVal, int fromBits, int toBits) {
 882         assert fromBits &lt;= toBits &amp;&amp; toBits &lt;= 64;
 883         if (fromBits == toBits) {
 884             return inputVal;
 885         } else if (toBits &gt; 32) {
 886             // sign extend to 64 bits
 887             switch (fromBits) {
 888                 case 8:
 889                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSXB, QWORD, inputVal);
 890                 case 16:
 891                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSX, QWORD, inputVal);
 892                 case 32:
 893                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.QWORD), MOVSXD, QWORD, inputVal);
 894                 default:
 895                     throw GraalError.unimplemented(&quot;unsupported sign extension (&quot; + fromBits + &quot; bit -&gt; &quot; + toBits + &quot; bit)&quot;);
 896             }
 897         } else {
 898             // sign extend to 32 bits (smaller values are internally represented as 32 bit values)
 899             switch (fromBits) {
 900                 case 8:
 901                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), MOVSXB, DWORD, inputVal);
 902                 case 16:
 903                     return emitConvertOp(LIRKind.combine(inputVal).changeType(AMD64Kind.DWORD), MOVSX, DWORD, inputVal);
 904                 case 32:
 905                     return inputVal;
 906                 default:
 907                     throw GraalError.unimplemented(&quot;unsupported sign extension (&quot; + fromBits + &quot; bit -&gt; &quot; + toBits + &quot; bit)&quot;);
 908             }
 909         }
 910     }
 911 
 912     @Override
 913     public Value emitZeroExtend(Value inputVal, int fromBits, int toBits) {
 914         assert fromBits &lt;= toBits &amp;&amp; toBits &lt;= 64;
 915         if (fromBits == toBits) {
 916             return inputVal;
 917         } else if (fromBits &gt; 32) {
 918             assert inputVal.getPlatformKind() == AMD64Kind.QWORD;
 919             Variable result = getLIRGen().newVariable(LIRKind.combine(inputVal));
 920             long mask = CodeUtil.mask(fromBits);
 921             getLIRGen().append(new AMD64Binary.DataTwoOp(AND.getRMOpcode(QWORD), QWORD, result, asAllocatable(inputVal), JavaConstant.forLong(mask)));
 922             return result;
 923         } else {
 924             LIRKind resultKind = LIRKind.combine(inputVal);
 925             if (toBits &gt; 32) {
 926                 resultKind = resultKind.changeType(AMD64Kind.QWORD);
 927             } else {
 928                 resultKind = resultKind.changeType(AMD64Kind.DWORD);
 929             }
 930 
 931             /*
 932              * Always emit DWORD operations, even if the resultKind is Long. On AMD64, all DWORD
 933              * operations implicitly set the upper half of the register to 0, which is what we want
 934              * anyway. Compared to the QWORD oparations, the encoding of the DWORD operations is
 935              * sometimes one byte shorter.
 936              */
 937             switch (fromBits) {
 938                 case 8:
 939                     return emitConvertOp(resultKind, MOVZXB, DWORD, inputVal);
 940                 case 16:
 941                     return emitConvertOp(resultKind, MOVZX, DWORD, inputVal);
 942                 case 32:
 943                     return emitConvertOp(resultKind, MOV, DWORD, inputVal);
 944             }
 945 
 946             // odd bit count, fall back on manual masking
 947             Variable result = getLIRGen().newVariable(resultKind);
 948             JavaConstant mask;
 949             if (toBits &gt; 32) {
 950                 mask = JavaConstant.forLong(CodeUtil.mask(fromBits));
 951             } else {
 952                 mask = JavaConstant.forInt((int) CodeUtil.mask(fromBits));
 953             }
 954             getLIRGen().append(new AMD64Binary.DataTwoOp(AND.getRMOpcode(DWORD), DWORD, result, asAllocatable(inputVal), mask));
 955             return result;
 956         }
 957     }
 958 
 959     @Override
 960     public Variable emitBitCount(Value value) {
 961         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 962         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
 963         if (value.getPlatformKind() == AMD64Kind.QWORD) {
 964             getLIRGen().append(new AMD64Unary.RMOp(POPCNT, QWORD, result, asAllocatable(value)));
 965         } else {
 966             getLIRGen().append(new AMD64Unary.RMOp(POPCNT, DWORD, result, asAllocatable(value)));
 967         }
 968         return result;
 969     }
 970 
 971     @Override
 972     public Variable emitBitScanForward(Value value) {
 973         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 974         getLIRGen().append(new AMD64Unary.RMOp(BSF, QWORD, result, asAllocatable(value)));
 975         return result;
 976     }
 977 
 978     @Override
 979     public Variable emitBitScanReverse(Value value) {
 980         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
 981         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
 982         if (value.getPlatformKind() == AMD64Kind.QWORD) {
 983             getLIRGen().append(new AMD64Unary.RMOp(BSR, QWORD, result, asAllocatable(value)));
 984         } else {
 985             getLIRGen().append(new AMD64Unary.RMOp(BSR, DWORD, result, asAllocatable(value)));
 986         }
 987         return result;
 988     }
 989 
 990     @Override
 991     public Variable emitFusedMultiplyAdd(Value a, Value b, Value c) {
 992         Variable result = getLIRGen().newVariable(LIRKind.combine(a, b, c));
 993         assert ((AMD64Kind) a.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) b.getPlatformKind()).isXMM() &amp;&amp; ((AMD64Kind) c.getPlatformKind()).isXMM();
 994         assert a.getPlatformKind().equals(b.getPlatformKind());
 995         assert b.getPlatformKind().equals(c.getPlatformKind());
 996 
 997         if (a.getPlatformKind() == AMD64Kind.DOUBLE) {
 998             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SD, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));
 999         } else {
1000             assert a.getPlatformKind() == AMD64Kind.SINGLE;
1001             getLIRGen().append(new AMD64Ternary.ThreeOp(VFMADD231SS, AVXSize.XMM, result, asAllocatable(c), asAllocatable(a), asAllocatable(b)));
1002         }
1003         return result;
1004     }
1005 
1006     @Override
1007     public Value emitCountLeadingZeros(Value value) {
1008         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
1009         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
1010         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1011             getLIRGen().append(new AMD64Unary.RMOp(LZCNT, QWORD, result, asAllocatable(value)));
1012         } else {
1013             getLIRGen().append(new AMD64Unary.RMOp(LZCNT, DWORD, result, asAllocatable(value)));
1014         }
1015         return result;
1016     }
1017 
1018     @Override
1019     public Value emitCountTrailingZeros(Value value) {
1020         Variable result = getLIRGen().newVariable(LIRKind.combine(value).changeType(AMD64Kind.DWORD));
1021         assert ((AMD64Kind) value.getPlatformKind()).isInteger();
1022         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1023             getLIRGen().append(new AMD64Unary.RMOp(TZCNT, QWORD, result, asAllocatable(value)));
1024         } else {
1025             getLIRGen().append(new AMD64Unary.RMOp(TZCNT, DWORD, result, asAllocatable(value)));
1026         }
1027         return result;
1028     }
1029 
1030     @Override
1031     public Value emitLogicalAndNot(Value value1, Value value2) {
1032         Variable result = getLIRGen().newVariable(LIRKind.combine(value1, value2));
1033 
1034         if (value1.getPlatformKind() == AMD64Kind.QWORD) {
1035             getLIRGen().append(new AMD64VectorBinary.AVXBinaryOp(VexGeneralPurposeRVMOp.ANDN, AVXSize.QWORD, result, asAllocatable(value1), asAllocatable(value2)));
1036         } else {
1037             getLIRGen().append(new AMD64VectorBinary.AVXBinaryOp(VexGeneralPurposeRVMOp.ANDN, AVXSize.DWORD, result, asAllocatable(value1), asAllocatable(value2)));
1038         }
1039         return result;
1040     }
1041 
1042     @Override
1043     public Value emitLowestSetIsolatedBit(Value value) {
1044         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1045 
1046         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1047             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSI, AVXSize.QWORD, result, asAllocatable(value)));
1048         } else {
1049             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSI, AVXSize.DWORD, result, asAllocatable(value)));
1050         }
1051 
1052         return result;
1053     }
1054 
1055     @Override
1056     public Value emitGetMaskUpToLowestSetBit(Value value) {
1057         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1058 
1059         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1060             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSMSK, AVXSize.QWORD, result, asAllocatable(value)));
1061         } else {
1062             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSMSK, AVXSize.DWORD, result, asAllocatable(value)));
1063         }
1064 
1065         return result;
1066     }
1067 
1068     @Override
1069     public Value emitResetLowestSetBit(Value value) {
1070         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1071 
1072         if (value.getPlatformKind() == AMD64Kind.QWORD) {
1073             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSR, AVXSize.QWORD, result, asAllocatable(value)));
1074         } else {
1075             getLIRGen().append(new AMD64VectorUnary.AVXUnaryOp(VexGeneralPurposeRMOp.BLSR, AVXSize.DWORD, result, asAllocatable(value)));
1076         }
1077 
1078         return result;
1079     }
1080 
1081     @Override
1082     public Value emitMathAbs(Value input) {
1083         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
1084         switch ((AMD64Kind) input.getPlatformKind()) {
1085             case SINGLE:
1086                 getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.AND, PS, result, asAllocatable(input), JavaConstant.forFloat(Float.intBitsToFloat(0x7FFFFFFF)), 16));
1087                 break;
1088             case DOUBLE:
1089                 getLIRGen().append(new AMD64Binary.DataTwoOp(SSEOp.AND, PD, result, asAllocatable(input), JavaConstant.forDouble(Double.longBitsToDouble(0x7FFFFFFFFFFFFFFFL)), 16));
1090                 break;
1091             default:
1092                 throw GraalError.shouldNotReachHere();
1093         }
1094         return result;
1095     }
1096 
1097     @Override
1098     public Value emitMathSqrt(Value input) {
1099         Variable result = getLIRGen().newVariable(LIRKind.combine(input));
1100         switch ((AMD64Kind) input.getPlatformKind()) {
1101             case SINGLE:
1102                 getLIRGen().append(new AMD64Unary.RMOp(SSEOp.SQRT, SS, result, asAllocatable(input)));
1103                 break;
1104             case DOUBLE:
1105                 getLIRGen().append(new AMD64Unary.RMOp(SSEOp.SQRT, SD, result, asAllocatable(input)));
1106                 break;
1107             default:
1108                 throw GraalError.shouldNotReachHere();
1109         }
1110         return result;
1111     }
1112 
1113     @Override
1114     public Value emitMathLog(Value input, boolean base10) {
1115         if (base10) {
1116             return new AMD64MathLog10Op().emitLIRWrapper(getLIRGen(), input);
1117         } else {
1118             return new AMD64MathLogOp().emitLIRWrapper(getLIRGen(), input);
1119         }
1120     }
1121 
1122     @Override
1123     public Value emitMathCos(Value input) {
1124         return new AMD64MathCosOp().emitLIRWrapper(getLIRGen(), input);
1125     }
1126 
1127     @Override
1128     public Value emitMathSin(Value input) {
1129         return new AMD64MathSinOp().emitLIRWrapper(getLIRGen(), input);
1130     }
1131 
1132     @Override
1133     public Value emitMathTan(Value input) {
1134         return new AMD64MathTanOp().emitLIRWrapper(getLIRGen(), input);
1135     }
1136 
1137     @Override
1138     public Value emitMathExp(Value input) {
1139         return new AMD64MathExpOp().emitLIRWrapper(getLIRGen(), input);
1140     }
1141 
1142     @Override
1143     public Value emitMathPow(Value x, Value y) {
1144         return new AMD64MathPowOp().emitLIRWrapper(getLIRGen(), x, y);
1145     }
1146 
1147     protected AMD64LIRGenerator getAMD64LIRGen() {
1148         return (AMD64LIRGenerator) getLIRGen();
1149     }
1150 
1151     @Override
1152     public Variable emitLoad(LIRKind kind, Value address, LIRFrameState state) {
1153         AMD64AddressValue loadAddress = getAMD64LIRGen().asAddressValue(address);
1154         Variable result = getLIRGen().newVariable(getLIRGen().toRegisterKind(kind));
1155         switch ((AMD64Kind) kind.getPlatformKind()) {
1156             case BYTE:
1157                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSXB, DWORD, result, loadAddress, state));
1158                 break;
1159             case WORD:
1160                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSX, DWORD, result, loadAddress, state));
1161                 break;
1162             case DWORD:
1163                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, DWORD, result, loadAddress, state));
1164                 break;
1165             case QWORD:
1166                 getLIRGen().append(new AMD64Unary.MemoryOp(MOV, QWORD, result, loadAddress, state));
1167                 break;
1168             case SINGLE:
1169                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSS, SS, result, loadAddress, state));
1170                 break;
1171             case DOUBLE:
1172                 getLIRGen().append(new AMD64Unary.MemoryOp(MOVSD, SD, result, loadAddress, state));
1173                 break;
1174             default:
1175                 throw GraalError.shouldNotReachHere();
1176         }
1177         return result;
1178     }
1179 
1180     protected void emitStoreConst(AMD64Kind kind, AMD64AddressValue address, ConstantValue value, LIRFrameState state) {
1181         Constant c = value.getConstant();
1182         if (JavaConstant.isNull(c)) {
1183             assert kind == AMD64Kind.DWORD || kind == AMD64Kind.QWORD;
1184             OperandSize size = kind == AMD64Kind.DWORD ? DWORD : QWORD;
1185             getLIRGen().append(new AMD64BinaryConsumer.MemoryConstOp(AMD64MIOp.MOV, size, address, 0, state));
1186             return;
1187         } else if (c instanceof VMConstant) {
1188             // only 32-bit constants can be patched
1189             if (kind == AMD64Kind.DWORD) {
1190                 if (getLIRGen().target().inlineObjects || !(c instanceof JavaConstant)) {
1191                     // if c is a JavaConstant, it&#39;s an oop, otherwise it&#39;s a metaspace constant
1192                     assert !(c instanceof JavaConstant) || ((JavaConstant) c).getJavaKind() == JavaKind.Object;
1193                     getLIRGen().append(new AMD64BinaryConsumer.MemoryVMConstOp(AMD64MIOp.MOV, address, (VMConstant) c, state));
1194                     return;
1195                 }
1196             }
1197         } else {
1198             JavaConstant jc = (JavaConstant) c;
1199             assert jc.getJavaKind().isPrimitive();
1200 
1201             AMD64MIOp op = AMD64MIOp.MOV;
1202             OperandSize size;
1203             long imm;
1204 
1205             switch (kind) {
1206                 case BYTE:
1207                     op = AMD64MIOp.MOVB;
1208                     size = BYTE;
1209                     imm = jc.asInt();
1210                     break;
1211                 case WORD:
1212                     size = WORD;
1213                     imm = jc.asInt();
1214                     break;
1215                 case DWORD:
1216                     size = DWORD;
1217                     imm = jc.asInt();
1218                     break;
1219                 case QWORD:
1220                     size = QWORD;
1221                     imm = jc.asLong();
1222                     break;
1223                 case SINGLE:
1224                     size = DWORD;
1225                     imm = Float.floatToRawIntBits(jc.asFloat());
1226                     break;
1227                 case DOUBLE:
1228                     size = QWORD;
1229                     imm = Double.doubleToRawLongBits(jc.asDouble());
1230                     break;
1231                 default:
1232                     throw GraalError.shouldNotReachHere(&quot;unexpected kind &quot; + kind);
1233             }
1234 
1235             if (NumUtil.isInt(imm)) {
1236                 getLIRGen().append(new AMD64BinaryConsumer.MemoryConstOp(op, size, address, (int) imm, state));
1237                 return;
1238             }
1239         }
1240 
1241         // fallback: load, then store
1242         emitStore(kind, address, asAllocatable(value), state);
1243     }
1244 
1245     protected void emitStore(AMD64Kind kind, AMD64AddressValue address, AllocatableValue value, LIRFrameState state) {
1246         switch (kind) {
1247             case BYTE:
1248                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVB, BYTE, address, value, state));
1249                 break;
1250             case WORD:
1251                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, WORD, address, value, state));
1252                 break;
1253             case DWORD:
1254                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, DWORD, address, value, state));
1255                 break;
1256             case QWORD:
1257                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOV, QWORD, address, value, state));
1258                 break;
1259             case SINGLE:
1260                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSS, SS, address, value, state));
1261                 break;
1262             case DOUBLE:
1263                 getLIRGen().append(new AMD64BinaryConsumer.MemoryMROp(AMD64MROp.MOVSD, SD, address, value, state));
1264                 break;
1265             default:
1266                 throw GraalError.shouldNotReachHere();
1267         }
1268     }
1269 
1270     @Override
1271     public void emitStore(ValueKind&lt;?&gt; lirKind, Value address, Value input, LIRFrameState state) {
1272         AMD64AddressValue storeAddress = getAMD64LIRGen().asAddressValue(address);
1273         AMD64Kind kind = (AMD64Kind) lirKind.getPlatformKind();
1274         if (isConstantValue(input)) {
1275             emitStoreConst(kind, storeAddress, asConstantValue(input), state);
1276         } else {
1277             emitStore(kind, storeAddress, asAllocatable(input), state);
1278         }
1279     }
1280 
<a name="4" id="anc4"></a><span class="line-modified">1281     public boolean mustReplaceNullWithNullRegister(Constant nullConstant) {</span>
1282         /* Uncompressed null pointers only */
1283         return nullRegisterValue != null &amp;&amp; JavaConstant.NULL_POINTER.equals(nullConstant);
1284     }
1285 
<a name="5" id="anc5"></a><span class="line-added">1286     public AllocatableValue getNullRegisterValue() {</span>
<span class="line-added">1287         return nullRegisterValue;</span>
<span class="line-added">1288     }</span>
<span class="line-added">1289 </span>
1290     @Override
1291     public void emitCompareOp(AMD64Kind cmpKind, Variable left, Value right) {
1292         OperandSize size;
1293         switch (cmpKind) {
1294             case BYTE:
1295                 size = BYTE;
1296                 break;
1297             case WORD:
1298                 size = WORD;
1299                 break;
1300             case DWORD:
1301                 size = DWORD;
1302                 break;
1303             case QWORD:
1304                 size = QWORD;
1305                 break;
1306             case SINGLE:
1307                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PS, left, asAllocatable(right)));
1308                 return;
1309             case DOUBLE:
1310                 getLIRGen().append(new AMD64BinaryConsumer.Op(SSEOp.UCOMIS, PD, left, asAllocatable(right)));
1311                 return;
1312             default:
1313                 throw GraalError.shouldNotReachHere(&quot;unexpected kind: &quot; + cmpKind);
1314         }
1315 
1316         if (isConstantValue(right)) {
1317             Constant c = LIRValueUtil.asConstant(right);
1318             if (JavaConstant.isNull(c)) {
1319                 if (mustReplaceNullWithNullRegister(c)) {
1320                     getLIRGen().append(new AMD64BinaryConsumer.Op(AMD64RMOp.CMP, size, left, nullRegisterValue));
1321                 } else {
1322                     getLIRGen().append(new AMD64BinaryConsumer.Op(TEST, size, left, left));
1323                 }
1324                 return;
1325             } else if (c instanceof VMConstant) {
1326                 VMConstant vc = (VMConstant) c;
1327                 if (size == DWORD &amp;&amp; !GeneratePIC.getValue(getOptions()) &amp;&amp; getLIRGen().target().inlineObjects) {
1328                     getLIRGen().append(new AMD64BinaryConsumer.VMConstOp(CMP.getMIOpcode(DWORD, false), left, vc));
1329                 } else {
1330                     getLIRGen().append(new AMD64BinaryConsumer.DataOp(CMP.getRMOpcode(size), size, left, vc));
1331                 }
1332                 return;
1333             } else if (c instanceof JavaConstant) {
1334                 JavaConstant jc = (JavaConstant) c;
1335                 if (jc.isDefaultForKind()) {
1336                     AMD64RMOp op = size == BYTE ? TESTB : TEST;
1337                     getLIRGen().append(new AMD64BinaryConsumer.Op(op, size, left, left));
1338                     return;
1339                 } else if (NumUtil.is32bit(jc.asLong())) {
1340                     getLIRGen().append(new AMD64BinaryConsumer.ConstOp(CMP, size, left, (int) jc.asLong()));
1341                     return;
1342                 }
1343             }
1344         }
1345 
1346         // fallback: load, then compare
1347         getLIRGen().append(new AMD64BinaryConsumer.Op(CMP.getRMOpcode(size), size, left, asAllocatable(right)));
1348     }
1349 
1350     @Override
1351     public Value emitRound(Value value, RoundingMode mode) {
1352         Variable result = getLIRGen().newVariable(LIRKind.combine(value));
1353         assert ((AMD64Kind) value.getPlatformKind()).isXMM();
1354         if (value.getPlatformKind() == AMD64Kind.SINGLE) {
1355             getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSS, OperandSize.PD, result, asAllocatable(value), mode.encoding));
1356         } else {
1357             getLIRGen().append(new AMD64Binary.RMIOp(AMD64RMIOp.ROUNDSD, OperandSize.PD, result, asAllocatable(value), mode.encoding));
1358         }
1359         return result;
1360     }
1361 
1362     public boolean supportAVX() {
1363         TargetDescription target = getLIRGen().target();
1364         return ((AMD64) target.arch).getFeatures().contains(CPUFeature.AVX);
1365     }
1366 
1367     private static AVXSize getRegisterSize(Value a) {
1368         AMD64Kind kind = (AMD64Kind) a.getPlatformKind();
1369         if (kind.isXMM()) {
1370             return AVXKind.getRegisterSize(kind);
1371         } else {
1372             return AVXSize.XMM;
1373         }
1374     }
1375 
1376     protected Variable emitBinary(LIRKind resultKind, VexRVMOp op, Value a, Value b) {
1377         Variable result = getLIRGen().newVariable(resultKind);
1378         if (b instanceof ConstantValue &amp;&amp; (b.getPlatformKind() == AMD64Kind.SINGLE || b.getPlatformKind() == AMD64Kind.DOUBLE)) {
1379             getLIRGen().append(new AVXBinaryConstFloatOp(op, getRegisterSize(result), result, asAllocatable(a), (ConstantValue) b));
1380         } else {
1381             getLIRGen().append(new AVXBinaryOp(op, getRegisterSize(result), result, asAllocatable(a), asAllocatable(b)));
1382         }
1383         return result;
1384     }
1385 
1386 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
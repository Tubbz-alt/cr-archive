<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/CompileTheWorld.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot.test;
  26 
  27 import static java.util.Collections.singletonList;
  28 import static org.graalvm.compiler.core.CompilationWrapper.ExceptionAction.Print;
  29 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationBailoutAsFailure;
  30 import static org.graalvm.compiler.core.GraalCompilerOptions.CompilationFailureAction;
  31 import static org.graalvm.compiler.core.test.ReflectionOptionDescriptors.extractEntries;
  32 import static org.graalvm.compiler.debug.MemUseTrackerKey.getCurrentThreadAllocatedBytes;
  33 import static org.graalvm.compiler.hotspot.CompilationTask.CompilationTime;
  34 import static org.graalvm.compiler.hotspot.CompilationTask.CompiledAndInstalledBytecodes;
  35 import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.DESCRIPTORS;
  36 import static org.graalvm.compiler.hotspot.test.CompileTheWorld.Options.InvalidateInstalledCode;
  37 import static sun.misc.Unsafe.ARRAY_BYTE_BASE_OFFSET;
  38 
  39 import java.io.ByteArrayOutputStream;
  40 import java.io.Closeable;
  41 import java.io.File;
  42 import java.io.IOException;
  43 import java.lang.annotation.Annotation;
  44 import java.lang.reflect.Constructor;
  45 import java.lang.reflect.Method;
  46 import java.lang.reflect.Modifier;
  47 import java.net.URI;
  48 import java.net.URL;
  49 import java.net.URLClassLoader;
  50 import java.nio.file.FileSystem;
  51 import java.nio.file.FileSystems;
  52 import java.nio.file.FileVisitResult;
  53 import java.nio.file.Files;
  54 import java.nio.file.Path;
  55 import java.nio.file.SimpleFileVisitor;
  56 import java.nio.file.attribute.BasicFileAttributes;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collections;
  60 import java.util.Enumeration;
  61 import java.util.HashMap;
  62 import java.util.HashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.ServiceLoader;
  66 import java.util.Set;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Future;
  69 import java.util.concurrent.LinkedBlockingQueue;
  70 import java.util.concurrent.ThreadPoolExecutor;
  71 import java.util.concurrent.TimeUnit;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.jar.JarEntry;
  74 import java.util.jar.JarFile;
  75 import java.util.regex.Matcher;
  76 import java.util.regex.Pattern;
  77 
  78 import jdk.internal.vm.compiler.collections.EconomicMap;
  79 import jdk.internal.vm.compiler.collections.UnmodifiableMapCursor;
  80 import org.graalvm.compiler.api.replacements.Snippet;
  81 import org.graalvm.compiler.bytecode.Bytecodes;
  82 import org.graalvm.compiler.core.CompilerThreadFactory;
  83 import org.graalvm.compiler.core.phases.HighTier;
  84 import org.graalvm.compiler.core.test.ReflectionOptionDescriptors;
  85 import org.graalvm.compiler.debug.GlobalMetrics;
  86 import org.graalvm.compiler.debug.GraalError;
  87 import org.graalvm.compiler.debug.MethodFilter;
  88 import org.graalvm.compiler.debug.MetricKey;
  89 import org.graalvm.compiler.debug.TTY;
  90 import org.graalvm.compiler.hotspot.CompilationTask;
  91 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
  92 import org.graalvm.compiler.hotspot.HotSpotGraalCompiler;
  93 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime;
  94 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
  95 import org.graalvm.compiler.hotspot.test.CompileTheWorld.LibGraalParams.StackTraceBuffer;
  96 import org.graalvm.compiler.options.OptionDescriptors;
  97 import org.graalvm.compiler.options.OptionKey;
  98 import org.graalvm.compiler.options.OptionValues;
  99 import org.graalvm.compiler.options.OptionsParser;
 100 import org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;
 101 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
 102 import org.graalvm.compiler.api.test.ModuleSupport;
 103 import jdk.internal.vm.compiler.libgraal.LibGraal;
 104 import jdk.internal.vm.compiler.libgraal.LibGraalScope;
 105 import org.graalvm.util.OptionsEncoder;
 106 
 107 import jdk.vm.ci.hotspot.HotSpotCodeCacheProvider;
 108 import jdk.vm.ci.hotspot.HotSpotCompilationRequest;
 109 import jdk.vm.ci.hotspot.HotSpotInstalledCode;
 110 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 111 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 112 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 113 import jdk.vm.ci.meta.ConstantPool;
 114 import jdk.vm.ci.meta.MetaAccessProvider;
 115 import jdk.vm.ci.runtime.JVMCI;
 116 import jdk.vm.ci.runtime.JVMCICompiler;
 117 import sun.misc.Unsafe;
 118 
 119 /**
 120  * This class implements compile-the-world functionality with JVMCI.
 121  */
 122 public final class CompileTheWorld {
 123 
 124     static {
 125         ModuleSupport.exportAndOpenAllPackagesToUnnamed(&quot;jdk.internal.vm.compiler&quot;);
 126     }
 127 
 128     /**
 129      * Magic token to denote that JDK classes are to be compiled. For JDK 8, the classes in
 130      * {@code rt.jar} are compiled. Otherwise the classes in the Java runtime image are compiled.
 131      */
 132     public static final String SUN_BOOT_CLASS_PATH = &quot;sun.boot.class.path&quot;;
 133 
 134     /**
 135      * Magic token to denote the classes in the Java runtime image (i.e. in the {@code jrt:/} file
 136      * system).
 137      */
 138     public static final String JRT_CLASS_PATH_ENTRY = &quot;&lt;jrt&gt;&quot;;
 139 
 140     /**
 141      * @param options a space separated set of option value settings with each option setting in a
 142      *            {@code -Dgraal.&lt;name&gt;=&lt;value&gt;} format but without the leading {@code -Dgraal.}.
 143      *            Ignored if null.
 144      */
 145     public static EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; parseOptions(String options) {
 146         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();
 147         if (options != null) {
 148             EconomicMap&lt;String, String&gt; optionSettings = EconomicMap.create();
 149             for (String optionSetting : options.split(&quot;\\s+|#&quot;)) {
 150                 OptionsParser.parseOptionSettingTo(optionSetting, optionSettings);
 151             }
 152             ServiceLoader&lt;OptionDescriptors&gt; loader = ServiceLoader.load(OptionDescriptors.class, OptionDescriptors.class.getClassLoader());
 153             OptionsParser.parseOptions(optionSettings, values, loader);
 154         }
 155         if (!values.containsKey(HighTier.Options.Inline)) {
 156             values.put(HighTier.Options.Inline, false);
 157         }
 158         return values;
 159     }
 160 
 161     private final HotSpotJVMCIRuntime jvmciRuntime;
 162 
 163     private final HotSpotGraalCompiler compiler;
 164 
 165     /**
 166      * Class path denoting classes to compile.
 167      *
 168      * @see Options#Classpath
 169      */
 170     private final String inputClassPath;
 171 
 172     /**
 173      * Class index to start compilation at.
 174      *
 175      * @see Options#StartAt
 176      */
 177     private final int startAt;
 178 
 179     /**
 180      * Class index to stop compilation at.
 181      *
 182      * @see Options#StopAt
 183      */
 184     private final int stopAt;
 185 
 186     /**
 187      * Max classes to compile.
 188      *
 189      * @see Options#MaxClasses
 190      */
 191     private final int maxClasses;
 192 
 193     /** Only compile methods matching this filter if the filter is non-null. */
 194     private final MethodFilter methodFilter;
 195 
 196     /**
 197      * Exclude methods matching this filter if the filter is non-null. This is used by mx to exclude
 198      * some methods, while users are expected to use positive or negative filters in
 199      * {@link #methodFilter} instead.
 200      */
 201     private final MethodFilter excludeMethodFilter;
 202 
 203     // Counters
 204     private int classFileCounter = 0;
 205     private AtomicLong compiledMethodsCounter = new AtomicLong();
 206     private AtomicLong compileTime = new AtomicLong();
 207     private AtomicLong memoryUsed = new AtomicLong();
 208 
 209     private boolean verbose;
 210 
 211     /**
 212      * Signal that the threads should start compiling in multithreaded mode.
 213      */
 214     private boolean running;
 215 
 216     private ThreadPoolExecutor threadPool;
 217 
 218     /**
 219      * Values for {@link CompileTheWorld.Options}.
 220      */
 221     private final OptionValues harnessOptions;
 222 
 223     /**
 224      * Option values used during compilation.
 225      */
 226     private final OptionValues compilerOptions;
 227 
 228     /**
 229      * Manages native memory buffers for passing arguments into libgraal and receiving return
 230      * values. The native memory buffers are freed when this object is {@linkplain #close() closed}.
 231      */
 232     static class LibGraalParams implements AutoCloseable {
 233 
 234         static {
 235             LibGraal.registerNativeMethods(HotSpotJVMCIRuntime.runtime(), CompileTheWorld.class);
 236         }
 237 
 238         /**
 239          * Native memory containing {@linkplain OptionsEncoder encoded} {@link OptionValues}.
 240          */
 241         static class OptionsBuffer {
 242             private long address;
 243             final int size;
 244             final int hash;
 245 
 246             OptionsBuffer(OptionValues options) {
 247                 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
 248                 UnmodifiableMapCursor&lt;OptionKey&lt;?&gt;, Object&gt; cursor = options.getMap().getEntries();
 249                 while (cursor.advance()) {
 250                     final OptionKey&lt;?&gt; key = cursor.getKey();
 251                     Object value = cursor.getValue();
 252                     map.put(key.getName(), value);
 253                 }
 254 
 255                 byte[] encoded = OptionsEncoder.encode(map);
 256                 size = encoded.length;
 257                 hash = Arrays.hashCode(encoded);
 258                 address = UNSAFE.allocateMemory(encoded.length);
 259                 UNSAFE.copyMemory(encoded, ARRAY_BYTE_BASE_OFFSET, null, address, size);
 260             }
 261 
 262             long getAddress() {
 263                 if (address == 0) {
 264                     throw new IllegalStateException();
 265                 }
 266                 return address;
 267             }
 268 
 269             void free() {
 270                 if (address != 0) {
 271                     UNSAFE.freeMemory(address);
 272                     address = 0;
 273                 }
 274             }
 275         }
 276 
 277         /**
 278          * Manages native memory for receiving a {@linkplain Throwable#printStackTrace() stack
 279          * trace} from libgraal serialized via {@link ByteArrayOutputStream} to a byte array.
 280          */
 281         static class StackTraceBuffer {
 282             final int size;
 283             private long address;
 284 
 285             StackTraceBuffer(int size) {
 286                 this.size = size;
 287                 address = UNSAFE.allocateMemory(size);
 288             }
 289 
 290             void free() {
 291                 if (address != 0L) {
 292                     UNSAFE.freeMemory(address);
 293                     address = 0L;
 294                 }
 295             }
 296 
 297             long getAddress() {
 298                 if (address == 0) {
 299                     throw new IllegalStateException();
 300                 }
 301                 return address;
 302             }
 303         }
 304 
 305         final OptionsBuffer options;
 306 
 307         private final List&lt;StackTraceBuffer&gt; stackTraceBuffers = new ArrayList&lt;&gt;();
 308 
 309         /**
 310          * Gets a stack trace buffer for the current thread.
 311          */
 312         StackTraceBuffer getStackTraceBuffer() {
 313             return stackTraceBuffer.get();
 314         }
 315 
 316         private final ThreadLocal&lt;StackTraceBuffer&gt; stackTraceBuffer = new ThreadLocal&lt;StackTraceBuffer&gt;() {
 317             @Override
 318             protected StackTraceBuffer initialValue() {
 319                 StackTraceBuffer buffer = new StackTraceBuffer(10_000);
 320                 synchronized (stackTraceBuffers) {
 321                     stackTraceBuffers.add(buffer);
 322                 }
 323                 return buffer;
 324             }
 325         };
 326 
 327         LibGraalParams(OptionValues options) {
 328             this.options = new OptionsBuffer(options);
 329         }
 330 
 331         @Override
 332         public void close() {
 333             options.free();
 334             synchronized (stackTraceBuffers) {
 335                 for (StackTraceBuffer buffer : stackTraceBuffers) {
 336                     buffer.free();
 337                 }
 338                 stackTraceBuffers.clear();
 339             }
 340         }
 341     }
 342 
 343     /**
 344      * Creates a compile-the-world instance.
 345      *
 346      * @param files {@link File#pathSeparator} separated list of Zip/Jar files to compile
 347      * @param startAt index of the class file to start compilation at
 348      * @param stopAt index of the class file to stop compilation at
 349      * @param maxClasses maximum number of classes to process
 350      * @param methodFilters filters describing the methods to compile
 351      * @param excludeMethodFilters filters describing the methods not to compile
 352      * @param harnessOptions values for {@link CompileTheWorld.Options}
 353      * @param compilerOptions option values used by the compiler
 354      */
 355     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 356                     HotSpotGraalCompiler compiler,
 357                     String files,
 358                     int startAt,
 359                     int stopAt,
 360                     int maxClasses,
 361                     String methodFilters,
 362                     String excludeMethodFilters,
 363                     boolean verbose,
 364                     OptionValues harnessOptions,
 365                     OptionValues compilerOptions) {
 366         this.jvmciRuntime = jvmciRuntime;
 367         this.compiler = compiler;
 368         this.inputClassPath = files;
 369         this.startAt = Math.max(startAt, 1);
 370         this.stopAt = Math.max(stopAt, 1);
 371         this.maxClasses = Math.max(maxClasses, 1);
 372         this.methodFilter = methodFilters == null ? null : MethodFilter.parse(methodFilters);
 373         this.excludeMethodFilter = excludeMethodFilters == null ? null : MethodFilter.parse(excludeMethodFilters);
 374         this.verbose = verbose;
 375         this.harnessOptions = harnessOptions;
 376 
 377         // Copy the initial options and add in any extra options
 378         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; compilerOptionsMap = EconomicMap.create(compilerOptions.getMap());
 379 
 380         // We want to see stack traces when a method fails to compile
 381         CompilationBailoutAsFailure.putIfAbsent(compilerOptionsMap, true);
 382         CompilationFailureAction.putIfAbsent(compilerOptionsMap, Print);
 383 
 384         this.compilerOptions = new OptionValues(compilerOptionsMap);
 385     }
 386 
 387     public CompileTheWorld(HotSpotJVMCIRuntime jvmciRuntime,
 388                     HotSpotGraalCompiler compiler,
 389                     OptionValues harnessOptions,
 390                     OptionValues compilerOptions) {
 391         this(jvmciRuntime, compiler, Options.Classpath.getValue(harnessOptions),
 392                         Options.StartAt.getValue(harnessOptions),
 393                         Options.StopAt.getValue(harnessOptions),
 394                         Options.MaxClasses.getValue(harnessOptions),
 395                         Options.MethodFilter.getValue(harnessOptions),
 396                         Options.ExcludeMethodFilter.getValue(harnessOptions),
 397                         Options.Verbose.hasBeenSet(harnessOptions) ? Options.Verbose.getValue(harnessOptions) : !Options.MultiThreaded.getValue(harnessOptions),
 398                         harnessOptions,
 399                         new OptionValues(compilerOptions, parseOptions(Options.Config.getValue(harnessOptions))));
 400     }
 401 
 402     /**
 403      * Compiles all methods in all classes in {@link #inputClassPath}. If {@link #inputClassPath}
 404      * equals {@link #SUN_BOOT_CLASS_PATH} the boot classes are used.
 405      */
 406     @SuppressWarnings(&quot;try&quot;)
 407     public void compile() throws Throwable {
 408         try (LibGraalParams libgraal = LibGraal.isAvailable() ? new LibGraalParams(compilerOptions) : null) {
 409             if (SUN_BOOT_CLASS_PATH.equals(inputClassPath)) {
 410                 String bcpEntry = null;
 411                 if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
 412                     final String[] entries = System.getProperty(SUN_BOOT_CLASS_PATH).split(File.pathSeparator);
 413                     for (int i = 0; i &lt; entries.length &amp;&amp; bcpEntry == null; i++) {
 414                         String entry = entries[i];
 415                         File entryFile = new File(entry);
 416                         if (entryFile.getName().endsWith(&quot;rt.jar&quot;) &amp;&amp; entryFile.isFile()) {
 417                             bcpEntry = entry;
 418                         }
 419                     }
 420                     if (bcpEntry == null) {
 421                         throw new GraalError(&quot;Could not find rt.jar on boot class path %s&quot;, System.getProperty(SUN_BOOT_CLASS_PATH));
 422                     }
 423                 } else {
 424                     bcpEntry = JRT_CLASS_PATH_ENTRY;
 425                 }
 426                 compile(bcpEntry, libgraal);
 427             } else {
 428                 compile(inputClassPath, libgraal);
 429             }
 430         }
 431     }
 432 
 433     public void println() {
 434         println(&quot;&quot;);
 435     }
 436 
 437     public void println(String format, Object... args) {
 438         println(String.format(format, args));
 439     }
 440 
 441     public void println(String s) {
 442         println(verbose, s);
 443     }
 444 
 445     public static void println(boolean cond, String s) {
 446         if (cond) {
 447             TTY.println(s);
 448         }
 449     }
 450 
 451     public void printStackTrace(Throwable t) {
 452         if (verbose) {
 453             t.printStackTrace(TTY.out);
 454         }
 455     }
 456 
 457     @SuppressWarnings(&quot;unused&quot;)
 458     private static void dummy() {
 459     }
 460 
 461     /**
 462      * Abstraction over different types of class path entries.
 463      */
 464     abstract static class ClassPathEntry implements Closeable {
 465         final String name;
 466 
 467         ClassPathEntry(String name) {
 468             this.name = name;
 469         }
 470 
 471         /**
 472          * Creates a {@link ClassLoader} for loading classes from this entry.
 473          */
 474         public abstract ClassLoader createClassLoader() throws IOException;
 475 
 476         /**
 477          * Gets the list of classes available under this entry.
 478          */
 479         public abstract List&lt;String&gt; getClassNames() throws IOException;
 480 
 481         @Override
 482         public String toString() {
 483             return name;
 484         }
 485 
 486         @Override
 487         public void close() throws IOException {
 488         }
 489     }
 490 
 491     /**
 492      * A class path entry that is a normal file system directory.
 493      */
 494     static class DirClassPathEntry extends ClassPathEntry {
 495 
 496         private final File dir;
 497 
 498         DirClassPathEntry(String name) {
 499             super(name);
 500             dir = new File(name);
 501             assert dir.isDirectory();
 502         }
 503 
 504         @Override
 505         public ClassLoader createClassLoader() throws IOException {
 506             URL url = dir.toURI().toURL();
 507             return new URLClassLoader(new URL[]{url});
 508         }
 509 
 510         @Override
 511         public List&lt;String&gt; getClassNames() throws IOException {
 512             List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
 513             String root = dir.getPath();
 514             SimpleFileVisitor&lt;Path&gt; visitor = new SimpleFileVisitor&lt;Path&gt;() {
 515                 @Override
 516                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
 517                     if (attrs.isRegularFile()) {
 518                         File path = file.toFile();
 519                         if (path.getName().endsWith(&quot;.class&quot;)) {
 520                             String pathString = path.getPath();
 521                             assert pathString.startsWith(root);
 522                             String classFile = pathString.substring(root.length() + 1);
 523                             String className = classFile.replace(File.separatorChar, &#39;.&#39;);
 524                             classNames.add(className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length()));
 525                         }
 526                     }
 527                     return super.visitFile(file, attrs);
 528                 }
 529             };
 530             Files.walkFileTree(dir.toPath(), visitor);
 531             return classNames;
 532         }
 533     }
 534 
 535     /**
 536      * A class path entry that is a jar or zip file.
 537      */
 538     static class JarClassPathEntry extends ClassPathEntry {
 539 
 540         private final JarFile jarFile;
 541 
 542         JarClassPathEntry(String name) throws IOException {
 543             super(name);
 544             jarFile = new JarFile(name);
 545         }
 546 
 547         @Override
 548         public ClassLoader createClassLoader() throws IOException {
 549             URL url = new URL(&quot;jar&quot;, &quot;&quot;, &quot;file:&quot; + name + &quot;!/&quot;);
 550             return new URLClassLoader(new URL[]{url});
 551         }
 552 
 553         /**
 554          * @see &quot;https://docs.oracle.com/javase/9/docs/specs/jar/jar.html#Multi-release&quot;
 555          */
 556         static Pattern MultiReleaseJarVersionedClassRE = Pattern.compile(&quot;META-INF/versions/[1-9][0-9]*/(.+)&quot;);
 557 
 558         @Override
 559         public List&lt;String&gt; getClassNames() throws IOException {
 560             Enumeration&lt;JarEntry&gt; e = jarFile.entries();
 561             List&lt;String&gt; classNames = new ArrayList&lt;&gt;(jarFile.size());
 562             while (e.hasMoreElements()) {
 563                 JarEntry je = e.nextElement();
 564                 if (je.isDirectory() || !je.getName().endsWith(&quot;.class&quot;)) {
 565                     continue;
 566                 }
 567                 String className = je.getName().substring(0, je.getName().length() - &quot;.class&quot;.length());
 568                 if (className.equals(&quot;module-info&quot;)) {
 569                     continue;
 570                 }
 571                 if (className.startsWith(&quot;META-INF/versions/&quot;)) {
 572                     Matcher m = MultiReleaseJarVersionedClassRE.matcher(className);
 573                     if (m.matches()) {
 574                         className = m.group(1);
 575                     } else {
 576                         continue;
 577                     }
 578                 }
 579                 classNames.add(className.replace(&#39;/&#39;, &#39;.&#39;));
 580             }
 581             return classNames;
 582         }
 583 
 584         @Override
 585         public void close() throws IOException {
 586             jarFile.close();
 587         }
 588     }
 589 
 590     /**
 591      * A class path entry representing the {@code jrt:/} file system.
 592      */
 593     static class JRTClassPathEntry extends ClassPathEntry {
 594 
 595         private final String limitModules;
 596 
 597         JRTClassPathEntry(String name, String limitModules) {
 598             super(name);
 599             this.limitModules = limitModules;
 600         }
 601 
 602         @Override
 603         public ClassLoader createClassLoader() throws IOException {
 604             URL url = URI.create(&quot;jrt:/&quot;).toURL();
 605             return new URLClassLoader(new URL[]{url});
 606         }
 607 
 608         @Override
 609         public List&lt;String&gt; getClassNames() throws IOException {
 610             Set&lt;String&gt; negative = new HashSet&lt;&gt;();
 611             Set&lt;String&gt; positive = new HashSet&lt;&gt;();
 612             if (limitModules != null &amp;&amp; !limitModules.isEmpty()) {
 613                 for (String s : limitModules.split(&quot;,&quot;)) {
 614                     if (s.startsWith(&quot;~&quot;)) {
 615                         negative.add(s.substring(1));
 616                     } else {
 617                         positive.add(s);
 618                     }
 619                 }
 620             }
 621             List&lt;String&gt; classNames = new ArrayList&lt;&gt;();
 622             FileSystem fs = FileSystems.newFileSystem(URI.create(&quot;jrt:/&quot;), Collections.emptyMap());
 623             Path top = fs.getPath(&quot;/modules/&quot;);
 624             Files.find(top, Integer.MAX_VALUE,
 625                             (path, attrs) -&gt; attrs.isRegularFile()).forEach(p -&gt; {
 626                                 int nameCount = p.getNameCount();
 627                                 if (nameCount &gt; 2) {
 628                                     String base = p.getName(nameCount - 1).toString();
 629                                     if (base.endsWith(&quot;.class&quot;) &amp;&amp; !base.equals(&quot;module-info.class&quot;)) {
 630                                         String module = p.getName(1).toString();
 631                                         if (positive.isEmpty() || positive.contains(module)) {
 632                                             if (negative.isEmpty() || !negative.contains(module)) {
 633                                                 // Strip module prefix and convert to dotted form
 634                                                 String className = p.subpath(2, nameCount).toString().replace(&#39;/&#39;, &#39;.&#39;);
 635                                                 // Strip &quot;.class&quot; suffix
 636                                                 className = className.replace(&#39;/&#39;, &#39;.&#39;).substring(0, className.length() - &quot;.class&quot;.length());
 637                                                 classNames.add(className);
 638                                             }
 639                                         }
 640                                     }
 641                                 }
 642                             });
 643             return classNames;
 644         }
 645     }
 646 
 647     private boolean isClassIncluded(String className) {
 648         if (methodFilter != null &amp;&amp; !methodFilter.matchesClassName(className)) {
 649             return false;
 650         }
 651         if (excludeMethodFilter != null &amp;&amp; excludeMethodFilter.matchesClassName(className)) {
 652             return false;
 653         }
 654         return true;
 655     }
 656 
 657     private ClassPathEntry openClassPathEntry(String entry) throws IOException {
 658         if (entry.endsWith(&quot;.zip&quot;) || entry.endsWith(&quot;.jar&quot;)) {
 659             return new JarClassPathEntry(entry);
 660         } else if (entry.equals(JRT_CLASS_PATH_ENTRY)) {
 661             return new JRTClassPathEntry(entry, Options.LimitModules.getValue(harnessOptions));
 662         } else {
 663             if (!new File(entry).isDirectory()) {
 664                 return null;
 665             }
 666             return new DirClassPathEntry(entry);
 667         }
 668     }
 669 
 670     /**
 671      * Compiles all methods in all classes in a given class path.
 672      *
 673      * @param classPath class path denoting classes to compile
 674      * @throws IOException
 675      */
 676     @SuppressWarnings(&quot;try&quot;)
 677     private void compile(String classPath, LibGraalParams libgraal) throws IOException {
 678         final String[] entries = classPath.split(File.pathSeparator);
 679         long start = System.nanoTime();
 680         Map&lt;Thread, StackTraceElement[]&gt; initialThreads = Thread.getAllStackTraces();
 681 
 682         if (libgraal == null) {
 683             try {
 684                 // compile dummy method to get compiler initialized outside of the
 685                 // config debug override.
 686                 HotSpotResolvedJavaMethod dummyMethod = (HotSpotResolvedJavaMethod) JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess().lookupJavaMethod(
 687                                 CompileTheWorld.class.getDeclaredMethod(&quot;dummy&quot;));
 688                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
 689                 boolean useProfilingInfo = false;
 690                 boolean installAsDefault = false;
 691                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, new HotSpotCompilationRequest(dummyMethod, entryBCI, 0L), useProfilingInfo, installAsDefault);
 692                 task.runCompilation(compilerOptions);
 693             } catch (NoSuchMethodException | SecurityException e1) {
 694                 printStackTrace(e1);
 695             }
 696         }
 697 
 698         /*
 699          * Always use a thread pool, even for single threaded mode since it simplifies the use of
 700          * DebugValueThreadFilter to filter on the thread names.
 701          */
 702         int threadCount = 1;
 703         if (Options.MultiThreaded.getValue(harnessOptions)) {
 704             threadCount = Options.Threads.getValue(harnessOptions);
 705             if (threadCount == 0) {
 706                 threadCount = Runtime.getRuntime().availableProcessors();
 707             }
 708         } else {
 709             running = true;
 710         }
 711 
 712         threadPool = new ThreadPoolExecutor(threadCount, threadCount, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), new CompilerThreadFactory(&quot;CompileTheWorld&quot;));
 713 
 714         int compileStartAt = startAt;
 715         int compileStopAt = stopAt;
 716         int compileStep = 1;
 717         if (maxClasses != Integer.MAX_VALUE) {
 718             int totalClassFileCount = 0;
 719             for (String entry : entries) {
 720                 try (ClassPathEntry cpe = openClassPathEntry(entry)) {
 721                     if (cpe != null) {
 722                         totalClassFileCount += cpe.getClassNames().size();
 723                     }
 724                 }
 725             }
 726 
 727             int lastClassFile = totalClassFileCount - 1;
 728             compileStartAt = Math.min(startAt, lastClassFile);
 729             compileStopAt = Math.min(stopAt, lastClassFile);
 730             int range = compileStopAt - compileStartAt + 1;
 731             if (maxClasses &lt; range) {
 732                 compileStep = range / maxClasses;
 733             }
 734         }
 735 
 736         for (int i = 0; i &lt; entries.length; i++) {
 737             final String entry = entries[i];
 738             try (ClassPathEntry cpe = openClassPathEntry(entry)) {
 739                 if (cpe == null) {
 740                     println(&quot;CompileTheWorld : Skipped classes in &quot; + entry);
 741                     println();
 742                     continue;
 743                 }
 744 
 745                 if (methodFilter == null || methodFilter.matchesNothing()) {
 746                     println(&quot;CompileTheWorld : Compiling all classes in &quot; + entry);
 747                 } else {
 748                     String include = methodFilter.toString();
 749                     println(&quot;CompileTheWorld : Compiling all methods in &quot; + entry + &quot; matching one of the following filters: &quot; + include);
 750                 }
 751                 if (excludeMethodFilter != null &amp;&amp; !excludeMethodFilter.matchesNothing()) {
 752                     String exclude = excludeMethodFilter.toString();
 753                     println(&quot;CompileTheWorld : Excluding all methods matching one of the following filters: &quot; + exclude);
 754                 }
 755                 println();
 756 
 757                 ClassLoader loader = cpe.createClassLoader();
 758 
 759                 for (String className : cpe.getClassNames()) {
 760 
 761                     // Are we done?
 762                     if (classFileCounter &gt;= compileStopAt) {
 763                         break;
 764                     }
 765 
 766                     classFileCounter++;
 767 
 768                     if (compileStep &gt; 1 &amp;&amp; ((classFileCounter - compileStartAt) % compileStep) != 0) {
 769                         continue;
 770                     }
 771 
 772                     if (className.startsWith(&quot;jdk.management.&quot;) ||
 773                                     className.startsWith(&quot;jdk.internal.cmm.*&quot;) ||
 774                                     // GR-5881: The class initializer for
 775                                     // sun.tools.jconsole.OutputViewer
 776                                     // spawns non-daemon threads for redirecting sysout and syserr.
 777                                     // These threads tend to cause deadlock at VM exit
 778                                     className.startsWith(&quot;sun.tools.jconsole.&quot;)) {
 779                         continue;
 780                     }
 781 
 782                     if (!isClassIncluded(className)) {
 783                         continue;
 784                     }
 785 
 786                     try {
 787                         // Load and initialize class
 788                         Class&lt;?&gt; javaClass = Class.forName(className, true, loader);
 789                         MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();
 790 
 791                         // Pre-load all classes in the constant pool.
 792                         try {
 793                             HotSpotResolvedObjectType objectType = (HotSpotResolvedObjectType) metaAccess.lookupJavaType(javaClass);
 794                             ConstantPool constantPool = objectType.getConstantPool();
 795                             for (int cpi = 1; cpi &lt; constantPool.length(); cpi++) {
 796                                 constantPool.loadReferencedType(cpi, Bytecodes.LDC);
 797                             }
 798                         } catch (Throwable t) {
 799                             // If something went wrong during pre-loading we just ignore it.
 800                             if (isClassIncluded(className)) {
 801                                 println(&quot;Preloading failed for (%d) %s: %s&quot;, classFileCounter, className, t);
 802                             }
 803                             continue;
 804                         }
 805 
 806                         // Are we compiling this class?
 807                         if (classFileCounter &gt;= compileStartAt) {
 808 
 809                             long start0 = System.nanoTime();
 810                             // Compile each constructor/method in the class.
 811                             for (Constructor&lt;?&gt; constructor : javaClass.getDeclaredConstructors()) {
 812                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(constructor);
 813                                 if (canBeCompiled(javaMethod, constructor.getModifiers())) {
 814                                     compileMethod(javaMethod, libgraal);
 815                                 }
 816                             }
 817                             for (Method method : javaClass.getDeclaredMethods()) {
 818                                 HotSpotResolvedJavaMethod javaMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);
 819                                 if (canBeCompiled(javaMethod, method.getModifiers())) {
 820                                     compileMethod(javaMethod, libgraal);
 821                                 }
 822                             }
 823 
 824                             // Also compile the class initializer if it exists
 825                             HotSpotResolvedJavaMethod clinit = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaType(javaClass).getClassInitializer();
 826                             if (clinit != null &amp;&amp; canBeCompiled(clinit, clinit.getModifiers())) {
 827                                 compileMethod(clinit, libgraal);
 828                             }
 829                             println(&quot;CompileTheWorld (%d) : %s (%d us)&quot;, classFileCounter, className, (System.nanoTime() - start0) / 1000);
 830                         }
 831                     } catch (Throwable t) {
 832                         if (isClassIncluded(className)) {
 833                             println(&quot;CompileTheWorld (%d) : Skipping %s %s&quot;, classFileCounter, className, t.toString());
 834                             printStackTrace(t);
 835                         }
 836                     }
 837                 }
 838             }
 839         }
 840 
 841         if (!running) {
 842             startThreads();
 843         }
 844         int wakeups = 0;
 845         long lastCompletedTaskCount = 0;
 846         for (long completedTaskCount = threadPool.getCompletedTaskCount(); completedTaskCount != threadPool.getTaskCount(); completedTaskCount = threadPool.getCompletedTaskCount()) {
 847             if (wakeups % 15 == 0) {
 848                 TTY.printf(&quot;CompileTheWorld : Waiting for %d compiles, just completed %d compiles%n&quot;, threadPool.getTaskCount() - completedTaskCount, completedTaskCount - lastCompletedTaskCount);
 849                 lastCompletedTaskCount = completedTaskCount;
 850             }
 851             try {
 852                 threadPool.awaitTermination(1, TimeUnit.SECONDS);
 853                 wakeups++;
 854             } catch (InterruptedException e) {
 855             }
 856         }
 857         threadPool.shutdown();
 858         threadPool = null;
 859 
 860         long elapsedTime = System.nanoTime() - start;
 861 
 862         println();
 863         int compiledClasses = classFileCounter &gt; compileStartAt ? classFileCounter - compileStartAt : 0;
 864         if (Options.MultiThreaded.getValue(harnessOptions)) {
 865             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms elapsed, %d ms compile time, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), elapsedTime,
 866                             compileTime.get() / 1000000, memoryUsed.get());
 867         } else {
 868             TTY.println(&quot;CompileTheWorld : Done (%d classes, %d methods, %d ms, %d bytes of memory used)&quot;, compiledClasses, compiledMethodsCounter.get(), compileTime.get(), memoryUsed.get());
 869         }
 870 
 871         GlobalMetrics metricValues = ((HotSpotGraalRuntime) compiler.getGraalRuntime()).getMetricValues();
 872         EconomicMap&lt;MetricKey, Long&gt; map = metricValues.asKeyValueMap();
 873         Long compiledAndInstalledBytecodes = map.get(CompiledAndInstalledBytecodes);
 874         Long compilationTime = map.get(CompilationTime);
 875         if (compiledAndInstalledBytecodes != null &amp;&amp; compilationTime != null) {
 876             TTY.println(&quot;CompileTheWorld : Aggregate compile speed %d bytecodes per second (%d / %d)&quot;, (int) (compiledAndInstalledBytecodes / (compilationTime / 1000000000.0)),
 877                             compiledAndInstalledBytecodes, compilationTime);
 878         }
 879 
 880         metricValues.print(compilerOptions);
 881         metricValues.clear();
 882 
 883         // Apart from the main thread, there should be only be daemon threads
 884         // alive now. If not, then a class initializer has probably started
 885         // a thread that could cause a deadlock while trying to exit the VM.
 886         // One known example of this is sun.tools.jconsole.OutputViewer which
 887         // spawns threads to redirect sysout and syserr. To help debug such
 888         // scenarios, the stacks of potentially problematic threads are dumped.
 889         Map&lt;Thread, StackTraceElement[]&gt; suspiciousThreads = new HashMap&lt;&gt;();
 890         for (Map.Entry&lt;Thread, StackTraceElement[]&gt; e : Thread.getAllStackTraces().entrySet()) {
 891             Thread thread = e.getKey();
 892             if (thread != Thread.currentThread() &amp;&amp; !initialThreads.containsKey(thread) &amp;&amp; !thread.isDaemon() &amp;&amp; thread.isAlive()) {
 893                 suspiciousThreads.put(thread, e.getValue());
 894             }
 895         }
 896         if (!suspiciousThreads.isEmpty()) {
 897             TTY.println(&quot;--- Non-daemon threads started during CTW ---&quot;);
 898             for (Map.Entry&lt;Thread, StackTraceElement[]&gt; e : suspiciousThreads.entrySet()) {
 899                 Thread thread = e.getKey();
 900                 if (thread.isAlive()) {
 901                     TTY.println(thread.toString() + &quot; &quot; + thread.getState());
 902                     for (StackTraceElement ste : e.getValue()) {
 903                         TTY.println(&quot;\tat &quot; + ste);
 904                     }
 905                 }
 906             }
 907             TTY.println(&quot;---------------------------------------------&quot;);
 908         }
 909     }
 910 
 911     private synchronized void startThreads() {
 912         running = true;
 913         // Wake up any waiting threads
 914         notifyAll();
 915     }
 916 
 917     private synchronized void waitToRun() {
 918         while (!running) {
 919             try {
 920                 wait();
 921             } catch (InterruptedException e) {
 922             }
 923         }
 924     }
 925 
 926     @SuppressWarnings(&quot;try&quot;)
 927     private void compileMethod(HotSpotResolvedJavaMethod method, LibGraalParams libgraal) throws InterruptedException, ExecutionException {
 928         if (methodFilter != null &amp;&amp; !methodFilter.matches(method)) {
 929             return;
 930         }
 931         if (excludeMethodFilter != null &amp;&amp; excludeMethodFilter.matches(method)) {
 932             return;
 933         }
 934         Future&lt;?&gt; task = threadPool.submit(new Runnable() {
 935             @Override
 936             public void run() {
 937                 waitToRun();
 938                 compileMethod(method, classFileCounter, libgraal);
 939             }
 940         });
 941         if (threadPool.getCorePoolSize() == 1) {
 942             task.get();
 943         }
 944     }
 945 
 946     private static final Unsafe UNSAFE = GraalUnsafeAccess.getUnsafe();
 947 
 948     /**
 949      * Implemented by
 950      * {@code com.oracle.svm.graal.hotspot.libgraal.LibGraalEntryPoints.compileMethod}.
 951      */
 952     static native long compileMethodInLibgraal(long isolateThread,
 953                     long methodHandle,
 954                     boolean useProfilingInfo,
 955                     boolean installAsDefault,
 956                     long optionsAddress,
 957                     int optionsSize,
 958                     int optionsHash,
 959                     long encodedThrowableBufferAddress,
 960                     int encodedThrowableBufferSize);
 961 
 962     /**
 963      * Compiles a method and gathers some statistics.
 964      */
 965     @SuppressWarnings(&quot;try&quot;)
 966     private void compileMethod(HotSpotResolvedJavaMethod method, int counter, LibGraalParams libgraal) {
 967         try {
 968             long start = System.nanoTime();
 969             long allocatedAtStart = getCurrentThreadAllocatedBytes();
 970             // For more stable CTW execution, disable use of profiling information
 971             boolean useProfilingInfo = false;
 972             boolean installAsDefault = false;
 973             HotSpotInstalledCode installedCode;
 974             if (libgraal != null) {
 975                 HotSpotJVMCIRuntime runtime = HotSpotJVMCIRuntime.runtime();
 976                 try (LibGraalScope scope = new LibGraalScope(runtime)) {
 977                     long methodHandle = LibGraal.translate(runtime, method);
 978                     long isolateThread = LibGraalScope.getIsolateThread();
 979 
 980                     StackTraceBuffer stackTraceBuffer = libgraal.getStackTraceBuffer();
 981 
 982                     long stackTraceBufferAddress = stackTraceBuffer.getAddress();
 983                     long installedCodeHandle = compileMethodInLibgraal(isolateThread,
 984                                     methodHandle,
 985                                     useProfilingInfo,
 986                                     installAsDefault,
 987                                     libgraal.options.getAddress(),
 988                                     libgraal.options.size,
 989                                     libgraal.options.hash,
 990                                     stackTraceBufferAddress,
 991                                     stackTraceBuffer.size);
 992 
 993                     installedCode = LibGraal.unhand(runtime, HotSpotInstalledCode.class, installedCodeHandle);
 994                     if (installedCode == null) {
 995                         int length = UNSAFE.getInt(stackTraceBufferAddress);
 996                         byte[] data = new byte[length];
 997                         UNSAFE.copyMemory(null, stackTraceBufferAddress + Integer.BYTES, data, ARRAY_BYTE_BASE_OFFSET, length);
 998                         String stackTrace = new String(data).trim();
 999                         println(true, String.format(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;)));
1000                         println(true, stackTrace);
1001                     }
1002                 }
1003             } else {
1004                 int entryBCI = JVMCICompiler.INVOCATION_ENTRY_BCI;
1005                 HotSpotCompilationRequest request = new HotSpotCompilationRequest(method, entryBCI, 0L);
1006                 CompilationTask task = new CompilationTask(jvmciRuntime, compiler, request, useProfilingInfo, installAsDefault);
1007                 task.runCompilation(compilerOptions);
1008                 installedCode = task.getInstalledCode();
1009             }
1010 
1011             // Invalidate the generated code so the code cache doesn&#39;t fill up
1012             if (installedCode != null &amp;&amp; InvalidateInstalledCode.getValue(compilerOptions)) {
1013                 installedCode.invalidate();
1014             }
1015 
1016             memoryUsed.getAndAdd(getCurrentThreadAllocatedBytes() - allocatedAtStart);
1017             compileTime.getAndAdd(System.nanoTime() - start);
1018             compiledMethodsCounter.incrementAndGet();
1019         } catch (Throwable t) {
1020             // Catch everything and print a message
1021             println(&quot;CompileTheWorld (%d) : Error compiling method: %s&quot;, counter, method.format(&quot;%H.%n(%p):%r&quot;));
1022             printStackTrace(t);
1023         }
1024     }
1025 
1026     /**
1027      * Determines if a method should be compiled (Cf. CompilationPolicy::can_be_compiled).
1028      *
1029      * @return true if it can be compiled, false otherwise
1030      */
1031     private boolean canBeCompiled(HotSpotResolvedJavaMethod javaMethod, int modifiers) {
1032         if (Modifier.isAbstract(modifiers) || Modifier.isNative(modifiers)) {
1033             return false;
1034         }
1035         GraalHotSpotVMConfig c = compiler.getGraalRuntime().getVMConfig();
1036         if (c.dontCompileHugeMethods &amp;&amp; javaMethod.getCodeSize() &gt; c.hugeMethodLimit) {
1037             println(verbose || methodFilter != null,
1038                             String.format(&quot;CompileTheWorld (%d) : Skipping huge method %s (use -XX:-DontCompileHugeMethods or -XX:HugeMethodLimit=%d to include it)&quot;, classFileCounter,
1039                                             javaMethod.format(&quot;%H.%n(%p):%r&quot;),
1040                                             javaMethod.getCodeSize()));
1041             return false;
1042         }
1043         // Allow use of -XX:CompileCommand=dontinline to exclude problematic methods
1044         if (!javaMethod.canBeInlined()) {
1045             return false;
1046         }
1047         // Skip @Snippets for now
1048         for (Annotation annotation : javaMethod.getAnnotations()) {
1049             if (annotation.annotationType().equals(Snippet.class)) {
1050                 return false;
1051             }
1052         }
1053         return true;
1054     }
1055 
1056     static class Options {
1057         public static final OptionKey&lt;Boolean&gt; Help = new OptionKey&lt;&gt;(false);
1058         public static final OptionKey&lt;String&gt; Classpath = new OptionKey&lt;&gt;(CompileTheWorld.SUN_BOOT_CLASS_PATH);
1059         public static final OptionKey&lt;Boolean&gt; Verbose = new OptionKey&lt;&gt;(true);
1060         /**
1061          * Ignore Graal classes by default to avoid problems associated with compiling snippets and
1062          * method substitutions.
1063          */
1064         public static final OptionKey&lt;String&gt; LimitModules = new OptionKey&lt;&gt;(&quot;~jdk.internal.vm.compiler&quot;);
1065         public static final OptionKey&lt;Integer&gt; Iterations = new OptionKey&lt;&gt;(1);
1066         public static final OptionKey&lt;String&gt; MethodFilter = new OptionKey&lt;&gt;(null);
1067         public static final OptionKey&lt;String&gt; ExcludeMethodFilter = new OptionKey&lt;&gt;(null);
1068         public static final OptionKey&lt;Integer&gt; StartAt = new OptionKey&lt;&gt;(1);
1069         public static final OptionKey&lt;Integer&gt; StopAt = new OptionKey&lt;&gt;(Integer.MAX_VALUE);
1070         public static final OptionKey&lt;Integer&gt; MaxClasses = new OptionKey&lt;&gt;(Integer.MAX_VALUE);
1071         public static final OptionKey&lt;String&gt; Config = new OptionKey&lt;&gt;(null);
1072         public static final OptionKey&lt;Boolean&gt; MultiThreaded = new OptionKey&lt;&gt;(false);
1073         public static final OptionKey&lt;Integer&gt; Threads = new OptionKey&lt;&gt;(0);
1074         public static final OptionKey&lt;Boolean&gt; InvalidateInstalledCode = new OptionKey&lt;&gt;(false);
1075 
1076         // @formatter:off
1077         static final ReflectionOptionDescriptors DESCRIPTORS = new ReflectionOptionDescriptors(Options.class,
1078                            &quot;Help&quot;, &quot;List options and their help messages and then exit.&quot;,
1079                       &quot;Classpath&quot;, &quot;Class path denoting methods to compile. Default is to compile boot classes.&quot;,
1080                         &quot;Verbose&quot;, &quot;Verbose operation. Default is !MultiThreaded.&quot;,
1081                    &quot;LimitModules&quot;, &quot;Comma separated list of module names to which compilation should be limited. &quot; +
1082                                    &quot;Module names can be prefixed with \&quot;~\&quot; to exclude the named module.&quot;,
1083                      &quot;Iterations&quot;, &quot;The number of iterations to perform.&quot;,
1084                    &quot;MethodFilter&quot;, &quot;Only compile methods matching this filter.&quot;,
1085             &quot;ExcludeMethodFilter&quot;, &quot;Exclude methods matching this filter from compilation.&quot;,
1086                         &quot;StartAt&quot;, &quot;First class to consider for compilation (default = 1).&quot;,
1087                          &quot;StopAt&quot;, &quot;Last class to consider for compilation (default = &lt;number of classes&gt;).&quot;,
1088                      &quot;MaxClasses&quot;, &quot;Maximum number of classes to process (default = &lt;number of classes&gt;). &quot; +
1089                                    &quot;Ignored if less than (StopAt - StartAt + 1).&quot;,
1090                          &quot;Config&quot;, &quot;Option values to use during compile the world compilations. For example, &quot; +
1091                                    &quot;to disable partial escape analysis and print compilations specify &quot; +
1092                                    &quot;&#39;PartialEscapeAnalysis=false PrintCompilation=true&#39;. &quot; +
1093                                    &quot;Unless explicitly enabled with &#39;Inline=true&#39; here, inlining is disabled.&quot;,
1094                   &quot;MultiThreaded&quot;, &quot;Run using multiple threads for compilation.&quot;,
1095                         &quot;Threads&quot;, &quot;Number of threads to use for multithreaded execution. Defaults to Runtime.getRuntime().availableProcessors().&quot;,
1096         &quot;InvalidateInstalledCode&quot;, &quot;Invalidate the generated code so the code cache doesn&#39;t fill up.&quot;);
1097         // @formatter:on
1098     }
1099 
1100     public static OptionValues loadHarnessOptions() {
1101         EconomicMap&lt;OptionKey&lt;?&gt;, Object&gt; values = OptionValues.newOptionMap();
1102         List&lt;OptionDescriptors&gt; loader = singletonList(DESCRIPTORS);
1103         OptionsParser.parseOptions(extractEntries(System.getProperties(), &quot;CompileTheWorld.&quot;, true), values, loader);
1104         OptionValues options = new OptionValues(values);
1105         if (Options.Help.getValue(options)) {
1106             options.printHelp(loader, System.out, &quot;CompileTheWorld.&quot;);
1107             System.exit(0);
1108         }
1109         return options;
1110     }
1111 
1112     public static void main(String[] args) throws Throwable {
1113         HotSpotJVMCIRuntime jvmciRuntime = HotSpotJVMCIRuntime.runtime();
1114         HotSpotGraalCompiler compiler = (HotSpotGraalCompiler) jvmciRuntime.getCompiler();
1115         HotSpotGraalRuntimeProvider graalRuntime = compiler.getGraalRuntime();
1116         HotSpotCodeCacheProvider codeCache = graalRuntime.getHostProviders().getCodeCache();
1117         OptionValues harnessOptions = loadHarnessOptions();
1118 
1119         int iterations = Options.Iterations.getValue(harnessOptions);
1120         for (int i = 0; i &lt; iterations; i++) {
1121             codeCache.resetCompilationStatistics();
1122             TTY.println(&quot;CompileTheWorld : iteration &quot; + i);
1123 
1124             CompileTheWorld ctw = new CompileTheWorld(jvmciRuntime, compiler, harnessOptions, graalRuntime.getOptions());
1125             ctw.compile();
1126             if (iterations &gt; 1) {
1127                 // Force a GC to encourage reclamation of nmethods when their InstalledCode
1128                 // reference has been dropped.
1129                 System.gc();
1130             }
1131         }
1132         // This is required as non-daemon threads can be started by class initializers
1133         System.exit(0);
1134     }
1135 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot.test/src/org/graalvm/compiler/hotspot/test/WriteBarrierAdditionTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.test;
 26 
 27 import static org.graalvm.compiler.core.common.GraalOptions.FullUnroll;
 28 import static org.graalvm.compiler.core.common.GraalOptions.LoopPeeling;
 29 import static org.graalvm.compiler.core.common.GraalOptions.PartialEscapeAnalysis;
 30 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.referentOffset;
 31 
 32 import java.lang.ref.Reference;
 33 import java.lang.ref.WeakReference;
 34 import java.util.EnumSet;
 35 import java.util.ListIterator;
 36 import java.util.Objects;
 37 
 38 import org.graalvm.compiler.api.test.Graal;
 39 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 40 import org.graalvm.compiler.hotspot.HotSpotBackend;
 41 import org.graalvm.compiler.hotspot.HotSpotGraalRuntime.HotSpotGC;
 42 import org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil;
 43 import org.graalvm.compiler.nodeinfo.NodeSize;
 44 import org.graalvm.compiler.nodes.StructuredGraph;
 45 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;
 46 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;
 47 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;
 48 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
 49 import org.graalvm.compiler.nodes.memory.HeapAccess;
 50 import org.graalvm.compiler.nodes.memory.ReadNode;
 51 import org.graalvm.compiler.nodes.memory.WriteNode;
 52 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 53 import org.graalvm.compiler.options.OptionValues;
 54 import org.graalvm.compiler.phases.BasePhase;
 55 import org.graalvm.compiler.phases.Phase;
 56 import org.graalvm.compiler.phases.common.WriteBarrierAdditionPhase;
 57 import org.graalvm.compiler.phases.tiers.MidTierContext;
 58 import org.graalvm.compiler.phases.tiers.Suites;
 59 import org.graalvm.compiler.runtime.RuntimeProvider;
 60 import org.junit.Assert;
 61 import org.junit.Before;
 62 import org.junit.Test;
 63 
 64 import jdk.vm.ci.meta.JavaConstant;
 65 import jdk.vm.ci.meta.MetaAccessProvider;
 66 
 67 /**
 68  * The following unit tests assert the presence of write barriers for G1 and for the other GCs that
 69  * use a simple card mark barrier, like Serial, CMS, ParallelGC and Pthe arNew/ParOld GCs. Normally,
 70  * the tests check for compile time inserted barriers. However, there are the cases of unsafe loads
 71  * of the java.lang.ref.Reference.referent field where runtime checks have to be performed also. For
 72  * those cases, the unit tests check the presence of the compile-time inserted barriers. Concerning
 73  * the runtime checks, the results of variable inputs (object types and offsets) passed as input
 74  * parameters can be checked against printed output from the G1 write barrier snippets. The runtime
 75  * checks have been validated offline.
 76  */
 77 public class WriteBarrierAdditionTest extends HotSpotGraalCompilerTest {
 78 
 79     /**
 80      * The set of GCs known at the time of writing of this test. The number of expected barrier
 81      * might need to be adjusted for new GCs implementations.
 82      */
 83     private static EnumSet&lt;HotSpotGC&gt; knownSupport = EnumSet.of(HotSpotGC.G1, HotSpotGC.CMS, HotSpotGC.Parallel, HotSpotGC.Serial);
 84 
 85     private final GraalHotSpotVMConfig config = runtime().getVMConfig();
 86 
 87     public static class Container {
 88 
 89         public Container a;
 90         public Container b;
 91 
 92         @Override
 93         public boolean equals(Object o) {
 94             if (this == o) {
 95                 return true;
 96             }
 97             if (o == null || getClass() != o.getClass()) {
 98                 return false;
 99             }
100             Container container = (Container) o;
101             return Objects.equals(a, container.a) &amp;&amp; Objects.equals(b, container.b);
102         }
103 
104         @Override
105         public int hashCode() {
106             return Objects.hash(a, b);
107         }
108     }
109 
110     private int expectedBarriers;
111 
112     /**
113      * Expected 2 barriers for the card mark GCs and 4 for G1 (2 pre + 2 post).
114      */
115     @Test
116     public void testAllocation() throws Exception {
117         this.expectedBarriers = (config.useG1GC) ? 4 : 2;
118         testWithoutPEA(&quot;testAllocationSnippet&quot;);
119     }
120 
121     public static Container testAllocationSnippet() {
122         Container main = new Container();
123         Container temp1 = new Container();
124         Container temp2 = new Container();
125         main.a = temp1;
126         main.b = temp2;
127         return main;
128     }
129 
130     /**
131      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).
132      */
133     @Test
134     public void testLoopAllocation1() throws Exception {
135         this.expectedBarriers = config.useG1GC ? 8 : 4;
136         testWithoutPEA(&quot;test2Snippet&quot;, false);
137         testWithoutPEA(&quot;test2Snippet&quot;, true);
138     }
139 
140     public static void test2Snippet(boolean test) {
141         Container main = new Container();
142         Container temp1 = new Container();
143         Container temp2 = new Container();
144         for (int i = 0; i &lt; 10; i++) {
145             if (test) {
146                 main.a = temp1;
147                 main.b = temp2;
148             } else {
149                 main.a = temp2;
150                 main.b = temp1;
151             }
152         }
153     }
154 
155     /**
156      * Expected 4 barriers for the card mark GCs and 8 for G1 (4 pre + 4 post).
157      */
158     @Test
159     public void testLoopAllocation2() throws Exception {
160         this.expectedBarriers = config.useG1GC ? 8 : 4;
161         testWithoutPEA(&quot;test3Snippet&quot;);
162     }
163 
164     public static void test3Snippet() {
165         Container[] main = new Container[10];
166         Container temp1 = new Container();
167         Container temp2 = new Container();
168         for (int i = 0; i &lt; 10; i++) {
169             main[i].a = main[i].b = temp1;
170         }
171 
172         for (int i = 0; i &lt; 10; i++) {
173             main[i].a = main[i].b = temp2;
174         }
175     }
176 
177     /**
178      * Expected 2 barriers for the card mark GCs and 5 for G1 (3 pre + 2 post) The (2 or 4) barriers
179      * are emitted while initializing the fields of the WeakReference instance. The extra pre
180      * barrier of G1 concerns the read of the referent field.
181      */
182     @Test
183     public void testReferenceGet() throws Exception {
184         this.expectedBarriers = config.useG1GC ? 1 : 0;
185         test(&quot;testReferenceGetSnippet&quot;);
186     }
187 
188     public static Object testReferenceGetSnippet() {
189         return weakReference.get();
190     }
191 
192     static class DummyReference {
193         Object referent;
194     }
195 
196     private static MetaAccessProvider getStaticMetaAccess() {
197         return ((HotSpotBackend) Graal.getRequiredCapability(RuntimeProvider.class).getHostBackend()).getRuntime().getHostProviders().getMetaAccess();
198     }
199 
200     private static final WeakReference&lt;?&gt; weakReference = new WeakReference&lt;&gt;(new Object());
201     private static final Object weakReferenceAsObject = new WeakReference&lt;&gt;(new Object());
202     private static final long referenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;referent&quot;);
203     private static final long referenceQueueFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(Reference.class), &quot;queue&quot;);
204 
205     private static final DummyReference dummyReference = new DummyReference();
206     private static final long dummyReferenceReferentFieldOffset = HotSpotReplacementsUtil.getFieldOffset(getStaticMetaAccess().lookupJavaType(DummyReference.class), &quot;referent&quot;);
207 
208     /**
209      * The type is known to be WeakReference and the offset is a constant, so the
210      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is converted back into a normal
211      * LoadFieldNode and the lowering of the field node inserts the proper barrier.
212      */
213     @Test
214     public void testReferenceReferent1() throws Exception {
215         this.expectedBarriers = config.useG1GC ? 1 : 0;
216         test(&quot;testReferenceReferentSnippet&quot;);
217     }
218 
219     public Object testReferenceReferentSnippet() {
220         return UNSAFE.getObject(weakReference, referenceReferentFieldOffset);
221     }
222 
223     /**
224      * The type is known to be WeakReference and the offset is non-constant, so the lowering of the
225      * {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the offset
226      * is the same as {@link #referenceReferentFieldOffset} which does a barrier if requires it.
227      */
228     @Test
229     public void testReferenceReferent2() throws Exception {
230         this.expectedBarriers = config.useG1GC ? 1 : 0;
231         test(&quot;testReferenceReferent2Snippet&quot;, referenceReferentFieldOffset);
232     }
233 
234     public Object testReferenceReferent2Snippet(long offset) {
235         return UNSAFE.getObject(weakReference, offset);
236     }
237 
238     /**
239      * The type is known to be WeakReference and the offset is constant but not the referent field,
240      * so no barrier is required.
241      */
242     @Test
243     public void testReferenceReferent3() throws Exception {
244         this.expectedBarriers = 0;
245         test(&quot;testReferenceReferent3Snippet&quot;);
246     }
247 
248     public Object testReferenceReferent3Snippet() {
249         return UNSAFE.getObject(weakReference, referenceQueueFieldOffset);
250     }
251 
252     /**
253      * The type is a super class of WeakReference and the offset is non-constant, so the lowering of
254      * the {@link org.graalvm.compiler.nodes.extended.RawLoadNode} is guarded by a check that the
255      * offset is the same as {@link #referenceReferentFieldOffset} and the base object is a
256      * subclasses of {@link java.lang.ref.Reference} and does a barrier if requires it.
257      */
258     @Test
259     public void testReferenceReferent4() throws Exception {
260         this.expectedBarriers = config.useG1GC ? 1 : 0;
261         test(&quot;testReferenceReferent4Snippet&quot;);
262     }
263 
264     public Object testReferenceReferent4Snippet() {
265         return UNSAFE.getObject(weakReferenceAsObject, referenceReferentFieldOffset);
266     }
267 
268     /**
269      * The type is not related to Reference at all so no barrier check is required. This should be
270      * statically detectable.
271      */
272     @Test
273     public void testReferenceReferent5() throws Exception {
274         this.expectedBarriers = 0;
275         Assert.assertEquals(&quot;expected fields to have the same offset&quot;, referenceReferentFieldOffset, dummyReferenceReferentFieldOffset);
276         test(&quot;testReferenceReferent5Snippet&quot;);
277     }
278 
279     public Object testReferenceReferent5Snippet() {
280         return UNSAFE.getObject(dummyReference, referenceReferentFieldOffset);
281     }
282 
283     static Object[] src = new Object[1];
284     static Object[] dst = new Object[1];
285 
286     static {
287         for (int i = 0; i &lt; src.length; i++) {
288             src[i] = new Object();
289         }
290         for (int i = 0; i &lt; dst.length; i++) {
291             dst[i] = new Object();
292         }
293     }
294 
295     public static void testArrayCopySnippet(Object a, Object b, Object c) throws Exception {
296         System.arraycopy(a, 0, b, 0, (int) c);
297     }
298 
299     @Test
300     public void testArrayCopy() throws Exception {
301         this.expectedBarriers = 0;
302         test(&quot;testArrayCopySnippet&quot;, src, dst, dst.length);
303     }
304 
305     private void verifyBarriers(StructuredGraph graph) {
306         Assert.assertTrue(&quot;Unknown collector selected&quot;, knownSupport.contains(runtime().getGarbageCollector()));
307         Assert.assertNotEquals(&quot;test must set expected barrier count&quot;, expectedBarriers, -1);
308         int barriers = 0;
309         if (config.useG1GC) {
310             barriers = graph.getNodes().filter(G1ReferentFieldReadBarrier.class).count() + graph.getNodes().filter(G1PreWriteBarrier.class).count() +
311                             graph.getNodes().filter(G1PostWriteBarrier.class).count();
312         } else {
313             barriers = graph.getNodes().filter(SerialWriteBarrier.class).count();
314         }
315         if (expectedBarriers != barriers) {
316             Assert.assertEquals(expectedBarriers, barriers);
317         }
318         for (WriteNode write : graph.getNodes().filter(WriteNode.class)) {
319             if (config.useG1GC) {
320                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {
321                     Assert.assertEquals(1, write.successors().count());
322                     Assert.assertTrue(write.next() instanceof G1PostWriteBarrier);
323                     Assert.assertTrue(write.predecessor() instanceof G1PreWriteBarrier || write.getLocationIdentity().isImmutable());
324                 }
325             } else {
326                 if (write.getBarrierType() != HeapAccess.BarrierType.NONE) {
327                     Assert.assertEquals(1, write.successors().count());
328                     Assert.assertTrue(write.next() instanceof SerialWriteBarrier);
329                 }
330             }
331         }
332 
333         for (ReadNode read : graph.getNodes().filter(ReadNode.class)) {
334             if (read.getBarrierType() != HeapAccess.BarrierType.NONE) {
335                 if (read.getAddress() instanceof OffsetAddressNode) {
336                     JavaConstant constDisp = ((OffsetAddressNode) read.getAddress()).getOffset().asJavaConstant();
337                     if (constDisp != null) {
338                         Assert.assertEquals(referentOffset(getMetaAccess()), constDisp.asLong());
339                     }
340                 }
341                 Assert.assertTrue(HeapAccess.BarrierType.WEAK_FIELD == read.getBarrierType() || HeapAccess.BarrierType.MAYBE_WEAK_FIELD == read.getBarrierType());
342                 if (config.useG1GC) {
343                     Assert.assertTrue(read.next() instanceof G1ReferentFieldReadBarrier);
344                 }
345             }
346         }
347     }
348 
349     protected Result testWithoutPEA(String name, Object... args) {
350         return test(new OptionValues(getInitialOptions(), PartialEscapeAnalysis, false, FullUnroll, false, LoopPeeling, false), name, args);
351     }
352 
353     @Before
354     public void before() {
355         expectedBarriers = -1;
356     }
357 
358     /*
359      * Check the state of the barriers immediately after insertion.
360      */
361     @Override
362     protected Suites createSuites(OptionValues opts) {
363         Suites ret = getBackend().getSuites().getDefaultSuites(opts).copy();
364         ListIterator&lt;BasePhase&lt;? super MidTierContext&gt;&gt; iter = ret.getMidTier().findPhase(WriteBarrierAdditionPhase.class, true);
365         iter.add(new Phase() {
366 
367             @Override
368             protected void run(StructuredGraph graph) {
369                 verifyBarriers(graph);
370             }
371 
372             @Override
373             public float codeSizeIncrease() {
374                 return NodeSize.IGNORE_SIZE_CONTRACT_FACTOR;
375             }
376 
377             @Override
378             protected CharSequence getName() {
379                 return &quot;VerifyBarriersPhase&quot;;
380             }
381         });
382         return ret;
383     }
384 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/symbol.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="symbol.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/symbol.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 104,18 ***</span>
    friend class VMStructs;
    friend class SymbolTable;
  
   private:
  
<span class="line-modified">!   // This is an int because it needs atomic operation on the refcount.  Mask length</span>
    // in high half word. length is the number of UTF8 characters in the symbol
<span class="line-modified">!   volatile uint32_t _length_and_refcount;</span>
<span class="line-modified">!   short _identity_hash;</span>
    u1 _body[2];
  
    enum {
<span class="line-removed">-     // max_symbol_length must fit into the top 16 bits of _length_and_refcount</span>
      max_symbol_length = (1 &lt;&lt; 16) -1
    };
  
    static int byte_size(int length) {
      // minimum number of natural words needed to hold these bits (no non-heap version)
<span class="line-new-header">--- 104,17 ---</span>
    friend class VMStructs;
    friend class SymbolTable;
  
   private:
  
<span class="line-modified">!   // This is an int because it needs atomic operation on the refcount.  Mask hash</span>
    // in high half word. length is the number of UTF8 characters in the symbol
<span class="line-modified">!   volatile uint32_t _hash_and_refcount;</span>
<span class="line-modified">!   u2 _length;</span>
    u1 _body[2];
  
    enum {
      max_symbol_length = (1 &lt;&lt; 16) -1
    };
  
    static int byte_size(int length) {
      // minimum number of natural words needed to hold these bits (no non-heap version)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,15 ***</span>
    void* operator new(size_t size, int len) throw();
    void* operator new(size_t size, int len, Arena* arena) throw();
  
    void  operator delete(void* p);
  
<span class="line-modified">!   static int extract_length(uint32_t value)   { return value &gt;&gt; 16; }</span>
    static int extract_refcount(uint32_t value) { return value &amp; 0xffff; }
<span class="line-modified">!   static uint32_t pack_length_and_refcount(int length, int refcount);</span>
  
<span class="line-modified">!   int length() const   { return extract_length(_length_and_refcount); }</span>
  
   public:
    // Low-level access (used with care, since not GC-safe)
    const u1* base() const { return &amp;_body[0]; }
  
<span class="line-new-header">--- 134,15 ---</span>
    void* operator new(size_t size, int len) throw();
    void* operator new(size_t size, int len, Arena* arena) throw();
  
    void  operator delete(void* p);
  
<span class="line-modified">!   static short extract_hash(uint32_t value)   { return (short)(value &gt;&gt; 16); }</span>
    static int extract_refcount(uint32_t value) { return value &amp; 0xffff; }
<span class="line-modified">!   static uint32_t pack_hash_and_refcount(short hash, int refcount);</span>
  
<span class="line-modified">!   int length() const   { return _length; }</span>
  
   public:
    // Low-level access (used with care, since not GC-safe)
    const u1* base() const { return &amp;_body[0]; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,16 ***</span>
  
    // Returns the largest size symbol we can safely hold.
    static int max_length() { return max_symbol_length; }
    unsigned identity_hash() const {
      unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
<span class="line-modified">!     return ((unsigned)_identity_hash &amp; 0xffff) |</span>
             ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
    }
  
    // Reference counting.  See comments above this class for when to use.
<span class="line-modified">!   int refcount() const { return extract_refcount(_length_and_refcount); }</span>
    bool try_increment_refcount();
    void increment_refcount();
    void decrement_refcount();
    bool is_permanent() {
      return (refcount() == PERM_REFCOUNT);
<span class="line-new-header">--- 154,16 ---</span>
  
    // Returns the largest size symbol we can safely hold.
    static int max_length() { return max_symbol_length; }
    unsigned identity_hash() const {
      unsigned addr_bits = (unsigned)((uintptr_t)this &gt;&gt; (LogMinObjAlignmentInBytes + 3));
<span class="line-modified">!     return ((unsigned)extract_hash(_hash_and_refcount) &amp; 0xffff) |</span>
             ((addr_bits ^ (length() &lt;&lt; 8) ^ (( _body[0] &lt;&lt; 8) | _body[1])) &lt;&lt; 16);
    }
  
    // Reference counting.  See comments above this class for when to use.
<span class="line-modified">!   int refcount() const { return extract_refcount(_hash_and_refcount); }</span>
    bool try_increment_refcount();
    void increment_refcount();
    void decrement_refcount();
    bool is_permanent() {
      return (refcount() == PERM_REFCOUNT);
</pre>
<center><a href="symbol.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
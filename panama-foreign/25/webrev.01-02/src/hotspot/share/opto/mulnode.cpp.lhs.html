<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/mulnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/convertnode.hpp&quot;
  30 #include &quot;opto/memnode.hpp&quot;
  31 #include &quot;opto/mulnode.hpp&quot;
  32 #include &quot;opto/phaseX.hpp&quot;
  33 #include &quot;opto/subnode.hpp&quot;
<a name="1" id="anc1"></a>
  34 
  35 // Portions of code courtesy of Clifford Click
  36 
  37 
  38 //=============================================================================
  39 //------------------------------hash-------------------------------------------
  40 // Hash function over MulNodes.  Needs to be commutative; i.e., I swap
  41 // (commute) inputs to MulNodes willy-nilly so the hash function must return
  42 // the same value in the presence of edge swapping.
  43 uint MulNode::hash() const {
  44   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  45 }
  46 
  47 //------------------------------Identity---------------------------------------
  48 // Multiplying a one preserves the other argument
  49 Node* MulNode::Identity(PhaseGVN* phase) {
  50   const Type *one = mul_id();  // The multiplicative identity
  51   if( phase-&gt;type( in(1) )-&gt;higher_equal( one ) ) return in(2);
  52   if( phase-&gt;type( in(2) )-&gt;higher_equal( one ) ) return in(1);
  53 
  54   return this;
  55 }
  56 
  57 //------------------------------Ideal------------------------------------------
  58 // We also canonicalize the Node, moving constants to the right input,
  59 // and flatten expressions (so that 1+x+2 becomes x+3).
  60 Node *MulNode::Ideal(PhaseGVN *phase, bool can_reshape) {
  61   const Type *t1 = phase-&gt;type( in(1) );
  62   const Type *t2 = phase-&gt;type( in(2) );
  63   Node *progress = NULL;        // Progress flag
  64   // We are OK if right is a constant, or right is a load and
  65   // left is a non-constant.
  66   if( !(t2-&gt;singleton() ||
  67         (in(2)-&gt;is_Load() &amp;&amp; !(t1-&gt;singleton() || in(1)-&gt;is_Load())) ) ) {
  68     if( t1-&gt;singleton() ||       // Left input is a constant?
  69         // Otherwise, sort inputs (commutativity) to help value numbering.
  70         (in(1)-&gt;_idx &gt; in(2)-&gt;_idx) ) {
  71       swap_edges(1, 2);
  72       const Type *t = t1;
  73       t1 = t2;
  74       t2 = t;
  75       progress = this;            // Made progress
  76     }
  77   }
  78 
  79   // If the right input is a constant, and the left input is a product of a
  80   // constant, flatten the expression tree.
  81   uint op = Opcode();
  82   if( t2-&gt;singleton() &amp;&amp;        // Right input is a constant?
  83       op != Op_MulF &amp;&amp;          // Float &amp; double cannot reassociate
  84       op != Op_MulD ) {
  85     if( t2 == Type::TOP ) return NULL;
  86     Node *mul1 = in(1);
  87 #ifdef ASSERT
  88     // Check for dead loop
  89     int   op1 = mul1-&gt;Opcode();
  90     if( phase-&gt;eqv( mul1, this ) || phase-&gt;eqv( in(2), this ) ||
  91         ( ( op1 == mul_opcode() || op1 == add_opcode() ) &amp;&amp;
  92           ( phase-&gt;eqv( mul1-&gt;in(1), this ) || phase-&gt;eqv( mul1-&gt;in(2), this ) ||
  93             phase-&gt;eqv( mul1-&gt;in(1), mul1 ) || phase-&gt;eqv( mul1-&gt;in(2), mul1 ) ) ) )
  94       assert(false, &quot;dead loop in MulNode::Ideal&quot;);
  95 #endif
  96 
  97     if( mul1-&gt;Opcode() == mul_opcode() ) {  // Left input is a multiply?
  98       // Mul of a constant?
  99       const Type *t12 = phase-&gt;type( mul1-&gt;in(2) );
 100       if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP) { // Left input is an add of a constant?
 101         // Compute new constant; check for overflow
 102         const Type *tcon01 = ((MulNode*)mul1)-&gt;mul_ring(t2,t12);
 103         if( tcon01-&gt;singleton() ) {
 104           // The Mul of the flattened expression
 105           set_req(1, mul1-&gt;in(1));
 106           set_req(2, phase-&gt;makecon( tcon01 ));
 107           t2 = tcon01;
 108           progress = this;      // Made progress
 109         }
 110       }
 111     }
 112     // If the right input is a constant, and the left input is an add of a
 113     // constant, flatten the tree: (X+con1)*con0 ==&gt; X*con0 + con1*con0
 114     const Node *add1 = in(1);
 115     if( add1-&gt;Opcode() == add_opcode() ) {      // Left input is an add?
 116       // Add of a constant?
 117       const Type *t12 = phase-&gt;type( add1-&gt;in(2) );
 118       if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP ) { // Left input is an add of a constant?
 119         assert( add1-&gt;in(1) != add1, &quot;dead loop in MulNode::Ideal&quot; );
 120         // Compute new constant; check for overflow
 121         const Type *tcon01 = mul_ring(t2,t12);
 122         if( tcon01-&gt;singleton() ) {
 123 
 124         // Convert (X+con1)*con0 into X*con0
 125           Node *mul = clone();    // mul = ()*con0
 126           mul-&gt;set_req(1,add1-&gt;in(1));  // mul = X*con0
 127           mul = phase-&gt;transform(mul);
 128 
 129           Node *add2 = add1-&gt;clone();
 130           add2-&gt;set_req(1, mul);        // X*con0 + con0*con1
 131           add2-&gt;set_req(2, phase-&gt;makecon(tcon01) );
 132           progress = add2;
 133         }
 134       }
 135     } // End of is left input an add
 136   } // End of is right input a Mul
 137 
 138   return progress;
 139 }
 140 
 141 //------------------------------Value-----------------------------------------
 142 const Type* MulNode::Value(PhaseGVN* phase) const {
 143   const Type *t1 = phase-&gt;type( in(1) );
 144   const Type *t2 = phase-&gt;type( in(2) );
 145   // Either input is TOP ==&gt; the result is TOP
 146   if( t1 == Type::TOP ) return Type::TOP;
 147   if( t2 == Type::TOP ) return Type::TOP;
 148 
 149   // Either input is ZERO ==&gt; the result is ZERO.
 150   // Not valid for floats or doubles since +0.0 * -0.0 --&gt; +0.0
 151   int op = Opcode();
 152   if( op == Op_MulI || op == Op_AndI || op == Op_MulL || op == Op_AndL ) {
 153     const Type *zero = add_id();        // The multiplicative zero
 154     if( t1-&gt;higher_equal( zero ) ) return zero;
 155     if( t2-&gt;higher_equal( zero ) ) return zero;
 156   }
 157 
 158   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 159   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 160     return bottom_type();
 161 
 162 #if defined(IA32)
 163   // Can&#39;t trust native compilers to properly fold strict double
 164   // multiplication with round-to-zero on this platform.
 165   if (op == Op_MulD &amp;&amp; phase-&gt;C-&gt;method()-&gt;is_strict()) {
 166     return TypeD::DOUBLE;
 167   }
 168 #endif
 169 
 170   return mul_ring(t1,t2);            // Local flavor of type multiplication
 171 }
 172 
 173 //=============================================================================
 174 //------------------------------Ideal------------------------------------------
 175 // Check for power-of-2 multiply, then try the regular MulNode::Ideal
 176 Node *MulINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 177   // Swap constant to right
 178   jint con;
 179   if ((con = in(1)-&gt;find_int_con(0)) != 0) {
 180     swap_edges(1, 2);
 181     // Finish rest of method to use info in &#39;con&#39;
 182   } else if ((con = in(2)-&gt;find_int_con(0)) == 0) {
 183     return MulNode::Ideal(phase, can_reshape);
 184   }
 185 
 186   // Now we have a constant Node on the right and the constant in con
 187   if (con == 0) return NULL;   // By zero is handled by Value call
 188   if (con == 1) return NULL;   // By one  is handled by Identity call
 189 
 190   // Check for negative constant; if so negate the final result
 191   bool sign_flip = false;
 192 
 193   unsigned int abs_con = uabs(con);
 194   if (abs_con != (unsigned int)con) {
 195     sign_flip = true;
 196   }
 197 
 198   // Get low bit; check for being the only bit
 199   Node *res = NULL;
 200   unsigned int bit1 = abs_con &amp; (0-abs_con);       // Extract low bit
 201   if (bit1 == abs_con) {           // Found a power of 2?
 202     res = new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit1)));
 203   } else {
 204 
 205     // Check for constant with 2 bits set
 206     unsigned int bit2 = abs_con-bit1;
 207     bit2 = bit2 &amp; (0-bit2);          // Extract 2nd bit
 208     if (bit2 + bit1 == abs_con) {    // Found all bits in con?
 209       Node *n1 = phase-&gt;transform( new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit1))));
 210       Node *n2 = phase-&gt;transform( new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit2))));
 211       res = new AddINode(n2, n1);
 212 
 213     } else if (is_power_of_2(abs_con+1)) {
 214       // Sleezy: power-of-2 -1.  Next time be generic.
 215       unsigned int temp = abs_con + 1;
 216       Node *n1 = phase-&gt;transform(new LShiftINode(in(1), phase-&gt;intcon(log2_uint(temp))));
 217       res = new SubINode(n1, in(1));
 218     } else {
 219       return MulNode::Ideal(phase, can_reshape);
 220     }
 221   }
 222 
 223   if (sign_flip) {             // Need to negate result?
 224     res = phase-&gt;transform(res);// Transform, before making the zero con
 225     res = new SubINode(phase-&gt;intcon(0),res);
 226   }
 227 
 228   return res;                   // Return final result
 229 }
 230 
 231 //------------------------------mul_ring---------------------------------------
 232 // Compute the product type of two integer ranges into this node.
 233 const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {
 234   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 235   const TypeInt *r1 = t1-&gt;is_int();
 236 
 237   // Fetch endpoints of all ranges
 238   jint lo0 = r0-&gt;_lo;
 239   double a = (double)lo0;
 240   jint hi0 = r0-&gt;_hi;
 241   double b = (double)hi0;
 242   jint lo1 = r1-&gt;_lo;
 243   double c = (double)lo1;
 244   jint hi1 = r1-&gt;_hi;
 245   double d = (double)hi1;
 246 
 247   // Compute all endpoints &amp; check for overflow
 248   int32_t A = java_multiply(lo0, lo1);
 249   if( (double)A != a*c ) return TypeInt::INT; // Overflow?
 250   int32_t B = java_multiply(lo0, hi1);
 251   if( (double)B != a*d ) return TypeInt::INT; // Overflow?
 252   int32_t C = java_multiply(hi0, lo1);
 253   if( (double)C != b*c ) return TypeInt::INT; // Overflow?
 254   int32_t D = java_multiply(hi0, hi1);
 255   if( (double)D != b*d ) return TypeInt::INT; // Overflow?
 256 
 257   if( A &lt; B ) { lo0 = A; hi0 = B; } // Sort range endpoints
 258   else { lo0 = B; hi0 = A; }
 259   if( C &lt; D ) {
 260     if( C &lt; lo0 ) lo0 = C;
 261     if( D &gt; hi0 ) hi0 = D;
 262   } else {
 263     if( D &lt; lo0 ) lo0 = D;
 264     if( C &gt; hi0 ) hi0 = C;
 265   }
 266   return TypeInt::make(lo0, hi0, MAX2(r0-&gt;_widen,r1-&gt;_widen));
 267 }
 268 
 269 
 270 //=============================================================================
 271 //------------------------------Ideal------------------------------------------
 272 // Check for power-of-2 multiply, then try the regular MulNode::Ideal
 273 Node *MulLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 274   // Swap constant to right
 275   jlong con;
 276   if ((con = in(1)-&gt;find_long_con(0)) != 0) {
 277     swap_edges(1, 2);
 278     // Finish rest of method to use info in &#39;con&#39;
 279   } else if ((con = in(2)-&gt;find_long_con(0)) == 0) {
 280     return MulNode::Ideal(phase, can_reshape);
 281   }
 282 
 283   // Now we have a constant Node on the right and the constant in con
 284   if (con == CONST64(0)) return NULL;  // By zero is handled by Value call
 285   if (con == CONST64(1)) return NULL;  // By one  is handled by Identity call
 286 
 287   // Check for negative constant; if so negate the final result
 288   bool sign_flip = false;
 289   julong abs_con = uabs(con);
 290   if (abs_con != (julong)con) {
 291     sign_flip = true;
 292   }
 293 
 294   // Get low bit; check for being the only bit
 295   Node *res = NULL;
 296   julong bit1 = abs_con &amp; (0-abs_con);      // Extract low bit
 297   if (bit1 == abs_con) {           // Found a power of 2?
 298     res = new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit1)));
 299   } else {
 300 
 301     // Check for constant with 2 bits set
 302     julong bit2 = abs_con-bit1;
 303     bit2 = bit2 &amp; (0-bit2);          // Extract 2nd bit
 304     if (bit2 + bit1 == abs_con) {    // Found all bits in con?
 305       Node *n1 = phase-&gt;transform(new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit1))));
 306       Node *n2 = phase-&gt;transform(new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit2))));
 307       res = new AddLNode(n2, n1);
 308 
<a name="2" id="anc2"></a><span class="line-modified"> 309     } else if (is_power_of_2_long(abs_con+1)) {</span>
 310       // Sleezy: power-of-2 -1.  Next time be generic.
 311       julong temp = abs_con + 1;
 312       Node *n1 = phase-&gt;transform( new LShiftLNode(in(1), phase-&gt;intcon(log2_long(temp))));
 313       res = new SubLNode(n1, in(1));
 314     } else {
 315       return MulNode::Ideal(phase, can_reshape);
 316     }
 317   }
 318 
 319   if (sign_flip) {             // Need to negate result?
 320     res = phase-&gt;transform(res);// Transform, before making the zero con
 321     res = new SubLNode(phase-&gt;longcon(0),res);
 322   }
 323 
 324   return res;                   // Return final result
 325 }
 326 
 327 //------------------------------mul_ring---------------------------------------
 328 // Compute the product type of two integer ranges into this node.
 329 const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {
 330   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 331   const TypeLong *r1 = t1-&gt;is_long();
 332 
 333   // Fetch endpoints of all ranges
 334   jlong lo0 = r0-&gt;_lo;
 335   double a = (double)lo0;
 336   jlong hi0 = r0-&gt;_hi;
 337   double b = (double)hi0;
 338   jlong lo1 = r1-&gt;_lo;
 339   double c = (double)lo1;
 340   jlong hi1 = r1-&gt;_hi;
 341   double d = (double)hi1;
 342 
 343   // Compute all endpoints &amp; check for overflow
 344   jlong A = java_multiply(lo0, lo1);
 345   if( (double)A != a*c ) return TypeLong::LONG; // Overflow?
 346   jlong B = java_multiply(lo0, hi1);
 347   if( (double)B != a*d ) return TypeLong::LONG; // Overflow?
 348   jlong C = java_multiply(hi0, lo1);
 349   if( (double)C != b*c ) return TypeLong::LONG; // Overflow?
 350   jlong D = java_multiply(hi0, hi1);
 351   if( (double)D != b*d ) return TypeLong::LONG; // Overflow?
 352 
 353   if( A &lt; B ) { lo0 = A; hi0 = B; } // Sort range endpoints
 354   else { lo0 = B; hi0 = A; }
 355   if( C &lt; D ) {
 356     if( C &lt; lo0 ) lo0 = C;
 357     if( D &gt; hi0 ) hi0 = D;
 358   } else {
 359     if( D &lt; lo0 ) lo0 = D;
 360     if( C &gt; hi0 ) hi0 = C;
 361   }
 362   return TypeLong::make(lo0, hi0, MAX2(r0-&gt;_widen,r1-&gt;_widen));
 363 }
 364 
 365 //=============================================================================
 366 //------------------------------mul_ring---------------------------------------
 367 // Compute the product type of two double ranges into this node.
 368 const Type *MulFNode::mul_ring(const Type *t0, const Type *t1) const {
 369   if( t0 == Type::FLOAT || t1 == Type::FLOAT ) return Type::FLOAT;
 370   return TypeF::make( t0-&gt;getf() * t1-&gt;getf() );
 371 }
 372 
 373 //=============================================================================
 374 //------------------------------mul_ring---------------------------------------
 375 // Compute the product type of two double ranges into this node.
 376 const Type *MulDNode::mul_ring(const Type *t0, const Type *t1) const {
 377   if( t0 == Type::DOUBLE || t1 == Type::DOUBLE ) return Type::DOUBLE;
 378   // We must be multiplying 2 double constants.
 379   return TypeD::make( t0-&gt;getd() * t1-&gt;getd() );
 380 }
 381 
 382 //=============================================================================
 383 //------------------------------Value------------------------------------------
 384 const Type* MulHiLNode::Value(PhaseGVN* phase) const {
 385   // Either input is TOP ==&gt; the result is TOP
 386   const Type *t1 = phase-&gt;type( in(1) );
 387   const Type *t2 = phase-&gt;type( in(2) );
 388   if( t1 == Type::TOP ) return Type::TOP;
 389   if( t2 == Type::TOP ) return Type::TOP;
 390 
 391   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 392   const Type *bot = bottom_type();
 393   if( (t1 == bot) || (t2 == bot) ||
 394       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 395     return bot;
 396 
 397   // It is not worth trying to constant fold this stuff!
 398   return TypeLong::LONG;
 399 }
 400 
 401 //=============================================================================
 402 //------------------------------mul_ring---------------------------------------
 403 // Supplied function returns the product of the inputs IN THE CURRENT RING.
 404 // For the logical operations the ring&#39;s MUL is really a logical AND function.
 405 // This also type-checks the inputs for sanity.  Guaranteed never to
 406 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 407 const Type *AndINode::mul_ring( const Type *t0, const Type *t1 ) const {
 408   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 409   const TypeInt *r1 = t1-&gt;is_int();
 410   int widen = MAX2(r0-&gt;_widen,r1-&gt;_widen);
 411 
 412   // If either input is a constant, might be able to trim cases
 413   if( !r0-&gt;is_con() &amp;&amp; !r1-&gt;is_con() )
 414     return TypeInt::INT;        // No constants to be had
 415 
 416   // Both constants?  Return bits
 417   if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() )
 418     return TypeInt::make( r0-&gt;get_con() &amp; r1-&gt;get_con() );
 419 
 420   if( r0-&gt;is_con() &amp;&amp; r0-&gt;get_con() &gt; 0 )
 421     return TypeInt::make(0, r0-&gt;get_con(), widen);
 422 
 423   if( r1-&gt;is_con() &amp;&amp; r1-&gt;get_con() &gt; 0 )
 424     return TypeInt::make(0, r1-&gt;get_con(), widen);
 425 
 426   if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {
 427     return TypeInt::BOOL;
 428   }
 429 
 430   return TypeInt::INT;          // No constants to be had
 431 }
 432 
 433 //------------------------------Identity---------------------------------------
 434 // Masking off the high bits of an unsigned load is not required
 435 Node* AndINode::Identity(PhaseGVN* phase) {
 436 
 437   // x &amp; x =&gt; x
 438   if (phase-&gt;eqv(in(1), in(2))) return in(1);
 439 
 440   Node* in1 = in(1);
 441   uint op = in1-&gt;Opcode();
 442   const TypeInt* t2 = phase-&gt;type(in(2))-&gt;isa_int();
 443   if (t2 &amp;&amp; t2-&gt;is_con()) {
 444     int con = t2-&gt;get_con();
 445     // Masking off high bits which are always zero is useless.
 446     const TypeInt* t1 = phase-&gt;type( in(1) )-&gt;isa_int();
 447     if (t1 != NULL &amp;&amp; t1-&gt;_lo &gt;= 0) {
 448       jint t1_support = right_n_bits(1 + log2_jint(t1-&gt;_hi));
 449       if ((t1_support &amp; con) == t1_support)
 450         return in1;
 451     }
 452     // Masking off the high bits of a unsigned-shift-right is not
 453     // needed either.
 454     if (op == Op_URShiftI) {
 455       const TypeInt* t12 = phase-&gt;type(in1-&gt;in(2))-&gt;isa_int();
 456       if (t12 &amp;&amp; t12-&gt;is_con()) {  // Shift is by a constant
 457         int shift = t12-&gt;get_con();
 458         shift &amp;= BitsPerJavaInteger - 1;  // semantics of Java shifts
 459         int mask = max_juint &gt;&gt; shift;
 460         if ((mask &amp; con) == mask)  // If AND is useless, skip it
 461           return in1;
 462       }
 463     }
 464   }
 465   return MulNode::Identity(phase);
 466 }
 467 
 468 //------------------------------Ideal------------------------------------------
 469 Node *AndINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 470   // Special case constant AND mask
 471   const TypeInt *t2 = phase-&gt;type( in(2) )-&gt;isa_int();
 472   if( !t2 || !t2-&gt;is_con() ) return MulNode::Ideal(phase, can_reshape);
 473   const int mask = t2-&gt;get_con();
 474   Node *load = in(1);
 475   uint lop = load-&gt;Opcode();
 476 
 477   // Masking bits off of a Character?  Hi bits are already zero.
 478   if( lop == Op_LoadUS &amp;&amp;
 479       (mask &amp; 0xFFFF0000) )     // Can we make a smaller mask?
 480     return new AndINode(load,phase-&gt;intcon(mask&amp;0xFFFF));
 481 
 482   // Masking bits off of a Short?  Loading a Character does some masking
 483   if (can_reshape &amp;&amp;
 484       load-&gt;outcnt() == 1 &amp;&amp; load-&gt;unique_out() == this) {
 485     if (lop == Op_LoadS &amp;&amp; (mask &amp; 0xFFFF0000) == 0 ) {
 486       Node* ldus = load-&gt;as_Load()-&gt;convert_to_unsigned_load(*phase);
 487       ldus = phase-&gt;transform(ldus);
 488       return new AndINode(ldus, phase-&gt;intcon(mask &amp; 0xFFFF));
 489     }
 490 
 491     // Masking sign bits off of a Byte?  Do an unsigned byte load plus
 492     // an and.
 493     if (lop == Op_LoadB &amp;&amp; (mask &amp; 0xFFFFFF00) == 0) {
 494       Node* ldub = load-&gt;as_Load()-&gt;convert_to_unsigned_load(*phase);
 495       ldub = phase-&gt;transform(ldub);
 496       return new AndINode(ldub, phase-&gt;intcon(mask));
 497     }
 498   }
 499 
 500   // Masking off sign bits?  Dont make them!
 501   if( lop == Op_RShiftI ) {
 502     const TypeInt *t12 = phase-&gt;type(load-&gt;in(2))-&gt;isa_int();
 503     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Shift is by a constant
 504       int shift = t12-&gt;get_con();
 505       shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
 506       const int sign_bits_mask = ~right_n_bits(BitsPerJavaInteger - shift);
 507       // If the AND&#39;ing of the 2 masks has no bits, then only original shifted
 508       // bits survive.  NO sign-extension bits survive the maskings.
 509       if( (sign_bits_mask &amp; mask) == 0 ) {
 510         // Use zero-fill shift instead
 511         Node *zshift = phase-&gt;transform(new URShiftINode(load-&gt;in(1),load-&gt;in(2)));
 512         return new AndINode( zshift, in(2) );
 513       }
 514     }
 515   }
 516 
 517   // Check for &#39;negate/and-1&#39;, a pattern emitted when someone asks for
 518   // &#39;mod 2&#39;.  Negate leaves the low order bit unchanged (think: complement
 519   // plus 1) and the mask is of the low order bit.  Skip the negate.
 520   if( lop == Op_SubI &amp;&amp; mask == 1 &amp;&amp; load-&gt;in(1) &amp;&amp;
 521       phase-&gt;type(load-&gt;in(1)) == TypeInt::ZERO )
 522     return new AndINode( load-&gt;in(2), in(2) );
 523 
 524   return MulNode::Ideal(phase, can_reshape);
 525 }
 526 
 527 //=============================================================================
 528 //------------------------------mul_ring---------------------------------------
 529 // Supplied function returns the product of the inputs IN THE CURRENT RING.
 530 // For the logical operations the ring&#39;s MUL is really a logical AND function.
 531 // This also type-checks the inputs for sanity.  Guaranteed never to
 532 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 533 const Type *AndLNode::mul_ring( const Type *t0, const Type *t1 ) const {
 534   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 535   const TypeLong *r1 = t1-&gt;is_long();
 536   int widen = MAX2(r0-&gt;_widen,r1-&gt;_widen);
 537 
 538   // If either input is a constant, might be able to trim cases
 539   if( !r0-&gt;is_con() &amp;&amp; !r1-&gt;is_con() )
 540     return TypeLong::LONG;      // No constants to be had
 541 
 542   // Both constants?  Return bits
 543   if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() )
 544     return TypeLong::make( r0-&gt;get_con() &amp; r1-&gt;get_con() );
 545 
 546   if( r0-&gt;is_con() &amp;&amp; r0-&gt;get_con() &gt; 0 )
 547     return TypeLong::make(CONST64(0), r0-&gt;get_con(), widen);
 548 
 549   if( r1-&gt;is_con() &amp;&amp; r1-&gt;get_con() &gt; 0 )
 550     return TypeLong::make(CONST64(0), r1-&gt;get_con(), widen);
 551 
 552   return TypeLong::LONG;        // No constants to be had
 553 }
 554 
 555 //------------------------------Identity---------------------------------------
 556 // Masking off the high bits of an unsigned load is not required
 557 Node* AndLNode::Identity(PhaseGVN* phase) {
 558 
 559   // x &amp; x =&gt; x
 560   if (phase-&gt;eqv(in(1), in(2))) return in(1);
 561 
 562   Node *usr = in(1);
 563   const TypeLong *t2 = phase-&gt;type( in(2) )-&gt;isa_long();
 564   if( t2 &amp;&amp; t2-&gt;is_con() ) {
 565     jlong con = t2-&gt;get_con();
 566     // Masking off high bits which are always zero is useless.
 567     const TypeLong* t1 = phase-&gt;type( in(1) )-&gt;isa_long();
 568     if (t1 != NULL &amp;&amp; t1-&gt;_lo &gt;= 0) {
 569       int bit_count = log2_long(t1-&gt;_hi) + 1;
 570       jlong t1_support = jlong(max_julong &gt;&gt; (BitsPerJavaLong - bit_count));
 571       if ((t1_support &amp; con) == t1_support)
 572         return usr;
 573     }
 574     uint lop = usr-&gt;Opcode();
 575     // Masking off the high bits of a unsigned-shift-right is not
 576     // needed either.
 577     if( lop == Op_URShiftL ) {
 578       const TypeInt *t12 = phase-&gt;type( usr-&gt;in(2) )-&gt;isa_int();
 579       if( t12 &amp;&amp; t12-&gt;is_con() ) {  // Shift is by a constant
 580         int shift = t12-&gt;get_con();
 581         shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 582         jlong mask = max_julong &gt;&gt; shift;
 583         if( (mask&amp;con) == mask )  // If AND is useless, skip it
 584           return usr;
 585       }
 586     }
 587   }
 588   return MulNode::Identity(phase);
 589 }
 590 
 591 //------------------------------Ideal------------------------------------------
 592 Node *AndLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 593   // Special case constant AND mask
 594   const TypeLong *t2 = phase-&gt;type( in(2) )-&gt;isa_long();
 595   if( !t2 || !t2-&gt;is_con() ) return MulNode::Ideal(phase, can_reshape);
 596   const jlong mask = t2-&gt;get_con();
 597 
 598   Node* in1 = in(1);
 599   uint op = in1-&gt;Opcode();
 600 
 601   // Are we masking a long that was converted from an int with a mask
 602   // that fits in 32-bits?  Commute them and use an AndINode.  Don&#39;t
 603   // convert masks which would cause a sign extension of the integer
 604   // value.  This check includes UI2L masks (0x00000000FFFFFFFF) which
 605   // would be optimized away later in Identity.
 606   if (op == Op_ConvI2L &amp;&amp; (mask &amp; UCONST64(0xFFFFFFFF80000000)) == 0) {
 607     Node* andi = new AndINode(in1-&gt;in(1), phase-&gt;intcon(mask));
 608     andi = phase-&gt;transform(andi);
 609     return new ConvI2LNode(andi);
 610   }
 611 
 612   // Masking off sign bits?  Dont make them!
 613   if (op == Op_RShiftL) {
 614     const TypeInt* t12 = phase-&gt;type(in1-&gt;in(2))-&gt;isa_int();
 615     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Shift is by a constant
 616       int shift = t12-&gt;get_con();
 617       shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 618       const jlong sign_bits_mask = ~(((jlong)CONST64(1) &lt;&lt; (jlong)(BitsPerJavaLong - shift)) -1);
 619       // If the AND&#39;ing of the 2 masks has no bits, then only original shifted
 620       // bits survive.  NO sign-extension bits survive the maskings.
 621       if( (sign_bits_mask &amp; mask) == 0 ) {
 622         // Use zero-fill shift instead
 623         Node *zshift = phase-&gt;transform(new URShiftLNode(in1-&gt;in(1), in1-&gt;in(2)));
 624         return new AndLNode(zshift, in(2));
 625       }
 626     }
 627   }
 628 
 629   return MulNode::Ideal(phase, can_reshape);
 630 }
 631 
 632 //=============================================================================
 633 
 634 static int getShiftCon(PhaseGVN *phase, Node *shiftNode, int retVal) {
 635   const Type *t = phase-&gt;type(shiftNode-&gt;in(2));
 636   if (t == Type::TOP) return retVal;       // Right input is dead.
 637   const TypeInt *t2 = t-&gt;isa_int();
 638   if (!t2 || !t2-&gt;is_con()) return retVal; // Right input is a constant.
 639 
 640   return t2-&gt;get_con();
 641 }
 642 
 643 static int maskShiftAmount(PhaseGVN *phase, Node *shiftNode, int nBits) {
 644   int       shift = getShiftCon(phase, shiftNode, 0);
 645   int maskedShift = shift &amp; (nBits - 1);
 646 
 647   if (maskedShift == 0) return 0;         // Let Identity() handle 0 shift count.
 648 
 649   if (shift != maskedShift) {
 650     shiftNode-&gt;set_req(2, phase-&gt;intcon(maskedShift)); // Replace shift count with masked value.
 651     phase-&gt;igvn_rehash_node_delayed(shiftNode);
 652   }
 653 
 654   return maskedShift;
 655 }
 656 
 657 //------------------------------Identity---------------------------------------
 658 Node* LShiftINode::Identity(PhaseGVN* phase) {
 659   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaInteger - 1)) == 0) ? in(1) : this;
 660 }
 661 
 662 //------------------------------Ideal------------------------------------------
 663 // If the right input is a constant, and the left input is an add of a
 664 // constant, flatten the tree: (X+con1)&lt;&lt;con0 ==&gt; X&lt;&lt;con0 + con1&lt;&lt;con0
 665 Node *LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 666   int con = maskShiftAmount(phase, this, BitsPerJavaInteger);
 667   if (con == 0) {
 668     return NULL;
 669   }
 670 
 671   // Left input is an add of a constant?
 672   Node *add1 = in(1);
 673   int add1_op = add1-&gt;Opcode();
 674   if( add1_op == Op_AddI ) {    // Left input is an add?
 675     assert( add1 != add1-&gt;in(1), &quot;dead loop in LShiftINode::Ideal&quot; );
 676     const TypeInt *t12 = phase-&gt;type(add1-&gt;in(2))-&gt;isa_int();
 677     if( t12 &amp;&amp; t12-&gt;is_con() ){ // Left input is an add of a con?
 678       // Transform is legal, but check for profit.  Avoid breaking &#39;i2s&#39;
 679       // and &#39;i2b&#39; patterns which typically fold into &#39;StoreC/StoreB&#39;.
 680       if( con &lt; 16 ) {
 681         // Compute X &lt;&lt; con0
 682         Node *lsh = phase-&gt;transform( new LShiftINode( add1-&gt;in(1), in(2) ) );
 683         // Compute X&lt;&lt;con0 + (con1&lt;&lt;con0)
 684         return new AddINode( lsh, phase-&gt;intcon(t12-&gt;get_con() &lt;&lt; con));
 685       }
 686     }
 687   }
 688 
 689   // Check for &quot;(x&gt;&gt;c0)&lt;&lt;c0&quot; which just masks off low bits
 690   if( (add1_op == Op_RShiftI || add1_op == Op_URShiftI ) &amp;&amp;
 691       add1-&gt;in(2) == in(2) )
 692     // Convert to &quot;(x &amp; -(1&lt;&lt;c0))&quot;
 693     return new AndINode(add1-&gt;in(1),phase-&gt;intcon( -(1&lt;&lt;con)));
 694 
 695   // Check for &quot;((x&gt;&gt;c0) &amp; Y)&lt;&lt;c0&quot; which just masks off more low bits
 696   if( add1_op == Op_AndI ) {
 697     Node *add2 = add1-&gt;in(1);
 698     int add2_op = add2-&gt;Opcode();
 699     if( (add2_op == Op_RShiftI || add2_op == Op_URShiftI ) &amp;&amp;
 700         add2-&gt;in(2) == in(2) ) {
 701       // Convert to &quot;(x &amp; (Y&lt;&lt;c0))&quot;
 702       Node *y_sh = phase-&gt;transform( new LShiftINode( add1-&gt;in(2), in(2) ) );
 703       return new AndINode( add2-&gt;in(1), y_sh );
 704     }
 705   }
 706 
 707   // Check for ((x &amp; ((1&lt;&lt;(32-c0))-1)) &lt;&lt; c0) which ANDs off high bits
 708   // before shifting them away.
 709   const jint bits_mask = right_n_bits(BitsPerJavaInteger-con);
 710   if( add1_op == Op_AndI &amp;&amp;
 711       phase-&gt;type(add1-&gt;in(2)) == TypeInt::make( bits_mask ) )
 712     return new LShiftINode( add1-&gt;in(1), in(2) );
 713 
 714   return NULL;
 715 }
 716 
 717 //------------------------------Value------------------------------------------
 718 // A LShiftINode shifts its input2 left by input1 amount.
 719 const Type* LShiftINode::Value(PhaseGVN* phase) const {
 720   const Type *t1 = phase-&gt;type( in(1) );
 721   const Type *t2 = phase-&gt;type( in(2) );
 722   // Either input is TOP ==&gt; the result is TOP
 723   if( t1 == Type::TOP ) return Type::TOP;
 724   if( t2 == Type::TOP ) return Type::TOP;
 725 
 726   // Left input is ZERO ==&gt; the result is ZERO.
 727   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 728   // Shift by zero does nothing
 729   if( t2 == TypeInt::ZERO ) return t1;
 730 
 731   // Either input is BOTTOM ==&gt; the result is BOTTOM
 732   if( (t1 == TypeInt::INT) || (t2 == TypeInt::INT) ||
 733       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 734     return TypeInt::INT;
 735 
 736   const TypeInt *r1 = t1-&gt;is_int(); // Handy access
 737   const TypeInt *r2 = t2-&gt;is_int(); // Handy access
 738 
 739   if (!r2-&gt;is_con())
 740     return TypeInt::INT;
 741 
 742   uint shift = r2-&gt;get_con();
 743   shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
 744   // Shift by a multiple of 32 does nothing:
 745   if (shift == 0)  return t1;
 746 
 747   // If the shift is a constant, shift the bounds of the type,
 748   // unless this could lead to an overflow.
 749   if (!r1-&gt;is_con()) {
 750     jint lo = r1-&gt;_lo, hi = r1-&gt;_hi;
 751     if (((lo &lt;&lt; shift) &gt;&gt; shift) == lo &amp;&amp;
 752         ((hi &lt;&lt; shift) &gt;&gt; shift) == hi) {
 753       // No overflow.  The range shifts up cleanly.
 754       return TypeInt::make((jint)lo &lt;&lt; (jint)shift,
 755                            (jint)hi &lt;&lt; (jint)shift,
 756                            MAX2(r1-&gt;_widen,r2-&gt;_widen));
 757     }
 758     return TypeInt::INT;
 759   }
 760 
 761   return TypeInt::make( (jint)r1-&gt;get_con() &lt;&lt; (jint)shift );
 762 }
 763 
 764 //=============================================================================
 765 //------------------------------Identity---------------------------------------
 766 Node* LShiftLNode::Identity(PhaseGVN* phase) {
 767   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
 768 }
 769 
 770 //------------------------------Ideal------------------------------------------
 771 // If the right input is a constant, and the left input is an add of a
 772 // constant, flatten the tree: (X+con1)&lt;&lt;con0 ==&gt; X&lt;&lt;con0 + con1&lt;&lt;con0
 773 Node *LShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 774   int con = maskShiftAmount(phase, this, BitsPerJavaLong);
 775   if (con == 0) {
 776     return NULL;
 777   }
 778 
 779   // Left input is an add of a constant?
 780   Node *add1 = in(1);
 781   int add1_op = add1-&gt;Opcode();
 782   if( add1_op == Op_AddL ) {    // Left input is an add?
 783     // Avoid dead data cycles from dead loops
 784     assert( add1 != add1-&gt;in(1), &quot;dead loop in LShiftLNode::Ideal&quot; );
 785     const TypeLong *t12 = phase-&gt;type(add1-&gt;in(2))-&gt;isa_long();
 786     if( t12 &amp;&amp; t12-&gt;is_con() ){ // Left input is an add of a con?
 787       // Compute X &lt;&lt; con0
 788       Node *lsh = phase-&gt;transform( new LShiftLNode( add1-&gt;in(1), in(2) ) );
 789       // Compute X&lt;&lt;con0 + (con1&lt;&lt;con0)
 790       return new AddLNode( lsh, phase-&gt;longcon(t12-&gt;get_con() &lt;&lt; con));
 791     }
 792   }
 793 
 794   // Check for &quot;(x&gt;&gt;c0)&lt;&lt;c0&quot; which just masks off low bits
 795   if( (add1_op == Op_RShiftL || add1_op == Op_URShiftL ) &amp;&amp;
 796       add1-&gt;in(2) == in(2) )
 797     // Convert to &quot;(x &amp; -(1&lt;&lt;c0))&quot;
 798     return new AndLNode(add1-&gt;in(1),phase-&gt;longcon( -(CONST64(1)&lt;&lt;con)));
 799 
 800   // Check for &quot;((x&gt;&gt;c0) &amp; Y)&lt;&lt;c0&quot; which just masks off more low bits
 801   if( add1_op == Op_AndL ) {
 802     Node *add2 = add1-&gt;in(1);
 803     int add2_op = add2-&gt;Opcode();
 804     if( (add2_op == Op_RShiftL || add2_op == Op_URShiftL ) &amp;&amp;
 805         add2-&gt;in(2) == in(2) ) {
 806       // Convert to &quot;(x &amp; (Y&lt;&lt;c0))&quot;
 807       Node *y_sh = phase-&gt;transform( new LShiftLNode( add1-&gt;in(2), in(2) ) );
 808       return new AndLNode( add2-&gt;in(1), y_sh );
 809     }
 810   }
 811 
 812   // Check for ((x &amp; ((CONST64(1)&lt;&lt;(64-c0))-1)) &lt;&lt; c0) which ANDs off high bits
 813   // before shifting them away.
 814   const jlong bits_mask = jlong(max_julong &gt;&gt; con);
 815   if( add1_op == Op_AndL &amp;&amp;
 816       phase-&gt;type(add1-&gt;in(2)) == TypeLong::make( bits_mask ) )
 817     return new LShiftLNode( add1-&gt;in(1), in(2) );
 818 
 819   return NULL;
 820 }
 821 
 822 //------------------------------Value------------------------------------------
 823 // A LShiftLNode shifts its input2 left by input1 amount.
 824 const Type* LShiftLNode::Value(PhaseGVN* phase) const {
 825   const Type *t1 = phase-&gt;type( in(1) );
 826   const Type *t2 = phase-&gt;type( in(2) );
 827   // Either input is TOP ==&gt; the result is TOP
 828   if( t1 == Type::TOP ) return Type::TOP;
 829   if( t2 == Type::TOP ) return Type::TOP;
 830 
 831   // Left input is ZERO ==&gt; the result is ZERO.
 832   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
 833   // Shift by zero does nothing
 834   if( t2 == TypeInt::ZERO ) return t1;
 835 
 836   // Either input is BOTTOM ==&gt; the result is BOTTOM
 837   if( (t1 == TypeLong::LONG) || (t2 == TypeInt::INT) ||
 838       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 839     return TypeLong::LONG;
 840 
 841   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
 842   const TypeInt  *r2 = t2-&gt;is_int();  // Handy access
 843 
 844   if (!r2-&gt;is_con())
 845     return TypeLong::LONG;
 846 
 847   uint shift = r2-&gt;get_con();
 848   shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 849   // Shift by a multiple of 64 does nothing:
 850   if (shift == 0)  return t1;
 851 
 852   // If the shift is a constant, shift the bounds of the type,
 853   // unless this could lead to an overflow.
 854   if (!r1-&gt;is_con()) {
 855     jlong lo = r1-&gt;_lo, hi = r1-&gt;_hi;
 856     if (((lo &lt;&lt; shift) &gt;&gt; shift) == lo &amp;&amp;
 857         ((hi &lt;&lt; shift) &gt;&gt; shift) == hi) {
 858       // No overflow.  The range shifts up cleanly.
 859       return TypeLong::make((jlong)lo &lt;&lt; (jint)shift,
 860                             (jlong)hi &lt;&lt; (jint)shift,
 861                             MAX2(r1-&gt;_widen,r2-&gt;_widen));
 862     }
 863     return TypeLong::LONG;
 864   }
 865 
 866   return TypeLong::make( (jlong)r1-&gt;get_con() &lt;&lt; (jint)shift );
 867 }
 868 
 869 //=============================================================================
 870 //------------------------------Identity---------------------------------------
 871 Node* RShiftINode::Identity(PhaseGVN* phase) {
 872   int shift = getShiftCon(phase, this, -1);
 873   if (shift == -1) return this;
 874   if ((shift &amp; (BitsPerJavaInteger - 1)) == 0) return in(1);
 875 
 876   // Check for useless sign-masking
 877   if (in(1)-&gt;Opcode() == Op_LShiftI &amp;&amp;
 878       in(1)-&gt;req() == 3 &amp;&amp;
 879       in(1)-&gt;in(2) == in(2)) {
 880     shift &amp;= BitsPerJavaInteger-1; // semantics of Java shifts
 881     // Compute masks for which this shifting doesn&#39;t change
 882     int lo = (-1 &lt;&lt; (BitsPerJavaInteger - ((uint)shift)-1)); // FFFF8000
 883     int hi = ~lo;               // 00007FFF
 884     const TypeInt *t11 = phase-&gt;type(in(1)-&gt;in(1))-&gt;isa_int();
 885     if (!t11) return this;
 886     // Does actual value fit inside of mask?
 887     if (lo &lt;= t11-&gt;_lo &amp;&amp; t11-&gt;_hi &lt;= hi) {
 888       return in(1)-&gt;in(1);      // Then shifting is a nop
 889     }
 890   }
 891 
 892   return this;
 893 }
 894 
 895 //------------------------------Ideal------------------------------------------
 896 Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 897   // Inputs may be TOP if they are dead.
 898   const TypeInt *t1 = phase-&gt;type(in(1))-&gt;isa_int();
 899   if (!t1) return NULL;        // Left input is an integer
 900   const TypeInt *t3;  // type of in(1).in(2)
 901   int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);
 902   if (shift == 0) {
 903     return NULL;
 904   }
 905 
 906   // Check for (x &amp; 0xFF000000) &gt;&gt; 24, whose mask can be made smaller.
 907   // Such expressions arise normally from shift chains like (byte)(x &gt;&gt; 24).
 908   const Node *mask = in(1);
 909   if( mask-&gt;Opcode() == Op_AndI &amp;&amp;
 910       (t3 = phase-&gt;type(mask-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 911       t3-&gt;is_con() ) {
 912     Node *x = mask-&gt;in(1);
 913     jint maskbits = t3-&gt;get_con();
 914     // Convert to &quot;(x &gt;&gt; shift) &amp; (mask &gt;&gt; shift)&quot;
 915     Node *shr_nomask = phase-&gt;transform( new RShiftINode(mask-&gt;in(1), in(2)) );
 916     return new AndINode(shr_nomask, phase-&gt;intcon( maskbits &gt;&gt; shift));
 917   }
 918 
 919   // Check for &quot;(short[i] &lt;&lt;16)&gt;&gt;16&quot; which simply sign-extends
 920   const Node *shl = in(1);
 921   if( shl-&gt;Opcode() != Op_LShiftI ) return NULL;
 922 
 923   if( shift == 16 &amp;&amp;
 924       (t3 = phase-&gt;type(shl-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 925       t3-&gt;is_con(16) ) {
 926     Node *ld = shl-&gt;in(1);
 927     if( ld-&gt;Opcode() == Op_LoadS ) {
 928       // Sign extension is just useless here.  Return a RShiftI of zero instead
 929       // returning &#39;ld&#39; directly.  We cannot return an old Node directly as
 930       // that is the job of &#39;Identity&#39; calls and Identity calls only work on
 931       // direct inputs (&#39;ld&#39; is an extra Node removed from &#39;this&#39;).  The
 932       // combined optimization requires Identity only return direct inputs.
 933       set_req(1, ld);
 934       set_req(2, phase-&gt;intcon(0));
 935       return this;
 936     }
 937     else if( can_reshape &amp;&amp;
 938              ld-&gt;Opcode() == Op_LoadUS &amp;&amp;
 939              ld-&gt;outcnt() == 1 &amp;&amp; ld-&gt;unique_out() == shl)
 940       // Replace zero-extension-load with sign-extension-load
 941       return ld-&gt;as_Load()-&gt;convert_to_signed_load(*phase);
 942   }
 943 
 944   // Check for &quot;(byte[i] &lt;&lt;24)&gt;&gt;24&quot; which simply sign-extends
 945   if( shift == 24 &amp;&amp;
 946       (t3 = phase-&gt;type(shl-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 947       t3-&gt;is_con(24) ) {
 948     Node *ld = shl-&gt;in(1);
 949     if( ld-&gt;Opcode() == Op_LoadB ) {
 950       // Sign extension is just useless here
 951       set_req(1, ld);
 952       set_req(2, phase-&gt;intcon(0));
 953       return this;
 954     }
 955   }
 956 
 957   return NULL;
 958 }
 959 
 960 //------------------------------Value------------------------------------------
 961 // A RShiftINode shifts its input2 right by input1 amount.
 962 const Type* RShiftINode::Value(PhaseGVN* phase) const {
 963   const Type *t1 = phase-&gt;type( in(1) );
 964   const Type *t2 = phase-&gt;type( in(2) );
 965   // Either input is TOP ==&gt; the result is TOP
 966   if( t1 == Type::TOP ) return Type::TOP;
 967   if( t2 == Type::TOP ) return Type::TOP;
 968 
 969   // Left input is ZERO ==&gt; the result is ZERO.
 970   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 971   // Shift by zero does nothing
 972   if( t2 == TypeInt::ZERO ) return t1;
 973 
 974   // Either input is BOTTOM ==&gt; the result is BOTTOM
 975   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
 976     return TypeInt::INT;
 977 
 978   if (t2 == TypeInt::INT)
 979     return TypeInt::INT;
 980 
 981   const TypeInt *r1 = t1-&gt;is_int(); // Handy access
 982   const TypeInt *r2 = t2-&gt;is_int(); // Handy access
 983 
 984   // If the shift is a constant, just shift the bounds of the type.
 985   // For example, if the shift is 31, we just propagate sign bits.
 986   if (r2-&gt;is_con()) {
 987     uint shift = r2-&gt;get_con();
 988     shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
 989     // Shift by a multiple of 32 does nothing:
 990     if (shift == 0)  return t1;
 991     // Calculate reasonably aggressive bounds for the result.
 992     // This is necessary if we are to correctly type things
 993     // like (x&lt;&lt;24&gt;&gt;24) == ((byte)x).
 994     jint lo = (jint)r1-&gt;_lo &gt;&gt; (jint)shift;
 995     jint hi = (jint)r1-&gt;_hi &gt;&gt; (jint)shift;
 996     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
 997     const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
 998 #ifdef ASSERT
 999     // Make sure we get the sign-capture idiom correct.
1000     if (shift == BitsPerJavaInteger-1) {
1001       if (r1-&gt;_lo &gt;= 0) assert(ti == TypeInt::ZERO,    &quot;&gt;&gt;31 of + is  0&quot;);
1002       if (r1-&gt;_hi &lt;  0) assert(ti == TypeInt::MINUS_1, &quot;&gt;&gt;31 of - is -1&quot;);
1003     }
1004 #endif
1005     return ti;
1006   }
1007 
1008   if( !r1-&gt;is_con() || !r2-&gt;is_con() )
1009     return TypeInt::INT;
1010 
1011   // Signed shift right
1012   return TypeInt::make( r1-&gt;get_con() &gt;&gt; (r2-&gt;get_con()&amp;31) );
1013 }
1014 
1015 //=============================================================================
1016 //------------------------------Identity---------------------------------------
1017 Node* RShiftLNode::Identity(PhaseGVN* phase) {
1018   const TypeInt *ti = phase-&gt;type(in(2))-&gt;isa_int(); // Shift count is an int.
1019   return (ti &amp;&amp; ti-&gt;is_con() &amp;&amp; (ti-&gt;get_con() &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
1020 }
1021 
1022 //------------------------------Value------------------------------------------
1023 // A RShiftLNode shifts its input2 right by input1 amount.
1024 const Type* RShiftLNode::Value(PhaseGVN* phase) const {
1025   const Type *t1 = phase-&gt;type( in(1) );
1026   const Type *t2 = phase-&gt;type( in(2) );
1027   // Either input is TOP ==&gt; the result is TOP
1028   if( t1 == Type::TOP ) return Type::TOP;
1029   if( t2 == Type::TOP ) return Type::TOP;
1030 
1031   // Left input is ZERO ==&gt; the result is ZERO.
1032   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1033   // Shift by zero does nothing
1034   if( t2 == TypeInt::ZERO ) return t1;
1035 
1036   // Either input is BOTTOM ==&gt; the result is BOTTOM
1037   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1038     return TypeLong::LONG;
1039 
1040   if (t2 == TypeInt::INT)
1041     return TypeLong::LONG;
1042 
1043   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
1044   const TypeInt  *r2 = t2-&gt;is_int (); // Handy access
1045 
1046   // If the shift is a constant, just shift the bounds of the type.
1047   // For example, if the shift is 63, we just propagate sign bits.
1048   if (r2-&gt;is_con()) {
1049     uint shift = r2-&gt;get_con();
1050     shift &amp;= (2*BitsPerJavaInteger)-1;  // semantics of Java shifts
1051     // Shift by a multiple of 64 does nothing:
1052     if (shift == 0)  return t1;
1053     // Calculate reasonably aggressive bounds for the result.
1054     // This is necessary if we are to correctly type things
1055     // like (x&lt;&lt;24&gt;&gt;24) == ((byte)x).
1056     jlong lo = (jlong)r1-&gt;_lo &gt;&gt; (jlong)shift;
1057     jlong hi = (jlong)r1-&gt;_hi &gt;&gt; (jlong)shift;
1058     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1059     const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1060     #ifdef ASSERT
1061     // Make sure we get the sign-capture idiom correct.
1062     if (shift == (2*BitsPerJavaInteger)-1) {
1063       if (r1-&gt;_lo &gt;= 0) assert(tl == TypeLong::ZERO,    &quot;&gt;&gt;63 of + is 0&quot;);
1064       if (r1-&gt;_hi &lt; 0)  assert(tl == TypeLong::MINUS_1, &quot;&gt;&gt;63 of - is -1&quot;);
1065     }
1066     #endif
1067     return tl;
1068   }
1069 
1070   return TypeLong::LONG;                // Give up
1071 }
1072 
1073 //=============================================================================
1074 //------------------------------Identity---------------------------------------
1075 Node* URShiftINode::Identity(PhaseGVN* phase) {
1076   int shift = getShiftCon(phase, this, -1);
1077   if ((shift &amp; (BitsPerJavaInteger - 1)) == 0) return in(1);
1078 
1079   // Check for &quot;((x &lt;&lt; LogBytesPerWord) + (wordSize-1)) &gt;&gt; LogBytesPerWord&quot; which is just &quot;x&quot;.
1080   // Happens during new-array length computation.
1081   // Safe if &#39;x&#39; is in the range [0..(max_int&gt;&gt;LogBytesPerWord)]
1082   Node *add = in(1);
1083   if (add-&gt;Opcode() == Op_AddI) {
1084     const TypeInt *t2 = phase-&gt;type(add-&gt;in(2))-&gt;isa_int();
1085     if (t2 &amp;&amp; t2-&gt;is_con(wordSize - 1) &amp;&amp;
1086         add-&gt;in(1)-&gt;Opcode() == Op_LShiftI) {
1087       // Check that shift_counts are LogBytesPerWord.
1088       Node          *lshift_count   = add-&gt;in(1)-&gt;in(2);
1089       const TypeInt *t_lshift_count = phase-&gt;type(lshift_count)-&gt;isa_int();
1090       if (t_lshift_count &amp;&amp; t_lshift_count-&gt;is_con(LogBytesPerWord) &amp;&amp;
1091           t_lshift_count == phase-&gt;type(in(2))) {
1092         Node          *x   = add-&gt;in(1)-&gt;in(1);
1093         const TypeInt *t_x = phase-&gt;type(x)-&gt;isa_int();
1094         if (t_x != NULL &amp;&amp; 0 &lt;= t_x-&gt;_lo &amp;&amp; t_x-&gt;_hi &lt;= (max_jint&gt;&gt;LogBytesPerWord)) {
1095           return x;
1096         }
1097       }
1098     }
1099   }
1100 
1101   return (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) ? in(1) : this;
1102 }
1103 
1104 //------------------------------Ideal------------------------------------------
1105 Node *URShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
1106   int con = maskShiftAmount(phase, this, BitsPerJavaInteger);
1107   if (con == 0) {
1108     return NULL;
1109   }
1110 
1111   // We&#39;ll be wanting the right-shift amount as a mask of that many bits
1112   const int mask = right_n_bits(BitsPerJavaInteger - con);
1113 
1114   int in1_op = in(1)-&gt;Opcode();
1115 
1116   // Check for ((x&gt;&gt;&gt;a)&gt;&gt;&gt;b) and replace with (x&gt;&gt;&gt;(a+b)) when a+b &lt; 32
1117   if( in1_op == Op_URShiftI ) {
1118     const TypeInt *t12 = phase-&gt;type( in(1)-&gt;in(2) )-&gt;isa_int();
1119     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Right input is a constant
1120       assert( in(1) != in(1)-&gt;in(1), &quot;dead loop in URShiftINode::Ideal&quot; );
1121       const int con2 = t12-&gt;get_con() &amp; 31; // Shift count is always masked
1122       const int con3 = con+con2;
1123       if( con3 &lt; 32 )           // Only merge shifts if total is &lt; 32
1124         return new URShiftINode( in(1)-&gt;in(1), phase-&gt;intcon(con3) );
1125     }
1126   }
1127 
1128   // Check for ((x &lt;&lt; z) + Y) &gt;&gt;&gt; z.  Replace with x + con&gt;&gt;&gt;z
1129   // The idiom for rounding to a power of 2 is &quot;(Q+(2^z-1)) &gt;&gt;&gt; z&quot;.
1130   // If Q is &quot;X &lt;&lt; z&quot; the rounding is useless.  Look for patterns like
1131   // ((X&lt;&lt;Z) + Y) &gt;&gt;&gt; Z  and replace with (X + Y&gt;&gt;&gt;Z) &amp; Z-mask.
1132   Node *add = in(1);
1133   const TypeInt *t2 = phase-&gt;type(in(2))-&gt;isa_int();
1134   if (in1_op == Op_AddI) {
1135     Node *lshl = add-&gt;in(1);
1136     if( lshl-&gt;Opcode() == Op_LShiftI &amp;&amp;
1137         phase-&gt;type(lshl-&gt;in(2)) == t2 ) {
1138       Node *y_z = phase-&gt;transform( new URShiftINode(add-&gt;in(2),in(2)) );
1139       Node *sum = phase-&gt;transform( new AddINode( lshl-&gt;in(1), y_z ) );
1140       return new AndINode( sum, phase-&gt;intcon(mask) );
1141     }
1142   }
1143 
1144   // Check for (x &amp; mask) &gt;&gt;&gt; z.  Replace with (x &gt;&gt;&gt; z) &amp; (mask &gt;&gt;&gt; z)
1145   // This shortens the mask.  Also, if we are extracting a high byte and
1146   // storing it to a buffer, the mask will be removed completely.
1147   Node *andi = in(1);
1148   if( in1_op == Op_AndI ) {
1149     const TypeInt *t3 = phase-&gt;type( andi-&gt;in(2) )-&gt;isa_int();
1150     if( t3 &amp;&amp; t3-&gt;is_con() ) { // Right input is a constant
1151       jint mask2 = t3-&gt;get_con();
1152       mask2 &gt;&gt;= con;  // *signed* shift downward (high-order zeroes do not help)
1153       Node *newshr = phase-&gt;transform( new URShiftINode(andi-&gt;in(1), in(2)) );
1154       return new AndINode(newshr, phase-&gt;intcon(mask2));
1155       // The negative values are easier to materialize than positive ones.
1156       // A typical case from address arithmetic is ((x &amp; ~15) &gt;&gt; 4).
1157       // It&#39;s better to change that to ((x &gt;&gt; 4) &amp; ~0) versus
1158       // ((x &gt;&gt; 4) &amp; 0x0FFFFFFF).  The difference is greatest in LP64.
1159     }
1160   }
1161 
1162   // Check for &quot;(X &lt;&lt; z ) &gt;&gt;&gt; z&quot; which simply zero-extends
1163   Node *shl = in(1);
1164   if( in1_op == Op_LShiftI &amp;&amp;
1165       phase-&gt;type(shl-&gt;in(2)) == t2 )
1166     return new AndINode( shl-&gt;in(1), phase-&gt;intcon(mask) );
1167 
1168   return NULL;
1169 }
1170 
1171 //------------------------------Value------------------------------------------
1172 // A URShiftINode shifts its input2 right by input1 amount.
1173 const Type* URShiftINode::Value(PhaseGVN* phase) const {
1174   // (This is a near clone of RShiftINode::Value.)
1175   const Type *t1 = phase-&gt;type( in(1) );
1176   const Type *t2 = phase-&gt;type( in(2) );
1177   // Either input is TOP ==&gt; the result is TOP
1178   if( t1 == Type::TOP ) return Type::TOP;
1179   if( t2 == Type::TOP ) return Type::TOP;
1180 
1181   // Left input is ZERO ==&gt; the result is ZERO.
1182   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
1183   // Shift by zero does nothing
1184   if( t2 == TypeInt::ZERO ) return t1;
1185 
1186   // Either input is BOTTOM ==&gt; the result is BOTTOM
1187   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1188     return TypeInt::INT;
1189 
1190   if (t2 == TypeInt::INT)
1191     return TypeInt::INT;
1192 
1193   const TypeInt *r1 = t1-&gt;is_int();     // Handy access
1194   const TypeInt *r2 = t2-&gt;is_int();     // Handy access
1195 
1196   if (r2-&gt;is_con()) {
1197     uint shift = r2-&gt;get_con();
1198     shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
1199     // Shift by a multiple of 32 does nothing:
1200     if (shift == 0)  return t1;
1201     // Calculate reasonably aggressive bounds for the result.
1202     jint lo = (juint)r1-&gt;_lo &gt;&gt; (juint)shift;
1203     jint hi = (juint)r1-&gt;_hi &gt;&gt; (juint)shift;
1204     if (r1-&gt;_hi &gt;= 0 &amp;&amp; r1-&gt;_lo &lt; 0) {
1205       // If the type has both negative and positive values,
1206       // there are two separate sub-domains to worry about:
1207       // The positive half and the negative half.
1208       jint neg_lo = lo;
1209       jint neg_hi = (juint)-1 &gt;&gt; (juint)shift;
1210       jint pos_lo = (juint) 0 &gt;&gt; (juint)shift;
1211       jint pos_hi = hi;
1212       lo = MIN2(neg_lo, pos_lo);  // == 0
1213       hi = MAX2(neg_hi, pos_hi);  // == -1 &gt;&gt;&gt; shift;
1214     }
1215     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1216     const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1217     #ifdef ASSERT
1218     // Make sure we get the sign-capture idiom correct.
1219     if (shift == BitsPerJavaInteger-1) {
1220       if (r1-&gt;_lo &gt;= 0) assert(ti == TypeInt::ZERO, &quot;&gt;&gt;&gt;31 of + is 0&quot;);
1221       if (r1-&gt;_hi &lt; 0)  assert(ti == TypeInt::ONE,  &quot;&gt;&gt;&gt;31 of - is +1&quot;);
1222     }
1223     #endif
1224     return ti;
1225   }
1226 
1227   //
1228   // Do not support shifted oops in info for GC
1229   //
1230   // else if( t1-&gt;base() == Type::InstPtr ) {
1231   //
1232   //   const TypeInstPtr *o = t1-&gt;is_instptr();
1233   //   if( t1-&gt;singleton() )
1234   //     return TypeInt::make( ((uint32_t)o-&gt;const_oop() + o-&gt;_offset) &gt;&gt; shift );
1235   // }
1236   // else if( t1-&gt;base() == Type::KlassPtr ) {
1237   //   const TypeKlassPtr *o = t1-&gt;is_klassptr();
1238   //   if( t1-&gt;singleton() )
1239   //     return TypeInt::make( ((uint32_t)o-&gt;const_oop() + o-&gt;_offset) &gt;&gt; shift );
1240   // }
1241 
1242   return TypeInt::INT;
1243 }
1244 
1245 //=============================================================================
1246 //------------------------------Identity---------------------------------------
1247 Node* URShiftLNode::Identity(PhaseGVN* phase) {
1248   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
1249 }
1250 
1251 //------------------------------Ideal------------------------------------------
1252 Node *URShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1253   int con = maskShiftAmount(phase, this, BitsPerJavaLong);
1254   if (con == 0) {
1255     return NULL;
1256   }
1257 
1258   // We&#39;ll be wanting the right-shift amount as a mask of that many bits
1259   const jlong mask = jlong(max_julong &gt;&gt; con);
1260 
1261   // Check for ((x &lt;&lt; z) + Y) &gt;&gt;&gt; z.  Replace with x + con&gt;&gt;&gt;z
1262   // The idiom for rounding to a power of 2 is &quot;(Q+(2^z-1)) &gt;&gt;&gt; z&quot;.
1263   // If Q is &quot;X &lt;&lt; z&quot; the rounding is useless.  Look for patterns like
1264   // ((X&lt;&lt;Z) + Y) &gt;&gt;&gt; Z  and replace with (X + Y&gt;&gt;&gt;Z) &amp; Z-mask.
1265   Node *add = in(1);
1266   const TypeInt *t2 = phase-&gt;type(in(2))-&gt;isa_int();
1267   if (add-&gt;Opcode() == Op_AddL) {
1268     Node *lshl = add-&gt;in(1);
1269     if( lshl-&gt;Opcode() == Op_LShiftL &amp;&amp;
1270         phase-&gt;type(lshl-&gt;in(2)) == t2 ) {
1271       Node *y_z = phase-&gt;transform( new URShiftLNode(add-&gt;in(2),in(2)) );
1272       Node *sum = phase-&gt;transform( new AddLNode( lshl-&gt;in(1), y_z ) );
1273       return new AndLNode( sum, phase-&gt;longcon(mask) );
1274     }
1275   }
1276 
1277   // Check for (x &amp; mask) &gt;&gt;&gt; z.  Replace with (x &gt;&gt;&gt; z) &amp; (mask &gt;&gt;&gt; z)
1278   // This shortens the mask.  Also, if we are extracting a high byte and
1279   // storing it to a buffer, the mask will be removed completely.
1280   Node *andi = in(1);
1281   if( andi-&gt;Opcode() == Op_AndL ) {
1282     const TypeLong *t3 = phase-&gt;type( andi-&gt;in(2) )-&gt;isa_long();
1283     if( t3 &amp;&amp; t3-&gt;is_con() ) { // Right input is a constant
1284       jlong mask2 = t3-&gt;get_con();
1285       mask2 &gt;&gt;= con;  // *signed* shift downward (high-order zeroes do not help)
1286       Node *newshr = phase-&gt;transform( new URShiftLNode(andi-&gt;in(1), in(2)) );
1287       return new AndLNode(newshr, phase-&gt;longcon(mask2));
1288     }
1289   }
1290 
1291   // Check for &quot;(X &lt;&lt; z ) &gt;&gt;&gt; z&quot; which simply zero-extends
1292   Node *shl = in(1);
1293   if( shl-&gt;Opcode() == Op_LShiftL &amp;&amp;
1294       phase-&gt;type(shl-&gt;in(2)) == t2 )
1295     return new AndLNode( shl-&gt;in(1), phase-&gt;longcon(mask) );
1296 
1297   return NULL;
1298 }
1299 
1300 //------------------------------Value------------------------------------------
1301 // A URShiftINode shifts its input2 right by input1 amount.
1302 const Type* URShiftLNode::Value(PhaseGVN* phase) const {
1303   // (This is a near clone of RShiftLNode::Value.)
1304   const Type *t1 = phase-&gt;type( in(1) );
1305   const Type *t2 = phase-&gt;type( in(2) );
1306   // Either input is TOP ==&gt; the result is TOP
1307   if( t1 == Type::TOP ) return Type::TOP;
1308   if( t2 == Type::TOP ) return Type::TOP;
1309 
1310   // Left input is ZERO ==&gt; the result is ZERO.
1311   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1312   // Shift by zero does nothing
1313   if( t2 == TypeInt::ZERO ) return t1;
1314 
1315   // Either input is BOTTOM ==&gt; the result is BOTTOM
1316   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1317     return TypeLong::LONG;
1318 
1319   if (t2 == TypeInt::INT)
1320     return TypeLong::LONG;
1321 
1322   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
1323   const TypeInt  *r2 = t2-&gt;is_int (); // Handy access
1324 
1325   if (r2-&gt;is_con()) {
1326     uint shift = r2-&gt;get_con();
1327     shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
1328     // Shift by a multiple of 64 does nothing:
1329     if (shift == 0)  return t1;
1330     // Calculate reasonably aggressive bounds for the result.
1331     jlong lo = (julong)r1-&gt;_lo &gt;&gt; (juint)shift;
1332     jlong hi = (julong)r1-&gt;_hi &gt;&gt; (juint)shift;
1333     if (r1-&gt;_hi &gt;= 0 &amp;&amp; r1-&gt;_lo &lt; 0) {
1334       // If the type has both negative and positive values,
1335       // there are two separate sub-domains to worry about:
1336       // The positive half and the negative half.
1337       jlong neg_lo = lo;
1338       jlong neg_hi = (julong)-1 &gt;&gt; (juint)shift;
1339       jlong pos_lo = (julong) 0 &gt;&gt; (juint)shift;
1340       jlong pos_hi = hi;
1341       //lo = MIN2(neg_lo, pos_lo);  // == 0
1342       lo = neg_lo &lt; pos_lo ? neg_lo : pos_lo;
1343       //hi = MAX2(neg_hi, pos_hi);  // == -1 &gt;&gt;&gt; shift;
1344       hi = neg_hi &gt; pos_hi ? neg_hi : pos_hi;
1345     }
1346     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1347     const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1348     #ifdef ASSERT
1349     // Make sure we get the sign-capture idiom correct.
1350     if (shift == BitsPerJavaLong - 1) {
1351       if (r1-&gt;_lo &gt;= 0) assert(tl == TypeLong::ZERO, &quot;&gt;&gt;&gt;63 of + is 0&quot;);
1352       if (r1-&gt;_hi &lt; 0)  assert(tl == TypeLong::ONE,  &quot;&gt;&gt;&gt;63 of - is +1&quot;);
1353     }
1354     #endif
1355     return tl;
1356   }
1357 
1358   return TypeLong::LONG;                // Give up
1359 }
1360 
1361 //=============================================================================
1362 //------------------------------Value------------------------------------------
1363 const Type* FmaDNode::Value(PhaseGVN* phase) const {
1364   const Type *t1 = phase-&gt;type(in(1));
1365   if (t1 == Type::TOP) return Type::TOP;
1366   if (t1-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1367   const Type *t2 = phase-&gt;type(in(2));
1368   if (t2 == Type::TOP) return Type::TOP;
1369   if (t2-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1370   const Type *t3 = phase-&gt;type(in(3));
1371   if (t3 == Type::TOP) return Type::TOP;
1372   if (t3-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1373 #ifndef __STDC_IEC_559__
1374   return Type::DOUBLE;
1375 #else
1376   double d1 = t1-&gt;getd();
1377   double d2 = t2-&gt;getd();
1378   double d3 = t3-&gt;getd();
1379   return TypeD::make(fma(d1, d2, d3));
1380 #endif
1381 }
1382 
1383 //=============================================================================
1384 //------------------------------Value------------------------------------------
1385 const Type* FmaFNode::Value(PhaseGVN* phase) const {
1386   const Type *t1 = phase-&gt;type(in(1));
1387   if (t1 == Type::TOP) return Type::TOP;
1388   if (t1-&gt;base() != Type::FloatCon) return Type::FLOAT;
1389   const Type *t2 = phase-&gt;type(in(2));
1390   if (t2 == Type::TOP) return Type::TOP;
1391   if (t2-&gt;base() != Type::FloatCon) return Type::FLOAT;
1392   const Type *t3 = phase-&gt;type(in(3));
1393   if (t3 == Type::TOP) return Type::TOP;
1394   if (t3-&gt;base() != Type::FloatCon) return Type::FLOAT;
1395 #ifndef __STDC_IEC_559__
1396   return Type::FLOAT;
1397 #else
1398   float f1 = t1-&gt;getf();
1399   float f2 = t2-&gt;getf();
1400   float f3 = t3-&gt;getf();
1401   return TypeF::make(fma(f1, f2, f3));
1402 #endif
1403 }
1404 
1405 //=============================================================================
1406 //------------------------------hash-------------------------------------------
1407 // Hash function for MulAddS2INode.  Operation is commutative with commutative pairs.
1408 // The hash function must return the same value when edge swapping is performed.
1409 uint MulAddS2INode::hash() const {
1410   return (uintptr_t)in(1) + (uintptr_t)in(2) + (uintptr_t)in(3) + (uintptr_t)in(4) + Opcode();
1411 }
<a name="3" id="anc3"></a><span class="line-removed">1412 </span>
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
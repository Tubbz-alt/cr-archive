<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/superword.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;compiler/compileLog.hpp&quot;
  26 #include &quot;libadt/vectset.hpp&quot;
  27 #include &quot;memory/allocation.inline.hpp&quot;
  28 #include &quot;memory/resourceArea.hpp&quot;
  29 #include &quot;opto/addnode.hpp&quot;
  30 #include &quot;opto/callnode.hpp&quot;
  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/convertnode.hpp&quot;
  33 #include &quot;opto/divnode.hpp&quot;
  34 #include &quot;opto/matcher.hpp&quot;
  35 #include &quot;opto/memnode.hpp&quot;
  36 #include &quot;opto/mulnode.hpp&quot;
  37 #include &quot;opto/opcodes.hpp&quot;
  38 #include &quot;opto/opaquenode.hpp&quot;
  39 #include &quot;opto/superword.hpp&quot;
  40 #include &quot;opto/vectornode.hpp&quot;
  41 #include &quot;opto/movenode.hpp&quot;
<a name="1" id="anc1"></a>
  42 
  43 //
  44 //                  S U P E R W O R D   T R A N S F O R M
  45 //=============================================================================
  46 
  47 //------------------------------SuperWord---------------------------
  48 SuperWord::SuperWord(PhaseIdealLoop* phase) :
  49   _phase(phase),
  50   _arena(phase-&gt;C-&gt;comp_arena()),
  51   _igvn(phase-&gt;_igvn),
  52   _packset(arena(), 8,  0, NULL),         // packs for the current block
  53   _bb_idx(arena(), (int)(1.10 * phase-&gt;C-&gt;unique()), 0, 0), // node idx to index in bb
  54   _block(arena(), 8,  0, NULL),           // nodes in current block
  55   _post_block(arena(), 8, 0, NULL),       // nodes common to current block which are marked as post loop vectorizable
  56   _data_entry(arena(), 8,  0, NULL),      // nodes with all inputs from outside
  57   _mem_slice_head(arena(), 8,  0, NULL),  // memory slice heads
  58   _mem_slice_tail(arena(), 8,  0, NULL),  // memory slice tails
  59   _node_info(arena(), 8,  0, SWNodeInfo::initial), // info needed per node
  60   _clone_map(phase-&gt;C-&gt;clone_map()),      // map of nodes created in cloning
  61   _cmovev_kit(_arena, this),              // map to facilitate CMoveV creation
  62   _align_to_ref(NULL),                    // memory reference to align vectors to
  63   _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial), // runtime disambiguated pointer pairs
  64   _dg(_arena),                            // dependence graph
  65   _visited(arena()),                      // visited node set
  66   _post_visited(arena()),                 // post visited node set
  67   _n_idx_list(arena(), 8),                // scratch list of (node,index) pairs
  68   _nlist(arena(), 8, 0, NULL),            // scratch list of nodes
  69   _stk(arena(), 8, 0, NULL),              // scratch stack of nodes
  70   _lpt(NULL),                             // loop tree node
  71   _lp(NULL),                              // LoopNode
  72   _bb(NULL),                              // basic block
  73   _iv(NULL),                              // induction var
  74   _race_possible(false),                  // cases where SDMU is true
  75   _early_return(true),                    // analysis evaluations routine
  76   _do_vector_loop(phase-&gt;C-&gt;do_vector_loop()),  // whether to do vectorization/simd style
  77   _do_reserve_copy(DoReserveCopyInSuperWord),
  78   _num_work_vecs(0),                      // amount of vector work we have
  79   _num_reductions(0),                     // amount of reduction work we have
  80   _ii_first(-1),                          // first loop generation index - only if do_vector_loop()
  81   _ii_last(-1),                           // last loop generation index - only if do_vector_loop()
  82   _ii_order(arena(), 8, 0, 0)
  83 {
  84 #ifndef PRODUCT
  85   _vector_loop_debug = 0;
  86   if (_phase-&gt;C-&gt;method() != NULL) {
  87     _vector_loop_debug = phase-&gt;C-&gt;directive()-&gt;VectorizeDebugOption;
  88   }
  89 
  90 #endif
  91 }
  92 
  93 //------------------------------transform_loop---------------------------
  94 void SuperWord::transform_loop(IdealLoopTree* lpt, bool do_optimization) {
  95   assert(UseSuperWord, &quot;should be&quot;);
  96   // Do vectors exist on this architecture?
  97   if (Matcher::vector_width_in_bytes(T_BYTE) &lt; 2) return;
  98 
  99   assert(lpt-&gt;_head-&gt;is_CountedLoop(), &quot;must be&quot;);
 100   CountedLoopNode *cl = lpt-&gt;_head-&gt;as_CountedLoop();
 101 
 102   if (!cl-&gt;is_valid_counted_loop()) return; // skip malformed counted loop
 103 
 104   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 105   if (post_loop_allowed) {
 106     if (cl-&gt;is_reduction_loop()) return; // no predication mapping
 107     Node *limit = cl-&gt;limit();
 108     if (limit-&gt;is_Con()) return; // non constant limits only
 109     // Now check the limit for expressions we do not handle
 110     if (limit-&gt;is_Add()) {
 111       Node *in2 = limit-&gt;in(2);
 112       if (in2-&gt;is_Con()) {
 113         int val = in2-&gt;get_int();
 114         // should not try to program these cases
 115         if (val &lt; 0) return;
 116       }
 117     }
 118   }
 119 
 120   // skip any loop that has not been assigned max unroll by analysis
 121   if (do_optimization) {
 122     if (SuperWordLoopUnrollAnalysis &amp;&amp; cl-&gt;slp_max_unroll() == 0) return;
 123   }
 124 
 125   // Check for no control flow in body (other than exit)
 126   Node *cl_exit = cl-&gt;loopexit();
 127   if (cl-&gt;is_main_loop() &amp;&amp; (cl_exit-&gt;in(0) != lpt-&gt;_head)) {
 128     #ifndef PRODUCT
 129       if (TraceSuperWord) {
 130         tty-&gt;print_cr(&quot;SuperWord::transform_loop: loop too complicated, cl_exit-&gt;in(0) != lpt-&gt;_head&quot;);
 131         tty-&gt;print(&quot;cl_exit %d&quot;, cl_exit-&gt;_idx); cl_exit-&gt;dump();
 132         tty-&gt;print(&quot;cl_exit-&gt;in(0) %d&quot;, cl_exit-&gt;in(0)-&gt;_idx); cl_exit-&gt;in(0)-&gt;dump();
 133         tty-&gt;print(&quot;lpt-&gt;_head %d&quot;, lpt-&gt;_head-&gt;_idx); lpt-&gt;_head-&gt;dump();
 134         lpt-&gt;dump_head();
 135       }
 136     #endif
 137     return;
 138   }
 139 
 140   // Make sure the are no extra control users of the loop backedge
 141   if (cl-&gt;back_control()-&gt;outcnt() != 1) {
 142     return;
 143   }
 144 
 145   // Skip any loops already optimized by slp
 146   if (cl-&gt;is_vectorized_loop()) return;
 147 
 148   if (cl-&gt;is_unroll_only()) return;
 149 
 150   if (cl-&gt;is_main_loop()) {
 151     // Check for pre-loop ending with CountedLoopEnd(Bool(Cmp(x,Opaque1(limit))))
 152     CountedLoopEndNode* pre_end = get_pre_loop_end(cl);
 153     if (pre_end == NULL) return;
 154     Node *pre_opaq1 = pre_end-&gt;limit();
 155     if (pre_opaq1-&gt;Opcode() != Op_Opaque1) return;
 156   }
 157 
 158   init(); // initialize data structures
 159 
 160   set_lpt(lpt);
 161   set_lp(cl);
 162 
 163   // For now, define one block which is the entire loop body
 164   set_bb(cl);
 165 
 166   if (do_optimization) {
 167     assert(_packset.length() == 0, &quot;packset must be empty&quot;);
 168     SLP_extract();
 169     if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors()) {
 170       if (cl-&gt;is_vectorized_loop() &amp;&amp; cl-&gt;is_main_loop() &amp;&amp; !cl-&gt;is_reduction_loop()) {
 171         IdealLoopTree *lpt_next = lpt-&gt;_next;
 172         CountedLoopNode *cl_next = lpt_next-&gt;_head-&gt;as_CountedLoop();
 173         _phase-&gt;has_range_checks(lpt_next);
 174         if (cl_next-&gt;is_post_loop() &amp;&amp; !cl_next-&gt;range_checks_present()) {
 175           if (!cl_next-&gt;is_vectorized_loop()) {
 176             int slp_max_unroll_factor = cl-&gt;slp_max_unroll();
 177             cl_next-&gt;set_slp_max_unroll(slp_max_unroll_factor);
 178           }
 179         }
 180       }
 181     }
 182   }
 183 }
 184 
 185 //------------------------------early unrolling analysis------------------------------
 186 void SuperWord::unrolling_analysis(int &amp;local_loop_unroll_factor) {
 187   bool is_slp = true;
 188   ResourceMark rm;
 189   size_t ignored_size = lpt()-&gt;_body.size();
 190   int *ignored_loop_nodes = NEW_RESOURCE_ARRAY(int, ignored_size);
 191   Node_Stack nstack((int)ignored_size);
 192   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 193   Node *cl_exit = cl-&gt;loopexit_or_null();
 194   int rpo_idx = _post_block.length();
 195 
 196   assert(rpo_idx == 0, &quot;post loop block is empty&quot;);
 197 
 198   // First clear the entries
 199   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 200     ignored_loop_nodes[i] = -1;
 201   }
 202 
 203   int max_vector = Matcher::max_vector_size(T_BYTE);
 204   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 205 
 206   // Process the loop, some/all of the stack entries will not be in order, ergo
 207   // need to preprocess the ignored initial state before we process the loop
 208   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 209     Node* n = lpt()-&gt;_body.at(i);
 210     if (n == cl-&gt;incr() ||
 211       n-&gt;is_reduction() ||
 212       n-&gt;is_AddP() ||
 213       n-&gt;is_Cmp() ||
 214       n-&gt;is_IfTrue() ||
 215       n-&gt;is_CountedLoop() ||
 216       (n == cl_exit)) {
 217       ignored_loop_nodes[i] = n-&gt;_idx;
 218       continue;
 219     }
 220 
 221     if (n-&gt;is_If()) {
 222       IfNode *iff = n-&gt;as_If();
 223       if (iff-&gt;_fcnt != COUNT_UNKNOWN &amp;&amp; iff-&gt;_prob != PROB_UNKNOWN) {
 224         if (lpt()-&gt;is_loop_exit(iff)) {
 225           ignored_loop_nodes[i] = n-&gt;_idx;
 226           continue;
 227         }
 228       }
 229     }
 230 
 231     if (n-&gt;is_Phi() &amp;&amp; (n-&gt;bottom_type() == Type::MEMORY)) {
 232       Node* n_tail = n-&gt;in(LoopNode::LoopBackControl);
 233       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
 234         if (!n_tail-&gt;is_Mem()) {
 235           is_slp = false;
 236           break;
 237         }
 238       }
 239     }
 240 
 241     // This must happen after check of phi/if
 242     if (n-&gt;is_Phi() || n-&gt;is_If()) {
 243       ignored_loop_nodes[i] = n-&gt;_idx;
 244       continue;
 245     }
 246 
 247     if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
 248       (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
 249       is_slp = false;
 250       break;
 251     }
 252 
 253     // Ignore nodes with non-primitive type.
 254     BasicType bt;
 255     if (n-&gt;is_Mem()) {
 256       bt = n-&gt;as_Mem()-&gt;memory_type();
 257     } else {
 258       bt = n-&gt;bottom_type()-&gt;basic_type();
 259     }
 260     if (is_java_primitive(bt) == false) {
 261       ignored_loop_nodes[i] = n-&gt;_idx;
 262       continue;
 263     }
 264 
 265     if (n-&gt;is_Mem()) {
 266       MemNode* current = n-&gt;as_Mem();
 267       Node* adr = n-&gt;in(MemNode::Address);
 268       Node* n_ctrl = _phase-&gt;get_ctrl(adr);
 269 
 270       // save a queue of post process nodes
 271       if (n_ctrl != NULL &amp;&amp; lpt()-&gt;is_member(_phase-&gt;get_loop(n_ctrl))) {
 272         // Process the memory expression
 273         int stack_idx = 0;
 274         bool have_side_effects = true;
 275         if (adr-&gt;is_AddP() == false) {
 276           nstack.push(adr, stack_idx++);
 277         } else {
 278           // Mark the components of the memory operation in nstack
 279           SWPointer p1(current, this, &amp;nstack, true);
 280           have_side_effects = p1.node_stack()-&gt;is_nonempty();
 281         }
 282 
 283         // Process the pointer stack
 284         while (have_side_effects) {
 285           Node* pointer_node = nstack.node();
 286           for (uint j = 0; j &lt; lpt()-&gt;_body.size(); j++) {
 287             Node* cur_node = lpt()-&gt;_body.at(j);
 288             if (cur_node == pointer_node) {
 289               ignored_loop_nodes[j] = cur_node-&gt;_idx;
 290               break;
 291             }
 292           }
 293           nstack.pop();
 294           have_side_effects = nstack.is_nonempty();
 295         }
 296       }
 297     }
 298   }
 299 
 300   if (is_slp) {
 301     // Now we try to find the maximum supported consistent vector which the machine
 302     // description can use
 303     bool small_basic_type = false;
 304     bool flag_small_bt = false;
 305     for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
 306       if (ignored_loop_nodes[i] != -1) continue;
 307 
 308       BasicType bt;
 309       Node* n = lpt()-&gt;_body.at(i);
 310       if (n-&gt;is_Mem()) {
 311         bt = n-&gt;as_Mem()-&gt;memory_type();
 312       } else {
 313         bt = n-&gt;bottom_type()-&gt;basic_type();
 314       }
 315 
 316       if (post_loop_allowed) {
 317         if (!small_basic_type) {
 318           switch (bt) {
 319           case T_CHAR:
 320           case T_BYTE:
 321           case T_SHORT:
 322             small_basic_type = true;
 323             break;
 324 
 325           case T_LONG:
 326             // TODO: Remove when support completed for mask context with LONG.
 327             //       Support needs to be augmented for logical qword operations, currently we map to dword
 328             //       buckets for vectors on logicals as these were legacy.
 329             small_basic_type = true;
 330             break;
 331 
 332           default:
 333             break;
 334           }
 335         }
 336       }
 337 
 338       if (is_java_primitive(bt) == false) continue;
 339 
 340          int cur_max_vector = Matcher::max_vector_size(bt);
 341 
 342       // If a max vector exists which is not larger than _local_loop_unroll_factor
 343       // stop looking, we already have the max vector to map to.
 344       if (cur_max_vector &lt; local_loop_unroll_factor) {
 345         is_slp = false;
 346         if (TraceSuperWordLoopUnrollAnalysis) {
 347           tty-&gt;print_cr(&quot;slp analysis fails: unroll limit greater than max vector\n&quot;);
 348         }
 349         break;
 350       }
 351 
 352       // Map the maximal common vector
 353       if (VectorNode::implemented(n-&gt;Opcode(), cur_max_vector, bt)) {
 354         if (cur_max_vector &lt; max_vector &amp;&amp; !flag_small_bt) {
 355           max_vector = cur_max_vector;
 356         } else if (cur_max_vector &gt; max_vector &amp;&amp; UseSubwordForMaxVector) {
 357           // Analyse subword in the loop to set maximum vector size to take advantage of full vector width for subword types.
 358           // Here we analyze if narrowing is likely to happen and if it is we set vector size more aggressively.
 359           // We check for possibility of narrowing by looking through chain operations using subword types.
 360           if (is_subword_type(bt)) {
 361             uint start, end;
 362             VectorNode::vector_operands(n, &amp;start, &amp;end);
 363 
 364             for (uint j = start; j &lt; end; j++) {
 365               Node* in = n-&gt;in(j);
 366               // Don&#39;t propagate through a memory
 367               if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; in-&gt;bottom_type()-&gt;basic_type() == T_INT) {
 368                 bool same_type = true;
 369                 for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 370                   Node *use = in-&gt;fast_out(k);
 371                   if (!in_bb(use) &amp;&amp; use-&gt;bottom_type()-&gt;basic_type() != bt) {
 372                     same_type = false;
 373                     break;
 374                   }
 375                 }
 376                 if (same_type) {
 377                   max_vector = cur_max_vector;
 378                   flag_small_bt = true;
 379                   cl-&gt;mark_subword_loop();
 380                 }
 381               }
 382             }
 383           }
 384         }
 385         // We only process post loops on predicated targets where we want to
 386         // mask map the loop to a single iteration
 387         if (post_loop_allowed) {
 388           _post_block.at_put_grow(rpo_idx++, n);
 389         }
 390       }
 391     }
 392     if (is_slp) {
 393       local_loop_unroll_factor = max_vector;
 394       cl-&gt;mark_passed_slp();
 395     }
 396     cl-&gt;mark_was_slp();
 397     if (cl-&gt;is_main_loop()) {
 398       cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 399     } else if (post_loop_allowed) {
 400       if (!small_basic_type) {
 401         // avoid replication context for small basic types in programmable masked loops
 402         cl-&gt;set_slp_max_unroll(local_loop_unroll_factor);
 403       }
 404     }
 405   }
 406 }
 407 
 408 //------------------------------SLP_extract---------------------------
 409 // Extract the superword level parallelism
 410 //
 411 // 1) A reverse post-order of nodes in the block is constructed.  By scanning
 412 //    this list from first to last, all definitions are visited before their uses.
 413 //
 414 // 2) A point-to-point dependence graph is constructed between memory references.
 415 //    This simplies the upcoming &quot;independence&quot; checker.
 416 //
 417 // 3) The maximum depth in the node graph from the beginning of the block
 418 //    to each node is computed.  This is used to prune the graph search
 419 //    in the independence checker.
 420 //
 421 // 4) For integer types, the necessary bit width is propagated backwards
 422 //    from stores to allow packed operations on byte, char, and short
 423 //    integers.  This reverses the promotion to type &quot;int&quot; that javac
 424 //    did for operations like: char c1,c2,c3;  c1 = c2 + c3.
 425 //
 426 // 5) One of the memory references is picked to be an aligned vector reference.
 427 //    The pre-loop trip count is adjusted to align this reference in the
 428 //    unrolled body.
 429 //
 430 // 6) The initial set of pack pairs is seeded with memory references.
 431 //
 432 // 7) The set of pack pairs is extended by following use-&gt;def and def-&gt;use links.
 433 //
 434 // 8) The pairs are combined into vector sized packs.
 435 //
 436 // 9) Reorder the memory slices to co-locate members of the memory packs.
 437 //
 438 // 10) Generate ideal vector nodes for the final set of packs and where necessary,
 439 //    inserting scalar promotion, vector creation from multiple scalars, and
 440 //    extraction of scalar values from vectors.
 441 //
 442 void SuperWord::SLP_extract() {
 443 
 444 #ifndef PRODUCT
 445   if (_do_vector_loop &amp;&amp; TraceSuperWord) {
 446     tty-&gt;print(&quot;SuperWord::SLP_extract\n&quot;);
 447     tty-&gt;print(&quot;input loop\n&quot;);
 448     _lpt-&gt;dump_head();
 449     _lpt-&gt;dump();
 450     for (uint i = 0; i &lt; _lpt-&gt;_body.size(); i++) {
 451       _lpt-&gt;_body.at(i)-&gt;dump();
 452     }
 453   }
 454 #endif
 455   // Ready the block
 456   if (!construct_bb()) {
 457     return; // Exit if no interesting nodes or complex graph.
 458   }
 459 
 460   // build    _dg, _disjoint_ptrs
 461   dependence_graph();
 462 
 463   // compute function depth(Node*)
 464   compute_max_depth();
 465 
 466   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
 467   bool post_loop_allowed = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
 468   if (cl-&gt;is_main_loop()) {
 469     if (_do_vector_loop) {
 470       if (mark_generations() != -1) {
 471         hoist_loads_in_graph(); // this only rebuild the graph; all basic structs need rebuild explicitly
 472 
 473         if (!construct_bb()) {
 474           return; // Exit if no interesting nodes or complex graph.
 475         }
 476         dependence_graph();
 477         compute_max_depth();
 478       }
 479 
 480 #ifndef PRODUCT
 481       if (TraceSuperWord) {
 482         tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop: graph after hoist_loads_in_graph&quot;);
 483         _lpt-&gt;dump_head();
 484         for (int j = 0; j &lt; _block.length(); j++) {
 485           Node* n = _block.at(j);
 486           int d = depth(n);
 487           for (int i = 0; i &lt; d; i++) tty-&gt;print(&quot;%s&quot;, &quot;  &quot;);
 488           tty-&gt;print(&quot;%d :&quot;, d);
 489           n-&gt;dump();
 490         }
 491       }
 492 #endif
 493     }
 494 
 495     compute_vector_element_type();
 496 
 497     // Attempt vectorization
 498 
 499     find_adjacent_refs();
 500 
 501     extend_packlist();
 502 
 503     if (_do_vector_loop) {
 504       if (_packset.length() == 0) {
 505         if (TraceSuperWord) {
 506           tty-&gt;print_cr(&quot;\nSuperWord::_do_vector_loop DFA could not build packset, now trying to build anyway&quot;);
 507         }
 508         pack_parallel();
 509       }
 510     }
 511 
 512     combine_packs();
 513 
 514     construct_my_pack_map();
 515     if (UseVectorCmov) {
 516       merge_packs_to_cmovd();
 517     }
 518 
 519     filter_packs();
 520 
 521     schedule();
 522   } else if (post_loop_allowed) {
 523     int saved_mapped_unroll_factor = cl-&gt;slp_max_unroll();
 524     if (saved_mapped_unroll_factor) {
 525       int vector_mapped_unroll_factor = saved_mapped_unroll_factor;
 526 
 527       // now reset the slp_unroll_factor so that we can check the analysis mapped
 528       // what the vector loop was mapped to
 529       cl-&gt;set_slp_max_unroll(0);
 530 
 531       // do the analysis on the post loop
 532       unrolling_analysis(vector_mapped_unroll_factor);
 533 
 534       // if our analyzed loop is a canonical fit, start processing it
 535       if (vector_mapped_unroll_factor == saved_mapped_unroll_factor) {
 536         // now add the vector nodes to packsets
 537         for (int i = 0; i &lt; _post_block.length(); i++) {
 538           Node* n = _post_block.at(i);
 539           Node_List* singleton = new Node_List();
 540           singleton-&gt;push(n);
 541           _packset.append(singleton);
 542           set_my_pack(n, singleton);
 543         }
 544 
 545         // map base types for vector usage
 546         compute_vector_element_type();
 547       } else {
 548         return;
 549       }
 550     } else {
 551       // for some reason we could not map the slp analysis state of the vectorized loop
 552       return;
 553     }
 554   }
 555 
 556   output();
 557 }
 558 
 559 //------------------------------find_adjacent_refs---------------------------
 560 // Find the adjacent memory references and create pack pairs for them.
 561 // This is the initial set of packs that will then be extended by
 562 // following use-&gt;def and def-&gt;use links.  The align positions are
 563 // assigned relative to the reference &quot;align_to_ref&quot;
 564 void SuperWord::find_adjacent_refs() {
 565   // Get list of memory operations
 566   Node_List memops;
 567   for (int i = 0; i &lt; _block.length(); i++) {
 568     Node* n = _block.at(i);
 569     if (n-&gt;is_Mem() &amp;&amp; !n-&gt;is_LoadStore() &amp;&amp; in_bb(n) &amp;&amp;
 570         is_java_primitive(n-&gt;as_Mem()-&gt;memory_type())) {
 571       int align = memory_alignment(n-&gt;as_Mem(), 0);
 572       if (align != bottom_align) {
 573         memops.push(n);
 574       }
 575     }
 576   }
 577 
 578   Node_List align_to_refs;
 579   int max_idx;
 580   int best_iv_adjustment = 0;
 581   MemNode* best_align_to_mem_ref = NULL;
 582 
 583   while (memops.size() != 0) {
 584     // Find a memory reference to align to.
 585     MemNode* mem_ref = find_align_to_ref(memops, max_idx);
 586     if (mem_ref == NULL) break;
 587     align_to_refs.push(mem_ref);
 588     int iv_adjustment = get_iv_adjustment(mem_ref);
 589 
 590     if (best_align_to_mem_ref == NULL) {
 591       // Set memory reference which is the best from all memory operations
 592       // to be used for alignment. The pre-loop trip count is modified to align
 593       // this reference to a vector-aligned address.
 594       best_align_to_mem_ref = mem_ref;
 595       best_iv_adjustment = iv_adjustment;
 596       NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 597     }
 598 
 599     SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 600     // Set alignment relative to &quot;align_to_ref&quot; for all related memory operations.
 601     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 602       MemNode* s = memops.at(i)-&gt;as_Mem();
 603       if (isomorphic(s, mem_ref) &amp;&amp;
 604            (!_do_vector_loop || same_origin_idx(s, mem_ref))) {
 605         SWPointer p2(s, this, NULL, false);
 606         if (p2.comparable(align_to_ref_p)) {
 607           int align = memory_alignment(s, iv_adjustment);
 608           set_alignment(s, align);
 609         }
 610       }
 611     }
 612 
 613     // Create initial pack pairs of memory operations for which
 614     // alignment is set and vectors will be aligned.
 615     bool create_pack = true;
 616     if (memory_alignment(mem_ref, best_iv_adjustment) == 0 || _do_vector_loop) {
 617       if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 618         int vw = vector_width(mem_ref);
 619         int vw_best = vector_width(best_align_to_mem_ref);
 620         if (vw &gt; vw_best) {
 621           // Do not vectorize a memory access with more elements per vector
 622           // if unaligned memory access is not allowed because number of
 623           // iterations in pre-loop will be not enough to align it.
 624           create_pack = false;
 625         } else {
 626           SWPointer p2(best_align_to_mem_ref, this, NULL, false);
 627           if (align_to_ref_p.invar() != p2.invar()) {
 628             // Do not vectorize memory accesses with different invariants
 629             // if unaligned memory accesses are not allowed.
 630             create_pack = false;
 631           }
 632         }
 633       }
 634     } else {
 635       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 636         // Can&#39;t allow vectorization of unaligned memory accesses with the
 637         // same type since it could be overlapped accesses to the same array.
 638         create_pack = false;
 639       } else {
 640         // Allow independent (different type) unaligned memory operations
 641         // if HW supports them.
 642         if (!Matcher::misaligned_vectors_ok() || AlignVector) {
 643           create_pack = false;
 644         } else {
 645           // Check if packs of the same memory type but
 646           // with a different alignment were created before.
 647           for (uint i = 0; i &lt; align_to_refs.size(); i++) {
 648             MemNode* mr = align_to_refs.at(i)-&gt;as_Mem();
 649             if (mr == mem_ref) {
 650               // Skip when we are looking at same memory operation.
 651               continue;
 652             }
 653             if (same_velt_type(mr, mem_ref) &amp;&amp;
 654                 memory_alignment(mr, iv_adjustment) != 0)
 655               create_pack = false;
 656           }
 657         }
 658       }
 659     }
 660     if (create_pack) {
 661       for (uint i = 0; i &lt; memops.size(); i++) {
 662         Node* s1 = memops.at(i);
 663         int align = alignment(s1);
 664         if (align == top_align) continue;
 665         for (uint j = 0; j &lt; memops.size(); j++) {
 666           Node* s2 = memops.at(j);
 667           if (alignment(s2) == top_align) continue;
 668           if (s1 != s2 &amp;&amp; are_adjacent_refs(s1, s2)) {
 669             if (stmts_can_pack(s1, s2, align)) {
 670               Node_List* pair = new Node_List();
 671               pair-&gt;push(s1);
 672               pair-&gt;push(s2);
 673               if (!_do_vector_loop || same_origin_idx(s1, s2)) {
 674                 _packset.append(pair);
 675               }
 676             }
 677           }
 678         }
 679       }
 680     } else { // Don&#39;t create unaligned pack
 681       // First, remove remaining memory ops of the same type from the list.
 682       for (int i = memops.size() - 1; i &gt;= 0; i--) {
 683         MemNode* s = memops.at(i)-&gt;as_Mem();
 684         if (same_velt_type(s, mem_ref)) {
 685           memops.remove(i);
 686         }
 687       }
 688 
 689       // Second, remove already constructed packs of the same type.
 690       for (int i = _packset.length() - 1; i &gt;= 0; i--) {
 691         Node_List* p = _packset.at(i);
 692         MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 693         if (same_velt_type(s, mem_ref)) {
 694           remove_pack_at(i);
 695         }
 696       }
 697 
 698       // If needed find the best memory reference for loop alignment again.
 699       if (same_velt_type(mem_ref, best_align_to_mem_ref)) {
 700         // Put memory ops from remaining packs back on memops list for
 701         // the best alignment search.
 702         uint orig_msize = memops.size();
 703         for (int i = 0; i &lt; _packset.length(); i++) {
 704           Node_List* p = _packset.at(i);
 705           MemNode* s = p-&gt;at(0)-&gt;as_Mem();
 706           assert(!same_velt_type(s, mem_ref), &quot;sanity&quot;);
 707           memops.push(s);
 708         }
 709         best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 710         if (best_align_to_mem_ref == NULL) {
 711           if (TraceSuperWord) {
 712             tty-&gt;print_cr(&quot;SuperWord::find_adjacent_refs(): best_align_to_mem_ref == NULL&quot;);
 713           }
 714           // best_align_to_mem_ref will be used for adjusting the pre-loop limit in
 715           // SuperWord::align_initial_loop_index. Find one with the biggest vector size,
 716           // smallest data size and smallest iv offset from memory ops from remaining packs.
 717           if (_packset.length() &gt; 0) {
 718             if (orig_msize == 0) {
 719               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 720             } else {
 721               for (uint i = 0; i &lt; orig_msize; i++) {
 722                 memops.remove(0);
 723               }
 724               best_align_to_mem_ref = find_align_to_ref(memops, max_idx);
 725               assert(best_align_to_mem_ref == NULL, &quot;sanity&quot;);
 726               best_align_to_mem_ref = memops.at(max_idx)-&gt;as_Mem();
 727             }
 728             assert(best_align_to_mem_ref != NULL, &quot;sanity&quot;);
 729           }
 730           break;
 731         }
 732         best_iv_adjustment = get_iv_adjustment(best_align_to_mem_ref);
 733         NOT_PRODUCT(find_adjacent_refs_trace_1(best_align_to_mem_ref, best_iv_adjustment);)
 734         // Restore list.
 735         while (memops.size() &gt; orig_msize)
 736           (void)memops.pop();
 737       }
 738     } // unaligned memory accesses
 739 
 740     // Remove used mem nodes.
 741     for (int i = memops.size() - 1; i &gt;= 0; i--) {
 742       MemNode* m = memops.at(i)-&gt;as_Mem();
 743       if (alignment(m) != top_align) {
 744         memops.remove(i);
 745       }
 746     }
 747 
 748   } // while (memops.size() != 0
 749   set_align_to_ref(best_align_to_mem_ref);
 750 
 751   if (TraceSuperWord) {
 752     tty-&gt;print_cr(&quot;\nAfter find_adjacent_refs&quot;);
 753     print_packset();
 754   }
 755 }
 756 
 757 #ifndef PRODUCT
 758 void SuperWord::find_adjacent_refs_trace_1(Node* best_align_to_mem_ref, int best_iv_adjustment) {
 759   if (is_trace_adjacent()) {
 760     tty-&gt;print(&quot;SuperWord::find_adjacent_refs best_align_to_mem_ref = %d, best_iv_adjustment = %d&quot;,
 761        best_align_to_mem_ref-&gt;_idx, best_iv_adjustment);
 762        best_align_to_mem_ref-&gt;dump();
 763   }
 764 }
 765 #endif
 766 
 767 //------------------------------find_align_to_ref---------------------------
 768 // Find a memory reference to align the loop induction variable to.
 769 // Looks first at stores then at loads, looking for a memory reference
 770 // with the largest number of references similar to it.
 771 MemNode* SuperWord::find_align_to_ref(Node_List &amp;memops, int &amp;idx) {
 772   GrowableArray&lt;int&gt; cmp_ct(arena(), memops.size(), memops.size(), 0);
 773 
 774   // Count number of comparable memory ops
 775   for (uint i = 0; i &lt; memops.size(); i++) {
 776     MemNode* s1 = memops.at(i)-&gt;as_Mem();
 777     SWPointer p1(s1, this, NULL, false);
 778     // Discard if pre loop can&#39;t align this reference
 779     if (!ref_is_alignable(p1)) {
 780       *cmp_ct.adr_at(i) = 0;
 781       continue;
 782     }
 783     for (uint j = i+1; j &lt; memops.size(); j++) {
 784       MemNode* s2 = memops.at(j)-&gt;as_Mem();
 785       if (isomorphic(s1, s2)) {
 786         SWPointer p2(s2, this, NULL, false);
 787         if (p1.comparable(p2)) {
 788           (*cmp_ct.adr_at(i))++;
 789           (*cmp_ct.adr_at(j))++;
 790         }
 791       }
 792     }
 793   }
 794 
 795   // Find Store (or Load) with the greatest number of &quot;comparable&quot; references,
 796   // biggest vector size, smallest data size and smallest iv offset.
 797   int max_ct        = 0;
 798   int max_vw        = 0;
 799   int max_idx       = -1;
 800   int min_size      = max_jint;
 801   int min_iv_offset = max_jint;
 802   for (uint j = 0; j &lt; memops.size(); j++) {
 803     MemNode* s = memops.at(j)-&gt;as_Mem();
 804     if (s-&gt;is_Store()) {
 805       int vw = vector_width_in_bytes(s);
 806       assert(vw &gt; 1, &quot;sanity&quot;);
 807       SWPointer p(s, this, NULL, false);
 808       if ( cmp_ct.at(j) &gt;  max_ct ||
 809           (cmp_ct.at(j) == max_ct &amp;&amp;
 810             ( vw &gt;  max_vw ||
 811              (vw == max_vw &amp;&amp;
 812               ( data_size(s) &lt;  min_size ||
 813                (data_size(s) == min_size &amp;&amp;
 814                 p.offset_in_bytes() &lt; min_iv_offset)))))) {
 815         max_ct = cmp_ct.at(j);
 816         max_vw = vw;
 817         max_idx = j;
 818         min_size = data_size(s);
 819         min_iv_offset = p.offset_in_bytes();
 820       }
 821     }
 822   }
 823   // If no stores, look at loads
 824   if (max_ct == 0) {
 825     for (uint j = 0; j &lt; memops.size(); j++) {
 826       MemNode* s = memops.at(j)-&gt;as_Mem();
 827       if (s-&gt;is_Load()) {
 828         int vw = vector_width_in_bytes(s);
 829         assert(vw &gt; 1, &quot;sanity&quot;);
 830         SWPointer p(s, this, NULL, false);
 831         if ( cmp_ct.at(j) &gt;  max_ct ||
 832             (cmp_ct.at(j) == max_ct &amp;&amp;
 833               ( vw &gt;  max_vw ||
 834                (vw == max_vw &amp;&amp;
 835                 ( data_size(s) &lt;  min_size ||
 836                  (data_size(s) == min_size &amp;&amp;
 837                   p.offset_in_bytes() &lt; min_iv_offset)))))) {
 838           max_ct = cmp_ct.at(j);
 839           max_vw = vw;
 840           max_idx = j;
 841           min_size = data_size(s);
 842           min_iv_offset = p.offset_in_bytes();
 843         }
 844       }
 845     }
 846   }
 847 
 848 #ifdef ASSERT
 849   if (TraceSuperWord &amp;&amp; Verbose) {
 850     tty-&gt;print_cr(&quot;\nVector memops after find_align_to_ref&quot;);
 851     for (uint i = 0; i &lt; memops.size(); i++) {
 852       MemNode* s = memops.at(i)-&gt;as_Mem();
 853       s-&gt;dump();
 854     }
 855   }
 856 #endif
 857 
 858   idx = max_idx;
 859   if (max_ct &gt; 0) {
 860 #ifdef ASSERT
 861     if (TraceSuperWord) {
 862       tty-&gt;print(&quot;\nVector align to node: &quot;);
 863       memops.at(max_idx)-&gt;as_Mem()-&gt;dump();
 864     }
 865 #endif
 866     return memops.at(max_idx)-&gt;as_Mem();
 867   }
 868   return NULL;
 869 }
 870 
 871 //------------------span_works_for_memory_size-----------------------------
 872 static bool span_works_for_memory_size(MemNode* mem, int span, int mem_size, int offset) {
 873   bool span_matches_memory = false;
 874   if ((mem_size == type2aelembytes(T_BYTE) || mem_size == type2aelembytes(T_SHORT))
 875     &amp;&amp; ABS(span) == type2aelembytes(T_INT)) {
 876     // There is a mismatch on span size compared to memory.
 877     for (DUIterator_Fast jmax, j = mem-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 878       Node* use = mem-&gt;fast_out(j);
 879       if (!VectorNode::is_type_transition_to_int(use)) {
 880         return false;
 881       }
 882     }
 883     // If all uses transition to integer, it means that we can successfully align even on mismatch.
 884     return true;
 885   }
 886   else {
 887     span_matches_memory = ABS(span) == mem_size;
 888   }
 889   return span_matches_memory &amp;&amp; (ABS(offset) % mem_size) == 0;
 890 }
 891 
 892 //------------------------------ref_is_alignable---------------------------
 893 // Can the preloop align the reference to position zero in the vector?
 894 bool SuperWord::ref_is_alignable(SWPointer&amp; p) {
 895   if (!p.has_iv()) {
 896     return true;   // no induction variable
 897   }
 898   CountedLoopEndNode* pre_end = get_pre_loop_end(lp()-&gt;as_CountedLoop());
 899   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
 900   assert(pre_end-&gt;stride_is_con(), &quot;pre loop stride is constant&quot;);
 901   int preloop_stride = pre_end-&gt;stride_con();
 902 
 903   int span = preloop_stride * p.scale_in_bytes();
 904   int mem_size = p.memory_size();
 905   int offset   = p.offset_in_bytes();
 906   // Stride one accesses are alignable if offset is aligned to memory operation size.
 907   // Offset can be unaligned when UseUnalignedAccesses is used.
 908   if (span_works_for_memory_size(p.mem(), span, mem_size, offset)) {
 909     return true;
 910   }
 911   // If the initial offset from start of the object is computable,
 912   // check if the pre-loop can align the final offset accordingly.
 913   //
 914   // In other words: Can we find an i such that the offset
 915   // after i pre-loop iterations is aligned to vw?
 916   //   (init_offset + pre_loop) % vw == 0              (1)
 917   // where
 918   //   pre_loop = i * span
 919   // is the number of bytes added to the offset by i pre-loop iterations.
 920   //
 921   // For this to hold we need pre_loop to increase init_offset by
 922   //   pre_loop = vw - (init_offset % vw)
 923   //
 924   // This is only possible if pre_loop is divisible by span because each
 925   // pre-loop iteration increases the initial offset by &#39;span&#39; bytes:
 926   //   (vw - (init_offset % vw)) % span == 0
 927   //
 928   int vw = vector_width_in_bytes(p.mem());
 929   assert(vw &gt; 1, &quot;sanity&quot;);
 930   Node* init_nd = pre_end-&gt;init_trip();
 931   if (init_nd-&gt;is_Con() &amp;&amp; p.invar() == NULL) {
 932     int init = init_nd-&gt;bottom_type()-&gt;is_int()-&gt;get_con();
 933     int init_offset = init * p.scale_in_bytes() + offset;
 934     if (init_offset &lt; 0) { // negative offset from object start?
 935       return false;        // may happen in dead loop
 936     }
 937     if (vw % span == 0) {
 938       // If vm is a multiple of span, we use formula (1).
 939       if (span &gt; 0) {
 940         return (vw - (init_offset % vw)) % span == 0;
 941       } else {
 942         assert(span &lt; 0, &quot;nonzero stride * scale&quot;);
 943         return (init_offset % vw) % -span == 0;
 944       }
 945     } else if (span % vw == 0) {
 946       // If span is a multiple of vw, we can simplify formula (1) to:
 947       //   (init_offset + i * span) % vw == 0
 948       //     =&gt;
 949       //   (init_offset % vw) + ((i * span) % vw) == 0
 950       //     =&gt;
 951       //   init_offset % vw == 0
 952       //
 953       // Because we add a multiple of vw to the initial offset, the final
 954       // offset is a multiple of vw if and only if init_offset is a multiple.
 955       //
 956       return (init_offset % vw) == 0;
 957     }
 958   }
 959   return false;
 960 }
 961 //---------------------------get_vw_bytes_special------------------------
 962 int SuperWord::get_vw_bytes_special(MemNode* s) {
 963   // Get the vector width in bytes.
 964   int vw = vector_width_in_bytes(s);
 965 
 966   // Check for special case where there is an MulAddS2I usage where short vectors are going to need combined.
 967   BasicType btype = velt_basic_type(s);
 968   if (type2aelembytes(btype) == 2) {
 969     bool should_combine_adjacent = true;
 970     for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); i &lt; imax; i++) {
 971       Node* user = s-&gt;fast_out(i);
 972       if (!VectorNode::is_muladds2i(user)) {
 973         should_combine_adjacent = false;
 974       }
 975     }
 976     if (should_combine_adjacent) {
 977       vw = MIN2(Matcher::max_vector_size(btype)*type2aelembytes(btype), vw * 2);
 978     }
 979   }
 980 
 981   return vw;
 982 }
 983 
 984 //---------------------------get_iv_adjustment---------------------------
 985 // Calculate loop&#39;s iv adjustment for this memory ops.
 986 int SuperWord::get_iv_adjustment(MemNode* mem_ref) {
 987   SWPointer align_to_ref_p(mem_ref, this, NULL, false);
 988   int offset = align_to_ref_p.offset_in_bytes();
 989   int scale  = align_to_ref_p.scale_in_bytes();
 990   int elt_size = align_to_ref_p.memory_size();
 991   int vw       = get_vw_bytes_special(mem_ref);
 992   assert(vw &gt; 1, &quot;sanity&quot;);
 993   int iv_adjustment;
 994   if (scale != 0) {
 995     int stride_sign = (scale * iv_stride()) &gt; 0 ? 1 : -1;
 996     // At least one iteration is executed in pre-loop by default. As result
 997     // several iterations are needed to align memory operations in main-loop even
 998     // if offset is 0.
 999     int iv_adjustment_in_bytes = (stride_sign * vw - (offset % vw));
1000     assert(((ABS(iv_adjustment_in_bytes) % elt_size) == 0),
1001            &quot;(%d) should be divisible by (%d)&quot;, iv_adjustment_in_bytes, elt_size);
1002     iv_adjustment = iv_adjustment_in_bytes/elt_size;
1003   } else {
1004     // This memory op is not dependent on iv (scale == 0)
1005     iv_adjustment = 0;
1006   }
1007 
1008 #ifndef PRODUCT
1009   if (TraceSuperWord) {
1010     tty-&gt;print(&quot;SuperWord::get_iv_adjustment: n = %d, noffset = %d iv_adjust = %d elt_size = %d scale = %d iv_stride = %d vect_size %d: &quot;,
1011       mem_ref-&gt;_idx, offset, iv_adjustment, elt_size, scale, iv_stride(), vw);
1012     mem_ref-&gt;dump();
1013   }
1014 #endif
1015   return iv_adjustment;
1016 }
1017 
1018 //---------------------------dependence_graph---------------------------
1019 // Construct dependency graph.
1020 // Add dependence edges to load/store nodes for memory dependence
1021 //    A.out()-&gt;DependNode.in(1) and DependNode.out()-&gt;B.prec(x)
1022 void SuperWord::dependence_graph() {
1023   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
1024   // First, assign a dependence node to each memory node
1025   for (int i = 0; i &lt; _block.length(); i++ ) {
1026     Node *n = _block.at(i);
1027     if (n-&gt;is_Mem() || (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
1028       _dg.make_node(n);
1029     }
1030   }
1031 
1032   // For each memory slice, create the dependences
1033   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
1034     Node* n      = _mem_slice_head.at(i);
1035     Node* n_tail = _mem_slice_tail.at(i);
1036 
1037     // Get slice in predecessor order (last is first)
1038     if (cl-&gt;is_main_loop()) {
1039       mem_slice_preds(n_tail, n, _nlist);
1040     }
1041 
1042 #ifndef PRODUCT
1043     if(TraceSuperWord &amp;&amp; Verbose) {
1044       tty-&gt;print_cr(&quot;SuperWord::dependence_graph: built a new mem slice&quot;);
1045       for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1046         _nlist.at(j)-&gt;dump();
1047       }
1048     }
1049 #endif
1050     // Make the slice dependent on the root
1051     DepMem* slice = _dg.dep(n);
1052     _dg.make_edge(_dg.root(), slice);
1053 
1054     // Create a sink for the slice
1055     DepMem* slice_sink = _dg.make_node(NULL);
1056     _dg.make_edge(slice_sink, _dg.tail());
1057 
1058     // Now visit each pair of memory ops, creating the edges
1059     for (int j = _nlist.length() - 1; j &gt;= 0 ; j--) {
1060       Node* s1 = _nlist.at(j);
1061 
1062       // If no dependency yet, use slice
1063       if (_dg.dep(s1)-&gt;in_cnt() == 0) {
1064         _dg.make_edge(slice, s1);
1065       }
1066       SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1067       bool sink_dependent = true;
1068       for (int k = j - 1; k &gt;= 0; k--) {
1069         Node* s2 = _nlist.at(k);
1070         if (s1-&gt;is_Load() &amp;&amp; s2-&gt;is_Load())
1071           continue;
1072         SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1073 
1074         int cmp = p1.cmp(p2);
1075         if (SuperWordRTDepCheck &amp;&amp;
1076             p1.base() != p2.base() &amp;&amp; p1.valid() &amp;&amp; p2.valid()) {
1077           // Create a runtime check to disambiguate
1078           OrderedPair pp(p1.base(), p2.base());
1079           _disjoint_ptrs.append_if_missing(pp);
1080         } else if (!SWPointer::not_equal(cmp)) {
1081           // Possibly same address
1082           _dg.make_edge(s1, s2);
1083           sink_dependent = false;
1084         }
1085       }
1086       if (sink_dependent) {
1087         _dg.make_edge(s1, slice_sink);
1088       }
1089     }
1090 
1091     if (TraceSuperWord) {
1092       tty-&gt;print_cr(&quot;\nDependence graph for slice: %d&quot;, n-&gt;_idx);
1093       for (int q = 0; q &lt; _nlist.length(); q++) {
1094         _dg.print(_nlist.at(q));
1095       }
1096       tty-&gt;cr();
1097     }
1098 
1099     _nlist.clear();
1100   }
1101 
1102   if (TraceSuperWord) {
1103     tty-&gt;print_cr(&quot;\ndisjoint_ptrs: %s&quot;, _disjoint_ptrs.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
1104     for (int r = 0; r &lt; _disjoint_ptrs.length(); r++) {
1105       _disjoint_ptrs.at(r).print();
1106       tty-&gt;cr();
1107     }
1108     tty-&gt;cr();
1109   }
1110 
1111 }
1112 
1113 //---------------------------mem_slice_preds---------------------------
1114 // Return a memory slice (node list) in predecessor order starting at &quot;start&quot;
1115 void SuperWord::mem_slice_preds(Node* start, Node* stop, GrowableArray&lt;Node*&gt; &amp;preds) {
1116   assert(preds.length() == 0, &quot;start empty&quot;);
1117   Node* n = start;
1118   Node* prev = NULL;
1119   while (true) {
1120     NOT_PRODUCT( if(is_trace_mem_slice()) tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: n %d&quot;, n-&gt;_idx);)
1121     assert(in_bb(n), &quot;must be in block&quot;);
1122     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
1123       Node* out = n-&gt;fast_out(i);
1124       if (out-&gt;is_Load()) {
1125         if (in_bb(out)) {
1126           preds.push(out);
1127           if (TraceSuperWord &amp;&amp; Verbose) {
1128             tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, out-&gt;_idx);
1129           }
1130         }
1131       } else {
1132         // FIXME
1133         if (out-&gt;is_MergeMem() &amp;&amp; !in_bb(out)) {
1134           // Either unrolling is causing a memory edge not to disappear,
1135           // or need to run igvn.optimize() again before SLP
1136         } else if (out-&gt;is_Phi() &amp;&amp; out-&gt;bottom_type() == Type::MEMORY &amp;&amp; !in_bb(out)) {
1137           // Ditto.  Not sure what else to check further.
1138         } else if (out-&gt;Opcode() == Op_StoreCM &amp;&amp; out-&gt;in(MemNode::OopStore) == n) {
1139           // StoreCM has an input edge used as a precedence edge.
1140           // Maybe an issue when oop stores are vectorized.
1141         } else {
1142           assert(out == prev || prev == NULL, &quot;no branches off of store slice&quot;);
1143         }
1144       }//else
1145     }//for
1146     if (n == stop) break;
1147     preds.push(n);
1148     if (TraceSuperWord &amp;&amp; Verbose) {
1149       tty-&gt;print_cr(&quot;SuperWord::mem_slice_preds: added pred(%d)&quot;, n-&gt;_idx);
1150     }
1151     prev = n;
1152     assert(n-&gt;is_Mem(), &quot;unexpected node %s&quot;, n-&gt;Name());
1153     n = n-&gt;in(MemNode::Memory);
1154   }
1155 }
1156 
1157 //------------------------------stmts_can_pack---------------------------
1158 // Can s1 and s2 be in a pack with s1 immediately preceding s2 and
1159 // s1 aligned at &quot;align&quot;
1160 bool SuperWord::stmts_can_pack(Node* s1, Node* s2, int align) {
1161 
1162   // Do not use superword for non-primitives
1163   BasicType bt1 = velt_basic_type(s1);
1164   BasicType bt2 = velt_basic_type(s2);
1165   if(!is_java_primitive(bt1) || !is_java_primitive(bt2))
1166     return false;
1167   if (Matcher::max_vector_size(bt1) &lt; 2) {
1168     return false; // No vectors for this type
1169   }
1170 
1171   if (isomorphic(s1, s2)) {
1172     if ((independent(s1, s2) &amp;&amp; have_similar_inputs(s1, s2)) || reduction(s1, s2)) {
1173       if (!exists_at(s1, 0) &amp;&amp; !exists_at(s2, 1)) {
1174         if (!s1-&gt;is_Mem() || are_adjacent_refs(s1, s2)) {
1175           int s1_align = alignment(s1);
1176           int s2_align = alignment(s2);
1177           if (s1_align == top_align || s1_align == align) {
1178             if (s2_align == top_align || s2_align == align + data_size(s1)) {
1179               return true;
1180             }
1181           }
1182         }
1183       }
1184     }
1185   }
1186   return false;
1187 }
1188 
1189 //------------------------------exists_at---------------------------
1190 // Does s exist in a pack at position pos?
1191 bool SuperWord::exists_at(Node* s, uint pos) {
1192   for (int i = 0; i &lt; _packset.length(); i++) {
1193     Node_List* p = _packset.at(i);
1194     if (p-&gt;at(pos) == s) {
1195       return true;
1196     }
1197   }
1198   return false;
1199 }
1200 
1201 //------------------------------are_adjacent_refs---------------------------
1202 // Is s1 immediately before s2 in memory?
1203 bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {
1204   if (!s1-&gt;is_Mem() || !s2-&gt;is_Mem()) return false;
1205   if (!in_bb(s1)    || !in_bb(s2))    return false;
1206 
1207   // Do not use superword for non-primitives
1208   if (!is_java_primitive(s1-&gt;as_Mem()-&gt;memory_type()) ||
1209       !is_java_primitive(s2-&gt;as_Mem()-&gt;memory_type())) {
1210     return false;
1211   }
1212 
1213   // FIXME - co_locate_pack fails on Stores in different mem-slices, so
1214   // only pack memops that are in the same alias set until that&#39;s fixed.
1215   if (_phase-&gt;C-&gt;get_alias_index(s1-&gt;as_Mem()-&gt;adr_type()) !=
1216       _phase-&gt;C-&gt;get_alias_index(s2-&gt;as_Mem()-&gt;adr_type()))
1217     return false;
1218   SWPointer p1(s1-&gt;as_Mem(), this, NULL, false);
1219   SWPointer p2(s2-&gt;as_Mem(), this, NULL, false);
1220   if (p1.base() != p2.base() || !p1.comparable(p2)) return false;
1221   int diff = p2.offset_in_bytes() - p1.offset_in_bytes();
1222   return diff == data_size(s1);
1223 }
1224 
1225 //------------------------------isomorphic---------------------------
1226 // Are s1 and s2 similar?
1227 bool SuperWord::isomorphic(Node* s1, Node* s2) {
1228   if (s1-&gt;Opcode() != s2-&gt;Opcode()) return false;
1229   if (s1-&gt;req() != s2-&gt;req()) return false;
1230   if (!same_velt_type(s1, s2)) return false;
1231   Node* s1_ctrl = s1-&gt;in(0);
1232   Node* s2_ctrl = s2-&gt;in(0);
1233   // If the control nodes are equivalent, no further checks are required to test for isomorphism.
1234   if (s1_ctrl == s2_ctrl) {
1235     return true;
1236   } else {
1237     bool s1_ctrl_inv = ((s1_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s1_ctrl));
1238     bool s2_ctrl_inv = ((s2_ctrl == NULL) ? true : lpt()-&gt;is_invariant(s2_ctrl));
1239     // If the control nodes are not invariant for the loop, fail isomorphism test.
1240     if (!s1_ctrl_inv || !s2_ctrl_inv) {
1241       return false;
1242     }
1243     if(s1_ctrl != NULL &amp;&amp; s2_ctrl != NULL) {
1244       if (s1_ctrl-&gt;is_Proj()) {
1245         s1_ctrl = s1_ctrl-&gt;in(0);
1246         assert(lpt()-&gt;is_invariant(s1_ctrl), &quot;must be invariant&quot;);
1247       }
1248       if (s2_ctrl-&gt;is_Proj()) {
1249         s2_ctrl = s2_ctrl-&gt;in(0);
1250         assert(lpt()-&gt;is_invariant(s2_ctrl), &quot;must be invariant&quot;);
1251       }
1252       if (!s1_ctrl-&gt;is_RangeCheck() || !s2_ctrl-&gt;is_RangeCheck()) {
1253         return false;
1254       }
1255     }
1256     // Control nodes are invariant. However, we have no way of checking whether they resolve
1257     // in an equivalent manner. But, we know that invariant range checks are guaranteed to
1258     // throw before the loop (if they would have thrown). Thus, the loop would not have been reached.
1259     // Therefore, if the control nodes for both are range checks, we accept them to be isomorphic.
1260     for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1261       Node* t1 = s1-&gt;fast_out(i);
1262       for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1263         Node* t2 = s2-&gt;fast_out(j);
1264         if (VectorNode::is_muladds2i(t1) &amp;&amp; VectorNode::is_muladds2i(t2)) {
1265           return true;
1266         }
1267       }
1268     }
1269   }
1270   return false;
1271 }
1272 
1273 //------------------------------independent---------------------------
1274 // Is there no data path from s1 to s2 or s2 to s1?
1275 bool SuperWord::independent(Node* s1, Node* s2) {
1276   //  assert(s1-&gt;Opcode() == s2-&gt;Opcode(), &quot;check isomorphic first&quot;);
1277   int d1 = depth(s1);
1278   int d2 = depth(s2);
1279   if (d1 == d2) return s1 != s2;
1280   Node* deep    = d1 &gt; d2 ? s1 : s2;
1281   Node* shallow = d1 &gt; d2 ? s2 : s1;
1282 
1283   visited_clear();
1284 
1285   return independent_path(shallow, deep);
1286 }
1287 
1288 //--------------------------have_similar_inputs-----------------------
1289 // For a node pair (s1, s2) which is isomorphic and independent,
1290 // do s1 and s2 have similar input edges?
1291 bool SuperWord::have_similar_inputs(Node* s1, Node* s2) {
1292   // assert(isomorphic(s1, s2) == true, &quot;check isomorphic&quot;);
1293   // assert(independent(s1, s2) == true, &quot;check independent&quot;);
1294   if (s1-&gt;req() &gt; 1 &amp;&amp; !s1-&gt;is_Store() &amp;&amp; !s1-&gt;is_Load()) {
1295     for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1296       if (s1-&gt;in(i)-&gt;Opcode() != s2-&gt;in(i)-&gt;Opcode()) return false;
1297     }
1298   }
1299   return true;
1300 }
1301 
1302 //------------------------------reduction---------------------------
1303 // Is there a data path between s1 and s2 and the nodes reductions?
1304 bool SuperWord::reduction(Node* s1, Node* s2) {
1305   bool retValue = false;
1306   int d1 = depth(s1);
1307   int d2 = depth(s2);
1308   if (d1 + 1 == d2) {
1309     if (s1-&gt;is_reduction() &amp;&amp; s2-&gt;is_reduction()) {
1310       // This is an ordered set, so s1 should define s2
1311       for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1312         Node* t1 = s1-&gt;fast_out(i);
1313         if (t1 == s2) {
1314           // both nodes are reductions and connected
1315           retValue = true;
1316         }
1317       }
1318     }
1319   }
1320 
1321   return retValue;
1322 }
1323 
1324 //------------------------------independent_path------------------------------
1325 // Helper for independent
1326 bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {
1327   if (dp &gt;= 1000) return false; // stop deep recursion
1328   visited_set(deep);
1329   int shal_depth = depth(shallow);
1330   assert(shal_depth &lt;= depth(deep), &quot;must be&quot;);
1331   for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {
1332     Node* pred = preds.current();
1333     if (in_bb(pred) &amp;&amp; !visited_test(pred)) {
1334       if (shallow == pred) {
1335         return false;
1336       }
1337       if (shal_depth &lt; depth(pred) &amp;&amp; !independent_path(shallow, pred, dp+1)) {
1338         return false;
1339       }
1340     }
1341   }
1342   return true;
1343 }
1344 
1345 //------------------------------set_alignment---------------------------
1346 void SuperWord::set_alignment(Node* s1, Node* s2, int align) {
1347   set_alignment(s1, align);
1348   if (align == top_align || align == bottom_align) {
1349     set_alignment(s2, align);
1350   } else {
1351     set_alignment(s2, align + data_size(s1));
1352   }
1353 }
1354 
1355 //------------------------------data_size---------------------------
1356 int SuperWord::data_size(Node* s) {
1357   Node* use = NULL; //test if the node is a candidate for CMoveV optimization, then return the size of CMov
1358   if (UseVectorCmov) {
1359     use = _cmovev_kit.is_Bool_candidate(s);
1360     if (use != NULL) {
1361       return data_size(use);
1362     }
1363     use = _cmovev_kit.is_CmpD_candidate(s);
1364     if (use != NULL) {
1365       return data_size(use);
1366     }
1367   }
1368 
1369   int bsize = type2aelembytes(velt_basic_type(s));
1370   assert(bsize != 0, &quot;valid size&quot;);
1371   return bsize;
1372 }
1373 
1374 //------------------------------extend_packlist---------------------------
1375 // Extend packset by following use-&gt;def and def-&gt;use links from pack members.
1376 void SuperWord::extend_packlist() {
1377   bool changed;
1378   do {
1379     packset_sort(_packset.length());
1380     changed = false;
1381     for (int i = 0; i &lt; _packset.length(); i++) {
1382       Node_List* p = _packset.at(i);
1383       changed |= follow_use_defs(p);
1384       changed |= follow_def_uses(p);
1385     }
1386   } while (changed);
1387 
1388   if (_race_possible) {
1389     for (int i = 0; i &lt; _packset.length(); i++) {
1390       Node_List* p = _packset.at(i);
1391       order_def_uses(p);
1392     }
1393   }
1394 
1395   if (TraceSuperWord) {
1396     tty-&gt;print_cr(&quot;\nAfter extend_packlist&quot;);
1397     print_packset();
1398   }
1399 }
1400 
1401 //------------------------------follow_use_defs---------------------------
1402 // Extend the packset by visiting operand definitions of nodes in pack p
1403 bool SuperWord::follow_use_defs(Node_List* p) {
1404   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1405   Node* s1 = p-&gt;at(0);
1406   Node* s2 = p-&gt;at(1);
1407   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1408   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1409 
1410   if (s1-&gt;is_Load()) return false;
1411 
1412   int align = alignment(s1);
1413   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1414   bool changed = false;
1415   int start = s1-&gt;is_Store() ? MemNode::ValueIn   : 1;
1416   int end   = s1-&gt;is_Store() ? MemNode::ValueIn+1 : s1-&gt;req();
1417   for (int j = start; j &lt; end; j++) {
1418     Node* t1 = s1-&gt;in(j);
1419     Node* t2 = s2-&gt;in(j);
1420     if (!in_bb(t1) || !in_bb(t2))
1421       continue;
1422     if (stmts_can_pack(t1, t2, align)) {
1423       if (est_savings(t1, t2) &gt;= 0) {
1424         Node_List* pair = new Node_List();
1425         pair-&gt;push(t1);
1426         pair-&gt;push(t2);
1427         _packset.append(pair);
1428         NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_use_defs: set_alignment(%d, %d, %d)&quot;, t1-&gt;_idx, t2-&gt;_idx, align);)
1429         set_alignment(t1, t2, align);
1430         changed = true;
1431       }
1432     }
1433   }
1434   return changed;
1435 }
1436 
1437 //------------------------------follow_def_uses---------------------------
1438 // Extend the packset by visiting uses of nodes in pack p
1439 bool SuperWord::follow_def_uses(Node_List* p) {
1440   bool changed = false;
1441   Node* s1 = p-&gt;at(0);
1442   Node* s2 = p-&gt;at(1);
1443   assert(p-&gt;size() == 2, &quot;just checking&quot;);
1444   assert(s1-&gt;req() == s2-&gt;req(), &quot;just checking&quot;);
1445   assert(alignment(s1) + data_size(s1) == alignment(s2), &quot;just checking&quot;);
1446 
1447   if (s1-&gt;is_Store()) return false;
1448 
1449   int align = alignment(s1);
1450   NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: s1 %d, align %d&quot;, s1-&gt;_idx, align);)
1451   int savings = -1;
1452   int num_s1_uses = 0;
1453   Node* u1 = NULL;
1454   Node* u2 = NULL;
1455   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1456     Node* t1 = s1-&gt;fast_out(i);
1457     num_s1_uses++;
1458     if (!in_bb(t1)) continue;
1459     for (DUIterator_Fast jmax, j = s2-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1460       Node* t2 = s2-&gt;fast_out(j);
1461       if (!in_bb(t2)) continue;
1462       if (t2-&gt;Opcode() == Op_AddI &amp;&amp; t2 == _lp-&gt;as_CountedLoop()-&gt;incr()) continue; // don&#39;t mess with the iv
1463       if (!opnd_positions_match(s1, t1, s2, t2))
1464         continue;
1465       if (stmts_can_pack(t1, t2, align)) {
1466         int my_savings = est_savings(t1, t2);
1467         if (my_savings &gt; savings) {
1468           savings = my_savings;
1469           u1 = t1;
1470           u2 = t2;
1471         }
1472       }
1473     }
1474   }
1475   if (num_s1_uses &gt; 1) {
1476     _race_possible = true;
1477   }
1478   if (savings &gt;= 0) {
1479     Node_List* pair = new Node_List();
1480     pair-&gt;push(u1);
1481     pair-&gt;push(u2);
1482     _packset.append(pair);
1483     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SuperWord::follow_def_uses: set_alignment(%d, %d, %d)&quot;, u1-&gt;_idx, u2-&gt;_idx, align);)
1484     set_alignment(u1, u2, align);
1485     changed = true;
1486   }
1487   return changed;
1488 }
1489 
1490 //------------------------------order_def_uses---------------------------
1491 // For extended packsets, ordinally arrange uses packset by major component
1492 void SuperWord::order_def_uses(Node_List* p) {
1493   Node* s1 = p-&gt;at(0);
1494 
1495   if (s1-&gt;is_Store()) return;
1496 
1497   // reductions are always managed beforehand
1498   if (s1-&gt;is_reduction()) return;
1499 
1500   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1501     Node* t1 = s1-&gt;fast_out(i);
1502 
1503     // Only allow operand swap on commuting operations
1504     if (!t1-&gt;is_Add() &amp;&amp; !t1-&gt;is_Mul() &amp;&amp; !VectorNode::is_muladds2i(t1)) {
1505       break;
1506     }
1507 
1508     // Now find t1&#39;s packset
1509     Node_List* p2 = NULL;
1510     for (int j = 0; j &lt; _packset.length(); j++) {
1511       p2 = _packset.at(j);
1512       Node* first = p2-&gt;at(0);
1513       if (t1 == first) {
1514         break;
1515       }
1516       p2 = NULL;
1517     }
1518     // Arrange all sub components by the major component
1519     if (p2 != NULL) {
1520       for (uint j = 1; j &lt; p-&gt;size(); j++) {
1521         Node* d1 = p-&gt;at(j);
1522         Node* u1 = p2-&gt;at(j);
1523         opnd_positions_match(s1, t1, d1, u1);
1524       }
1525     }
1526   }
1527 }
1528 
1529 //---------------------------opnd_positions_match-------------------------
1530 // Is the use of d1 in u1 at the same operand position as d2 in u2?
1531 bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {
1532   // check reductions to see if they are marshalled to represent the reduction
1533   // operator in a specified opnd
1534   if (u1-&gt;is_reduction() &amp;&amp; u2-&gt;is_reduction()) {
1535     // ensure reductions have phis and reduction definitions feeding the 1st operand
1536     Node* first = u1-&gt;in(2);
1537     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1538       u1-&gt;swap_edges(1, 2);
1539     }
1540     // ensure reductions have phis and reduction definitions feeding the 1st operand
1541     first = u2-&gt;in(2);
1542     if (first-&gt;is_Phi() || first-&gt;is_reduction()) {
1543       u2-&gt;swap_edges(1, 2);
1544     }
1545     return true;
1546   }
1547 
1548   uint ct = u1-&gt;req();
1549   if (ct != u2-&gt;req()) return false;
1550   uint i1 = 0;
1551   uint i2 = 0;
1552   do {
1553     for (i1++; i1 &lt; ct; i1++) if (u1-&gt;in(i1) == d1) break;
1554     for (i2++; i2 &lt; ct; i2++) if (u2-&gt;in(i2) == d2) break;
1555     if (i1 != i2) {
1556       if ((i1 == (3-i2)) &amp;&amp; (u2-&gt;is_Add() || u2-&gt;is_Mul())) {
1557         // Further analysis relies on operands position matching.
1558         u2-&gt;swap_edges(i1, i2);
1559       } else if (VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1560         if (i1 == 5 - i2) { // ((i1 == 3 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 3) || (i1 == 1 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 1))
1561           u2-&gt;swap_edges(1, 2);
1562           u2-&gt;swap_edges(3, 4);
1563         }
1564         if (i1 == 3 - i2 || i1 == 7 - i2) { // ((i1 == 1 &amp;&amp; i2 == 2) || (i1 == 2 &amp;&amp; i2 == 1) || (i1 == 3 &amp;&amp; i2 == 4) || (i1 == 4 &amp;&amp; i2 == 3))
1565           u2-&gt;swap_edges(2, 3);
1566           u2-&gt;swap_edges(1, 4);
1567         }
1568         return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1569       } else {
1570         return false;
1571       }
1572     } else if (i1 == i2 &amp;&amp; VectorNode::is_muladds2i(u2) &amp;&amp; u1 != u2) {
1573       u2-&gt;swap_edges(1, 3);
1574       u2-&gt;swap_edges(2, 4);
1575       return false; // Just swap the edges, the muladds2i nodes get packed in follow_use_defs
1576     }
1577   } while (i1 &lt; ct);
1578   return true;
1579 }
1580 
1581 //------------------------------est_savings---------------------------
1582 // Estimate the savings from executing s1 and s2 as a pack
1583 int SuperWord::est_savings(Node* s1, Node* s2) {
1584   int save_in = 2 - 1; // 2 operations per instruction in packed form
1585 
1586   // inputs
1587   for (uint i = 1; i &lt; s1-&gt;req(); i++) {
1588     Node* x1 = s1-&gt;in(i);
1589     Node* x2 = s2-&gt;in(i);
1590     if (x1 != x2) {
1591       if (are_adjacent_refs(x1, x2)) {
1592         save_in += adjacent_profit(x1, x2);
1593       } else if (!in_packset(x1, x2)) {
1594         save_in -= pack_cost(2);
1595       } else {
1596         save_in += unpack_cost(2);
1597       }
1598     }
1599   }
1600 
1601   // uses of result
1602   uint ct = 0;
1603   int save_use = 0;
1604   for (DUIterator_Fast imax, i = s1-&gt;fast_outs(imax); i &lt; imax; i++) {
1605     Node* s1_use = s1-&gt;fast_out(i);
1606     for (int j = 0; j &lt; _packset.length(); j++) {
1607       Node_List* p = _packset.at(j);
1608       if (p-&gt;at(0) == s1_use) {
1609         for (DUIterator_Fast kmax, k = s2-&gt;fast_outs(kmax); k &lt; kmax; k++) {
1610           Node* s2_use = s2-&gt;fast_out(k);
1611           if (p-&gt;at(p-&gt;size()-1) == s2_use) {
1612             ct++;
1613             if (are_adjacent_refs(s1_use, s2_use)) {
1614               save_use += adjacent_profit(s1_use, s2_use);
1615             }
1616           }
1617         }
1618       }
1619     }
1620   }
1621 
1622   if (ct &lt; s1-&gt;outcnt()) save_use += unpack_cost(1);
1623   if (ct &lt; s2-&gt;outcnt()) save_use += unpack_cost(1);
1624 
1625   return MAX2(save_in, save_use);
1626 }
1627 
1628 //------------------------------costs---------------------------
1629 int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }
1630 int SuperWord::pack_cost(int ct)   { return ct; }
1631 int SuperWord::unpack_cost(int ct) { return ct; }
1632 
1633 //------------------------------combine_packs---------------------------
1634 // Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last
1635 void SuperWord::combine_packs() {
1636   bool changed = true;
1637   // Combine packs regardless max vector size.
1638   while (changed) {
1639     changed = false;
1640     for (int i = 0; i &lt; _packset.length(); i++) {
1641       Node_List* p1 = _packset.at(i);
1642       if (p1 == NULL) continue;
1643       // Because of sorting we can start at i + 1
1644       for (int j = i + 1; j &lt; _packset.length(); j++) {
1645         Node_List* p2 = _packset.at(j);
1646         if (p2 == NULL) continue;
1647         if (i == j) continue;
1648         if (p1-&gt;at(p1-&gt;size()-1) == p2-&gt;at(0)) {
1649           for (uint k = 1; k &lt; p2-&gt;size(); k++) {
1650             p1-&gt;push(p2-&gt;at(k));
1651           }
1652           _packset.at_put(j, NULL);
1653           changed = true;
1654         }
1655       }
1656     }
1657   }
1658 
1659   // Split packs which have size greater then max vector size.
1660   for (int i = 0; i &lt; _packset.length(); i++) {
1661     Node_List* p1 = _packset.at(i);
1662     if (p1 != NULL) {
1663       BasicType bt = velt_basic_type(p1-&gt;at(0));
1664       uint max_vlen = Matcher::max_vector_size(bt); // Max elements in vector
1665       assert(is_power_of_2(max_vlen), &quot;sanity&quot;);
1666       uint psize = p1-&gt;size();
1667       if (!is_power_of_2(psize)) {
1668         // Skip pack which can&#39;t be vector.
1669         // case1: for(...) { a[i] = i; }    elements values are different (i+x)
1670         // case2: for(...) { a[i] = b[i+1]; }  can&#39;t align both, load and store
1671         _packset.at_put(i, NULL);
1672         continue;
1673       }
1674       if (psize &gt; max_vlen) {
1675         Node_List* pack = new Node_List();
1676         for (uint j = 0; j &lt; psize; j++) {
1677           pack-&gt;push(p1-&gt;at(j));
1678           if (pack-&gt;size() &gt;= max_vlen) {
1679             assert(is_power_of_2(pack-&gt;size()), &quot;sanity&quot;);
1680             _packset.append(pack);
1681             pack = new Node_List();
1682           }
1683         }
1684         _packset.at_put(i, NULL);
1685       }
1686     }
1687   }
1688 
1689   // Compress list.
1690   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1691     Node_List* p1 = _packset.at(i);
1692     if (p1 == NULL) {
1693       _packset.remove_at(i);
1694     }
1695   }
1696 
1697   if (TraceSuperWord) {
1698     tty-&gt;print_cr(&quot;\nAfter combine_packs&quot;);
1699     print_packset();
1700   }
1701 }
1702 
1703 //-----------------------------construct_my_pack_map--------------------------
1704 // Construct the map from nodes to packs.  Only valid after the
1705 // point where a node is only in one pack (after combine_packs).
1706 void SuperWord::construct_my_pack_map() {
1707   Node_List* rslt = NULL;
1708   for (int i = 0; i &lt; _packset.length(); i++) {
1709     Node_List* p = _packset.at(i);
1710     for (uint j = 0; j &lt; p-&gt;size(); j++) {
1711       Node* s = p-&gt;at(j);
1712       assert(my_pack(s) == NULL, &quot;only in one pack&quot;);
1713       set_my_pack(s, p);
1714     }
1715   }
1716 }
1717 
1718 //------------------------------filter_packs---------------------------
1719 // Remove packs that are not implemented or not profitable.
1720 void SuperWord::filter_packs() {
1721   // Remove packs that are not implemented
1722   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1723     Node_List* pk = _packset.at(i);
1724     bool impl = implemented(pk);
1725     if (!impl) {
1726 #ifndef PRODUCT
1727       if (TraceSuperWord &amp;&amp; Verbose) {
1728         tty-&gt;print_cr(&quot;Unimplemented&quot;);
1729         pk-&gt;at(0)-&gt;dump();
1730       }
1731 #endif
1732       remove_pack_at(i);
1733     }
1734     Node *n = pk-&gt;at(0);
1735     if (n-&gt;is_reduction()) {
1736       _num_reductions++;
1737     } else {
1738       _num_work_vecs++;
1739     }
1740   }
1741 
1742   // Remove packs that are not profitable
1743   bool changed;
1744   do {
1745     changed = false;
1746     for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1747       Node_List* pk = _packset.at(i);
1748       bool prof = profitable(pk);
1749       if (!prof) {
1750 #ifndef PRODUCT
1751         if (TraceSuperWord &amp;&amp; Verbose) {
1752           tty-&gt;print_cr(&quot;Unprofitable&quot;);
1753           pk-&gt;at(0)-&gt;dump();
1754         }
1755 #endif
1756         remove_pack_at(i);
1757         changed = true;
1758       }
1759     }
1760   } while (changed);
1761 
1762 #ifndef PRODUCT
1763   if (TraceSuperWord) {
1764     tty-&gt;print_cr(&quot;\nAfter filter_packs&quot;);
1765     print_packset();
1766     tty-&gt;cr();
1767   }
1768 #endif
1769 }
1770 
1771 //------------------------------merge_packs_to_cmovd---------------------------
1772 // Merge CMoveD into new vector-nodes
1773 // We want to catch this pattern and subsume CmpD and Bool into CMoveD
1774 //
1775 //                   SubD             ConD
1776 //                  /  |               /
1777 //                 /   |           /   /
1778 //                /    |       /      /
1779 //               /     |   /         /
1780 //              /      /            /
1781 //             /    /  |           /
1782 //            v /      |          /
1783 //         CmpD        |         /
1784 //          |          |        /
1785 //          v          |       /
1786 //         Bool        |      /
1787 //           \         |     /
1788 //             \       |    /
1789 //               \     |   /
1790 //                 \   |  /
1791 //                   \ v /
1792 //                   CMoveD
1793 //
1794 
1795 void SuperWord::merge_packs_to_cmovd() {
1796   for (int i = _packset.length() - 1; i &gt;= 0; i--) {
1797     _cmovev_kit.make_cmovevd_pack(_packset.at(i));
1798   }
1799   #ifndef PRODUCT
1800     if (TraceSuperWord) {
1801       tty-&gt;print_cr(&quot;\nSuperWord::merge_packs_to_cmovd(): After merge&quot;);
1802       print_packset();
1803       tty-&gt;cr();
1804     }
1805   #endif
1806 }
1807 
1808 Node* CMoveKit::is_Bool_candidate(Node* def) const {
1809   Node* use = NULL;
1810   if (!def-&gt;is_Bool() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1811     return NULL;
1812   }
1813   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1814     use = def-&gt;fast_out(j);
1815     if (!_sw-&gt;same_generation(def, use) || !use-&gt;is_CMove()) {
1816       return NULL;
1817     }
1818   }
1819   return use;
1820 }
1821 
1822 Node* CMoveKit::is_CmpD_candidate(Node* def) const {
1823   Node* use = NULL;
1824   if (!def-&gt;is_Cmp() || def-&gt;in(0) != NULL || def-&gt;outcnt() != 1) {
1825     return NULL;
1826   }
1827   for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
1828     use = def-&gt;fast_out(j);
1829     if (!_sw-&gt;same_generation(def, use) || (use = is_Bool_candidate(use)) == NULL || !_sw-&gt;same_generation(def, use)) {
1830       return NULL;
1831     }
1832   }
1833   return use;
1834 }
1835 
1836 Node_List* CMoveKit::make_cmovevd_pack(Node_List* cmovd_pk) {
1837   Node *cmovd = cmovd_pk-&gt;at(0);
1838   if (!cmovd-&gt;is_CMove()) {
1839     return NULL;
1840   }
1841   if (cmovd-&gt;Opcode() != Op_CMoveF &amp;&amp; cmovd-&gt;Opcode() != Op_CMoveD) {
1842     return NULL;
1843   }
1844   if (pack(cmovd) != NULL) { // already in the cmov pack
1845     return NULL;
1846   }
1847   if (cmovd-&gt;in(0) != NULL) {
1848     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CMoveD %d has control flow, escaping...&quot;, cmovd-&gt;_idx); cmovd-&gt;dump();})
1849     return NULL;
1850   }
1851 
1852   Node* bol = cmovd-&gt;as_CMove()-&gt;in(CMoveNode::Condition);
1853   if (!bol-&gt;is_Bool()
1854       || bol-&gt;outcnt() != 1
1855       || !_sw-&gt;same_generation(bol, cmovd)
1856       || bol-&gt;in(0) != NULL  // BoolNode has control flow!!
1857       || _sw-&gt;my_pack(bol) == NULL) {
1858       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: Bool %d does not fit CMoveD %d for building vector, escaping...&quot;, bol-&gt;_idx, cmovd-&gt;_idx); bol-&gt;dump();})
1859       return NULL;
1860   }
1861   Node_List* bool_pk = _sw-&gt;my_pack(bol);
1862   if (bool_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1863     return NULL;
1864   }
1865 
1866   Node* cmpd = bol-&gt;in(1);
1867   if (!cmpd-&gt;is_Cmp()
1868       || cmpd-&gt;outcnt() != 1
1869       || !_sw-&gt;same_generation(cmpd, cmovd)
1870       || cmpd-&gt;in(0) != NULL  // CmpDNode has control flow!!
1871       || _sw-&gt;my_pack(cmpd) == NULL) {
1872       NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: CmpD %d does not fit CMoveD %d for building vector, escaping...&quot;, cmpd-&gt;_idx, cmovd-&gt;_idx); cmpd-&gt;dump();})
1873       return NULL;
1874   }
1875   Node_List* cmpd_pk = _sw-&gt;my_pack(cmpd);
1876   if (cmpd_pk-&gt;size() != cmovd_pk-&gt;size() ) {
1877     return NULL;
1878   }
1879 
1880   if (!test_cmpd_pack(cmpd_pk, cmovd_pk)) {
1881     NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print(&quot;CMoveKit::make_cmovevd_pack: cmpd pack for CmpD %d failed vectorization test&quot;, cmpd-&gt;_idx); cmpd-&gt;dump();})
1882     return NULL;
1883   }
1884 
1885   Node_List* new_cmpd_pk = new Node_List();
1886   uint sz = cmovd_pk-&gt;size() - 1;
1887   for (uint i = 0; i &lt;= sz; ++i) {
1888     Node* cmov = cmovd_pk-&gt;at(i);
1889     Node* bol  = bool_pk-&gt;at(i);
1890     Node* cmp  = cmpd_pk-&gt;at(i);
1891 
1892     new_cmpd_pk-&gt;insert(i, cmov);
1893 
1894     map(cmov, new_cmpd_pk);
1895     map(bol, new_cmpd_pk);
1896     map(cmp, new_cmpd_pk);
1897 
1898     _sw-&gt;set_my_pack(cmov, new_cmpd_pk); // and keep old packs for cmp and bool
1899   }
1900   _sw-&gt;_packset.remove(cmovd_pk);
1901   _sw-&gt;_packset.remove(bool_pk);
1902   _sw-&gt;_packset.remove(cmpd_pk);
1903   _sw-&gt;_packset.append(new_cmpd_pk);
1904   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) {tty-&gt;print_cr(&quot;CMoveKit::make_cmovevd_pack: added syntactic CMoveD pack&quot;); _sw-&gt;print_pack(new_cmpd_pk);})
1905   return new_cmpd_pk;
1906 }
1907 
1908 bool CMoveKit::test_cmpd_pack(Node_List* cmpd_pk, Node_List* cmovd_pk) {
1909   Node* cmpd0 = cmpd_pk-&gt;at(0);
1910   assert(cmpd0-&gt;is_Cmp(), &quot;CMoveKit::test_cmpd_pack: should be CmpDNode&quot;);
1911   assert(cmovd_pk-&gt;at(0)-&gt;is_CMove(), &quot;CMoveKit::test_cmpd_pack: should be CMoveD&quot;);
1912   assert(cmpd_pk-&gt;size() == cmovd_pk-&gt;size(), &quot;CMoveKit::test_cmpd_pack: should be same size&quot;);
1913   Node* in1 = cmpd0-&gt;in(1);
1914   Node* in2 = cmpd0-&gt;in(2);
1915   Node_List* in1_pk = _sw-&gt;my_pack(in1);
1916   Node_List* in2_pk = _sw-&gt;my_pack(in2);
1917 
1918   if (  (in1_pk != NULL &amp;&amp; in1_pk-&gt;size() != cmpd_pk-&gt;size())
1919      || (in2_pk != NULL &amp;&amp; in2_pk-&gt;size() != cmpd_pk-&gt;size()) ) {
1920     return false;
1921   }
1922 
1923   // test if &quot;all&quot; in1 are in the same pack or the same node
1924   if (in1_pk == NULL) {
1925     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1926       if (cmpd_pk-&gt;at(j)-&gt;in(1) != in1) {
1927         return false;
1928       }
1929     }//for: in1_pk is not pack but all CmpD nodes in the pack have the same in(1)
1930   }
1931   // test if &quot;all&quot; in2 are in the same pack or the same node
1932   if (in2_pk == NULL) {
1933     for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1934       if (cmpd_pk-&gt;at(j)-&gt;in(2) != in2) {
1935         return false;
1936       }
1937     }//for: in2_pk is not pack but all CmpD nodes in the pack have the same in(2)
1938   }
1939   //now check if cmpd_pk may be subsumed in vector built for cmovd_pk
1940   int cmovd_ind1, cmovd_ind2;
1941   if (cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1942    &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1943       cmovd_ind1 = CMoveNode::IfFalse;
1944       cmovd_ind2 = CMoveNode::IfTrue;
1945   } else if (cmpd_pk-&gt;at(0)-&gt;in(2) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfFalse)
1946           &amp;&amp; cmpd_pk-&gt;at(0)-&gt;in(1) == cmovd_pk-&gt;at(0)-&gt;as_CMove()-&gt;in(CMoveNode::IfTrue)) {
1947       cmovd_ind2 = CMoveNode::IfFalse;
1948       cmovd_ind1 = CMoveNode::IfTrue;
1949   }
1950   else {
1951     return false;
1952   }
1953 
1954   for (uint j = 1; j &lt; cmpd_pk-&gt;size(); j++) {
1955     if (cmpd_pk-&gt;at(j)-&gt;in(1) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind1)
1956         || cmpd_pk-&gt;at(j)-&gt;in(2) != cmovd_pk-&gt;at(j)-&gt;as_CMove()-&gt;in(cmovd_ind2)) {
1957         return false;
1958     }//if
1959   }
1960   NOT_PRODUCT(if(_sw-&gt;is_trace_cmov()) { tty-&gt;print(&quot;CMoveKit::test_cmpd_pack: cmpd pack for 1st CmpD %d is OK for vectorization: &quot;, cmpd0-&gt;_idx); cmpd0-&gt;dump(); })
1961   return true;
1962 }
1963 
1964 //------------------------------implemented---------------------------
1965 // Can code be generated for pack p?
1966 bool SuperWord::implemented(Node_List* p) {
1967   bool retValue = false;
1968   Node* p0 = p-&gt;at(0);
1969   if (p0 != NULL) {
1970     int opc = p0-&gt;Opcode();
1971     uint size = p-&gt;size();
1972     if (p0-&gt;is_reduction()) {
1973       const Type *arith_type = p0-&gt;bottom_type();
1974       // Length 2 reductions of INT/LONG do not offer performance benefits
1975       if (((arith_type-&gt;basic_type() == T_INT) || (arith_type-&gt;basic_type() == T_LONG)) &amp;&amp; (size == 2)) {
1976         retValue = false;
1977       } else {
1978         retValue = ReductionNode::implemented(opc, size, arith_type-&gt;basic_type());
1979       }
1980     } else {
1981       retValue = VectorNode::implemented(opc, size, velt_basic_type(p0));
1982     }
1983     if (!retValue) {
1984       if (is_cmov_pack(p)) {
1985         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::implemented: found cmpd pack&quot;); print_pack(p);})
1986         return true;
1987       }
1988     }
1989   }
1990   return retValue;
1991 }
1992 
1993 bool SuperWord::is_cmov_pack(Node_List* p) {
1994   return _cmovev_kit.pack(p-&gt;at(0)) != NULL;
1995 }
1996 //------------------------------same_inputs--------------------------
1997 // For pack p, are all idx operands the same?
1998 bool SuperWord::same_inputs(Node_List* p, int idx) {
1999   Node* p0 = p-&gt;at(0);
2000   uint vlen = p-&gt;size();
2001   Node* p0_def = p0-&gt;in(idx);
2002   for (uint i = 1; i &lt; vlen; i++) {
2003     Node* pi = p-&gt;at(i);
2004     Node* pi_def = pi-&gt;in(idx);
2005     if (p0_def != pi_def) {
2006       return false;
2007     }
2008   }
2009   return true;
2010 }
2011 
2012 //------------------------------profitable---------------------------
2013 // For pack p, are all operands and all uses (with in the block) vector?
2014 bool SuperWord::profitable(Node_List* p) {
2015   Node* p0 = p-&gt;at(0);
2016   uint start, end;
2017   VectorNode::vector_operands(p0, &amp;start, &amp;end);
2018 
2019   // Return false if some inputs are not vectors or vectors with different
2020   // size or alignment.
2021   // Also, for now, return false if not scalar promotion case when inputs are
2022   // the same. Later, implement PackNode and allow differing, non-vector inputs
2023   // (maybe just the ones from outside the block.)
2024   for (uint i = start; i &lt; end; i++) {
2025     if (!is_vector_use(p0, i)) {
2026       return false;
2027     }
2028   }
2029   // Check if reductions are connected
2030   if (p0-&gt;is_reduction()) {
2031     Node* second_in = p0-&gt;in(2);
2032     Node_List* second_pk = my_pack(second_in);
2033     if ((second_pk == NULL) || (_num_work_vecs == _num_reductions)) {
2034       // Remove reduction flag if no parent pack or if not enough work
2035       // to cover reduction expansion overhead
2036       p0-&gt;remove_flag(Node::Flag_is_reduction);
2037       return false;
2038     } else if (second_pk-&gt;size() != p-&gt;size()) {
2039       return false;
2040     }
2041   }
2042   if (VectorNode::is_shift(p0)) {
2043     // For now, return false if shift count is vector or not scalar promotion
2044     // case (different shift counts) because it is not supported yet.
2045     Node* cnt = p0-&gt;in(2);
2046     Node_List* cnt_pk = my_pack(cnt);
2047     if (cnt_pk != NULL)
2048       return false;
2049     if (!same_inputs(p, 2))
2050       return false;
2051   }
2052   if (!p0-&gt;is_Store()) {
2053     // For now, return false if not all uses are vector.
2054     // Later, implement ExtractNode and allow non-vector uses (maybe
2055     // just the ones outside the block.)
2056     for (uint i = 0; i &lt; p-&gt;size(); i++) {
2057       Node* def = p-&gt;at(i);
2058       if (is_cmov_pack_internal_node(p, def)) {
2059         continue;
2060       }
2061       for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2062         Node* use = def-&gt;fast_out(j);
2063         for (uint k = 0; k &lt; use-&gt;req(); k++) {
2064           Node* n = use-&gt;in(k);
2065           if (def == n) {
2066             // Reductions should only have a Phi use at the loop head or a non-phi use
2067             // outside of the loop if it is the last element of the pack (e.g. SafePoint).
2068             if (def-&gt;is_reduction() &amp;&amp;
2069                 ((use-&gt;is_Phi() &amp;&amp; use-&gt;in(0) == _lpt-&gt;_head) ||
2070                  (!_lpt-&gt;is_member(_phase-&gt;get_loop(_phase-&gt;ctrl_or_self(use))) &amp;&amp; i == p-&gt;size()-1))) {
2071               continue;
2072             }
2073             if (!is_vector_use(use, k)) {
2074               return false;
2075             }
2076           }
2077         }
2078       }
2079     }
2080   }
2081   return true;
2082 }
2083 
2084 //------------------------------schedule---------------------------
2085 // Adjust the memory graph for the packed operations
2086 void SuperWord::schedule() {
2087 
2088   // Co-locate in the memory graph the members of each memory pack
2089   for (int i = 0; i &lt; _packset.length(); i++) {
2090     co_locate_pack(_packset.at(i));
2091   }
2092 }
2093 
2094 //-------------------------------remove_and_insert-------------------
2095 // Remove &quot;current&quot; from its current position in the memory graph and insert
2096 // it after the appropriate insertion point (lip or uip).
2097 void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,
2098                                   Node *uip, Unique_Node_List &amp;sched_before) {
2099   Node* my_mem = current-&gt;in(MemNode::Memory);
2100   bool sched_up = sched_before.member(current);
2101 
2102   // remove current_store from its current position in the memmory graph
2103   for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2104     Node* use = current-&gt;out(i);
2105     if (use-&gt;is_Mem()) {
2106       assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2107       if (use == prev) { // connect prev to my_mem
2108           _igvn.replace_input_of(use, MemNode::Memory, my_mem);
2109           --i; //deleted this edge; rescan position
2110       } else if (sched_before.member(use)) {
2111         if (!sched_up) { // Will be moved together with current
2112           _igvn.replace_input_of(use, MemNode::Memory, uip);
2113           --i; //deleted this edge; rescan position
2114         }
2115       } else {
2116         if (sched_up) { // Will be moved together with current
2117           _igvn.replace_input_of(use, MemNode::Memory, lip);
2118           --i; //deleted this edge; rescan position
2119         }
2120       }
2121     }
2122   }
2123 
2124   Node *insert_pt =  sched_up ?  uip : lip;
2125 
2126   // all uses of insert_pt&#39;s memory state should use current&#39;s instead
2127   for (DUIterator i = insert_pt-&gt;outs(); insert_pt-&gt;has_out(i); i++) {
2128     Node* use = insert_pt-&gt;out(i);
2129     if (use-&gt;is_Mem()) {
2130       assert(use-&gt;in(MemNode::Memory) == insert_pt, &quot;must be&quot;);
2131       _igvn.replace_input_of(use, MemNode::Memory, current);
2132       --i; //deleted this edge; rescan position
2133     } else if (!sched_up &amp;&amp; use-&gt;is_Phi() &amp;&amp; use-&gt;bottom_type() == Type::MEMORY) {
2134       uint pos; //lip (lower insert point) must be the last one in the memory slice
2135       for (pos=1; pos &lt; use-&gt;req(); pos++) {
2136         if (use-&gt;in(pos) == insert_pt) break;
2137       }
2138       _igvn.replace_input_of(use, pos, current);
2139       --i;
2140     }
2141   }
2142 
2143   //connect current to insert_pt
2144   _igvn.replace_input_of(current, MemNode::Memory, insert_pt);
2145 }
2146 
2147 //------------------------------co_locate_pack----------------------------------
2148 // To schedule a store pack, we need to move any sandwiched memory ops either before
2149 // or after the pack, based upon dependence information:
2150 // (1) If any store in the pack depends on the sandwiched memory op, the
2151 //     sandwiched memory op must be scheduled BEFORE the pack;
2152 // (2) If a sandwiched memory op depends on any store in the pack, the
2153 //     sandwiched memory op must be scheduled AFTER the pack;
2154 // (3) If a sandwiched memory op (say, memA) depends on another sandwiched
2155 //     memory op (say memB), memB must be scheduled before memA. So, if memA is
2156 //     scheduled before the pack, memB must also be scheduled before the pack;
2157 // (4) If there is no dependence restriction for a sandwiched memory op, we simply
2158 //     schedule this store AFTER the pack
2159 // (5) We know there is no dependence cycle, so there in no other case;
2160 // (6) Finally, all memory ops in another single pack should be moved in the same direction.
2161 //
2162 // To schedule a load pack, we use the memory state of either the first or the last load in
2163 // the pack, based on the dependence constraint.
2164 void SuperWord::co_locate_pack(Node_List* pk) {
2165   if (pk-&gt;at(0)-&gt;is_Store()) {
2166     MemNode* first     = executed_first(pk)-&gt;as_Mem();
2167     MemNode* last      = executed_last(pk)-&gt;as_Mem();
2168     Unique_Node_List schedule_before_pack;
2169     Unique_Node_List memops;
2170 
2171     MemNode* current   = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2172     MemNode* previous  = last;
2173     while (true) {
2174       assert(in_bb(current), &quot;stay in block&quot;);
2175       memops.push(previous);
2176       for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2177         Node* use = current-&gt;out(i);
2178         if (use-&gt;is_Mem() &amp;&amp; use != previous)
2179           memops.push(use);
2180       }
2181       if (current == first) break;
2182       previous = current;
2183       current  = current-&gt;in(MemNode::Memory)-&gt;as_Mem();
2184     }
2185 
2186     // determine which memory operations should be scheduled before the pack
2187     for (uint i = 1; i &lt; memops.size(); i++) {
2188       Node *s1 = memops.at(i);
2189       if (!in_pack(s1, pk) &amp;&amp; !schedule_before_pack.member(s1)) {
2190         for (uint j = 0; j&lt; i; j++) {
2191           Node *s2 = memops.at(j);
2192           if (!independent(s1, s2)) {
2193             if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {
2194               schedule_before_pack.push(s1); // s1 must be scheduled before
2195               Node_List* mem_pk = my_pack(s1);
2196               if (mem_pk != NULL) {
2197                 for (uint ii = 0; ii &lt; mem_pk-&gt;size(); ii++) {
2198                   Node* s = mem_pk-&gt;at(ii);  // follow partner
2199                   if (memops.member(s) &amp;&amp; !schedule_before_pack.member(s))
2200                     schedule_before_pack.push(s);
2201                 }
2202               }
2203               break;
2204             }
2205           }
2206         }
2207       }
2208     }
2209 
2210     Node*    upper_insert_pt = first-&gt;in(MemNode::Memory);
2211     // Following code moves loads connected to upper_insert_pt below aliased stores.
2212     // Collect such loads here and reconnect them back to upper_insert_pt later.
2213     memops.clear();
2214     for (DUIterator i = upper_insert_pt-&gt;outs(); upper_insert_pt-&gt;has_out(i); i++) {
2215       Node* use = upper_insert_pt-&gt;out(i);
2216       if (use-&gt;is_Mem() &amp;&amp; !use-&gt;is_Store()) {
2217         memops.push(use);
2218       }
2219     }
2220 
2221     MemNode* lower_insert_pt = last;
2222     previous                 = last; //previous store in pk
2223     current                  = last-&gt;in(MemNode::Memory)-&gt;as_Mem();
2224 
2225     // start scheduling from &quot;last&quot; to &quot;first&quot;
2226     while (true) {
2227       assert(in_bb(current), &quot;stay in block&quot;);
2228       assert(in_pack(previous, pk), &quot;previous stays in pack&quot;);
2229       Node* my_mem = current-&gt;in(MemNode::Memory);
2230 
2231       if (in_pack(current, pk)) {
2232         // Forward users of my memory state (except &quot;previous) to my input memory state
2233         for (DUIterator i = current-&gt;outs(); current-&gt;has_out(i); i++) {
2234           Node* use = current-&gt;out(i);
2235           if (use-&gt;is_Mem() &amp;&amp; use != previous) {
2236             assert(use-&gt;in(MemNode::Memory) == current, &quot;must be&quot;);
2237             if (schedule_before_pack.member(use)) {
2238               _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);
2239             } else {
2240               _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);
2241             }
2242             --i; // deleted this edge; rescan position
2243           }
2244         }
2245         previous = current;
2246       } else { // !in_pack(current, pk) ==&gt; a sandwiched store
2247         remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);
2248       }
2249 
2250       if (current == first) break;
2251       current = my_mem-&gt;as_Mem();
2252     } // end while
2253 
2254     // Reconnect loads back to upper_insert_pt.
2255     for (uint i = 0; i &lt; memops.size(); i++) {
2256       Node *ld = memops.at(i);
2257       if (ld-&gt;in(MemNode::Memory) != upper_insert_pt) {
2258         _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);
2259       }
2260     }
2261   } else if (pk-&gt;at(0)-&gt;is_Load()) { //load
2262     // all loads in the pack should have the same memory state. By default,
2263     // we use the memory state of the last load. However, if any load could
2264     // not be moved down due to the dependence constraint, we use the memory
2265     // state of the first load.
2266     Node* last_mem  = pk-&gt;at(0)-&gt;in(MemNode::Memory);
2267     Node* first_mem = last_mem;
2268     // Walk the memory graph from the current first load until the
2269     // start of the loop and check if nodes on the way are memory
2270     // edges of loads in the pack. The last one we encounter is the
2271     // first load.
2272     for (Node* current = first_mem; in_bb(current); current = current-&gt;is_Phi() ? current-&gt;in(LoopNode::EntryControl) : current-&gt;in(MemNode::Memory)) {
2273      assert(current-&gt;is_Mem() || (current-&gt;is_Phi() &amp;&amp; current-&gt;in(0) == bb()), &quot;unexpected memory&quot;);
2274      for (uint i = 1; i &lt; pk-&gt;size(); i++) {
2275         Node* ld = pk-&gt;at(i);
2276         if (ld-&gt;in(MemNode::Memory) == current) {
2277           first_mem = current;
2278           break;
2279         }
2280       }
2281     }
2282     // Find the last load by going over the pack again and walking
2283     // the memory graph from the loads of the pack to the memory of
2284     // the first load. If we encounter the memory of the current last
2285     // load, then we started from further down in the memory graph and
2286     // the load we started from is the last load. Check for dependence
2287     // constraints in that loop as well.
2288     bool schedule_last = true;
2289     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2290       Node* ld = pk-&gt;at(i);
2291       for (Node* current = ld-&gt;in(MemNode::Memory); current != first_mem; current = current-&gt;in(MemNode::Memory)) {
2292         assert(current-&gt;is_Mem() &amp;&amp; in_bb(current), &quot;unexpected memory&quot;);
2293         if (current-&gt;in(MemNode::Memory) == last_mem) {
2294           last_mem = ld-&gt;in(MemNode::Memory);
2295         }
2296         if (!independent(current, ld)) {
2297           schedule_last = false; // a later store depends on this load
2298         }
2299       }
2300     }
2301 
2302     Node* mem_input = schedule_last ? last_mem : first_mem;
2303     _igvn.hash_delete(mem_input);
2304     // Give each load the same memory state
2305     for (uint i = 0; i &lt; pk-&gt;size(); i++) {
2306       LoadNode* ld = pk-&gt;at(i)-&gt;as_Load();
2307       _igvn.replace_input_of(ld, MemNode::Memory, mem_input);
2308     }
2309   }
2310 }
2311 
2312 #ifndef PRODUCT
2313 void SuperWord::print_loop(bool whole) {
2314   Node_Stack stack(_arena, _phase-&gt;C-&gt;unique() &gt;&gt; 2);
2315   Node_List rpo_list;
2316   VectorSet visited(_arena);
2317   visited.set(lpt()-&gt;_head-&gt;_idx);
2318   _phase-&gt;rpo(lpt()-&gt;_head, stack, visited, rpo_list);
2319   _phase-&gt;dump(lpt(), rpo_list.size(), rpo_list );
2320   if(whole) {
2321     tty-&gt;print_cr(&quot;\n Whole loop tree&quot;);
2322     _phase-&gt;dump();
2323     tty-&gt;print_cr(&quot; End of whole loop tree\n&quot;);
2324   }
2325 }
2326 #endif
2327 
2328 //------------------------------output---------------------------
2329 // Convert packs into vector node operations
2330 void SuperWord::output() {
2331   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2332   Compile* C = _phase-&gt;C;
2333   if (_packset.length() == 0) {
2334     if (cl-&gt;is_main_loop()) {
2335       // Instigate more unrolling for optimization when vectorization fails.
2336       C-&gt;set_major_progress();
2337       cl-&gt;set_notpassed_slp();
2338       cl-&gt;mark_do_unroll_only();
2339     }
2340     return;
2341   }
2342 
2343 #ifndef PRODUCT
2344   if (TraceLoopOpts) {
2345     tty-&gt;print(&quot;SuperWord::output    &quot;);
2346     lpt()-&gt;dump_head();
2347   }
2348 #endif
2349 
2350   if (cl-&gt;is_main_loop()) {
2351     // MUST ENSURE main loop&#39;s initial value is properly aligned:
2352     //  (iv_initial_value + min_iv_offset) % vector_width_in_bytes() == 0
2353 
2354     align_initial_loop_index(align_to_ref());
2355 
2356     // Insert extract (unpack) operations for scalar uses
2357     for (int i = 0; i &lt; _packset.length(); i++) {
2358       insert_extracts(_packset.at(i));
2359     }
2360   }
2361 
2362   uint max_vlen_in_bytes = 0;
2363   uint max_vlen = 0;
2364   bool can_process_post_loop = (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop());
2365 
2366   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop before create_reserve_version_of_loop&quot;); print_loop(true);})
2367 
2368   CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());
2369 
2370   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;SWPointer::output: print loop after create_reserve_version_of_loop&quot;); print_loop(true);})
2371 
2372   if (do_reserve_copy() &amp;&amp; !make_reversable.has_reserved()) {
2373     NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: loop was not reserved correctly, exiting SuperWord&quot;);})
2374     return;
2375   }
2376 
2377   for (int i = 0; i &lt; _block.length(); i++) {
2378     Node* n = _block.at(i);
2379     Node_List* p = my_pack(n);
2380     if (p &amp;&amp; n == executed_last(p)) {
2381       uint vlen = p-&gt;size();
2382       uint vlen_in_bytes = 0;
2383       Node* vn = NULL;
2384       Node* low_adr = p-&gt;at(0);
2385       Node* first   = executed_first(p);
2386       if (can_process_post_loop) {
2387         // override vlen with the main loops vector length
2388         vlen = cl-&gt;slp_max_unroll();
2389       }
2390       NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d executed first, %d executed last in pack&quot;, first-&gt;_idx, n-&gt;_idx); print_pack(p);})
2391       int   opc = n-&gt;Opcode();
2392       if (n-&gt;is_Load()) {
2393         Node* ctl = n-&gt;in(MemNode::Control);
2394         Node* mem = first-&gt;in(MemNode::Memory);
2395         SWPointer p1(n-&gt;as_Mem(), this, NULL, false);
2396         // Identify the memory dependency for the new loadVector node by
2397         // walking up through memory chain.
2398         // This is done to give flexibility to the new loadVector node so that
2399         // it can move above independent storeVector nodes.
2400         while (mem-&gt;is_StoreVector()) {
2401           SWPointer p2(mem-&gt;as_Mem(), this, NULL, false);
2402           int cmp = p1.cmp(p2);
2403           if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {
2404             mem = mem-&gt;in(MemNode::Memory);
2405           } else {
2406             break; // dependent memory
2407           }
2408         }
2409         Node* adr = low_adr-&gt;in(MemNode::Address);
2410         const TypePtr* atyp = n-&gt;adr_type();
2411         vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));
2412         vlen_in_bytes = vn-&gt;as_LoadVector()-&gt;memory_size();
2413       } else if (n-&gt;is_Store()) {
2414         // Promote value to be stored to vector
2415         Node* val = vector_opd(p, MemNode::ValueIn);
2416         if (val == NULL) {
2417           if (do_reserve_copy()) {
2418             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: val should not be NULL, exiting SuperWord&quot;);})
2419             return; //and reverse to backup IG
2420           }
2421           ShouldNotReachHere();
2422         }
2423 
2424         Node* ctl = n-&gt;in(MemNode::Control);
2425         Node* mem = first-&gt;in(MemNode::Memory);
2426         Node* adr = low_adr-&gt;in(MemNode::Address);
2427         const TypePtr* atyp = n-&gt;adr_type();
2428         vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);
2429         vlen_in_bytes = vn-&gt;as_StoreVector()-&gt;memory_size();
2430       } else if (VectorNode::is_roundopD(n)) {
2431         Node* in1 = vector_opd(p, 1);
2432         Node* in2 = low_adr-&gt;in(2);
2433         assert(in2-&gt;is_Con(), &quot;Constant rounding mode expected.&quot;);
2434         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2435         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2436       } else if (VectorNode::is_muladds2i(n)) {
2437         assert(n-&gt;req() == 5u, &quot;MulAddS2I should have 4 operands.&quot;);
2438         Node* in1 = vector_opd(p, 1);
2439         Node* in2 = vector_opd(p, 2);
2440         vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2441         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2442       } else if (n-&gt;req() == 3 &amp;&amp; !is_cmov_pack(p)) {
2443         // Promote operands to vector
2444         Node* in1 = NULL;
2445         bool node_isa_reduction = n-&gt;is_reduction();
2446         if (node_isa_reduction) {
2447           // the input to the first reduction operation is retained
2448           in1 = low_adr-&gt;in(1);
2449         } else {
2450           in1 = vector_opd(p, 1);
2451           if (in1 == NULL) {
2452             if (do_reserve_copy()) {
2453               NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in1 should not be NULL, exiting SuperWord&quot;);})
2454               return; //and reverse to backup IG
2455             }
2456             ShouldNotReachHere();
2457           }
2458         }
2459         Node* in2 = vector_opd(p, 2);
2460         if (in2 == NULL) {
2461           if (do_reserve_copy()) {
2462             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: in2 should not be NULL, exiting SuperWord&quot;);})
2463             return; //and reverse to backup IG
2464           }
2465           ShouldNotReachHere();
2466         }
2467         if (VectorNode::is_invariant_vector(in1) &amp;&amp; (node_isa_reduction == false) &amp;&amp; (n-&gt;is_Add() || n-&gt;is_Mul())) {
2468           // Move invariant vector input into second position to avoid register spilling.
2469           Node* tmp = in1;
2470           in1 = in2;
2471           in2 = tmp;
2472         }
2473         if (node_isa_reduction) {
2474           const Type *arith_type = n-&gt;bottom_type();
2475           vn = ReductionNode::make(opc, NULL, in1, in2, arith_type-&gt;basic_type());
2476           if (in2-&gt;is_Load()) {
2477             vlen_in_bytes = in2-&gt;as_LoadVector()-&gt;memory_size();
2478           } else {
2479             vlen_in_bytes = in2-&gt;as_Vector()-&gt;length_in_bytes();
2480           }
2481         } else {
2482           vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));
2483           vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2484         }
2485       } else if (opc == Op_SqrtF || opc == Op_SqrtD ||
2486                  opc == Op_AbsF || opc == Op_AbsD ||
2487                  opc == Op_AbsI || opc == Op_AbsL ||
2488                  opc == Op_NegF || opc == Op_NegD ||
2489                  opc == Op_PopCountI) {
2490         assert(n-&gt;req() == 2, &quot;only one input expected&quot;);
2491         Node* in = vector_opd(p, 1);
2492         vn = VectorNode::make(opc, in, NULL, vlen, velt_basic_type(n));
2493         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2494       } else if (is_cmov_pack(p)) {
2495         if (can_process_post_loop) {
2496           // do not refactor of flow in post loop context
2497           return;
2498         }
2499         if (!n-&gt;is_CMove()) {
2500           continue;
2501         }
2502         // place here CMoveVDNode
2503         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: print before CMove vectorization&quot;); print_loop(false);})
2504         Node* bol = n-&gt;in(CMoveNode::Condition);
2505         if (!bol-&gt;is_Bool() &amp;&amp; bol-&gt;Opcode() == Op_ExtractI &amp;&amp; bol-&gt;req() &gt; 1 ) {
2506           NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print_cr(&quot;SWPointer::output: %d is not Bool node, trying its in(1) node %d&quot;, bol-&gt;_idx, bol-&gt;in(1)-&gt;_idx); bol-&gt;dump(); bol-&gt;in(1)-&gt;dump();})
2507           bol = bol-&gt;in(1); //may be ExtractNode
2508         }
2509 
2510         assert(bol-&gt;is_Bool(), &quot;should be BoolNode - too late to bail out!&quot;);
2511         if (!bol-&gt;is_Bool()) {
2512           if (do_reserve_copy()) {
2513             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: expected %d bool node, exiting SuperWord&quot;, bol-&gt;_idx); bol-&gt;dump();})
2514             return; //and reverse to backup IG
2515           }
2516           ShouldNotReachHere();
2517         }
2518 
2519         int cond = (int)bol-&gt;as_Bool()-&gt;_test._test;
2520         Node* in_cc  = _igvn.intcon(cond);
2521         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created intcon in_cc node %d&quot;, in_cc-&gt;_idx); in_cc-&gt;dump();})
2522         Node* cc = bol-&gt;clone();
2523         cc-&gt;set_req(1, in_cc);
2524         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created bool cc node %d&quot;, cc-&gt;_idx); cc-&gt;dump();})
2525 
2526         Node* src1 = vector_opd(p, 2); //2=CMoveNode::IfFalse
2527         if (src1 == NULL) {
2528           if (do_reserve_copy()) {
2529             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src1 should not be NULL, exiting SuperWord&quot;);})
2530             return; //and reverse to backup IG
2531           }
2532           ShouldNotReachHere();
2533         }
2534         Node* src2 = vector_opd(p, 3); //3=CMoveNode::IfTrue
2535         if (src2 == NULL) {
2536           if (do_reserve_copy()) {
2537             NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: src2 should not be NULL, exiting SuperWord&quot;);})
2538             return; //and reverse to backup IG
2539           }
2540           ShouldNotReachHere();
2541         }
2542         BasicType bt = velt_basic_type(n);
2543         const TypeVect* vt = TypeVect::make(bt, vlen);
2544         assert(bt == T_FLOAT || bt == T_DOUBLE, &quot;Only vectorization for FP cmovs is supported&quot;);
2545         if (bt == T_FLOAT) {
2546           vn = new CMoveVFNode(cc, src1, src2, vt);
2547         } else {
2548           assert(bt == T_DOUBLE, &quot;Expected double&quot;);
2549           vn = new CMoveVDNode(cc, src1, src2, vt);
2550         }
2551         NOT_PRODUCT(if(is_trace_cmov()) {tty-&gt;print(&quot;SWPointer::output: created new CMove node %d: &quot;, vn-&gt;_idx); vn-&gt;dump();})
2552       } else if (opc == Op_FmaD || opc == Op_FmaF) {
2553         // Promote operands to vector
2554         Node* in1 = vector_opd(p, 1);
2555         Node* in2 = vector_opd(p, 2);
2556         Node* in3 = vector_opd(p, 3);
2557         vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));
2558         vlen_in_bytes = vn-&gt;as_Vector()-&gt;length_in_bytes();
2559       } else {
2560         if (do_reserve_copy()) {
2561           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: ShouldNotReachHere, exiting SuperWord&quot;);})
2562           return; //and reverse to backup IG
2563         }
2564         ShouldNotReachHere();
2565       }
2566 
2567       assert(vn != NULL, &quot;sanity&quot;);
2568       if (vn == NULL) {
2569         if (do_reserve_copy()){
2570           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;SWPointer::output: got NULL node, cannot proceed, exiting SuperWord&quot;);})
2571           return; //and reverse to backup IG
2572         }
2573         ShouldNotReachHere();
2574       }
2575 
2576       _block.at_put(i, vn);
2577       _igvn.register_new_node_with_optimizer(vn);
2578       _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(p-&gt;at(0)));
2579       for (uint j = 0; j &lt; p-&gt;size(); j++) {
2580         Node* pm = p-&gt;at(j);
2581         _igvn.replace_node(pm, vn);
2582       }
2583       _igvn._worklist.push(vn);
2584 
2585       if (can_process_post_loop) {
2586         // first check if the vector size if the maximum vector which we can use on the machine,
2587         // other vector size have reduced values for predicated data mapping.
2588         if (vlen_in_bytes != (uint)MaxVectorSize) {
2589           return;
2590         }
2591       }
2592 
2593       if (vlen_in_bytes &gt;= max_vlen_in_bytes &amp;&amp; vlen &gt; max_vlen) {
2594         max_vlen = vlen;
2595         max_vlen_in_bytes = vlen_in_bytes;
2596       }
2597 #ifdef ASSERT
2598       if (TraceNewVectors) {
2599         tty-&gt;print(&quot;new Vector node: &quot;);
2600         vn-&gt;dump();
2601       }
2602 #endif
2603     }
2604   }//for (int i = 0; i &lt; _block.length(); i++)
2605 
2606   if (max_vlen_in_bytes &gt; C-&gt;max_vector_size()) {
2607     C-&gt;set_max_vector_size(max_vlen_in_bytes);
2608   }
2609   if (max_vlen_in_bytes &gt; 0) {
2610     cl-&gt;mark_loop_vectorized();
2611   }
2612 
2613   if (SuperWordLoopUnrollAnalysis) {
2614     if (cl-&gt;has_passed_slp()) {
2615       uint slp_max_unroll_factor = cl-&gt;slp_max_unroll();
2616       if (slp_max_unroll_factor == max_vlen) {
2617         if (TraceSuperWordLoopUnrollAnalysis) {
2618           tty-&gt;print_cr(&quot;vector loop(unroll=%d, len=%d)\n&quot;, max_vlen, max_vlen_in_bytes*BitsPerByte);
2619         }
2620 
2621         // For atomic unrolled loops which are vector mapped, instigate more unrolling
2622         cl-&gt;set_notpassed_slp();
2623         if (cl-&gt;is_main_loop()) {
2624           // if vector resources are limited, do not allow additional unrolling, also
2625           // do not unroll more on pure vector loops which were not reduced so that we can
2626           // program the post loop to single iteration execution.
2627           if (FLOATPRESSURE &gt; 8) {
2628             C-&gt;set_major_progress();
2629             cl-&gt;mark_do_unroll_only();
2630           }
2631         }
2632 
2633         if (do_reserve_copy()) {
2634           if (can_process_post_loop) {
2635             // Now create the difference of trip and limit and use it as our mask index.
2636             // Note: We limited the unroll of the vectorized loop so that
2637             //       only vlen-1 size iterations can remain to be mask programmed.
2638             Node *incr = cl-&gt;incr();
2639             SubINode *index = new SubINode(cl-&gt;limit(), cl-&gt;init_trip());
2640             _igvn.register_new_node_with_optimizer(index);
2641             SetVectMaskINode  *mask = new SetVectMaskINode(_phase-&gt;get_ctrl(cl-&gt;init_trip()), index);
2642             _igvn.register_new_node_with_optimizer(mask);
2643             // make this a single iteration loop
2644             AddINode *new_incr = new AddINode(incr-&gt;in(1), mask);
2645             _igvn.register_new_node_with_optimizer(new_incr);
2646             _phase-&gt;set_ctrl(new_incr, _phase-&gt;get_ctrl(incr));
2647             _igvn.replace_node(incr, new_incr);
2648             cl-&gt;mark_is_multiversioned();
2649             cl-&gt;loopexit()-&gt;add_flag(Node::Flag_has_vector_mask_set);
2650           }
2651         }
2652       }
2653     }
2654   }
2655 
2656   if (do_reserve_copy()) {
2657     make_reversable.use_new();
2658   }
2659   NOT_PRODUCT(if(is_trace_loop_reverse()) {tty-&gt;print_cr(&quot;\n Final loop after SuperWord&quot;); print_loop(true);})
2660   return;
2661 }
2662 
2663 //------------------------------vector_opd---------------------------
2664 // Create a vector operand for the nodes in pack p for operand: in(opd_idx)
2665 Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {
2666   Node* p0 = p-&gt;at(0);
2667   uint vlen = p-&gt;size();
2668   Node* opd = p0-&gt;in(opd_idx);
2669   CountedLoopNode *cl = lpt()-&gt;_head-&gt;as_CountedLoop();
2670 
2671   if (PostLoopMultiversioning &amp;&amp; Matcher::has_predicated_vectors() &amp;&amp; cl-&gt;is_post_loop()) {
2672     // override vlen with the main loops vector length
2673     vlen = cl-&gt;slp_max_unroll();
2674   }
2675 
2676   if (same_inputs(p, opd_idx)) {
2677     if (opd-&gt;is_Vector() || opd-&gt;is_LoadVector()) {
2678       assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), &quot;shift&#39;s count can&#39;t be vector&quot;);
2679       if (opd_idx == 2 &amp;&amp; VectorNode::is_shift(p0)) {
2680         NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;shift&#39;s count can&#39;t be vector&quot;);})
2681         return NULL;
2682       }
2683       return opd; // input is matching vector
2684     }
2685     if ((opd_idx == 2) &amp;&amp; VectorNode::is_shift(p0)) {
2686       Compile* C = _phase-&gt;C;
2687       Node* cnt = opd;
2688       // Vector instructions do not mask shift count, do it here.
2689       juint mask = (p0-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
2690       const TypeInt* t = opd-&gt;find_int_type();
2691       if (t != NULL &amp;&amp; t-&gt;is_con()) {
2692         juint shift = t-&gt;get_con();
2693         if (shift &gt; mask) { // Unsigned cmp
2694           cnt = ConNode::make(TypeInt::make(shift &amp; mask));
2695         }
2696       } else {
2697         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
2698           cnt = ConNode::make(TypeInt::make(mask));
2699           _igvn.register_new_node_with_optimizer(cnt);
2700           cnt = new AndINode(opd, cnt);
2701           _igvn.register_new_node_with_optimizer(cnt);
2702           _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2703         }
2704         assert(opd-&gt;bottom_type()-&gt;isa_int(), &quot;int type only&quot;);
2705         if (!opd-&gt;bottom_type()-&gt;isa_int()) {
2706           NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should be int type only&quot;);})
2707           return NULL;
2708         }
2709       }
2710       // Move shift count into vector register.
2711       cnt = VectorNode::shift_count(p0, cnt, vlen, velt_basic_type(p0));
2712       _igvn.register_new_node_with_optimizer(cnt);
2713       _phase-&gt;set_ctrl(cnt, _phase-&gt;get_ctrl(opd));
2714       return cnt;
2715     }
2716     assert(!opd-&gt;is_StoreVector(), &quot;such vector is not expected here&quot;);
2717     if (opd-&gt;is_StoreVector()) {
2718       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;StoreVector is not expected here&quot;);})
2719       return NULL;
2720     }
2721     // Convert scalar input to vector with the same number of elements as
2722     // p0&#39;s vector. Use p0&#39;s type because size of operand&#39;s container in
2723     // vector should match p0&#39;s size regardless operand&#39;s size.
2724     const Type* p0_t = velt_type(p0);
2725     VectorNode* vn = VectorNode::scalar2vector(opd, vlen, p0_t);
2726 
2727     _igvn.register_new_node_with_optimizer(vn);
2728     _phase-&gt;set_ctrl(vn, _phase-&gt;get_ctrl(opd));
2729 #ifdef ASSERT
2730     if (TraceNewVectors) {
2731       tty-&gt;print(&quot;new Vector node: &quot;);
2732       vn-&gt;dump();
2733     }
2734 #endif
2735     return vn;
2736   }
2737 
2738   // Insert pack operation
2739   BasicType bt = velt_basic_type(p0);
2740   PackNode* pk = PackNode::make(opd, vlen, bt);
2741   DEBUG_ONLY( const BasicType opd_bt = opd-&gt;bottom_type()-&gt;basic_type(); )
2742 
2743   for (uint i = 1; i &lt; vlen; i++) {
2744     Node* pi = p-&gt;at(i);
2745     Node* in = pi-&gt;in(opd_idx);
2746     assert(my_pack(in) == NULL, &quot;Should already have been unpacked&quot;);
2747     if (my_pack(in) != NULL) {
2748       NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty-&gt;print_cr(&quot;Should already have been unpacked&quot;);})
2749       return NULL;
2750     }
2751     assert(opd_bt == in-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2752     pk-&gt;add_opd(in);
2753     if (VectorNode::is_muladds2i(pi)) {
2754       Node* in2 = pi-&gt;in(opd_idx + 2);
2755       assert(my_pack(in2) == NULL, &quot;Should already have been unpacked&quot;);
2756       if (my_pack(in2) != NULL) {
2757         NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty-&gt;print_cr(&quot;Should already have been unpacked&quot;); })
2758           return NULL;
2759       }
2760       assert(opd_bt == in2-&gt;bottom_type()-&gt;basic_type(), &quot;all same type&quot;);
2761       pk-&gt;add_opd(in2);
2762     }
2763   }
2764   _igvn.register_new_node_with_optimizer(pk);
2765   _phase-&gt;set_ctrl(pk, _phase-&gt;get_ctrl(opd));
2766 #ifdef ASSERT
2767   if (TraceNewVectors) {
2768     tty-&gt;print(&quot;new Vector node: &quot;);
2769     pk-&gt;dump();
2770   }
2771 #endif
2772   return pk;
2773 }
2774 
2775 //------------------------------insert_extracts---------------------------
2776 // If a use of pack p is not a vector use, then replace the
2777 // use with an extract operation.
2778 void SuperWord::insert_extracts(Node_List* p) {
2779   if (p-&gt;at(0)-&gt;is_Store()) return;
2780   assert(_n_idx_list.is_empty(), &quot;empty (node,index) list&quot;);
2781 
2782   // Inspect each use of each pack member.  For each use that is
2783   // not a vector use, replace the use with an extract operation.
2784 
2785   for (uint i = 0; i &lt; p-&gt;size(); i++) {
2786     Node* def = p-&gt;at(i);
2787     for (DUIterator_Fast jmax, j = def-&gt;fast_outs(jmax); j &lt; jmax; j++) {
2788       Node* use = def-&gt;fast_out(j);
2789       for (uint k = 0; k &lt; use-&gt;req(); k++) {
2790         Node* n = use-&gt;in(k);
2791         if (def == n) {
2792           Node_List* u_pk = my_pack(use);
2793           if ((u_pk == NULL || !is_cmov_pack(u_pk) || use-&gt;is_CMove()) &amp;&amp; !is_vector_use(use, k)) {
2794               _n_idx_list.push(use, k);
2795           }
2796         }
2797       }
2798     }
2799   }
2800 
2801   while (_n_idx_list.is_nonempty()) {
2802     Node* use = _n_idx_list.node();
2803     int   idx = _n_idx_list.index();
2804     _n_idx_list.pop();
2805     Node* def = use-&gt;in(idx);
2806 
2807     if (def-&gt;is_reduction()) continue;
2808 
2809     // Insert extract operation
2810     _igvn.hash_delete(def);
2811     int def_pos = alignment(def) / data_size(def);
2812 
2813     Node* ex = ExtractNode::make(def, def_pos, velt_basic_type(def));
2814     _igvn.register_new_node_with_optimizer(ex);
2815     _phase-&gt;set_ctrl(ex, _phase-&gt;get_ctrl(def));
2816     _igvn.replace_input_of(use, idx, ex);
2817     _igvn._worklist.push(def);
2818 
2819     bb_insert_after(ex, bb_idx(def));
2820     set_velt_type(ex, velt_type(def));
2821   }
2822 }
2823 
2824 //------------------------------is_vector_use---------------------------
2825 // Is use-&gt;in(u_idx) a vector use?
2826 bool SuperWord::is_vector_use(Node* use, int u_idx) {
2827   Node_List* u_pk = my_pack(use);
2828   if (u_pk == NULL) return false;
2829   if (use-&gt;is_reduction()) return true;
2830   Node* def = use-&gt;in(u_idx);
2831   Node_List* d_pk = my_pack(def);
2832   if (d_pk == NULL) {
2833     // check for scalar promotion
2834     Node* n = u_pk-&gt;at(0)-&gt;in(u_idx);
2835     for (uint i = 1; i &lt; u_pk-&gt;size(); i++) {
2836       if (u_pk-&gt;at(i)-&gt;in(u_idx) != n) return false;
2837     }
2838     return true;
2839   }
2840   if (VectorNode::is_muladds2i(use)) {
2841     // MulAddS2I takes shorts and produces ints - hence the special checks
2842     // on alignment and size.
2843     if (u_pk-&gt;size() * 2 != d_pk-&gt;size()) {
2844       return false;
2845     }
2846     for (uint i = 0; i &lt; MIN2(d_pk-&gt;size(), u_pk-&gt;size()); i++) {
2847       Node* ui = u_pk-&gt;at(i);
2848       Node* di = d_pk-&gt;at(i);
2849       if (alignment(ui) != alignment(di) * 2) {
2850         return false;
2851       }
2852     }
2853     return true;
2854   }
2855   if (u_pk-&gt;size() != d_pk-&gt;size())
2856     return false;
2857   for (uint i = 0; i &lt; u_pk-&gt;size(); i++) {
2858     Node* ui = u_pk-&gt;at(i);
2859     Node* di = d_pk-&gt;at(i);
2860     if (ui-&gt;in(u_idx) != di || alignment(ui) != alignment(di))
2861       return false;
2862   }
2863   return true;
2864 }
2865 
2866 //------------------------------construct_bb---------------------------
2867 // Construct reverse postorder list of block members
2868 bool SuperWord::construct_bb() {
2869   Node* entry = bb();
2870 
2871   assert(_stk.length() == 0,            &quot;stk is empty&quot;);
2872   assert(_block.length() == 0,          &quot;block is empty&quot;);
2873   assert(_data_entry.length() == 0,     &quot;data_entry is empty&quot;);
2874   assert(_mem_slice_head.length() == 0, &quot;mem_slice_head is empty&quot;);
2875   assert(_mem_slice_tail.length() == 0, &quot;mem_slice_tail is empty&quot;);
2876 
2877   // Find non-control nodes with no inputs from within block,
2878   // create a temporary map from node _idx to bb_idx for use
2879   // by the visited and post_visited sets,
2880   // and count number of nodes in block.
2881   int bb_ct = 0;
2882   for (uint i = 0; i &lt; lpt()-&gt;_body.size(); i++) {
2883     Node *n = lpt()-&gt;_body.at(i);
2884     set_bb_idx(n, i); // Create a temporary map
2885     if (in_bb(n)) {
2886       if (n-&gt;is_LoadStore() || n-&gt;is_MergeMem() ||
2887           (n-&gt;is_Proj() &amp;&amp; !n-&gt;as_Proj()-&gt;is_CFG())) {
2888         // Bailout if the loop has LoadStore, MergeMem or data Proj
2889         // nodes. Superword optimization does not work with them.
2890         return false;
2891       }
2892       bb_ct++;
2893       if (!n-&gt;is_CFG()) {
2894         bool found = false;
2895         for (uint j = 0; j &lt; n-&gt;req(); j++) {
2896           Node* def = n-&gt;in(j);
2897           if (def &amp;&amp; in_bb(def)) {
2898             found = true;
2899             break;
2900           }
2901         }
2902         if (!found) {
2903           assert(n != entry, &quot;can&#39;t be entry&quot;);
2904           _data_entry.push(n);
2905         }
2906       }
2907     }
2908   }
2909 
2910   // Find memory slices (head and tail)
2911   for (DUIterator_Fast imax, i = lp()-&gt;fast_outs(imax); i &lt; imax; i++) {
2912     Node *n = lp()-&gt;fast_out(i);
2913     if (in_bb(n) &amp;&amp; (n-&gt;is_Phi() &amp;&amp; n-&gt;bottom_type() == Type::MEMORY)) {
2914       Node* n_tail  = n-&gt;in(LoopNode::LoopBackControl);
2915       if (n_tail != n-&gt;in(LoopNode::EntryControl)) {
2916         if (!n_tail-&gt;is_Mem()) {
2917           assert(n_tail-&gt;is_Mem(), &quot;unexpected node for memory slice: %s&quot;, n_tail-&gt;Name());
2918           return false; // Bailout
2919         }
2920         _mem_slice_head.push(n);
2921         _mem_slice_tail.push(n_tail);
2922       }
2923     }
2924   }
2925 
2926   // Create an RPO list of nodes in block
2927 
2928   visited_clear();
2929   post_visited_clear();
2930 
2931   // Push all non-control nodes with no inputs from within block, then control entry
2932   for (int j = 0; j &lt; _data_entry.length(); j++) {
2933     Node* n = _data_entry.at(j);
2934     visited_set(n);
2935     _stk.push(n);
2936   }
2937   visited_set(entry);
2938   _stk.push(entry);
2939 
2940   // Do a depth first walk over out edges
2941   int rpo_idx = bb_ct - 1;
2942   int size;
2943   int reduction_uses = 0;
2944   while ((size = _stk.length()) &gt; 0) {
2945     Node* n = _stk.top(); // Leave node on stack
2946     if (!visited_test_set(n)) {
2947       // forward arc in graph
2948     } else if (!post_visited_test(n)) {
2949       // cross or back arc
2950       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2951         Node *use = n-&gt;fast_out(i);
2952         if (in_bb(use) &amp;&amp; !visited_test(use) &amp;&amp;
2953             // Don&#39;t go around backedge
2954             (!use-&gt;is_Phi() || n == entry)) {
2955           if (use-&gt;is_reduction()) {
2956             // First see if we can map the reduction on the given system we are on, then
2957             // make a data entry operation for each reduction we see.
2958             BasicType bt = use-&gt;bottom_type()-&gt;basic_type();
2959             if (ReductionNode::implemented(use-&gt;Opcode(), Matcher::min_vector_size(bt), bt)) {
2960               reduction_uses++;
2961             }
2962           }
2963           _stk.push(use);
2964         }
2965       }
2966       if (_stk.length() == size) {
2967         // There were no additional uses, post visit node now
2968         _stk.pop(); // Remove node from stack
2969         assert(rpo_idx &gt;= 0, &quot;&quot;);
2970         _block.at_put_grow(rpo_idx, n);
2971         rpo_idx--;
2972         post_visited_set(n);
2973         assert(rpo_idx &gt;= 0 || _stk.is_empty(), &quot;&quot;);
2974       }
2975     } else {
2976       _stk.pop(); // Remove post-visited node from stack
2977     }
2978   }//while
2979 
2980   int ii_current = -1;
2981   unsigned int load_idx = (unsigned int)-1;
2982   _ii_order.clear();
2983   // Create real map of block indices for nodes
2984   for (int j = 0; j &lt; _block.length(); j++) {
2985     Node* n = _block.at(j);
2986     set_bb_idx(n, j);
2987     if (_do_vector_loop &amp;&amp; n-&gt;is_Load()) {
2988       if (ii_current == -1) {
2989         ii_current = _clone_map.gen(n-&gt;_idx);
2990         _ii_order.push(ii_current);
2991         load_idx = _clone_map.idx(n-&gt;_idx);
2992       } else if (_clone_map.idx(n-&gt;_idx) == load_idx &amp;&amp; _clone_map.gen(n-&gt;_idx) != ii_current) {
2993         ii_current = _clone_map.gen(n-&gt;_idx);
2994         _ii_order.push(ii_current);
2995       }
2996     }
2997   }//for
2998 
2999   // Ensure extra info is allocated.
3000   initialize_bb();
3001 
3002 #ifndef PRODUCT
3003   if (_vector_loop_debug &amp;&amp; _ii_order.length() &gt; 0) {
3004     tty-&gt;print(&quot;SuperWord::construct_bb: List of generations: &quot;);
3005     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
3006       tty-&gt;print(&quot;  %d:%d&quot;, jj, _ii_order.at(jj));
3007     }
3008     tty-&gt;print_cr(&quot; &quot;);
3009   }
3010   if (TraceSuperWord) {
3011     print_bb();
3012     tty-&gt;print_cr(&quot;\ndata entry nodes: %s&quot;, _data_entry.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3013     for (int m = 0; m &lt; _data_entry.length(); m++) {
3014       tty-&gt;print(&quot;%3d &quot;, m);
3015       _data_entry.at(m)-&gt;dump();
3016     }
3017     tty-&gt;print_cr(&quot;\nmemory slices: %s&quot;, _mem_slice_head.length() &gt; 0 ? &quot;&quot; : &quot;NONE&quot;);
3018     for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
3019       tty-&gt;print(&quot;%3d &quot;, m); _mem_slice_head.at(m)-&gt;dump();
3020       tty-&gt;print(&quot;    &quot;);    _mem_slice_tail.at(m)-&gt;dump();
3021     }
3022   }
3023 #endif
3024   assert(rpo_idx == -1 &amp;&amp; bb_ct == _block.length(), &quot;all block members found&quot;);
3025   return (_mem_slice_head.length() &gt; 0) || (reduction_uses &gt; 0) || (_data_entry.length() &gt; 0);
3026 }
3027 
3028 //------------------------------initialize_bb---------------------------
3029 // Initialize per node info
3030 void SuperWord::initialize_bb() {
3031   Node* last = _block.at(_block.length() - 1);
3032   grow_node_info(bb_idx(last));
3033 }
3034 
3035 //------------------------------bb_insert_after---------------------------
3036 // Insert n into block after pos
3037 void SuperWord::bb_insert_after(Node* n, int pos) {
3038   int n_pos = pos + 1;
3039   // Make room
3040   for (int i = _block.length() - 1; i &gt;= n_pos; i--) {
3041     _block.at_put_grow(i+1, _block.at(i));
3042   }
3043   for (int j = _node_info.length() - 1; j &gt;= n_pos; j--) {
3044     _node_info.at_put_grow(j+1, _node_info.at(j));
3045   }
3046   // Set value
3047   _block.at_put_grow(n_pos, n);
3048   _node_info.at_put_grow(n_pos, SWNodeInfo::initial);
3049   // Adjust map from node-&gt;_idx to _block index
3050   for (int i = n_pos; i &lt; _block.length(); i++) {
3051     set_bb_idx(_block.at(i), i);
3052   }
3053 }
3054 
3055 //------------------------------compute_max_depth---------------------------
3056 // Compute max depth for expressions from beginning of block
3057 // Use to prune search paths during test for independence.
3058 void SuperWord::compute_max_depth() {
3059   int ct = 0;
3060   bool again;
3061   do {
3062     again = false;
3063     for (int i = 0; i &lt; _block.length(); i++) {
3064       Node* n = _block.at(i);
3065       if (!n-&gt;is_Phi()) {
3066         int d_orig = depth(n);
3067         int d_in   = 0;
3068         for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {
3069           Node* pred = preds.current();
3070           if (in_bb(pred)) {
3071             d_in = MAX2(d_in, depth(pred));
3072           }
3073         }
3074         if (d_in + 1 != d_orig) {
3075           set_depth(n, d_in + 1);
3076           again = true;
3077         }
3078       }
3079     }
3080     ct++;
3081   } while (again);
3082 
3083   if (TraceSuperWord &amp;&amp; Verbose) {
3084     tty-&gt;print_cr(&quot;compute_max_depth iterated: %d times&quot;, ct);
3085   }
3086 }
3087 
3088 //-------------------------compute_vector_element_type-----------------------
3089 // Compute necessary vector element type for expressions
3090 // This propagates backwards a narrower integer type when the
3091 // upper bits of the value are not needed.
3092 // Example:  char a,b,c;  a = b + c;
3093 // Normally the type of the add is integer, but for packed character
3094 // operations the type of the add needs to be char.
3095 void SuperWord::compute_vector_element_type() {
3096   if (TraceSuperWord &amp;&amp; Verbose) {
3097     tty-&gt;print_cr(&quot;\ncompute_velt_type:&quot;);
3098   }
3099 
3100   // Initial type
3101   for (int i = 0; i &lt; _block.length(); i++) {
3102     Node* n = _block.at(i);
3103     set_velt_type(n, container_type(n));
3104   }
3105 
3106   // Propagate integer narrowed type backwards through operations
3107   // that don&#39;t depend on higher order bits
3108   for (int i = _block.length() - 1; i &gt;= 0; i--) {
3109     Node* n = _block.at(i);
3110     // Only integer types need be examined
3111     const Type* vtn = velt_type(n);
3112     if (vtn-&gt;basic_type() == T_INT) {
3113       uint start, end;
3114       VectorNode::vector_operands(n, &amp;start, &amp;end);
3115 
3116       for (uint j = start; j &lt; end; j++) {
3117         Node* in  = n-&gt;in(j);
3118         // Don&#39;t propagate through a memory
3119         if (!in-&gt;is_Mem() &amp;&amp; in_bb(in) &amp;&amp; velt_type(in)-&gt;basic_type() == T_INT &amp;&amp;
3120             data_size(n) &lt; data_size(in)) {
3121           bool same_type = true;
3122           for (DUIterator_Fast kmax, k = in-&gt;fast_outs(kmax); k &lt; kmax; k++) {
3123             Node *use = in-&gt;fast_out(k);
3124             if (!in_bb(use) || !same_velt_type(use, n)) {
3125               same_type = false;
3126               break;
3127             }
3128           }
3129           if (same_type) {
3130             // For right shifts of small integer types (bool, byte, char, short)
3131             // we need precise information about sign-ness. Only Load nodes have
3132             // this information because Store nodes are the same for signed and
3133             // unsigned values. And any arithmetic operation after a load may
3134             // expand a value to signed Int so such right shifts can&#39;t be used
3135             // because vector elements do not have upper bits of Int.
3136             const Type* vt = vtn;
3137             if (VectorNode::is_shift(in)) {
3138               Node* load = in-&gt;in(1);
3139               if (load-&gt;is_Load() &amp;&amp; in_bb(load) &amp;&amp; (velt_type(load)-&gt;basic_type() == T_INT)) {
3140                 vt = velt_type(load);
3141               } else if (in-&gt;Opcode() != Op_LShiftI) {
3142                 // Widen type to Int to avoid creation of right shift vector
3143                 // (align + data_size(s1) check in stmts_can_pack() will fail).
3144                 // Note, left shifts work regardless type.
3145                 vt = TypeInt::INT;
3146               }
3147             }
3148             set_velt_type(in, vt);
3149           }
3150         }
3151       }
3152     }
3153   }
3154 #ifndef PRODUCT
3155   if (TraceSuperWord &amp;&amp; Verbose) {
3156     for (int i = 0; i &lt; _block.length(); i++) {
3157       Node* n = _block.at(i);
3158       velt_type(n)-&gt;dump();
3159       tty-&gt;print(&quot;\t&quot;);
3160       n-&gt;dump();
3161     }
3162   }
3163 #endif
3164 }
3165 
3166 //------------------------------memory_alignment---------------------------
3167 // Alignment within a vector memory reference
3168 int SuperWord::memory_alignment(MemNode* s, int iv_adjust) {
3169   #ifndef PRODUCT
3170     if(TraceSuperWord &amp;&amp; Verbose) {
3171       tty-&gt;print(&quot;SuperWord::memory_alignment within a vector memory reference for %d:  &quot;, s-&gt;_idx); s-&gt;dump();
3172     }
3173   #endif
3174   NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)
3175   SWPointer p(s, this, NULL, false);
3176   if (!p.valid()) {
3177     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print(&quot;SWPointer::memory_alignment: SWPointer p invalid, return bottom_align&quot;);)
3178     return bottom_align;
3179   }
3180   int vw = get_vw_bytes_special(s);
3181   if (vw &lt; 2) {
3182     NOT_PRODUCT(if(is_trace_alignment()) tty-&gt;print_cr(&quot;SWPointer::memory_alignment: vector_width_in_bytes &lt; 2, return bottom_align&quot;);)
3183     return bottom_align; // No vectors for this type
3184   }
3185   int offset  = p.offset_in_bytes();
3186   offset     += iv_adjust*p.memory_size();
3187   int off_rem = offset % vw;
3188   int off_mod = off_rem &gt;= 0 ? off_rem : off_rem + vw;
3189   if (TraceSuperWord &amp;&amp; Verbose) {
3190     tty-&gt;print_cr(&quot;SWPointer::memory_alignment: off_rem = %d, off_mod = %d&quot;, off_rem, off_mod);
3191   }
3192   return off_mod;
3193 }
3194 
3195 //---------------------------container_type---------------------------
3196 // Smallest type containing range of values
3197 const Type* SuperWord::container_type(Node* n) {
3198   if (n-&gt;is_Mem()) {
3199     BasicType bt = n-&gt;as_Mem()-&gt;memory_type();
3200     if (n-&gt;is_Store() &amp;&amp; (bt == T_CHAR)) {
3201       // Use T_SHORT type instead of T_CHAR for stored values because any
3202       // preceding arithmetic operation extends values to signed Int.
3203       bt = T_SHORT;
3204     }
3205     if (n-&gt;Opcode() == Op_LoadUB) {
3206       // Adjust type for unsigned byte loads, it is important for right shifts.
3207       // T_BOOLEAN is used because there is no basic type representing type
3208       // TypeInt::UBYTE. Use of T_BOOLEAN for vectors is fine because only
3209       // size (one byte) and sign is important.
3210       bt = T_BOOLEAN;
3211     }
3212     return Type::get_const_basic_type(bt);
3213   }
3214   const Type* t = _igvn.type(n);
3215   if (t-&gt;basic_type() == T_INT) {
3216     // A narrow type of arithmetic operations will be determined by
3217     // propagating the type of memory operations.
3218     return TypeInt::INT;
3219   }
3220   return t;
3221 }
3222 
3223 bool SuperWord::same_velt_type(Node* n1, Node* n2) {
3224   const Type* vt1 = velt_type(n1);
3225   const Type* vt2 = velt_type(n2);
3226   if (vt1-&gt;basic_type() == T_INT &amp;&amp; vt2-&gt;basic_type() == T_INT) {
3227     // Compare vectors element sizes for integer types.
3228     return data_size(n1) == data_size(n2);
3229   }
3230   return vt1 == vt2;
3231 }
3232 
3233 //------------------------------in_packset---------------------------
3234 // Are s1 and s2 in a pack pair and ordered as s1,s2?
3235 bool SuperWord::in_packset(Node* s1, Node* s2) {
3236   for (int i = 0; i &lt; _packset.length(); i++) {
3237     Node_List* p = _packset.at(i);
3238     assert(p-&gt;size() == 2, &quot;must be&quot;);
3239     if (p-&gt;at(0) == s1 &amp;&amp; p-&gt;at(p-&gt;size()-1) == s2) {
3240       return true;
3241     }
3242   }
3243   return false;
3244 }
3245 
3246 //------------------------------in_pack---------------------------
3247 // Is s in pack p?
3248 Node_List* SuperWord::in_pack(Node* s, Node_List* p) {
3249   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3250     if (p-&gt;at(i) == s) {
3251       return p;
3252     }
3253   }
3254   return NULL;
3255 }
3256 
3257 //------------------------------remove_pack_at---------------------------
3258 // Remove the pack at position pos in the packset
3259 void SuperWord::remove_pack_at(int pos) {
3260   Node_List* p = _packset.at(pos);
3261   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3262     Node* s = p-&gt;at(i);
3263     set_my_pack(s, NULL);
3264   }
3265   _packset.remove_at(pos);
3266 }
3267 
3268 void SuperWord::packset_sort(int n) {
3269   // simple bubble sort so that we capitalize with O(n) when its already sorted
3270   while (n != 0) {
3271     bool swapped = false;
3272     for (int i = 1; i &lt; n; i++) {
3273       Node_List* q_low = _packset.at(i-1);
3274       Node_List* q_i = _packset.at(i);
3275 
3276       // only swap when we find something to swap
3277       if (alignment(q_low-&gt;at(0)) &gt; alignment(q_i-&gt;at(0))) {
3278         Node_List* t = q_i;
3279         *(_packset.adr_at(i)) = q_low;
3280         *(_packset.adr_at(i-1)) = q_i;
3281         swapped = true;
3282       }
3283     }
3284     if (swapped == false) break;
3285     n--;
3286   }
3287 }
3288 
3289 //------------------------------executed_first---------------------------
3290 // Return the node executed first in pack p.  Uses the RPO block list
3291 // to determine order.
3292 Node* SuperWord::executed_first(Node_List* p) {
3293   Node* n = p-&gt;at(0);
3294   int n_rpo = bb_idx(n);
3295   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3296     Node* s = p-&gt;at(i);
3297     int s_rpo = bb_idx(s);
3298     if (s_rpo &lt; n_rpo) {
3299       n = s;
3300       n_rpo = s_rpo;
3301     }
3302   }
3303   return n;
3304 }
3305 
3306 //------------------------------executed_last---------------------------
3307 // Return the node executed last in pack p.
3308 Node* SuperWord::executed_last(Node_List* p) {
3309   Node* n = p-&gt;at(0);
3310   int n_rpo = bb_idx(n);
3311   for (uint i = 1; i &lt; p-&gt;size(); i++) {
3312     Node* s = p-&gt;at(i);
3313     int s_rpo = bb_idx(s);
3314     if (s_rpo &gt; n_rpo) {
3315       n = s;
3316       n_rpo = s_rpo;
3317     }
3318   }
3319   return n;
3320 }
3321 
3322 LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {
3323   LoadNode::ControlDependency dep = LoadNode::DependsOnlyOnTest;
3324   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3325     Node* n = p-&gt;at(i);
3326     assert(n-&gt;is_Load(), &quot;only meaningful for loads&quot;);
3327     if (!n-&gt;depends_only_on_test()) {
3328       if (n-&gt;as_Load()-&gt;has_unknown_control_dependency() &amp;&amp;
3329           dep != LoadNode::Pinned) {
3330         // Upgrade to unknown control...
3331         dep = LoadNode::UnknownControl;
3332       } else {
3333         // Otherwise, we must pin it.
3334         dep = LoadNode::Pinned;
3335       }
3336     }
3337   }
3338   return dep;
3339 }
3340 
3341 
3342 //----------------------------align_initial_loop_index---------------------------
3343 // Adjust pre-loop limit so that in main loop, a load/store reference
3344 // to align_to_ref will be a position zero in the vector.
3345 //   (iv + k) mod vector_align == 0
3346 void SuperWord::align_initial_loop_index(MemNode* align_to_ref) {
3347   CountedLoopNode *main_head = lp()-&gt;as_CountedLoop();
3348   assert(main_head-&gt;is_main_loop(), &quot;&quot;);
3349   CountedLoopEndNode* pre_end = get_pre_loop_end(main_head);
3350   assert(pre_end != NULL, &quot;we must have a correct pre-loop&quot;);
3351   Node *pre_opaq1 = pre_end-&gt;limit();
3352   assert(pre_opaq1-&gt;Opcode() == Op_Opaque1, &quot;&quot;);
3353   Opaque1Node *pre_opaq = (Opaque1Node*)pre_opaq1;
3354   Node *lim0 = pre_opaq-&gt;in(1);
3355 
3356   // Where we put new limit calculations
3357   Node *pre_ctrl = pre_end-&gt;loopnode()-&gt;in(LoopNode::EntryControl);
3358 
3359   // Ensure the original loop limit is available from the
3360   // pre-loop Opaque1 node.
3361   Node *orig_limit = pre_opaq-&gt;original_loop_limit();
3362   assert(orig_limit != NULL &amp;&amp; _igvn.type(orig_limit) != Type::TOP, &quot;&quot;);
3363 
3364   SWPointer align_to_ref_p(align_to_ref, this, NULL, false);
3365   assert(align_to_ref_p.valid(), &quot;sanity&quot;);
3366 
3367   // Given:
3368   //     lim0 == original pre loop limit
3369   //     V == v_align (power of 2)
3370   //     invar == extra invariant piece of the address expression
3371   //     e == offset [ +/- invar ]
3372   //
3373   // When reassociating expressions involving &#39;%&#39; the basic rules are:
3374   //     (a - b) % k == 0   =&gt;  a % k == b % k
3375   // and:
3376   //     (a + b) % k == 0   =&gt;  a % k == (k - b) % k
3377   //
3378   // For stride &gt; 0 &amp;&amp; scale &gt; 0,
3379   //   Derive the new pre-loop limit &quot;lim&quot; such that the two constraints:
3380   //     (1) lim = lim0 + N           (where N is some positive integer &lt; V)
3381   //     (2) (e + lim) % V == 0
3382   //   are true.
3383   //
3384   //   Substituting (1) into (2),
3385   //     (e + lim0 + N) % V == 0
3386   //   solve for N:
3387   //     N = (V - (e + lim0)) % V
3388   //   substitute back into (1), so that new limit
3389   //     lim = lim0 + (V - (e + lim0)) % V
3390   //
3391   // For stride &gt; 0 &amp;&amp; scale &lt; 0
3392   //   Constraints:
3393   //     lim = lim0 + N
3394   //     (e - lim) % V == 0
3395   //   Solving for lim:
3396   //     (e - lim0 - N) % V == 0
3397   //     N = (e - lim0) % V
3398   //     lim = lim0 + (e - lim0) % V
3399   //
3400   // For stride &lt; 0 &amp;&amp; scale &gt; 0
3401   //   Constraints:
3402   //     lim = lim0 - N
3403   //     (e + lim) % V == 0
3404   //   Solving for lim:
3405   //     (e + lim0 - N) % V == 0
3406   //     N = (e + lim0) % V
3407   //     lim = lim0 - (e + lim0) % V
3408   //
3409   // For stride &lt; 0 &amp;&amp; scale &lt; 0
3410   //   Constraints:
3411   //     lim = lim0 - N
3412   //     (e - lim) % V == 0
3413   //   Solving for lim:
3414   //     (e - lim0 + N) % V == 0
3415   //     N = (V - (e - lim0)) % V
3416   //     lim = lim0 - (V - (e - lim0)) % V
3417 
3418   int vw = vector_width_in_bytes(align_to_ref);
3419   int stride   = iv_stride();
3420   int scale    = align_to_ref_p.scale_in_bytes();
3421   int elt_size = align_to_ref_p.memory_size();
3422   int v_align  = vw / elt_size;
3423   assert(v_align &gt; 1, &quot;sanity&quot;);
3424   int offset   = align_to_ref_p.offset_in_bytes() / elt_size;
3425   Node *offsn  = _igvn.intcon(offset);
3426 
3427   Node *e = offsn;
3428   if (align_to_ref_p.invar() != NULL) {
3429     // incorporate any extra invariant piece producing (offset +/- invar) &gt;&gt;&gt; log2(elt)
3430     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3431     Node* invar = align_to_ref_p.invar();
3432     if (_igvn.type(invar)-&gt;isa_long()) {
3433       // Computations are done % (vector width/element size) so it&#39;s
3434       // safe to simply convert invar to an int and loose the upper 32
3435       // bit half.
3436       invar = new ConvL2INode(invar);
3437       _igvn.register_new_node_with_optimizer(invar);
3438     }
3439     Node* aref = new URShiftINode(invar, log2_elt);
3440     _igvn.register_new_node_with_optimizer(aref);
3441     _phase-&gt;set_ctrl(aref, pre_ctrl);
3442     if (align_to_ref_p.negate_invar()) {
3443       e = new SubINode(e, aref);
3444     } else {
3445       e = new AddINode(e, aref);
3446     }
3447     _igvn.register_new_node_with_optimizer(e);
3448     _phase-&gt;set_ctrl(e, pre_ctrl);
3449   }
3450   if (vw &gt; ObjectAlignmentInBytes || align_to_ref_p.base()-&gt;is_top()) {
3451     // incorporate base e +/- base &amp;&amp; Mask &gt;&gt;&gt; log2(elt)
3452     Node* xbase = new CastP2XNode(NULL, align_to_ref_p.adr());
3453     _igvn.register_new_node_with_optimizer(xbase);
3454 #ifdef _LP64
3455     xbase  = new ConvL2INode(xbase);
3456     _igvn.register_new_node_with_optimizer(xbase);
3457 #endif
3458     Node* mask = _igvn.intcon(vw-1);
3459     Node* masked_xbase  = new AndINode(xbase, mask);
3460     _igvn.register_new_node_with_optimizer(masked_xbase);
3461     Node* log2_elt = _igvn.intcon(exact_log2(elt_size));
3462     Node* bref     = new URShiftINode(masked_xbase, log2_elt);
3463     _igvn.register_new_node_with_optimizer(bref);
3464     _phase-&gt;set_ctrl(bref, pre_ctrl);
3465     e = new AddINode(e, bref);
3466     _igvn.register_new_node_with_optimizer(e);
3467     _phase-&gt;set_ctrl(e, pre_ctrl);
3468   }
3469 
3470   // compute e +/- lim0
3471   if (scale &lt; 0) {
3472     e = new SubINode(e, lim0);
3473   } else {
3474     e = new AddINode(e, lim0);
3475   }
3476   _igvn.register_new_node_with_optimizer(e);
3477   _phase-&gt;set_ctrl(e, pre_ctrl);
3478 
3479   if (stride * scale &gt; 0) {
3480     // compute V - (e +/- lim0)
3481     Node* va  = _igvn.intcon(v_align);
3482     e = new SubINode(va, e);
3483     _igvn.register_new_node_with_optimizer(e);
3484     _phase-&gt;set_ctrl(e, pre_ctrl);
3485   }
3486   // compute N = (exp) % V
3487   Node* va_msk = _igvn.intcon(v_align - 1);
3488   Node* N = new AndINode(e, va_msk);
3489   _igvn.register_new_node_with_optimizer(N);
3490   _phase-&gt;set_ctrl(N, pre_ctrl);
3491 
3492   //   substitute back into (1), so that new limit
3493   //     lim = lim0 + N
3494   Node* lim;
3495   if (stride &lt; 0) {
3496     lim = new SubINode(lim0, N);
3497   } else {
3498     lim = new AddINode(lim0, N);
3499   }
3500   _igvn.register_new_node_with_optimizer(lim);
3501   _phase-&gt;set_ctrl(lim, pre_ctrl);
3502   Node* constrained =
3503     (stride &gt; 0) ? (Node*) new MinINode(lim, orig_limit)
3504                  : (Node*) new MaxINode(lim, orig_limit);
3505   _igvn.register_new_node_with_optimizer(constrained);
3506   _phase-&gt;set_ctrl(constrained, pre_ctrl);
3507   _igvn.replace_input_of(pre_opaq, 1, constrained);
3508 }
3509 
3510 //----------------------------get_pre_loop_end---------------------------
3511 // Find pre loop end from main loop.  Returns null if none.
3512 CountedLoopEndNode* SuperWord::get_pre_loop_end(CountedLoopNode* cl) {
3513   // The loop cannot be optimized if the graph shape at
3514   // the loop entry is inappropriate.
3515   if (!PhaseIdealLoop::is_canonical_loop_entry(cl)) {
3516     return NULL;
3517   }
3518 
3519   Node* p_f = cl-&gt;skip_predicates()-&gt;in(0)-&gt;in(0);
3520   if (!p_f-&gt;is_IfFalse()) return NULL;
3521   if (!p_f-&gt;in(0)-&gt;is_CountedLoopEnd()) return NULL;
3522   CountedLoopEndNode* pre_end = p_f-&gt;in(0)-&gt;as_CountedLoopEnd();
3523   CountedLoopNode* loop_node = pre_end-&gt;loopnode();
3524   if (loop_node == NULL || !loop_node-&gt;is_pre_loop()) return NULL;
3525   return pre_end;
3526 }
3527 
3528 //------------------------------init---------------------------
3529 void SuperWord::init() {
3530   _dg.init();
3531   _packset.clear();
3532   _disjoint_ptrs.clear();
3533   _block.clear();
3534   _post_block.clear();
3535   _data_entry.clear();
3536   _mem_slice_head.clear();
3537   _mem_slice_tail.clear();
3538   _iteration_first.clear();
3539   _iteration_last.clear();
3540   _node_info.clear();
3541   _align_to_ref = NULL;
3542   _lpt = NULL;
3543   _lp = NULL;
3544   _bb = NULL;
3545   _iv = NULL;
3546   _race_possible = 0;
3547   _early_return = false;
3548   _num_work_vecs = 0;
3549   _num_reductions = 0;
3550 }
3551 
3552 //------------------------------restart---------------------------
3553 void SuperWord::restart() {
3554   _dg.init();
3555   _packset.clear();
3556   _disjoint_ptrs.clear();
3557   _block.clear();
3558   _post_block.clear();
3559   _data_entry.clear();
3560   _mem_slice_head.clear();
3561   _mem_slice_tail.clear();
3562   _node_info.clear();
3563 }
3564 
3565 //------------------------------print_packset---------------------------
3566 void SuperWord::print_packset() {
3567 #ifndef PRODUCT
3568   tty-&gt;print_cr(&quot;packset&quot;);
3569   for (int i = 0; i &lt; _packset.length(); i++) {
3570     tty-&gt;print_cr(&quot;Pack: %d&quot;, i);
3571     Node_List* p = _packset.at(i);
3572     print_pack(p);
3573   }
3574 #endif
3575 }
3576 
3577 //------------------------------print_pack---------------------------
3578 void SuperWord::print_pack(Node_List* p) {
3579   for (uint i = 0; i &lt; p-&gt;size(); i++) {
3580     print_stmt(p-&gt;at(i));
3581   }
3582 }
3583 
3584 //------------------------------print_bb---------------------------
3585 void SuperWord::print_bb() {
3586 #ifndef PRODUCT
3587   tty-&gt;print_cr(&quot;\nBlock&quot;);
3588   for (int i = 0; i &lt; _block.length(); i++) {
3589     Node* n = _block.at(i);
3590     tty-&gt;print(&quot;%d &quot;, i);
3591     if (n) {
3592       n-&gt;dump();
3593     }
3594   }
3595 #endif
3596 }
3597 
3598 //------------------------------print_stmt---------------------------
3599 void SuperWord::print_stmt(Node* s) {
3600 #ifndef PRODUCT
3601   tty-&gt;print(&quot; align: %d \t&quot;, alignment(s));
3602   s-&gt;dump();
3603 #endif
3604 }
3605 
3606 //------------------------------blank---------------------------
3607 char* SuperWord::blank(uint depth) {
3608   static char blanks[101];
3609   assert(depth &lt; 101, &quot;too deep&quot;);
3610   for (uint i = 0; i &lt; depth; i++) blanks[i] = &#39; &#39;;
3611   blanks[depth] = &#39;\0&#39;;
3612   return blanks;
3613 }
3614 
3615 
3616 //==============================SWPointer===========================
3617 #ifndef PRODUCT
3618 int SWPointer::Tracer::_depth = 0;
3619 #endif
3620 //----------------------------SWPointer------------------------
3621 SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :
3622   _mem(mem), _slp(slp),  _base(NULL),  _adr(NULL),
3623   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3624   _nstack(nstack), _analyze_only(analyze_only),
3625   _stack_idx(0)
3626 #ifndef PRODUCT
3627   , _tracer(slp)
3628 #endif
3629 {
3630   NOT_PRODUCT(_tracer.ctor_1(mem);)
3631 
3632   Node* adr = mem-&gt;in(MemNode::Address);
3633   if (!adr-&gt;is_AddP()) {
3634     assert(!valid(), &quot;too complex&quot;);
3635     return;
3636   }
3637   // Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)
3638   Node* base = adr-&gt;in(AddPNode::Base);
3639   // The base address should be loop invariant
3640   if (!invariant(base)) {
3641     assert(!valid(), &quot;base address is loop variant&quot;);
3642     return;
3643   }
3644   // unsafe references require misaligned vector access support
3645   if (base-&gt;is_top() &amp;&amp; !Matcher::misaligned_vectors_ok()) {
3646     assert(!valid(), &quot;unsafe access&quot;);
3647     return;
3648   }
3649 
3650   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.store_depth();)
3651   NOT_PRODUCT(_tracer.ctor_2(adr);)
3652 
3653   int i;
3654   for (i = 0; i &lt; 3; i++) {
3655     NOT_PRODUCT(_tracer.ctor_3(adr, i);)
3656 
3657     if (!scaled_iv_plus_offset(adr-&gt;in(AddPNode::Offset))) {
3658       assert(!valid(), &quot;too complex&quot;);
3659       return;
3660     }
3661     adr = adr-&gt;in(AddPNode::Address);
3662     NOT_PRODUCT(_tracer.ctor_4(adr, i);)
3663 
3664     if (base == adr || !adr-&gt;is_AddP()) {
3665       NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)
3666       break; // stop looking at addp&#39;s
3667     }
3668   }
3669   if (!invariant(adr)) {
3670     assert(!valid(), &quot;adr is loop variant&quot;);
3671     return;
3672   }
3673 
3674   if (!base-&gt;is_top() &amp;&amp; adr != base) {
3675     assert(!valid(), &quot;adr and base differ&quot;);
3676     return;
3677   }
3678 
3679   NOT_PRODUCT(if(_slp-&gt;is_trace_alignment()) _tracer.restore_depth();)
3680   NOT_PRODUCT(_tracer.ctor_6(mem);)
3681 
3682   _base = base;
3683   _adr  = adr;
3684   assert(valid(), &quot;Usable&quot;);
3685 }
3686 
3687 // Following is used to create a temporary object during
3688 // the pattern match of an address expression.
3689 SWPointer::SWPointer(SWPointer* p) :
3690   _mem(p-&gt;_mem), _slp(p-&gt;_slp),  _base(NULL),  _adr(NULL),
3691   _scale(0), _offset(0), _invar(NULL), _negate_invar(false),
3692   _nstack(p-&gt;_nstack), _analyze_only(p-&gt;_analyze_only),
3693   _stack_idx(p-&gt;_stack_idx)
3694   #ifndef PRODUCT
3695   , _tracer(p-&gt;_slp)
3696   #endif
3697 {}
3698 
3699 
3700 bool SWPointer::invariant(Node* n) {
3701   NOT_PRODUCT(Tracer::Depth dd;)
3702   Node *n_c = phase()-&gt;get_ctrl(n);
3703   NOT_PRODUCT(_tracer.invariant_1(n, n_c);)
3704   return !lpt()-&gt;is_member(phase()-&gt;get_loop(n_c));
3705 }
3706 //------------------------scaled_iv_plus_offset--------------------
3707 // Match: k*iv + offset
3708 // where: k is a constant that maybe zero, and
3709 //        offset is (k2 [+/- invariant]) where k2 maybe zero and invariant is optional
3710 bool SWPointer::scaled_iv_plus_offset(Node* n) {
3711   NOT_PRODUCT(Tracer::Depth ddd;)
3712   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)
3713 
3714   if (scaled_iv(n)) {
3715     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)
3716     return true;
3717   }
3718 
3719   if (offset_plus_k(n)) {
3720     NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)
3721     return true;
3722   }
3723 
3724   int opc = n-&gt;Opcode();
3725   if (opc == Op_AddI) {
3726     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2))) {
3727       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)
3728       return true;
3729     }
3730     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3731       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)
3732       return true;
3733     }
3734   } else if (opc == Op_SubI) {
3735     if (scaled_iv(n-&gt;in(1)) &amp;&amp; offset_plus_k(n-&gt;in(2), true)) {
3736       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)
3737       return true;
3738     }
3739     if (scaled_iv(n-&gt;in(2)) &amp;&amp; offset_plus_k(n-&gt;in(1))) {
3740       _scale *= -1;
3741       NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)
3742       return true;
3743     }
3744   }
3745 
3746   NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)
3747   return false;
3748 }
3749 
3750 //----------------------------scaled_iv------------------------
3751 // Match: k*iv where k is a constant that&#39;s not zero
3752 bool SWPointer::scaled_iv(Node* n) {
3753   NOT_PRODUCT(Tracer::Depth ddd;)
3754   NOT_PRODUCT(_tracer.scaled_iv_1(n);)
3755 
3756   if (_scale != 0) { // already found a scale
3757     NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)
3758     return false;
3759   }
3760 
3761   if (n == iv()) {
3762     _scale = 1;
3763     NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)
3764     return true;
3765   }
3766   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3767     _nstack-&gt;push(n, _stack_idx++);
3768   }
3769 
3770   int opc = n-&gt;Opcode();
3771   if (opc == Op_MulI) {
3772     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3773       _scale = n-&gt;in(2)-&gt;get_int();
3774       NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)
3775       return true;
3776     } else if (n-&gt;in(2) == iv() &amp;&amp; n-&gt;in(1)-&gt;is_Con()) {
3777       _scale = n-&gt;in(1)-&gt;get_int();
3778       NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)
3779       return true;
3780     }
3781   } else if (opc == Op_LShiftI) {
3782     if (n-&gt;in(1) == iv() &amp;&amp; n-&gt;in(2)-&gt;is_Con()) {
3783       _scale = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3784       NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)
3785       return true;
3786     }
3787   } else if (opc == Op_ConvI2L) {
3788     if (n-&gt;in(1)-&gt;Opcode() == Op_CastII &amp;&amp;
3789         n-&gt;in(1)-&gt;as_CastII()-&gt;has_range_check()) {
3790       // Skip range check dependent CastII nodes
3791       n = n-&gt;in(1);
3792     }
3793     if (scaled_iv_plus_offset(n-&gt;in(1))) {
3794       NOT_PRODUCT(_tracer.scaled_iv_7(n);)
3795       return true;
3796     }
3797   } else if (opc == Op_LShiftL) {
3798     if (!has_iv() &amp;&amp; _invar == NULL) {
3799       // Need to preserve the current _offset value, so
3800       // create a temporary object for this expression subtree.
3801       // Hacky, so should re-engineer the address pattern match.
3802       NOT_PRODUCT(Tracer::Depth dddd;)
3803       SWPointer tmp(this);
3804       NOT_PRODUCT(_tracer.scaled_iv_8(n, &amp;tmp);)
3805 
3806       if (tmp.scaled_iv_plus_offset(n-&gt;in(1))) {
3807         if (tmp._invar == NULL || _slp-&gt;do_vector_loop()) {
3808           int mult = 1 &lt;&lt; n-&gt;in(2)-&gt;get_int();
3809           _scale   = tmp._scale  * mult;
3810           _offset += tmp._offset * mult;
3811           NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, mult);)
3812           return true;
3813         }
3814       }
3815     }
3816   }
3817   NOT_PRODUCT(_tracer.scaled_iv_10(n);)
3818   return false;
3819 }
3820 
3821 //----------------------------offset_plus_k------------------------
3822 // Match: offset is (k [+/- invariant])
3823 // where k maybe zero and invariant is optional, but not both.
3824 bool SWPointer::offset_plus_k(Node* n, bool negate) {
3825   NOT_PRODUCT(Tracer::Depth ddd;)
3826   NOT_PRODUCT(_tracer.offset_plus_k_1(n);)
3827 
3828   int opc = n-&gt;Opcode();
3829   if (opc == Op_ConI) {
3830     _offset += negate ? -(n-&gt;get_int()) : n-&gt;get_int();
3831     NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)
3832     return true;
3833   } else if (opc == Op_ConL) {
3834     // Okay if value fits into an int
3835     const TypeLong* t = n-&gt;find_long_type();
3836     if (t-&gt;higher_equal(TypeLong::INT)) {
3837       jlong loff = n-&gt;get_long();
3838       jint  off  = (jint)loff;
3839       _offset += negate ? -off : loff;
3840       NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)
3841       return true;
3842     }
3843     NOT_PRODUCT(_tracer.offset_plus_k_4(n);)
3844     return false;
3845   }
3846   if (_invar != NULL) { // already has an invariant
3847     NOT_PRODUCT(_tracer.offset_plus_k_5(n, _invar);)
3848     return false;
3849   }
3850 
3851   if (_analyze_only &amp;&amp; (invariant(n) == false)) {
3852     _nstack-&gt;push(n, _stack_idx++);
3853   }
3854   if (opc == Op_AddI) {
3855     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3856       _negate_invar = negate;
3857       _invar = n-&gt;in(1);
3858       _offset += negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3859       NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, _negate_invar, _offset);)
3860       return true;
3861     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3862       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3863       _negate_invar = negate;
3864       _invar = n-&gt;in(2);
3865       NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, _negate_invar, _offset);)
3866       return true;
3867     }
3868   }
3869   if (opc == Op_SubI) {
3870     if (n-&gt;in(2)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(1))) {
3871       _negate_invar = negate;
3872       _invar = n-&gt;in(1);
3873       _offset += !negate ? -(n-&gt;in(2)-&gt;get_int()) : n-&gt;in(2)-&gt;get_int();
3874       NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, _negate_invar, _offset);)
3875       return true;
3876     } else if (n-&gt;in(1)-&gt;is_Con() &amp;&amp; invariant(n-&gt;in(2))) {
3877       _offset += negate ? -(n-&gt;in(1)-&gt;get_int()) : n-&gt;in(1)-&gt;get_int();
3878       _negate_invar = !negate;
3879       _invar = n-&gt;in(2);
3880       NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, _negate_invar, _offset);)
3881       return true;
3882     }
3883   }
3884   if (invariant(n)) {
3885     if (opc == Op_ConvI2L) {
3886       n = n-&gt;in(1);
3887       if (n-&gt;Opcode() == Op_CastII &amp;&amp;
3888           n-&gt;as_CastII()-&gt;has_range_check()) {
3889         // Skip range check dependent CastII nodes
3890         assert(invariant(n), &quot;sanity&quot;);
3891         n = n-&gt;in(1);
3892       }
3893     }
3894     _negate_invar = negate;
3895     _invar = n;
3896     NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, _negate_invar, _offset);)
3897     return true;
3898   }
3899 
3900   NOT_PRODUCT(_tracer.offset_plus_k_11(n);)
3901   return false;
3902 }
3903 
3904 //----------------------------print------------------------
3905 void SWPointer::print() {
3906 #ifndef PRODUCT
3907   tty-&gt;print(&quot;base: %d  adr: %d  scale: %d  offset: %d  invar: %c%d\n&quot;,
3908              _base != NULL ? _base-&gt;_idx : 0,
3909              _adr  != NULL ? _adr-&gt;_idx  : 0,
3910              _scale, _offset,
3911              _negate_invar?&#39;-&#39;:&#39;+&#39;,
3912              _invar != NULL ? _invar-&gt;_idx : 0);
3913 #endif
3914 }
3915 
3916 //----------------------------tracing------------------------
3917 #ifndef PRODUCT
3918 void SWPointer::Tracer::print_depth() {
3919   for (int ii = 0; ii&lt;_depth; ++ii) tty-&gt;print(&quot;  &quot;);
3920 }
3921 
3922 void SWPointer::Tracer::ctor_1 (Node* mem) {
3923   if(_slp-&gt;is_trace_alignment()) {
3924     print_depth(); tty-&gt;print(&quot; %d SWPointer::SWPointer: start alignment analysis&quot;, mem-&gt;_idx); mem-&gt;dump();
3925   }
3926 }
3927 
3928 void SWPointer::Tracer::ctor_2(Node* adr) {
3929   if(_slp-&gt;is_trace_alignment()) {
3930     //store_depth();
3931     inc_depth();
3932     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: &quot;, adr-&gt;_idx); adr-&gt;dump();
3933     inc_depth();
3934     print_depth(); tty-&gt;print(&quot; %d (base) SWPointer::SWPointer: &quot;, adr-&gt;in(AddPNode::Base)-&gt;_idx); adr-&gt;in(AddPNode::Base)-&gt;dump();
3935   }
3936 }
3937 
3938 void SWPointer::Tracer::ctor_3(Node* adr, int i) {
3939   if(_slp-&gt;is_trace_alignment()) {
3940     inc_depth();
3941     Node* offset = adr-&gt;in(AddPNode::Offset);
3942     print_depth(); tty-&gt;print(&quot; %d (offset) SWPointer::SWPointer: i = %d: &quot;, offset-&gt;_idx, i); offset-&gt;dump();
3943   }
3944 }
3945 
3946 void SWPointer::Tracer::ctor_4(Node* adr, int i) {
3947   if(_slp-&gt;is_trace_alignment()) {
3948     inc_depth();
3949     print_depth(); tty-&gt;print(&quot; %d (adr) SWPointer::SWPointer: i = %d: &quot;, adr-&gt;_idx, i); adr-&gt;dump();
3950   }
3951 }
3952 
3953 void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {
3954   if(_slp-&gt;is_trace_alignment()) {
3955     inc_depth();
3956     if (base == adr) {
3957       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, base-&gt;_idx, i);
3958     } else if (!adr-&gt;is_AddP()) {
3959       print_depth(); tty-&gt;print_cr(&quot;  \\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d&quot;, adr-&gt;_idx, i);
3960     }
3961   }
3962 }
3963 
3964 void SWPointer::Tracer::ctor_6(Node* mem) {
3965   if(_slp-&gt;is_trace_alignment()) {
3966     //restore_depth();
3967     print_depth(); tty-&gt;print_cr(&quot; %d (adr) SWPointer::SWPointer: stop analysis&quot;, mem-&gt;_idx);
3968   }
3969 }
3970 
3971 void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) {
3972   if (_slp-&gt;do_vector_loop() &amp;&amp; _slp-&gt;is_debug() &amp;&amp; _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c)) != (int)_slp-&gt;in_bb(n)) {
3973     int is_member =  _slp-&gt;_lpt-&gt;is_member(_slp-&gt;_phase-&gt;get_loop(n_c));
3974     int in_bb     =  _slp-&gt;in_bb(n);
3975     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot; %d SWPointer::invariant  conditions differ: n_c %d&quot;, n-&gt;_idx, n_c-&gt;_idx);
3976     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  tty-&gt;print_cr(&quot;is_member %d, in_bb %d&quot;, is_member, in_bb);
3977     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n-&gt;dump();
3978     print_depth(); tty-&gt;print(&quot;  \\ &quot;);  n_c-&gt;dump();
3979   }
3980 }
3981 
3982 void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {
3983   if(_slp-&gt;is_trace_alignment()) {
3984     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv_plus_offset testing node: &quot;, n-&gt;_idx);
3985     n-&gt;dump();
3986   }
3987 }
3988 
3989 void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {
3990   if(_slp-&gt;is_trace_alignment()) {
3991     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3992   }
3993 }
3994 
3995 void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {
3996   if(_slp-&gt;is_trace_alignment()) {
3997     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: PASSED&quot;, n-&gt;_idx);
3998   }
3999 }
4000 
4001 void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {
4002   if(_slp-&gt;is_trace_alignment()) {
4003     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4004     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4005     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4006   }
4007 }
4008 
4009 void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {
4010   if(_slp-&gt;is_trace_alignment()) {
4011     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED&quot;, n-&gt;_idx);
4012     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4013     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4014   }
4015 }
4016 
4017 void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {
4018   if(_slp-&gt;is_trace_alignment()) {
4019     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4020     print_depth(); tty-&gt;print(&quot;  \\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4021     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4022   }
4023 }
4024 
4025 void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {
4026   if(_slp-&gt;is_trace_alignment()) {
4027     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: Op_SubI PASSED&quot;, n-&gt;_idx);
4028     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4029     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4030   }
4031 }
4032 
4033 void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {
4034   if(_slp-&gt;is_trace_alignment()) {
4035     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv_plus_offset: FAILED&quot;, n-&gt;_idx);
4036   }
4037 }
4038 
4039 void SWPointer::Tracer::scaled_iv_1(Node* n) {
4040   if(_slp-&gt;is_trace_alignment()) {
4041     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4042   }
4043 }
4044 
4045 void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {
4046   if(_slp-&gt;is_trace_alignment()) {
4047     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED since another _scale has been detected before&quot;, n-&gt;_idx);
4048     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: _scale (%d) != 0&quot;, scale);
4049   }
4050 }
4051 
4052 void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {
4053   if(_slp-&gt;is_trace_alignment()) {
4054     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: is iv, setting _scale = %d&quot;, n-&gt;_idx, scale);
4055   }
4056 }
4057 
4058 void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {
4059   if(_slp-&gt;is_trace_alignment()) {
4060     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4061     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4062     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4063   }
4064 }
4065 
4066 void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {
4067   if(_slp-&gt;is_trace_alignment()) {
4068     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4069     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is iv: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4070     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4071   }
4072 }
4073 
4074 void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {
4075   if(_slp-&gt;is_trace_alignment()) {
4076     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d&quot;, n-&gt;_idx, scale);
4077     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(1) is iv: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4078     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::scaled_iv: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4079   }
4080 }
4081 
4082 void SWPointer::Tracer::scaled_iv_7(Node* n) {
4083   if(_slp-&gt;is_trace_alignment()) {
4084     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_ConvI2L PASSED&quot;, n-&gt;_idx);
4085     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: &quot;, n-&gt;in(1)-&gt;_idx);
4086     inc_depth(); inc_depth();
4087     print_depth(); n-&gt;in(1)-&gt;dump();
4088     dec_depth(); dec_depth();
4089   }
4090 }
4091 
4092 void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {
4093   if(_slp-&gt;is_trace_alignment()) {
4094     print_depth(); tty-&gt;print(&quot; %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: &quot;, n-&gt;_idx); tmp-&gt;print();
4095   }
4096 }
4097 
4098 void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int _offset, int mult) {
4099   if(_slp-&gt;is_trace_alignment()) {
4100     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d&quot;, n-&gt;_idx, scale, _offset);
4101     print_depth(); tty-&gt;print_cr(&quot;  \\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset, in(2) %d used to get mult = %d: _scale = %d, _offset = %d&quot;,
4102     n-&gt;in(1)-&gt;_idx, n-&gt;in(2)-&gt;_idx, mult, scale, _offset);
4103     inc_depth(); inc_depth();
4104     print_depth(); n-&gt;in(1)-&gt;dump();
4105     print_depth(); n-&gt;in(2)-&gt;dump();
4106     dec_depth(); dec_depth();
4107   }
4108 }
4109 
4110 void SWPointer::Tracer::scaled_iv_10(Node* n) {
4111   if(_slp-&gt;is_trace_alignment()) {
4112     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::scaled_iv: FAILED&quot;, n-&gt;_idx);
4113   }
4114 }
4115 
4116 void SWPointer::Tracer::offset_plus_k_1(Node* n) {
4117   if(_slp-&gt;is_trace_alignment()) {
4118     print_depth(); tty-&gt;print(&quot; %d SWPointer::offset_plus_k: testing node: &quot;, n-&gt;_idx); n-&gt;dump();
4119   }
4120 }
4121 
4122 void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {
4123   if(_slp-&gt;is_trace_alignment()) {
4124     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4125   }
4126 }
4127 
4128 void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {
4129   if(_slp-&gt;is_trace_alignment()) {
4130     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d&quot;, n-&gt;_idx, _offset);
4131   }
4132 }
4133 
4134 void SWPointer::Tracer::offset_plus_k_4(Node* n) {
4135   if(_slp-&gt;is_trace_alignment()) {
4136     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4137     print_depth(); tty-&gt;print_cr(&quot;  \\ &quot; JLONG_FORMAT &quot; SWPointer::offset_plus_k: Op_ConL FAILED, k is too big&quot;, n-&gt;get_long());
4138   }
4139 }
4140 
4141 void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {
4142   if(_slp-&gt;is_trace_alignment()) {
4143     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before&quot;, n-&gt;_idx);
4144     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: _invar != NULL: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4145   }
4146 }
4147 
4148 void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4149   if(_slp-&gt;is_trace_alignment()) {
4150     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4151     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4152     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4153     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4154   }
4155 }
4156 
4157 void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4158   if(_slp-&gt;is_trace_alignment()) {
4159     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4160     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4161     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4162     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4163   }
4164 }
4165 
4166 void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4167   if(_slp-&gt;is_trace_alignment()) {
4168     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;,
4169     n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4170     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is Con: &quot;, n-&gt;in(2)-&gt;_idx); n-&gt;in(2)-&gt;dump();
4171     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4172   }
4173 }
4174 
4175 void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4176   if(_slp-&gt;is_trace_alignment()) {
4177     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4178     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(1) is Con: &quot;, n-&gt;in(1)-&gt;_idx); n-&gt;in(1)-&gt;dump();
4179     print_depth(); tty-&gt;print(&quot;  \\ %d SWPointer::offset_plus_k: in(2) is invariant: &quot;, _invar-&gt;_idx); _invar-&gt;dump();
4180   }
4181 }
4182 
4183 void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {
4184   if(_slp-&gt;is_trace_alignment()) {
4185     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: PASSED, setting _negate_invar = %d, _invar = %d, _offset = %d&quot;, n-&gt;_idx, _negate_invar, _invar-&gt;_idx, _offset);
4186     print_depth(); tty-&gt;print_cr(&quot;  \\ %d SWPointer::offset_plus_k: is invariant&quot;, n-&gt;_idx);
4187   }
4188 }
4189 
4190 void SWPointer::Tracer::offset_plus_k_11(Node* n) {
4191   if(_slp-&gt;is_trace_alignment()) {
4192     print_depth(); tty-&gt;print_cr(&quot; %d SWPointer::offset_plus_k: FAILED&quot;, n-&gt;_idx);
4193   }
4194 }
4195 
4196 #endif
4197 // ========================= OrderedPair =====================
4198 
4199 const OrderedPair OrderedPair::initial;
4200 
4201 // ========================= SWNodeInfo =====================
4202 
4203 const SWNodeInfo SWNodeInfo::initial;
4204 
4205 
4206 // ============================ DepGraph ===========================
4207 
4208 //------------------------------make_node---------------------------
4209 // Make a new dependence graph node for an ideal node.
4210 DepMem* DepGraph::make_node(Node* node) {
4211   DepMem* m = new (_arena) DepMem(node);
4212   if (node != NULL) {
4213     assert(_map.at_grow(node-&gt;_idx) == NULL, &quot;one init only&quot;);
4214     _map.at_put_grow(node-&gt;_idx, m);
4215   }
4216   return m;
4217 }
4218 
4219 //------------------------------make_edge---------------------------
4220 // Make a new dependence graph edge from dpred -&gt; dsucc
4221 DepEdge* DepGraph::make_edge(DepMem* dpred, DepMem* dsucc) {
4222   DepEdge* e = new (_arena) DepEdge(dpred, dsucc, dsucc-&gt;in_head(), dpred-&gt;out_head());
4223   dpred-&gt;set_out_head(e);
4224   dsucc-&gt;set_in_head(e);
4225   return e;
4226 }
4227 
4228 // ========================== DepMem ========================
4229 
4230 //------------------------------in_cnt---------------------------
4231 int DepMem::in_cnt() {
4232   int ct = 0;
4233   for (DepEdge* e = _in_head; e != NULL; e = e-&gt;next_in()) ct++;
4234   return ct;
4235 }
4236 
4237 //------------------------------out_cnt---------------------------
4238 int DepMem::out_cnt() {
4239   int ct = 0;
4240   for (DepEdge* e = _out_head; e != NULL; e = e-&gt;next_out()) ct++;
4241   return ct;
4242 }
4243 
4244 //------------------------------print-----------------------------
4245 void DepMem::print() {
4246 #ifndef PRODUCT
4247   tty-&gt;print(&quot;  DepNode %d (&quot;, _node-&gt;_idx);
4248   for (DepEdge* p = _in_head; p != NULL; p = p-&gt;next_in()) {
4249     Node* pred = p-&gt;pred()-&gt;node();
4250     tty-&gt;print(&quot; %d&quot;, pred != NULL ? pred-&gt;_idx : 0);
4251   }
4252   tty-&gt;print(&quot;) [&quot;);
4253   for (DepEdge* s = _out_head; s != NULL; s = s-&gt;next_out()) {
4254     Node* succ = s-&gt;succ()-&gt;node();
4255     tty-&gt;print(&quot; %d&quot;, succ != NULL ? succ-&gt;_idx : 0);
4256   }
4257   tty-&gt;print_cr(&quot; ]&quot;);
4258 #endif
4259 }
4260 
4261 // =========================== DepEdge =========================
4262 
4263 //------------------------------DepPreds---------------------------
4264 void DepEdge::print() {
4265 #ifndef PRODUCT
4266   tty-&gt;print_cr(&quot;DepEdge: %d [ %d ]&quot;, _pred-&gt;node()-&gt;_idx, _succ-&gt;node()-&gt;_idx);
4267 #endif
4268 }
4269 
4270 // =========================== DepPreds =========================
4271 // Iterator over predecessor edges in the dependence graph.
4272 
4273 //------------------------------DepPreds---------------------------
4274 DepPreds::DepPreds(Node* n, DepGraph&amp; dg) {
4275   _n = n;
4276   _done = false;
4277   if (_n-&gt;is_Store() || _n-&gt;is_Load()) {
4278     _next_idx = MemNode::Address;
4279     _end_idx  = n-&gt;req();
4280     _dep_next = dg.dep(_n)-&gt;in_head();
4281   } else if (_n-&gt;is_Mem()) {
4282     _next_idx = 0;
4283     _end_idx  = 0;
4284     _dep_next = dg.dep(_n)-&gt;in_head();
4285   } else {
4286     _next_idx = 1;
4287     _end_idx  = _n-&gt;req();
4288     _dep_next = NULL;
4289   }
4290   next();
4291 }
4292 
4293 //------------------------------next---------------------------
4294 void DepPreds::next() {
4295   if (_dep_next != NULL) {
4296     _current  = _dep_next-&gt;pred()-&gt;node();
4297     _dep_next = _dep_next-&gt;next_in();
4298   } else if (_next_idx &lt; _end_idx) {
4299     _current  = _n-&gt;in(_next_idx++);
4300   } else {
4301     _done = true;
4302   }
4303 }
4304 
4305 // =========================== DepSuccs =========================
4306 // Iterator over successor edges in the dependence graph.
4307 
4308 //------------------------------DepSuccs---------------------------
4309 DepSuccs::DepSuccs(Node* n, DepGraph&amp; dg) {
4310   _n = n;
4311   _done = false;
4312   if (_n-&gt;is_Load()) {
4313     _next_idx = 0;
4314     _end_idx  = _n-&gt;outcnt();
4315     _dep_next = dg.dep(_n)-&gt;out_head();
4316   } else if (_n-&gt;is_Mem() || (_n-&gt;is_Phi() &amp;&amp; _n-&gt;bottom_type() == Type::MEMORY)) {
4317     _next_idx = 0;
4318     _end_idx  = 0;
4319     _dep_next = dg.dep(_n)-&gt;out_head();
4320   } else {
4321     _next_idx = 0;
4322     _end_idx  = _n-&gt;outcnt();
4323     _dep_next = NULL;
4324   }
4325   next();
4326 }
4327 
4328 //-------------------------------next---------------------------
4329 void DepSuccs::next() {
4330   if (_dep_next != NULL) {
4331     _current  = _dep_next-&gt;succ()-&gt;node();
4332     _dep_next = _dep_next-&gt;next_out();
4333   } else if (_next_idx &lt; _end_idx) {
4334     _current  = _n-&gt;raw_out(_next_idx++);
4335   } else {
4336     _done = true;
4337   }
4338 }
4339 
4340 //
4341 // --------------------------------- vectorization/simd -----------------------------------
4342 //
4343 bool SuperWord::same_origin_idx(Node* a, Node* b) const {
4344   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_idx(a-&gt;_idx, b-&gt;_idx);
4345 }
4346 bool SuperWord::same_generation(Node* a, Node* b) const {
4347   return a != NULL &amp;&amp; b != NULL &amp;&amp; _clone_map.same_gen(a-&gt;_idx, b-&gt;_idx);
4348 }
4349 
4350 Node*  SuperWord::find_phi_for_mem_dep(LoadNode* ld) {
4351   assert(in_bb(ld), &quot;must be in block&quot;);
4352   if (_clone_map.gen(ld-&gt;_idx) == _ii_first) {
4353 #ifndef PRODUCT
4354     if (_vector_loop_debug) {
4355       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(ld-&gt;_idx)=%d&quot;,
4356         _clone_map.gen(ld-&gt;_idx));
4357     }
4358 #endif
4359     return NULL; //we think that any ld in the first gen being vectorizable
4360   }
4361 
4362   Node* mem = ld-&gt;in(MemNode::Memory);
4363   if (mem-&gt;outcnt() &lt;= 1) {
4364     // we don&#39;t want to remove the only edge from mem node to load
4365 #ifndef PRODUCT
4366     if (_vector_loop_debug) {
4367       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep input node %d to load %d has no other outputs and edge mem-&gt;load cannot be removed&quot;,
4368         mem-&gt;_idx, ld-&gt;_idx);
4369       ld-&gt;dump();
4370       mem-&gt;dump();
4371     }
4372 #endif
4373     return NULL;
4374   }
4375   if (!in_bb(mem) || same_generation(mem, ld)) {
4376 #ifndef PRODUCT
4377     if (_vector_loop_debug) {
4378       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep _clone_map.gen(mem-&gt;_idx)=%d&quot;,
4379         _clone_map.gen(mem-&gt;_idx));
4380     }
4381 #endif
4382     return NULL; // does not depend on loop volatile node or depends on the same generation
4383   }
4384 
4385   //otherwise first node should depend on mem-phi
4386   Node* first = first_node(ld);
4387   assert(first-&gt;is_Load(), &quot;must be Load&quot;);
4388   Node* phi = first-&gt;as_Load()-&gt;in(MemNode::Memory);
4389   if (!phi-&gt;is_Phi() || phi-&gt;bottom_type() != Type::MEMORY) {
4390 #ifndef PRODUCT
4391     if (_vector_loop_debug) {
4392       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load is not vectorizable node, since it&#39;s `first` does not take input from mem phi&quot;);
4393       ld-&gt;dump();
4394       first-&gt;dump();
4395     }
4396 #endif
4397     return NULL;
4398   }
4399 
4400   Node* tail = 0;
4401   for (int m = 0; m &lt; _mem_slice_head.length(); m++) {
4402     if (_mem_slice_head.at(m) == phi) {
4403       tail = _mem_slice_tail.at(m);
4404     }
4405   }
4406   if (tail == 0) { //test that found phi is in the list  _mem_slice_head
4407 #ifndef PRODUCT
4408     if (_vector_loop_debug) {
4409       tty-&gt;print_cr(&quot;SuperWord::find_phi_for_mem_dep load %d is not vectorizable node, its phi %d is not _mem_slice_head&quot;,
4410         ld-&gt;_idx, phi-&gt;_idx);
4411       ld-&gt;dump();
4412       phi-&gt;dump();
4413     }
4414 #endif
4415     return NULL;
4416   }
4417 
4418   // now all conditions are met
4419   return phi;
4420 }
4421 
4422 Node* SuperWord::first_node(Node* nd) {
4423   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4424     Node* nnn = _iteration_first.at(ii);
4425     if (same_origin_idx(nnn, nd)) {
4426 #ifndef PRODUCT
4427       if (_vector_loop_debug) {
4428         tty-&gt;print_cr(&quot;SuperWord::first_node: %d is the first iteration node for %d (_clone_map.idx(nnn-&gt;_idx) = %d)&quot;,
4429           nnn-&gt;_idx, nd-&gt;_idx, _clone_map.idx(nnn-&gt;_idx));
4430       }
4431 #endif
4432       return nnn;
4433     }
4434   }
4435 
4436 #ifndef PRODUCT
4437   if (_vector_loop_debug) {
4438     tty-&gt;print_cr(&quot;SuperWord::first_node: did not find first iteration node for %d (_clone_map.idx(nd-&gt;_idx)=%d)&quot;,
4439       nd-&gt;_idx, _clone_map.idx(nd-&gt;_idx));
4440   }
4441 #endif
4442   return 0;
4443 }
4444 
4445 Node* SuperWord::last_node(Node* nd) {
4446   for (int ii = 0; ii &lt; _iteration_last.length(); ii++) {
4447     Node* nnn = _iteration_last.at(ii);
4448     if (same_origin_idx(nnn, nd)) {
4449 #ifndef PRODUCT
4450       if (_vector_loop_debug) {
4451         tty-&gt;print_cr(&quot;SuperWord::last_node _clone_map.idx(nnn-&gt;_idx)=%d, _clone_map.idx(nd-&gt;_idx)=%d&quot;,
4452           _clone_map.idx(nnn-&gt;_idx), _clone_map.idx(nd-&gt;_idx));
4453       }
4454 #endif
4455       return nnn;
4456     }
4457   }
4458   return 0;
4459 }
4460 
4461 int SuperWord::mark_generations() {
4462   Node *ii_err = NULL, *tail_err = NULL;
4463   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4464     Node* phi  = _mem_slice_head.at(i);
4465     assert(phi-&gt;is_Phi(), &quot;must be phi&quot;);
4466 
4467     Node* tail = _mem_slice_tail.at(i);
4468     if (_ii_last == -1) {
4469       tail_err = tail;
4470       _ii_last = _clone_map.gen(tail-&gt;_idx);
4471     }
4472     else if (_ii_last != _clone_map.gen(tail-&gt;_idx)) {
4473 #ifndef PRODUCT
4474       if (TraceSuperWord &amp;&amp; Verbose) {
4475         tty-&gt;print_cr(&quot;SuperWord::mark_generations _ii_last error - found different generations in two tail nodes &quot;);
4476         tail-&gt;dump();
4477         tail_err-&gt;dump();
4478       }
4479 #endif
4480       return -1;
4481     }
4482 
4483     // find first iteration in the loop
4484     for (DUIterator_Fast imax, i = phi-&gt;fast_outs(imax); i &lt; imax; i++) {
4485       Node* ii = phi-&gt;fast_out(i);
4486       if (in_bb(ii) &amp;&amp; ii-&gt;is_Store()) { // we speculate that normally Stores of one and one only generation have deps from mem phi
4487         if (_ii_first == -1) {
4488           ii_err = ii;
4489           _ii_first = _clone_map.gen(ii-&gt;_idx);
4490         } else if (_ii_first != _clone_map.gen(ii-&gt;_idx)) {
4491 #ifndef PRODUCT
4492           if (TraceSuperWord &amp;&amp; Verbose) {
4493             tty-&gt;print_cr(&quot;SuperWord::mark_generations: _ii_first was found before and not equal to one in this node (%d)&quot;, _ii_first);
4494             ii-&gt;dump();
4495             if (ii_err!= 0) {
4496               ii_err-&gt;dump();
4497             }
4498           }
4499 #endif
4500           return -1; // this phi has Stores from different generations of unroll and cannot be simd/vectorized
4501         }
4502       }
4503     }//for (DUIterator_Fast imax,
4504   }//for (int i...
4505 
4506   if (_ii_first == -1 || _ii_last == -1) {
4507     if (TraceSuperWord &amp;&amp; Verbose) {
4508       tty-&gt;print_cr(&quot;SuperWord::mark_generations unknown error, something vent wrong&quot;);
4509     }
4510     return -1; // something vent wrong
4511   }
4512   // collect nodes in the first and last generations
4513   assert(_iteration_first.length() == 0, &quot;_iteration_first must be empty&quot;);
4514   assert(_iteration_last.length() == 0, &quot;_iteration_last must be empty&quot;);
4515   for (int j = 0; j &lt; _block.length(); j++) {
4516     Node* n = _block.at(j);
4517     node_idx_t gen = _clone_map.gen(n-&gt;_idx);
4518     if ((signed)gen == _ii_first) {
4519       _iteration_first.push(n);
4520     } else if ((signed)gen == _ii_last) {
4521       _iteration_last.push(n);
4522     }
4523   }
4524 
4525   // building order of iterations
4526   if (_ii_order.length() == 0 &amp;&amp; ii_err != 0) {
4527     assert(in_bb(ii_err) &amp;&amp; ii_err-&gt;is_Store(), &quot;should be Store in bb&quot;);
4528     Node* nd = ii_err;
4529     while(_clone_map.gen(nd-&gt;_idx) != _ii_last) {
4530       _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4531       bool found = false;
4532       for (DUIterator_Fast imax, i = nd-&gt;fast_outs(imax); i &lt; imax; i++) {
4533         Node* use = nd-&gt;fast_out(i);
4534         if (same_origin_idx(use, nd) &amp;&amp; use-&gt;as_Store()-&gt;in(MemNode::Memory) == nd) {
4535           found = true;
4536           nd = use;
4537           break;
4538         }
4539       }//for
4540 
4541       if (found == false) {
4542         if (TraceSuperWord &amp;&amp; Verbose) {
4543           tty-&gt;print_cr(&quot;SuperWord::mark_generations: Cannot build order of iterations - no dependent Store for %d&quot;, nd-&gt;_idx);
4544         }
4545         _ii_order.clear();
4546         return -1;
4547       }
4548     } //while
4549     _ii_order.push(_clone_map.gen(nd-&gt;_idx));
4550   }
4551 
4552 #ifndef PRODUCT
4553   if (_vector_loop_debug) {
4554     tty-&gt;print_cr(&quot;SuperWord::mark_generations&quot;);
4555     tty-&gt;print_cr(&quot;First generation (%d) nodes:&quot;, _ii_first);
4556     for (int ii = 0; ii &lt; _iteration_first.length(); ii++)  _iteration_first.at(ii)-&gt;dump();
4557     tty-&gt;print_cr(&quot;Last generation (%d) nodes:&quot;, _ii_last);
4558     for (int ii = 0; ii &lt; _iteration_last.length(); ii++)  _iteration_last.at(ii)-&gt;dump();
4559     tty-&gt;print_cr(&quot; &quot;);
4560 
4561     tty-&gt;print(&quot;SuperWord::List of generations: &quot;);
4562     for (int jj = 0; jj &lt; _ii_order.length(); ++jj) {
4563       tty-&gt;print(&quot;%d:%d &quot;, jj, _ii_order.at(jj));
4564     }
4565     tty-&gt;print_cr(&quot; &quot;);
4566   }
4567 #endif
4568 
4569   return _ii_first;
4570 }
4571 
4572 bool SuperWord::fix_commutative_inputs(Node* gold, Node* fix) {
4573   assert(gold-&gt;is_Add() &amp;&amp; fix-&gt;is_Add() || gold-&gt;is_Mul() &amp;&amp; fix-&gt;is_Mul(), &quot;should be only Add or Mul nodes&quot;);
4574   assert(same_origin_idx(gold, fix), &quot;should be clones of the same node&quot;);
4575   Node* gin1 = gold-&gt;in(1);
4576   Node* gin2 = gold-&gt;in(2);
4577   Node* fin1 = fix-&gt;in(1);
4578   Node* fin2 = fix-&gt;in(2);
4579   bool swapped = false;
4580 
4581   if (in_bb(gin1) &amp;&amp; in_bb(gin2) &amp;&amp; in_bb(fin1) &amp;&amp; in_bb(fin1)) {
4582     if (same_origin_idx(gin1, fin1) &amp;&amp;
4583         same_origin_idx(gin2, fin2)) {
4584       return true; // nothing to fix
4585     }
4586     if (same_origin_idx(gin1, fin2) &amp;&amp;
4587         same_origin_idx(gin2, fin1)) {
4588       fix-&gt;swap_edges(1, 2);
4589       swapped = true;
4590     }
4591   }
4592   // at least one input comes from outside of bb
4593   if (gin1-&gt;_idx == fin1-&gt;_idx)  {
4594     return true; // nothing to fix
4595   }
4596   if (!swapped &amp;&amp; (gin1-&gt;_idx == fin2-&gt;_idx || gin2-&gt;_idx == fin1-&gt;_idx))  { //swapping is expensive, check condition first
4597     fix-&gt;swap_edges(1, 2);
4598     swapped = true;
4599   }
4600 
4601   if (swapped) {
4602 #ifndef PRODUCT
4603     if (_vector_loop_debug) {
4604       tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: fixed node %d&quot;, fix-&gt;_idx);
4605     }
4606 #endif
4607     return true;
4608   }
4609 
4610   if (TraceSuperWord &amp;&amp; Verbose) {
4611     tty-&gt;print_cr(&quot;SuperWord::fix_commutative_inputs: cannot fix node %d&quot;, fix-&gt;_idx);
4612   }
4613 
4614   return false;
4615 }
4616 
4617 bool SuperWord::pack_parallel() {
4618 #ifndef PRODUCT
4619   if (_vector_loop_debug) {
4620     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: START&quot;);
4621   }
4622 #endif
4623 
4624   _packset.clear();
4625 
4626   for (int ii = 0; ii &lt; _iteration_first.length(); ii++) {
4627     Node* nd = _iteration_first.at(ii);
4628     if (in_bb(nd) &amp;&amp; (nd-&gt;is_Load() || nd-&gt;is_Store() || nd-&gt;is_Add() || nd-&gt;is_Mul())) {
4629       Node_List* pk = new Node_List();
4630       pk-&gt;push(nd);
4631       for (int gen = 1; gen &lt; _ii_order.length(); ++gen) {
4632         for (int kk = 0; kk &lt; _block.length(); kk++) {
4633           Node* clone = _block.at(kk);
4634           if (same_origin_idx(clone, nd) &amp;&amp;
4635               _clone_map.gen(clone-&gt;_idx) == _ii_order.at(gen)) {
4636             if (nd-&gt;is_Add() || nd-&gt;is_Mul()) {
4637               fix_commutative_inputs(nd, clone);
4638             }
4639             pk-&gt;push(clone);
4640             if (pk-&gt;size() == 4) {
4641               _packset.append(pk);
4642 #ifndef PRODUCT
4643               if (_vector_loop_debug) {
4644                 tty-&gt;print_cr(&quot;SuperWord::pack_parallel: added pack &quot;);
4645                 pk-&gt;dump();
4646               }
4647 #endif
4648               if (_clone_map.gen(clone-&gt;_idx) != _ii_last) {
4649                 pk = new Node_List();
4650               }
4651             }
4652             break;
4653           }
4654         }
4655       }//for
4656     }//if
4657   }//for
4658 
4659 #ifndef PRODUCT
4660   if (_vector_loop_debug) {
4661     tty-&gt;print_cr(&quot;SuperWord::pack_parallel: END&quot;);
4662   }
4663 #endif
4664 
4665   return true;
4666 }
4667 
4668 bool SuperWord::hoist_loads_in_graph() {
4669   GrowableArray&lt;Node*&gt; loads;
4670 
4671 #ifndef PRODUCT
4672   if (_vector_loop_debug) {
4673     tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: total number _mem_slice_head.length() = %d&quot;, _mem_slice_head.length());
4674   }
4675 #endif
4676 
4677   for (int i = 0; i &lt; _mem_slice_head.length(); i++) {
4678     Node* n = _mem_slice_head.at(i);
4679     if ( !in_bb(n) || !n-&gt;is_Phi() || n-&gt;bottom_type() != Type::MEMORY) {
4680       if (TraceSuperWord &amp;&amp; Verbose) {
4681         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: skipping unexpected node n=%d&quot;, n-&gt;_idx);
4682       }
4683       continue;
4684     }
4685 
4686 #ifndef PRODUCT
4687     if (_vector_loop_debug) {
4688       tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: processing phi %d  = _mem_slice_head.at(%d);&quot;, n-&gt;_idx, i);
4689     }
4690 #endif
4691 
4692     for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
4693       Node* ld = n-&gt;fast_out(i);
4694       if (ld-&gt;is_Load() &amp;&amp; ld-&gt;as_Load()-&gt;in(MemNode::Memory) == n &amp;&amp; in_bb(ld)) {
4695         for (int i = 0; i &lt; _block.length(); i++) {
4696           Node* ld2 = _block.at(i);
4697           if (ld2-&gt;is_Load() &amp;&amp; same_origin_idx(ld, ld2) &amp;&amp;
4698               !same_generation(ld, ld2)) { // &lt;= do not collect the first generation ld
4699 #ifndef PRODUCT
4700             if (_vector_loop_debug) {
4701               tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph: will try to hoist load ld2-&gt;_idx=%d, cloned from %d (ld-&gt;_idx=%d)&quot;,
4702                 ld2-&gt;_idx, _clone_map.idx(ld-&gt;_idx), ld-&gt;_idx);
4703             }
4704 #endif
4705             // could not do on-the-fly, since iterator is immutable
4706             loads.push(ld2);
4707           }
4708         }// for
4709       }//if
4710     }//for (DUIterator_Fast imax,
4711   }//for (int i = 0; i
4712 
4713   for (int i = 0; i &lt; loads.length(); i++) {
4714     LoadNode* ld = loads.at(i)-&gt;as_Load();
4715     Node* phi = find_phi_for_mem_dep(ld);
4716     if (phi != NULL) {
4717 #ifndef PRODUCT
4718       if (_vector_loop_debug) {
4719         tty-&gt;print_cr(&quot;SuperWord::hoist_loads_in_graph replacing MemNode::Memory(%d) edge in %d with one from %d&quot;,
4720           MemNode::Memory, ld-&gt;_idx, phi-&gt;_idx);
4721       }
4722 #endif
4723       _igvn.replace_input_of(ld, MemNode::Memory, phi);
4724     }
4725   }//for
4726 
4727   restart(); // invalidate all basic structures, since we rebuilt the graph
4728 
4729   if (TraceSuperWord &amp;&amp; Verbose) {
4730     tty-&gt;print_cr(&quot;\nSuperWord::hoist_loads_in_graph() the graph was rebuilt, all structures invalidated and need rebuild&quot;);
4731   }
4732 
4733   return true;
4734 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
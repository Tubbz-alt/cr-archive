<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gcm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,13 ***</span>
<span class="line-new-header">--- 39,15 ---</span>
  #include &quot;opto/machnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="line-added">+ #include &quot;opto/subtypenode.hpp&quot;</span>
  #include &quot;runtime/deoptimization.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
<span class="line-added">+ #include &quot;utilities/powerOfTwo.hpp&quot;</span>
  
  //----------------------------GraphKit-----------------------------------------
  // Main utility constructor.
  GraphKit::GraphKit(JVMState* jvms)
    : Phase(Phase::Parser),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2620,50 ***</span>
  
    // Get the no-exception control from the CatchNode.
    set_control(norm);
  }
  
<span class="line-modified">! static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN* gvn, BasicType bt) {</span>
    Node* cmp = NULL;
    switch(bt) {
    case T_INT: cmp = new CmpINode(in1, in2); break;
    case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
    default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
    }
<span class="line-modified">!   gvn-&gt;transform(cmp);</span>
<span class="line-modified">!   Node* bol = gvn-&gt;transform(new BoolNode(cmp, test));</span>
    IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
<span class="line-modified">!   gvn-&gt;transform(iff);</span>
<span class="line-modified">!   if (!bol-&gt;is_Con()) gvn-&gt;record_for_igvn(iff);</span>
    return iff;
  }
  
  
  //-------------------------------gen_subtype_check-----------------------------
  // Generate a subtyping check.  Takes as input the subtype and supertype.
  // Returns 2 values: sets the default control() to the true path and returns
  // the false path.  Only reads invariant memory; sets no (visible) memory.
  // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
  // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
  // Object; if you wish to check an Object you need to load the Object&#39;s class
  // prior to coming here.
<span class="line-modified">! Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, MergeMemNode* mem, PhaseGVN* gvn) {</span>
<span class="line-modified">!   Compile* C = gvn-&gt;C;</span>
<span class="line-removed">- </span>
    if ((*ctrl)-&gt;is_top()) {
      return C-&gt;top();
    }
  
    // Fast check for identical types, perhaps identical constants.
    // The types can even be identical non-constants, in cases
    // involving Array.newInstance, Object.clone, etc.
    if (subklass == superklass)
      return C-&gt;top();             // false path is dead; no test needed.
  
<span class="line-modified">!   if (gvn-&gt;type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">!     ciKlass* superk = gvn-&gt;type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">!     ciKlass* subk   = gvn-&gt;type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
  
      // In the common case of an exact superklass, try to fold up the
      // test before generating code.  You may ask, why not just generate
      // the code and then let it fold up?  The answer is that the generated
      // code will necessarily include null checks, which do not always
<span class="line-new-header">--- 2622,122 ---</span>
  
    // Get the no-exception control from the CatchNode.
    set_control(norm);
  }
  
<span class="line-modified">! static IfNode* gen_subtype_check_compare(Node* ctrl, Node* in1, Node* in2, BoolTest::mask test, float p, PhaseGVN&amp; gvn, BasicType bt) {</span>
    Node* cmp = NULL;
    switch(bt) {
    case T_INT: cmp = new CmpINode(in1, in2); break;
    case T_ADDRESS: cmp = new CmpPNode(in1, in2); break;
    default: fatal(&quot;unexpected comparison type %s&quot;, type2name(bt));
    }
<span class="line-modified">!   gvn.transform(cmp);</span>
<span class="line-modified">!   Node* bol = gvn.transform(new BoolNode(cmp, test));</span>
    IfNode* iff = new IfNode(ctrl, bol, p, COUNT_UNKNOWN);
<span class="line-modified">!   gvn.transform(iff);</span>
<span class="line-modified">!   if (!bol-&gt;is_Con()) gvn.record_for_igvn(iff);</span>
    return iff;
  }
  
<span class="line-added">+ // Find the memory state for the secondary super type cache load when</span>
<span class="line-added">+ // a subtype check is expanded at macro expansion time. That field is</span>
<span class="line-added">+ // mutable so should not use immutable memory but</span>
<span class="line-added">+ // PartialSubtypeCheckNode that might modify it doesn&#39;t produce a new</span>
<span class="line-added">+ // memory state so bottom memory is the most accurate memory state to</span>
<span class="line-added">+ // hook the load with. This follows the implementation used when the</span>
<span class="line-added">+ // subtype check is expanded at parse time.</span>
<span class="line-added">+ static Node* find_bottom_mem(Node* ctrl, Compile* C) {</span>
<span class="line-added">+   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="line-added">+   Node_Stack stack(0);</span>
<span class="line-added">+   VectorSet seen(Thread::current()-&gt;resource_area());</span>
<span class="line-added">+ </span>
<span class="line-added">+   Node* c = ctrl;</span>
<span class="line-added">+   Node* mem = NULL;</span>
<span class="line-added">+   uint iter = 0;</span>
<span class="line-added">+   do {</span>
<span class="line-added">+     iter++;</span>
<span class="line-added">+     assert(iter &lt; C-&gt;live_nodes(), &quot;infinite loop&quot;);</span>
<span class="line-added">+     if (c-&gt;is_Region()) {</span>
<span class="line-added">+       for (DUIterator_Fast imax, i = c-&gt;fast_outs(imax); i &lt; imax &amp;&amp; mem == NULL; i++) {</span>
<span class="line-added">+         Node* u = c-&gt;fast_out(i);</span>
<span class="line-added">+         if (u-&gt;is_Phi() &amp;&amp; u-&gt;bottom_type() == Type::MEMORY &amp;&amp;</span>
<span class="line-added">+             (u-&gt;adr_type() == TypePtr::BOTTOM || u-&gt;adr_type() == adr_type)) {</span>
<span class="line-added">+           mem = u;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (mem == NULL) {</span>
<span class="line-added">+         if (!seen.test_set(c-&gt;_idx)) {</span>
<span class="line-added">+           stack.push(c, 2);</span>
<span class="line-added">+           c = c-&gt;in(1);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           Node* phi = NULL;</span>
<span class="line-added">+           uint idx = 0;</span>
<span class="line-added">+           for (;;) {</span>
<span class="line-added">+             phi = stack.node();</span>
<span class="line-added">+             idx = stack.index();</span>
<span class="line-added">+             if (idx &lt; phi-&gt;req()) {</span>
<span class="line-added">+               break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             stack.pop();</span>
<span class="line-added">+           }</span>
<span class="line-added">+           c = phi-&gt;in(idx);</span>
<span class="line-added">+           stack.set_index(idx+1);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (c-&gt;is_Proj() &amp;&amp; c-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added">+       for (DUIterator_Fast imax, i = c-&gt;in(0)-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">+         Node* u = c-&gt;in(0)-&gt;fast_out(i);</span>
<span class="line-added">+         if (u-&gt;bottom_type() == Type::MEMORY &amp;&amp; u-&gt;as_Proj()-&gt;_is_io_use == c-&gt;as_Proj()-&gt;_is_io_use) {</span>
<span class="line-added">+           assert(mem == NULL, &quot;&quot;);</span>
<span class="line-added">+           mem = u;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (c-&gt;is_CatchProj() &amp;&amp; c-&gt;in(0)-&gt;in(0)-&gt;in(0)-&gt;adr_type() == TypePtr::BOTTOM) {</span>
<span class="line-added">+       Node* call = c-&gt;in(0)-&gt;in(0)-&gt;in(0);</span>
<span class="line-added">+       assert(call-&gt;is_Call(), &quot;CatchProj with no call?&quot;);</span>
<span class="line-added">+       CallProjections projs;</span>
<span class="line-added">+       call-&gt;as_Call()-&gt;extract_projections(&amp;projs, false, false);</span>
<span class="line-added">+       if (projs.catchall_memproj == NULL) {</span>
<span class="line-added">+         mem = projs.fallthrough_memproj;</span>
<span class="line-added">+       } else if (c == projs.fallthrough_catchproj) {</span>
<span class="line-added">+         mem = projs.fallthrough_memproj;</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         assert(c == projs.catchall_catchproj, &quot;strange control&quot;);</span>
<span class="line-added">+         mem = projs.catchall_memproj;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(!c-&gt;is_Start(), &quot;should stop before start&quot;);</span>
<span class="line-added">+       c = c-&gt;in(0);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } while (mem == NULL);</span>
<span class="line-added">+   return mem;</span>
<span class="line-added">+ }</span>
  
  //-------------------------------gen_subtype_check-----------------------------
  // Generate a subtyping check.  Takes as input the subtype and supertype.
  // Returns 2 values: sets the default control() to the true path and returns
  // the false path.  Only reads invariant memory; sets no (visible) memory.
  // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
  // but that&#39;s not exposed to the optimizer.  This call also doesn&#39;t take in an
  // Object; if you wish to check an Object you need to load the Object&#39;s class
  // prior to coming here.
<span class="line-modified">! Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN&amp; gvn) {</span>
<span class="line-modified">!   Compile* C = gvn.C;</span>
    if ((*ctrl)-&gt;is_top()) {
      return C-&gt;top();
    }
  
    // Fast check for identical types, perhaps identical constants.
    // The types can even be identical non-constants, in cases
    // involving Array.newInstance, Object.clone, etc.
    if (subklass == superklass)
      return C-&gt;top();             // false path is dead; no test needed.
  
<span class="line-modified">!   if (gvn.type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">!     ciKlass* superk = gvn.type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">!     ciKlass* subk   = gvn.type(subklass)-&gt;is_klassptr()-&gt;klass();</span>
  
      // In the common case of an exact superklass, try to fold up the
      // test before generating code.  You may ask, why not just generate
      // the code and then let it fold up?  The answer is that the generated
      // code will necessarily include null checks, which do not always
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2674,21 ***</span>
      // of fa[1]=x will fold up, without testing the nullness of x.
      switch (C-&gt;static_subtype_check(superk, subk)) {
      case Compile::SSC_always_false:
        {
          Node* always_fail = *ctrl;
<span class="line-modified">!         *ctrl = gvn-&gt;C-&gt;top();</span>
          return always_fail;
        }
      case Compile::SSC_always_true:
        return C-&gt;top();
      case Compile::SSC_easy_test:
        {
          // Just do a direct pointer compare and be done.
          IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);
<span class="line-modified">!         *ctrl = gvn-&gt;transform(new IfTrueNode(iff));</span>
<span class="line-modified">!         return gvn-&gt;transform(new IfFalseNode(iff));</span>
        }
      case Compile::SSC_full_test:
        break;
      default:
        ShouldNotReachHere();
<span class="line-new-header">--- 2748,21 ---</span>
      // of fa[1]=x will fold up, without testing the nullness of x.
      switch (C-&gt;static_subtype_check(superk, subk)) {
      case Compile::SSC_always_false:
        {
          Node* always_fail = *ctrl;
<span class="line-modified">!         *ctrl = gvn.C-&gt;top();</span>
          return always_fail;
        }
      case Compile::SSC_always_true:
        return C-&gt;top();
      case Compile::SSC_easy_test:
        {
          // Just do a direct pointer compare and be done.
          IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);
<span class="line-modified">!         *ctrl = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-modified">!         return gvn.transform(new IfFalseNode(iff));</span>
        }
      case Compile::SSC_full_test:
        break;
      default:
        ShouldNotReachHere();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2698,44 ***</span>
    // %%% Possible further optimization:  Even if the superklass is not exact,
    // if the subklass is the unique subtype of the superklass, the check
    // will always succeed.  We could leave a dependency behind to ensure this.
  
    // First load the super-klass&#39;s check-offset
<span class="line-modified">!   Node *p1 = gvn-&gt;transform(new AddPNode(superklass, superklass, gvn-&gt;MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="line-modified">!   Node* m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p1)-&gt;is_ptr()));</span>
<span class="line-modified">!   Node *chk_off = gvn-&gt;transform(new LoadINode(NULL, m, p1, gvn-&gt;type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
    int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
<span class="line-modified">!   bool might_be_cache = (gvn-&gt;find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
  
    // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
    // the secondary superclass list, or a failing value with a sentinel offset
    // if the super-klass is an interface or exceptionally deep in the Java
    // hierarchy and we have to scan the secondary superclass list the hard way.
    // Worst-case type is a little odd: NULL is allowed as a result (usually
    // klass loads can never produce a NULL).
    Node *chk_off_X = chk_off;
  #ifdef _LP64
<span class="line-modified">!   chk_off_X = gvn-&gt;transform(new ConvI2LNode(chk_off_X));</span>
  #endif
<span class="line-modified">!   Node *p2 = gvn-&gt;transform(new AddPNode(subklass,subklass,chk_off_X));</span>
    // For some types like interfaces the following loadKlass is from a 1-word
    // cache which is mutable so can&#39;t use immutable memory.  Other
    // types load from the super-class display table which is immutable.
<span class="line-modified">!   m = mem-&gt;memory_at(C-&gt;get_alias_index(gvn-&gt;type(p2)-&gt;is_ptr()));</span>
<span class="line-modified">!   Node *kmem = might_be_cache ? m : C-&gt;immutable_memory();</span>
<span class="line-modified">!   Node *nkls = gvn-&gt;transform(LoadKlassNode::make(*gvn, NULL, kmem, p2, gvn-&gt;type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>
  
    // Compile speed common case: ARE a subtype and we canNOT fail
    if( superklass == nkls )
      return C-&gt;top();             // false path is dead; no test needed.
  
    // See if we get an immediate positive hit.  Happens roughly 83% of the
    // time.  Test to see if the value loaded just previously from the subklass
    // is exactly the superklass.
    IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
<span class="line-modified">!   Node *iftrue1 = gvn-&gt;transform( new IfTrueNode (iff1));</span>
<span class="line-modified">!   *ctrl = gvn-&gt;transform(new IfFalseNode(iff1));</span>
  
    // Compile speed common case: Check for being deterministic right now.  If
    // chk_off is a constant and not equal to cacheoff then we are NOT a
    // subklass.  In this case we need exactly the 1 test above and we can
    // return those results immediately.
<span class="line-new-header">--- 2772,51 ---</span>
    // %%% Possible further optimization:  Even if the superklass is not exact,
    // if the subklass is the unique subtype of the superklass, the check
    // will always succeed.  We could leave a dependency behind to ensure this.
  
    // First load the super-klass&#39;s check-offset
<span class="line-modified">!   Node *p1 = gvn.transform(new AddPNode(superklass, superklass, gvn.MakeConX(in_bytes(Klass::super_check_offset_offset()))));</span>
<span class="line-modified">!   Node* m = C-&gt;immutable_memory();</span>
<span class="line-modified">!   Node *chk_off = gvn.transform(new LoadINode(NULL, m, p1, gvn.type(p1)-&gt;is_ptr(), TypeInt::INT, MemNode::unordered));</span>
    int cacheoff_con = in_bytes(Klass::secondary_super_cache_offset());
<span class="line-modified">!   bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);</span>
  
    // Load from the sub-klass&#39;s super-class display list, or a 1-word cache of
    // the secondary superclass list, or a failing value with a sentinel offset
    // if the super-klass is an interface or exceptionally deep in the Java
    // hierarchy and we have to scan the secondary superclass list the hard way.
    // Worst-case type is a little odd: NULL is allowed as a result (usually
    // klass loads can never produce a NULL).
    Node *chk_off_X = chk_off;
  #ifdef _LP64
<span class="line-modified">!   chk_off_X = gvn.transform(new ConvI2LNode(chk_off_X));</span>
  #endif
<span class="line-modified">!   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));</span>
    // For some types like interfaces the following loadKlass is from a 1-word
    // cache which is mutable so can&#39;t use immutable memory.  Other
    // types load from the super-class display table which is immutable.
<span class="line-modified">!   Node *kmem = C-&gt;immutable_memory();</span>
<span class="line-modified">!   if (might_be_cache) {</span>
<span class="line-modified">!     assert((C-&gt;get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot)) ==</span>
<span class="line-added">+             C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())), &quot;&quot;);</span>
<span class="line-added">+     if (mem == NULL) {</span>
<span class="line-added">+       mem = find_bottom_mem(*ctrl, C);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     kmem = mem-&gt;is_MergeMem() ? mem-&gt;as_MergeMem()-&gt;memory_at(C-&gt;get_alias_index(gvn.type(p2)-&gt;is_ptr())) : mem;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)-&gt;is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));</span>
  
    // Compile speed common case: ARE a subtype and we canNOT fail
    if( superklass == nkls )
      return C-&gt;top();             // false path is dead; no test needed.
  
    // See if we get an immediate positive hit.  Happens roughly 83% of the
    // time.  Test to see if the value loaded just previously from the subklass
    // is exactly the superklass.
    IfNode *iff1 = gen_subtype_check_compare(*ctrl, superklass, nkls, BoolTest::eq, PROB_LIKELY(0.83f), gvn, T_ADDRESS);
<span class="line-modified">!   Node *iftrue1 = gvn.transform( new IfTrueNode (iff1));</span>
<span class="line-modified">!   *ctrl = gvn.transform(new IfFalseNode(iff1));</span>
  
    // Compile speed common case: Check for being deterministic right now.  If
    // chk_off is a constant and not equal to cacheoff then we are NOT a
    // subklass.  In this case we need exactly the 1 test above and we can
    // return those results immediately.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2745,32 ***</span>
      return not_subtype_ctrl;
    }
  
    // Gather the various success &amp; failures here
    RegionNode *r_ok_subtype = new RegionNode(4);
<span class="line-modified">!   gvn-&gt;record_for_igvn(r_ok_subtype);</span>
    RegionNode *r_not_subtype = new RegionNode(3);
<span class="line-modified">!   gvn-&gt;record_for_igvn(r_not_subtype);</span>
  
    r_ok_subtype-&gt;init_req(1, iftrue1);
  
    // Check for immediate negative hit.  Happens roughly 11% of the time (which
    // is roughly 63% of the remaining cases).  Test to see if the loaded
    // check-offset points into the subklass display list or the 1-element
    // cache.  If it points to the display (and NOT the cache) and the display
    // missed then it&#39;s not a subtype.
<span class="line-modified">!   Node *cacheoff = gvn-&gt;intcon(cacheoff_con);</span>
    IfNode *iff2 = gen_subtype_check_compare(*ctrl, chk_off, cacheoff, BoolTest::ne, PROB_LIKELY(0.63f), gvn, T_INT);
<span class="line-modified">!   r_not_subtype-&gt;init_req(1, gvn-&gt;transform(new IfTrueNode (iff2)));</span>
<span class="line-modified">!   *ctrl = gvn-&gt;transform(new IfFalseNode(iff2));</span>
  
    // Check for self.  Very rare to get here, but it is taken 1/3 the time.
    // No performance impact (too rare) but allows sharing of secondary arrays
    // which has some footprint reduction.
    IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);
<span class="line-modified">!   r_ok_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode(iff3)));</span>
<span class="line-modified">!   *ctrl = gvn-&gt;transform(new IfFalseNode(iff3));</span>
  
    // -- Roads not taken here: --
    // We could also have chosen to perform the self-check at the beginning
    // of this code sequence, as the assembler does.  This would not pay off
    // the same way, since the optimizer, unlike the assembler, can perform
<span class="line-new-header">--- 2826,32 ---</span>
      return not_subtype_ctrl;
    }
  
    // Gather the various success &amp; failures here
    RegionNode *r_ok_subtype = new RegionNode(4);
<span class="line-modified">!   gvn.record_for_igvn(r_ok_subtype);</span>
    RegionNode *r_not_subtype = new RegionNode(3);
<span class="line-modified">!   gvn.record_for_igvn(r_not_subtype);</span>
  
    r_ok_subtype-&gt;init_req(1, iftrue1);
  
    // Check for immediate negative hit.  Happens roughly 11% of the time (which
    // is roughly 63% of the remaining cases).  Test to see if the loaded
    // check-offset points into the subklass display list or the 1-element
    // cache.  If it points to the display (and NOT the cache) and the display
    // missed then it&#39;s not a subtype.
<span class="line-modified">!   Node *cacheoff = gvn.intcon(cacheoff_con);</span>
    IfNode *iff2 = gen_subtype_check_compare(*ctrl, chk_off, cacheoff, BoolTest::ne, PROB_LIKELY(0.63f), gvn, T_INT);
<span class="line-modified">!   r_not_subtype-&gt;init_req(1, gvn.transform(new IfTrueNode (iff2)));</span>
<span class="line-modified">!   *ctrl = gvn.transform(new IfFalseNode(iff2));</span>
  
    // Check for self.  Very rare to get here, but it is taken 1/3 the time.
    // No performance impact (too rare) but allows sharing of secondary arrays
    // which has some footprint reduction.
    IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);
<span class="line-modified">!   r_ok_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode(iff3)));</span>
<span class="line-modified">!   *ctrl = gvn.transform(new IfFalseNode(iff3));</span>
  
    // -- Roads not taken here: --
    // We could also have chosen to perform the self-check at the beginning
    // of this code sequence, as the assembler does.  This would not pay off
    // the same way, since the optimizer, unlike the assembler, can perform
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2789,20 ***</span>
    // performance impact (too rare) but it&#39;s gotta be done.
    // Since the code is rarely used, there is no penalty for moving it
    // out of line, and it can only improve I-cache density.
    // The decision to inline or out-of-line this final check is platform
    // dependent, and is found in the AD file definition of PartialSubtypeCheck.
<span class="line-modified">!   Node* psc = gvn-&gt;transform(</span>
      new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
  
<span class="line-modified">!   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn-&gt;zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="line-modified">!   r_not_subtype-&gt;init_req(2, gvn-&gt;transform(new IfTrueNode (iff4)));</span>
<span class="line-modified">!   r_ok_subtype -&gt;init_req(3, gvn-&gt;transform(new IfFalseNode(iff4)));</span>
  
    // Return false path; set default control to true path.
<span class="line-modified">!   *ctrl = gvn-&gt;transform(r_ok_subtype);</span>
<span class="line-modified">!   return gvn-&gt;transform(r_not_subtype);</span>
  }
  
  // Profile-driven exact type check:
  Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
                                      float prob,
<span class="line-new-header">--- 2870,42 ---</span>
    // performance impact (too rare) but it&#39;s gotta be done.
    // Since the code is rarely used, there is no penalty for moving it
    // out of line, and it can only improve I-cache density.
    // The decision to inline or out-of-line this final check is platform
    // dependent, and is found in the AD file definition of PartialSubtypeCheck.
<span class="line-modified">!   Node* psc = gvn.transform(</span>
      new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
  
<span class="line-modified">!   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn.zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);</span>
<span class="line-modified">!   r_not_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode (iff4)));</span>
<span class="line-modified">!   r_ok_subtype -&gt;init_req(3, gvn.transform(new IfFalseNode(iff4)));</span>
  
    // Return false path; set default control to true path.
<span class="line-modified">!   *ctrl = gvn.transform(r_ok_subtype);</span>
<span class="line-modified">!   return gvn.transform(r_not_subtype);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ Node* GraphKit::gen_subtype_check(Node* obj_or_subklass, Node* superklass) {</span>
<span class="line-added">+   if (ExpandSubTypeCheckAtParseTime) {</span>
<span class="line-added">+     MergeMemNode* mem = merged_memory();</span>
<span class="line-added">+     Node* ctrl = control();</span>
<span class="line-added">+     Node* subklass = obj_or_subklass;</span>
<span class="line-added">+     if (!_gvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
<span class="line-added">+       subklass = load_object_klass(obj_or_subklass);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, _gvn);</span>
<span class="line-added">+     set_control(ctrl);</span>
<span class="line-added">+     return n;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
<span class="line-added">+   Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));</span>
<span class="line-added">+   Node* bol = _gvn.transform(new BoolNode(check, BoolTest::eq));</span>
<span class="line-added">+   IfNode* iff = create_and_xform_if(control(), bol, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);</span>
<span class="line-added">+   set_control(_gvn.transform(new IfTrueNode(iff)));</span>
<span class="line-added">+   return _gvn.transform(new IfFalseNode(iff));</span>
  }
  
  // Profile-driven exact type check:
  Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
                                      float prob,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2830,14 ***</span>
  
  //------------------------------subtype_check_receiver-------------------------
  Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
                                         Node** casted_receiver) {
    const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
<span class="line-removed">-   Node* recv_klass = load_object_klass(receiver);</span>
    Node* want_klass = makecon(tklass);
  
<span class="line-modified">!   Node* slow_ctl = gen_subtype_check(recv_klass, want_klass);</span>
  
    // Cast receiver after successful check
    const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
    Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
    (*casted_receiver) = _gvn.transform(cast);
<span class="line-new-header">--- 2933,13 ---</span>
  
  //------------------------------subtype_check_receiver-------------------------
  Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
                                         Node** casted_receiver) {
    const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
    Node* want_klass = makecon(tklass);
  
<span class="line-modified">!   Node* slow_ctl = gen_subtype_check(receiver, want_klass);</span>
  
    // Cast receiver after successful check
    const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
    Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
    (*casted_receiver) = _gvn.transform(cast);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3098,15 ***</span>
          not_null_obj = cast_obj;
        }
      }
    }
  
<span class="line-removed">-   // Load the object&#39;s klass</span>
<span class="line-removed">-   Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="line-removed">- </span>
    // Generate the subtype check
<span class="line-modified">!   Node* not_subtype_ctrl = gen_subtype_check(obj_klass, superklass);</span>
  
    // Plug in the success path to the general merge in slot 1.
    region-&gt;init_req(_obj_path, control());
    phi   -&gt;init_req(_obj_path, intcon(1));
  
<span class="line-new-header">--- 3200,12 ---</span>
          not_null_obj = cast_obj;
        }
      }
    }
  
    // Generate the subtype check
<span class="line-modified">!   Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);</span>
  
    // Plug in the success path to the general merge in slot 1.
    region-&gt;init_req(_obj_path, control());
    phi   -&gt;init_req(_obj_path, intcon(1));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3225,24 ***</span>
        }
      }
    }
  
    if (cast_obj == NULL) {
<span class="line-removed">-     // Load the object&#39;s klass</span>
<span class="line-removed">-     Node* obj_klass = load_object_klass(not_null_obj);</span>
<span class="line-removed">- </span>
      // Generate the subtype check
<span class="line-modified">!     Node* not_subtype_ctrl = gen_subtype_check( obj_klass, superklass );</span>
  
      // Plug in success path into the merge
      cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));
      // Failure path ends in uncommon trap (or may be dead - failure impossible)
      if (failure_control == NULL) {
        if (not_subtype_ctrl != top()) { // If failure is possible
          PreserveJVMState pjvms(this);
          set_control(not_subtype_ctrl);
<span class="line-modified">!         builtin_throw(Deoptimization::Reason_class_check, obj_klass);</span>
        }
      } else {
        (*failure_control) = not_subtype_ctrl;
      }
    }
<span class="line-new-header">--- 3324,21 ---</span>
        }
      }
    }
  
    if (cast_obj == NULL) {
      // Generate the subtype check
<span class="line-modified">!     Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );</span>
  
      // Plug in success path into the merge
      cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));
      // Failure path ends in uncommon trap (or may be dead - failure impossible)
      if (failure_control == NULL) {
        if (not_subtype_ctrl != top()) { // If failure is possible
          PreserveJVMState pjvms(this);
          set_control(not_subtype_ctrl);
<span class="line-modified">!         builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));</span>
        }
      } else {
        (*failure_control) = not_subtype_ctrl;
      }
    }
</pre>
<center><a href="gcm.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>